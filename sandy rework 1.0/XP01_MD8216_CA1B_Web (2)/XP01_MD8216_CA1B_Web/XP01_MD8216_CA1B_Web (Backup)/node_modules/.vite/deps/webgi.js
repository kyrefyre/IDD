// node_modules/webgi/dist/examples/runtime/bundle.m.js
var __webpackgi_modules__ = { 109: function(e, t, n) {
  var r = n(352), i = n.n(r)()(function(e2) {
    return e2[1];
  });
  i.push([e.id, '.tippy-box[data-animation=fade][data-state=hidden]{opacity:0}[data-tippy-root]{max-width:calc(100vw - 10px)}.tippy-box{position:relative;background-color:#333;color:#fff;border-radius:4px;font-size:14px;line-height:1.4;white-space:normal;outline:0;transition-property:transform,visibility,opacity}.tippy-box[data-placement^=top]>.tippy-arrow{bottom:0}.tippy-box[data-placement^=top]>.tippy-arrow:before{bottom:-7px;left:0;border-width:8px 8px 0;border-top-color:initial;transform-origin:center top}.tippy-box[data-placement^=bottom]>.tippy-arrow{top:0}.tippy-box[data-placement^=bottom]>.tippy-arrow:before{top:-7px;left:0;border-width:0 8px 8px;border-bottom-color:initial;transform-origin:center bottom}.tippy-box[data-placement^=left]>.tippy-arrow{right:0}.tippy-box[data-placement^=left]>.tippy-arrow:before{border-width:8px 0 8px 8px;border-left-color:initial;right:-7px;transform-origin:center left}.tippy-box[data-placement^=right]>.tippy-arrow{left:0}.tippy-box[data-placement^=right]>.tippy-arrow:before{left:-7px;border-width:8px 8px 8px 0;border-right-color:initial;transform-origin:center right}.tippy-box[data-inertia][data-state=visible]{transition-timing-function:cubic-bezier(0.54, 1.5, 0.38, 1.11)}.tippy-arrow{width:16px;height:16px;color:#333}.tippy-arrow:before{content:"";position:absolute;border-color:rgba(0,0,0,0);border-style:solid}.tippy-content{position:relative;padding:5px 9px;z-index:1}', ""]), t.Z = i;
}, 356: function(e, t, n) {
  var r = n(352), i = n.n(r)()(function(e2) {
    return e2[1];
  });
  i.push([e.id, ".loader{width:48px;height:48px;border:5px solid #333;border-bottom-color:rgba(0,0,0,0);border-radius:50%;display:inline-block;box-sizing:border-box;animation:rotation 1s linear infinite}@keyframes rotation{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}", ""]), t.Z = i;
}, 44: function(e, t, n) {
  var r = n(352), i = n.n(r)()(function(e2) {
    return e2[1];
  });
  i.push([e.id, "#assetManagerLoadingBar{z-index:400;position:absolute;top:0;left:0;right:0;width:100%;background-color:rgba(0,0,0,0);height:auto}#assetManagerLoadingBarContent{color:#fff;position:absolute;left:0;right:0;margin:auto;transition:width .5s;background-color:rgba(34,34,34,.6666666667);text-align:center;font-size:.5rem;line-height:.6rem;height:.6rem;border-radius:0 0 .125rem .125rem;border-bottom:#999 1px solid}.processState{font-weight:bold}", ""]), t.Z = i;
}, 27: function(e, t, n) {
  var r = n(352), i = n.n(r)()(function(e2) {
    return e2[1];
  });
  i.push([e.id, '#assetManagerLoadingScreen{z-index:300;position:absolute;bottom:0;right:0;min-width:100%;min-height:100%;color:#333;font-size:1rem;gap:1rem;display:flex;align-content:center;justify-content:center;align-items:center;flex-direction:column;opacity:1;transition:opacity .5s ease-in-out,min-width .5s,min-height .5s,bottom .5s,right .5s;overflow:hidden;background:rgba(0,0,0,0);-webkit-backdrop-filter:blur(16px);backdrop-filter:blur(16px);background-blend-mode:luminosity;--b-opacity: 0.8;--b-background: #ffffff}#assetManagerLoadingScreen::before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;z-index:-1;opacity:var(--b-opacity);background:var(--b-background)}#assetManagerLoadingScreenContent{padding-top:.5rem}.loadingScreenProcessState{font-weight:bold}#assetManagerLoadingScreen.minimizedLoadingScreen{top:unset;left:unset;bottom:2rem;right:2rem;min-width:0;min-height:0;max-width:80vw;max-height:80vh;width:-moz-max-content;width:max-content;height:-moz-max-content;height:max-content;padding:1.5rem;border-radius:.5rem}.loadingScreenFilesElement{min-height:4rem;padding:1rem}.loadingScreenLogoElement{margin-bottom:.5rem;max-width:80%}.loadingScreenLogoElement img{min-height:3rem;max-height:5rem;max-width:100%;-o-object-fit:contain;object-fit:contain}.loadingScreenLogoImage{width:-moz-max-content;width:max-content;height:-moz-max-content;height:max-content}.minimizedLoadingScreen .loadingScreenLoadingElement{display:none}.minimizedLoadingScreen .loadingScreenFilesElement{min-height:0}.minimizedLoadingScreen .loadingScreenLogoElement{min-height:0;display:none}.minimizedLoadingScreen #assetManagerLoadingScreenContent{display:none}', ""]), t.Z = i;
}, 798: function(e, t, n) {
  var r = n(352), i = n.n(r)()(function(e2) {
    return e2[1];
  });
  i.push([e.id, "#assetManagerPopup{z-index:300;position:absolute;bottom:2rem;right:2rem;color:#fff;-webkit-backdrop-filter:blur(16px);backdrop-filter:blur(16px);background-blend-mode:luminosity;background-color:rgba(40,34,60,.6666666667);padding:1.5rem;font-size:1rem;width:-moz-max-content;width:max-content;max-width:80vw;max-height:80vh;overflow-y:scroll;border-radius:.5rem;height:-moz-max-content;height:max-content}#assetManagerPopupClose{position:absolute;top:0;right:0;padding:.5rem;cursor:pointer}#assetManagerPopupContent{padding-top:.5rem}.processState{font-weight:bold}", ""]), t.Z = i;
}, 729: function(e, t, n) {
  var r = n(352), i = n.n(r)()(function(e2) {
    return e2[1];
  });
  i.push([e.id, '.button-bar{background:var(--tp-base-background-color);width:fit-content;width:-moz-fit-content;height:auto;display:flex;flex-direction:row;justify-content:center;flex-wrap:wrap;z-index:200;padding:.25rem .5rem .5rem;border-radius:.5rem;pointer-events:auto;box-shadow:0 2px 4px var(--tp-base-shadow-color);gap:8px;font-size:.85rem;line-height:130%;font-family:Inter,"Roboto Mono","Source Code Pro",Menlo,Courier,monospace;opacity:1;transition:all .25s}.button-bar-button{background-color:rgba(0,0,0,0);cursor:pointer;width:auto;height:auto;font-weight:500;padding:.35rem .5rem;position:relative;-webkit-user-select:none;-moz-user-select:none;user-select:none;color:var(--tp-input-foreground-color, #cccccc);transition:color .25s}.button-bar-button:hover{color:var(--tp-label-foreground-color, #eeeeee)}.button-bar-selected{color:var(--tp-label-foreground-color, #eeeeee)}.button-bar-selected-box{color:var(--tp-label-foreground-color, #eeeeee)}.button-bar>.button-bar-button:not(:last-child)::after{content:"";position:absolute;right:-5px;top:20%;width:2px;height:60%;border-radius:1px;background-color:var(--tp-container-background-color-active, #413762)}.button-bar-button:before{left:50%;width:0;content:"";position:absolute}.button-bar-selected:before{left:25%;width:50%;bottom:0;height:2px;border-radius:1px;background-color:var(--tp-container-foreground-color, #cccccc);transition:width .25s,left .25s}.button-bar-selected-box{background-color:rgba(238,238,238,.3333333333);border-radius:.25rem;transition:all .25s}.round-button{width:1rem;height:1rem;padding:.6rem;background-color:var(--tp-base-background-color);border-radius:1.2rem;color:#ccc;cursor:pointer;box-shadow:0 2px 4px var(--tp-base-shadow-color);transition:all .25s;box-sizing:content-box !important}.round-button:hover{color:#fff}.util-buttons-container{bottom:1.25rem;right:1.25rem;position:absolute;gap:8px;padding:.25rem}.util-button{position:relative;width:auto;height:1.2rem;aspect-ratio:1;box-sizing:content-box !important}.mode-buttons-container{border-top:0;top:0;left:0;right:0;margin-left:auto;margin-right:auto;position:absolute;min-width:6rem;border-radius:0 0 .5rem .5rem;gap:8px;flex-wrap:nowrap !important;overflow-x:scroll;pointer-events:auto;max-width:100%;align-content:center;justify-content:flex-start;align-items:center;box-sizing:border-box}.mode-buttons-container::-webkit-scrollbar{display:none}.mode-buttons-container{-ms-overflow-style:none;scrollbar-width:none}.mode-button{font-weight:500}#webgi-logo{background-image:url("https://static.webgi.xyz/logo.svg");background-size:contain;background-repeat:no-repeat;background-position:center;bottom:1.25rem;left:1rem;z-index:100;width:7.5rem;height:2.5rem;position:absolute;cursor:pointer}#webgi-logo:hover{filter:grayscale(100%)}#fsToggle{position:absolute;right:1.25rem;top:1.25rem;color:var(--tp-container-foreground-color, #dddddd)}#assetManagerPopup{position:absolute;margin:auto;left:0;right:0;top:0;bottom:0;color:#fff;padding:1.5rem;font-size:.85rem;overflow-y:scroll;background-color:var(--tp-base-background-color)}::-webkit-scrollbar{width:8px;height:8px}::-webkit-scrollbar-track{background:rgba(40,34,60,.8) !important;border-radius:6px}::-webkit-scrollbar-thumb{background:rgba(255,255,255,.4);border-radius:6px}::-webkit-scrollbar-corner{background:rgba(0,0,0,.5)}.tippy-box[data-theme~=editor]{margin:.25rem !important;background-color:var(--tp-base-background-color) !important;font-size:.9rem !important;color:var(--tp-container-foreground-color, #dddddd) !important}#tweakpaneUiContainer{margin-top:4.5rem}#canvasContainer{display:flex;justify-content:center;align-items:center}@media only screen and (min-width: 920px){#canvasContainer{width:calc(min(100% - 3rem,100% - var(--tweakpane-ui-container-width, 300px)) - 3.5rem) !important;height:calc(100% - 5rem);margin:3.5rem 1.5rem 1.5rem 1.5rem;border-radius:.5rem;box-shadow:rgba(0,0,0,.25) 0px 25px 50px -12px}#mcanvas{border-radius:.5rem}#tweakpaneUiContainer{margin-top:3.5rem}}body{transition:background-color .5s ease;background-color:#d1d4e7}body.tpTheme-blue{background-color:#d1d4e7}body.tpTheme-white{background-color:#dcdcdc}body.tpTheme-black{background-color:#48495d}', ""]), t.Z = i;
}, 898: function(e, t, n) {
  var r = n(352), i = n.n(r)()(function(e2) {
    return e2[1];
  });
  i.push([e.id, ':root{--tp-blade-unit-size: 26px;--tp-font-family: "Inter";--tp-element-border-radius: 0.25rem}:root{--tp-base-background-color: #0e0e0e;--tp-container-background-color: rgba(32, 32, 32, 0.2);--tp-container-background-color-hover: rgba(32, 32, 32, 0.3);--tp-container-background-color-active: rgba(50, 50, 50, 0.8);--tp-container-background-color-focus: rgba(50, 50, 50, 1.0);--tp-container-foreground-color: hsla(0, 0%, 90%, 0.90);--tp-label-foreground-color: hsla(0, 0%, 85%, 0.90)}:root .tpTheme-blue{--tp-base-background-color: #28223C;--tp-base-shadow-color: hsla(0, 0%, 0%, 0.2);--tp-button-background-color: hsla(230, 10%, 80%, 1.00);--tp-button-background-color-active: hsla(230, 10%, 95%, 1.00);--tp-button-background-color-focus: hsla(230, 10%, 90%, 1.00);--tp-button-background-color-hover: hsla(230, 10%, 85%, 1.00);--tp-button-foreground-color: hsla(230, 20%, 11%, 1.00);--tp-container-background-color: hsla(230, 25%, 16%, 0.65);--tp-container-background-color-active: hsla(230, 25%, 36%, 0.65);--tp-container-background-color-focus: hsla(230, 25%, 26%, 0.65);--tp-container-background-color-hover: hsla(230, 25%, 21%, 0.65);--tp-container-foreground-color: hsl(240, 10%, 92%);--tp-groove-foreground-color: hsla(230, 20%, 8%, 1.00);--tp-input-background-color: hsla(230, 20%, 8%, 1.00);--tp-input-background-color-active: hsla(230, 28%, 23%, 1.00);--tp-input-background-color-focus: hsla(230, 28%, 18%, 1.00);--tp-input-background-color-hover: hsla(230, 20%, 13%, 1.00);--tp-input-foreground-color: hsla(230, 10%, 80%, 1.00);--tp-monitor-background-color: hsla(230, 20%, 8%, 1.00);--tp-monitor-foreground-color: hsla(230, 12%, 48%, 1.00);--tp-label-foreground-color: #E4E2ED}:root .tpTheme-white{--tp-base-background-color: hsla(230, 5%, 90%, 1.00);--tp-base-shadow-color: hsla(0, 0%, 0%, 0.10);--tp-button-background-color: hsla(230, 7%, 85%, 1.00);--tp-button-background-color-active: hsla(230, 7%, 70%, 1.00);--tp-button-background-color-focus: hsla(230, 7%, 75%, 1.00);--tp-button-background-color-hover: hsla(230, 7%, 80%, 1.00);--tp-button-foreground-color: hsla(230, 10%, 30%, 1.00);--tp-container-background-color: hsla(230, 15%, 80%, 0.10);--tp-container-background-color-active: hsla(230, 15%, 70%, 0.32);--tp-container-background-color-focus: hsla(230, 15%, 70%, 0.28);--tp-container-background-color-hover: hsla(230, 15%, 70%, 0.24);--tp-container-foreground-color: hsla(230, 10%, 30%, 1.00);--tp-groove-foreground-color: hsla(230, 15%, 20%, 0.10);--tp-input-background-color: hsla(230, 15%, 30%, 0.10);--tp-input-background-color-active: hsla(230, 15%, 50%, 0.22);--tp-input-background-color-focus: hsla(230, 15%, 50%, 0.18);--tp-input-background-color-hover: hsla(230, 15%, 50%, 0.14);--tp-input-foreground-color: hsla(230, 10%, 20%, 1.00);--tp-label-foreground-color: hsla(230, 10%, 10%, 1.00);--tp-monitor-background-color: hsla(230, 15%, 30%, 0.10);--tp-monitor-foreground-color: hsla(230, 10%, 30%, 0.50)}.tp-fldv{margin-top:.25rem;margin-bottom:.25rem;background-blend-mode:luminosity;position:relative}.tp-fldv .tp-fldv{margin-top:.5rem;margin-bottom:.5rem}.tp-fldv_b{height:calc(var(--bld-us)*1.5 + 4px) !important;font-size:.9rem !important;transition:background-color .5s ease}.tp-fldv_b+.tp-brkv .tp-fldv_b{height:calc(var(--bld-us)*1.1 + 4px) !important;font-size:.7rem !important}.tp-lblv_l{font-size:.75rem !important;font-weight:500 !important;flex-grow:1 !important;flex-basis:20% !important}.tp-lblv_v{flex-grow:1 !important;flex-basis:50% !important}.tp-txtv_i{font-size:.75rem !important;font-weight:500 !important}.tp-fldv_t{font-weight:500 !important;padding-left:1.5rem !important}.tp-fldv_m{right:auto !important;left:.75rem;opacity:1 !important}.pluginOptionsButton{position:absolute;right:0;top:.75rem;padding-left:.5rem;padding-right:.5rem;height:-moz-min-content;height:min-content;background:rgba(0,0,0,0);color:var(--tp-container-foreground-color, #eeeeee);font-size:.9rem;border:none}.tp-sldv_k::after{background-color:var(--tp-input-foreground-color, hsl(230, 7%, 75%))}.tp-btnv_b{height:calc(var(--tp-blade-unit-size)*1.15)}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{font-weight:500 !important}.tp-rotv{font-size:13px !important}', ""]), t.Z = i;
}, 513: function(e, t, n) {
  var r = n(352), i = n.n(r)()(function(e2) {
    return e2[1];
  });
  i.push([e.id, ".wwise-perspective{perspective:1000px;position:fixed;left:0;top:0;width:100vw;height:100vh}.wwise-wrapper{position:fixed;width:0;height:0;font-weight:400}.wwise-wrapper.v-center{top:50%}.wwise-wrapper.h-center{left:50%}.wwise-wrapper.left{left:0}.wwise-wrapper.right{right:0}.wwise-wrapper.top{top:0}.wwise-wrapper.bottom{bottom:0}.wwise *.preset{color:#fafafa}.wwise *.preset.ok{background:rgba(45,193,80,.95)}.wwise *.preset.error{background:rgba(190,17,51,.95)}.wwise *.preset.info{background:rgba(40,34,60,.95)}.wwise *.preset.caution{background:rgba(239,128,0,.95)}.wwise-no-scroll{position:relative;overflow:hidden}.wwise-overlay{position:fixed;left:0;top:0;width:100vw;height:100vh;background:rgba(50,50,50,.5)}.wwise{position:absolute;left:0;top:0;display:flex;flex-direction:column;border-radius:5px;box-shadow:1px 1px 10px rgba(150,150,150,.5);box-sizing:border-box}.wwise.no-radius{border-radius:0}.wwise *{box-sizing:border-box}.wwise .clear{clear:both}.wwise>.content{padding:0;margin:0;flex-grow:1;border-radius:0 0 4px 4px;background:#fff;color:#333;box-shadow:0 1px 3px rgba(200,200,200,.5) inset}.wwise>.content.no-topbar{border-radius:4px;box-shadow:none}.wwise.no-radius>.content,.wwise.no-radius>.content.no-topbar{border-radius:0}.wwise .modal>.main{width:90vw;max-width:400px;border-radius:4px 4px 0 0;text-align:center;padding-bottom:10px;color:#fff}.wwise .modal>.main .icon{display:block;margin:0 auto;fill:#fff;width:100px}.wwise .modal>.main .title{font-size:30px}.wwise .modal>.main .text{margin:10px 0;font-weight:300;font-size:16px}.wwise .modal>.main.no-op{border-radius:4px}.wwise .modal>.main.ok{background:#2dc150}.wwise .modal>.main.error{background:#be1133}.wwise .modal>.main.info{background:#28223c}.wwise .modal>.main.caution{background:#ef8000}.wwise .modal>.operation .button-wrapper{text-align:center;margin:30px 0 20px 0}.wwise .modal>.operation .button{display:inline-block;line-height:18px;padding:8px 10px;margin:0 15px;line-height:18px;width:100px;border-radius:4px;border:1px solid #eee;box-shadow:1px 1px 3px rgba(220,220,220,.8);color:#555;transition:all ease .2s}.wwise .modal>.operation .button:hover{background:#f5f5f5;cursor:pointer}.wwise .modal>.operation .button.main{color:#fff}.wwise .modal>.operation.ok .main{background:#2dc150}.wwise .modal>.operation.ok .main:hover{background:#23983f}.wwise .modal>.operation.error .main{background:#be1133}.wwise .modal>.operation.error .main:hover{background:#8f0d26}.wwise .modal>.operation.info .main{background:#28223c}.wwise .modal>.operation.info .main:hover{background:#12101b}.wwise .modal>.operation.caution .main{background:#ef8000}.wwise .modal>.operation.caution .main:hover{background:#bc6500}.wwise .input-wrapper{margin:15px auto -15px auto}.wwise .input-wrapper .input{display:block;margin:0 auto;width:95%;max-width:300px;outline:none;border:none;background:#f3f3f3;padding:15px;font-size:16px;border-radius:5px}.wwise .input-wrapper .error{width:95%;text-align:center;margin-top:10px;color:red}div:has(>.wwise-wrapper){position:absolute !important}.wwise-wrapper{position:absolute !important}.wwise .modal>.main{padding-top:10px}", ""]), t.Z = i;
}, 476: function(e) {
  var t;
  t = function() {
    return function(e2) {
      var t2 = {};
      function n(r) {
        if (t2[r])
          return t2[r].exports;
        var i = t2[r] = { i: r, l: false, exports: {} };
        return e2[r].call(i.exports, i, i.exports, n), i.l = true, i.exports;
      }
      return n.m = e2, n.c = t2, n.i = function(e3) {
        return e3;
      }, n.d = function(e3, t3, r) {
        n.o(e3, t3) || Object.defineProperty(e3, t3, { configurable: false, enumerable: true, get: r });
      }, n.n = function(e3) {
        var t3 = e3 && e3.__esModule ? function() {
          return e3.default;
        } : function() {
          return e3;
        };
        return n.d(t3, "a", t3), t3;
      }, n.o = function(e3, t3) {
        return Object.prototype.hasOwnProperty.call(e3, t3);
      }, n.p = "", n(n.s = 5);
    }([function(e2, t2, n) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var r = { convertToObject: function(e3) {
        var t3 = e3.substring(e3.indexOf("{") + 1).trim().slice(0, -1), n2 = {};
        return t3.split(";").map(function(e4) {
          if (e4 = e4.trim()) {
            var t4 = e4.split(":");
            n2[t4[0].trim()] = t4[1].trim();
          }
        }), n2;
      }, getFromSheets: function(e3) {
        var t3 = document.styleSheets;
        for (var n2 in t3) {
          var i = null;
          try {
            i = t3[n2].rules || t3[n2].cssRules;
          } catch (e4) {
          }
          if (i) {
            for (var s in i)
              if (i[s].selectorText && -1 != i[s].selectorText.split(",").indexOf(e3))
                return i[s].cssText ? r.convertToObject(i[s].cssText) : r.convertToObject(i[s].style.cssText);
          }
        }
        return {};
      }, getPropertyDefault: function(e3) {
        return "timing-function" == e3 ? "ease" : "iteration-count" == e3 ? 1 : "direction" == e3 ? "normal" : "fill-mode" == e3 ? "none" : null;
      } };
      t2.default = r;
    }, function(e2, t2, n) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var r = { generateId: function() {
        for (var e3 = "", t3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", n2 = 0; n2 < 8; ++n2)
          e3 += t3.charAt(Math.floor(Math.random() * t3.length));
        return e3;
      }, frameToString: function(e3) {
        var t3 = "";
        for (var n2 in e3)
          t3 += n2 + ":" + e3[n2] + ";";
        return t3;
      }, convertTimeToMs: function(e3) {
        if (!e3)
          return 0;
        if ("number" == typeof e3)
          return e3;
        var t3 = parseFloat(e3);
        return -1 != e3.indexOf("ms") ? t3 : 1e3 * t3;
      }, prefixes: ["", "-webkit-", "-moz-", "-o-"] };
      t2.default = r;
    }, function(e2, t2, n) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var r, i = (r = n(0)) && r.__esModule ? r : { default: r };
      t2.default = function e3(t3, n2) {
        if (function(e4, t4) {
          if (!(e4 instanceof t4))
            throw new TypeError("Cannot call a class as a function");
        }(this, e3), this.styles = "string" == typeof t3 ? i.default.getFromSheets(t3) : t3, "string" == typeof n2) {
          var r2 = i.default.getFromSheets(n2);
          for (var s in this.options = {}, r2)
            this.options[s.replace("animation-", "")] = r2[s];
        } else
          this.options = "number" == typeof n2 ? { duration: n2 } : n2;
      };
    }, function(e2, t2, n) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var r = function() {
        function e3(e4, t3) {
          for (var n2 = 0; n2 < t3.length; n2++) {
            var r2 = t3[n2];
            r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(e4, r2.key, r2);
          }
        }
        return function(t3, n2, r2) {
          return n2 && e3(t3.prototype, n2), r2 && e3(t3, r2), t3;
        };
      }(), i = a(n(4)), s = a(n(1)), o = a(n(0));
      function a(e3) {
        return e3 && e3.__esModule ? e3 : { default: e3 };
      }
      var l = function() {
        function e3(t3, n2, r2, i2) {
          if (function(e4, t4) {
            if (!(e4 instanceof t4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), t3.constructor === Array ? this.doms = t3 : this.doms = [t3], n2.constructor === Array ? this.frames = n2 : this.frames = [n2], this.options = { startFrom: 0, pauseAt: [], prefix: false, count: 1, clear: true, applyOnEnd: false, instant: false }, null != r2 && null != r2)
            if ("boolean" == typeof r2)
              this.options.instant = r2;
            else if ("number" == typeof r2)
              this.options.count = r2, "boolean" == typeof i2 && (this.options.instant = i2);
            else
              for (var o2 in r2)
                "pauseAt" == o2 && r2.pauseAt.constructor !== Array ? this.options[o2] = [r2[o2]] : this.options[o2] = r2[o2];
          for (var a2 in this.promiseSupported = "undefined" != typeof Promise && -1 !== Promise.toString().indexOf("[native code]"), this.countRemainder = [], this.animations = [], this.styleDoms = [], this.superSets = [], this.eventHandler = [], this.options.prefix ? this.prefixes = s.default.prefixes : this.prefixes = [""], t3)
            this.countRemainder[a2] = this.options.count - 1;
          this.options.instant && this.play();
        }
        return r(e3, [{ key: "play", value: function() {
          var e4 = this;
          for (var t3 in this.clear(), this.promiseSupported && (this.promise = new Promise(function(t4) {
            e4.promiseResolve = t4;
          })), this.doms) {
            var n2 = this.makeAnimation(this.doms[t3]);
            this.animations[t3] = n2.names, this.styleDoms[t3] = n2.styleDom, this.superSets[t3] = this.makeSuperSet(this.doms[t3], this.animations[t3]), this.playAnimation(this.doms[t3], this.superSets[t3]), this.eventHandler[t3] = this.handleAnimationEnd.bind(this, t3), this.doms[t3].addEventListener("animationend", this.eventHandler[t3]);
          }
          if (this.promiseSupported)
            return this.promise;
        } }, { key: "clear", value: function(e4) {
          if (!e4) {
            for (var t3 in this.doms)
              this.clear(t3);
            return this.animationEnded = 0, this.promise = void 0, void (this.promiseResolve = void 0);
          }
          var n2 = this.styleDoms[e4];
          for (var r2 in n2 && n2.parentNode && n2.parentNode.removeChild(n2), this.superSets[e4])
            for (var i2 in this.prefixes)
              this.doms[e4].style[this.prefixes[i2] + "animation-" + r2] = null;
          for (var s2 in this.prefixes)
            this.doms[e4].style[this.prefixes[s2] + "animation-play-state"] = null;
          this.doms[e4].removeEventListener("animationend", this.eventHandler[e4]), this.countRemainder[e4] = this.options.count - 1;
        } }, { key: "replay", value: function(e4) {
          var t3 = this.doms[e4], n2 = t3.cloneNode(true);
          t3.parentNode.replaceChild(n2, t3), this.doms[e4].removeEventListener("animationend", this.eventHandler[e4]), this.doms[e4] = n2, this.doms[e4].addEventListener("animationend", this.eventHandler[e4]);
        } }, { key: "pause", value: function() {
          for (var e4 in this.doms)
            this.pauseDom(this.doms[e4]);
        } }, { key: "resume", value: function() {
          for (var e4 in this.doms)
            this.resumeDom(this.doms[e4]);
        } }, { key: "getPromise", value: function() {
          return this.promise;
        } }, { key: "handleAnimationEnd", value: function(e4, t3) {
          var n2 = t3.animationName, r2 = n2.substring(n2.lastIndexOf("-") + 1);
          this.options.pauseAt.includes(parseInt(r2)) && this.pauseDom(this.doms[e4]), r2 == this.frames.length && (-1 == this.countRemainder[e4] ? this.replay(e4) : this.countRemainder[e4] > 0 ? (this.countRemainder[e4]--, this.replay(e4)) : (this.options.applyOnEnd && this.applyOnEnd(e4), this.animationEnded++, this.animationEnded == this.doms.length && (this.promiseSupported && this.promiseResolve(), this.options.clear && this.clear())));
        } }, { key: "pauseDom", value: function(e4) {
          for (var t3 in this.prefixes)
            e4.style[this.prefixes[t3] + "animation-play-state"] = "paused";
        } }, { key: "resumeDom", value: function(e4) {
          for (var t3 in this.prefixes)
            e4.style[this.prefixes[t3] + "animation-play-state"] = "running";
        } }, { key: "applyOnEnd", value: function(e4) {
          var t3 = this.newFrames[this.frames.length];
          for (var n2 in t3)
            this.doms[e4].style[n2] = t3[n2];
        } }, { key: "makeAnimation", value: function(e4) {
          var t3 = {}, n2 = [], r2 = {};
          for (var s2 in this.frames)
            for (var o2 in n2.push(this.frames[s2].styles), n2[s2])
              r2[o2] = true;
          var a2 = window.getComputedStyle(e4);
          for (var l2 in r2)
            t3[l2] = a2[l2];
          n2.unshift(t3);
          for (var c = [n2[0]], u = 1; u < n2.length; ++u) {
            var p = JSON.parse(JSON.stringify(c[u - 1]));
            for (var d in n2[u])
              p[d] = n2[u][d];
            c.push(p);
          }
          return this.newFrames = c, i.default.make(c, this.prefixes);
        } }, { key: "makeSuperSet", value: function(e4, t3) {
          var n2 = 0, r2 = {};
          for (var i2 in this.frames)
            for (var a2 in this.frames[i2].options)
              r2[a2] = "";
          r2.name = "", r2.duration = "", r2.delay = "";
          for (var l2 = 0; l2 < this.frames.length; ++l2) {
            if (l2)
              for (var c in r2)
                r2[c] += ",";
            var u = s.default.convertTimeToMs(this.frames[l2].options.duration), p = s.default.convertTimeToMs(this.frames[l2].options.delay);
            for (var d in l2 < this.options.startFrom && (u = 0, p = 0), r2.name += t3[l2], r2.duration += u + "ms", r2.delay += n2 + p + "ms", r2)
              "name" != d && "duration" != d && "delay" != d && (r2[d] += this.frames[l2].options[d] ? this.frames[l2].options[d] : o.default.getPropertyDefault(d));
            var h = this.frames[l2].options["iteration-count"];
            n2 += u * parseInt(h || 1) + p;
          }
          return r2;
        } }, { key: "playAnimation", value: function(e4, t3) {
          for (var n2 in t3)
            for (var r2 in this.prefixes)
              e4.style[this.prefixes[r2] + "animation-" + n2] = t3[n2];
          this.options.pauseAt.includes(0) && this.pauseDom(e4);
        } }]), e3;
      }();
      t2.default = l;
    }, function(e2, t2, n) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var r, i = (r = n(1)) && r.__esModule ? r : { default: r }, s = { make: function(e3, t3) {
        for (var n2 = [], r2 = "", o = "atr-" + i.default.generateId(), a = document.createElement("style"), l = 0; l < e3.length - 1; ++l)
          n2.push(o + "-" + (l + 1)), r2 += s.makeFromTwoFrames(e3[l], e3[l + 1], n2[l], t3);
        return a.innerHTML = r2, a.class = "foo", document.getElementsByTagName("head")[0].appendChild(a), { names: n2, styleDom: a };
      }, makeFromTwoFrames: function(e3, t3, n2, r2) {
        var s2 = "";
        for (var o in r2)
          s2 += "@" + r2[o] + "keyframes " + n2 + " {", s2 += "0%", s2 += "{" + i.default.frameToString(e3) + "}", s2 += "100%", s2 += "{" + i.default.frameToString(t3) + "}", s2 += "}";
        return s2;
      } };
      t2.default = s;
    }, function(e2, t2, n) {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.Queue = t2.Frame = void 0;
      var r = s(n(2)), i = s(n(3));
      function s(e3) {
        return e3 && e3.__esModule ? e3 : { default: e3 };
      }
      t2.Frame = r.default, t2.Queue = i.default;
    }]);
  }, e.exports = t();
}, 352: function(e) {
  e.exports = function(e2) {
    var t = [];
    return t.toString = function() {
      return this.map(function(t2) {
        var n = e2(t2);
        return t2[2] ? "@media ".concat(t2[2], " {").concat(n, "}") : n;
      }).join("");
    }, t.i = function(e3, n, r) {
      "string" == typeof e3 && (e3 = [[null, e3, ""]]);
      var i = {};
      if (r)
        for (var s = 0; s < this.length; s++) {
          var o = this[s][0];
          null != o && (i[o] = true);
        }
      for (var a = 0; a < e3.length; a++) {
        var l = [].concat(e3[a]);
        r && i[l[0]] || (n && (l[2] ? l[2] = "".concat(n, " and ").concat(l[2]) : l[2] = n), t.push(l));
      }
    }, t;
  };
}, 388: function(e) {
  e.exports = function e2(t, n, r) {
    function i(o2, a) {
      if (!n[o2]) {
        if (!t[o2]) {
          if (s)
            return s(o2, true);
          throw new Error("Cannot find module '" + o2 + "'");
        }
        var l = n[o2] = { exports: {} };
        t[o2][0].call(l.exports, function(e3) {
          return i(t[o2][1][e3] || e3);
        }, l, l.exports, e2, t, n, r);
      }
      return n[o2].exports;
    }
    for (var s = void 0, o = 0; o < r.length; o++)
      i(r[o]);
    return i;
  }({ 1: [function(e2, t, n) {
    (function(r, i, s, o, a, l, c, u, p) {
      var d = e2("crypto");
      function h(e3, t2) {
        return function(e4, t3) {
          var n2;
          if (void 0 === (n2 = "passthrough" !== t3.algorithm ? d.createHash(t3.algorithm) : new y()).write && (n2.write = n2.update, n2.end = n2.update), v(t3, n2).dispatch(e4), n2.update || n2.end(""), n2.digest)
            return n2.digest("buffer" === t3.encoding ? void 0 : t3.encoding);
          var r2 = n2.read();
          return "buffer" !== t3.encoding ? r2.toString(t3.encoding) : r2;
        }(e3, t2 = _(e3, t2));
      }
      (n = t.exports = h).sha1 = function(e3) {
        return h(e3);
      }, n.keys = function(e3) {
        return h(e3, { excludeValues: true, algorithm: "sha1", encoding: "hex" });
      }, n.MD5 = function(e3) {
        return h(e3, { algorithm: "md5", encoding: "hex" });
      }, n.keysMD5 = function(e3) {
        return h(e3, { algorithm: "md5", encoding: "hex", excludeValues: true });
      };
      var f = d.getHashes ? d.getHashes().slice() : ["sha1", "md5"];
      f.push("passthrough");
      var m = ["buffer", "hex", "binary", "base64"];
      function _(e3, t2) {
        t2 = t2 || {};
        var n2 = {};
        if (n2.algorithm = t2.algorithm || "sha1", n2.encoding = t2.encoding || "hex", n2.excludeValues = !!t2.excludeValues, n2.algorithm = n2.algorithm.toLowerCase(), n2.encoding = n2.encoding.toLowerCase(), n2.ignoreUnknown = true === t2.ignoreUnknown, n2.respectType = false !== t2.respectType, n2.respectFunctionNames = false !== t2.respectFunctionNames, n2.respectFunctionProperties = false !== t2.respectFunctionProperties, n2.unorderedArrays = true === t2.unorderedArrays, n2.unorderedSets = false !== t2.unorderedSets, n2.unorderedObjects = false !== t2.unorderedObjects, n2.replacer = t2.replacer || void 0, n2.excludeKeys = t2.excludeKeys || void 0, void 0 === e3)
          throw new Error("Object argument required.");
        for (var r2 = 0; r2 < f.length; ++r2)
          f[r2].toLowerCase() === n2.algorithm.toLowerCase() && (n2.algorithm = f[r2]);
        if (-1 === f.indexOf(n2.algorithm))
          throw new Error('Algorithm "' + n2.algorithm + '"  not supported. supported values: ' + f.join(", "));
        if (-1 === m.indexOf(n2.encoding) && "passthrough" !== n2.algorithm)
          throw new Error('Encoding "' + n2.encoding + '"  not supported. supported values: ' + m.join(", "));
        return n2;
      }
      function g(e3) {
        if ("function" == typeof e3)
          return null != /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(e3));
      }
      function v(e3, t2, n2) {
        function r2(e4) {
          return t2.update ? t2.update(e4, "utf8") : t2.write(e4, "utf8");
        }
        return n2 = n2 || [], { dispatch: function(t3) {
          return e3.replacer && (t3 = e3.replacer(t3)), this["_" + (null === t3 ? "null" : typeof t3)](t3);
        }, _object: function(t3) {
          var i2, o2 = Object.prototype.toString.call(t3), a2 = /\[object (.*)\]/i.exec(o2);
          if (a2 = (a2 = a2 ? a2[1] : "unknown:[" + o2 + "]").toLowerCase(), 0 <= (i2 = n2.indexOf(t3)))
            return this.dispatch("[CIRCULAR:" + i2 + "]");
          if (n2.push(t3), void 0 !== s && s.isBuffer && s.isBuffer(t3))
            return r2("buffer:"), r2(t3);
          if ("object" === a2 || "function" === a2 || "asyncfunction" === a2) {
            var l2 = Object.keys(t3);
            e3.unorderedObjects && (l2 = l2.sort()), false === e3.respectType || g(t3) || l2.splice(0, 0, "prototype", "__proto__", "constructor"), e3.excludeKeys && (l2 = l2.filter(function(t4) {
              return !e3.excludeKeys(t4);
            })), r2("object:" + l2.length + ":");
            var c2 = this;
            return l2.forEach(function(n3) {
              c2.dispatch(n3), r2(":"), e3.excludeValues || c2.dispatch(t3[n3]), r2(",");
            });
          }
          if (!this["_" + a2]) {
            if (e3.ignoreUnknown)
              return r2("[" + a2 + "]");
            throw new Error('Unknown object type "' + a2 + '"');
          }
          this["_" + a2](t3);
        }, _array: function(t3, i2) {
          i2 = void 0 !== i2 ? i2 : false !== e3.unorderedArrays;
          var s2 = this;
          if (r2("array:" + t3.length + ":"), !i2 || t3.length <= 1)
            return t3.forEach(function(e4) {
              return s2.dispatch(e4);
            });
          var o2 = [], a2 = t3.map(function(t4) {
            var r3 = new y(), i3 = n2.slice();
            return v(e3, r3, i3).dispatch(t4), o2 = o2.concat(i3.slice(n2.length)), r3.read().toString();
          });
          return n2 = n2.concat(o2), a2.sort(), this._array(a2, false);
        }, _date: function(e4) {
          return r2("date:" + e4.toJSON());
        }, _symbol: function(e4) {
          return r2("symbol:" + e4.toString());
        }, _error: function(e4) {
          return r2("error:" + e4.toString());
        }, _boolean: function(e4) {
          return r2("bool:" + e4.toString());
        }, _string: function(e4) {
          r2("string:" + e4.length + ":"), r2(e4.toString());
        }, _function: function(t3) {
          r2("fn:"), g(t3) ? this.dispatch("[native]") : this.dispatch(t3.toString()), false !== e3.respectFunctionNames && this.dispatch("function-name:" + String(t3.name)), e3.respectFunctionProperties && this._object(t3);
        }, _number: function(e4) {
          return r2("number:" + e4.toString());
        }, _xml: function(e4) {
          return r2("xml:" + e4.toString());
        }, _null: function() {
          return r2("Null");
        }, _undefined: function() {
          return r2("Undefined");
        }, _regexp: function(e4) {
          return r2("regex:" + e4.toString());
        }, _uint8array: function(e4) {
          return r2("uint8array:"), this.dispatch(Array.prototype.slice.call(e4));
        }, _uint8clampedarray: function(e4) {
          return r2("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(e4));
        }, _int8array: function(e4) {
          return r2("uint8array:"), this.dispatch(Array.prototype.slice.call(e4));
        }, _uint16array: function(e4) {
          return r2("uint16array:"), this.dispatch(Array.prototype.slice.call(e4));
        }, _int16array: function(e4) {
          return r2("uint16array:"), this.dispatch(Array.prototype.slice.call(e4));
        }, _uint32array: function(e4) {
          return r2("uint32array:"), this.dispatch(Array.prototype.slice.call(e4));
        }, _int32array: function(e4) {
          return r2("uint32array:"), this.dispatch(Array.prototype.slice.call(e4));
        }, _float32array: function(e4) {
          return r2("float32array:"), this.dispatch(Array.prototype.slice.call(e4));
        }, _float64array: function(e4) {
          return r2("float64array:"), this.dispatch(Array.prototype.slice.call(e4));
        }, _arraybuffer: function(e4) {
          return r2("arraybuffer:"), this.dispatch(new Uint8Array(e4));
        }, _url: function(e4) {
          return r2("url:" + e4.toString());
        }, _map: function(t3) {
          r2("map:");
          var n3 = Array.from(t3);
          return this._array(n3, false !== e3.unorderedSets);
        }, _set: function(t3) {
          r2("set:");
          var n3 = Array.from(t3);
          return this._array(n3, false !== e3.unorderedSets);
        }, _file: function(e4) {
          return r2("file:"), this.dispatch([e4.name, e4.size, e4.type, e4.lastModfied]);
        }, _blob: function() {
          if (e3.ignoreUnknown)
            return r2("[blob]");
          throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n');
        }, _domwindow: function() {
          return r2("domwindow");
        }, _bigint: function(e4) {
          return r2("bigint:" + e4.toString());
        }, _process: function() {
          return r2("process");
        }, _timer: function() {
          return r2("timer");
        }, _pipe: function() {
          return r2("pipe");
        }, _tcp: function() {
          return r2("tcp");
        }, _udp: function() {
          return r2("udp");
        }, _tty: function() {
          return r2("tty");
        }, _statwatcher: function() {
          return r2("statwatcher");
        }, _securecontext: function() {
          return r2("securecontext");
        }, _connection: function() {
          return r2("connection");
        }, _zlib: function() {
          return r2("zlib");
        }, _context: function() {
          return r2("context");
        }, _nodescript: function() {
          return r2("nodescript");
        }, _httpparser: function() {
          return r2("httpparser");
        }, _dataview: function() {
          return r2("dataview");
        }, _signal: function() {
          return r2("signal");
        }, _fsevent: function() {
          return r2("fsevent");
        }, _tlswrap: function() {
          return r2("tlswrap");
        } };
      }
      function y() {
        return { buf: "", write: function(e3) {
          this.buf += e3;
        }, end: function(e3) {
          this.buf += e3;
        }, read: function() {
          return this.buf;
        } };
      }
      n.writeToStream = function(e3, t2, n2) {
        return void 0 === n2 && (n2 = t2, t2 = {}), v(t2 = _(e3, t2), n2).dispatch(e3);
      };
    }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_7eac155c.js", "/");
  }, { buffer: 3, crypto: 5, lYpoI2: 10 }], 2: [function(e2, t, n) {
    (function(e3, t2, r, i, s, o, a, l, c) {
      !function(e4) {
        var t3 = "undefined" != typeof Uint8Array ? Uint8Array : Array, n2 = "+".charCodeAt(0), r2 = "/".charCodeAt(0), i2 = "0".charCodeAt(0), s2 = "a".charCodeAt(0), o2 = "A".charCodeAt(0), a2 = "-".charCodeAt(0), l2 = "_".charCodeAt(0);
        function c2(e5) {
          var t4 = e5.charCodeAt(0);
          return t4 === n2 || t4 === a2 ? 62 : t4 === r2 || t4 === l2 ? 63 : t4 < i2 ? -1 : t4 < i2 + 10 ? t4 - i2 + 26 + 26 : t4 < o2 + 26 ? t4 - o2 : t4 < s2 + 26 ? t4 - s2 + 26 : void 0;
        }
        e4.toByteArray = function(e5) {
          var n3, r3;
          if (0 < e5.length % 4)
            throw new Error("Invalid string. Length must be a multiple of 4");
          var i3 = e5.length, s3 = "=" === e5.charAt(i3 - 2) ? 2 : "=" === e5.charAt(i3 - 1) ? 1 : 0, o3 = new t3(3 * e5.length / 4 - s3), a3 = 0 < s3 ? e5.length - 4 : e5.length, l3 = 0;
          function u(e6) {
            o3[l3++] = e6;
          }
          for (n3 = 0; n3 < a3; n3 += 4, 0)
            u((16711680 & (r3 = c2(e5.charAt(n3)) << 18 | c2(e5.charAt(n3 + 1)) << 12 | c2(e5.charAt(n3 + 2)) << 6 | c2(e5.charAt(n3 + 3)))) >> 16), u((65280 & r3) >> 8), u(255 & r3);
          return 2 == s3 ? u(255 & (r3 = c2(e5.charAt(n3)) << 2 | c2(e5.charAt(n3 + 1)) >> 4)) : 1 == s3 && (u((r3 = c2(e5.charAt(n3)) << 10 | c2(e5.charAt(n3 + 1)) << 4 | c2(e5.charAt(n3 + 2)) >> 2) >> 8 & 255), u(255 & r3)), o3;
        }, e4.fromByteArray = function(e5) {
          var t4, n3, r3, i3, s3 = e5.length % 3, o3 = "";
          function a3(e6) {
            return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e6);
          }
          for (t4 = 0, r3 = e5.length - s3; t4 < r3; t4 += 3)
            o3 += a3((i3 = n3 = (e5[t4] << 16) + (e5[t4 + 1] << 8) + e5[t4 + 2]) >> 18 & 63) + a3(i3 >> 12 & 63) + a3(i3 >> 6 & 63) + a3(63 & i3);
          switch (s3) {
            case 1:
              o3 += a3((n3 = e5[e5.length - 1]) >> 2), o3 += a3(n3 << 4 & 63), o3 += "==";
              break;
            case 2:
              o3 += a3((n3 = (e5[e5.length - 2] << 8) + e5[e5.length - 1]) >> 10), o3 += a3(n3 >> 4 & 63), o3 += a3(n3 << 2 & 63), o3 += "=";
          }
          return o3;
        };
      }(void 0 === n ? this.base64js = {} : n);
    }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib");
  }, { buffer: 3, lYpoI2: 10 }], 3: [function(e2, t, n) {
    (function(t2, r, i, s, o, a, l, c, u) {
      var p = e2("base64-js"), d = e2("ieee754");
      function i(e3, t3, n2) {
        if (!(this instanceof i))
          return new i(e3, t3, n2);
        var r2, s2, o2, a2, l2, c2 = typeof e3;
        if ("base64" === t3 && "string" == c2)
          for (e3 = (r2 = e3).trim ? r2.trim() : r2.replace(/^\s+|\s+$/g, ""); e3.length % 4 != 0; )
            e3 += "=";
        if ("number" == c2)
          s2 = M(e3);
        else if ("string" == c2)
          s2 = i.byteLength(e3, t3);
        else {
          if ("object" != c2)
            throw new Error("First argument needs to be a number, array or string.");
          s2 = M(e3.length);
        }
        if (i._useTypedArrays ? o2 = i._augment(new Uint8Array(s2)) : ((o2 = this).length = s2, o2._isBuffer = true), i._useTypedArrays && "number" == typeof e3.byteLength)
          o2._set(e3);
        else if (T(l2 = e3) || i.isBuffer(l2) || l2 && "object" == typeof l2 && "number" == typeof l2.length)
          for (a2 = 0; a2 < s2; a2++)
            i.isBuffer(e3) ? o2[a2] = e3.readUInt8(a2) : o2[a2] = e3[a2];
        else if ("string" == c2)
          o2.write(e3, 0, t3);
        else if ("number" == c2 && !i._useTypedArrays && !n2)
          for (a2 = 0; a2 < s2; a2++)
            o2[a2] = 0;
        return o2;
      }
      function h(e3, t3, n2, r2) {
        r2 || (U("boolean" == typeof n2, "missing or invalid endian"), U(null != t3, "missing offset"), U(t3 + 1 < e3.length, "Trying to read beyond buffer length"));
        var i2, s2 = e3.length;
        if (!(s2 <= t3))
          return n2 ? (i2 = e3[t3], t3 + 1 < s2 && (i2 |= e3[t3 + 1] << 8)) : (i2 = e3[t3] << 8, t3 + 1 < s2 && (i2 |= e3[t3 + 1])), i2;
      }
      function f(e3, t3, n2, r2) {
        r2 || (U("boolean" == typeof n2, "missing or invalid endian"), U(null != t3, "missing offset"), U(t3 + 3 < e3.length, "Trying to read beyond buffer length"));
        var i2, s2 = e3.length;
        if (!(s2 <= t3))
          return n2 ? (t3 + 2 < s2 && (i2 = e3[t3 + 2] << 16), t3 + 1 < s2 && (i2 |= e3[t3 + 1] << 8), i2 |= e3[t3], t3 + 3 < s2 && (i2 += e3[t3 + 3] << 24 >>> 0)) : (t3 + 1 < s2 && (i2 = e3[t3 + 1] << 16), t3 + 2 < s2 && (i2 |= e3[t3 + 2] << 8), t3 + 3 < s2 && (i2 |= e3[t3 + 3]), i2 += e3[t3] << 24 >>> 0), i2;
      }
      function m(e3, t3, n2, r2) {
        if (r2 || (U("boolean" == typeof n2, "missing or invalid endian"), U(null != t3, "missing offset"), U(t3 + 1 < e3.length, "Trying to read beyond buffer length")), !(e3.length <= t3)) {
          var i2 = h(e3, t3, n2, true);
          return 32768 & i2 ? -1 * (65535 - i2 + 1) : i2;
        }
      }
      function _(e3, t3, n2, r2) {
        if (r2 || (U("boolean" == typeof n2, "missing or invalid endian"), U(null != t3, "missing offset"), U(t3 + 3 < e3.length, "Trying to read beyond buffer length")), !(e3.length <= t3)) {
          var i2 = f(e3, t3, n2, true);
          return 2147483648 & i2 ? -1 * (4294967295 - i2 + 1) : i2;
        }
      }
      function g(e3, t3, n2, r2) {
        return r2 || (U("boolean" == typeof n2, "missing or invalid endian"), U(t3 + 3 < e3.length, "Trying to read beyond buffer length")), d.read(e3, t3, n2, 23, 4);
      }
      function v(e3, t3, n2, r2) {
        return r2 || (U("boolean" == typeof n2, "missing or invalid endian"), U(t3 + 7 < e3.length, "Trying to read beyond buffer length")), d.read(e3, t3, n2, 52, 8);
      }
      function y(e3, t3, n2, r2, i2) {
        i2 || (U(null != t3, "missing value"), U("boolean" == typeof r2, "missing or invalid endian"), U(null != n2, "missing offset"), U(n2 + 1 < e3.length, "trying to write beyond buffer length"), B(t3, 65535));
        var s2 = e3.length;
        if (!(s2 <= n2))
          for (var o2 = 0, a2 = Math.min(s2 - n2, 2); o2 < a2; o2++)
            e3[n2 + o2] = (t3 & 255 << 8 * (r2 ? o2 : 1 - o2)) >>> 8 * (r2 ? o2 : 1 - o2);
      }
      function b(e3, t3, n2, r2, i2) {
        i2 || (U(null != t3, "missing value"), U("boolean" == typeof r2, "missing or invalid endian"), U(null != n2, "missing offset"), U(n2 + 3 < e3.length, "trying to write beyond buffer length"), B(t3, 4294967295));
        var s2 = e3.length;
        if (!(s2 <= n2))
          for (var o2 = 0, a2 = Math.min(s2 - n2, 4); o2 < a2; o2++)
            e3[n2 + o2] = t3 >>> 8 * (r2 ? o2 : 3 - o2) & 255;
      }
      function w(e3, t3, n2, r2, i2) {
        i2 || (U(null != t3, "missing value"), U("boolean" == typeof r2, "missing or invalid endian"), U(null != n2, "missing offset"), U(n2 + 1 < e3.length, "Trying to write beyond buffer length"), O(t3, 32767, -32768)), e3.length <= n2 || y(e3, 0 <= t3 ? t3 : 65535 + t3 + 1, n2, r2, i2);
      }
      function A(e3, t3, n2, r2, i2) {
        i2 || (U(null != t3, "missing value"), U("boolean" == typeof r2, "missing or invalid endian"), U(null != n2, "missing offset"), U(n2 + 3 < e3.length, "Trying to write beyond buffer length"), O(t3, 2147483647, -2147483648)), e3.length <= n2 || b(e3, 0 <= t3 ? t3 : 4294967295 + t3 + 1, n2, r2, i2);
      }
      function x(e3, t3, n2, r2, i2) {
        i2 || (U(null != t3, "missing value"), U("boolean" == typeof r2, "missing or invalid endian"), U(null != n2, "missing offset"), U(n2 + 3 < e3.length, "Trying to write beyond buffer length"), L(t3, 34028234663852886e22, -34028234663852886e22)), e3.length <= n2 || d.write(e3, t3, n2, r2, 23, 4);
      }
      function E(e3, t3, n2, r2, i2) {
        i2 || (U(null != t3, "missing value"), U("boolean" == typeof r2, "missing or invalid endian"), U(null != n2, "missing offset"), U(n2 + 7 < e3.length, "Trying to write beyond buffer length"), L(t3, 17976931348623157e292, -17976931348623157e292)), e3.length <= n2 || d.write(e3, t3, n2, r2, 52, 8);
      }
      n.Buffer = i, n.SlowBuffer = i, n.INSPECT_MAX_BYTES = 50, i.poolSize = 8192, i._useTypedArrays = function() {
        try {
          var e3 = new ArrayBuffer(0), t3 = new Uint8Array(e3);
          return t3.foo = function() {
            return 42;
          }, 42 === t3.foo() && "function" == typeof t3.subarray;
        } catch (e4) {
          return false;
        }
      }(), i.isEncoding = function(e3) {
        switch (String(e3).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "raw":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      }, i.isBuffer = function(e3) {
        return !(null == e3 || !e3._isBuffer);
      }, i.byteLength = function(e3, t3) {
        var n2;
        switch (e3 += "", t3 || "utf8") {
          case "hex":
            n2 = e3.length / 2;
            break;
          case "utf8":
          case "utf-8":
            n2 = I(e3).length;
            break;
          case "ascii":
          case "binary":
          case "raw":
            n2 = e3.length;
            break;
          case "base64":
            n2 = R(e3).length;
            break;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            n2 = 2 * e3.length;
            break;
          default:
            throw new Error("Unknown encoding");
        }
        return n2;
      }, i.concat = function(e3, t3) {
        if (U(T(e3), "Usage: Buffer.concat(list, [totalLength])\nlist should be an Array."), 0 === e3.length)
          return new i(0);
        if (1 === e3.length)
          return e3[0];
        if ("number" != typeof t3)
          for (s2 = t3 = 0; s2 < e3.length; s2++)
            t3 += e3[s2].length;
        for (var n2 = new i(t3), r2 = 0, s2 = 0; s2 < e3.length; s2++) {
          var o2 = e3[s2];
          o2.copy(n2, r2), r2 += o2.length;
        }
        return n2;
      }, i.prototype.write = function(e3, t3, n2, r2) {
        var s2;
        isFinite(t3) ? isFinite(n2) || (r2 = n2, n2 = void 0) : (s2 = r2, r2 = t3, t3 = n2, n2 = s2), t3 = Number(t3) || 0;
        var o2, a2, l2, c2, u2, p2, d2, h2 = this.length - t3;
        switch ((!n2 || h2 < (n2 = Number(n2))) && (n2 = h2), r2 = String(r2 || "utf8").toLowerCase()) {
          case "hex":
            o2 = function(e4, t4, n3, r3) {
              n3 = Number(n3) || 0;
              var s3 = e4.length - n3;
              (!r3 || s3 < (r3 = Number(r3))) && (r3 = s3);
              var o3 = t4.length;
              U(o3 % 2 == 0, "Invalid hex string"), o3 / 2 < r3 && (r3 = o3 / 2);
              for (var a3 = 0; a3 < r3; a3++) {
                var l3 = parseInt(t4.substr(2 * a3, 2), 16);
                U(!isNaN(l3), "Invalid hex string"), e4[n3 + a3] = l3;
              }
              return i._charsWritten = 2 * a3, a3;
            }(this, e3, t3, n2);
            break;
          case "utf8":
          case "utf-8":
            this, u2 = e3, p2 = t3, d2 = n2, o2 = i._charsWritten = k(I(u2), this, p2, d2);
            break;
          case "ascii":
          case "binary":
            o2 = function(e4, t4, n3, r3) {
              return i._charsWritten = k(function(e5) {
                for (var t5 = [], n4 = 0; n4 < e5.length; n4++)
                  t5.push(255 & e5.charCodeAt(n4));
                return t5;
              }(t4), e4, n3, r3);
            }(this, e3, t3, n2);
            break;
          case "base64":
            this, a2 = e3, l2 = t3, c2 = n2, o2 = i._charsWritten = k(R(a2), this, l2, c2);
            break;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            o2 = function(e4, t4, n3, r3) {
              return i._charsWritten = k(function(e5) {
                for (var t5, n4, r4, i2 = [], s3 = 0; s3 < e5.length; s3++)
                  n4 = (t5 = e5.charCodeAt(s3)) >> 8, r4 = t5 % 256, i2.push(r4), i2.push(n4);
                return i2;
              }(t4), e4, n3, r3);
            }(this, e3, t3, n2);
            break;
          default:
            throw new Error("Unknown encoding");
        }
        return o2;
      }, i.prototype.toString = function(e3, t3, n2) {
        var r2, i2, s2, o2, a2 = this;
        if (e3 = String(e3 || "utf8").toLowerCase(), t3 = Number(t3) || 0, (n2 = void 0 !== n2 ? Number(n2) : n2 = a2.length) === t3)
          return "";
        switch (e3) {
          case "hex":
            r2 = function(e4, t4, n3) {
              var r3 = e4.length;
              (!t4 || t4 < 0) && (t4 = 0), (!n3 || n3 < 0 || r3 < n3) && (n3 = r3);
              for (var i3 = "", s3 = t4; s3 < n3; s3++)
                i3 += P(e4[s3]);
              return i3;
            }(a2, t3, n2);
            break;
          case "utf8":
          case "utf-8":
            r2 = function(e4, t4, n3) {
              var r3 = "", i3 = "";
              n3 = Math.min(e4.length, n3);
              for (var s3 = t4; s3 < n3; s3++)
                e4[s3] <= 127 ? (r3 += D(i3) + String.fromCharCode(e4[s3]), i3 = "") : i3 += "%" + e4[s3].toString(16);
              return r3 + D(i3);
            }(a2, t3, n2);
            break;
          case "ascii":
          case "binary":
            r2 = function(e4, t4, n3) {
              var r3 = "";
              n3 = Math.min(e4.length, n3);
              for (var i3 = t4; i3 < n3; i3++)
                r3 += String.fromCharCode(e4[i3]);
              return r3;
            }(a2, t3, n2);
            break;
          case "base64":
            i2 = a2, o2 = n2, r2 = 0 === (s2 = t3) && o2 === i2.length ? p.fromByteArray(i2) : p.fromByteArray(i2.slice(s2, o2));
            break;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            r2 = function(e4, t4, n3) {
              for (var r3 = e4.slice(t4, n3), i3 = "", s3 = 0; s3 < r3.length; s3 += 2)
                i3 += String.fromCharCode(r3[s3] + 256 * r3[s3 + 1]);
              return i3;
            }(a2, t3, n2);
            break;
          default:
            throw new Error("Unknown encoding");
        }
        return r2;
      }, i.prototype.toJSON = function() {
        return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
      }, i.prototype.copy = function(e3, t3, n2, r2) {
        if (n2 = n2 || 0, r2 || 0 === r2 || (r2 = this.length), t3 = t3 || 0, r2 !== n2 && 0 !== e3.length && 0 !== this.length) {
          U(n2 <= r2, "sourceEnd < sourceStart"), U(0 <= t3 && t3 < e3.length, "targetStart out of bounds"), U(0 <= n2 && n2 < this.length, "sourceStart out of bounds"), U(0 <= r2 && r2 <= this.length, "sourceEnd out of bounds"), r2 > this.length && (r2 = this.length), e3.length - t3 < r2 - n2 && (r2 = e3.length - t3 + n2);
          var s2 = r2 - n2;
          if (s2 < 100 || !i._useTypedArrays)
            for (var o2 = 0; o2 < s2; o2++)
              e3[o2 + t3] = this[o2 + n2];
          else
            e3._set(this.subarray(n2, n2 + s2), t3);
        }
      }, i.prototype.slice = function(e3, t3) {
        var n2 = this.length;
        if (e3 = S(e3, n2, 0), t3 = S(t3, n2, n2), i._useTypedArrays)
          return i._augment(this.subarray(e3, t3));
        for (var r2 = t3 - e3, s2 = new i(r2, void 0, true), o2 = 0; o2 < r2; o2++)
          s2[o2] = this[o2 + e3];
        return s2;
      }, i.prototype.get = function(e3) {
        return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(e3);
      }, i.prototype.set = function(e3, t3) {
        return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(e3, t3);
      }, i.prototype.readUInt8 = function(e3, t3) {
        if (t3 || (U(null != e3, "missing offset"), U(e3 < this.length, "Trying to read beyond buffer length")), !(e3 >= this.length))
          return this[e3];
      }, i.prototype.readUInt16LE = function(e3, t3) {
        return h(this, e3, true, t3);
      }, i.prototype.readUInt16BE = function(e3, t3) {
        return h(this, e3, false, t3);
      }, i.prototype.readUInt32LE = function(e3, t3) {
        return f(this, e3, true, t3);
      }, i.prototype.readUInt32BE = function(e3, t3) {
        return f(this, e3, false, t3);
      }, i.prototype.readInt8 = function(e3, t3) {
        if (t3 || (U(null != e3, "missing offset"), U(e3 < this.length, "Trying to read beyond buffer length")), !(e3 >= this.length))
          return 128 & this[e3] ? -1 * (255 - this[e3] + 1) : this[e3];
      }, i.prototype.readInt16LE = function(e3, t3) {
        return m(this, e3, true, t3);
      }, i.prototype.readInt16BE = function(e3, t3) {
        return m(this, e3, false, t3);
      }, i.prototype.readInt32LE = function(e3, t3) {
        return _(this, e3, true, t3);
      }, i.prototype.readInt32BE = function(e3, t3) {
        return _(this, e3, false, t3);
      }, i.prototype.readFloatLE = function(e3, t3) {
        return g(this, e3, true, t3);
      }, i.prototype.readFloatBE = function(e3, t3) {
        return g(this, e3, false, t3);
      }, i.prototype.readDoubleLE = function(e3, t3) {
        return v(this, e3, true, t3);
      }, i.prototype.readDoubleBE = function(e3, t3) {
        return v(this, e3, false, t3);
      }, i.prototype.writeUInt8 = function(e3, t3, n2) {
        n2 || (U(null != e3, "missing value"), U(null != t3, "missing offset"), U(t3 < this.length, "trying to write beyond buffer length"), B(e3, 255)), t3 >= this.length || (this[t3] = e3);
      }, i.prototype.writeUInt16LE = function(e3, t3, n2) {
        y(this, e3, t3, true, n2);
      }, i.prototype.writeUInt16BE = function(e3, t3, n2) {
        y(this, e3, t3, false, n2);
      }, i.prototype.writeUInt32LE = function(e3, t3, n2) {
        b(this, e3, t3, true, n2);
      }, i.prototype.writeUInt32BE = function(e3, t3, n2) {
        b(this, e3, t3, false, n2);
      }, i.prototype.writeInt8 = function(e3, t3, n2) {
        n2 || (U(null != e3, "missing value"), U(null != t3, "missing offset"), U(t3 < this.length, "Trying to write beyond buffer length"), O(e3, 127, -128)), t3 >= this.length || (0 <= e3 ? this.writeUInt8(e3, t3, n2) : this.writeUInt8(255 + e3 + 1, t3, n2));
      }, i.prototype.writeInt16LE = function(e3, t3, n2) {
        w(this, e3, t3, true, n2);
      }, i.prototype.writeInt16BE = function(e3, t3, n2) {
        w(this, e3, t3, false, n2);
      }, i.prototype.writeInt32LE = function(e3, t3, n2) {
        A(this, e3, t3, true, n2);
      }, i.prototype.writeInt32BE = function(e3, t3, n2) {
        A(this, e3, t3, false, n2);
      }, i.prototype.writeFloatLE = function(e3, t3, n2) {
        x(this, e3, t3, true, n2);
      }, i.prototype.writeFloatBE = function(e3, t3, n2) {
        x(this, e3, t3, false, n2);
      }, i.prototype.writeDoubleLE = function(e3, t3, n2) {
        E(this, e3, t3, true, n2);
      }, i.prototype.writeDoubleBE = function(e3, t3, n2) {
        E(this, e3, t3, false, n2);
      }, i.prototype.fill = function(e3, t3, n2) {
        if (e3 = e3 || 0, t3 = t3 || 0, n2 = n2 || this.length, "string" == typeof e3 && (e3 = e3.charCodeAt(0)), U("number" == typeof e3 && !isNaN(e3), "value is not a number"), U(t3 <= n2, "end < start"), n2 !== t3 && 0 !== this.length) {
          U(0 <= t3 && t3 < this.length, "start out of bounds"), U(0 <= n2 && n2 <= this.length, "end out of bounds");
          for (var r2 = t3; r2 < n2; r2++)
            this[r2] = e3;
        }
      }, i.prototype.inspect = function() {
        for (var e3 = [], t3 = this.length, r2 = 0; r2 < t3; r2++)
          if (e3[r2] = P(this[r2]), r2 === n.INSPECT_MAX_BYTES) {
            e3[r2 + 1] = "...";
            break;
          }
        return "<Buffer " + e3.join(" ") + ">";
      }, i.prototype.toArrayBuffer = function() {
        if ("undefined" == typeof Uint8Array)
          throw new Error("Buffer.toArrayBuffer not supported in this browser");
        if (i._useTypedArrays)
          return new i(this).buffer;
        for (var e3 = new Uint8Array(this.length), t3 = 0, n2 = e3.length; t3 < n2; t3 += 1)
          e3[t3] = this[t3];
        return e3.buffer;
      };
      var C = i.prototype;
      function S(e3, t3, n2) {
        return "number" != typeof e3 ? n2 : t3 <= (e3 = ~~e3) ? t3 : 0 <= e3 || 0 <= (e3 += t3) ? e3 : 0;
      }
      function M(e3) {
        return (e3 = ~~Math.ceil(+e3)) < 0 ? 0 : e3;
      }
      function T(e3) {
        return (Array.isArray || function(e4) {
          return "[object Array]" === Object.prototype.toString.call(e4);
        })(e3);
      }
      function P(e3) {
        return e3 < 16 ? "0" + e3.toString(16) : e3.toString(16);
      }
      function I(e3) {
        for (var t3 = [], n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3.charCodeAt(n2);
          if (r2 <= 127)
            t3.push(e3.charCodeAt(n2));
          else {
            var i2 = n2;
            55296 <= r2 && r2 <= 57343 && n2++;
            for (var s2 = encodeURIComponent(e3.slice(i2, n2 + 1)).substr(1).split("%"), o2 = 0; o2 < s2.length; o2++)
              t3.push(parseInt(s2[o2], 16));
          }
        }
        return t3;
      }
      function R(e3) {
        return p.toByteArray(e3);
      }
      function k(e3, t3, n2, r2) {
        for (var i2 = 0; i2 < r2 && !(i2 + n2 >= t3.length || i2 >= e3.length); i2++)
          t3[i2 + n2] = e3[i2];
        return i2;
      }
      function D(e3) {
        try {
          return decodeURIComponent(e3);
        } catch (e4) {
          return String.fromCharCode(65533);
        }
      }
      function B(e3, t3) {
        U("number" == typeof e3, "cannot write a non-number as a number"), U(0 <= e3, "specified a negative value for writing an unsigned value"), U(e3 <= t3, "value is larger than maximum value for type"), U(Math.floor(e3) === e3, "value has a fractional component");
      }
      function O(e3, t3, n2) {
        U("number" == typeof e3, "cannot write a non-number as a number"), U(e3 <= t3, "value larger than maximum allowed value"), U(n2 <= e3, "value smaller than minimum allowed value"), U(Math.floor(e3) === e3, "value has a fractional component");
      }
      function L(e3, t3, n2) {
        U("number" == typeof e3, "cannot write a non-number as a number"), U(e3 <= t3, "value larger than maximum allowed value"), U(n2 <= e3, "value smaller than minimum allowed value");
      }
      function U(e3, t3) {
        if (!e3)
          throw new Error(t3 || "Failed assertion");
      }
      i._augment = function(e3) {
        return e3._isBuffer = true, e3._get = e3.get, e3._set = e3.set, e3.get = C.get, e3.set = C.set, e3.write = C.write, e3.toString = C.toString, e3.toLocaleString = C.toString, e3.toJSON = C.toJSON, e3.copy = C.copy, e3.slice = C.slice, e3.readUInt8 = C.readUInt8, e3.readUInt16LE = C.readUInt16LE, e3.readUInt16BE = C.readUInt16BE, e3.readUInt32LE = C.readUInt32LE, e3.readUInt32BE = C.readUInt32BE, e3.readInt8 = C.readInt8, e3.readInt16LE = C.readInt16LE, e3.readInt16BE = C.readInt16BE, e3.readInt32LE = C.readInt32LE, e3.readInt32BE = C.readInt32BE, e3.readFloatLE = C.readFloatLE, e3.readFloatBE = C.readFloatBE, e3.readDoubleLE = C.readDoubleLE, e3.readDoubleBE = C.readDoubleBE, e3.writeUInt8 = C.writeUInt8, e3.writeUInt16LE = C.writeUInt16LE, e3.writeUInt16BE = C.writeUInt16BE, e3.writeUInt32LE = C.writeUInt32LE, e3.writeUInt32BE = C.writeUInt32BE, e3.writeInt8 = C.writeInt8, e3.writeInt16LE = C.writeInt16LE, e3.writeInt16BE = C.writeInt16BE, e3.writeInt32LE = C.writeInt32LE, e3.writeInt32BE = C.writeInt32BE, e3.writeFloatLE = C.writeFloatLE, e3.writeFloatBE = C.writeFloatBE, e3.writeDoubleLE = C.writeDoubleLE, e3.writeDoubleBE = C.writeDoubleBE, e3.fill = C.fill, e3.inspect = C.inspect, e3.toArrayBuffer = C.toArrayBuffer, e3;
      };
    }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer");
  }, { "base64-js": 2, buffer: 3, ieee754: 11, lYpoI2: 10 }], 4: [function(e2, t, n) {
    (function(n2, r, i, s, o, a, l, c, u) {
      i = e2("buffer").Buffer;
      var p = new i(4);
      p.fill(0), t.exports = { hash: function(e3, t2, n3, r2) {
        return i.isBuffer(e3) || (e3 = new i(e3)), function(e4, t3, n4) {
          for (var r3 = new i(t3), s2 = n4 ? r3.writeInt32BE : r3.writeInt32LE, o2 = 0; o2 < e4.length; o2++)
            s2.call(r3, e4[o2], 4 * o2, true);
          return r3;
        }(t2(function(e4, t3) {
          var n4;
          e4.length % 4 != 0 && (n4 = e4.length + (4 - e4.length % 4), e4 = i.concat([e4, p], n4));
          for (var r3 = [], s2 = t3 ? e4.readInt32BE : e4.readInt32LE, o2 = 0; o2 < e4.length; o2 += 4)
            r3.push(s2.call(e4, o2));
          return r3;
        }(e3, r2), 8 * e3.length), n3, r2);
      } };
    }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
  }, { buffer: 3, lYpoI2: 10 }], 5: [function(e2, t, n) {
    (function(t2, r, i, s, o, a, l, c, u) {
      i = e2("buffer").Buffer;
      var p = e2("./sha"), d = e2("./sha256"), h = e2("./rng"), f = { sha1: p, sha256: d, md5: e2("./md5") }, m = 64, _ = new i(m);
      function g(e3, t3) {
        var n2 = f[e3 = e3 || "sha1"], r2 = [];
        return n2 || v("algorithm:", e3, "is not yet supported"), { update: function(e4) {
          return i.isBuffer(e4) || (e4 = new i(e4)), r2.push(e4), e4.length, this;
        }, digest: function(e4) {
          var s2 = i.concat(r2), o2 = t3 ? function(e5, t4, n3) {
            i.isBuffer(t4) || (t4 = new i(t4)), i.isBuffer(n3) || (n3 = new i(n3)), t4.length > m ? t4 = e5(t4) : t4.length < m && (t4 = i.concat([t4, _], m));
            for (var r3 = new i(m), s3 = new i(m), o3 = 0; o3 < m; o3++)
              r3[o3] = 54 ^ t4[o3], s3[o3] = 92 ^ t4[o3];
            var a2 = e5(i.concat([r3, n3]));
            return e5(i.concat([s3, a2]));
          }(n2, t3, s2) : n2(s2);
          return r2 = null, e4 ? o2.toString(e4) : o2;
        } };
      }
      function v() {
        var e3 = [].slice.call(arguments).join(" ");
        throw new Error([e3, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join("\n"));
      }
      _.fill(0), n.createHash = function(e3) {
        return g(e3);
      }, n.createHmac = g, n.randomBytes = function(e3, t3) {
        if (!t3 || !t3.call)
          return new i(h(e3));
        try {
          t3.call(this, void 0, new i(h(e3)));
        } catch (e4) {
          t3(e4);
        }
      }, function(e3, t3) {
        for (var n2 in e3)
          t3(e3[n2]);
      }(["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], function(e3) {
        n[e3] = function() {
          v("sorry,", e3, "is not implemented yet");
        };
      });
    }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
  }, { "./md5": 6, "./rng": 7, "./sha": 8, "./sha256": 9, buffer: 3, lYpoI2: 10 }], 6: [function(e2, t, n) {
    (function(n2, r, i, s, o, a, l, c, u) {
      var p = e2("./helpers");
      function d(e3, t2) {
        e3[t2 >> 5] |= 128 << t2 % 32, e3[14 + (t2 + 64 >>> 9 << 4)] = t2;
        for (var n3 = 1732584193, r2 = -271733879, i2 = -1732584194, s2 = 271733878, o2 = 0; o2 < e3.length; o2 += 16) {
          var a2 = n3, l2 = r2, c2 = i2, u2 = s2;
          n3 = f(n3, r2, i2, s2, e3[o2 + 0], 7, -680876936), s2 = f(s2, n3, r2, i2, e3[o2 + 1], 12, -389564586), i2 = f(i2, s2, n3, r2, e3[o2 + 2], 17, 606105819), r2 = f(r2, i2, s2, n3, e3[o2 + 3], 22, -1044525330), n3 = f(n3, r2, i2, s2, e3[o2 + 4], 7, -176418897), s2 = f(s2, n3, r2, i2, e3[o2 + 5], 12, 1200080426), i2 = f(i2, s2, n3, r2, e3[o2 + 6], 17, -1473231341), r2 = f(r2, i2, s2, n3, e3[o2 + 7], 22, -45705983), n3 = f(n3, r2, i2, s2, e3[o2 + 8], 7, 1770035416), s2 = f(s2, n3, r2, i2, e3[o2 + 9], 12, -1958414417), i2 = f(i2, s2, n3, r2, e3[o2 + 10], 17, -42063), r2 = f(r2, i2, s2, n3, e3[o2 + 11], 22, -1990404162), n3 = f(n3, r2, i2, s2, e3[o2 + 12], 7, 1804603682), s2 = f(s2, n3, r2, i2, e3[o2 + 13], 12, -40341101), i2 = f(i2, s2, n3, r2, e3[o2 + 14], 17, -1502002290), n3 = m(n3, r2 = f(r2, i2, s2, n3, e3[o2 + 15], 22, 1236535329), i2, s2, e3[o2 + 1], 5, -165796510), s2 = m(s2, n3, r2, i2, e3[o2 + 6], 9, -1069501632), i2 = m(i2, s2, n3, r2, e3[o2 + 11], 14, 643717713), r2 = m(r2, i2, s2, n3, e3[o2 + 0], 20, -373897302), n3 = m(n3, r2, i2, s2, e3[o2 + 5], 5, -701558691), s2 = m(s2, n3, r2, i2, e3[o2 + 10], 9, 38016083), i2 = m(i2, s2, n3, r2, e3[o2 + 15], 14, -660478335), r2 = m(r2, i2, s2, n3, e3[o2 + 4], 20, -405537848), n3 = m(n3, r2, i2, s2, e3[o2 + 9], 5, 568446438), s2 = m(s2, n3, r2, i2, e3[o2 + 14], 9, -1019803690), i2 = m(i2, s2, n3, r2, e3[o2 + 3], 14, -187363961), r2 = m(r2, i2, s2, n3, e3[o2 + 8], 20, 1163531501), n3 = m(n3, r2, i2, s2, e3[o2 + 13], 5, -1444681467), s2 = m(s2, n3, r2, i2, e3[o2 + 2], 9, -51403784), i2 = m(i2, s2, n3, r2, e3[o2 + 7], 14, 1735328473), n3 = _(n3, r2 = m(r2, i2, s2, n3, e3[o2 + 12], 20, -1926607734), i2, s2, e3[o2 + 5], 4, -378558), s2 = _(s2, n3, r2, i2, e3[o2 + 8], 11, -2022574463), i2 = _(i2, s2, n3, r2, e3[o2 + 11], 16, 1839030562), r2 = _(r2, i2, s2, n3, e3[o2 + 14], 23, -35309556), n3 = _(n3, r2, i2, s2, e3[o2 + 1], 4, -1530992060), s2 = _(s2, n3, r2, i2, e3[o2 + 4], 11, 1272893353), i2 = _(i2, s2, n3, r2, e3[o2 + 7], 16, -155497632), r2 = _(r2, i2, s2, n3, e3[o2 + 10], 23, -1094730640), n3 = _(n3, r2, i2, s2, e3[o2 + 13], 4, 681279174), s2 = _(s2, n3, r2, i2, e3[o2 + 0], 11, -358537222), i2 = _(i2, s2, n3, r2, e3[o2 + 3], 16, -722521979), r2 = _(r2, i2, s2, n3, e3[o2 + 6], 23, 76029189), n3 = _(n3, r2, i2, s2, e3[o2 + 9], 4, -640364487), s2 = _(s2, n3, r2, i2, e3[o2 + 12], 11, -421815835), i2 = _(i2, s2, n3, r2, e3[o2 + 15], 16, 530742520), n3 = g(n3, r2 = _(r2, i2, s2, n3, e3[o2 + 2], 23, -995338651), i2, s2, e3[o2 + 0], 6, -198630844), s2 = g(s2, n3, r2, i2, e3[o2 + 7], 10, 1126891415), i2 = g(i2, s2, n3, r2, e3[o2 + 14], 15, -1416354905), r2 = g(r2, i2, s2, n3, e3[o2 + 5], 21, -57434055), n3 = g(n3, r2, i2, s2, e3[o2 + 12], 6, 1700485571), s2 = g(s2, n3, r2, i2, e3[o2 + 3], 10, -1894986606), i2 = g(i2, s2, n3, r2, e3[o2 + 10], 15, -1051523), r2 = g(r2, i2, s2, n3, e3[o2 + 1], 21, -2054922799), n3 = g(n3, r2, i2, s2, e3[o2 + 8], 6, 1873313359), s2 = g(s2, n3, r2, i2, e3[o2 + 15], 10, -30611744), i2 = g(i2, s2, n3, r2, e3[o2 + 6], 15, -1560198380), r2 = g(r2, i2, s2, n3, e3[o2 + 13], 21, 1309151649), n3 = g(n3, r2, i2, s2, e3[o2 + 4], 6, -145523070), s2 = g(s2, n3, r2, i2, e3[o2 + 11], 10, -1120210379), i2 = g(i2, s2, n3, r2, e3[o2 + 2], 15, 718787259), r2 = g(r2, i2, s2, n3, e3[o2 + 9], 21, -343485551), n3 = v(n3, a2), r2 = v(r2, l2), i2 = v(i2, c2), s2 = v(s2, u2);
        }
        return Array(n3, r2, i2, s2);
      }
      function h(e3, t2, n3, r2, i2, s2) {
        return v((o2 = v(v(t2, e3), v(r2, s2))) << (a2 = i2) | o2 >>> 32 - a2, n3);
        var o2, a2;
      }
      function f(e3, t2, n3, r2, i2, s2, o2) {
        return h(t2 & n3 | ~t2 & r2, e3, t2, i2, s2, o2);
      }
      function m(e3, t2, n3, r2, i2, s2, o2) {
        return h(t2 & r2 | n3 & ~r2, e3, t2, i2, s2, o2);
      }
      function _(e3, t2, n3, r2, i2, s2, o2) {
        return h(t2 ^ n3 ^ r2, e3, t2, i2, s2, o2);
      }
      function g(e3, t2, n3, r2, i2, s2, o2) {
        return h(n3 ^ (t2 | ~r2), e3, t2, i2, s2, o2);
      }
      function v(e3, t2) {
        var n3 = (65535 & e3) + (65535 & t2);
        return (e3 >> 16) + (t2 >> 16) + (n3 >> 16) << 16 | 65535 & n3;
      }
      t.exports = function(e3) {
        return p.hash(e3, d, 16);
      };
    }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
  }, { "./helpers": 4, buffer: 3, lYpoI2: 10 }], 7: [function(e2, t, n) {
    (function(e3, n2, r, i, s, o, a, l, c) {
      var u;
      u = function(e4) {
        for (var t2, n3 = new Array(e4), r2 = 0; r2 < e4; r2++)
          0 == (3 & r2) && (t2 = 4294967296 * Math.random()), n3[r2] = t2 >>> ((3 & r2) << 3) & 255;
        return n3;
      }, t.exports = u;
    }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
  }, { buffer: 3, lYpoI2: 10 }], 8: [function(e2, t, n) {
    (function(n2, r, i, s, o, a, l, c, u) {
      var p = e2("./helpers");
      function d(e3, t2) {
        e3[t2 >> 5] |= 128 << 24 - t2 % 32, e3[15 + (t2 + 64 >> 9 << 4)] = t2;
        for (var n3, r2, i2, s2, o2, a2 = Array(80), l2 = 1732584193, c2 = -271733879, u2 = -1732584194, p2 = 271733878, d2 = -1009589776, m = 0; m < e3.length; m += 16) {
          for (var _ = l2, g = c2, v = u2, y = p2, b = d2, w = 0; w < 80; w++) {
            a2[w] = w < 16 ? e3[m + w] : f(a2[w - 3] ^ a2[w - 8] ^ a2[w - 14] ^ a2[w - 16], 1);
            var A = h(h(f(l2, 5), (i2 = c2, s2 = u2, o2 = p2, (r2 = w) < 20 ? i2 & s2 | ~i2 & o2 : !(r2 < 40) && r2 < 60 ? i2 & s2 | i2 & o2 | s2 & o2 : i2 ^ s2 ^ o2)), h(h(d2, a2[w]), (n3 = w) < 20 ? 1518500249 : n3 < 40 ? 1859775393 : n3 < 60 ? -1894007588 : -899497514));
            d2 = p2, p2 = u2, u2 = f(c2, 30), c2 = l2, l2 = A;
          }
          l2 = h(l2, _), c2 = h(c2, g), u2 = h(u2, v), p2 = h(p2, y), d2 = h(d2, b);
        }
        return Array(l2, c2, u2, p2, d2);
      }
      function h(e3, t2) {
        var n3 = (65535 & e3) + (65535 & t2);
        return (e3 >> 16) + (t2 >> 16) + (n3 >> 16) << 16 | 65535 & n3;
      }
      function f(e3, t2) {
        return e3 << t2 | e3 >>> 32 - t2;
      }
      t.exports = function(e3) {
        return p.hash(e3, d, 20, true);
      };
    }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
  }, { "./helpers": 4, buffer: 3, lYpoI2: 10 }], 9: [function(e2, t, n) {
    (function(n2, r, i, s, o, a, l, c, u) {
      function p(e3, t2) {
        var n3 = (65535 & e3) + (65535 & t2);
        return (e3 >> 16) + (t2 >> 16) + (n3 >> 16) << 16 | 65535 & n3;
      }
      function d(e3, t2) {
        return e3 >>> t2 | e3 << 32 - t2;
      }
      function h(e3, t2) {
        var n3, r2, i2, s2, o2, a2, l2, c2, u2, h2, f2 = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298), m = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225), _ = new Array(64);
        e3[t2 >> 5] |= 128 << 24 - t2 % 32, e3[15 + (t2 + 64 >> 9 << 4)] = t2;
        for (var g, v, y, b, w, A, x, E, C = 0; C < e3.length; C += 16) {
          n3 = m[0], r2 = m[1], i2 = m[2], s2 = m[3], o2 = m[4], a2 = m[5], l2 = m[6], c2 = m[7];
          for (var S = 0; S < 64; S++)
            _[S] = S < 16 ? e3[S + C] : p(p(p(d(E = _[S - 2], 17) ^ d(E, 19) ^ E >>> 10, _[S - 7]), d(x = _[S - 15], 7) ^ d(x, 18) ^ x >>> 3), _[S - 16]), u2 = p(p(p(p(c2, d(A = o2, 6) ^ d(A, 11) ^ d(A, 25)), (w = o2) & a2 ^ ~w & l2), f2[S]), _[S]), h2 = p(d(b = n3, 2) ^ d(b, 13) ^ d(b, 22), (g = n3) & (v = r2) ^ g & (y = i2) ^ v & y), c2 = l2, l2 = a2, a2 = o2, o2 = p(s2, u2), s2 = i2, i2 = r2, r2 = n3, n3 = p(u2, h2);
          m[0] = p(n3, m[0]), m[1] = p(r2, m[1]), m[2] = p(i2, m[2]), m[3] = p(s2, m[3]), m[4] = p(o2, m[4]), m[5] = p(a2, m[5]), m[6] = p(l2, m[6]), m[7] = p(c2, m[7]);
        }
        return m;
      }
      var f = e2("./helpers");
      t.exports = function(e3) {
        return f.hash(e3, h, 32, true);
      };
    }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
  }, { "./helpers": 4, buffer: 3, lYpoI2: 10 }], 10: [function(e2, t, n) {
    (function(e3, n2, r, i, s, o, a, l, c) {
      function u() {
      }
      (e3 = t.exports = {}).nextTick = function() {
        var e4 = "undefined" != typeof window && window.setImmediate, t2 = "undefined" != typeof window && window.postMessage && window.addEventListener;
        if (e4)
          return function(e5) {
            return window.setImmediate(e5);
          };
        if (t2) {
          var n3 = [];
          return window.addEventListener("message", function(e5) {
            var t3 = e5.source;
            t3 !== window && null !== t3 || "process-tick" !== e5.data || (e5.stopPropagation(), 0 < n3.length && n3.shift()());
          }, true), function(e5) {
            n3.push(e5), window.postMessage("process-tick", "*");
          };
        }
        return function(e5) {
          setTimeout(e5, 0);
        };
      }(), e3.title = "browser", e3.browser = true, e3.env = {}, e3.argv = [], e3.on = u, e3.addListener = u, e3.once = u, e3.off = u, e3.removeListener = u, e3.removeAllListeners = u, e3.emit = u, e3.binding = function(e4) {
        throw new Error("process.binding is not supported");
      }, e3.cwd = function() {
        return "/";
      }, e3.chdir = function(e4) {
        throw new Error("process.chdir is not supported");
      };
    }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process");
  }, { buffer: 3, lYpoI2: 10 }], 11: [function(e2, t, n) {
    (function(e3, t2, r, i, s, o, a, l, c) {
      n.read = function(e4, t3, n2, r2, i2) {
        var s2, o2, a2 = 8 * i2 - r2 - 1, l2 = (1 << a2) - 1, c2 = l2 >> 1, u = -7, p = n2 ? i2 - 1 : 0, d = n2 ? -1 : 1, h = e4[t3 + p];
        for (p += d, s2 = h & (1 << -u) - 1, h >>= -u, u += a2; 0 < u; s2 = 256 * s2 + e4[t3 + p], p += d, u -= 8)
          ;
        for (o2 = s2 & (1 << -u) - 1, s2 >>= -u, u += r2; 0 < u; o2 = 256 * o2 + e4[t3 + p], p += d, u -= 8)
          ;
        if (0 === s2)
          s2 = 1 - c2;
        else {
          if (s2 === l2)
            return o2 ? NaN : 1 / 0 * (h ? -1 : 1);
          o2 += Math.pow(2, r2), s2 -= c2;
        }
        return (h ? -1 : 1) * o2 * Math.pow(2, s2 - r2);
      }, n.write = function(e4, t3, n2, r2, i2, s2) {
        var o2, a2, l2, c2 = 8 * s2 - i2 - 1, u = (1 << c2) - 1, p = u >> 1, d = 23 === i2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, h = r2 ? 0 : s2 - 1, f = r2 ? 1 : -1, m = t3 < 0 || 0 === t3 && 1 / t3 < 0 ? 1 : 0;
        for (t3 = Math.abs(t3), isNaN(t3) || t3 === 1 / 0 ? (a2 = isNaN(t3) ? 1 : 0, o2 = u) : (o2 = Math.floor(Math.log(t3) / Math.LN2), t3 * (l2 = Math.pow(2, -o2)) < 1 && (o2--, l2 *= 2), 2 <= (t3 += 1 <= o2 + p ? d / l2 : d * Math.pow(2, 1 - p)) * l2 && (o2++, l2 /= 2), u <= o2 + p ? (a2 = 0, o2 = u) : 1 <= o2 + p ? (a2 = (t3 * l2 - 1) * Math.pow(2, i2), o2 += p) : (a2 = t3 * Math.pow(2, p - 1) * Math.pow(2, i2), o2 = 0)); 8 <= i2; e4[n2 + h] = 255 & a2, h += f, a2 /= 256, i2 -= 8)
          ;
        for (o2 = o2 << i2 | a2, c2 += i2; 0 < c2; e4[n2 + h] = 255 & o2, h += f, o2 /= 256, c2 -= 8)
          ;
        e4[n2 + h - f] |= 128 * m;
      };
    }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/ieee754/index.js", "/node_modules/ieee754");
  }, { buffer: 3, lYpoI2: 10 }] }, {}, [1])(1);
}, 654: function(e) {
  var t = function() {
    function e2(e3) {
      return l(e3, c(a(u(e3.length), e3), 1 / e3.length));
    }
    function t2(e3) {
      return a(p(e3), e3);
    }
    function n(e3, t3) {
      return c(e3, t3 ? 1 / (e3.length - 1) : 1 / e3.length);
    }
    function r(e3) {
      var t3 = function(e4) {
        var t4, n3 = Math.pow(2, -52), r2 = 1e-64 / n3, i2 = 0, s2 = 0, o2 = 0, a2 = 0, l2 = 0, c2 = d(e4), u2 = c2.length, p2 = c2[0].length;
        if (u2 < p2)
          throw "Need more rows than columns";
        var h = new Array(p2), f = new Array(p2);
        for (s2 = 0; s2 < p2; s2++)
          h[s2] = f[s2] = 0;
        var m = function e5(t5, n4, r3) {
          void 0 === r3 && (r3 = 0);
          var i3, s3 = t5[r3], o3 = Array(s3);
          if (r3 === t5.length - 1) {
            for (i3 = s3 - 2; i3 >= 0; i3 -= 2)
              o3[i3 + 1] = n4, o3[i3] = n4;
            return -1 === i3 && (o3[0] = n4), o3;
          }
          for (i3 = s3 - 1; i3 >= 0; i3--)
            o3[i3] = e5(t5, n4, r3 + 1);
          return o3;
        }([p2, p2], 0);
        function _(e5, t5) {
          return (e5 = Math.abs(e5)) > (t5 = Math.abs(t5)) ? e5 * Math.sqrt(1 + t5 * t5 / e5 / e5) : 0 == t5 ? e5 : t5 * Math.sqrt(1 + e5 * e5 / t5 / t5);
        }
        var g = 0, v = 0, y = 0, b = 0, w = 0, A = 0, x = 0;
        for (s2 = 0; s2 < p2; s2++) {
          for (h[s2] = v, x = 0, l2 = s2 + 1, o2 = s2; o2 < u2; o2++)
            x += c2[o2][s2] * c2[o2][s2];
          if (x <= r2)
            v = 0;
          else
            for (g = c2[s2][s2], v = Math.sqrt(x), g >= 0 && (v = -v), y = g * v - x, c2[s2][s2] = g - v, o2 = l2; o2 < p2; o2++) {
              for (x = 0, a2 = s2; a2 < u2; a2++)
                x += c2[a2][s2] * c2[a2][o2];
              for (g = x / y, a2 = s2; a2 < u2; a2++)
                c2[a2][o2] += g * c2[a2][s2];
            }
          for (f[s2] = v, x = 0, o2 = l2; o2 < p2; o2++)
            x += c2[s2][o2] * c2[s2][o2];
          if (x <= r2)
            v = 0;
          else {
            for (g = c2[s2][s2 + 1], v = Math.sqrt(x), g >= 0 && (v = -v), y = g * v - x, c2[s2][s2 + 1] = g - v, o2 = l2; o2 < p2; o2++)
              h[o2] = c2[s2][o2] / y;
            for (o2 = l2; o2 < u2; o2++) {
              for (x = 0, a2 = l2; a2 < p2; a2++)
                x += c2[o2][a2] * c2[s2][a2];
              for (a2 = l2; a2 < p2; a2++)
                c2[o2][a2] += x * h[a2];
            }
          }
          (w = Math.abs(f[s2]) + Math.abs(h[s2])) > b && (b = w);
        }
        for (s2 = p2 - 1; -1 != s2; s2 += -1) {
          if (0 != v) {
            for (y = v * c2[s2][s2 + 1], o2 = l2; o2 < p2; o2++)
              m[o2][s2] = c2[s2][o2] / y;
            for (o2 = l2; o2 < p2; o2++) {
              for (x = 0, a2 = l2; a2 < p2; a2++)
                x += c2[s2][a2] * m[a2][o2];
              for (a2 = l2; a2 < p2; a2++)
                m[a2][o2] += x * m[a2][s2];
            }
          }
          for (o2 = l2; o2 < p2; o2++)
            m[s2][o2] = 0, m[o2][s2] = 0;
          m[s2][s2] = 1, v = h[s2], l2 = s2;
        }
        for (s2 = p2 - 1; -1 != s2; s2 += -1) {
          for (l2 = s2 + 1, v = f[s2], o2 = l2; o2 < p2; o2++)
            c2[s2][o2] = 0;
          if (0 != v) {
            for (y = c2[s2][s2] * v, o2 = l2; o2 < p2; o2++) {
              for (x = 0, a2 = l2; a2 < u2; a2++)
                x += c2[a2][s2] * c2[a2][o2];
              for (g = x / y, a2 = s2; a2 < u2; a2++)
                c2[a2][o2] += g * c2[a2][s2];
            }
            for (o2 = s2; o2 < u2; o2++)
              c2[o2][s2] = c2[o2][s2] / v;
          } else
            for (o2 = s2; o2 < u2; o2++)
              c2[o2][s2] = 0;
          c2[s2][s2] += 1;
        }
        for (n3 *= b, a2 = p2 - 1; -1 != a2; a2 += -1)
          for (var E = 0; E < 50; E++) {
            var C = false;
            for (l2 = a2; -1 != l2; l2 += -1) {
              if (Math.abs(h[l2]) <= n3) {
                C = true;
                break;
              }
              if (Math.abs(f[l2 - 1]) <= n3)
                break;
            }
            if (!C) {
              i2 = 0, x = 1;
              var S = l2 - 1;
              for (s2 = l2; s2 < a2 + 1 && (g = x * h[s2], h[s2] = i2 * h[s2], !(Math.abs(g) <= n3)); s2++)
                for (y = _(g, v = f[s2]), f[s2] = y, i2 = v / y, x = -g / y, o2 = 0; o2 < u2; o2++)
                  w = c2[o2][S], A = c2[o2][s2], c2[o2][S] = w * i2 + A * x, c2[o2][s2] = -w * x + A * i2;
            }
            if (A = f[a2], l2 == a2) {
              if (A < 0)
                for (f[a2] = -A, o2 = 0; o2 < p2; o2++)
                  m[o2][a2] = -m[o2][a2];
              break;
            }
            if (E >= 49)
              throw "Error: no convergence.";
            for (b = f[l2], v = _(g = (((w = f[a2 - 1]) - A) * (w + A) + ((v = h[a2 - 1]) - (y = h[a2])) * (v + y)) / (2 * y * w), 1), g = g < 0 ? ((b - A) * (b + A) + y * (w / (g - v) - y)) / b : ((b - A) * (b + A) + y * (w / (g + v) - y)) / b, i2 = 1, x = 1, s2 = l2 + 1; s2 < a2 + 1; s2++) {
              for (v = h[s2], w = f[s2], y = x * v, v *= i2, A = _(g, y), h[s2 - 1] = A, g = b * (i2 = g / A) + v * (x = y / A), v = -b * x + v * i2, y = w * x, w *= i2, o2 = 0; o2 < p2; o2++)
                b = m[o2][s2 - 1], A = m[o2][s2], m[o2][s2 - 1] = b * i2 + A * x, m[o2][s2] = -b * x + A * i2;
              for (A = _(g, y), f[s2 - 1] = A, g = (i2 = g / A) * v + (x = y / A) * w, b = -x * v + i2 * w, o2 = 0; o2 < u2; o2++)
                w = c2[o2][s2 - 1], A = c2[o2][s2], c2[o2][s2 - 1] = w * i2 + A * x, c2[o2][s2] = -w * x + A * i2;
            }
            h[l2] = 0, h[a2] = g, f[a2] = b;
          }
        for (s2 = 0; s2 < f.length; s2++)
          f[s2] < n3 && (f[s2] = 0);
        for (s2 = 0; s2 < p2; s2++)
          for (o2 = s2 - 1; o2 >= 0; o2--)
            if (f[o2] < f[s2]) {
              for (i2 = f[o2], f[o2] = f[s2], f[s2] = i2, a2 = 0; a2 < c2.length; a2++)
                t4 = c2[a2][s2], c2[a2][s2] = c2[a2][o2], c2[a2][o2] = t4;
              for (a2 = 0; a2 < m.length; a2++)
                t4 = m[a2][s2], m[a2][s2] = m[a2][o2], m[a2][o2] = t4;
              s2 = o2;
            }
        return { U: c2, S: f, V: m };
      }(e3);
      console.log(t3);
      var n2 = t3.U;
      return t3.S.map(function(e4, t4) {
        var r2 = {};
        return r2.eigenvalue = e4, r2.vector = n2.map(function(e5, n3) {
          return -1 * e5[t4];
        }), r2;
      });
    }
    function i(t3, ...n2) {
      var r2 = n2.map(function(e3) {
        return e3.vector;
      }), i2 = a(r2, p(e2(t3))), s2 = c(a(u(t3.length), t3), -1 / t3.length);
      return { adjustedData: i2, formattedAdjustedData: o(i2, 2), avgData: s2, selectedVectors: r2 };
    }
    function s(i2) {
      return r(n(t2(e2(i2)), false));
    }
    function o(e3, t3) {
      var n2 = Math.pow(10, t3 || 2);
      return e3.map(function(e4, t4) {
        return e4.map(function(e5) {
          return Math.round(e5 * n2) / n2;
        });
      });
    }
    function a(e3, t3) {
      if (!(e3[0] && t3[0] && e3.length && t3.length))
        throw new Error("Both A and B should be matrices");
      if (t3.length !== e3[0].length)
        throw new Error("Columns in A should be the same as the number of rows in B");
      for (var n2 = [], r2 = 0; r2 < e3.length; r2++) {
        n2[r2] = [];
        for (var i2 = 0; i2 < t3[0].length; i2++)
          for (var s2 = 0; s2 < e3[0].length; s2++)
            n2[r2][i2] = n2[r2][i2] ? n2[r2][i2] + e3[r2][s2] * t3[s2][i2] : e3[r2][s2] * t3[s2][i2];
      }
      return n2;
    }
    function l(e3, t3) {
      if (e3.length !== t3.length || e3[0].length !== t3[0].length)
        throw new Error("Both A and B should have the same dimensions");
      for (var n2 = [], r2 = 0; r2 < e3.length; r2++) {
        n2[r2] = [];
        for (var i2 = 0; i2 < t3[0].length; i2++)
          n2[r2][i2] = e3[r2][i2] - t3[r2][i2];
      }
      return n2;
    }
    function c(e3, t3) {
      for (var n2 = [], r2 = 0; r2 < e3.length; r2++) {
        n2[r2] = [];
        for (var i2 = 0; i2 < e3[0].length; i2++)
          n2[r2][i2] = e3[r2][i2] * t3;
      }
      return n2;
    }
    function u(e3) {
      for (var t3 = [], n2 = 0; n2 < e3; n2++) {
        t3[n2] = [];
        for (var r2 = 0; r2 < e3; r2++)
          t3[n2][r2] = 1;
      }
      return t3;
    }
    function p(e3) {
      return d(e3)[0].map(function(t3, n2) {
        return e3.map(function(e4) {
          return e4[n2];
        });
      });
    }
    function d(e3) {
      var t3 = JSON.stringify(e3);
      return JSON.parse(t3);
    }
    return { computeDeviationScores: t2, computeDeviationMatrix: e2, computeSVD: r, computePercentageExplained: function(e3, ...t3) {
      var n2 = e3.map(function(e4) {
        return e4.eigenvalue;
      }).reduce(function(e4, t4) {
        return e4 + t4;
      });
      return t3.map(function(e4) {
        return e4.eigenvalue;
      }).reduce(function(e4, t4) {
        return e4 + t4;
      }) / n2;
    }, computeOriginalData: function(e3, t3, n2) {
      var r2 = l(p(a(p(t3), e3)), n2);
      return { originalData: r2, formattedOriginalData: o(r2, 2) };
    }, computeVarianceCovariance: n, computeAdjustedData: i, getEigenVectors: s, analyseTopResult: function(e3) {
      var t3 = s(e3).sort(function(e4, t4) {
        return t4.eigenvalue - e4.eigenvalue;
      });
      return console.log("Sorted Vectors", t3), i(e3, t3[0].vector);
    }, transpose: p, multiply: a, clone: d, scale: c };
  }();
  e.exports = t;
}, 701: function(e) {
  var t = [];
  function n(e2) {
    for (var n2 = -1, r2 = 0; r2 < t.length; r2++)
      if (t[r2].identifier === e2) {
        n2 = r2;
        break;
      }
    return n2;
  }
  function r(e2, r2) {
    for (var s = {}, o = [], a = 0; a < e2.length; a++) {
      var l = e2[a], c = r2.base ? l[0] + r2.base : l[0], u = s[c] || 0, p = "".concat(c, " ").concat(u);
      s[c] = u + 1;
      var d = n(p), h = { css: l[1], media: l[2], sourceMap: l[3], supports: l[4], layer: l[5] };
      if (-1 !== d)
        t[d].references++, t[d].updater(h);
      else {
        var f = i(h, r2);
        r2.byIndex = a, t.splice(a, 0, { identifier: p, updater: f, references: 1 });
      }
      o.push(p);
    }
    return o;
  }
  function i(e2, t2) {
    var n2 = t2.domAPI(t2);
    return n2.update(e2), function(t3) {
      if (t3) {
        if (t3.css === e2.css && t3.media === e2.media && t3.sourceMap === e2.sourceMap && t3.supports === e2.supports && t3.layer === e2.layer)
          return;
        n2.update(e2 = t3);
      } else
        n2.remove();
    };
  }
  e.exports = function(e2, i2) {
    var s = r(e2 = e2 || [], i2 = i2 || {});
    return function(e3) {
      e3 = e3 || [];
      for (var o = 0; o < s.length; o++) {
        var a = n(s[o]);
        t[a].references--;
      }
      for (var l = r(e3, i2), c = 0; c < s.length; c++) {
        var u = n(s[c]);
        0 === t[u].references && (t[u].updater(), t.splice(u, 1));
      }
      s = l;
    };
  };
}, 182: function(e) {
  e.exports = function(e2) {
    var t = document.createElement("style");
    return e2.setAttributes(t, e2.attributes), e2.insert(t, e2.options), t;
  };
}, 850: function(e, t, n) {
  e.exports = function(e2) {
    var t2 = n.nc;
    t2 && e2.setAttribute("nonce", t2);
  };
}, 236: function(e) {
  e.exports = function(e2) {
    var t = e2.insertStyleElement(e2);
    return { update: function(n) {
      !function(e3, t2, n2) {
        var r = "";
        n2.supports && (r += "@supports (".concat(n2.supports, ") {")), n2.media && (r += "@media ".concat(n2.media, " {"));
        var i = void 0 !== n2.layer;
        i && (r += "@layer".concat(n2.layer.length > 0 ? " ".concat(n2.layer) : "", " {")), r += n2.css, i && (r += "}"), n2.media && (r += "}"), n2.supports && (r += "}");
        var s = n2.sourceMap;
        s && "undefined" != typeof btoa && (r += "\n/", r += "*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(s)))), " *"), r += "/"), t2.styleTagTransform(r, e3, t2.options);
      }(t, e2, n);
    }, remove: function() {
      !function(e3) {
        if (null === e3.parentNode)
          return false;
        e3.parentNode.removeChild(e3);
      }(t);
    } };
  };
}, 213: function(e) {
  e.exports = function(e2, t) {
    if (t.styleSheet)
      t.styleSheet.cssText = e2;
    else {
      for (; t.firstChild; )
        t.removeChild(t.firstChild);
      t.appendChild(document.createTextNode(e2));
    }
  };
}, 1: function(e) {
  self, e.exports = function() {
    var e2 = { 820: function(e3, t2, n2) {
      var r2 = n2(537), i = n2.n(r2), s = n2(645), o = n2.n(s)()(i());
      o.push([e3.id, ".treejs {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  font-size: 14px;\n  margin-left: -18px;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}\n.treejs *:after,\n.treejs *:before {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n}\n.treejs > .treejs-node {\n  padding-left: 0;\n}\n.treejs .treejs-nodes {\n  list-style: none;\n  padding-left: 18px;\n  margin: 0;\n  overflow: hidden;\n  -webkit-transition: height 150ms ease-out, opacity 150ms ease-out;\n  -o-transition: height 150ms ease-out, opacity 150ms ease-out;\n  transition: height 150ms ease-out, opacity 150ms ease-out;\n}\n.treejs .treejs-node {\n  cursor: pointer;\n  overflow: hidden;\n}\n.treejs .treejs-node.treejs-placeholder {\n  padding-left: 18px;\n}\n.treejs .treejs-switcher {\n  display: inline-block;\n  vertical-align: middle;\n  width: 20px;\n  height: 20px;\n  cursor: pointer;\n  position: relative;\n  -webkit-transition: -webkit-transform 150ms ease-out;\n  transition: -webkit-transform 150ms ease-out;\n  -o-transition: transform 150ms ease-out;\n  transition: transform 150ms ease-out;\n  transition: transform 150ms ease-out, -webkit-transform 150ms ease-out;\n}\n.treejs .treejs-switcher:before {\n  position: absolute;\n  top: 8px;\n  left: 6px;\n  display: block;\n  content: ' ';\n  border: 4px solid transparent;\n  border-top: 4px solid rgba(245, 245, 245, 0.7);\n  -webkit-transition: border-color 150ms;\n  -o-transition: border-color 150ms;\n  transition: border-color 150ms;\n}\n.treejs .treejs-switcher:hover:before {\n  border-top: 4px solid rgba(245, 245, 245, 0.96);\n}\n.treejs .treejs-node__close > .treejs-switcher {\n  -webkit-transform: rotate(-90deg);\n      -ms-transform: rotate(-90deg);\n          transform: rotate(-90deg);\n}\n.treejs .treejs-node__close > .treejs-nodes {\n  height: 0;\n}\n.treejs .treejs-checkbox {\n  display: inline-block;\n  vertical-align: middle;\n  width: 20px;\n  height: 20px;\n  cursor: pointer;\n  position: relative;\n}\n.treejs .treejs-checkbox:before {\n  -webkit-transition: all 0.3s;\n  -o-transition: all 0.3s;\n  transition: all 0.3s;\n  cursor: pointer;\n  position: absolute;\n  top: 2px;\n  content: ' ';\n  display: block;\n  width: 16px;\n  height: 16px;\n  border: 1px solid #d9d9d9;\n  border-radius: 2px;\n}\n.treejs .treejs-checkbox:hover:before {\n  -webkit-box-shadow: 0 0 2px 1px #1890ff;\n          box-shadow: 0 0 2px 1px #1890ff;\n}\n.treejs .treejs-node__checked > .treejs-checkbox:before {\n  background-color: #1890ff;\n  border-color: #1890ff;\n}\n.treejs .treejs-node__checked > .treejs-checkbox:after {\n  position: absolute;\n  content: ' ';\n  display: block;\n  top: 4px;\n  left: 5px;\n  width: 5px;\n  height: 9px;\n  border: 2px solid #fff;\n  border-top: none;\n  border-left: none;\n  -webkit-transform: rotate(45deg);\n      -ms-transform: rotate(45deg);\n          transform: rotate(45deg);\n}\n.treejs .treejs-node__halfchecked > .treejs-checkbox:before {\n  background-color: #1890ff;\n  border-color: #1890ff;\n}\n.treejs .treejs-node__halfchecked > .treejs-checkbox:after {\n  position: absolute;\n  content: ' ';\n  display: block;\n  top: 9px;\n  left: 3px;\n  width: 10px;\n  height: 2px;\n  background-color: #fff;\n}\n.treejs .treejs-node__disabled {\n  cursor: not-allowed;\n  color: rgba(255, 255, 255, 0.25);\n}\n.treejs .treejs-node__disabled .treejs-checkbox {\n  cursor: not-allowed;\n}\n.treejs .treejs-node__disabled .treejs-checkbox:before {\n  cursor: not-allowed;\n  border-color: #d9d9d9 !important;\n  background-color: #f5f5f5 !important;\n}\n.treejs .treejs-node__disabled .treejs-checkbox:hover:before {\n  -webkit-box-shadow: none !important;\n          box-shadow: none !important;\n}\n.treejs .treejs-node__disabled .treejs-node__checked > .treejs-checkbox:after {\n  border-color: #d9d9d9;\n}\n.treejs .treejs-node__disabled .treejs-node__halfchecked > .treejs-checkbox:after {\n  background-color: #d9d9d9;\n}\n.treejs .treejs-node__disabled.treejs-node__checked > .treejs-checkbox:after {\n  border-color: #d9d9d9;\n}\n.treejs .treejs-node__disabled.treejs-node__halfchecked > .treejs-checkbox:after {\n  background-color: #d9d9d9;\n}\n.treejs .treejs-label {\n  vertical-align: middle;\n}\n", "", { version: 3, sources: ["webpack://./src/index.less"], names: [], mappings: "AAKA;EACE,8BAAA;UAAA,sBAAA;EACA,eAAA;EACA,kBAAA;EACA,yBAAA;KAAA,sBAAA;MAAA,qBAAA;UAAA,iBAAA;AAJF;AAAA;;EAQI,8BAAA;UAAA,sBAAA;AAJJ;AAOE;EACE,eAAA;AALJ;AAPA;EAgBI,gBAAA;EACA,kBAAA;EACA,SAAA;EACA,gBAAA;EACA,iEAAA;EAAA,4DAAA;EAAA,yDAAA;AANJ;AAdA;EAwBI,eAAA;EACA,gBAAA;AAPJ;AASI;EACE,kBAAA;AAPN;AArBA;EAiCI,qBAAA;EACA,sBAAA;EACA,WAAA;EACA,YAAA;EACA,eAAA;EACA,kBAAA;EACA,oDAAA;EAAA,4CAAA;EAAA,uCAAA;EAAA,oCAAA;EAAA,sEAAA;AATJ;AAWI;EACE,kBAAA;EACA,QAAA;EACA,SAAA;EACA,cAAA;EACA,YAAA;EACA,6BAAA;EACA,8CAAA;EACA,sCAAA;EAAA,iCAAA;EAAA,8BAAA;AATN;AAWI;EACE,+CAAA;AATN;AA3CA;EAwDI,iCAAA;MAAA,6BAAA;UAAA,yBAAA;AAVJ;AA9CA;EA2DI,SAAA;AAVJ;AAjDA;EA+DI,qBAAA;EACA,sBAAA;EACA,WAAA;EACA,YAAA;EACA,eAAA;EACA,kBAAA;AAXJ;AAaI;EACE,4BAAA;EAAA,uBAAA;EAAA,oBAAA;EACA,eAAA;EACA,kBAAA;EACA,QAAA;EACA,YAAA;EACA,cAAA;EACA,WAAA;EACA,YAAA;EACA,yBAAA;EACA,kBAAA;AAXN;AAaI;EACE,uCAAA;UAAA,+BAAA;AAXN;AAgBM;EACE,yBAAA;EACA,qBAAA;AAdR;AAgBM;EACE,kBAAA;EACA,YAAA;EACA,cAAA;EACA,QAAA;EACA,SAAA;EACA,UAAA;EACA,WAAA;EACA,sBAAA;EACA,gBAAA;EACA,iBAAA;EACA,gCAAA;MAAA,4BAAA;UAAA,wBAAA;AAdR;AAoBM;EACE,yBAAA;EACA,qBAAA;AAlBR;AAoBM;EACE,kBAAA;EACA,YAAA;EACA,cAAA;EACA,QAAA;EACA,SAAA;EACA,WAAA;EACA,WAAA;EACA,sBAAA;AAlBR;AAvGA;EA+HI,mBAAA;EACA,gCAAA;AArBJ;AA3GA;EAkIM,mBAAA;AApBN;AAqBM;EACE,mBAAA;EACA,gCAAA;EACA,oCAAA;AAnBR;AAqBM;EACE,mCAAA;UAAA,2BAAA;AAnBR;AAwBQ;EACE,qBAAA;AAtBV;AA4BQ;EACE,yBAAA;AA1BV;AAiCM;EACE,qBAAA;AA/BR;AAqCM;EACE,yBAAA;AAnCR;AAlIA;EA2KI,sBAAA;AAtCJ", sourcesContent: ["@color-disable: #d4d4d4;\n@bgcolor-disable: #f5f5f5;\n@greyborder: #d9d9d9;\n@bluebg: #1890ff;\n\n.treejs {\n  box-sizing: border-box;\n  font-size: 14px;\n  margin-left: -18px;\n  user-select: none;\n\n  *:after,\n  *:before {\n    box-sizing: border-box;\n  }\n\n  & > .treejs-node {\n    padding-left: 0;\n  }\n\n  .treejs-nodes {\n    list-style: none;\n    padding-left: 18px;\n    margin: 0; //  for default ul...\n    overflow: hidden;\n    transition: height 150ms ease-out, opacity 150ms ease-out;\n  }\n\n  .treejs-node {\n    cursor: pointer;\n    overflow: hidden;\n\n    &.treejs-placeholder {\n      padding-left: 18px;\n    }\n  }\n\n  .treejs-switcher {\n    display: inline-block;\n    vertical-align: middle;\n    width: 20px;\n    height: 20px;\n    cursor: pointer;\n    position: relative;\n    transition: transform 150ms ease-out;\n\n    &:before {\n      position: absolute;\n      top: 8px;\n      left: 6px;\n      display: block;\n      content: ' ';\n      border: 4px solid transparent;\n      border-top: 4px solid rgba(245, 245, 245, 0.7);\n      transition: border-color 150ms;\n    }\n    &:hover:before {\n      border-top: 4px solid rgba(245, 245, 245, 0.96);\n    }\n  }\n  .treejs-node__close > .treejs-switcher {\n    transform: rotate(-90deg);\n  }\n  .treejs-node__close > .treejs-nodes {\n    height: 0;\n  }\n\n  .treejs-checkbox {\n    display: inline-block;\n    vertical-align: middle;\n    width: 20px;\n    height: 20px;\n    cursor: pointer;\n    position: relative;\n\n    &:before {\n      transition: all 0.3s;\n      cursor: pointer;\n      position: absolute;\n      top: 2px;\n      content: ' ';\n      display: block;\n      width: 16px;\n      height: 16px;\n      border: 1px solid @greyborder;\n      border-radius: 2px;\n    }\n    &:hover:before {\n      box-shadow: 0 0 2px 1px @bluebg;\n    }\n  }\n  .treejs-node__checked {\n    & > .treejs-checkbox {\n      &:before {\n        background-color: @bluebg;\n        border-color: @bluebg;\n      }\n      &:after {\n        position: absolute;\n        content: ' ';\n        display: block;\n        top: 4px;\n        left: 5px;\n        width: 5px;\n        height: 9px;\n        border: 2px solid #fff;\n        border-top: none;\n        border-left: none;\n        transform: rotate(45deg);\n      }\n    }\n  }\n  .treejs-node__halfchecked {\n    & > .treejs-checkbox {\n      &:before {\n        background-color: @bluebg;\n        border-color: @bluebg;\n      }\n      &:after {\n        position: absolute;\n        content: ' ';\n        display: block;\n        top: 9px;\n        left: 3px;\n        width: 10px;\n        height: 2px;\n        background-color: #fff;\n      }\n    }\n  }\n\n  .treejs-node__disabled {\n    cursor: not-allowed;\n    color: rgba(255, 255, 255, 0.25);\n    .treejs-checkbox {\n      cursor: not-allowed;\n      &:before {\n        cursor: not-allowed;\n        border-color: @greyborder !important;\n        background-color: @bgcolor-disable !important;\n      }\n      &:hover:before {\n        box-shadow: none !important;\n      }\n    }\n    .treejs-node__checked {\n      & > .treejs-checkbox {\n        &:after {\n          border-color: @greyborder;\n        }\n      }\n    }\n    .treejs-node__halfchecked {\n      & > .treejs-checkbox {\n        &:after {\n          background-color: @greyborder;\n        }\n      }\n    }\n  }\n  .treejs-node__disabled.treejs-node__checked {\n    & > .treejs-checkbox {\n      &:after {\n        border-color: @greyborder;\n      }\n    }\n  }\n  .treejs-node__disabled.treejs-node__halfchecked {\n    & > .treejs-checkbox {\n      &:after {\n        background-color: @greyborder;\n      }\n    }\n  }\n\n  .treejs-label {\n    vertical-align: middle;\n  }\n}\n"], sourceRoot: "" }]), t2.Z = o;
    }, 645: function(e3) {
      e3.exports = function(e4) {
        var t2 = [];
        return t2.toString = function() {
          return this.map(function(t3) {
            var n2 = "", r2 = void 0 !== t3[5];
            return t3[4] && (n2 += "@supports (".concat(t3[4], ") {")), t3[2] && (n2 += "@media ".concat(t3[2], " {")), r2 && (n2 += "@layer".concat(t3[5].length > 0 ? " ".concat(t3[5]) : "", " {")), n2 += e4(t3), r2 && (n2 += "}"), t3[2] && (n2 += "}"), t3[4] && (n2 += "}"), n2;
          }).join("");
        }, t2.i = function(e5, n2, r2, i, s) {
          "string" == typeof e5 && (e5 = [[null, e5, void 0]]);
          var o = {};
          if (r2)
            for (var a = 0; a < this.length; a++) {
              var l = this[a][0];
              null != l && (o[l] = true);
            }
          for (var c = 0; c < e5.length; c++) {
            var u = [].concat(e5[c]);
            r2 && o[u[0]] || (void 0 !== s && (void 0 === u[5] || (u[1] = "@layer".concat(u[5].length > 0 ? " ".concat(u[5]) : "", " {").concat(u[1], "}")), u[5] = s), n2 && (u[2] ? (u[1] = "@media ".concat(u[2], " {").concat(u[1], "}"), u[2] = n2) : u[2] = n2), i && (u[4] ? (u[1] = "@supports (".concat(u[4], ") {").concat(u[1], "}"), u[4] = i) : u[4] = "".concat(i)), t2.push(u));
          }
        }, t2;
      };
    }, 537: function(e3) {
      e3.exports = function(e4) {
        var t2 = e4[1], n2 = e4[3];
        if (!n2)
          return t2;
        if ("function" == typeof btoa) {
          var r2 = btoa(unescape(encodeURIComponent(JSON.stringify(n2)))), i = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(r2), s = "/*# ".concat(i, " */"), o = n2.sources.map(function(e5) {
            return "/*# sourceURL=".concat(n2.sourceRoot || "").concat(e5, " */");
          });
          return [t2].concat(o).concat([s]).join("\n");
        }
        return [t2].join("\n");
      };
    }, 379: function(e3) {
      var t2 = [];
      function n2(e4) {
        for (var n3 = -1, r3 = 0; r3 < t2.length; r3++)
          if (t2[r3].identifier === e4) {
            n3 = r3;
            break;
          }
        return n3;
      }
      function r2(e4, r3) {
        for (var s = {}, o = [], a = 0; a < e4.length; a++) {
          var l = e4[a], c = r3.base ? l[0] + r3.base : l[0], u = s[c] || 0, p = "".concat(c, " ").concat(u);
          s[c] = u + 1;
          var d = n2(p), h = { css: l[1], media: l[2], sourceMap: l[3], supports: l[4], layer: l[5] };
          if (-1 !== d)
            t2[d].references++, t2[d].updater(h);
          else {
            var f = i(h, r3);
            r3.byIndex = a, t2.splice(a, 0, { identifier: p, updater: f, references: 1 });
          }
          o.push(p);
        }
        return o;
      }
      function i(e4, t3) {
        var n3 = t3.domAPI(t3);
        return n3.update(e4), function(t4) {
          if (t4) {
            if (t4.css === e4.css && t4.media === e4.media && t4.sourceMap === e4.sourceMap && t4.supports === e4.supports && t4.layer === e4.layer)
              return;
            n3.update(e4 = t4);
          } else
            n3.remove();
        };
      }
      e3.exports = function(e4, i2) {
        var s = r2(e4 = e4 || [], i2 = i2 || {});
        return function(e5) {
          e5 = e5 || [];
          for (var o = 0; o < s.length; o++) {
            var a = n2(s[o]);
            t2[a].references--;
          }
          for (var l = r2(e5, i2), c = 0; c < s.length; c++) {
            var u = n2(s[c]);
            0 === t2[u].references && (t2[u].updater(), t2.splice(u, 1));
          }
          s = l;
        };
      };
    }, 216: function(e3) {
      e3.exports = function(e4) {
        var t2 = document.createElement("style");
        return e4.setAttributes(t2, e4.attributes), e4.insert(t2, e4.options), t2;
      };
    }, 636: function(e3, t2, n2) {
      e3.exports = function(e4) {
        var t3 = n2.nc;
        t3 && e4.setAttribute("nonce", t3);
      };
    }, 795: function(e3) {
      e3.exports = function(e4) {
        var t2 = e4.insertStyleElement(e4);
        return { update: function(n2) {
          !function(e5, t3, n3) {
            var r2 = "";
            n3.supports && (r2 += "@supports (".concat(n3.supports, ") {")), n3.media && (r2 += "@media ".concat(n3.media, " {"));
            var i = void 0 !== n3.layer;
            i && (r2 += "@layer".concat(n3.layer.length > 0 ? " ".concat(n3.layer) : "", " {")), r2 += n3.css, i && (r2 += "}"), n3.media && (r2 += "}"), n3.supports && (r2 += "}");
            var s = n3.sourceMap;
            s && "undefined" != typeof btoa && (r2 += "\n/", r2 += "*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(s)))), " *"), r2 += "/"), t3.styleTagTransform(r2, e5, t3.options);
          }(t2, e4, n2);
        }, remove: function() {
          !function(e5) {
            if (null === e5.parentNode)
              return false;
            e5.parentNode.removeChild(e5);
          }(t2);
        } };
      };
    }, 589: function(e3) {
      e3.exports = function(e4, t2) {
        if (t2.styleSheet)
          t2.styleSheet.cssText = e4;
        else {
          for (; t2.firstChild; )
            t2.removeChild(t2.firstChild);
          t2.appendChild(document.createTextNode(e4));
        }
      };
    } }, t = {};
    function n(r2) {
      var i = t[r2];
      if (void 0 !== i)
        return i.exports;
      var s = t[r2] = { id: r2, exports: {} };
      return e2[r2](s, s.exports, n), s.exports;
    }
    n.n = function(e3) {
      var t2 = e3 && e3.__esModule ? function() {
        return e3.default;
      } : function() {
        return e3;
      };
      return n.d(t2, { a: t2 }), t2;
    }, n.d = function(e3, t2) {
      for (var r2 in t2)
        n.o(t2, r2) && !n.o(e3, r2) && Object.defineProperty(e3, r2, { enumerable: true, get: t2[r2] });
    }, n.o = function(e3, t2) {
      return Object.prototype.hasOwnProperty.call(e3, t2);
    }, n.nc = void 0;
    var r = {};
    return function() {
      n.d(r, { default: function() {
        return T;
      } });
      var e3 = n(379), t2 = n.n(e3), i = n(795), s = n.n(i), o = n(636), a = n.n(o), l = n(216), c = n.n(l), u = n(589), p = n.n(u), d = n(820), h = {};
      d.Z && d.Z.locals && (h.locals = d.Z.locals);
      var f, m = 0, _ = {};
      _.styleTagTransform = p(), _.setAttributes = a(), _.insert = function(e4, t3) {
        (t3.target || document.head).appendChild(e4);
      }, _.domAPI = s(), _.insertStyleElement = c(), h.use = function(e4) {
        return _.options = e4 || {}, m++ || (f = t2()(d.Z, _)), h;
      }, h.unuse = function() {
        m > 0 && !--m && (f(), f = null);
      };
      var g = h;
      function v(e4, t3) {
        return function(e5) {
          if (Array.isArray(e5))
            return e5;
        }(e4) || function(e5, t4) {
          var n2 = null == e5 ? null : "undefined" != typeof Symbol && e5[Symbol.iterator] || e5["@@iterator"];
          if (null != n2) {
            var r2, i2, s2 = [], o2 = true, a2 = false;
            try {
              for (n2 = n2.call(e5); !(o2 = (r2 = n2.next()).done) && (s2.push(r2.value), !t4 || s2.length !== t4); o2 = true)
                ;
            } catch (e6) {
              a2 = true, i2 = e6;
            } finally {
              try {
                o2 || null == n2.return || n2.return();
              } finally {
                if (a2)
                  throw i2;
              }
            }
            return s2;
          }
        }(e4, t3) || function(e5, t4) {
          if (e5) {
            if ("string" == typeof e5)
              return y(e5, t4);
            var n2 = Object.prototype.toString.call(e5).slice(8, -1);
            return "Object" === n2 && e5.constructor && (n2 = e5.constructor.name), "Map" === n2 || "Set" === n2 ? Array.from(e5) : "Arguments" === n2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2) ? y(e5, t4) : void 0;
          }
        }(e4, t3) || function() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function y(e4, t3) {
        (null == t3 || t3 > e4.length) && (t3 = e4.length);
        for (var n2 = 0, r2 = new Array(t3); n2 < t3; n2++)
          r2[n2] = e4[n2];
        return r2;
      }
      function b(e4, t3) {
        var n2 = Object.keys(e4);
        if (Object.getOwnPropertySymbols) {
          var r2 = Object.getOwnPropertySymbols(e4);
          t3 && (r2 = r2.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e4, t4).enumerable;
          })), n2.push.apply(n2, r2);
        }
        return n2;
      }
      function w(e4) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var n2 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? b(Object(n2), true).forEach(function(t4) {
            A(e4, t4, n2[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(n2)) : b(Object(n2)).forEach(function(t4) {
            Object.defineProperty(e4, t4, Object.getOwnPropertyDescriptor(n2, t4));
          });
        }
        return e4;
      }
      function A(e4, t3, n2) {
        return t3 in e4 ? Object.defineProperty(e4, t3, { value: n2, enumerable: true, configurable: true, writable: true }) : e4[t3] = n2, e4;
      }
      function x(e4, t3) {
        for (var n2 = 0; n2 < t3.length; n2++) {
          var r2 = t3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(e4, r2.key, r2);
        }
      }
      function E(e4) {
        var t3 = {};
        return e4.reduce(function(e5, n2) {
          return t3[n2] || (t3[n2] = true, e5.push(n2)), e5;
        }, []);
      }
      function C(e4, t3) {
        requestAnimationFrame(function() {
          t3.enter(), requestAnimationFrame(function() {
            t3.active(), setTimeout(function() {
              t3.leave();
            }, e4);
          });
        });
      }
      function S(e4, t3) {
        try {
          var n2 = e4.liElementsById[t3.parent.id];
          n2.classList.contains("treejs-node__close") || n2.getElementsByClassName("treejs-switcher")[0].click();
        } catch (e5) {
          return;
        }
        Object.prototype.hasOwnProperty.call(t3, "parent") && S(e4, t3.parent);
      }
      function M(e4, t3) {
        var n2 = e4.liElementsById[t3.id];
        n2.classList.contains("treejs-node__close") && n2.getElementsByClassName("treejs-switcher")[0].click(), Object.prototype.hasOwnProperty.call(t3, "children") && t3.children.forEach(function(t4) {
          return M(e4, t4);
        });
      }
      var T = function() {
        function e4(t4, n3) {
          !function(e5, t5) {
            if (!(e5 instanceof t5))
              throw new TypeError("Cannot call a class as a function");
          }(this, e4), g.use({ target: "string" == typeof this.container ? document.querySelector(this.container) : this.container }), this.treeNodes = [], this.nodesById = {}, this.leafNodesById = {}, this.liElementsById = {}, this.willUpdateNodesById = {}, this.container = t4, this.options = Object.assign({ values: [], disables: [], loaded: null, closeDepth: null }, n3), Object.defineProperties(this, { values: { get: function() {
            return this.getValues();
          }, set: function(e5) {
            this.setValues(E(e5));
          } }, disables: { get: function() {
            return this.getDisables();
          }, set: function(e5) {
            this.setDisables(E(e5));
          } }, selectedNodes: { get: function() {
            var e5 = [], t5 = this.nodesById;
            return Object.keys(t5).forEach(function(n4) {
              if (Object.prototype.hasOwnProperty.call(t5, n4) && (1 === t5[n4].status || 2 === t5[n4].status)) {
                var r3 = w({}, t5[n4]);
                delete r3.parent, delete r3.children, e5.push(r3);
              }
            }), e5;
          } }, disabledNodes: { get: function() {
            var e5 = [], t5 = this.nodesById;
            return Object.keys(t5).forEach(function(n4) {
              if (Object.prototype.hasOwnProperty.call(t5, n4) && t5[n4].disabled) {
                var r3 = w({}, t5[n4]);
                delete r3.parent, e5.push(r3);
              }
            }), e5;
          } } }), this.init(this.options.data);
        }
        var t3, n2, r2;
        return t3 = e4, r2 = [{ key: "onSwitcherClick", value: function(e5) {
          var t4 = e5.parentNode, n3 = t4.lastChild, r3 = n3.scrollHeight;
          t4.classList.contains("treejs-node__close") ? C(150, { enter: function() {
            n3.style.height = 0, n3.style.opacity = 0;
          }, active: function() {
            n3.style.height = "".concat(r3, "px"), n3.style.opacity = 1;
          }, leave: function() {
            n3.style.height = "", n3.style.opacity = "", t4.classList.remove("treejs-node__close");
          } }) : C(150, { enter: function() {
            n3.style.height = "".concat(r3, "px"), n3.style.opacity = 1;
          }, active: function() {
            n3.style.height = 0, n3.style.opacity = 0;
          }, leave: function() {
            n3.style.height = "", n3.style.opacity = "", t4.classList.add("treejs-node__close");
          } });
        } }, { key: "parseTreeData", value: function(e5) {
          var t4, n3 = (t4 = e5, JSON.parse(JSON.stringify(t4))), r3 = {}, i2 = {}, s2 = [], o2 = [];
          return function e6(t5, n4) {
            t5.forEach(function(t6) {
              r3[t6.id] = t6, t6.checked && s2.push(t6.id), t6.disabled && o2.push(t6.id), n4 && (t6.parent = n4), t6.children && t6.children.length ? e6(t6.children, t6) : i2[t6.id] = t6;
            });
          }(n3), { treeNodes: n3, nodesById: r3, leafNodesById: i2, defaultValues: s2, defaultDisables: o2 };
        } }, { key: "createRootEle", value: function() {
          var e5 = document.createElement("div");
          return e5.classList.add("treejs"), e5;
        } }, { key: "createUlEle", value: function() {
          var e5 = document.createElement("ul");
          return e5.classList.add("treejs-nodes"), e5;
        } }, { key: "createLiEle", value: function(e5, t4) {
          var n3 = document.createElement("li");
          if (n3.classList.add("treejs-node"), t4 && n3.classList.add("treejs-node__close"), e5.children && e5.children.length) {
            var r3 = document.createElement("span");
            r3.classList.add("treejs-switcher"), n3.appendChild(r3);
          } else
            n3.classList.add("treejs-placeholder");
          var i2 = document.createElement("span");
          i2.classList.add("treejs-checkbox"), n3.appendChild(i2);
          var s2 = document.createElement("span");
          s2.classList.add("treejs-label");
          var o2 = document.createTextNode(e5.text);
          return s2.appendChild(o2), n3.appendChild(s2), n3.nodeId = e5.id, n3;
        } }], (n2 = [{ key: "init", value: function(t4) {
          var n3 = e4.parseTreeData(t4), r3 = n3.treeNodes, i2 = n3.nodesById, s2 = n3.leafNodesById, o2 = n3.defaultValues, a2 = n3.defaultDisables;
          this.treeNodes = r3, this.nodesById = i2, this.leafNodesById = s2, this.render(this.treeNodes);
          var l2 = this.options, c2 = l2.values, u2 = l2.disables, p2 = l2.loaded;
          c2 && c2.length ? this.setValues(c2) : o2 && o2.length && this.setValues(o2), u2 && u2.length ? this.setDisables(u2) : a2 && a2.length && this.setDisables(a2), "function" == typeof p2 && p2.call(this);
        } }, { key: "render", value: function(t4) {
          var n3 = e4.createRootEle();
          n3.appendChild(this.buildTree(t4, 0)), this.bindEvent(n3);
          var r3 = "string" == typeof this.container ? document.querySelector(this.container) : this.container;
          !function(e5) {
            for (; e5.firstChild; )
              e5.removeChild(e5.firstChild);
          }(r3), r3.appendChild(n3);
        } }, { key: "buildTree", value: function(t4, n3) {
          var r3 = this, i2 = e4.createUlEle();
          return t4 && t4.length && t4.forEach(function(t5) {
            var s2 = e4.createLiEle(t5, n3 === r3.options.closeDepth - 1);
            r3.liElementsById[t5.id] = s2;
            var o2 = null;
            t5.children && t5.children.length && (o2 = r3.buildTree(t5.children, n3 + 1)), o2 && s2.appendChild(o2), i2.appendChild(s2);
          }), i2;
        } }, { key: "bindEvent", value: function(t4) {
          var n3 = this;
          t4.addEventListener("click", function(t5) {
            var r3 = t5.target;
            "SPAN" === r3.nodeName && r3.classList.contains("treejs-checkbox") ? n3.onItemClick(r3.parentNode.nodeId) : "SPAN" === r3.nodeName && r3.classList.contains("treejs-label") ? n3.onItemLabelClick(r3.parentNode.nodeId) : "LI" === r3.nodeName && r3.classList.contains("treejs-node") ? n3.onItemClick(r3.nodeId) : "SPAN" === r3.nodeName && r3.classList.contains("treejs-switcher") && e4.onSwitcherClick(r3);
          }, false);
        } }, { key: "onItemClick", value: function(e5) {
          var t4 = this.nodesById[e5], n3 = this.options.onChange;
          t4.disabled || (this.setValue(e5), this.updateLiElements()), n3 && n3.call(this);
        } }, { key: "onItemLabelClick", value: function(e5) {
          var t4 = this.options.onItemLabelClick;
          t4 && t4.call(this, e5);
        } }, { key: "setValue", value: function(e5) {
          var t4 = this.nodesById[e5];
          if (t4) {
            var n3 = t4.status, r3 = 1 === n3 || 2 === n3 ? 0 : 2;
            t4.status = r3, this.markWillUpdateNode(t4), this.walkUp(t4, "status"), this.walkDown(t4, "status");
          }
        } }, { key: "getValues", value: function() {
          var e5 = this, t4 = [];
          return Object.keys(this.leafNodesById).forEach(function(n3) {
            Object.prototype.hasOwnProperty.call(e5.leafNodesById, n3) && (1 !== e5.leafNodesById[n3].status && 2 !== e5.leafNodesById[n3].status || t4.push(n3));
          }), t4;
        } }, { key: "setValues", value: function(e5) {
          var t4 = this;
          this.emptyNodesCheckStatus(), e5.forEach(function(e6) {
            t4.setValue(e6);
          }), this.updateLiElements();
          var n3 = this.options.onChange;
          n3 && n3.call(this);
        } }, { key: "setDisable", value: function(e5) {
          var t4 = this.nodesById[e5];
          t4 && (t4.disabled || (t4.disabled = true, this.markWillUpdateNode(t4), this.walkUp(t4, "disabled"), this.walkDown(t4, "disabled")));
        } }, { key: "getDisables", value: function() {
          var e5 = this, t4 = [];
          return Object.keys(this.leafNodesById).forEach(function(n3) {
            Object.prototype.hasOwnProperty.call(e5.leafNodesById, n3) && e5.leafNodesById[n3].disabled && t4.push(n3);
          }), t4;
        } }, { key: "setDisables", value: function(e5) {
          var t4 = this;
          this.emptyNodesDisable(), e5.forEach(function(e6) {
            t4.setDisable(e6);
          }), this.updateLiElements();
        } }, { key: "emptyNodesCheckStatus", value: function() {
          this.willUpdateNodesById = this.getSelectedNodesById(), Object.values(this.willUpdateNodesById).forEach(function(e5) {
            e5.disabled || (e5.status = 0);
          });
        } }, { key: "emptyNodesDisable", value: function() {
          this.willUpdateNodesById = this.getDisabledNodesById(), Object.values(this.willUpdateNodesById).forEach(function(e5) {
            e5.disabled = false;
          });
        } }, { key: "getSelectedNodesById", value: function() {
          return Object.entries(this.nodesById).reduce(function(e5, t4) {
            var n3 = v(t4, 2), r3 = n3[0], i2 = n3[1];
            return 1 !== i2.status && 2 !== i2.status || (e5[r3] = i2), e5;
          }, {});
        } }, { key: "getDisabledNodesById", value: function() {
          return Object.entries(this.nodesById).reduce(function(e5, t4) {
            var n3 = v(t4, 2), r3 = n3[0], i2 = n3[1];
            return i2.disabled && (e5[r3] = i2), e5;
          }, {});
        } }, { key: "updateLiElements", value: function() {
          var e5 = this;
          Object.values(this.willUpdateNodesById).forEach(function(t4) {
            e5.updateLiElement(t4);
          }), this.willUpdateNodesById = {};
        } }, { key: "markWillUpdateNode", value: function(e5) {
          this.willUpdateNodesById[e5.id] = e5;
        } }, { key: "walkUp", value: function(e5, t4) {
          var n3 = e5.parent;
          if (n3) {
            if ("status" === t4) {
              var r3, i2 = n3.children.reduce(function(e6, t5) {
                return Number.isNaN(t5.status) ? e6 : e6 + t5.status;
              }, 0);
              if (r3 = i2 ? i2 === 2 * n3.children.length ? 2 : 1 : 0, n3.status === r3)
                return;
              n3.status = r3;
            } else {
              var s2 = n3.children.reduce(function(e6, t5) {
                return e6 && t5.disabled;
              }, true);
              if (n3.disabled === s2)
                return;
              n3.disabled = s2;
            }
            this.markWillUpdateNode(n3), this.walkUp(n3, t4);
          }
        } }, { key: "walkDown", value: function(e5, t4) {
          var n3 = this;
          e5.children && e5.children.length && e5.children.forEach(function(r3) {
            "status" === t4 && r3.disabled || (r3[t4] = e5[t4], n3.markWillUpdateNode(r3), n3.walkDown(r3, t4));
          });
        } }, { key: "updateLiElement", value: function(e5) {
          var t4 = this.liElementsById[e5.id].classList;
          switch (e5.status) {
            case 0:
              t4.remove("treejs-node__halfchecked", "treejs-node__checked");
              break;
            case 1:
              t4.remove("treejs-node__checked"), t4.add("treejs-node__halfchecked");
              break;
            case 2:
              t4.remove("treejs-node__halfchecked"), t4.add("treejs-node__checked");
          }
          switch (e5.disabled) {
            case true:
              t4.contains("treejs-node__disabled") || t4.add("treejs-node__disabled");
              break;
            case false:
              t4.contains("treejs-node__disabled") && t4.remove("treejs-node__disabled");
          }
        } }, { key: "collapseAll", value: function() {
          var e5 = this;
          Object.keys(this.leafNodesById).forEach(function(t4) {
            var n3 = e5.leafNodesById[t4];
            S(e5, n3);
          });
        } }, { key: "expandAll", value: function() {
          M(this, this.treeNodes[0]);
        } }]) && x(t3.prototype, n2), r2 && x(t3, r2), Object.defineProperty(t3, "prototype", { writable: false }), e4;
      }();
    }(), r.default;
  }();
}, 8: function(e, t) {
  !function(e2) {
    class t2 {
      constructor() {
        this._eventListeners = {}, this.dispatchEvent = this.dispatchEvent.bind(this), this.addEventListener = this.addEventListener.bind(this), this.removeEventListener = this.removeEventListener.bind(this), this.hasEventListener = this.hasEventListener.bind(this);
      }
      addEventListener(e3, t3) {
        const n2 = this._eventListeners;
        void 0 === n2[e3] && (n2[e3] = []), n2[e3].includes(t3) || n2[e3].push(t3);
      }
      hasEventListener(e3, t3) {
        const n2 = this._eventListeners;
        return void 0 !== n2[e3] && n2[e3].includes(t3);
      }
      removeEventListener(e3, t3) {
        const n2 = this._eventListeners[e3];
        if (void 0 !== n2) {
          const e4 = n2.indexOf(t3);
          -1 !== e4 && n2.splice(e4, 1);
        }
      }
      dispatchEvent(e3) {
        const t3 = this._eventListeners[e3.type];
        if (void 0 !== t3) {
          e3.target = this;
          const n2 = t3.slice(0);
          for (let t4 = 0, r2 = n2.length; t4 < r2; t4++)
            n2[t4].call(this, e3);
        }
      }
    }
    function n() {
      return ("undefined" == typeof performance ? Date : performance).now();
    }
    class r {
      constructor(e3 = r.DECAY_MILLISECONDS) {
        this.velocity = 0, this.naturalFrequency = 0, this.setDecayTime(e3);
      }
      setDecayTime(e3) {
        this.naturalFrequency = 1 / Math.max(r.MIN_DECAY_MILLISECONDS, e3);
      }
      update(e3, t3, n2, r2) {
        const i2 = 2e-4 * this.naturalFrequency;
        if (null == e3 || 0 === r2)
          return t3;
        if (e3 === t3 && 0 === this.velocity)
          return t3;
        if (n2 < 0)
          return e3;
        const s2 = e3 - t3, o2 = this.velocity + this.naturalFrequency * s2, a2 = s2 + n2 * o2, l2 = Math.exp(-this.naturalFrequency * n2), c2 = (o2 - this.naturalFrequency * a2) * l2, u2 = -this.naturalFrequency * (c2 + o2 * l2);
        return Math.abs(c2) < i2 * Math.abs(r2) && u2 * s2 >= 0 ? (this.velocity = 0, t3) : (this.velocity = c2, t3 + a2 * l2);
      }
    }
    async function i(e3) {
      return new Promise((t3, n2) => {
        const r2 = new Image();
        r2.onload = () => t3(r2), r2.onerror = n2, r2.crossOrigin = "anonymous", r2.decoding = "sync", r2.src = e3;
      });
    }
    function s(e3, t3 = document.head) {
      const n2 = document.createElement("style");
      return n2.type = "text/css", n2.innerText = e3, null == t3 || t3.appendChild(n2), n2;
    }
    r.SETTLING_TIME = 1e4, r.MIN_DECAY_MILLISECONDS = 1e-3, r.DECAY_MILLISECONDS = 50;
    const o = { Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array };
    function a(e3) {
      return e3.replace(/([.*+?^=!:${}()|[\]/\\])/g, "\\$1");
    }
    function l(e3, t3, n2) {
      return e3.replace(new RegExp(a(t3), "g"), n2);
    }
    const c = (e3, ...t3) => String.raw({ raw: e3 }, ...t3), u = (e3, ...t3) => {
      let n2 = String.raw({ raw: e3 }, ...t3);
      return n2 = l(n2, "%", "%25"), n2 = l(n2, "> <", "><"), n2 = l(n2, "; }", ";}"), n2 = l(n2, "<", "%3c"), n2 = l(n2, ">", "%3e"), n2 = l(n2, '"', "'"), n2 = l(n2, "#", "%23"), n2 = l(n2, "{", "%7b"), n2 = l(n2, "}", "%7d"), n2 = l(n2, "|", "%7c"), n2 = l(n2, "^", "%5e"), n2 = l(n2, "`", "%60"), n2 = l(n2, "@", "%40"), n2 = l(n2, "&", "&amp;"), n2 = l(n2, "\n", "%0A"), "data:image/svg+xml;charset=UTF-8," + n2;
    };
    function p(e3, t3) {
      const n2 = window.URL.createObjectURL(e3), r2 = document.createElement("a");
      r2.style.display = "none", r2.href = n2, r2.download = t3, document.body.appendChild(r2), r2.click(), setTimeout(() => {
        document.body.removeChild(r2), window.URL.revokeObjectURL(n2);
      }, 1e3);
    }
    async function d(e3) {
      return new Promise((t3, n2) => {
        const r2 = new FileReader();
        r2.onload = (e4) => t3(r2.result), r2.onerror = (e4) => n2(r2.error), r2.onabort = (e4) => n2(new Error("Read aborted")), r2.readAsDataURL(e3);
      });
    }
    function h(e3, t3) {
      let n2;
      do {
        n2 = Object.getOwnPropertyDescriptor(e3, t3);
      } while (!n2 && (e3 = Object.getPrototypeOf(e3)));
      return n2;
    }
    function f(e3, t3, n2 = true, r2 = false) {
      const i2 = h(e3, t3);
      return !!(null == i2 ? void 0 : i2.set) || n2 && false !== (null == i2 ? void 0 : i2.writable) && void 0 === (null == i2 ? void 0 : i2.get) || r2 && !i2;
    }
    function m(e3, t3, n2, r2 = true, i2 = false) {
      return !(!e3 || !f(e3, t3, r2, i2) || (e3[t3] = n2, 0));
    }
    function _(e3, t3) {
      for (let n2 = e3.length - 1; n2 >= 0; n2--)
        if (t3(e3[n2]))
          return n2;
      return -1;
    }
    const g = { priority: 1 / 0, serialize: (e3, t3) => Object.fromEntries(Object.entries(e3).map(([e4, n2]) => [e4, v.Serialize(n2, t3, false)])), deserialize: (e3, t3, n2) => Object.assign(t3 || {}, Object.fromEntries(Object.entries(e3).map(([e4, r2]) => [e4, v.Deserialize(r2, null == t3 ? void 0 : t3[e4], n2, false)]))), isType: (e3) => (e3.constructor || Object) === Object };
    class v {
      static GetSerializer(e3) {
        return v.Serializers.find((t3) => t3.isType(e3));
      }
      static RegisterSerializer(...e3) {
        var t3;
        for (const n2 of e3) {
          const e4 = null !== (t3 = n2.priority) && void 0 !== t3 ? t3 : 1e10, r2 = _(v.Serializers, (t4) => void 0 !== t4.priority && t4.priority < e4);
          r2 >= 0 ? v.Serializers.splice(r2 + 1, 0, n2) : v.Serializers.push(n2);
        }
      }
      static UnregisterSerializer(...e3) {
        for (const t3 of e3) {
          const e4 = v.Serializers.indexOf(t3);
          e4 >= 0 && v.Serializers.splice(e4, 1);
        }
      }
      static Serialize(e3, t3, n2 = false) {
        var r2, i2;
        if ("function" == typeof e3)
          return;
        if (!n2) {
          const n3 = v.GetSerializer(e3);
          if (n3)
            return n3.serialize(e3, t3);
          if ("function" == typeof e3.toJSON) {
            const n4 = e3.toJSON(t3);
            return e3.serializableClassId && n4 && (n4.serializableClassId = e3.serializableClassId), n4;
          }
        }
        let s2 = null !== (r2 = e3.constructor) && void 0 !== r2 ? r2 : Object;
        const o2 = {};
        for (; s2 && s2 !== Object; ) {
          const n3 = null !== (i2 = v.TypeMap.get(s2)) && void 0 !== i2 ? i2 : [];
          for (const [r3, i3] of n3)
            o2[r3] = v.Serialize(e3[i3], t3, false);
          s2 = Object.getPrototypeOf(s2);
        }
        return e3.serializableClassId && (o2.serializableClassId = e3.serializableClassId), o2;
      }
      static Deserialize(e3, t3, n2, r2 = false) {
        var i2, s2;
        if (void 0 === e3)
          return t3;
        if (t3 === e3)
          return t3;
        if (e3 && "object" == typeof e3 && (e3.constructor || Object) === Object && e3.resource && "string" == typeof e3.resource && e3.uuid) {
          const r3 = null == n2 ? void 0 : n2[e3.resource];
          if (!r3)
            return console.warn(`Resource ${e3.resource} not found`), t3;
          if ("object" == typeof (e3 = r3[e3.uuid]) && (e3.__useCount = e3.__useCount ? e3.__useCount + 1 : 1), e3 || console.warn(`Resource ${e3.resource} with uuid ${e3.uuid} not found`), t3 === e3)
            return t3;
          if (e3 && "object" == typeof e3) {
            if ((e3.constructor || Object) !== Object)
              return t3 ? (console.warn("replacing object", t3, "with deserialized object from meta", e3), e3) : e3;
            console.error("Deserialize; meta should only have class instances, not js objects", e3, t3, n2);
          }
        }
        if (e3 && "object" == typeof e3 && (e3.constructor || Object) !== Object && !Array.isArray(e3) && console.warn("Data might already be deserialized. It will be cloned, or copied to source", e3, "source", t3, e3.constructor, e3.constructor !== Object), e3 && "object" == typeof e3)
          if (!e3.serializableClassId || t3 && t3.serializableClassId === e3.serializableClassId)
            (e3.constructor || Object) !== Object || t3 ? Array.isArray(e3) && !t3 && (t3 = []) : t3 = {};
          else {
            const n3 = v.SerializableClasses.get(e3.serializableClassId);
            n3 && (t3 = n3.DataInConstructor ? new n3(e3) : new n3());
          }
        if ("function" == typeof t3)
          return console.error("cannot deserialize over function", t3, e3), t3;
        if (!r2) {
          const r3 = v.GetSerializer(e3);
          if (r3 && r3 !== g)
            return r3.deserialize(e3, t3, n2);
        }
        if (!e3 || null == t3 || "object" != typeof t3)
          return e3;
        if (!r2 && "function" == typeof (null == t3 ? void 0 : t3.fromJSON))
          return t3.fromJSON(e3, n2), t3;
        let o2 = null !== (i2 = t3.constructor) && void 0 !== i2 ? i2 : Object;
        if (o2 === Object)
          return g.deserialize(e3, t3, n2);
        for (; o2 && o2 !== Object; ) {
          const r3 = null !== (s2 = v.TypeMap.get(o2)) && void 0 !== s2 ? s2 : [];
          for (const [i3, s3] of r3) {
            const r4 = t3[s3], o3 = v.Deserialize(e3[i3], r4, n2, false);
            o3 !== r4 && m(t3, s3, o3, true);
          }
          o2 = Object.getPrototypeOf(o2);
        }
        return t3;
      }
    }
    function y(e3, t3 = "param") {
      if (!e3)
        throw new Error("onChange: fnKey is undefined, make sure the function exists or provide a string");
      return (n2, r2) => {
        Object.defineProperty(n2, r2, { get() {
          return this[`_oc_${r2}`];
        }, set(n3) {
          var i2;
          const s2 = this[`_oc_${r2}`];
          if (s2 === n3)
            return;
          this[`_oc_${r2}`] = n3;
          const o2 = "param" === t3 ? [r2, n3, s2] : "object" === t3 ? [{ key: r2, value: n3, oldValue: s2 }] : "";
          if ("string" == typeof e3)
            null === (i2 = this[e3]) || void 0 === i2 || i2.call(this, ...o2);
          else if ("function" == typeof e3) {
            let t4 = false;
            if (e3.name) {
              let n4 = this;
              for (; n4; ) {
                if (n4[e3.name] === e3) {
                  e3.call(this, ...o2), t4 = true;
                  break;
                }
                n4 = Object.getPrototypeOf(n4);
              }
            }
            t4 || (e3.name && this[e3.name].name === `bound ${e3.name}` ? this[e3.name](...o2) : e3(...o2));
          }
        } });
      };
    }
    function b(e3, { backgroundColor: t3 = "", scale: n2 = 1, width: r2 = 512, height: i2 = 512 }) {
      const s2 = document.createElement("canvas"), o2 = s2.getContext("2d"), a2 = n2, l2 = r2, c2 = i2;
      return s2.width = l2 * a2, s2.height = c2 * a2, s2.style.width = `${l2}`, s2.style.height = `${c2}`, (null == t3 ? void 0 : t3.length) > 0 && (o2.fillStyle = t3, o2.fillRect(0, 0, s2.width, s2.height)), o2.drawImage(e3, 0, 0, s2.width, s2.height), s2;
    }
    v.TypeMap = /* @__PURE__ */ new Map(), v.SerializableClasses = /* @__PURE__ */ new Map(), v.Serializers = [{ priority: 0, isType: (e3) => Array.isArray(e3), serialize: (e3, t3) => e3.map((e4) => v.Serialize(e4, t3, false)), deserialize: (e3, t3, n2) => {
      const r2 = e3.length;
      Array.isArray(t3) || (t3 = []);
      for (let i2 = 0; i2 < r2; i2++) {
        const r3 = e3[i2], s2 = t3.length > i2 ? v.Deserialize(r3, t3[i2], n2, false) : v.Deserialize(r3, void 0, n2, false);
        t3.length <= i2 ? t3.push(s2) : t3[i2] = s2;
      }
      return t3;
    } }, { priority: 0, isType: (e3) => !e3 || "object" != typeof e3, serialize: (e3) => {
      if (e3 && "number" == typeof e3) {
        if (e3 === 1 / 0)
          return "Infinity";
        if (e3 === -1 / 0)
          return "-Infinity";
        if (isNaN(e3))
          return "NaN";
      }
      return e3;
    }, deserialize: (e3, t3) => {
      if ("number" == typeof t3) {
        if ("Infinity" === e3)
          return 1 / 0;
        if ("-Infinity" === e3)
          return -1 / 0;
        if ("NaN" === e3)
          return NaN;
        if ("number" == typeof e3 || !e3)
          return e3;
      }
      return e3;
    } }, g];
    const w = async (e3, t3) => b(await i(e3), t3), A = async (e3, t3) => await w(e3, t3).then((e4) => e4.toDataURL("image/png")), x = async (e3) => d(await (await fetch(e3)).blob());
    function E(e3, t3, { width: n2, height: r2 }, i2 = true) {
      const s2 = `
<svg viewBox="0 0 ${n2} ${r2}" xmlns="http://www.w3.org/2000/svg">
    <style>
    ${t3}
    </style>
    <foreignObject x="0" y="0" width="100%" height="100%">
        <div xmlns="http://www.w3.org/1999/xhtml" style="height: 100%; width: 100%; position: absolute: top:0; left:0">
            ${e3}
        </div>
    </foreignObject>
</svg>
    `;
      return i2 ? u(s2) : s2;
    }
    e2.Damper = r, e2.LinearToSRGB = function(e3) {
      return e3 < 31308e-7 ? 12.92 * e3 : 1.055 * Math.pow(e3, 0.41666) - 0.055;
    }, e2.PointerDragHelper = class extends t2 {
      constructor() {
        super(...arguments), this._onPointerDown = (e3) => {
          if (0 !== e3.button)
            return;
          if (!this._element)
            return;
          this._pointerUp = void 0;
          const t3 = e3.clientX / this._element.clientWidth * 2 - 1, r2 = -e3.clientY / this._element.clientHeight * 2 + 1, i2 = n();
          this._pointerDown = { x: t3, y: r2, time: i2 }, this._pointer = this._pointerDown, this.dispatchEvent({ type: "dragStart", pointer: this._pointerDown });
        }, this._onPointerMove = (e3) => {
          if (!this._pointerDown || !this._pointer)
            return;
          if (!this._element)
            return;
          const t3 = e3.clientX / this._element.clientWidth * 2 - 1, r2 = -e3.clientY / this._element.clientHeight * 2 + 1, i2 = n();
          this.dispatchEvent({ type: "drag", pointer: this._pointer, drag: { x: t3 - this._pointerDown.x, y: r2 - this._pointerDown.y, time: i2 - this._pointerDown.time }, delta: { x: t3 - this._pointer.x, y: r2 - this._pointer.y, time: i2 - this._pointer.time } }), this._pointer = { x: t3, y: r2, time: n() }, e3.buttons % 2 == 0 && this._onPointerUp(e3);
        }, this._onPointerUp = (e3) => {
          if (0 !== e3.button)
            return;
          if (!this._pointerDown)
            return;
          if (!this._element)
            return;
          const t3 = e3.clientX / this._element.clientWidth * 2 - 1, r2 = -e3.clientY / this._element.clientHeight * 2 + 1, i2 = n();
          this._pointerUp = { x: t3, y: r2, time: i2 }, this.dispatchEvent({ type: "dragEnd", pointer: this._pointerUp, drag: { x: this._pointerUp.x - this._pointerDown.x, y: this._pointerUp.y - this._pointerDown.y, time: this._pointerUp.time - this._pointerDown.time } }), this._pointerDown = void 0, this._pointer = void 0;
        };
      }
      get element() {
        return this._element;
      }
      set element(e3) {
        this._element !== e3 && (this._element && this._removeElement(), this._element = e3, this._element && this._addElement());
      }
      _removeElement() {
        var e3, t3, n2, r2, i2;
        null === (e3 = this._element) || void 0 === e3 || e3.removeEventListener("pointerdown", this._onPointerDown), null === (t3 = this._element) || void 0 === t3 || t3.removeEventListener("pointermove", this._onPointerMove), null === (n2 = this._element) || void 0 === n2 || n2.removeEventListener("pointerup", this._onPointerUp), null === (r2 = this._element) || void 0 === r2 || r2.removeEventListener("pointercancel", this._onPointerUp), null === (i2 = this._element) || void 0 === i2 || i2.removeEventListener("pointerout", this._onPointerUp);
      }
      _addElement() {
        var e3, t3, n2, r2, i2;
        null === (e3 = this._element) || void 0 === e3 || e3.addEventListener("pointerdown", this._onPointerDown), null === (t3 = this._element) || void 0 === t3 || t3.addEventListener("pointermove", this._onPointerMove), null === (n2 = this._element) || void 0 === n2 || n2.addEventListener("pointerup", this._onPointerUp), null === (r2 = this._element) || void 0 === r2 || r2.addEventListener("pointercancel", this._onPointerUp), null === (i2 = this._element) || void 0 === i2 || i2.addEventListener("pointerout", this._onPointerUp);
      }
      dispose() {
        this.element = void 0;
      }
    }, e2.SRGBToLinear = function(e3) {
      return e3 < 0.04045 ? 0.0773993808 * e3 : Math.pow(0.9478672986 * e3 + 0.0521327014, 2.4);
    }, e2.Serialization = v, e2.SimpleEventDispatcher = t2, e2.TYPED_ARRAYS = o, e2.absMax = function(e3, t3) {
      return Math.abs(e3) > Math.abs(t3) ? e3 : t3;
    }, e2.aesGcmDecrypt = async function(e3, t3) {
      const n2 = "string" == typeof t3 ? new TextEncoder().encode(t3) : t3, r2 = await crypto.subtle.digest("SHA-256", n2), i2 = e3.slice(0, 12), s2 = { name: "AES-GCM", iv: "string" == typeof i2 ? new Uint8Array(Array.from(i2).map((e4) => e4.charCodeAt(0))) : i2 }, o2 = await crypto.subtle.importKey("raw", r2, s2, false, ["decrypt"]), a2 = e3.slice(12), l2 = "string" == typeof a2 ? new Uint8Array(Array.from(a2).map((e4) => e4.charCodeAt(0))) : a2;
      try {
        const t4 = await crypto.subtle.decrypt(s2, o2, l2);
        return "string" == typeof e3 ? new TextDecoder().decode(t4) : new Uint8Array(t4);
      } catch (e4) {
        throw new Error("Decrypt failed");
      }
    }, e2.aesGcmEncrypt = async function(e3, t3, n2) {
      const r2 = "string" == typeof t3 ? new TextEncoder().encode(t3) : t3, i2 = await crypto.subtle.digest("SHA-256", r2), s2 = crypto.getRandomValues(new Uint8Array(12)), o2 = Array.from(s2).map((e4) => String.fromCharCode(e4)).join(""), a2 = { name: "AES-GCM", iv: s2 }, l2 = await crypto.subtle.importKey("raw", i2, a2, false, ["encrypt"]), c2 = "string" == typeof e3 ? new TextEncoder().encode(e3) : e3, u2 = await crypto.subtle.encrypt(a2, l2, c2), p2 = new Uint8Array(u2), d2 = Array.from(p2), h2 = d2.map((e4) => String.fromCharCode(e4)).join(""), f2 = n2 ? "string" == typeof n2 ? n2 : new TextDecoder().decode(n2) : "", m2 = n2 ? "string" == typeof n2 ? new TextEncoder().encode(n2) : Array.from(n2) : [];
      return "string" == typeof e3 ? f2 + o2 + h2 : new Uint8Array([...m2, ...s2, ...d2]);
    }, e2.arrayBufferToBase64 = function(e3) {
      if (!window)
        return console.warn("window is required"), "";
      let t3 = "";
      const n2 = new Uint8Array(e3), r2 = n2.byteLength;
      for (let e4 = 0; e4 < r2; e4++)
        t3 += String.fromCharCode(n2[e4]);
      return window.btoa(t3);
    }, e2.base64ToArrayBuffer = function(e3) {
      if (!window)
        return console.warn("window is required"), new Uint8Array(0);
      const t3 = window.atob(e3), n2 = t3.length, r2 = new Uint8Array(n2);
      for (let e4 = 0; e4 < n2; e4++)
        r2[e4] = t3.charCodeAt(e4);
      return r2.buffer;
    }, e2.blobToDataURL = d, e2.canvasFlipY = function(e3) {
      const t3 = document.createElement("canvas");
      t3.width = e3.width, t3.height = e3.height;
      const n2 = t3.getContext("2d");
      if (!n2)
        throw new Error("Unable to get 2d context");
      return n2.translate(0, e3.height), n2.scale(1, -1), n2.drawImage(e3, 0, 0), t3;
    }, e2.clearBit = function(e3, t3) {
      return e3 & ~(1 << t3);
    }, e2.colorToDataUrl = function(e3, t3 = 1, n2 = 1) {
      const r2 = document.createElement("canvas");
      r2.width = t3, r2.height = n2;
      const i2 = r2.getContext("2d");
      i2.fillStyle = "#" + e3, i2.fillRect(0, 0, t3, n2);
      const s2 = r2.toDataURL();
      return r2.remove(), s2;
    }, e2.copyProps = function(e3, t3, n2) {
      for (const r2 of n2) {
        const n3 = e3[r2];
        void 0 !== n3 && m(t3, r2, n3, true);
      }
      return t3;
    }, e2.createCanvasElement = function() {
      const e3 = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      return e3.style.display = "block", e3;
    }, e2.createDiv = function({ innerHTML: e3 = "", id: t3, classList: n2, addToBody: r2 = true, elementTag: i2 = "div" }) {
      const s2 = document.createElement(i2);
      return t3 && (s2.id = t3), s2.innerHTML = e3, n2 && s2.classList.add(...n2), r2 && document.body.appendChild(s2), s2;
    }, e2.createImage = i, e2.createScriptFromURL = async function(e3, t3 = document.head) {
      return new Promise((n2, r2) => {
        const i2 = document.createElement("script");
        i2.setAttribute("src", e3), i2.addEventListener("load", () => n2(i2)), i2.addEventListener("error", r2), t3.appendChild(i2);
      });
    }, e2.createStyles = s, e2.css = c, e2.deepAccessObject = function(e3, t3, n2 = false) {
      for ("string" == typeof e3 && (e3 = e3.split(".")); e3.length > 0; ) {
        if (!t3)
          return;
        const r2 = e3.splice(0, 1)[0];
        if (!(r2.length < 1)) {
          if (!(r2 in t3)) {
            if (n2)
              throw new Error("invalid access, check " + r2 + " in " + t3);
            return;
          }
          t3 = t3[r2];
        }
      }
      return t3;
    }, e2.downloadBlob = p, e2.downloadFile = function(e3, t3) {
      return p(e3, null != t3 ? t3 : e3.name);
    }, e2.embedUrlRefs = async function(e3, t3 = x) {
      const n2 = e3.match(/(((ftp|https?):\/\/)[\-\w@:%_\+.~#?,&\/\/=]+)/g);
      if (n2)
        for (const r2 of n2) {
          const n3 = await t3(r2);
          e3 = e3.replace(r2, n3);
        }
      return e3;
    }, e2.escapeRegExp = a, e2.getFileHandle = function() {
      return "showOpenFilePicker" in window ? window.showOpenFilePicker().then((e3) => e3[0]) : window.chooseFileSystemEntries();
    }, e2.getFilenameFromPath = function(e3) {
      return e3.substring(e3.lastIndexOf("/") + 1);
    }, e2.getKeyByValue = function(e3, t3) {
      return Object.keys(e3).find((n2) => e3[n2] === t3);
    }, e2.getNewFileHandle = function() {
      if ("showSaveFilePicker" in window) {
        const e3 = { types: [{ description: "Text file", accept: { "text/plain": [".txt"] } }] };
        return window.showSaveFilePicker(e3);
      }
      return window.chooseFileSystemEntries({ type: "save-file", accepts: [{ description: "Text file", extensions: ["txt"], mimeTypes: ["text/plain"] }] });
    }, e2.getOrCall = function(e3, ...t3) {
      return "function" == typeof e3 && (e3 = e3(...t3)), e3;
    }, e2.getPropertyDescriptor = h, e2.getTypedArray = function(e3, t3) {
      return new o[e3](t3);
    }, e2.getUrlQueryParam = function(e3, t3 = null) {
      var n2;
      return null !== (n2 = new URL(window.location.href).searchParams.get(e3)) && void 0 !== n2 ? n2 : t3;
    }, e2.glsl = (e3, ...t3) => String.raw({ raw: e3 }, ...t3), e2.html = (e3, ...t3) => String.raw({ raw: e3 }, ...t3), e2.htmlToCanvas = async function(e3, t3, n2) {
      const r2 = E(e3, t3, n2);
      return await w(r2, n2);
    }, e2.htmlToPng = async function(e3, t3, n2) {
      const r2 = E(e3, t3, n2);
      return await A(r2, n2);
    }, e2.htmlToSvg = E, e2.imageBitmapToBase64 = function(e3, t3 = 8192, n2 = false) {
      var r2;
      if (!e3.width || !e3.height)
        return "";
      const i2 = document.createElement("canvas");
      i2.width = Math.min(t3, e3.width), i2.height = Math.floor(1 + i2.width * e3.height / e3.width);
      const s2 = e3 instanceof ImageBitmap, o2 = s2 && n2 && Math.abs(i2.width - e3.width) < 0.5 ? i2.getContext("bitmaprenderer") : void 0;
      o2 ? o2.transferFromImageBitmap(e3) : null === (r2 = i2.getContext("2d")) || void 0 === r2 || r2.drawImage(e3, 0, 0, i2.width, i2.height);
      const a2 = i2.toDataURL("image/png");
      return i2.remove(), s2 && n2 && e3.close(), a2;
    }, e2.imageDataToCanvas = function(e3) {
      const t3 = document.createElement("canvas");
      return t3.width = e3.width, t3.height = e3.height, t3.getContext("2d").putImageData(e3, 0, 0), t3;
    }, e2.imageToCanvas = b, e2.imageUrlToImageData = async function(e3) {
      return new Promise((t3, n2) => {
        const r2 = new Image();
        r2.addEventListener("load", () => {
          const e4 = document.createElement("canvas");
          e4.width = r2.width, e4.height = r2.height;
          const i2 = e4.getContext("2d");
          if (!i2)
            return void n2(new Error("Could not get 2d context"));
          i2.drawImage(r2, 0, 0, e4.width, e4.height);
          const s2 = i2.getImageData(0, 0, e4.width, e4.height);
          t3(s2), e4.remove(), r2.remove();
        }, false), r2.addEventListener("error", (e4) => {
          r2.remove(), n2(e4);
        }, false), r2.src = e3;
      });
    }, e2.includesAll = function(e3, t3) {
      for (const n2 of t3)
        if (!e3.includes(n2))
          return false;
      return true;
    }, e2.isPropertyWritable = f, e2.isWebpExportSupported = function() {
      const e3 = document.createElement("canvas");
      return !(!e3.getContext || !e3.getContext("2d")) && e3.toDataURL("image/webp").startsWith("data:image/webp");
    }, e2.longestCommonPrefix = function(e3) {
      return e3.sort(), e3[0].split("").map((t3, n2) => e3[e3.length - 1][n2] === t3 ? t3 : "\0").join("").split("\0").at(0) || "";
    }, e2.makeColorSvg = (e3) => `data:image/svg+xml,%3Csvg width='16' height='16' viewBox='0 0 16 16' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='16' height='16' fill='%23${e3}'/%3E%3C/svg%3E%0A`, e2.makeColorSvgCircle = (e3) => `data:image/svg+xml,%3Csvg width='16' height='16' viewBox='0 0 16 16' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='8' cy='8' r='7' fill='%23${e3}'/%3E%3C/svg%3E%0A`, e2.makeTextSvg = (e3) => `data:image/svg+xml,%3Csvg viewBox='0 0 80 14' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext style='font: 8px "Roboto Mono", "Source Code Pro", Menlo, Courier, monospace; fill: white;' x='9' y='9'%3E${e3}%3C/text%3E%3C/svg%3E%0A`, e2.mobileAndTabletCheck = function() {
      let e3 = false;
      var t3;
      return t3 = navigator.userAgent || navigator.vendor || window.opera, (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(t3) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t3.substr(0, 4))) && (e3 = true), e3;
    }, e2.now = n, e2.objectHasOwn = function(e3, t3) {
      return Object.hasOwn ? Object.hasOwn(e3, t3) : e3.hasOwnProperty(t3);
    }, e2.onChange = y, e2.onChange2 = function(e3, t3 = "void") {
      if (!e3)
        throw new Error("onChange: fnKey is undefined, make sure the function exists or provide a string");
      return y(e3, t3);
    }, e2.onChange3 = function(e3, t3 = "object") {
      if (!e3)
        throw new Error("onChange: fnKey is undefined, make sure the function exists or provide a string");
      return y(e3, t3);
    }, e2.parseFileExtension = function(e3) {
      var t3;
      if (!e3 || "" === e3 || e3.match(/__MACOSX\/.*\._/))
        return "";
      const n2 = null !== (t3 = (e3 = e3.replace(/\?.*$/, "")).split(/[\\/]/).pop()) && void 0 !== t3 ? t3 : "", r2 = n2.lastIndexOf(".");
      return "" === n2 || r2 < 1 ? "" : n2.slice(r2 + 1);
    }, e2.pathJoin = function(e3, t3 = "/") {
      return e3.join(t3);
    }, e2.prettyScrollbar = function(e3 = document.head) {
      return s(c`
      ::-webkit-scrollbar
      {
        width: 8px;  /* for vertical scrollbars */
        height: 8px; /* for horizontal scrollbars */
      }
      ::-webkit-scrollbar-track
      {
        background: rgba(64, 64, 64, 0.4);
        border-radius: 6px;
      }
      ::-webkit-scrollbar-thumb
      {
        background: rgba(128, 128, 128, 0.2);
        border-radius: 6px;
      }
      ::-webkit-scrollbar-corner {background: rgba(0,0,0,0.5);}
    `, e3);
    }, e2.readFile = function(e3) {
      return e3.text ? e3.text() : function(e4) {
        return new Promise((t3) => {
          const n2 = new FileReader();
          n2.addEventListener("loadend", (e5) => {
            const n3 = e5.srcElement.result;
            t3(n3);
          }), n2.readAsText(e4);
        });
      }(e3);
    }, e2.remoteWorkerURL = function(e3, t3) {
      const n2 = (t3 ? `var Module = { locateFile: function(s) { return "${t3}"; } }; 
` : "") + `importScripts( "${e3}" );`;
      return URL.createObjectURL(new Blob([n2], { type: "text/javascript" }));
    }, e2.replaceAll = l, e2.safeSetProperty = m, e2.serializable = function(e3) {
      return (t3) => (t3 = class extends t3 {
        constructor() {
          super(...arguments), this.serializableClassId = e3;
        }
      }, v.SerializableClasses.set(e3, t3), t3);
    }, e2.serialize = function(e3) {
      return (t3, n2) => {
        const r2 = t3.constructor;
        if (r2 === Object)
          throw new Error("All properties in an object are serialized by default");
        v.TypeMap.has(r2) || v.TypeMap.set(r2, []), v.TypeMap.get(r2).push([e3 || n2, n2]);
      };
    }, e2.setUrlQueryParam = function(e3, t3, n2 = false) {
      const r2 = new URLSearchParams(location.search);
      null == t3 ? r2.has(e3) && r2.delete(e3) : r2.set(e3, t3), n2 ? window.location.search = r2.toString() : window.history.replaceState({}, "", "?" + r2.toString());
    }, e2.svgToCanvas = w, e2.svgToPng = A, e2.svgUrl = u, e2.timeout = async function(e3) {
      return new Promise((t3) => setTimeout(t3, Math.max(0, e3)));
    }, e2.toTitleCase = function(e3) {
      return e3.replace(/\w\S*/g, function(e4) {
        return e4.charAt(0).toUpperCase() + e4.substr(1).toLowerCase();
      });
    }, e2.updateBit = function(e3, t3, n2) {
      return e3 & ~(1 << t3) | (n2 ? 1 : 0) << t3;
    }, e2.uploadFile = async function(e3 = false, t3 = false, n2) {
      const r2 = document.createElement("input");
      r2.type = "file", r2.multiple = e3, r2.accept = n2 || "*", r2.webkitdirectory = t3, r2.style.display = "none", document.body.appendChild(r2), r2.click();
      const i2 = await new Promise((e4) => {
        r2.onchange = (t4) => {
          e4(Array.from(r2.files || []));
        };
      });
      return document.body.removeChild(r2), i2;
    }, e2.verifyPermission = async function(e3, t3) {
      const n2 = {};
      return t3 && (n2.writable = true, n2.mode = "readwrite"), "granted" === await e3.queryPermission(n2) || "granted" === await e3.requestPermission(n2);
    }, e2.writeFile = async function(e3, t3) {
      if (e3.createWriter) {
        const n3 = await e3.createWriter();
        return await n3.write(0, t3), void await n3.close();
      }
      const n2 = await e3.createWritable();
      await n2.write(t3), await n2.close();
    };
  }(t);
}, 819: function(e, t) {
  !function(e2) {
    const t2 = "tp";
    function n(e3) {
      return (t3) => (n2) => {
        if (!t3 && void 0 === n2)
          return { succeeded: false, value: void 0 };
        if (t3 && void 0 === n2)
          return { succeeded: true, value: void 0 };
        const r2 = e3(n2);
        return void 0 !== r2 ? { succeeded: true, value: r2 } : { succeeded: false, value: void 0 };
      };
    }
    function r(e3) {
      return { custom: (t3) => n(t3)(e3), boolean: n((e4) => "boolean" == typeof e4 ? e4 : void 0)(e3), number: n((e4) => "number" == typeof e4 ? e4 : void 0)(e3), string: n((e4) => "string" == typeof e4 ? e4 : void 0)(e3), function: n((e4) => "function" == typeof e4 ? e4 : void 0)(e3), constant: (t3) => n((e4) => e4 === t3 ? t3 : void 0)(e3), raw: n((e4) => e4)(e3), object: (t3) => n((e4) => {
        if (null !== (n2 = e4) && "object" == typeof n2)
          return function(e5, t4) {
            return Object.keys(t4).reduce((n3, r2) => {
              if (void 0 === n3)
                return;
              const i2 = (0, t4[r2])(e5[r2]);
              return i2.succeeded ? Object.assign(Object.assign({}, n3), { [r2]: i2.value }) : void 0;
            }, {});
          }(e4, t3);
        var n2;
      })(e3), array: (t3) => n((e4) => {
        if (Array.isArray(e4))
          return n2 = t3, e4.reduce((e5, t4) => {
            if (void 0 === e5)
              return;
            const r2 = n2(t4);
            return r2.succeeded && void 0 !== r2.value ? [...e5, r2.value] : void 0;
          }, []);
        var n2;
      })(e3) };
    }
    const i = { optional: r(true), required: r(false) };
    function s(e3) {
      return (t3) => t3.toFixed(Math.max(Math.min(e3, 20), 0));
    }
    function o(e3) {
      return [e3[0], e3[1], e3[2]];
    }
    function a(e3) {
      return (t3) => function(e4, t4) {
        const n2 = s("float" === t4 ? 2 : 0);
        return `rgb(${o(e4.getComponents("rgb", t4)).map((e5) => n2(e5)).join(", ")})`;
      }(t3, e3);
    }
    function l(e3) {
      return (t3) => function(e4, t4) {
        const n2 = s(2), r2 = s("float" === t4 ? 2 : 0);
        return `rgba(${e4.getComponents("rgb", t4).map((e5, t5) => (3 === t5 ? n2 : r2)(e5)).join(", ")})`;
      }(t3, e3);
    }
    function c(e3) {
      return (t3) => function(e4, t4) {
        const n2 = s("float" === t4 ? 2 : 0), r2 = ["r", "g", "b"];
        return `{${o(e4.getComponents("rgb", t4)).map((e5, t5) => `${r2[t5]}: ${n2(e5)}`).join(", ")}}`;
      }(t3, e3);
    }
    function u(e3) {
      return (t3) => function(e4, t4) {
        const n2 = s(2), r2 = s("float" === t4 ? 2 : 0), i2 = ["r", "g", "b", "a"];
        return `{${e4.getComponents("rgb", t4).map((e5, t5) => `${i2[t5]}: ${(3 === t5 ? n2 : r2)(e5)}`).join(", ")}}`;
      }(t3, e3);
    }
    function p(e3, t3, n2, r2) {
      return new (n2 || (n2 = Promise))(function(i2, s2) {
        function o2(e4) {
          try {
            l2(r2.next(e4));
          } catch (e5) {
            s2(e5);
          }
        }
        function a2(e4) {
          try {
            l2(r2.throw(e4));
          } catch (e5) {
            s2(e5);
          }
        }
        function l2(e4) {
          var t4;
          e4.done ? i2(e4.value) : (t4 = e4.value, t4 instanceof n2 ? t4 : new n2(function(e5) {
            e5(t4);
          })).then(o2, a2);
        }
        l2((r2 = r2.apply(e3, t3 || [])).next());
      });
    }
    function d(e3) {
      return p(this, void 0, void 0, function* () {
        const t3 = new Image();
        return t3.crossOrigin = "anonymous", new Promise((n2, r2) => {
          t3.src = e3, t3.onload = () => {
            n2(t3);
          }, t3.onerror = r2;
        });
      });
    }
    s(0), ["int", "float"].reduce((e3, t3) => [...e3, { format: { alpha: false, mode: "rgb", notation: "func", type: t3 }, stringifier: a(t3) }, { format: { alpha: true, mode: "rgb", notation: "func", type: t3 }, stringifier: l(t3) }, { format: { alpha: false, mode: "rgb", notation: "object", type: t3 }, stringifier: c(t3) }, { format: { alpha: true, mode: "rgb", notation: "object", type: t3 }, stringifier: u(t3) }], []);
    const h = (f = "img", (e3, n2) => [t2, "-", f, "v", e3 ? `_${e3}` : "", n2 ? `-${n2}` : ""].join(""));
    var f;
    class m {
      constructor(e3, t3) {
        this.element = e3.createElement("div"), this.element.classList.add(h()), t3.viewProps.bindClassModifiers(this.element), this.input = e3.createElement("input"), this.input.classList.add(h("input")), this.input.setAttribute("type", "file"), this.input.setAttribute("accept", t3.extensions.join(",")), this.image_ = e3.createElement("img"), this.image_.classList.add(h("image")), this.image_.classList.add(h(`image_${t3.imageFit}`)), this.image_.crossOrigin = "anonymous", this.image_.onclick = (e4) => {
          t3.clickCallback ? t3.clickCallback(e4, this.input) : this.input.click();
        }, this.element.classList.add(h("area_root")), this.element.appendChild(this.image_), this.element.appendChild(this.input);
      }
      changeImage(e3) {
        this.image_.src = e3;
      }
      changeDraggingState(e3) {
        const t3 = this.element;
        e3 ? null == t3 || t3.classList.add(h("area_dragging")) : null == t3 || t3.classList.remove(h("area_dragging"));
      }
    }
    let _ = null;
    class g {
      constructor(e3, t3) {
        this.value = t3.value, this.viewProps = t3.viewProps, this.view = new m(e3, { viewProps: this.viewProps, extensions: t3.extensions, imageFit: t3.imageFit, clickCallback: t3.clickCallback }), this.onFile = this.onFile.bind(this), this.onDrop = this.onDrop.bind(this), this.onDragOver = this.onDragOver.bind(this), this.onDragLeave = this.onDragLeave.bind(this), this.view.input.addEventListener("change", this.onFile), this.view.element.addEventListener("drop", this.onDrop), this.view.element.addEventListener("dragover", this.onDragOver), this.view.element.addEventListener("dragleave", this.onDragLeave), this.viewProps.handleDispose(() => {
          this.view.input.removeEventListener("change", this.onFile), this.view.input.removeEventListener("drop", this.onDrop), this.view.input.removeEventListener("dragover", this.onDragOver), this.view.input.removeEventListener("dragleave", this.onDragLeave);
        }), this.value.emitter.on("change", this.handleValueChange.bind(this)), this.handleValueChange();
      }
      onFile(e3) {
        const t3 = (null == e3 ? void 0 : e3.target).files;
        if (!t3 || !t3.length)
          return;
        const n2 = t3[0];
        this.setValue(n2);
      }
      onDrop(e3) {
        return p(this, void 0, void 0, function* () {
          e3.preventDefault();
          try {
            const { dataTransfer: t3 } = e3, n2 = null == t3 ? void 0 : t3.files[0];
            if (n2)
              this.setValue(n2);
            else {
              const e4 = null == t3 ? void 0 : t3.getData("url");
              if (!e4)
                throw new Error("No url");
              this.setValue(e4);
            }
          } catch (e4) {
            console.error("Could not parse the dropped image", e4);
          } finally {
            this.view.changeDraggingState(false);
          }
        });
      }
      onDragOver(e3) {
        e3.preventDefault(), this.view.changeDraggingState(true);
      }
      onDragLeave() {
        this.view.changeDraggingState(false);
      }
      handleImage(e3) {
        return p(this, void 0, void 0, function* () {
          e3 instanceof HTMLImageElement ? this.updateImage(e3.src) : "string" != typeof e3 && e3 ? yield this.setValue(e3) : ("placeholder" !== e3 && e3 || (e3 = (yield this.handlePlaceholderImage()).src), this.updateImage(e3));
        });
      }
      updateImage(e3) {
        this.view.changeImage(e3);
      }
      setValue(e3) {
        return p(this, void 0, void 0, function* () {
          if (e3 instanceof HTMLImageElement)
            this.value.setRawValue(e3);
          else if (e3 instanceof File) {
            const t3 = URL.createObjectURL(e3) + "#" + e3.name;
            e3.src = t3;
            const n2 = yield d(t3).catch(() => {
            });
            this.value.setRawValue(n2 || e3);
          } else
            e3 ? this.value.setRawValue(yield d(e3)) : this.value.setRawValue(yield this.handlePlaceholderImage());
        });
      }
      handleValueChange() {
        this.handleImage(this.value.rawValue);
      }
      handlePlaceholderImage() {
        return p(this, void 0, void 0, function* () {
          return _ || (_ = yield function() {
            const e3 = document.createElement("canvas");
            e3.width = 320, e3.height = 50;
            const t3 = e3.getContext("2d");
            return t3.fillStyle = "#00000004", t3.fillRect(0, 0, e3.width, e3.height), t3.fillStyle = "#eee", t3.font = '1.25rem "Roboto Mono", "Source Code Pro", Menlo, Courier, monospace', t3.textAlign = "center", t3.textBaseline = "middle", t3.fillText("No image", 0.5 * e3.width, 0.5 * e3.height), new Promise((t4) => {
              e3.toBlob((e4) => {
                const n2 = new Image();
                n2.src = URL.createObjectURL(e4), n2.isPlaceholder = true, n2.onload = () => {
                  t4(n2);
                };
              });
            });
          }()), _;
        });
      }
    }
    const v = [".jpg", ".png", ".gif"], y = { id: "input-image", type: "input", css: ".tp-imgv{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-imgv{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-imgv:hover{background-color:var(--in-bg-h)}.tp-imgv:focus{background-color:var(--in-bg-f)}.tp-imgv:active{background-color:var(--in-bg-a)}.tp-imgv:disabled{opacity:.5}:root{--tp-plugin-image-dragging-color: hsla(230, 100%, 66%, 1.00)}.tp-imgv{cursor:pointer;display:inline-flex;height:auto !important;max-height:calc(var(--bld-us)*3);border-radius:4px;position:relative}.tp-imgv.tp-v-disabled{opacity:.5}.tp-imgv_input{width:0;height:0;pointer-events:none;visibility:hidden}.tp-imgv_image{width:100%;height:-moz-max-content;height:max-content;max-height:calc(var(--bld-us)*3);border:0}.tp-imgv_image_contain{-o-object-fit:contain;object-fit:contain}.tp-imgv_image_cover{-o-object-fit:cover;object-fit:cover}.tp-imgv_area_root{transition:opacity .16s ease-in-out}.tp-imgv_area_dragging{border:2px dashed var(--tp-plugin-image-dragging-color);border-radius:4px;opacity:.6}", accept(e3, t3) {
      if (!(e3 instanceof HTMLImageElement || "string" == typeof e3))
        return null;
      const n2 = i, r2 = function(e4, t4) {
        const n3 = i.required.object(t4)(e4);
        return n3.succeeded ? n3.value : void 0;
      }(t3, { view: n2.required.constant("input-image"), acceptUrl: n2.optional.boolean, clickCallback: n2.optional.function, imageFit: n2.optional.custom((e4) => "contain" === e4 || "cover" === e4 ? e4 : void 0), extensions: n2.optional.array(n2.required.string) });
      return r2 ? { initialValue: e3, params: r2 } : null;
    }, binding: { reader(e3) {
      return (e4) => void 0 !== e4.src ? "" === e4.src ? "placeholder" : e4.src : e4;
    }, writer(e3) {
      return (e4, t3) => {
        e4.write(t3);
      };
    } }, controller(e3) {
      var t3, n2;
      return new g(e3.document, { value: e3.value, imageFit: null !== (t3 = e3.params.imageFit) && void 0 !== t3 ? t3 : "cover", clickCallback: e3.params.clickCallback, viewProps: e3.viewProps, extensions: null !== (n2 = e3.params.extensions) && void 0 !== n2 ? n2 : v });
    } };
    e2.plugin = y, Object.defineProperty(e2, "__esModule", { value: true });
  }(t);
}, 665: function(e, t) {
  !function(e2) {
    class t2 {
      constructor(e3) {
        this.controller_ = e3;
      }
      get element() {
        return this.controller_.view.element;
      }
      get disabled() {
        return this.controller_.viewProps.get("disabled");
      }
      set disabled(e3) {
        this.controller_.viewProps.set("disabled", e3);
      }
      get hidden() {
        return this.controller_.viewProps.get("hidden");
      }
      set hidden(e3) {
        this.controller_.viewProps.set("hidden", e3);
      }
      dispose() {
        this.controller_.viewProps.set("disposed", true);
      }
    }
    class n {
      constructor(e3) {
        this.target = e3;
      }
    }
    class r extends n {
      constructor(e3, t3, n2, r2) {
        super(e3), this.value = t3, this.presetKey = n2, this.last = null == r2 || r2;
      }
    }
    class i extends n {
      constructor(e3, t3, n2) {
        super(e3), this.value = t3, this.presetKey = n2;
      }
    }
    class s extends n {
      constructor(e3, t3) {
        super(e3), this.expanded = t3;
      }
    }
    class o extends n {
      constructor(e3, t3) {
        super(e3), this.index = t3;
      }
    }
    function a(e3) {
      return null == e3;
    }
    function l(e3, t3) {
      if (e3.length !== t3.length)
        return false;
      for (let n2 = 0; n2 < e3.length; n2++)
        if (e3[n2] !== t3[n2])
          return false;
      return true;
    }
    function c(e3, t3) {
      let n2 = e3;
      do {
        const e4 = Object.getOwnPropertyDescriptor(n2, t3);
        if (e4 && (void 0 !== e4.set || true === e4.writable))
          return true;
        n2 = Object.getPrototypeOf(n2);
      } while (null !== n2);
      return false;
    }
    const u = { alreadydisposed: () => "View has been already disposed", invalidparams: (e3) => `Invalid parameters for '${e3.name}'`, nomatchingcontroller: (e3) => `No matching controller for '${e3.key}'`, nomatchingview: (e3) => `No matching view for '${JSON.stringify(e3.params)}'`, notbindable: () => "Value is not bindable", propertynotfound: (e3) => `Property '${e3.name}' not found`, shouldneverhappen: () => "This error should never happen" };
    class p {
      static alreadyDisposed() {
        return new p({ type: "alreadydisposed" });
      }
      static notBindable() {
        return new p({ type: "notbindable" });
      }
      static propertyNotFound(e3) {
        return new p({ type: "propertynotfound", context: { name: e3 } });
      }
      static shouldNeverHappen() {
        return new p({ type: "shouldneverhappen" });
      }
      constructor(e3) {
        var t3;
        this.message = null !== (t3 = u[e3.type](e3.context)) && void 0 !== t3 ? t3 : "Unexpected error", this.name = this.constructor.name, this.stack = new Error(this.message).stack, this.type = e3.type;
      }
    }
    class d {
      constructor(e3, t3, n2) {
        this.obj_ = e3, this.key_ = t3, this.presetKey_ = null != n2 ? n2 : t3;
      }
      static isBindable(e3) {
        return null !== e3 && "object" == typeof e3;
      }
      get key() {
        return this.key_;
      }
      get presetKey() {
        return this.presetKey_;
      }
      read() {
        return this.obj_[this.key_];
      }
      write(e3) {
        this.obj_[this.key_] = e3;
      }
      writeProperty(e3, t3) {
        const n2 = this.read();
        if (!d.isBindable(n2))
          throw p.notBindable();
        if (!(e3 in n2))
          throw p.propertyNotFound(e3);
        n2[e3] = t3;
      }
    }
    class h extends t2 {
      get label() {
        return this.controller_.props.get("label");
      }
      set label(e3) {
        this.controller_.props.set("label", e3);
      }
      get title() {
        var e3;
        return null !== (e3 = this.controller_.valueController.props.get("title")) && void 0 !== e3 ? e3 : "";
      }
      set title(e3) {
        this.controller_.valueController.props.set("title", e3);
      }
      on(e3, t3) {
        const r2 = t3.bind(this);
        return this.controller_.valueController.emitter.on(e3, () => {
          r2(new n(this));
        }), this;
      }
    }
    class f {
      constructor() {
        this.observers_ = {};
      }
      on(e3, t3) {
        let n2 = this.observers_[e3];
        return n2 || (n2 = this.observers_[e3] = []), n2.push({ handler: t3 }), this;
      }
      off(e3, t3) {
        const n2 = this.observers_[e3];
        return n2 && (this.observers_[e3] = n2.filter((e4) => e4.handler !== t3)), this;
      }
      emit(e3, t3) {
        const n2 = this.observers_[e3];
        n2 && n2.forEach((e4) => {
          e4.handler(t3);
        });
      }
    }
    const m = "tp";
    function _(e3) {
      return (t3, n2) => [m, "-", e3, "v", t3 ? `_${t3}` : "", n2 ? `-${n2}` : ""].join("");
    }
    function g(e3) {
      return e3.rawValue;
    }
    function v(e3, t3) {
      var n2, r2;
      e3.emitter.on("change", (n2 = g, r2 = t3, (e4) => r2(n2(e4)))), t3(e3.rawValue);
    }
    function y(e3, t3, n2) {
      v(e3.value(t3), n2);
    }
    function b(e3, t3) {
      return (n2) => {
        !function(e4, t4, n3) {
          n3 ? e4.classList.add(t4) : e4.classList.remove(t4);
        }(e3, t3, n2);
      };
    }
    function w(e3, t3) {
      v(e3, (e4) => {
        t3.textContent = null != e4 ? e4 : "";
      });
    }
    const A = _("btn");
    class x {
      constructor(e3, t3) {
        this.element = e3.createElement("div"), this.element.classList.add(A()), t3.viewProps.bindClassModifiers(this.element);
        const n2 = e3.createElement("button");
        n2.classList.add(A("b")), t3.viewProps.bindDisabled(n2), this.element.appendChild(n2), this.buttonElement = n2;
        const r2 = e3.createElement("div");
        r2.classList.add(A("t")), w(t3.props.value("title"), r2), this.buttonElement.appendChild(r2);
      }
    }
    class E {
      constructor(e3, t3) {
        this.emitter = new f(), this.onClick_ = this.onClick_.bind(this), this.props = t3.props, this.viewProps = t3.viewProps, this.view = new x(e3, { props: this.props, viewProps: this.viewProps }), this.view.buttonElement.addEventListener("click", this.onClick_);
      }
      onClick_() {
        this.emitter.emit("click", { sender: this });
      }
    }
    class C {
      constructor(e3, t3) {
        var n2;
        this.constraint_ = null == t3 ? void 0 : t3.constraint, this.equals_ = null !== (n2 = null == t3 ? void 0 : t3.equals) && void 0 !== n2 ? n2 : (e4, t4) => e4 === t4, this.emitter = new f(), this.rawValue_ = e3;
      }
      get constraint() {
        return this.constraint_;
      }
      get rawValue() {
        return this.rawValue_;
      }
      set rawValue(e3) {
        this.setRawValue(e3, { forceEmit: false, last: true });
      }
      setRawValue(e3, t3) {
        const n2 = null != t3 ? t3 : { forceEmit: false, last: true }, r2 = this.constraint_ ? this.constraint_.constrain(e3) : e3, i2 = this.rawValue_;
        (!this.equals_(i2, r2) || n2.forceEmit) && (this.emitter.emit("beforechange", { sender: this }), this.rawValue_ = r2, this.emitter.emit("change", { options: n2, previousRawValue: i2, rawValue: r2, sender: this }));
      }
    }
    class S {
      constructor(e3) {
        this.emitter = new f(), this.value_ = e3;
      }
      get rawValue() {
        return this.value_;
      }
      set rawValue(e3) {
        this.setRawValue(e3, { forceEmit: false, last: true });
      }
      setRawValue(e3, t3) {
        const n2 = null != t3 ? t3 : { forceEmit: false, last: true }, r2 = this.value_;
        (r2 !== e3 || n2.forceEmit) && (this.emitter.emit("beforechange", { sender: this }), this.value_ = e3, this.emitter.emit("change", { options: n2, previousRawValue: r2, rawValue: this.value_, sender: this }));
      }
    }
    function M(e3, t3) {
      const n2 = null == t3 ? void 0 : t3.constraint, r2 = null == t3 ? void 0 : t3.equals;
      return n2 || r2 ? new C(e3, t3) : new S(e3);
    }
    class T {
      constructor(e3) {
        this.emitter = new f(), this.valMap_ = e3;
        for (const e4 in this.valMap_)
          this.valMap_[e4].emitter.on("change", () => {
            this.emitter.emit("change", { key: e4, sender: this });
          });
      }
      static createCore(e3) {
        return Object.keys(e3).reduce((t3, n2) => Object.assign(t3, { [n2]: M(e3[n2]) }), {});
      }
      static fromObject(e3) {
        const t3 = this.createCore(e3);
        return new T(t3);
      }
      get(e3) {
        return this.valMap_[e3].rawValue;
      }
      set(e3, t3) {
        this.valMap_[e3].rawValue = t3;
      }
      value(e3) {
        return this.valMap_[e3];
      }
    }
    function P(e3) {
      return (t3) => (n2) => {
        if (!t3 && void 0 === n2)
          return { succeeded: false, value: void 0 };
        if (t3 && void 0 === n2)
          return { succeeded: true, value: void 0 };
        const r2 = e3(n2);
        return void 0 !== r2 ? { succeeded: true, value: r2 } : { succeeded: false, value: void 0 };
      };
    }
    function I(e3) {
      return { custom: (t3) => P(t3)(e3), boolean: P((e4) => "boolean" == typeof e4 ? e4 : void 0)(e3), number: P((e4) => "number" == typeof e4 ? e4 : void 0)(e3), string: P((e4) => "string" == typeof e4 ? e4 : void 0)(e3), function: P((e4) => "function" == typeof e4 ? e4 : void 0)(e3), constant: (t3) => P((e4) => e4 === t3 ? t3 : void 0)(e3), raw: P((e4) => e4)(e3), object: (t3) => P((e4) => {
        if (null !== (n2 = e4) && "object" == typeof n2)
          return function(e5, t4) {
            return Object.keys(t4).reduce((n3, r2) => {
              if (void 0 === n3)
                return;
              const i2 = (0, t4[r2])(e5[r2]);
              return i2.succeeded ? Object.assign(Object.assign({}, n3), { [r2]: i2.value }) : void 0;
            }, {});
          }(e4, t3);
        var n2;
      })(e3), array: (t3) => P((e4) => {
        if (Array.isArray(e4))
          return n2 = t3, e4.reduce((e5, t4) => {
            if (void 0 === e5)
              return;
            const r2 = n2(t4);
            return r2.succeeded && void 0 !== r2.value ? [...e5, r2.value] : void 0;
          }, []);
        var n2;
      })(e3) };
    }
    const R = { optional: I(true), required: I(false) };
    function k(e3, t3) {
      const n2 = R.required.object(t3)(e3);
      return n2.succeeded ? n2.value : void 0;
    }
    function D(e3) {
      console.warn([`Missing '${e3.key}' of ${e3.target} in ${e3.place}.`, "Please rebuild plugins with the latest core package."].join(" "));
    }
    class B {
      constructor(e3) {
        this.value_ = e3;
      }
      static create(e3) {
        return [new B(e3), (t3, n2) => {
          e3.setRawValue(t3, n2);
        }];
      }
      get emitter() {
        return this.value_.emitter;
      }
      get rawValue() {
        return this.value_.rawValue;
      }
    }
    const O = _("");
    function L(e3, t3) {
      return b(e3, O(void 0, t3));
    }
    class U extends T {
      constructor(e3) {
        var t3;
        super(e3), this.onDisabledChange_ = this.onDisabledChange_.bind(this), this.onParentChange_ = this.onParentChange_.bind(this), this.onParentGlobalDisabledChange_ = this.onParentGlobalDisabledChange_.bind(this), [this.globalDisabled_, this.setGlobalDisabled_] = B.create(M(this.getGlobalDisabled_())), this.value("disabled").emitter.on("change", this.onDisabledChange_), this.value("parent").emitter.on("change", this.onParentChange_), null === (t3 = this.get("parent")) || void 0 === t3 || t3.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_);
      }
      static create(e3) {
        var t3, n2, r2;
        const i2 = null != e3 ? e3 : {};
        return new U(T.createCore({ disabled: null !== (t3 = i2.disabled) && void 0 !== t3 && t3, disposed: false, hidden: null !== (n2 = i2.hidden) && void 0 !== n2 && n2, parent: null !== (r2 = i2.parent) && void 0 !== r2 ? r2 : null }));
      }
      get globalDisabled() {
        return this.globalDisabled_;
      }
      bindClassModifiers(e3) {
        v(this.globalDisabled_, L(e3, "disabled")), y(this, "hidden", L(e3, "hidden"));
      }
      bindDisabled(e3) {
        v(this.globalDisabled_, (t3) => {
          e3.disabled = t3;
        });
      }
      bindTabIndex(e3) {
        v(this.globalDisabled_, (t3) => {
          e3.tabIndex = t3 ? -1 : 0;
        });
      }
      handleDispose(e3) {
        this.value("disposed").emitter.on("change", (t3) => {
          t3 && e3();
        });
      }
      getGlobalDisabled_() {
        const e3 = this.get("parent");
        return !!e3 && e3.globalDisabled.rawValue || this.get("disabled");
      }
      updateGlobalDisabled_() {
        this.setGlobalDisabled_(this.getGlobalDisabled_());
      }
      onDisabledChange_() {
        this.updateGlobalDisabled_();
      }
      onParentGlobalDisabledChange_() {
        this.updateGlobalDisabled_();
      }
      onParentChange_(e3) {
        var t3;
        const n2 = e3.previousRawValue;
        null == n2 || n2.globalDisabled.emitter.off("change", this.onParentGlobalDisabledChange_), null === (t3 = this.get("parent")) || void 0 === t3 || t3.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_), this.updateGlobalDisabled_();
      }
    }
    const F = _(""), N = { veryfirst: "vfst", first: "fst", last: "lst", verylast: "vlst" };
    class j {
      constructor(e3) {
        this.parent_ = null, this.blade = e3.blade, this.view = e3.view, this.viewProps = e3.viewProps;
        const t3 = this.view.element;
        this.blade.value("positions").emitter.on("change", () => {
          ["veryfirst", "first", "last", "verylast"].forEach((e4) => {
            t3.classList.remove(F(void 0, N[e4]));
          }), this.blade.get("positions").forEach((e4) => {
            t3.classList.add(F(void 0, N[e4]));
          });
        }), this.viewProps.handleDispose(() => {
          !function(e4) {
            e4 && e4.parentElement && e4.parentElement.removeChild(e4);
          }(t3);
        });
      }
      get parent() {
        return this.parent_;
      }
      set parent(e3) {
        this.parent_ = e3, "parent" in this.viewProps.valMap_ ? this.viewProps.set("parent", this.parent_ ? this.parent_.viewProps : null) : D({ key: "parent", target: U.name, place: "BladeController.parent" });
      }
    }
    const z = "http://www.w3.org/2000/svg";
    function G(e3) {
      e3.offsetHeight;
    }
    function V(e3) {
      return void 0 !== e3.ontouchstart;
    }
    function H() {
      return globalThis.document;
    }
    const Q = { check: '<path d="M2 8l4 4l8 -8"/>', dropdown: '<path d="M5 7h6l-3 3 z"/>', p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>' };
    function W(e3, t3) {
      const n2 = e3.createElementNS(z, "svg");
      return n2.innerHTML = Q[t3], n2;
    }
    function q(e3, t3, n2) {
      e3.insertBefore(t3, e3.children[n2]);
    }
    function X(e3) {
      e3.parentElement && e3.parentElement.removeChild(e3);
    }
    function Y(e3) {
      for (; e3.children.length > 0; )
        e3.removeChild(e3.children[0]);
    }
    function K(e3) {
      return e3.relatedTarget ? e3.relatedTarget : "explicitOriginalTarget" in e3 ? e3.explicitOriginalTarget : null;
    }
    const J = _("lbl");
    class Z {
      constructor(e3, t3) {
        this.element = e3.createElement("div"), this.element.classList.add(J()), t3.viewProps.bindClassModifiers(this.element);
        const n2 = e3.createElement("div");
        n2.classList.add(J("l")), y(t3.props, "label", (t4) => {
          a(t4) ? this.element.classList.add(J(void 0, "nol")) : (this.element.classList.remove(J(void 0, "nol")), function(e4) {
            for (; e4.childNodes.length > 0; )
              e4.removeChild(e4.childNodes[0]);
          }(n2), n2.appendChild(function(e4, t5) {
            const n3 = e4.createDocumentFragment();
            return t5.split("\n").map((t6) => e4.createTextNode(t6)).forEach((t6, r3) => {
              r3 > 0 && n3.appendChild(e4.createElement("br")), n3.appendChild(t6);
            }), n3;
          }(e3, t4)));
        }), this.element.appendChild(n2), this.labelElement = n2;
        const r2 = e3.createElement("div");
        r2.classList.add(J("v")), this.element.appendChild(r2), this.valueElement = r2;
      }
    }
    class $ extends j {
      constructor(e3, t3) {
        const n2 = t3.valueController.viewProps;
        super(Object.assign(Object.assign({}, t3), { view: new Z(e3, { props: t3.props, viewProps: n2 }), viewProps: n2 })), this.props = t3.props, this.valueController = t3.valueController, this.view.valueElement.appendChild(this.valueController.view.element);
      }
    }
    const ee = { id: "button", type: "blade", accept(e3) {
      const t3 = R, n2 = k(e3, { title: t3.required.string, view: t3.required.constant("button"), label: t3.optional.string });
      return n2 ? { params: n2 } : null;
    }, controller(e3) {
      return new $(e3.document, { blade: e3.blade, props: T.fromObject({ label: e3.params.label }), valueController: new E(e3.document, { props: T.fromObject({ title: e3.params.title }), viewProps: e3.viewProps }) });
    }, api(e3) {
      return e3.controller instanceof $ && e3.controller.valueController instanceof E ? new h(e3.controller) : null;
    } };
    class te extends j {
      constructor(e3) {
        super(e3), this.value = e3.value;
      }
    }
    function ne() {
      return new T({ positions: M([], { equals: l }) });
    }
    class re extends T {
      constructor(e3) {
        super(e3);
      }
      static create(e3) {
        const t3 = { completed: true, expanded: e3, expandedHeight: null, shouldFixHeight: false, temporaryExpanded: null }, n2 = T.createCore(t3);
        return new re(n2);
      }
      get styleExpanded() {
        var e3;
        return null !== (e3 = this.get("temporaryExpanded")) && void 0 !== e3 ? e3 : this.get("expanded");
      }
      get styleHeight() {
        if (!this.styleExpanded)
          return "0";
        const e3 = this.get("expandedHeight");
        return this.get("shouldFixHeight") && !a(e3) ? `${e3}px` : "auto";
      }
      bindExpandedClass(e3, t3) {
        const n2 = () => {
          this.styleExpanded ? e3.classList.add(t3) : e3.classList.remove(t3);
        };
        y(this, "expanded", n2), y(this, "temporaryExpanded", n2);
      }
      cleanUpTransition() {
        this.set("shouldFixHeight", false), this.set("expandedHeight", null), this.set("completed", true);
      }
    }
    function ie(e3, t3) {
      t3.style.height = e3.styleHeight;
    }
    function se(e3, t3) {
      e3.value("expanded").emitter.on("beforechange", () => {
        if (e3.set("completed", false), a(e3.get("expandedHeight"))) {
          const n2 = function(e4, t4) {
            let n3 = 0;
            return function(e5, t5) {
              const n4 = e5.style.transition;
              e5.style.transition = "none", t5(), e5.style.transition = n4;
            }(t4, () => {
              e4.set("expandedHeight", null), e4.set("temporaryExpanded", true), G(t4), n3 = t4.clientHeight, e4.set("temporaryExpanded", null), G(t4);
            }), n3;
          }(e3, t3);
          n2 > 0 && e3.set("expandedHeight", n2);
        }
        e3.set("shouldFixHeight", true), G(t3);
      }), e3.emitter.on("change", () => {
        ie(e3, t3);
      }), ie(e3, t3), t3.addEventListener("transitionend", (t4) => {
        "height" === t4.propertyName && e3.cleanUpTransition();
      });
    }
    class oe extends t2 {
      constructor(e3, t3) {
        super(e3), this.rackApi_ = t3;
      }
    }
    class ae {
      constructor(e3) {
        this.emitter = new f(), this.items_ = [], this.cache_ = /* @__PURE__ */ new Set(), this.onSubListAdd_ = this.onSubListAdd_.bind(this), this.onSubListRemove_ = this.onSubListRemove_.bind(this), this.extract_ = e3;
      }
      get items() {
        return this.items_;
      }
      allItems() {
        return Array.from(this.cache_);
      }
      find(e3) {
        for (const t3 of this.allItems())
          if (e3(t3))
            return t3;
        return null;
      }
      includes(e3) {
        return this.cache_.has(e3);
      }
      add(e3, t3) {
        if (this.includes(e3))
          throw p.shouldNeverHappen();
        const n2 = void 0 !== t3 ? t3 : this.items_.length;
        this.items_.splice(n2, 0, e3), this.cache_.add(e3);
        const r2 = this.extract_(e3);
        r2 && (r2.emitter.on("add", this.onSubListAdd_), r2.emitter.on("remove", this.onSubListRemove_), r2.allItems().forEach((e4) => {
          this.cache_.add(e4);
        })), this.emitter.emit("add", { index: n2, item: e3, root: this, target: this });
      }
      remove(e3) {
        const t3 = this.items_.indexOf(e3);
        if (t3 < 0)
          return;
        this.items_.splice(t3, 1), this.cache_.delete(e3);
        const n2 = this.extract_(e3);
        n2 && (n2.emitter.off("add", this.onSubListAdd_), n2.emitter.off("remove", this.onSubListRemove_)), this.emitter.emit("remove", { index: t3, item: e3, root: this, target: this });
      }
      onSubListAdd_(e3) {
        this.cache_.add(e3.item), this.emitter.emit("add", { index: e3.index, item: e3.item, root: this, target: e3.target });
      }
      onSubListRemove_(e3) {
        this.cache_.delete(e3.item), this.emitter.emit("remove", { index: e3.index, item: e3.item, root: this, target: e3.target });
      }
    }
    class le extends t2 {
      constructor(e3) {
        super(e3), this.onBindingChange_ = this.onBindingChange_.bind(this), this.emitter_ = new f(), this.controller_.binding.emitter.on("change", this.onBindingChange_);
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(e3) {
        this.controller_.props.set("label", e3);
      }
      on(e3, t3) {
        const n2 = t3.bind(this);
        return this.emitter_.on(e3, (e4) => {
          n2(e4.event);
        }), this;
      }
      refresh() {
        this.controller_.binding.read();
      }
      onBindingChange_(e3) {
        const t3 = e3.sender.target.read();
        this.emitter_.emit("change", { event: new r(this, t3, this.controller_.binding.target.presetKey, e3.options.last) });
      }
    }
    class ce extends $ {
      constructor(e3, t3) {
        super(e3, t3), this.binding = t3.binding;
      }
    }
    class ue extends t2 {
      constructor(e3) {
        super(e3), this.onBindingUpdate_ = this.onBindingUpdate_.bind(this), this.emitter_ = new f(), this.controller_.binding.emitter.on("update", this.onBindingUpdate_);
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(e3) {
        this.controller_.props.set("label", e3);
      }
      on(e3, t3) {
        const n2 = t3.bind(this);
        return this.emitter_.on(e3, (e4) => {
          n2(e4.event);
        }), this;
      }
      refresh() {
        this.controller_.binding.read();
      }
      onBindingUpdate_(e3) {
        const t3 = e3.sender.target.read();
        this.emitter_.emit("update", { event: new i(this, t3, this.controller_.binding.target.presetKey) });
      }
    }
    class pe extends $ {
      constructor(e3, t3) {
        super(e3, t3), this.binding = t3.binding, this.viewProps.bindDisabled(this.binding.ticker), this.viewProps.handleDispose(() => {
          this.binding.dispose();
        });
      }
    }
    function de(e3) {
      return e3 instanceof me ? e3.apiSet_ : e3 instanceof oe ? e3.rackApi_.apiSet_ : null;
    }
    function he(e3, t3) {
      const n2 = e3.find((e4) => e4.controller_ === t3);
      if (!n2)
        throw p.shouldNeverHappen();
      return n2;
    }
    function fe(e3, t3, n2) {
      if (!d.isBindable(e3))
        throw p.notBindable();
      return new d(e3, t3, n2);
    }
    class me extends t2 {
      constructor(e3, t3) {
        super(e3), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this), this.onRackInputChange_ = this.onRackInputChange_.bind(this), this.onRackMonitorUpdate_ = this.onRackMonitorUpdate_.bind(this), this.emitter_ = new f(), this.apiSet_ = new ae(de), this.pool_ = t3;
        const n2 = this.controller_.rack;
        n2.emitter.on("add", this.onRackAdd_), n2.emitter.on("remove", this.onRackRemove_), n2.emitter.on("inputchange", this.onRackInputChange_), n2.emitter.on("monitorupdate", this.onRackMonitorUpdate_), n2.children.forEach((e4) => {
          this.setUpApi_(e4);
        });
      }
      get children() {
        return this.controller_.rack.children.map((e3) => he(this.apiSet_, e3));
      }
      addInput(e3, t3, n2) {
        const r2 = null != n2 ? n2 : {}, i2 = this.controller_.view.element.ownerDocument, s2 = this.pool_.createInput(i2, fe(e3, t3, r2.presetKey), r2), o2 = new le(s2);
        return this.add(o2, r2.index);
      }
      addMonitor(e3, t3, n2) {
        const r2 = null != n2 ? n2 : {}, i2 = this.controller_.view.element.ownerDocument, s2 = this.pool_.createMonitor(i2, fe(e3, t3), r2), o2 = new ue(s2);
        return this.add(o2, r2.index);
      }
      addFolder(e3) {
        return function(e4, t3) {
          return e4.addBlade(Object.assign(Object.assign({}, t3), { view: "folder" }));
        }(this, e3);
      }
      addButton(e3) {
        return function(e4, t3) {
          return e4.addBlade(Object.assign(Object.assign({}, t3), { view: "button" }));
        }(this, e3);
      }
      addSeparator(e3) {
        return function(e4, t3) {
          const n2 = null != t3 ? t3 : {};
          return e4.addBlade(Object.assign(Object.assign({}, n2), { view: "separator" }));
        }(this, e3);
      }
      addTab(e3) {
        return function(e4, t3) {
          return e4.addBlade(Object.assign(Object.assign({}, t3), { view: "tab" }));
        }(this, e3);
      }
      add(e3, t3) {
        this.controller_.rack.add(e3.controller_, t3);
        const n2 = this.apiSet_.find((t4) => t4.controller_ === e3.controller_);
        return n2 && this.apiSet_.remove(n2), this.apiSet_.add(e3), e3;
      }
      remove(e3) {
        this.controller_.rack.remove(e3.controller_);
      }
      addBlade(e3) {
        const t3 = this.controller_.view.element.ownerDocument, n2 = this.pool_.createBlade(t3, e3), r2 = this.pool_.createBladeApi(n2);
        return this.add(r2, e3.index);
      }
      on(e3, t3) {
        const n2 = t3.bind(this);
        return this.emitter_.on(e3, (e4) => {
          n2(e4.event);
        }), this;
      }
      setUpApi_(e3) {
        this.apiSet_.find((t3) => t3.controller_ === e3) || this.apiSet_.add(this.pool_.createBladeApi(e3));
      }
      onRackAdd_(e3) {
        this.setUpApi_(e3.bladeController);
      }
      onRackRemove_(e3) {
        if (e3.isRoot) {
          const t3 = he(this.apiSet_, e3.bladeController);
          this.apiSet_.remove(t3);
        }
      }
      onRackInputChange_(e3) {
        const t3 = e3.bladeController;
        if (t3 instanceof ce) {
          const n2 = he(this.apiSet_, t3), i2 = t3.binding;
          this.emitter_.emit("change", { event: new r(n2, i2.target.read(), i2.target.presetKey, e3.options.last) });
        } else if (t3 instanceof te) {
          const n2 = he(this.apiSet_, t3);
          this.emitter_.emit("change", { event: new r(n2, t3.value.rawValue, void 0, e3.options.last) });
        }
      }
      onRackMonitorUpdate_(e3) {
        if (!(e3.bladeController instanceof pe))
          throw p.shouldNeverHappen();
        const t3 = he(this.apiSet_, e3.bladeController), n2 = e3.bladeController.binding;
        this.emitter_.emit("update", { event: new i(t3, n2.target.read(), n2.target.presetKey) });
      }
    }
    class _e extends oe {
      constructor(e3, t3) {
        super(e3, new me(e3.rackController, t3)), this.emitter_ = new f(), this.controller_.foldable.value("expanded").emitter.on("change", (e4) => {
          this.emitter_.emit("fold", { event: new s(this, e4.sender.rawValue) });
        }), this.rackApi_.on("change", (e4) => {
          this.emitter_.emit("change", { event: e4 });
        }), this.rackApi_.on("update", (e4) => {
          this.emitter_.emit("update", { event: e4 });
        });
      }
      get expanded() {
        return this.controller_.foldable.get("expanded");
      }
      set expanded(e3) {
        this.controller_.foldable.set("expanded", e3);
      }
      get title() {
        return this.controller_.props.get("title");
      }
      set title(e3) {
        this.controller_.props.set("title", e3);
      }
      get children() {
        return this.rackApi_.children;
      }
      addInput(e3, t3, n2) {
        return this.rackApi_.addInput(e3, t3, n2);
      }
      addMonitor(e3, t3, n2) {
        return this.rackApi_.addMonitor(e3, t3, n2);
      }
      addFolder(e3) {
        return this.rackApi_.addFolder(e3);
      }
      addButton(e3) {
        return this.rackApi_.addButton(e3);
      }
      addSeparator(e3) {
        return this.rackApi_.addSeparator(e3);
      }
      addTab(e3) {
        return this.rackApi_.addTab(e3);
      }
      add(e3, t3) {
        return this.rackApi_.add(e3, t3);
      }
      remove(e3) {
        this.rackApi_.remove(e3);
      }
      addBlade(e3) {
        return this.rackApi_.addBlade(e3);
      }
      on(e3, t3) {
        const n2 = t3.bind(this);
        return this.emitter_.on(e3, (e4) => {
          n2(e4.event);
        }), this;
      }
    }
    class ge extends j {
      constructor(e3) {
        super({ blade: e3.blade, view: e3.view, viewProps: e3.rackController.viewProps }), this.rackController = e3.rackController;
      }
    }
    class ve {
      constructor(e3, t3) {
        const n2 = _(t3.viewName);
        this.element = e3.createElement("div"), this.element.classList.add(n2()), t3.viewProps.bindClassModifiers(this.element);
      }
    }
    function ye(e3) {
      return e3 instanceof Ae ? e3.rack : e3 instanceof ge ? e3.rackController.rack : null;
    }
    function be(e3) {
      const t3 = ye(e3);
      return t3 ? t3.bcSet_ : null;
    }
    class we {
      constructor(e3) {
        var t3, n2;
        this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this), this.onSetAdd_ = this.onSetAdd_.bind(this), this.onSetRemove_ = this.onSetRemove_.bind(this), this.onChildDispose_ = this.onChildDispose_.bind(this), this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this), this.onChildInputChange_ = this.onChildInputChange_.bind(this), this.onChildMonitorUpdate_ = this.onChildMonitorUpdate_.bind(this), this.onChildValueChange_ = this.onChildValueChange_.bind(this), this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this), this.onDescendantLayout_ = this.onDescendantLayout_.bind(this), this.onDescendantInputChange_ = this.onDescendantInputChange_.bind(this), this.onDescendantMonitorUpdate_ = this.onDescendantMonitorUpdate_.bind(this), this.emitter = new f(), this.blade_ = null !== (t3 = e3.blade) && void 0 !== t3 ? t3 : null, null === (n2 = this.blade_) || void 0 === n2 || n2.value("positions").emitter.on("change", this.onBladePositionsChange_), this.viewProps = e3.viewProps, this.bcSet_ = new ae(be), this.bcSet_.emitter.on("add", this.onSetAdd_), this.bcSet_.emitter.on("remove", this.onSetRemove_);
      }
      get children() {
        return this.bcSet_.items;
      }
      add(e3, t3) {
        var n2;
        null === (n2 = e3.parent) || void 0 === n2 || n2.remove(e3), c(e3, "parent") ? e3.parent = this : (e3.parent_ = this, D({ key: "parent", target: "BladeController", place: "BladeRack.add" })), this.bcSet_.add(e3, t3);
      }
      remove(e3) {
        c(e3, "parent") ? e3.parent = null : (e3.parent_ = null, D({ key: "parent", target: "BladeController", place: "BladeRack.remove" })), this.bcSet_.remove(e3);
      }
      find(e3) {
        return this.bcSet_.allItems().filter((t3) => t3 instanceof e3);
      }
      onSetAdd_(e3) {
        this.updatePositions_();
        const t3 = e3.target === e3.root;
        if (this.emitter.emit("add", { bladeController: e3.item, index: e3.index, isRoot: t3, sender: this }), !t3)
          return;
        const n2 = e3.item;
        if (n2.viewProps.emitter.on("change", this.onChildViewPropsChange_), n2.blade.value("positions").emitter.on("change", this.onChildPositionsChange_), n2.viewProps.handleDispose(this.onChildDispose_), n2 instanceof ce)
          n2.binding.emitter.on("change", this.onChildInputChange_);
        else if (n2 instanceof pe)
          n2.binding.emitter.on("update", this.onChildMonitorUpdate_);
        else if (n2 instanceof te)
          n2.value.emitter.on("change", this.onChildValueChange_);
        else {
          const e4 = ye(n2);
          if (e4) {
            const t4 = e4.emitter;
            t4.on("layout", this.onDescendantLayout_), t4.on("inputchange", this.onDescendantInputChange_), t4.on("monitorupdate", this.onDescendantMonitorUpdate_);
          }
        }
      }
      onSetRemove_(e3) {
        this.updatePositions_();
        const t3 = e3.target === e3.root;
        if (this.emitter.emit("remove", { bladeController: e3.item, isRoot: t3, sender: this }), !t3)
          return;
        const n2 = e3.item;
        if (n2 instanceof ce)
          n2.binding.emitter.off("change", this.onChildInputChange_);
        else if (n2 instanceof pe)
          n2.binding.emitter.off("update", this.onChildMonitorUpdate_);
        else if (n2 instanceof te)
          n2.value.emitter.off("change", this.onChildValueChange_);
        else {
          const e4 = ye(n2);
          if (e4) {
            const t4 = e4.emitter;
            t4.off("layout", this.onDescendantLayout_), t4.off("inputchange", this.onDescendantInputChange_), t4.off("monitorupdate", this.onDescendantMonitorUpdate_);
          }
        }
      }
      updatePositions_() {
        const e3 = this.bcSet_.items.filter((e4) => !e4.viewProps.get("hidden")), t3 = e3[0], n2 = e3[e3.length - 1];
        this.bcSet_.items.forEach((e4) => {
          const r2 = [];
          e4 === t3 && (r2.push("first"), this.blade_ && !this.blade_.get("positions").includes("veryfirst") || r2.push("veryfirst")), e4 === n2 && (r2.push("last"), this.blade_ && !this.blade_.get("positions").includes("verylast") || r2.push("verylast")), e4.blade.set("positions", r2);
        });
      }
      onChildPositionsChange_() {
        this.updatePositions_(), this.emitter.emit("layout", { sender: this });
      }
      onChildViewPropsChange_(e3) {
        this.updatePositions_(), this.emitter.emit("layout", { sender: this });
      }
      onChildDispose_() {
        this.bcSet_.items.filter((e3) => e3.viewProps.get("disposed")).forEach((e3) => {
          this.bcSet_.remove(e3);
        });
      }
      onChildInputChange_(e3) {
        const t3 = function(e4, t4) {
          for (let n2 = 0; n2 < e4.length; n2++) {
            const r2 = e4[n2];
            if (r2 instanceof ce && r2.binding === t4)
              return r2;
          }
          return null;
        }(this.find(ce), e3.sender);
        if (!t3)
          throw p.alreadyDisposed();
        this.emitter.emit("inputchange", { bladeController: t3, options: e3.options, sender: this });
      }
      onChildMonitorUpdate_(e3) {
        const t3 = function(e4, t4) {
          for (let n2 = 0; n2 < e4.length; n2++) {
            const r2 = e4[n2];
            if (r2 instanceof pe && r2.binding === t4)
              return r2;
          }
          return null;
        }(this.find(pe), e3.sender);
        if (!t3)
          throw p.alreadyDisposed();
        this.emitter.emit("monitorupdate", { bladeController: t3, sender: this });
      }
      onChildValueChange_(e3) {
        const t3 = function(e4, t4) {
          for (let n2 = 0; n2 < e4.length; n2++) {
            const r2 = e4[n2];
            if (r2 instanceof te && r2.value === t4)
              return r2;
          }
          return null;
        }(this.find(te), e3.sender);
        if (!t3)
          throw p.alreadyDisposed();
        this.emitter.emit("inputchange", { bladeController: t3, options: e3.options, sender: this });
      }
      onDescendantLayout_(e3) {
        this.updatePositions_(), this.emitter.emit("layout", { sender: this });
      }
      onDescendantInputChange_(e3) {
        this.emitter.emit("inputchange", { bladeController: e3.bladeController, options: e3.options, sender: this });
      }
      onDescendantMonitorUpdate_(e3) {
        this.emitter.emit("monitorupdate", { bladeController: e3.bladeController, sender: this });
      }
      onBladePositionsChange_() {
        this.updatePositions_();
      }
    }
    class Ae extends j {
      constructor(e3, t3) {
        super(Object.assign(Object.assign({}, t3), { view: new ve(e3, { viewName: "brk", viewProps: t3.viewProps }) })), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this);
        const n2 = new we({ blade: t3.root ? void 0 : t3.blade, viewProps: t3.viewProps });
        n2.emitter.on("add", this.onRackAdd_), n2.emitter.on("remove", this.onRackRemove_), this.rack = n2, this.viewProps.handleDispose(() => {
          for (let e4 = this.rack.children.length - 1; e4 >= 0; e4--)
            this.rack.children[e4].viewProps.set("disposed", true);
        });
      }
      onRackAdd_(e3) {
        e3.isRoot && q(this.view.element, e3.bladeController.view.element, e3.index);
      }
      onRackRemove_(e3) {
        e3.isRoot && X(e3.bladeController.view.element);
      }
    }
    const xe = _("cnt");
    class Ee {
      constructor(e3, t3) {
        var n2;
        this.className_ = _(null !== (n2 = t3.viewName) && void 0 !== n2 ? n2 : "fld"), this.element = e3.createElement("div"), this.element.classList.add(this.className_(), xe()), t3.viewProps.bindClassModifiers(this.element), this.foldable_ = t3.foldable, this.foldable_.bindExpandedClass(this.element, this.className_(void 0, "expanded")), y(this.foldable_, "completed", b(this.element, this.className_(void 0, "cpl")));
        const r2 = e3.createElement("button");
        r2.classList.add(this.className_("b")), y(t3.props, "title", (e4) => {
          a(e4) ? this.element.classList.add(this.className_(void 0, "not")) : this.element.classList.remove(this.className_(void 0, "not"));
        }), t3.viewProps.bindDisabled(r2), this.element.appendChild(r2), this.buttonElement = r2;
        const i2 = e3.createElement("div");
        i2.classList.add(this.className_("i")), this.element.appendChild(i2);
        const s2 = e3.createElement("div");
        s2.classList.add(this.className_("t")), w(t3.props.value("title"), s2), this.buttonElement.appendChild(s2), this.titleElement = s2;
        const o2 = e3.createElement("div");
        o2.classList.add(this.className_("m")), this.buttonElement.appendChild(o2);
        const l2 = t3.containerElement;
        l2.classList.add(this.className_("c")), this.element.appendChild(l2), this.containerElement = l2;
      }
    }
    class Ce extends ge {
      constructor(e3, t3) {
        var n2;
        const r2 = re.create(null === (n2 = t3.expanded) || void 0 === n2 || n2), i2 = new Ae(e3, { blade: t3.blade, root: t3.root, viewProps: t3.viewProps });
        super(Object.assign(Object.assign({}, t3), { rackController: i2, view: new Ee(e3, { containerElement: i2.view.element, foldable: r2, props: t3.props, viewName: t3.root ? "rot" : void 0, viewProps: t3.viewProps }) })), this.onTitleClick_ = this.onTitleClick_.bind(this), this.props = t3.props, this.foldable = r2, se(this.foldable, this.view.containerElement), this.rackController.rack.emitter.on("add", () => {
          this.foldable.cleanUpTransition();
        }), this.rackController.rack.emitter.on("remove", () => {
          this.foldable.cleanUpTransition();
        }), this.view.buttonElement.addEventListener("click", this.onTitleClick_);
      }
      get document() {
        return this.view.element.ownerDocument;
      }
      onTitleClick_() {
        this.foldable.set("expanded", !this.foldable.get("expanded"));
      }
    }
    const Se = { id: "folder", type: "blade", accept(e3) {
      const t3 = R, n2 = k(e3, { title: t3.required.string, view: t3.required.constant("folder"), expanded: t3.optional.boolean });
      return n2 ? { params: n2 } : null;
    }, controller(e3) {
      return new Ce(e3.document, { blade: e3.blade, expanded: e3.params.expanded, props: T.fromObject({ title: e3.params.title }), viewProps: e3.viewProps });
    }, api(e3) {
      return e3.controller instanceof Ce ? new _e(e3.controller, e3.pool) : null;
    } };
    class Me extends te {
      constructor(e3, t3) {
        const n2 = t3.valueController.viewProps;
        super(Object.assign(Object.assign({}, t3), { value: t3.valueController.value, view: new Z(e3, { props: t3.props, viewProps: n2 }), viewProps: n2 })), this.props = t3.props, this.valueController = t3.valueController, this.view.valueElement.appendChild(this.valueController.view.element);
      }
    }
    class Te extends t2 {
    }
    const Pe = _("spr");
    class Ie {
      constructor(e3, t3) {
        this.element = e3.createElement("div"), this.element.classList.add(Pe()), t3.viewProps.bindClassModifiers(this.element);
        const n2 = e3.createElement("hr");
        n2.classList.add(Pe("r")), this.element.appendChild(n2);
      }
    }
    class Re extends j {
      constructor(e3, t3) {
        super(Object.assign(Object.assign({}, t3), { view: new Ie(e3, { viewProps: t3.viewProps }) }));
      }
    }
    const ke = { id: "separator", type: "blade", accept(e3) {
      const t3 = k(e3, { view: R.required.constant("separator") });
      return t3 ? { params: t3 } : null;
    }, controller(e3) {
      return new Re(e3.document, { blade: e3.blade, viewProps: e3.viewProps });
    }, api(e3) {
      return e3.controller instanceof Re ? new Te(e3.controller) : null;
    } }, De = _("tbi");
    class Be {
      constructor(e3, t3) {
        this.element = e3.createElement("div"), this.element.classList.add(De()), t3.viewProps.bindClassModifiers(this.element), y(t3.props, "selected", (e4) => {
          e4 ? this.element.classList.add(De(void 0, "sel")) : this.element.classList.remove(De(void 0, "sel"));
        });
        const n2 = e3.createElement("button");
        n2.classList.add(De("b")), t3.viewProps.bindDisabled(n2), this.element.appendChild(n2), this.buttonElement = n2;
        const r2 = e3.createElement("div");
        r2.classList.add(De("t")), w(t3.props.value("title"), r2), this.buttonElement.appendChild(r2), this.titleElement = r2;
      }
    }
    class Oe {
      constructor(e3, t3) {
        this.emitter = new f(), this.onClick_ = this.onClick_.bind(this), this.props = t3.props, this.viewProps = t3.viewProps, this.view = new Be(e3, { props: t3.props, viewProps: t3.viewProps }), this.view.buttonElement.addEventListener("click", this.onClick_);
      }
      onClick_() {
        this.emitter.emit("click", { sender: this });
      }
    }
    class Le {
      constructor(e3, t3) {
        this.onItemClick_ = this.onItemClick_.bind(this), this.ic_ = new Oe(e3, { props: t3.itemProps, viewProps: U.create() }), this.ic_.emitter.on("click", this.onItemClick_), this.cc_ = new Ae(e3, { blade: ne(), viewProps: U.create() }), this.props = t3.props, y(this.props, "selected", (e4) => {
          this.itemController.props.set("selected", e4), this.contentController.viewProps.set("hidden", !e4);
        });
      }
      get itemController() {
        return this.ic_;
      }
      get contentController() {
        return this.cc_;
      }
      onItemClick_() {
        this.props.set("selected", true);
      }
    }
    class Ue {
      constructor(e3, t3) {
        this.controller_ = e3, this.rackApi_ = t3;
      }
      get title() {
        var e3;
        return null !== (e3 = this.controller_.itemController.props.get("title")) && void 0 !== e3 ? e3 : "";
      }
      set title(e3) {
        this.controller_.itemController.props.set("title", e3);
      }
      get selected() {
        return this.controller_.props.get("selected");
      }
      set selected(e3) {
        this.controller_.props.set("selected", e3);
      }
      get children() {
        return this.rackApi_.children;
      }
      addButton(e3) {
        return this.rackApi_.addButton(e3);
      }
      addFolder(e3) {
        return this.rackApi_.addFolder(e3);
      }
      addSeparator(e3) {
        return this.rackApi_.addSeparator(e3);
      }
      addTab(e3) {
        return this.rackApi_.addTab(e3);
      }
      add(e3, t3) {
        this.rackApi_.add(e3, t3);
      }
      remove(e3) {
        this.rackApi_.remove(e3);
      }
      addInput(e3, t3, n2) {
        return this.rackApi_.addInput(e3, t3, n2);
      }
      addMonitor(e3, t3, n2) {
        return this.rackApi_.addMonitor(e3, t3, n2);
      }
      addBlade(e3) {
        return this.rackApi_.addBlade(e3);
      }
    }
    class Fe extends oe {
      constructor(e3, t3) {
        super(e3, new me(e3.rackController, t3)), this.onPageAdd_ = this.onPageAdd_.bind(this), this.onPageRemove_ = this.onPageRemove_.bind(this), this.onSelect_ = this.onSelect_.bind(this), this.emitter_ = new f(), this.pageApiMap_ = /* @__PURE__ */ new Map(), this.rackApi_.on("change", (e4) => {
          this.emitter_.emit("change", { event: e4 });
        }), this.rackApi_.on("update", (e4) => {
          this.emitter_.emit("update", { event: e4 });
        }), this.controller_.tab.selectedIndex.emitter.on("change", this.onSelect_), this.controller_.pageSet.emitter.on("add", this.onPageAdd_), this.controller_.pageSet.emitter.on("remove", this.onPageRemove_), this.controller_.pageSet.items.forEach((e4) => {
          this.setUpPageApi_(e4);
        });
      }
      get pages() {
        return this.controller_.pageSet.items.map((e3) => {
          const t3 = this.pageApiMap_.get(e3);
          if (!t3)
            throw p.shouldNeverHappen();
          return t3;
        });
      }
      addPage(e3) {
        const t3 = this.controller_.view.element.ownerDocument, n2 = new Le(t3, { itemProps: T.fromObject({ selected: false, title: e3.title }), props: T.fromObject({ selected: false }) });
        this.controller_.add(n2, e3.index);
        const r2 = this.pageApiMap_.get(n2);
        if (!r2)
          throw p.shouldNeverHappen();
        return r2;
      }
      removePage(e3) {
        this.controller_.remove(e3);
      }
      on(e3, t3) {
        const n2 = t3.bind(this);
        return this.emitter_.on(e3, (e4) => {
          n2(e4.event);
        }), this;
      }
      setUpPageApi_(e3) {
        const t3 = this.rackApi_.apiSet_.find((t4) => t4.controller_ === e3.contentController);
        if (!t3)
          throw p.shouldNeverHappen();
        const n2 = new Ue(e3, t3);
        this.pageApiMap_.set(e3, n2);
      }
      onPageAdd_(e3) {
        this.setUpPageApi_(e3.item);
      }
      onPageRemove_(e3) {
        if (!this.pageApiMap_.get(e3.item))
          throw p.shouldNeverHappen();
        this.pageApiMap_.delete(e3.item);
      }
      onSelect_(e3) {
        this.emitter_.emit("select", { event: new o(this, e3.rawValue) });
      }
    }
    class Ne {
      constructor() {
        this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this), this.empty = M(true), this.selectedIndex = M(-1), this.items_ = [];
      }
      add(e3, t3) {
        const n2 = null != t3 ? t3 : this.items_.length;
        this.items_.splice(n2, 0, e3), e3.emitter.on("change", this.onItemSelectedChange_), this.keepSelection_();
      }
      remove(e3) {
        const t3 = this.items_.indexOf(e3);
        t3 < 0 || (this.items_.splice(t3, 1), e3.emitter.off("change", this.onItemSelectedChange_), this.keepSelection_());
      }
      keepSelection_() {
        if (0 === this.items_.length)
          return this.selectedIndex.rawValue = -1, void (this.empty.rawValue = true);
        const e3 = this.items_.findIndex((e4) => e4.rawValue);
        e3 < 0 ? (this.items_.forEach((e4, t3) => {
          e4.rawValue = 0 === t3;
        }), this.selectedIndex.rawValue = 0) : (this.items_.forEach((t3, n2) => {
          t3.rawValue = n2 === e3;
        }), this.selectedIndex.rawValue = e3), this.empty.rawValue = false;
      }
      onItemSelectedChange_(e3) {
        if (e3.rawValue) {
          const t3 = this.items_.findIndex((t4) => t4 === e3.sender);
          this.items_.forEach((e4, n2) => {
            e4.rawValue = n2 === t3;
          }), this.selectedIndex.rawValue = t3;
        } else
          this.keepSelection_();
      }
    }
    const je = _("tab");
    class ze {
      constructor(e3, t3) {
        this.element = e3.createElement("div"), this.element.classList.add(je(), xe()), t3.viewProps.bindClassModifiers(this.element), v(t3.empty, b(this.element, je(void 0, "nop")));
        const n2 = e3.createElement("div");
        n2.classList.add(je("t")), this.element.appendChild(n2), this.itemsElement = n2;
        const r2 = e3.createElement("div");
        r2.classList.add(je("i")), this.element.appendChild(r2);
        const i2 = t3.contentsElement;
        i2.classList.add(je("c")), this.element.appendChild(i2), this.contentsElement = i2;
      }
    }
    class Ge extends ge {
      constructor(e3, t3) {
        const n2 = new Ae(e3, { blade: t3.blade, viewProps: t3.viewProps }), r2 = new Ne();
        super({ blade: t3.blade, rackController: n2, view: new ze(e3, { contentsElement: n2.view.element, empty: r2.empty, viewProps: t3.viewProps }) }), this.onPageAdd_ = this.onPageAdd_.bind(this), this.onPageRemove_ = this.onPageRemove_.bind(this), this.pageSet_ = new ae(() => null), this.pageSet_.emitter.on("add", this.onPageAdd_), this.pageSet_.emitter.on("remove", this.onPageRemove_), this.tab = r2;
      }
      get pageSet() {
        return this.pageSet_;
      }
      add(e3, t3) {
        this.pageSet_.add(e3, t3);
      }
      remove(e3) {
        this.pageSet_.remove(this.pageSet_.items[e3]);
      }
      onPageAdd_(e3) {
        const t3 = e3.item;
        q(this.view.itemsElement, t3.itemController.view.element, e3.index), t3.itemController.viewProps.set("parent", this.viewProps), this.rackController.rack.add(t3.contentController, e3.index), this.tab.add(t3.props.value("selected"));
      }
      onPageRemove_(e3) {
        const t3 = e3.item;
        X(t3.itemController.view.element), t3.itemController.viewProps.set("parent", null), this.rackController.rack.remove(t3.contentController), this.tab.remove(t3.props.value("selected"));
      }
    }
    const Ve = { id: "tab", type: "blade", accept(e3) {
      const t3 = R, n2 = k(e3, { pages: t3.required.array(t3.required.object({ title: t3.required.string })), view: t3.required.constant("tab") });
      return n2 && 0 !== n2.pages.length ? { params: n2 } : null;
    }, controller(e3) {
      const t3 = new Ge(e3.document, { blade: e3.blade, viewProps: e3.viewProps });
      return e3.params.pages.forEach((n2) => {
        const r2 = new Le(e3.document, { itemProps: T.fromObject({ selected: false, title: n2.title }), props: T.fromObject({ selected: false }) });
        t3.add(r2);
      }), t3;
    }, api(e3) {
      return e3.controller instanceof Ge ? new Fe(e3.controller, e3.pool) : null;
    } };
    class He {
      constructor() {
        this.disabled = false, this.emitter = new f();
      }
      dispose() {
      }
      tick() {
        this.disabled || this.emitter.emit("tick", { sender: this });
      }
    }
    class Qe {
      constructor(e3, t3) {
        this.disabled_ = false, this.timerId_ = null, this.onTick_ = this.onTick_.bind(this), this.doc_ = e3, this.emitter = new f(), this.interval_ = t3, this.setTimer_();
      }
      get disabled() {
        return this.disabled_;
      }
      set disabled(e3) {
        this.disabled_ = e3, this.disabled_ ? this.clearTimer_() : this.setTimer_();
      }
      dispose() {
        this.clearTimer_();
      }
      clearTimer_() {
        if (null === this.timerId_)
          return;
        const e3 = this.doc_.defaultView;
        e3 && e3.clearInterval(this.timerId_), this.timerId_ = null;
      }
      setTimer_() {
        if (this.clearTimer_(), this.interval_ <= 0)
          return;
        const e3 = this.doc_.defaultView;
        e3 && (this.timerId_ = e3.setInterval(this.onTick_, this.interval_));
      }
      onTick_() {
        this.disabled_ || this.emitter.emit("tick", { sender: this });
      }
    }
    class We {
      constructor(e3) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.reader = e3.reader, this.writer = e3.writer, this.emitter = new f(), this.value = e3.value, this.value.emitter.on("change", this.onValueChange_), this.target = e3.target, this.read();
      }
      read() {
        const e3 = this.target.read();
        void 0 !== e3 && (this.value.rawValue = this.reader(e3));
      }
      write_(e3) {
        this.writer(this.target, e3);
      }
      onValueChange_(e3) {
        this.write_(e3.rawValue), this.emitter.emit("change", { options: e3.options, rawValue: e3.rawValue, sender: this });
      }
    }
    function qe(e3, t3) {
      for (; e3.length < t3; )
        e3.push(void 0);
    }
    function Xe(e3) {
      const t3 = [];
      return qe(t3, e3), M(t3);
    }
    function Ye(e3) {
      const t3 = e3.indexOf(void 0);
      return t3 < 0 ? e3 : e3.slice(0, t3);
    }
    class Ke {
      constructor(e3) {
        this.onTick_ = this.onTick_.bind(this), this.reader_ = e3.reader, this.target = e3.target, this.emitter = new f(), this.value = e3.value, this.ticker = e3.ticker, this.ticker.emitter.on("tick", this.onTick_), this.read();
      }
      dispose() {
        this.ticker.dispose();
      }
      read() {
        const e3 = this.target.read();
        if (void 0 === e3)
          return;
        const t3 = this.value.rawValue, n2 = this.reader_(e3);
        this.value.rawValue = function(e4, t4) {
          const n3 = [...Ye(e4), t4];
          return n3.length > e4.length ? n3.splice(0, n3.length - e4.length) : qe(n3, e4.length), n3;
        }(t3, n2), this.emitter.emit("update", { rawValue: n2, sender: this });
      }
      onTick_(e3) {
        this.read();
      }
    }
    class Je {
      constructor(e3) {
        this.constraints = e3;
      }
      constrain(e3) {
        return this.constraints.reduce((e4, t3) => t3.constrain(e4), e3);
      }
    }
    function Ze(e3, t3) {
      if (e3 instanceof t3)
        return e3;
      if (e3 instanceof Je) {
        const n2 = e3.constraints.reduce((e4, n3) => e4 || (n3 instanceof t3 ? n3 : null), null);
        if (n2)
          return n2;
      }
      return null;
    }
    class $e {
      constructor(e3) {
        this.values = T.fromObject({ max: e3.max, min: e3.min });
      }
      constrain(e3) {
        const t3 = this.values.get("max"), n2 = this.values.get("min");
        return Math.min(Math.max(e3, n2), t3);
      }
    }
    class et {
      constructor(e3) {
        this.values = T.fromObject({ options: e3 });
      }
      get options() {
        return this.values.get("options");
      }
      constrain(e3) {
        const t3 = this.values.get("options");
        return 0 === t3.length || t3.filter((t4) => t4.value === e3).length > 0 ? e3 : t3[0].value;
      }
    }
    class tt {
      constructor(e3) {
        this.values = T.fromObject({ max: e3.max, min: e3.min });
      }
      get maxValue() {
        return this.values.get("max");
      }
      get minValue() {
        return this.values.get("min");
      }
      constrain(e3) {
        const t3 = this.values.get("max"), n2 = this.values.get("min");
        let r2 = e3;
        return a(n2) || (r2 = Math.max(r2, n2)), a(t3) || (r2 = Math.min(r2, t3)), r2;
      }
    }
    class nt {
      constructor(e3, t3 = 0) {
        this.step = e3, this.origin = t3;
      }
      constrain(e3) {
        const t3 = this.origin % this.step;
        return t3 + Math.round((e3 - t3) / this.step) * this.step;
      }
    }
    const rt = _("lst");
    class it {
      constructor(e3, t3) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.props_ = t3.props, this.element = e3.createElement("div"), this.element.classList.add(rt()), t3.viewProps.bindClassModifiers(this.element);
        const n2 = e3.createElement("select");
        n2.classList.add(rt("s")), y(this.props_, "options", (t4) => {
          Y(n2), t4.forEach((t5, r3) => {
            const i2 = e3.createElement("option");
            i2.dataset.index = String(r3), i2.textContent = t5.text, i2.value = String(t5.value), n2.appendChild(i2);
          });
        }), t3.viewProps.bindDisabled(n2), this.element.appendChild(n2), this.selectElement = n2;
        const r2 = e3.createElement("div");
        r2.classList.add(rt("m")), r2.appendChild(W(e3, "dropdown")), this.element.appendChild(r2), t3.value.emitter.on("change", this.onValueChange_), this.value_ = t3.value, this.update_();
      }
      update_() {
        this.selectElement.value = String(this.value_.rawValue);
      }
      onValueChange_() {
        this.update_();
      }
    }
    class st {
      constructor(e3, t3) {
        this.onSelectChange_ = this.onSelectChange_.bind(this), this.props = t3.props, this.value = t3.value, this.viewProps = t3.viewProps, this.view = new it(e3, { props: this.props, value: this.value, viewProps: this.viewProps }), this.view.selectElement.addEventListener("change", this.onSelectChange_);
      }
      onSelectChange_(e3) {
        const t3 = e3.currentTarget.selectedOptions.item(0);
        if (!t3)
          return;
        const n2 = Number(t3.dataset.index);
        this.value.rawValue = this.props.get("options")[n2].value;
      }
    }
    const ot = _("pop");
    class at {
      constructor(e3, t3) {
        this.element = e3.createElement("div"), this.element.classList.add(ot()), t3.viewProps.bindClassModifiers(this.element), v(t3.shows, b(this.element, ot(void 0, "v")));
      }
    }
    class lt {
      constructor(e3, t3) {
        this.shows = M(false), this.viewProps = t3.viewProps, this.view = new at(e3, { shows: this.shows, viewProps: this.viewProps });
      }
    }
    const ct = _("txt");
    class ut {
      constructor(e3, t3) {
        this.onChange_ = this.onChange_.bind(this), this.element = e3.createElement("div"), this.element.classList.add(ct()), t3.viewProps.bindClassModifiers(this.element), this.props_ = t3.props, this.props_.emitter.on("change", this.onChange_);
        const n2 = e3.createElement("input");
        n2.classList.add(ct("i")), n2.type = "text", t3.viewProps.bindDisabled(n2), this.element.appendChild(n2), this.inputElement = n2, t3.value.emitter.on("change", this.onChange_), this.value_ = t3.value, this.refresh();
      }
      refresh() {
        const e3 = this.props_.get("formatter");
        this.inputElement.value = e3(this.value_.rawValue);
      }
      onChange_() {
        this.refresh();
      }
    }
    class pt {
      constructor(e3, t3) {
        this.onInputChange_ = this.onInputChange_.bind(this), this.parser_ = t3.parser, this.props = t3.props, this.value = t3.value, this.viewProps = t3.viewProps, this.view = new ut(e3, { props: t3.props, value: this.value, viewProps: this.viewProps }), this.view.inputElement.addEventListener("change", this.onInputChange_);
      }
      onInputChange_(e3) {
        const t3 = e3.currentTarget.value, n2 = this.parser_(t3);
        a(n2) || (this.value.rawValue = n2), this.view.refresh();
      }
    }
    function dt(e3) {
      return "false" !== e3 && !!e3;
    }
    function ht(e3) {
      return function(e4) {
        return String(e4);
      }(e3);
    }
    class ft {
      constructor(e3) {
        this.text = e3;
      }
      evaluate() {
        return Number(this.text);
      }
      toString() {
        return this.text;
      }
    }
    const mt = { "**": (e3, t3) => Math.pow(e3, t3), "*": (e3, t3) => e3 * t3, "/": (e3, t3) => e3 / t3, "%": (e3, t3) => e3 % t3, "+": (e3, t3) => e3 + t3, "-": (e3, t3) => e3 - t3, "<<": (e3, t3) => e3 << t3, ">>": (e3, t3) => e3 >> t3, ">>>": (e3, t3) => e3 >>> t3, "&": (e3, t3) => e3 & t3, "^": (e3, t3) => e3 ^ t3, "|": (e3, t3) => e3 | t3 };
    class _t {
      constructor(e3, t3, n2) {
        this.left = t3, this.operator = e3, this.right = n2;
      }
      evaluate() {
        const e3 = mt[this.operator];
        if (!e3)
          throw new Error(`unexpected binary operator: '${this.operator}`);
        return e3(this.left.evaluate(), this.right.evaluate());
      }
      toString() {
        return ["b(", this.left.toString(), this.operator, this.right.toString(), ")"].join(" ");
      }
    }
    const gt = { "+": (e3) => e3, "-": (e3) => -e3, "~": (e3) => ~e3 };
    class vt {
      constructor(e3, t3) {
        this.operator = e3, this.expression = t3;
      }
      evaluate() {
        const e3 = gt[this.operator];
        if (!e3)
          throw new Error(`unexpected unary operator: '${this.operator}`);
        return e3(this.expression.evaluate());
      }
      toString() {
        return ["u(", this.operator, this.expression.toString(), ")"].join(" ");
      }
    }
    function yt(e3) {
      return (t3, n2) => {
        for (let r2 = 0; r2 < e3.length; r2++) {
          const i2 = e3[r2](t3, n2);
          if ("" !== i2)
            return i2;
        }
        return "";
      };
    }
    function bt(e3, t3) {
      var n2;
      const r2 = e3.substr(t3).match(/^\s+/);
      return null !== (n2 = r2 && r2[0]) && void 0 !== n2 ? n2 : "";
    }
    function wt(e3, t3) {
      var n2;
      const r2 = e3.substr(t3).match(/^[0-9]+/);
      return null !== (n2 = r2 && r2[0]) && void 0 !== n2 ? n2 : "";
    }
    function At(e3, t3) {
      const n2 = e3.substr(t3, 1);
      if (t3 += 1, "e" !== n2.toLowerCase())
        return "";
      const r2 = function(e4, t4) {
        const n3 = wt(e4, t4);
        if ("" !== n3)
          return n3;
        const r3 = e4.substr(t4, 1);
        if ("-" !== r3 && "+" !== r3)
          return "";
        const i2 = wt(e4, t4 += 1);
        return "" === i2 ? "" : r3 + i2;
      }(e3, t3);
      return "" === r2 ? "" : n2 + r2;
    }
    function xt(e3, t3) {
      const n2 = e3.substr(t3, 1);
      if ("0" === n2)
        return n2;
      const r2 = function(e4, t4) {
        const n3 = e4.substr(t4, 1);
        return n3.match(/^[1-9]$/) ? n3 : "";
      }(e3, t3);
      return t3 += r2.length, "" === r2 ? "" : r2 + wt(e3, t3);
    }
    const Et = yt([function(e3, t3) {
      const n2 = xt(e3, t3);
      if (t3 += n2.length, "" === n2)
        return "";
      const r2 = e3.substr(t3, 1);
      if (t3 += r2.length, "." !== r2)
        return "";
      const i2 = wt(e3, t3);
      return n2 + r2 + i2 + At(e3, t3 += i2.length);
    }, function(e3, t3) {
      const n2 = e3.substr(t3, 1);
      if (t3 += n2.length, "." !== n2)
        return "";
      const r2 = wt(e3, t3);
      return t3 += r2.length, "" === r2 ? "" : n2 + r2 + At(e3, t3);
    }, function(e3, t3) {
      const n2 = xt(e3, t3);
      return t3 += n2.length, "" === n2 ? "" : n2 + At(e3, t3);
    }]);
    const Ct = yt([function(e3, t3) {
      const n2 = e3.substr(t3, 2);
      if (t3 += n2.length, "0b" !== n2.toLowerCase())
        return "";
      const r2 = function(e4, t4) {
        var n3;
        const r3 = e4.substr(t4).match(/^[01]+/);
        return null !== (n3 = r3 && r3[0]) && void 0 !== n3 ? n3 : "";
      }(e3, t3);
      return "" === r2 ? "" : n2 + r2;
    }, function(e3, t3) {
      const n2 = e3.substr(t3, 2);
      if (t3 += n2.length, "0o" !== n2.toLowerCase())
        return "";
      const r2 = function(e4, t4) {
        var n3;
        const r3 = e4.substr(t4).match(/^[0-7]+/);
        return null !== (n3 = r3 && r3[0]) && void 0 !== n3 ? n3 : "";
      }(e3, t3);
      return "" === r2 ? "" : n2 + r2;
    }, function(e3, t3) {
      const n2 = e3.substr(t3, 2);
      if (t3 += n2.length, "0x" !== n2.toLowerCase())
        return "";
      const r2 = function(e4, t4) {
        var n3;
        const r3 = e4.substr(t4).match(/^[0-9a-f]+/i);
        return null !== (n3 = r3 && r3[0]) && void 0 !== n3 ? n3 : "";
      }(e3, t3);
      return "" === r2 ? "" : n2 + r2;
    }]), St = yt([Ct, Et]);
    function Mt(e3, t3) {
      var n2;
      return null !== (n2 = function(e4, t4) {
        const n3 = St(e4, t4);
        return t4 += n3.length, "" === n3 ? null : { evaluable: new ft(n3), cursor: t4 };
      }(e3, t3)) && void 0 !== n2 ? n2 : function(e4, t4) {
        const n3 = e4.substr(t4, 1);
        if (t4 += n3.length, "(" !== n3)
          return null;
        const r2 = It(e4, t4);
        if (!r2)
          return null;
        t4 = r2.cursor, t4 += bt(e4, t4).length;
        const i2 = e4.substr(t4, 1);
        return t4 += i2.length, ")" !== i2 ? null : { evaluable: r2.evaluable, cursor: t4 };
      }(e3, t3);
    }
    function Tt(e3, t3, n2) {
      n2 += bt(t3, n2).length;
      const r2 = e3.filter((e4) => t3.startsWith(e4, n2))[0];
      return r2 ? (n2 += r2.length, { cursor: n2 += bt(t3, n2).length, operator: r2 }) : null;
    }
    const Pt = [["**"], ["*", "/", "%"], ["+", "-"], ["<<", ">>>", ">>"], ["&"], ["^"], ["|"]].reduce((e3, t3) => function(e4, t4) {
      return (n2, r2) => {
        const i2 = e4(n2, r2);
        if (!i2)
          return null;
        r2 = i2.cursor;
        let s2 = i2.evaluable;
        for (; ; ) {
          const i3 = Tt(t4, n2, r2);
          if (!i3)
            break;
          r2 = i3.cursor;
          const o2 = e4(n2, r2);
          if (!o2)
            return null;
          r2 = o2.cursor, s2 = new _t(i3.operator, s2, o2.evaluable);
        }
        return s2 ? { cursor: r2, evaluable: s2 } : null;
      };
    }(e3, t3), function e3(t3, n2) {
      const r2 = Mt(t3, n2);
      if (r2)
        return r2;
      const i2 = t3.substr(n2, 1);
      if (n2 += i2.length, "+" !== i2 && "-" !== i2 && "~" !== i2)
        return null;
      const s2 = e3(t3, n2);
      return s2 ? { cursor: n2 = s2.cursor, evaluable: new vt(i2, s2.evaluable) } : null;
    });
    function It(e3, t3) {
      return t3 += bt(e3, t3).length, Pt(e3, t3);
    }
    function Rt(e3) {
      var t3;
      const n2 = function(e4) {
        const t4 = It(e4, 0);
        return t4 ? t4.cursor + bt(e4, t4.cursor).length !== e4.length ? null : t4.evaluable : null;
      }(e3);
      return null !== (t3 = null == n2 ? void 0 : n2.evaluate()) && void 0 !== t3 ? t3 : null;
    }
    function kt(e3) {
      if ("number" == typeof e3)
        return e3;
      if ("string" == typeof e3) {
        const t3 = Rt(e3);
        if (!a(t3))
          return t3;
      }
      return 0;
    }
    function Dt(e3) {
      return String(e3);
    }
    function Bt(e3) {
      return (t3) => t3.toFixed(Math.max(Math.min(e3, 20), 0));
    }
    const Ot = Bt(0);
    function Lt(e3) {
      return Ot(e3) + "%";
    }
    function Ut(e3) {
      return String(e3);
    }
    function Ft(e3) {
      return e3;
    }
    function Nt({ primary: e3, secondary: t3, forward: n2, backward: r2 }) {
      let i2 = false;
      function s2(e4) {
        i2 || (i2 = true, e4(), i2 = false);
      }
      e3.emitter.on("change", (r3) => {
        s2(() => {
          t3.setRawValue(n2(e3, t3), r3.options);
        });
      }), t3.emitter.on("change", (i3) => {
        s2(() => {
          e3.setRawValue(r2(e3, t3), i3.options);
        }), s2(() => {
          t3.setRawValue(n2(e3, t3), i3.options);
        });
      }), s2(() => {
        t3.setRawValue(n2(e3, t3), { forceEmit: false, last: true });
      });
    }
    function jt(e3, t3) {
      const n2 = e3 * (t3.altKey ? 0.1 : 1) * (t3.shiftKey ? 10 : 1);
      return t3.upKey ? +n2 : t3.downKey ? -n2 : 0;
    }
    function zt(e3) {
      return { altKey: e3.altKey, downKey: "ArrowDown" === e3.key, shiftKey: e3.shiftKey, upKey: "ArrowUp" === e3.key };
    }
    function Gt(e3) {
      return { altKey: e3.altKey, downKey: "ArrowLeft" === e3.key, shiftKey: e3.shiftKey, upKey: "ArrowRight" === e3.key };
    }
    function Vt(e3) {
      return function(e4) {
        return "ArrowUp" === e4 || "ArrowDown" === e4;
      }(e3) || "ArrowLeft" === e3 || "ArrowRight" === e3;
    }
    function Ht(e3, t3) {
      var n2, r2;
      const i2 = t3.ownerDocument.defaultView, s2 = t3.getBoundingClientRect();
      return { x: e3.pageX - ((null !== (n2 = i2 && i2.scrollX) && void 0 !== n2 ? n2 : 0) + s2.left), y: e3.pageY - ((null !== (r2 = i2 && i2.scrollY) && void 0 !== r2 ? r2 : 0) + s2.top) };
    }
    class Qt {
      constructor(e3) {
        this.lastTouch_ = null, this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this), this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this), this.onMouseDown_ = this.onMouseDown_.bind(this), this.onTouchEnd_ = this.onTouchEnd_.bind(this), this.onTouchMove_ = this.onTouchMove_.bind(this), this.onTouchStart_ = this.onTouchStart_.bind(this), this.elem_ = e3, this.emitter = new f(), e3.addEventListener("touchstart", this.onTouchStart_, { passive: false }), e3.addEventListener("touchmove", this.onTouchMove_, { passive: true }), e3.addEventListener("touchend", this.onTouchEnd_), e3.addEventListener("mousedown", this.onMouseDown_);
      }
      computePosition_(e3) {
        const t3 = this.elem_.getBoundingClientRect();
        return { bounds: { width: t3.width, height: t3.height }, point: e3 ? { x: e3.x, y: e3.y } : null };
      }
      onMouseDown_(e3) {
        var t3;
        e3.preventDefault(), null === (t3 = e3.currentTarget) || void 0 === t3 || t3.focus();
        const n2 = this.elem_.ownerDocument;
        n2.addEventListener("mousemove", this.onDocumentMouseMove_), n2.addEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("down", { altKey: e3.altKey, data: this.computePosition_(Ht(e3, this.elem_)), sender: this, shiftKey: e3.shiftKey });
      }
      onDocumentMouseMove_(e3) {
        this.emitter.emit("move", { altKey: e3.altKey, data: this.computePosition_(Ht(e3, this.elem_)), sender: this, shiftKey: e3.shiftKey });
      }
      onDocumentMouseUp_(e3) {
        const t3 = this.elem_.ownerDocument;
        t3.removeEventListener("mousemove", this.onDocumentMouseMove_), t3.removeEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("up", { altKey: e3.altKey, data: this.computePosition_(Ht(e3, this.elem_)), sender: this, shiftKey: e3.shiftKey });
      }
      onTouchStart_(e3) {
        e3.preventDefault();
        const t3 = e3.targetTouches.item(0), n2 = this.elem_.getBoundingClientRect();
        this.emitter.emit("down", { altKey: e3.altKey, data: this.computePosition_(t3 ? { x: t3.clientX - n2.left, y: t3.clientY - n2.top } : void 0), sender: this, shiftKey: e3.shiftKey }), this.lastTouch_ = t3;
      }
      onTouchMove_(e3) {
        const t3 = e3.targetTouches.item(0), n2 = this.elem_.getBoundingClientRect();
        this.emitter.emit("move", { altKey: e3.altKey, data: this.computePosition_(t3 ? { x: t3.clientX - n2.left, y: t3.clientY - n2.top } : void 0), sender: this, shiftKey: e3.shiftKey }), this.lastTouch_ = t3;
      }
      onTouchEnd_(e3) {
        var t3;
        const n2 = null !== (t3 = e3.targetTouches.item(0)) && void 0 !== t3 ? t3 : this.lastTouch_, r2 = this.elem_.getBoundingClientRect();
        this.emitter.emit("up", { altKey: e3.altKey, data: this.computePosition_(n2 ? { x: n2.clientX - r2.left, y: n2.clientY - r2.top } : void 0), sender: this, shiftKey: e3.shiftKey });
      }
    }
    function Wt(e3, t3, n2, r2, i2) {
      return r2 + (e3 - t3) / (n2 - t3) * (i2 - r2);
    }
    function qt(e3) {
      return String(e3.toFixed(10)).split(".")[1].replace(/0+$/, "").length;
    }
    function Xt(e3, t3, n2) {
      return Math.min(Math.max(e3, t3), n2);
    }
    function Yt(e3, t3) {
      return (e3 % t3 + t3) % t3;
    }
    const Kt = _("txt");
    class Jt {
      constructor(e3, t3) {
        this.onChange_ = this.onChange_.bind(this), this.props_ = t3.props, this.props_.emitter.on("change", this.onChange_), this.element = e3.createElement("div"), this.element.classList.add(Kt(), Kt(void 0, "num")), t3.arrayPosition && this.element.classList.add(Kt(void 0, t3.arrayPosition)), t3.viewProps.bindClassModifiers(this.element);
        const n2 = e3.createElement("input");
        n2.classList.add(Kt("i")), n2.type = "text", t3.viewProps.bindDisabled(n2), this.element.appendChild(n2), this.inputElement = n2, this.onDraggingChange_ = this.onDraggingChange_.bind(this), this.dragging_ = t3.dragging, this.dragging_.emitter.on("change", this.onDraggingChange_), this.element.classList.add(Kt()), this.inputElement.classList.add(Kt("i"));
        const r2 = e3.createElement("div");
        r2.classList.add(Kt("k")), this.element.appendChild(r2), this.knobElement = r2;
        const i2 = e3.createElementNS(z, "svg");
        i2.classList.add(Kt("g")), this.knobElement.appendChild(i2);
        const s2 = e3.createElementNS(z, "path");
        s2.classList.add(Kt("gb")), i2.appendChild(s2), this.guideBodyElem_ = s2;
        const o2 = e3.createElementNS(z, "path");
        o2.classList.add(Kt("gh")), i2.appendChild(o2), this.guideHeadElem_ = o2;
        const a2 = e3.createElement("div");
        a2.classList.add(_("tt")()), this.knobElement.appendChild(a2), this.tooltipElem_ = a2, t3.value.emitter.on("change", this.onChange_), this.value = t3.value, this.refresh();
      }
      onDraggingChange_(e3) {
        if (null === e3.rawValue)
          return void this.element.classList.remove(Kt(void 0, "drg"));
        this.element.classList.add(Kt(void 0, "drg"));
        const t3 = e3.rawValue / this.props_.get("draggingScale"), n2 = t3 + (t3 > 0 ? -1 : t3 < 0 ? 1 : 0), r2 = Xt(-n2, -4, 4);
        this.guideHeadElem_.setAttributeNS(null, "d", [`M ${n2 + r2},0 L${n2},4 L${n2 + r2},8`, `M ${t3},-1 L${t3},9`].join(" ")), this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${t3},4`);
        const i2 = this.props_.get("formatter");
        this.tooltipElem_.textContent = i2(this.value.rawValue), this.tooltipElem_.style.left = `${t3}px`;
      }
      refresh() {
        const e3 = this.props_.get("formatter");
        this.inputElement.value = e3(this.value.rawValue);
      }
      onChange_() {
        this.refresh();
      }
    }
    class Zt {
      constructor(e3, t3) {
        var n2;
        this.originRawValue_ = 0, this.onInputChange_ = this.onInputChange_.bind(this), this.onInputKeyDown_ = this.onInputKeyDown_.bind(this), this.onInputKeyUp_ = this.onInputKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = t3.baseStep, this.parser_ = t3.parser, this.props = t3.props, this.sliderProps_ = null !== (n2 = t3.sliderProps) && void 0 !== n2 ? n2 : null, this.value = t3.value, this.viewProps = t3.viewProps, this.dragging_ = M(null), this.view = new Jt(e3, { arrayPosition: t3.arrayPosition, dragging: this.dragging_, props: this.props, value: this.value, viewProps: this.viewProps }), this.view.inputElement.addEventListener("change", this.onInputChange_), this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_), this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
        const r2 = new Qt(this.view.knobElement);
        r2.emitter.on("down", this.onPointerDown_), r2.emitter.on("move", this.onPointerMove_), r2.emitter.on("up", this.onPointerUp_);
      }
      constrainValue_(e3) {
        var t3, n2;
        const r2 = null === (t3 = this.sliderProps_) || void 0 === t3 ? void 0 : t3.get("minValue"), i2 = null === (n2 = this.sliderProps_) || void 0 === n2 ? void 0 : n2.get("maxValue");
        let s2 = e3;
        return void 0 !== r2 && (s2 = Math.max(s2, r2)), void 0 !== i2 && (s2 = Math.min(s2, i2)), s2;
      }
      onInputChange_(e3) {
        const t3 = e3.currentTarget.value, n2 = this.parser_(t3);
        a(n2) || (this.value.rawValue = this.constrainValue_(n2)), this.view.refresh();
      }
      onInputKeyDown_(e3) {
        const t3 = jt(this.baseStep_, zt(e3));
        0 !== t3 && this.value.setRawValue(this.constrainValue_(this.value.rawValue + t3), { forceEmit: false, last: false });
      }
      onInputKeyUp_(e3) {
        0 !== jt(this.baseStep_, zt(e3)) && this.value.setRawValue(this.value.rawValue, { forceEmit: true, last: true });
      }
      onPointerDown_() {
        this.originRawValue_ = this.value.rawValue, this.dragging_.rawValue = 0;
      }
      computeDraggingValue_(e3) {
        if (!e3.point)
          return null;
        const t3 = e3.point.x - e3.bounds.width / 2;
        return this.constrainValue_(this.originRawValue_ + t3 * this.props.get("draggingScale"));
      }
      onPointerMove_(e3) {
        const t3 = this.computeDraggingValue_(e3.data);
        null !== t3 && (this.value.setRawValue(t3, { forceEmit: false, last: false }), this.dragging_.rawValue = this.value.rawValue - this.originRawValue_);
      }
      onPointerUp_(e3) {
        const t3 = this.computeDraggingValue_(e3.data);
        null !== t3 && (this.value.setRawValue(t3, { forceEmit: true, last: true }), this.dragging_.rawValue = null);
      }
    }
    const $t = _("sld");
    class en {
      constructor(e3, t3) {
        this.onChange_ = this.onChange_.bind(this), this.props_ = t3.props, this.props_.emitter.on("change", this.onChange_), this.element = e3.createElement("div"), this.element.classList.add($t()), t3.viewProps.bindClassModifiers(this.element);
        const n2 = e3.createElement("div");
        n2.classList.add($t("t")), t3.viewProps.bindTabIndex(n2), this.element.appendChild(n2), this.trackElement = n2;
        const r2 = e3.createElement("div");
        r2.classList.add($t("k")), this.trackElement.appendChild(r2), this.knobElement = r2, t3.value.emitter.on("change", this.onChange_), this.value = t3.value, this.update_();
      }
      update_() {
        const e3 = Xt(Wt(this.value.rawValue, this.props_.get("minValue"), this.props_.get("maxValue"), 0, 100), 0, 100);
        this.knobElement.style.width = `${e3}%`;
      }
      onChange_() {
        this.update_();
      }
    }
    class tn {
      constructor(e3, t3) {
        this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = t3.baseStep, this.value = t3.value, this.viewProps = t3.viewProps, this.props = t3.props, this.view = new en(e3, { props: this.props, value: this.value, viewProps: this.viewProps }), this.ptHandler_ = new Qt(this.view.trackElement), this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.trackElement.addEventListener("keydown", this.onKeyDown_), this.view.trackElement.addEventListener("keyup", this.onKeyUp_);
      }
      handlePointerEvent_(e3, t3) {
        e3.point && this.value.setRawValue(Wt(Xt(e3.point.x, 0, e3.bounds.width), 0, e3.bounds.width, this.props.get("minValue"), this.props.get("maxValue")), t3);
      }
      onPointerDownOrMove_(e3) {
        this.handlePointerEvent_(e3.data, { forceEmit: false, last: false });
      }
      onPointerUp_(e3) {
        this.handlePointerEvent_(e3.data, { forceEmit: true, last: true });
      }
      onKeyDown_(e3) {
        const t3 = jt(this.baseStep_, Gt(e3));
        0 !== t3 && this.value.setRawValue(this.value.rawValue + t3, { forceEmit: false, last: false });
      }
      onKeyUp_(e3) {
        0 !== jt(this.baseStep_, Gt(e3)) && this.value.setRawValue(this.value.rawValue, { forceEmit: true, last: true });
      }
    }
    const nn = _("sldtxt");
    class rn {
      constructor(e3, t3) {
        this.element = e3.createElement("div"), this.element.classList.add(nn());
        const n2 = e3.createElement("div");
        n2.classList.add(nn("s")), this.sliderView_ = t3.sliderView, n2.appendChild(this.sliderView_.element), this.element.appendChild(n2);
        const r2 = e3.createElement("div");
        r2.classList.add(nn("t")), this.textView_ = t3.textView, r2.appendChild(this.textView_.element), this.element.appendChild(r2);
      }
    }
    class sn {
      constructor(e3, t3) {
        this.value = t3.value, this.viewProps = t3.viewProps, this.sliderC_ = new tn(e3, { baseStep: t3.baseStep, props: t3.sliderProps, value: t3.value, viewProps: this.viewProps }), this.textC_ = new Zt(e3, { baseStep: t3.baseStep, parser: t3.parser, props: t3.textProps, sliderProps: t3.sliderProps, value: t3.value, viewProps: t3.viewProps }), this.view = new rn(e3, { sliderView: this.sliderC_.view, textView: this.textC_.view });
      }
      get sliderController() {
        return this.sliderC_;
      }
      get textController() {
        return this.textC_;
      }
    }
    function on(e3, t3) {
      e3.write(t3);
    }
    function an(e3) {
      const t3 = R;
      return Array.isArray(e3) ? t3.required.array(t3.required.object({ text: t3.required.string, value: t3.required.raw }))(e3).value : "object" == typeof e3 ? t3.required.raw(e3).value : void 0;
    }
    function ln(e3) {
      if ("inline" === e3 || "popup" === e3)
        return e3;
    }
    function cn(e3) {
      const t3 = R;
      return t3.required.object({ max: t3.optional.number, min: t3.optional.number, step: t3.optional.number })(e3).value;
    }
    function un(e3) {
      if (Array.isArray(e3))
        return e3;
      const t3 = [];
      return Object.keys(e3).forEach((n2) => {
        t3.push({ text: n2, value: e3[n2] });
      }), t3;
    }
    function pn(e3) {
      return a(e3) ? null : new et(un(e3));
    }
    function dn(e3, t3) {
      const n2 = e3 && Ze(e3, nt);
      return n2 ? qt(n2.step) : Math.max(qt(t3), 2);
    }
    function hn(e3) {
      const t3 = function(e4) {
        const t4 = e4 ? Ze(e4, nt) : null;
        return t4 ? t4.step : null;
      }(e3);
      return null != t3 ? t3 : 1;
    }
    function fn(e3, t3) {
      var n2;
      const r2 = e3 && Ze(e3, nt), i2 = Math.abs(null !== (n2 = null == r2 ? void 0 : r2.step) && void 0 !== n2 ? n2 : t3);
      return 0 === i2 ? 0.1 : Math.pow(10, Math.floor(Math.log10(i2)) - 1);
    }
    const mn = _("ckb");
    class _n {
      constructor(e3, t3) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.element = e3.createElement("div"), this.element.classList.add(mn()), t3.viewProps.bindClassModifiers(this.element);
        const n2 = e3.createElement("label");
        n2.classList.add(mn("l")), this.element.appendChild(n2);
        const r2 = e3.createElement("input");
        r2.classList.add(mn("i")), r2.type = "checkbox", n2.appendChild(r2), this.inputElement = r2, t3.viewProps.bindDisabled(this.inputElement);
        const i2 = e3.createElement("div");
        i2.classList.add(mn("w")), n2.appendChild(i2);
        const s2 = W(e3, "check");
        i2.appendChild(s2), t3.value.emitter.on("change", this.onValueChange_), this.value = t3.value, this.update_();
      }
      update_() {
        this.inputElement.checked = this.value.rawValue;
      }
      onValueChange_() {
        this.update_();
      }
    }
    class gn {
      constructor(e3, t3) {
        this.onInputChange_ = this.onInputChange_.bind(this), this.value = t3.value, this.viewProps = t3.viewProps, this.view = new _n(e3, { value: this.value, viewProps: this.viewProps }), this.view.inputElement.addEventListener("change", this.onInputChange_);
      }
      onInputChange_(e3) {
        const t3 = e3.currentTarget;
        this.value.rawValue = t3.checked;
      }
    }
    const vn = { id: "input-bool", type: "input", accept: (e3, t3) => {
      if ("boolean" != typeof e3)
        return null;
      const n2 = k(t3, { options: R.optional.custom(an) });
      return n2 ? { initialValue: e3, params: n2 } : null;
    }, binding: { reader: (e3) => dt, constraint: (e3) => function(e4) {
      const t3 = [], n2 = pn(e4.options);
      return n2 && t3.push(n2), new Je(t3);
    }(e3.params), writer: (e3) => on }, controller: (e3) => {
      const t3 = e3.document, n2 = e3.value, r2 = e3.constraint, i2 = r2 && Ze(r2, et);
      return i2 ? new st(t3, { props: new T({ options: i2.values.value("options") }), value: n2, viewProps: e3.viewProps }) : new gn(t3, { value: n2, viewProps: e3.viewProps });
    } }, yn = _("col");
    class bn {
      constructor(e3, t3) {
        this.element = e3.createElement("div"), this.element.classList.add(yn()), t3.foldable.bindExpandedClass(this.element, yn(void 0, "expanded")), y(t3.foldable, "completed", b(this.element, yn(void 0, "cpl")));
        const n2 = e3.createElement("div");
        n2.classList.add(yn("h")), this.element.appendChild(n2);
        const r2 = e3.createElement("div");
        r2.classList.add(yn("s")), n2.appendChild(r2), this.swatchElement = r2;
        const i2 = e3.createElement("div");
        if (i2.classList.add(yn("t")), n2.appendChild(i2), this.textElement = i2, "inline" === t3.pickerLayout) {
          const t4 = e3.createElement("div");
          t4.classList.add(yn("p")), this.element.appendChild(t4), this.pickerElement = t4;
        } else
          this.pickerElement = null;
      }
    }
    function wn(e3, t3, n2) {
      const r2 = Yt(e3, 360), i2 = Xt(t3 / 100, 0, 1), s2 = Xt(n2 / 100, 0, 1), o2 = s2 * i2, a2 = o2 * (1 - Math.abs(r2 / 60 % 2 - 1)), l2 = s2 - o2;
      let c2, u2, p2;
      return [c2, u2, p2] = r2 >= 0 && r2 < 60 ? [o2, a2, 0] : r2 >= 60 && r2 < 120 ? [a2, o2, 0] : r2 >= 120 && r2 < 180 ? [0, o2, a2] : r2 >= 180 && r2 < 240 ? [0, a2, o2] : r2 >= 240 && r2 < 300 ? [a2, 0, o2] : [o2, 0, a2], [255 * (c2 + l2), 255 * (u2 + l2), 255 * (p2 + l2)];
    }
    function An(e3) {
      return [e3[0], e3[1], e3[2]];
    }
    function xn(e3, t3) {
      return [e3[0], e3[1], e3[2], t3];
    }
    const En = { hsl: { hsl: (e3, t3, n2) => [e3, t3, n2], hsv: function(e3, t3, n2) {
      const r2 = n2 + t3 * (100 - Math.abs(2 * n2 - 100)) / 200;
      return [e3, 0 !== r2 ? t3 * (100 - Math.abs(2 * n2 - 100)) / r2 : 0, n2 + t3 * (100 - Math.abs(2 * n2 - 100)) / 200];
    }, rgb: function(e3, t3, n2) {
      const r2 = (e3 % 360 + 360) % 360, i2 = Xt(t3 / 100, 0, 1), s2 = Xt(n2 / 100, 0, 1), o2 = (1 - Math.abs(2 * s2 - 1)) * i2, a2 = o2 * (1 - Math.abs(r2 / 60 % 2 - 1)), l2 = s2 - o2 / 2;
      let c2, u2, p2;
      return [c2, u2, p2] = r2 >= 0 && r2 < 60 ? [o2, a2, 0] : r2 >= 60 && r2 < 120 ? [a2, o2, 0] : r2 >= 120 && r2 < 180 ? [0, o2, a2] : r2 >= 180 && r2 < 240 ? [0, a2, o2] : r2 >= 240 && r2 < 300 ? [a2, 0, o2] : [o2, 0, a2], [255 * (c2 + l2), 255 * (u2 + l2), 255 * (p2 + l2)];
    } }, hsv: { hsl: function(e3, t3, n2) {
      const r2 = 100 - Math.abs(n2 * (200 - t3) / 100 - 100);
      return [e3, 0 !== r2 ? t3 * n2 / r2 : 0, n2 * (200 - t3) / 200];
    }, hsv: (e3, t3, n2) => [e3, t3, n2], rgb: wn }, rgb: { hsl: function(e3, t3, n2) {
      const r2 = Xt(e3 / 255, 0, 1), i2 = Xt(t3 / 255, 0, 1), s2 = Xt(n2 / 255, 0, 1), o2 = Math.max(r2, i2, s2), a2 = Math.min(r2, i2, s2), l2 = o2 - a2;
      let c2 = 0, u2 = 0;
      const p2 = (a2 + o2) / 2;
      return 0 !== l2 && (u2 = l2 / (1 - Math.abs(o2 + a2 - 1)), c2 = r2 === o2 ? (i2 - s2) / l2 : i2 === o2 ? 2 + (s2 - r2) / l2 : 4 + (r2 - i2) / l2, c2 = c2 / 6 + (c2 < 0 ? 1 : 0)), [360 * c2, 100 * u2, 100 * p2];
    }, hsv: function(e3, t3, n2) {
      const r2 = Xt(e3 / 255, 0, 1), i2 = Xt(t3 / 255, 0, 1), s2 = Xt(n2 / 255, 0, 1), o2 = Math.max(r2, i2, s2), a2 = o2 - Math.min(r2, i2, s2);
      let l2;
      return l2 = 0 === a2 ? 0 : o2 === r2 ? ((i2 - s2) / a2 % 6 + 6) % 6 * 60 : o2 === i2 ? 60 * ((s2 - r2) / a2 + 2) : 60 * ((r2 - i2) / a2 + 4), [l2, 100 * (0 === o2 ? 0 : a2 / o2), 100 * o2];
    }, rgb: (e3, t3, n2) => [e3, t3, n2] } };
    function Cn(e3, t3) {
      return ["float" === t3 ? 1 : "rgb" === e3 ? 255 : 360, "float" === t3 ? 1 : "rgb" === e3 ? 255 : 100, "float" === t3 ? 1 : "rgb" === e3 ? 255 : 100];
    }
    function Sn(e3, t3, n2, r2) {
      const i2 = Cn(t3, n2), s2 = Cn(t3, r2);
      return e3.map((e4, t4) => e4 / i2[t4] * s2[t4]);
    }
    function Mn(e3, t3) {
      return "object" == typeof e3 && !a(e3) && t3 in e3 && "number" == typeof e3[t3];
    }
    class Tn {
      static black(e3 = "int") {
        return new Tn([0, 0, 0], "rgb", e3);
      }
      static fromObject(e3, t3 = "int") {
        const n2 = "a" in e3 ? [e3.r, e3.g, e3.b, e3.a] : [e3.r, e3.g, e3.b];
        return new Tn(n2, "rgb", t3);
      }
      static toRgbaObject(e3, t3 = "int") {
        return e3.toRgbaObject(t3);
      }
      static isRgbColorObject(e3) {
        return Mn(e3, "r") && Mn(e3, "g") && Mn(e3, "b");
      }
      static isRgbaColorObject(e3) {
        return this.isRgbColorObject(e3) && Mn(e3, "a");
      }
      static isColorObject(e3) {
        return this.isRgbColorObject(e3);
      }
      static equals(e3, t3) {
        if (e3.mode !== t3.mode)
          return false;
        const n2 = e3.comps_, r2 = t3.comps_;
        for (let e4 = 0; e4 < n2.length; e4++)
          if (n2[e4] !== r2[e4])
            return false;
        return true;
      }
      constructor(e3, t3, n2 = "int") {
        this.mode = t3, this.type = n2, this.comps_ = function(e4, t4, n3) {
          var r2;
          const i2 = Cn(t4, n3);
          return ["rgb" === t4 ? Xt(e4[0], 0, i2[0]) : (s2 = e4[0], o2 = i2[0], s2 === o2 ? o2 : Yt(s2, o2)), Xt(e4[1], 0, i2[1]), Xt(e4[2], 0, i2[2]), Xt(null !== (r2 = e4[3]) && void 0 !== r2 ? r2 : 1, 0, 1)];
          var s2, o2;
        }(e3, t3, n2);
      }
      getComponents(e3, t3 = "int") {
        return xn(function(e4, t4, n2) {
          const r2 = Sn(e4, t4.mode, t4.type, "int");
          return Sn(En[t4.mode][n2.mode](...r2), n2.mode, "int", n2.type);
        }(An(this.comps_), { mode: this.mode, type: this.type }, { mode: null != e3 ? e3 : this.mode, type: t3 }), this.comps_[3]);
      }
      toRgbaObject(e3 = "int") {
        const t3 = this.getComponents("rgb", e3);
        return { r: t3[0], g: t3[1], b: t3[2], a: t3[3] };
      }
    }
    const Pn = _("colp");
    class In {
      constructor(e3, t3) {
        this.alphaViews_ = null, this.element = e3.createElement("div"), this.element.classList.add(Pn()), t3.viewProps.bindClassModifiers(this.element);
        const n2 = e3.createElement("div");
        n2.classList.add(Pn("hsv"));
        const r2 = e3.createElement("div");
        r2.classList.add(Pn("sv")), this.svPaletteView_ = t3.svPaletteView, r2.appendChild(this.svPaletteView_.element), n2.appendChild(r2);
        const i2 = e3.createElement("div");
        i2.classList.add(Pn("h")), this.hPaletteView_ = t3.hPaletteView, i2.appendChild(this.hPaletteView_.element), n2.appendChild(i2), this.element.appendChild(n2);
        const s2 = e3.createElement("div");
        if (s2.classList.add(Pn("rgb")), this.textView_ = t3.textView, s2.appendChild(this.textView_.element), this.element.appendChild(s2), t3.alphaViews) {
          this.alphaViews_ = { palette: t3.alphaViews.palette, text: t3.alphaViews.text };
          const n3 = e3.createElement("div");
          n3.classList.add(Pn("a"));
          const r3 = e3.createElement("div");
          r3.classList.add(Pn("ap")), r3.appendChild(this.alphaViews_.palette.element), n3.appendChild(r3);
          const i3 = e3.createElement("div");
          i3.classList.add(Pn("at")), i3.appendChild(this.alphaViews_.text.element), n3.appendChild(i3), this.element.appendChild(n3);
        }
      }
      get allFocusableElements() {
        const e3 = [this.svPaletteView_.element, this.hPaletteView_.element, this.textView_.modeSelectElement, ...this.textView_.textViews.map((e4) => e4.inputElement)];
        return this.alphaViews_ && e3.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement), e3;
      }
    }
    function Rn(e3) {
      return "int" === e3 ? "int" : "float" === e3 ? "float" : void 0;
    }
    function kn(e3) {
      const t3 = R;
      return k(e3, { alpha: t3.optional.boolean, color: t3.optional.object({ alpha: t3.optional.boolean, type: t3.optional.custom(Rn) }), expanded: t3.optional.boolean, picker: t3.optional.custom(ln) });
    }
    function Dn(e3) {
      return e3 ? 0.1 : 1;
    }
    function Bn(e3) {
      var t3;
      return null === (t3 = e3.color) || void 0 === t3 ? void 0 : t3.type;
    }
    function On(e3, t3) {
      const n2 = e3.match(/^(.+)%$/);
      return n2 ? Math.min(0.01 * parseFloat(n2[1]) * t3, t3) : Math.min(parseFloat(e3), t3);
    }
    const Ln = { deg: (e3) => e3, grad: (e3) => 360 * e3 / 400, rad: (e3) => 360 * e3 / (2 * Math.PI), turn: (e3) => 360 * e3 };
    function Un(e3) {
      const t3 = e3.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
      if (!t3)
        return parseFloat(e3);
      const n2 = parseFloat(t3[1]), r2 = t3[2];
      return Ln[r2](n2);
    }
    function Fn(e3) {
      const t3 = e3.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
      if (!t3)
        return null;
      const n2 = [On(t3[1], 255), On(t3[2], 255), On(t3[3], 255)];
      return isNaN(n2[0]) || isNaN(n2[1]) || isNaN(n2[2]) ? null : n2;
    }
    function Nn(e3) {
      return (t3) => {
        const n2 = Fn(t3);
        return n2 ? new Tn(n2, "rgb", e3) : null;
      };
    }
    function jn(e3) {
      const t3 = e3.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
      if (!t3)
        return null;
      const n2 = [On(t3[1], 255), On(t3[2], 255), On(t3[3], 255), On(t3[4], 1)];
      return isNaN(n2[0]) || isNaN(n2[1]) || isNaN(n2[2]) || isNaN(n2[3]) ? null : n2;
    }
    function zn(e3) {
      return (t3) => {
        const n2 = jn(t3);
        return n2 ? new Tn(n2, "rgb", e3) : null;
      };
    }
    function Gn(e3) {
      const t3 = e3.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
      if (!t3)
        return null;
      const n2 = [Un(t3[1]), On(t3[2], 100), On(t3[3], 100)];
      return isNaN(n2[0]) || isNaN(n2[1]) || isNaN(n2[2]) ? null : n2;
    }
    function Vn(e3) {
      return (t3) => {
        const n2 = Gn(t3);
        return n2 ? new Tn(n2, "hsl", e3) : null;
      };
    }
    function Hn(e3) {
      const t3 = e3.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
      if (!t3)
        return null;
      const n2 = [Un(t3[1]), On(t3[2], 100), On(t3[3], 100), On(t3[4], 1)];
      return isNaN(n2[0]) || isNaN(n2[1]) || isNaN(n2[2]) || isNaN(n2[3]) ? null : n2;
    }
    function Qn(e3) {
      return (t3) => {
        const n2 = Hn(t3);
        return n2 ? new Tn(n2, "hsl", e3) : null;
      };
    }
    function Wn(e3) {
      const t3 = e3.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
      if (t3)
        return [parseInt(t3[1] + t3[1], 16), parseInt(t3[2] + t3[2], 16), parseInt(t3[3] + t3[3], 16)];
      const n2 = e3.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
      return n2 ? [parseInt(n2[1], 16), parseInt(n2[2], 16), parseInt(n2[3], 16)] : null;
    }
    function qn(e3) {
      const t3 = e3.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
      if (t3)
        return [parseInt(t3[1] + t3[1], 16), parseInt(t3[2] + t3[2], 16), parseInt(t3[3] + t3[3], 16), Wt(parseInt(t3[4] + t3[4], 16), 0, 255, 0, 1)];
      const n2 = e3.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
      return n2 ? [parseInt(n2[1], 16), parseInt(n2[2], 16), parseInt(n2[3], 16), Wt(parseInt(n2[4], 16), 0, 255, 0, 1)] : null;
    }
    function Xn(e3) {
      const t3 = e3.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
      if (!t3)
        return null;
      const n2 = [parseFloat(t3[1]), parseFloat(t3[2]), parseFloat(t3[3])];
      return isNaN(n2[0]) || isNaN(n2[1]) || isNaN(n2[2]) ? null : n2;
    }
    function Yn(e3) {
      return (t3) => {
        const n2 = Xn(t3);
        return n2 ? new Tn(n2, "rgb", e3) : null;
      };
    }
    function Kn(e3) {
      const t3 = e3.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
      if (!t3)
        return null;
      const n2 = [parseFloat(t3[1]), parseFloat(t3[2]), parseFloat(t3[3]), parseFloat(t3[4])];
      return isNaN(n2[0]) || isNaN(n2[1]) || isNaN(n2[2]) || isNaN(n2[3]) ? null : n2;
    }
    function Jn(e3) {
      return (t3) => {
        const n2 = Kn(t3);
        return n2 ? new Tn(n2, "rgb", e3) : null;
      };
    }
    const Zn = [{ parser: Wn, result: { alpha: false, mode: "rgb", notation: "hex" } }, { parser: qn, result: { alpha: true, mode: "rgb", notation: "hex" } }, { parser: Fn, result: { alpha: false, mode: "rgb", notation: "func" } }, { parser: jn, result: { alpha: true, mode: "rgb", notation: "func" } }, { parser: Gn, result: { alpha: false, mode: "hsl", notation: "func" } }, { parser: Hn, result: { alpha: true, mode: "hsl", notation: "func" } }, { parser: Xn, result: { alpha: false, mode: "rgb", notation: "object" } }, { parser: Kn, result: { alpha: true, mode: "rgb", notation: "object" } }];
    function $n(e3, t3 = "int") {
      const n2 = function(e4) {
        return Zn.reduce((t4, { parser: n3, result: r2 }) => t4 || (n3(e4) ? r2 : null), null);
      }(e3);
      return n2 ? "hex" === n2.notation && "float" !== t3 ? Object.assign(Object.assign({}, n2), { type: "int" }) : "func" === n2.notation ? Object.assign(Object.assign({}, n2), { type: t3 }) : null : null;
    }
    const er = { int: [function(e3) {
      const t3 = Wn(e3);
      return t3 ? new Tn(t3, "rgb", "int") : null;
    }, function(e3) {
      const t3 = qn(e3);
      return t3 ? new Tn(t3, "rgb", "int") : null;
    }, Nn("int"), zn("int"), Vn("int"), Qn("int"), Yn("int"), Jn("int")], float: [Nn("float"), zn("float"), Vn("float"), Qn("float"), Yn("float"), Jn("float")] };
    function tr(e3) {
      const t3 = er[e3];
      return (e4) => t3.reduce((t4, n2) => t4 || n2(e4), null);
    }
    function nr(e3) {
      const t3 = Xt(Math.floor(e3), 0, 255).toString(16);
      return 1 === t3.length ? `0${t3}` : t3;
    }
    function rr(e3, t3 = "#") {
      return `${t3}${An(e3.getComponents("rgb")).map(nr).join("")}`;
    }
    function ir(e3, t3 = "#") {
      const n2 = e3.getComponents("rgb");
      return `${t3}${[n2[0], n2[1], n2[2], 255 * n2[3]].map(nr).join("")}`;
    }
    function sr(e3, t3) {
      const n2 = Bt("float" === t3 ? 2 : 0);
      return `rgb(${An(e3.getComponents("rgb", t3)).map((e4) => n2(e4)).join(", ")})`;
    }
    function or(e3) {
      return (t3) => sr(t3, e3);
    }
    function ar(e3, t3) {
      const n2 = Bt(2), r2 = Bt("float" === t3 ? 2 : 0);
      return `rgba(${e3.getComponents("rgb", t3).map((e4, t4) => (3 === t4 ? n2 : r2)(e4)).join(", ")})`;
    }
    function lr(e3) {
      return (t3) => ar(t3, e3);
    }
    function cr(e3, t3) {
      const n2 = Bt("float" === t3 ? 2 : 0), r2 = ["r", "g", "b"];
      return `{${An(e3.getComponents("rgb", t3)).map((e4, t4) => `${r2[t4]}: ${n2(e4)}`).join(", ")}}`;
    }
    function ur(e3) {
      return (t3) => cr(t3, e3);
    }
    function pr(e3, t3) {
      const n2 = Bt(2), r2 = Bt("float" === t3 ? 2 : 0), i2 = ["r", "g", "b", "a"];
      return `{${e3.getComponents("rgb", t3).map((e4, t4) => `${i2[t4]}: ${(3 === t4 ? n2 : r2)(e4)}`).join(", ")}}`;
    }
    function dr(e3) {
      return (t3) => pr(t3, e3);
    }
    const hr = [{ format: { alpha: false, mode: "rgb", notation: "hex", type: "int" }, stringifier: rr }, { format: { alpha: true, mode: "rgb", notation: "hex", type: "int" }, stringifier: ir }, { format: { alpha: false, mode: "hsl", notation: "func", type: "int" }, stringifier: function(e3) {
      const t3 = [Bt(0), Lt, Lt];
      return `hsl(${An(e3.getComponents("hsl")).map((e4, n2) => t3[n2](e4)).join(", ")})`;
    } }, { format: { alpha: true, mode: "hsl", notation: "func", type: "int" }, stringifier: function(e3) {
      const t3 = [Bt(0), Lt, Lt, Bt(2)];
      return `hsla(${e3.getComponents("hsl").map((e4, n2) => t3[n2](e4)).join(", ")})`;
    } }, ...["int", "float"].reduce((e3, t3) => [...e3, { format: { alpha: false, mode: "rgb", notation: "func", type: t3 }, stringifier: or(t3) }, { format: { alpha: true, mode: "rgb", notation: "func", type: t3 }, stringifier: lr(t3) }, { format: { alpha: false, mode: "rgb", notation: "object", type: t3 }, stringifier: ur(t3) }, { format: { alpha: true, mode: "rgb", notation: "object", type: t3 }, stringifier: dr(t3) }], [])];
    function fr(e3) {
      return hr.reduce((t3, n2) => {
        return t3 || (r2 = n2.format, i2 = e3, r2.alpha === i2.alpha && r2.mode === i2.mode && r2.notation === i2.notation && r2.type === i2.type ? n2.stringifier : null);
        var r2, i2;
      }, null);
    }
    const mr = _("apl");
    class _r {
      constructor(e3, t3) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.value = t3.value, this.value.emitter.on("change", this.onValueChange_), this.element = e3.createElement("div"), this.element.classList.add(mr()), t3.viewProps.bindClassModifiers(this.element), t3.viewProps.bindTabIndex(this.element);
        const n2 = e3.createElement("div");
        n2.classList.add(mr("b")), this.element.appendChild(n2);
        const r2 = e3.createElement("div");
        r2.classList.add(mr("c")), n2.appendChild(r2), this.colorElem_ = r2;
        const i2 = e3.createElement("div");
        i2.classList.add(mr("m")), this.element.appendChild(i2), this.markerElem_ = i2;
        const s2 = e3.createElement("div");
        s2.classList.add(mr("p")), this.markerElem_.appendChild(s2), this.previewElem_ = s2, this.update_();
      }
      update_() {
        const e3 = this.value.rawValue, t3 = e3.getComponents("rgb"), n2 = new Tn([t3[0], t3[1], t3[2], 0], "rgb"), r2 = new Tn([t3[0], t3[1], t3[2], 255], "rgb"), i2 = ["to right", ar(n2), ar(r2)];
        this.colorElem_.style.background = `linear-gradient(${i2.join(",")})`, this.previewElem_.style.backgroundColor = ar(e3);
        const s2 = Wt(t3[3], 0, 1, 0, 100);
        this.markerElem_.style.left = `${s2}%`;
      }
      onValueChange_() {
        this.update_();
      }
    }
    class gr {
      constructor(e3, t3) {
        this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t3.value, this.viewProps = t3.viewProps, this.view = new _r(e3, { value: this.value, viewProps: this.viewProps }), this.ptHandler_ = new Qt(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
      }
      handlePointerEvent_(e3, t3) {
        if (!e3.point)
          return;
        const n2 = e3.point.x / e3.bounds.width, r2 = this.value.rawValue, [i2, s2, o2] = r2.getComponents("hsv");
        this.value.setRawValue(new Tn([i2, s2, o2, n2], "hsv"), t3);
      }
      onPointerDown_(e3) {
        this.handlePointerEvent_(e3.data, { forceEmit: false, last: false });
      }
      onPointerMove_(e3) {
        this.handlePointerEvent_(e3.data, { forceEmit: false, last: false });
      }
      onPointerUp_(e3) {
        this.handlePointerEvent_(e3.data, { forceEmit: true, last: true });
      }
      onKeyDown_(e3) {
        const t3 = jt(Dn(true), Gt(e3));
        if (0 === t3)
          return;
        const n2 = this.value.rawValue, [r2, i2, s2, o2] = n2.getComponents("hsv");
        this.value.setRawValue(new Tn([r2, i2, s2, o2 + t3], "hsv"), { forceEmit: false, last: false });
      }
      onKeyUp_(e3) {
        0 !== jt(Dn(true), Gt(e3)) && this.value.setRawValue(this.value.rawValue, { forceEmit: true, last: true });
      }
    }
    const vr = _("coltxt");
    class yr {
      constructor(e3, t3) {
        this.element = e3.createElement("div"), this.element.classList.add(vr()), t3.viewProps.bindClassModifiers(this.element);
        const n2 = e3.createElement("div");
        n2.classList.add(vr("m")), this.modeElem_ = function(e4) {
          const t4 = e4.createElement("select");
          return t4.appendChild([{ text: "RGB", value: "rgb" }, { text: "HSL", value: "hsl" }, { text: "HSV", value: "hsv" }].reduce((t5, n3) => {
            const r3 = e4.createElement("option");
            return r3.textContent = n3.text, r3.value = n3.value, t5.appendChild(r3), t5;
          }, e4.createDocumentFragment())), t4;
        }(e3), this.modeElem_.classList.add(vr("ms")), n2.appendChild(this.modeSelectElement), t3.viewProps.bindDisabled(this.modeElem_);
        const r2 = e3.createElement("div");
        r2.classList.add(vr("mm")), r2.appendChild(W(e3, "dropdown")), n2.appendChild(r2), this.element.appendChild(n2);
        const i2 = e3.createElement("div");
        i2.classList.add(vr("w")), this.element.appendChild(i2), this.textsElem_ = i2, this.textViews_ = t3.textViews, this.applyTextViews_(), v(t3.colorMode, (e4) => {
          this.modeElem_.value = e4;
        });
      }
      get modeSelectElement() {
        return this.modeElem_;
      }
      get textViews() {
        return this.textViews_;
      }
      set textViews(e3) {
        this.textViews_ = e3, this.applyTextViews_();
      }
      applyTextViews_() {
        Y(this.textsElem_);
        const e3 = this.element.ownerDocument;
        this.textViews_.forEach((t3) => {
          const n2 = e3.createElement("div");
          n2.classList.add(vr("c")), n2.appendChild(t3.element), this.textsElem_.appendChild(n2);
        });
      }
    }
    function br(e3, t3, n2) {
      const r2 = Cn(e3, t3)[n2];
      return new $e({ min: 0, max: r2 });
    }
    function wr(e3, t3, n2) {
      return new Zt(e3, { arrayPosition: 0 === n2 ? "fst" : 2 === n2 ? "lst" : "mid", baseStep: Dn(false), parser: t3.parser, props: T.fromObject({ draggingScale: "float" === t3.colorType ? 0.01 : 1, formatter: (r2 = t3.colorType, Bt("float" === r2 ? 2 : 0)) }), value: M(0, { constraint: br(t3.colorMode, t3.colorType, n2) }), viewProps: t3.viewProps });
      var r2;
    }
    class Ar {
      constructor(e3, t3) {
        this.onModeSelectChange_ = this.onModeSelectChange_.bind(this), this.colorType_ = t3.colorType, this.parser_ = t3.parser, this.value = t3.value, this.viewProps = t3.viewProps, this.colorMode = M(this.value.rawValue.mode), this.ccs_ = this.createComponentControllers_(e3), this.view = new yr(e3, { colorMode: this.colorMode, textViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view], viewProps: this.viewProps }), this.view.modeSelectElement.addEventListener("change", this.onModeSelectChange_);
      }
      createComponentControllers_(e3) {
        const t3 = { colorMode: this.colorMode.rawValue, colorType: this.colorType_, parser: this.parser_, viewProps: this.viewProps }, n2 = [wr(e3, t3, 0), wr(e3, t3, 1), wr(e3, t3, 2)];
        return n2.forEach((e4, t4) => {
          Nt({ primary: this.value, secondary: e4.value, forward: (e5) => e5.rawValue.getComponents(this.colorMode.rawValue, this.colorType_)[t4], backward: (e5, n3) => {
            const r2 = this.colorMode.rawValue, i2 = e5.rawValue.getComponents(r2, this.colorType_);
            return i2[t4] = n3.rawValue, new Tn(xn(An(i2), i2[3]), r2, this.colorType_);
          } });
        }), n2;
      }
      onModeSelectChange_(e3) {
        const t3 = e3.currentTarget;
        this.colorMode.rawValue = t3.value, this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument), this.view.textViews = [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view];
      }
    }
    const xr = _("hpl");
    class Er {
      constructor(e3, t3) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.value = t3.value, this.value.emitter.on("change", this.onValueChange_), this.element = e3.createElement("div"), this.element.classList.add(xr()), t3.viewProps.bindClassModifiers(this.element), t3.viewProps.bindTabIndex(this.element);
        const n2 = e3.createElement("div");
        n2.classList.add(xr("c")), this.element.appendChild(n2);
        const r2 = e3.createElement("div");
        r2.classList.add(xr("m")), this.element.appendChild(r2), this.markerElem_ = r2, this.update_();
      }
      update_() {
        const e3 = this.value.rawValue, [t3] = e3.getComponents("hsv");
        this.markerElem_.style.backgroundColor = sr(new Tn([t3, 100, 100], "hsv"));
        const n2 = Wt(t3, 0, 360, 0, 100);
        this.markerElem_.style.left = `${n2}%`;
      }
      onValueChange_() {
        this.update_();
      }
    }
    class Cr {
      constructor(e3, t3) {
        this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t3.value, this.viewProps = t3.viewProps, this.view = new Er(e3, { value: this.value, viewProps: this.viewProps }), this.ptHandler_ = new Qt(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
      }
      handlePointerEvent_(e3, t3) {
        if (!e3.point)
          return;
        const n2 = Wt(Xt(e3.point.x, 0, e3.bounds.width), 0, e3.bounds.width, 0, 360), r2 = this.value.rawValue, [, i2, s2, o2] = r2.getComponents("hsv");
        this.value.setRawValue(new Tn([n2, i2, s2, o2], "hsv"), t3);
      }
      onPointerDown_(e3) {
        this.handlePointerEvent_(e3.data, { forceEmit: false, last: false });
      }
      onPointerMove_(e3) {
        this.handlePointerEvent_(e3.data, { forceEmit: false, last: false });
      }
      onPointerUp_(e3) {
        this.handlePointerEvent_(e3.data, { forceEmit: true, last: true });
      }
      onKeyDown_(e3) {
        const t3 = jt(Dn(false), Gt(e3));
        if (0 === t3)
          return;
        const n2 = this.value.rawValue, [r2, i2, s2, o2] = n2.getComponents("hsv");
        this.value.setRawValue(new Tn([r2 + t3, i2, s2, o2], "hsv"), { forceEmit: false, last: false });
      }
      onKeyUp_(e3) {
        0 !== jt(Dn(false), Gt(e3)) && this.value.setRawValue(this.value.rawValue, { forceEmit: true, last: true });
      }
    }
    const Sr = _("svp");
    class Mr {
      constructor(e3, t3) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.value = t3.value, this.value.emitter.on("change", this.onValueChange_), this.element = e3.createElement("div"), this.element.classList.add(Sr()), t3.viewProps.bindClassModifiers(this.element), t3.viewProps.bindTabIndex(this.element);
        const n2 = e3.createElement("canvas");
        n2.height = 64, n2.width = 64, n2.classList.add(Sr("c")), this.element.appendChild(n2), this.canvasElement = n2;
        const r2 = e3.createElement("div");
        r2.classList.add(Sr("m")), this.element.appendChild(r2), this.markerElem_ = r2, this.update_();
      }
      update_() {
        const e3 = function(e4) {
          const t4 = e4.ownerDocument.defaultView;
          return t4 && "document" in t4 ? e4.getContext("2d", { willReadFrequently: true }) : null;
        }(this.canvasElement);
        if (!e3)
          return;
        const t3 = this.value.rawValue.getComponents("hsv"), n2 = this.canvasElement.width, r2 = this.canvasElement.height, i2 = e3.getImageData(0, 0, n2, r2), s2 = i2.data;
        for (let e4 = 0; e4 < r2; e4++)
          for (let i3 = 0; i3 < n2; i3++) {
            const o3 = Wt(i3, 0, n2, 0, 100), a3 = Wt(e4, 0, r2, 100, 0), l2 = wn(t3[0], o3, a3), c2 = 4 * (e4 * n2 + i3);
            s2[c2] = l2[0], s2[c2 + 1] = l2[1], s2[c2 + 2] = l2[2], s2[c2 + 3] = 255;
          }
        e3.putImageData(i2, 0, 0);
        const o2 = Wt(t3[1], 0, 100, 0, 100);
        this.markerElem_.style.left = `${o2}%`;
        const a2 = Wt(t3[2], 0, 100, 100, 0);
        this.markerElem_.style.top = `${a2}%`;
      }
      onValueChange_() {
        this.update_();
      }
    }
    class Tr {
      constructor(e3, t3) {
        this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t3.value, this.viewProps = t3.viewProps, this.view = new Mr(e3, { value: this.value, viewProps: this.viewProps }), this.ptHandler_ = new Qt(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
      }
      handlePointerEvent_(e3, t3) {
        if (!e3.point)
          return;
        const n2 = Wt(e3.point.x, 0, e3.bounds.width, 0, 100), r2 = Wt(e3.point.y, 0, e3.bounds.height, 100, 0), [i2, , , s2] = this.value.rawValue.getComponents("hsv");
        this.value.setRawValue(new Tn([i2, n2, r2, s2], "hsv"), t3);
      }
      onPointerDown_(e3) {
        this.handlePointerEvent_(e3.data, { forceEmit: false, last: false });
      }
      onPointerMove_(e3) {
        this.handlePointerEvent_(e3.data, { forceEmit: false, last: false });
      }
      onPointerUp_(e3) {
        this.handlePointerEvent_(e3.data, { forceEmit: true, last: true });
      }
      onKeyDown_(e3) {
        Vt(e3.key) && e3.preventDefault();
        const [t3, n2, r2, i2] = this.value.rawValue.getComponents("hsv"), s2 = Dn(false), o2 = jt(s2, Gt(e3)), a2 = jt(s2, zt(e3));
        0 === o2 && 0 === a2 || this.value.setRawValue(new Tn([t3, n2 + o2, r2 + a2, i2], "hsv"), { forceEmit: false, last: false });
      }
      onKeyUp_(e3) {
        const t3 = Dn(false), n2 = jt(t3, Gt(e3)), r2 = jt(t3, zt(e3));
        0 === n2 && 0 === r2 || this.value.setRawValue(this.value.rawValue, { forceEmit: true, last: true });
      }
    }
    class Pr {
      constructor(e3, t3) {
        this.value = t3.value, this.viewProps = t3.viewProps, this.hPaletteC_ = new Cr(e3, { value: this.value, viewProps: this.viewProps }), this.svPaletteC_ = new Tr(e3, { value: this.value, viewProps: this.viewProps }), this.alphaIcs_ = t3.supportsAlpha ? { palette: new gr(e3, { value: this.value, viewProps: this.viewProps }), text: new Zt(e3, { parser: Rt, baseStep: 0.1, props: T.fromObject({ draggingScale: 0.01, formatter: Bt(2) }), value: M(0, { constraint: new $e({ min: 0, max: 1 }) }), viewProps: this.viewProps }) } : null, this.alphaIcs_ && Nt({ primary: this.value, secondary: this.alphaIcs_.text.value, forward: (e4) => e4.rawValue.getComponents()[3], backward: (e4, t4) => {
          const n2 = e4.rawValue.getComponents();
          return n2[3] = t4.rawValue, new Tn(n2, e4.rawValue.mode);
        } }), this.textC_ = new Ar(e3, { colorType: t3.colorType, parser: Rt, value: this.value, viewProps: this.viewProps }), this.view = new In(e3, { alphaViews: this.alphaIcs_ ? { palette: this.alphaIcs_.palette.view, text: this.alphaIcs_.text.view } : null, hPaletteView: this.hPaletteC_.view, supportsAlpha: t3.supportsAlpha, svPaletteView: this.svPaletteC_.view, textView: this.textC_.view, viewProps: this.viewProps });
      }
      get textController() {
        return this.textC_;
      }
    }
    const Ir = _("colsw");
    class Rr {
      constructor(e3, t3) {
        this.onValueChange_ = this.onValueChange_.bind(this), t3.value.emitter.on("change", this.onValueChange_), this.value = t3.value, this.element = e3.createElement("div"), this.element.classList.add(Ir()), t3.viewProps.bindClassModifiers(this.element);
        const n2 = e3.createElement("div");
        n2.classList.add(Ir("sw")), this.element.appendChild(n2), this.swatchElem_ = n2;
        const r2 = e3.createElement("button");
        r2.classList.add(Ir("b")), t3.viewProps.bindDisabled(r2), this.element.appendChild(r2), this.buttonElement = r2, this.update_();
      }
      update_() {
        const e3 = this.value.rawValue;
        this.swatchElem_.style.backgroundColor = ir(e3);
      }
      onValueChange_() {
        this.update_();
      }
    }
    class kr {
      constructor(e3, t3) {
        this.value = t3.value, this.viewProps = t3.viewProps, this.view = new Rr(e3, { value: this.value, viewProps: this.viewProps });
      }
    }
    class Dr {
      constructor(e3, t3) {
        this.onButtonBlur_ = this.onButtonBlur_.bind(this), this.onButtonClick_ = this.onButtonClick_.bind(this), this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.value = t3.value, this.viewProps = t3.viewProps, this.foldable_ = re.create(t3.expanded), this.swatchC_ = new kr(e3, { value: this.value, viewProps: this.viewProps });
        const n2 = this.swatchC_.view.buttonElement;
        n2.addEventListener("blur", this.onButtonBlur_), n2.addEventListener("click", this.onButtonClick_), this.textC_ = new pt(e3, { parser: t3.parser, props: T.fromObject({ formatter: t3.formatter }), value: this.value, viewProps: this.viewProps }), this.view = new bn(e3, { foldable: this.foldable_, pickerLayout: t3.pickerLayout }), this.view.swatchElement.appendChild(this.swatchC_.view.element), this.view.textElement.appendChild(this.textC_.view.element), this.popC_ = "popup" === t3.pickerLayout ? new lt(e3, { viewProps: this.viewProps }) : null;
        const r2 = new Pr(e3, { colorType: t3.colorType, supportsAlpha: t3.supportsAlpha, value: this.value, viewProps: this.viewProps });
        r2.view.allFocusableElements.forEach((e4) => {
          e4.addEventListener("blur", this.onPopupChildBlur_), e4.addEventListener("keydown", this.onPopupChildKeydown_);
        }), this.pickerC_ = r2, this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(r2.view.element), Nt({ primary: this.foldable_.value("expanded"), secondary: this.popC_.shows, forward: (e4) => e4.rawValue, backward: (e4, t4) => t4.rawValue })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), se(this.foldable_, this.view.pickerElement));
      }
      get textController() {
        return this.textC_;
      }
      onButtonBlur_(e3) {
        if (!this.popC_)
          return;
        const t3 = this.view.element, n2 = e3.relatedTarget;
        n2 && t3.contains(n2) || (this.popC_.shows.rawValue = false);
      }
      onButtonClick_() {
        this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus();
      }
      onPopupChildBlur_(e3) {
        if (!this.popC_)
          return;
        const t3 = this.popC_.view.element, n2 = K(e3);
        n2 && t3.contains(n2) || n2 && n2 === this.swatchC_.view.buttonElement && !V(t3.ownerDocument) || (this.popC_.shows.rawValue = false);
      }
      onPopupChildKeydown_(e3) {
        this.popC_ ? "Escape" === e3.key && (this.popC_.shows.rawValue = false) : this.view.pickerElement && "Escape" === e3.key && this.swatchC_.view.buttonElement.focus();
      }
    }
    function Br(e3) {
      return An(e3.getComponents("rgb")).reduce((e4, t3) => e4 << 8 | 255 & Math.floor(t3), 0);
    }
    function Or(e3) {
      return e3.getComponents("rgb").reduce((e4, t3, n2) => e4 << 8 | 255 & Math.floor(3 === n2 ? 255 * t3 : t3), 0) >>> 0;
    }
    function Lr(e3) {
      return "number" != typeof e3 ? Tn.black() : new Tn([(t3 = e3) >> 16 & 255, t3 >> 8 & 255, 255 & t3], "rgb");
      var t3;
    }
    function Ur(e3) {
      return "number" != typeof e3 ? Tn.black() : new Tn([(t3 = e3) >> 24 & 255, t3 >> 16 & 255, t3 >> 8 & 255, Wt(255 & t3, 0, 255, 0, 1)], "rgb");
      var t3;
    }
    function Fr(e3) {
      var t3;
      return !(!(null == e3 ? void 0 : e3.alpha) && !(null === (t3 = null == e3 ? void 0 : e3.color) || void 0 === t3 ? void 0 : t3.alpha));
    }
    function Nr(e3) {
      return e3 ? (e4) => ir(e4, "0x") : (e4) => rr(e4, "0x");
    }
    const jr = { id: "input-color-number", type: "input", accept: (e3, t3) => {
      if ("number" != typeof e3)
        return null;
      if (!function(e4) {
        return "color" in e4 || "view" in e4 && "color" === e4.view;
      }(t3))
        return null;
      const n2 = kn(t3);
      return n2 ? { initialValue: e3, params: n2 } : null;
    }, binding: { reader: (e3) => Fr(e3.params) ? Ur : Lr, equals: Tn.equals, writer: (e3) => function(e4) {
      const t3 = e4 ? Or : Br;
      return (e5, n2) => {
        on(e5, t3(n2));
      };
    }(Fr(e3.params)) }, controller: (e3) => {
      const t3 = Fr(e3.params), n2 = "expanded" in e3.params ? e3.params.expanded : void 0, r2 = "picker" in e3.params ? e3.params.picker : void 0;
      return new Dr(e3.document, { colorType: "int", expanded: null != n2 && n2, formatter: Nr(t3), parser: tr("int"), pickerLayout: null != r2 ? r2 : "popup", supportsAlpha: t3, value: e3.value, viewProps: e3.viewProps });
    } };
    function zr(e3) {
      return (t3) => function(e4, t4) {
        return Tn.isColorObject(e4) ? Tn.fromObject(e4, t4) : Tn.black(t4);
      }(t3, e3);
    }
    function Gr(e3, t3) {
      return (n2) => e3 ? pr(n2, t3) : cr(n2, t3);
    }
    const Vr = { id: "input-color-object", type: "input", accept: (e3, t3) => {
      if (!Tn.isColorObject(e3))
        return null;
      const n2 = kn(t3);
      return n2 ? { initialValue: e3, params: n2 } : null;
    }, binding: { reader: (e3) => zr(Bn(e3.params)), equals: Tn.equals, writer: (e3) => {
      return r2 = e3.initialValue, t3 = Tn.isRgbaColorObject(r2), n2 = Bn(e3.params), (e4, r3) => {
        t3 ? function(e5, t4, n3) {
          const r4 = t4.toRgbaObject(n3);
          e5.writeProperty("r", r4.r), e5.writeProperty("g", r4.g), e5.writeProperty("b", r4.b), e5.writeProperty("a", r4.a);
        }(e4, r3, n2) : function(e5, t4, n3) {
          const r4 = t4.toRgbaObject(n3);
          e5.writeProperty("r", r4.r), e5.writeProperty("g", r4.g), e5.writeProperty("b", r4.b);
        }(e4, r3, n2);
      };
      var t3, n2, r2;
    } }, controller: (e3) => {
      var t3;
      const n2 = Tn.isRgbaColorObject(e3.initialValue), r2 = "expanded" in e3.params ? e3.params.expanded : void 0, i2 = "picker" in e3.params ? e3.params.picker : void 0, s2 = null !== (t3 = Bn(e3.params)) && void 0 !== t3 ? t3 : "int";
      return new Dr(e3.document, { colorType: s2, expanded: null != r2 && r2, formatter: Gr(n2, s2), parser: tr(s2), pickerLayout: null != i2 ? i2 : "popup", supportsAlpha: n2, value: e3.value, viewProps: e3.viewProps });
    } }, Hr = { id: "input-color-string", type: "input", accept: (e3, t3) => {
      if ("string" != typeof e3)
        return null;
      if ("view" in t3 && "text" === t3.view)
        return null;
      const n2 = $n(e3, Bn(t3));
      if (!n2)
        return null;
      if (!fr(n2))
        return null;
      const r2 = kn(t3);
      return r2 ? { initialValue: e3, params: r2 } : null;
    }, binding: { reader: (e3) => {
      var t3;
      return function(e4) {
        const t4 = er[e4];
        return (n2) => {
          if ("string" != typeof n2)
            return Tn.black(e4);
          const r2 = t4.reduce((e5, t5) => e5 || t5(n2), null);
          return null != r2 ? r2 : Tn.black(e4);
        };
      }(null !== (t3 = Bn(e3.params)) && void 0 !== t3 ? t3 : "int");
    }, equals: Tn.equals, writer: (e3) => {
      const t3 = $n(e3.initialValue, Bn(e3.params));
      if (!t3)
        throw p.shouldNeverHappen();
      const n2 = function(e4) {
        const t4 = fr(e4);
        return t4 ? (e5, n3) => {
          on(e5, t4(n3));
        } : null;
      }(t3);
      if (!n2)
        throw p.notBindable();
      return n2;
    } }, controller: (e3) => {
      const t3 = $n(e3.initialValue, Bn(e3.params));
      if (!t3)
        throw p.shouldNeverHappen();
      const n2 = fr(t3);
      if (!n2)
        throw p.shouldNeverHappen();
      const r2 = "expanded" in e3.params ? e3.params.expanded : void 0, i2 = "picker" in e3.params ? e3.params.picker : void 0;
      return new Dr(e3.document, { colorType: t3.type, expanded: null != r2 && r2, formatter: n2, parser: tr(t3.type), pickerLayout: null != i2 ? i2 : "popup", supportsAlpha: t3.alpha, value: e3.value, viewProps: e3.viewProps });
    } };
    class Qr {
      constructor(e3) {
        this.components = e3.components, this.asm_ = e3.assembly;
      }
      constrain(e3) {
        const t3 = this.asm_.toComponents(e3).map((e4, t4) => {
          var n2, r2;
          return null !== (r2 = null === (n2 = this.components[t4]) || void 0 === n2 ? void 0 : n2.constrain(e4)) && void 0 !== r2 ? r2 : e4;
        });
        return this.asm_.fromComponents(t3);
      }
    }
    const Wr = _("pndtxt");
    class qr {
      constructor(e3, t3) {
        this.textViews = t3.textViews, this.element = e3.createElement("div"), this.element.classList.add(Wr()), this.textViews.forEach((t4) => {
          const n2 = e3.createElement("div");
          n2.classList.add(Wr("a")), n2.appendChild(t4.element), this.element.appendChild(n2);
        });
      }
    }
    class Xr {
      constructor(e3, t3) {
        this.value = t3.value, this.viewProps = t3.viewProps, this.acs_ = t3.axes.map((n2, r2) => function(e4, t4, n3) {
          return new Zt(e4, { arrayPosition: 0 === n3 ? "fst" : n3 === t4.axes.length - 1 ? "lst" : "mid", baseStep: t4.axes[n3].baseStep, parser: t4.parser, props: t4.axes[n3].textProps, value: M(0, { constraint: t4.axes[n3].constraint }), viewProps: t4.viewProps });
        }(e3, t3, r2)), this.acs_.forEach((e4, n2) => {
          Nt({ primary: this.value, secondary: e4.value, forward: (e5) => t3.assembly.toComponents(e5.rawValue)[n2], backward: (e5, r2) => {
            const i2 = t3.assembly.toComponents(e5.rawValue);
            return i2[n2] = r2.rawValue, t3.assembly.fromComponents(i2);
          } });
        }), this.view = new qr(e3, { textViews: this.acs_.map((e4) => e4.view) });
      }
    }
    function Yr(e3, t3) {
      return "step" in e3 && !a(e3.step) ? new nt(e3.step, t3) : null;
    }
    function Kr(e3) {
      return a(e3.max) || a(e3.min) ? a(e3.max) && a(e3.min) ? null : new tt({ max: e3.max, min: e3.min }) : new $e({ max: e3.max, min: e3.min });
    }
    const Jr = { id: "input-number", type: "input", accept: (e3, t3) => {
      if ("number" != typeof e3)
        return null;
      const n2 = R, r2 = k(t3, { format: n2.optional.function, max: n2.optional.number, min: n2.optional.number, options: n2.optional.custom(an), step: n2.optional.number });
      return r2 ? { initialValue: e3, params: r2 } : null;
    }, binding: { reader: (e3) => kt, constraint: (e3) => function(e4, t3) {
      const n2 = [], r2 = Yr(e4, t3);
      r2 && n2.push(r2);
      const i2 = Kr(e4);
      i2 && n2.push(i2);
      const s2 = pn(e4.options);
      return s2 && n2.push(s2), new Je(n2);
    }(e3.params, e3.initialValue), writer: (e3) => on }, controller: (e3) => {
      var t3;
      const n2 = e3.value, r2 = e3.constraint, i2 = r2 && Ze(r2, et);
      if (i2)
        return new st(e3.document, { props: new T({ options: i2.values.value("options") }), value: n2, viewProps: e3.viewProps });
      const s2 = null !== (t3 = "format" in e3.params ? e3.params.format : void 0) && void 0 !== t3 ? t3 : Bt(dn(r2, n2.rawValue)), o2 = r2 && Ze(r2, $e);
      return o2 ? new sn(e3.document, { baseStep: hn(r2), parser: Rt, sliderProps: new T({ maxValue: o2.values.value("max"), minValue: o2.values.value("min") }), textProps: T.fromObject({ draggingScale: fn(r2, n2.rawValue), formatter: s2 }), value: n2, viewProps: e3.viewProps }) : new Zt(e3.document, { baseStep: hn(r2), parser: Rt, props: T.fromObject({ draggingScale: fn(r2, n2.rawValue), formatter: s2 }), value: n2, viewProps: e3.viewProps });
    } };
    class Zr {
      constructor(e3 = 0, t3 = 0) {
        this.x = e3, this.y = t3;
      }
      getComponents() {
        return [this.x, this.y];
      }
      static isObject(e3) {
        if (a(e3))
          return false;
        const t3 = e3.x, n2 = e3.y;
        return "number" == typeof t3 && "number" == typeof n2;
      }
      static equals(e3, t3) {
        return e3.x === t3.x && e3.y === t3.y;
      }
      toObject() {
        return { x: this.x, y: this.y };
      }
    }
    const $r = { toComponents: (e3) => e3.getComponents(), fromComponents: (e3) => new Zr(...e3) }, ei = _("p2d");
    class ti {
      constructor(e3, t3) {
        this.element = e3.createElement("div"), this.element.classList.add(ei()), t3.viewProps.bindClassModifiers(this.element), v(t3.expanded, b(this.element, ei(void 0, "expanded")));
        const n2 = e3.createElement("div");
        n2.classList.add(ei("h")), this.element.appendChild(n2);
        const r2 = e3.createElement("button");
        r2.classList.add(ei("b")), r2.appendChild(W(e3, "p2dpad")), t3.viewProps.bindDisabled(r2), n2.appendChild(r2), this.buttonElement = r2;
        const i2 = e3.createElement("div");
        if (i2.classList.add(ei("t")), n2.appendChild(i2), this.textElement = i2, "inline" === t3.pickerLayout) {
          const t4 = e3.createElement("div");
          t4.classList.add(ei("p")), this.element.appendChild(t4), this.pickerElement = t4;
        } else
          this.pickerElement = null;
      }
    }
    const ni = _("p2dp");
    class ri {
      constructor(e3, t3) {
        this.onFoldableChange_ = this.onFoldableChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.invertsY_ = t3.invertsY, this.maxValue_ = t3.maxValue, this.element = e3.createElement("div"), this.element.classList.add(ni()), "popup" === t3.layout && this.element.classList.add(ni(void 0, "p")), t3.viewProps.bindClassModifiers(this.element);
        const n2 = e3.createElement("div");
        n2.classList.add(ni("p")), t3.viewProps.bindTabIndex(n2), this.element.appendChild(n2), this.padElement = n2;
        const r2 = e3.createElementNS(z, "svg");
        r2.classList.add(ni("g")), this.padElement.appendChild(r2), this.svgElem_ = r2;
        const i2 = e3.createElementNS(z, "line");
        i2.classList.add(ni("ax")), i2.setAttributeNS(null, "x1", "0"), i2.setAttributeNS(null, "y1", "50%"), i2.setAttributeNS(null, "x2", "100%"), i2.setAttributeNS(null, "y2", "50%"), this.svgElem_.appendChild(i2);
        const s2 = e3.createElementNS(z, "line");
        s2.classList.add(ni("ax")), s2.setAttributeNS(null, "x1", "50%"), s2.setAttributeNS(null, "y1", "0"), s2.setAttributeNS(null, "x2", "50%"), s2.setAttributeNS(null, "y2", "100%"), this.svgElem_.appendChild(s2);
        const o2 = e3.createElementNS(z, "line");
        o2.classList.add(ni("l")), o2.setAttributeNS(null, "x1", "50%"), o2.setAttributeNS(null, "y1", "50%"), this.svgElem_.appendChild(o2), this.lineElem_ = o2;
        const a2 = e3.createElement("div");
        a2.classList.add(ni("m")), this.padElement.appendChild(a2), this.markerElem_ = a2, t3.value.emitter.on("change", this.onValueChange_), this.value = t3.value, this.update_();
      }
      get allFocusableElements() {
        return [this.padElement];
      }
      update_() {
        const [e3, t3] = this.value.rawValue.getComponents(), n2 = this.maxValue_, r2 = Wt(e3, -n2, +n2, 0, 100), i2 = Wt(t3, -n2, +n2, 0, 100), s2 = this.invertsY_ ? 100 - i2 : i2;
        this.lineElem_.setAttributeNS(null, "x2", `${r2}%`), this.lineElem_.setAttributeNS(null, "y2", `${s2}%`), this.markerElem_.style.left = `${r2}%`, this.markerElem_.style.top = `${s2}%`;
      }
      onValueChange_() {
        this.update_();
      }
      onFoldableChange_() {
        this.update_();
      }
    }
    function ii(e3, t3, n2) {
      return [jt(t3[0], Gt(e3)), jt(t3[1], zt(e3)) * (n2 ? 1 : -1)];
    }
    class si {
      constructor(e3, t3) {
        this.onPadKeyDown_ = this.onPadKeyDown_.bind(this), this.onPadKeyUp_ = this.onPadKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t3.value, this.viewProps = t3.viewProps, this.baseSteps_ = t3.baseSteps, this.maxValue_ = t3.maxValue, this.invertsY_ = t3.invertsY, this.view = new ri(e3, { invertsY: this.invertsY_, layout: t3.layout, maxValue: this.maxValue_, value: this.value, viewProps: this.viewProps }), this.ptHandler_ = new Qt(this.view.padElement), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.padElement.addEventListener("keydown", this.onPadKeyDown_), this.view.padElement.addEventListener("keyup", this.onPadKeyUp_);
      }
      handlePointerEvent_(e3, t3) {
        if (!e3.point)
          return;
        const n2 = this.maxValue_, r2 = Wt(e3.point.x, 0, e3.bounds.width, -n2, +n2), i2 = Wt(this.invertsY_ ? e3.bounds.height - e3.point.y : e3.point.y, 0, e3.bounds.height, -n2, +n2);
        this.value.setRawValue(new Zr(r2, i2), t3);
      }
      onPointerDown_(e3) {
        this.handlePointerEvent_(e3.data, { forceEmit: false, last: false });
      }
      onPointerMove_(e3) {
        this.handlePointerEvent_(e3.data, { forceEmit: false, last: false });
      }
      onPointerUp_(e3) {
        this.handlePointerEvent_(e3.data, { forceEmit: true, last: true });
      }
      onPadKeyDown_(e3) {
        Vt(e3.key) && e3.preventDefault();
        const [t3, n2] = ii(e3, this.baseSteps_, this.invertsY_);
        0 === t3 && 0 === n2 || this.value.setRawValue(new Zr(this.value.rawValue.x + t3, this.value.rawValue.y + n2), { forceEmit: false, last: false });
      }
      onPadKeyUp_(e3) {
        const [t3, n2] = ii(e3, this.baseSteps_, this.invertsY_);
        0 === t3 && 0 === n2 || this.value.setRawValue(this.value.rawValue, { forceEmit: true, last: true });
      }
    }
    class oi {
      constructor(e3, t3) {
        var n2, r2;
        this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this), this.onPadButtonClick_ = this.onPadButtonClick_.bind(this), this.value = t3.value, this.viewProps = t3.viewProps, this.foldable_ = re.create(t3.expanded), this.popC_ = "popup" === t3.pickerLayout ? new lt(e3, { viewProps: this.viewProps }) : null;
        const i2 = new si(e3, { baseSteps: [t3.axes[0].baseStep, t3.axes[1].baseStep], invertsY: t3.invertsY, layout: t3.pickerLayout, maxValue: t3.maxValue, value: this.value, viewProps: this.viewProps });
        i2.view.allFocusableElements.forEach((e4) => {
          e4.addEventListener("blur", this.onPopupChildBlur_), e4.addEventListener("keydown", this.onPopupChildKeydown_);
        }), this.pickerC_ = i2, this.textC_ = new Xr(e3, { assembly: $r, axes: t3.axes, parser: t3.parser, value: this.value, viewProps: this.viewProps }), this.view = new ti(e3, { expanded: this.foldable_.value("expanded"), pickerLayout: t3.pickerLayout, viewProps: this.viewProps }), this.view.textElement.appendChild(this.textC_.view.element), null === (n2 = this.view.buttonElement) || void 0 === n2 || n2.addEventListener("blur", this.onPadButtonBlur_), null === (r2 = this.view.buttonElement) || void 0 === r2 || r2.addEventListener("click", this.onPadButtonClick_), this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(this.pickerC_.view.element), Nt({ primary: this.foldable_.value("expanded"), secondary: this.popC_.shows, forward: (e4) => e4.rawValue, backward: (e4, t4) => t4.rawValue })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), se(this.foldable_, this.view.pickerElement));
      }
      onPadButtonBlur_(e3) {
        if (!this.popC_)
          return;
        const t3 = this.view.element, n2 = e3.relatedTarget;
        n2 && t3.contains(n2) || (this.popC_.shows.rawValue = false);
      }
      onPadButtonClick_() {
        this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus();
      }
      onPopupChildBlur_(e3) {
        if (!this.popC_)
          return;
        const t3 = this.popC_.view.element, n2 = K(e3);
        n2 && t3.contains(n2) || n2 && n2 === this.view.buttonElement && !V(t3.ownerDocument) || (this.popC_.shows.rawValue = false);
      }
      onPopupChildKeydown_(e3) {
        this.popC_ ? "Escape" === e3.key && (this.popC_.shows.rawValue = false) : this.view.pickerElement && "Escape" === e3.key && this.view.buttonElement.focus();
      }
    }
    class ai {
      constructor(e3 = 0, t3 = 0, n2 = 0) {
        this.x = e3, this.y = t3, this.z = n2;
      }
      getComponents() {
        return [this.x, this.y, this.z];
      }
      static isObject(e3) {
        if (a(e3))
          return false;
        const t3 = e3.x, n2 = e3.y, r2 = e3.z;
        return "number" == typeof t3 && "number" == typeof n2 && "number" == typeof r2;
      }
      static equals(e3, t3) {
        return e3.x === t3.x && e3.y === t3.y && e3.z === t3.z;
      }
      toObject() {
        return { x: this.x, y: this.y, z: this.z };
      }
    }
    const li = { toComponents: (e3) => e3.getComponents(), fromComponents: (e3) => new ai(...e3) };
    function ci(e3) {
      return ai.isObject(e3) ? new ai(e3.x, e3.y, e3.z) : new ai();
    }
    function ui(e3, t3) {
      e3.writeProperty("x", t3.x), e3.writeProperty("y", t3.y), e3.writeProperty("z", t3.z);
    }
    function pi(e3, t3) {
      return { baseStep: hn(t3), constraint: t3, textProps: T.fromObject({ draggingScale: fn(t3, e3), formatter: Bt(dn(t3, e3)) }) };
    }
    const di = { id: "input-point3d", type: "input", accept: (e3, t3) => {
      if (!ai.isObject(e3))
        return null;
      const n2 = R, r2 = k(t3, { x: n2.optional.custom(cn), y: n2.optional.custom(cn), z: n2.optional.custom(cn) });
      return r2 ? { initialValue: e3, params: r2 } : null;
    }, binding: { reader: (e3) => ci, constraint: (e3) => {
      return t3 = e3.params, n2 = e3.initialValue, new Qr({ assembly: li, components: [Fi("x" in t3 ? t3.x : void 0, n2.x), Fi("y" in t3 ? t3.y : void 0, n2.y), Fi("z" in t3 ? t3.z : void 0, n2.z)] });
      var t3, n2;
    }, equals: ai.equals, writer: (e3) => ui }, controller: (e3) => {
      const t3 = e3.value, n2 = e3.constraint;
      if (!(n2 instanceof Qr))
        throw p.shouldNeverHappen();
      return new Xr(e3.document, { assembly: li, axes: [pi(t3.rawValue.x, n2.components[0]), pi(t3.rawValue.y, n2.components[1]), pi(t3.rawValue.z, n2.components[2])], parser: Rt, value: t3, viewProps: e3.viewProps });
    } };
    class hi {
      constructor(e3 = 0, t3 = 0, n2 = 0, r2 = 0) {
        this.x = e3, this.y = t3, this.z = n2, this.w = r2;
      }
      getComponents() {
        return [this.x, this.y, this.z, this.w];
      }
      static isObject(e3) {
        if (a(e3))
          return false;
        const t3 = e3.x, n2 = e3.y, r2 = e3.z, i2 = e3.w;
        return "number" == typeof t3 && "number" == typeof n2 && "number" == typeof r2 && "number" == typeof i2;
      }
      static equals(e3, t3) {
        return e3.x === t3.x && e3.y === t3.y && e3.z === t3.z && e3.w === t3.w;
      }
      toObject() {
        return { x: this.x, y: this.y, z: this.z, w: this.w };
      }
    }
    const fi = { toComponents: (e3) => e3.getComponents(), fromComponents: (e3) => new hi(...e3) };
    function mi(e3) {
      return hi.isObject(e3) ? new hi(e3.x, e3.y, e3.z, e3.w) : new hi();
    }
    function _i(e3, t3) {
      e3.writeProperty("x", t3.x), e3.writeProperty("y", t3.y), e3.writeProperty("z", t3.z), e3.writeProperty("w", t3.w);
    }
    const gi = { id: "input-point4d", type: "input", accept: (e3, t3) => {
      if (!hi.isObject(e3))
        return null;
      const n2 = R, r2 = k(t3, { x: n2.optional.custom(cn), y: n2.optional.custom(cn), z: n2.optional.custom(cn), w: n2.optional.custom(cn) });
      return r2 ? { initialValue: e3, params: r2 } : null;
    }, binding: { reader: (e3) => mi, constraint: (e3) => {
      return t3 = e3.params, n2 = e3.initialValue, new Qr({ assembly: fi, components: [Fi("x" in t3 ? t3.x : void 0, n2.x), Fi("y" in t3 ? t3.y : void 0, n2.y), Fi("z" in t3 ? t3.z : void 0, n2.z), Fi("w" in t3 ? t3.w : void 0, n2.w)] });
      var t3, n2;
    }, equals: hi.equals, writer: (e3) => _i }, controller: (e3) => {
      const t3 = e3.value, n2 = e3.constraint;
      if (!(n2 instanceof Qr))
        throw p.shouldNeverHappen();
      return new Xr(e3.document, { assembly: fi, axes: t3.rawValue.getComponents().map((e4, t4) => {
        return r2 = e4, { baseStep: hn(i2 = n2.components[t4]), constraint: i2, textProps: T.fromObject({ draggingScale: fn(i2, r2), formatter: Bt(dn(i2, r2)) }) };
        var r2, i2;
      }), parser: Rt, value: t3, viewProps: e3.viewProps });
    } };
    const vi = { id: "input-string", type: "input", accept: (e3, t3) => {
      if ("string" != typeof e3)
        return null;
      const n2 = k(t3, { options: R.optional.custom(an) });
      return n2 ? { initialValue: e3, params: n2 } : null;
    }, binding: { reader: (e3) => Ut, constraint: (e3) => function(e4) {
      const t3 = [], n2 = pn(e4.options);
      return n2 && t3.push(n2), new Je(t3);
    }(e3.params), writer: (e3) => on }, controller: (e3) => {
      const t3 = e3.document, n2 = e3.value, r2 = e3.constraint, i2 = r2 && Ze(r2, et);
      return i2 ? new st(t3, { props: new T({ options: i2.values.value("options") }), value: n2, viewProps: e3.viewProps }) : new pt(t3, { parser: (e4) => e4, props: T.fromObject({ formatter: Ft }), value: n2, viewProps: e3.viewProps });
    } }, yi = { monitor: { defaultInterval: 200, defaultLineCount: 3 } }, bi = _("mll");
    class wi {
      constructor(e3, t3) {
        this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = t3.formatter, this.element = e3.createElement("div"), this.element.classList.add(bi()), t3.viewProps.bindClassModifiers(this.element);
        const n2 = e3.createElement("textarea");
        n2.classList.add(bi("i")), n2.style.height = `calc(var(--bld-us) * ${t3.lineCount})`, n2.readOnly = true, t3.viewProps.bindDisabled(n2), this.element.appendChild(n2), this.textareaElem_ = n2, t3.value.emitter.on("change", this.onValueUpdate_), this.value = t3.value, this.update_();
      }
      update_() {
        const e3 = this.textareaElem_, t3 = e3.scrollTop === e3.scrollHeight - e3.clientHeight, n2 = [];
        this.value.rawValue.forEach((e4) => {
          void 0 !== e4 && n2.push(this.formatter_(e4));
        }), e3.textContent = n2.join("\n"), t3 && (e3.scrollTop = e3.scrollHeight);
      }
      onValueUpdate_() {
        this.update_();
      }
    }
    class Ai {
      constructor(e3, t3) {
        this.value = t3.value, this.viewProps = t3.viewProps, this.view = new wi(e3, { formatter: t3.formatter, lineCount: t3.lineCount, value: this.value, viewProps: this.viewProps });
      }
    }
    const xi = _("sgl");
    class Ei {
      constructor(e3, t3) {
        this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = t3.formatter, this.element = e3.createElement("div"), this.element.classList.add(xi()), t3.viewProps.bindClassModifiers(this.element);
        const n2 = e3.createElement("input");
        n2.classList.add(xi("i")), n2.readOnly = true, n2.type = "text", t3.viewProps.bindDisabled(n2), this.element.appendChild(n2), this.inputElement = n2, t3.value.emitter.on("change", this.onValueUpdate_), this.value = t3.value, this.update_();
      }
      update_() {
        const e3 = this.value.rawValue, t3 = e3[e3.length - 1];
        this.inputElement.value = void 0 !== t3 ? this.formatter_(t3) : "";
      }
      onValueUpdate_() {
        this.update_();
      }
    }
    class Ci {
      constructor(e3, t3) {
        this.value = t3.value, this.viewProps = t3.viewProps, this.view = new Ei(e3, { formatter: t3.formatter, value: this.value, viewProps: this.viewProps });
      }
    }
    const Si = { id: "monitor-bool", type: "monitor", accept: (e3, t3) => {
      if ("boolean" != typeof e3)
        return null;
      const n2 = k(t3, { lineCount: R.optional.number });
      return n2 ? { initialValue: e3, params: n2 } : null;
    }, binding: { reader: (e3) => dt }, controller: (e3) => {
      var t3;
      return 1 === e3.value.rawValue.length ? new Ci(e3.document, { formatter: ht, value: e3.value, viewProps: e3.viewProps }) : new Ai(e3.document, { formatter: ht, lineCount: null !== (t3 = e3.params.lineCount) && void 0 !== t3 ? t3 : yi.monitor.defaultLineCount, value: e3.value, viewProps: e3.viewProps });
    } }, Mi = _("grl");
    class Ti {
      constructor(e3, t3) {
        this.onCursorChange_ = this.onCursorChange_.bind(this), this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.element = e3.createElement("div"), this.element.classList.add(Mi()), t3.viewProps.bindClassModifiers(this.element), this.formatter_ = t3.formatter, this.props_ = t3.props, this.cursor_ = t3.cursor, this.cursor_.emitter.on("change", this.onCursorChange_);
        const n2 = e3.createElementNS(z, "svg");
        n2.classList.add(Mi("g")), n2.style.height = `calc(var(--bld-us) * ${t3.lineCount})`, this.element.appendChild(n2), this.svgElem_ = n2;
        const r2 = e3.createElementNS(z, "polyline");
        this.svgElem_.appendChild(r2), this.lineElem_ = r2;
        const i2 = e3.createElement("div");
        i2.classList.add(Mi("t"), _("tt")()), this.element.appendChild(i2), this.tooltipElem_ = i2, t3.value.emitter.on("change", this.onValueUpdate_), this.value = t3.value, this.update_();
      }
      get graphElement() {
        return this.svgElem_;
      }
      update_() {
        const e3 = this.svgElem_.getBoundingClientRect(), t3 = this.value.rawValue.length - 1, n2 = this.props_.get("minValue"), r2 = this.props_.get("maxValue"), i2 = [];
        this.value.rawValue.forEach((s3, o3) => {
          if (void 0 === s3)
            return;
          const a3 = Wt(o3, 0, t3, 0, e3.width), l3 = Wt(s3, n2, r2, e3.height, 0);
          i2.push([a3, l3].join(","));
        }), this.lineElem_.setAttributeNS(null, "points", i2.join(" "));
        const s2 = this.tooltipElem_, o2 = this.value.rawValue[this.cursor_.rawValue];
        if (void 0 === o2)
          return void s2.classList.remove(Mi("t", "a"));
        const a2 = Wt(this.cursor_.rawValue, 0, t3, 0, e3.width), l2 = Wt(o2, n2, r2, e3.height, 0);
        s2.style.left = `${a2}px`, s2.style.top = `${l2}px`, s2.textContent = `${this.formatter_(o2)}`, s2.classList.contains(Mi("t", "a")) || (s2.classList.add(Mi("t", "a"), Mi("t", "in")), G(s2), s2.classList.remove(Mi("t", "in")));
      }
      onValueUpdate_() {
        this.update_();
      }
      onCursorChange_() {
        this.update_();
      }
    }
    class Pi {
      constructor(e3, t3) {
        if (this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this), this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this), this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this), this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this), this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this), this.props_ = t3.props, this.value = t3.value, this.viewProps = t3.viewProps, this.cursor_ = M(-1), this.view = new Ti(e3, { cursor: this.cursor_, formatter: t3.formatter, lineCount: t3.lineCount, props: this.props_, value: this.value, viewProps: this.viewProps }), V(e3)) {
          const e4 = new Qt(this.view.element);
          e4.emitter.on("down", this.onGraphPointerDown_), e4.emitter.on("move", this.onGraphPointerMove_), e4.emitter.on("up", this.onGraphPointerUp_);
        } else
          this.view.element.addEventListener("mousemove", this.onGraphMouseMove_), this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
      }
      onGraphMouseLeave_() {
        this.cursor_.rawValue = -1;
      }
      onGraphMouseMove_(e3) {
        const t3 = this.view.element.getBoundingClientRect();
        this.cursor_.rawValue = Math.floor(Wt(e3.offsetX, 0, t3.width, 0, this.value.rawValue.length));
      }
      onGraphPointerDown_(e3) {
        this.onGraphPointerMove_(e3);
      }
      onGraphPointerMove_(e3) {
        e3.data.point ? this.cursor_.rawValue = Math.floor(Wt(e3.data.point.x, 0, e3.data.bounds.width, 0, this.value.rawValue.length)) : this.cursor_.rawValue = -1;
      }
      onGraphPointerUp_() {
        this.cursor_.rawValue = -1;
      }
    }
    function Ii(e3) {
      return "format" in e3 && !a(e3.format) ? e3.format : Bt(2);
    }
    function Ri(e3) {
      return "view" in e3 && "graph" === e3.view;
    }
    const ki = { id: "monitor-number", type: "monitor", accept: (e3, t3) => {
      if ("number" != typeof e3)
        return null;
      const n2 = R, r2 = k(t3, { format: n2.optional.function, lineCount: n2.optional.number, max: n2.optional.number, min: n2.optional.number, view: n2.optional.string });
      return r2 ? { initialValue: e3, params: r2 } : null;
    }, binding: { defaultBufferSize: (e3) => Ri(e3) ? 64 : 1, reader: (e3) => kt }, controller: (e3) => Ri(e3.params) ? function(e4) {
      var t3, n2, r2;
      return new Pi(e4.document, { formatter: Ii(e4.params), lineCount: null !== (t3 = e4.params.lineCount) && void 0 !== t3 ? t3 : yi.monitor.defaultLineCount, props: T.fromObject({ maxValue: null !== (n2 = "max" in e4.params ? e4.params.max : null) && void 0 !== n2 ? n2 : 100, minValue: null !== (r2 = "min" in e4.params ? e4.params.min : null) && void 0 !== r2 ? r2 : 0 }), value: e4.value, viewProps: e4.viewProps });
    }(e3) : function(e4) {
      var t3;
      return 1 === e4.value.rawValue.length ? new Ci(e4.document, { formatter: Ii(e4.params), value: e4.value, viewProps: e4.viewProps }) : new Ai(e4.document, { formatter: Ii(e4.params), lineCount: null !== (t3 = e4.params.lineCount) && void 0 !== t3 ? t3 : yi.monitor.defaultLineCount, value: e4.value, viewProps: e4.viewProps });
    }(e3) }, Di = { id: "monitor-string", type: "monitor", accept: (e3, t3) => {
      if ("string" != typeof e3)
        return null;
      const n2 = R, r2 = k(t3, { lineCount: n2.optional.number, multiline: n2.optional.boolean });
      return r2 ? { initialValue: e3, params: r2 } : null;
    }, binding: { reader: (e3) => Ut }, controller: (e3) => {
      var t3;
      const n2 = e3.value;
      return n2.rawValue.length > 1 || "multiline" in e3.params && e3.params.multiline ? new Ai(e3.document, { formatter: Ft, lineCount: null !== (t3 = e3.params.lineCount) && void 0 !== t3 ? t3 : yi.monitor.defaultLineCount, value: n2, viewProps: e3.viewProps }) : new Ci(e3.document, { formatter: Ft, value: n2, viewProps: e3.viewProps });
    } };
    function Bi(e3, t3) {
      return 0 === t3 ? new He() : new Qe(e3, null != t3 ? t3 : yi.monitor.defaultInterval);
    }
    class Oi {
      constructor() {
        this.pluginsMap_ = { blades: [], inputs: [], monitors: [] };
      }
      getAll() {
        return [...this.pluginsMap_.blades, ...this.pluginsMap_.inputs, ...this.pluginsMap_.monitors];
      }
      register(e3) {
        "blade" === e3.type ? this.pluginsMap_.blades.unshift(e3) : "input" === e3.type ? this.pluginsMap_.inputs.unshift(e3) : "monitor" === e3.type && this.pluginsMap_.monitors.unshift(e3);
      }
      createInput(e3, t3, n2) {
        if (a(t3.read()))
          throw new p({ context: { key: t3.key }, type: "nomatchingcontroller" });
        const r2 = this.pluginsMap_.inputs.reduce((r3, i2) => null != r3 ? r3 : function(e4, t4) {
          const n3 = e4.accept(t4.target.read(), t4.params);
          if (a(n3))
            return null;
          const r4 = R, i3 = { target: t4.target, initialValue: n3.initialValue, params: n3.params }, s2 = e4.binding.reader(i3), o2 = e4.binding.constraint ? e4.binding.constraint(i3) : void 0, l2 = M(s2(n3.initialValue), { constraint: o2, equals: e4.binding.equals }), c2 = new We({ reader: s2, target: t4.target, value: l2, writer: e4.binding.writer(i3) }), u2 = r4.optional.boolean(t4.params.disabled).value, p2 = r4.optional.boolean(t4.params.hidden).value, d2 = e4.controller({ constraint: o2, document: t4.document, initialValue: n3.initialValue, params: n3.params, value: c2.value, viewProps: U.create({ disabled: u2, hidden: p2 }) }), h2 = r4.optional.string(t4.params.label).value;
          return new ce(t4.document, { binding: c2, blade: ne(), props: T.fromObject({ label: null != h2 ? h2 : t4.target.key }), valueController: d2 });
        }(i2, { document: e3, target: t3, params: n2 }), null);
        if (r2)
          return r2;
        throw new p({ context: { key: t3.key }, type: "nomatchingcontroller" });
      }
      createMonitor(e3, t3, n2) {
        const r2 = this.pluginsMap_.monitors.reduce((r3, i2) => null != r3 ? r3 : function(e4, t4) {
          var n3, r4, i3;
          const s2 = R, o2 = e4.accept(t4.target.read(), t4.params);
          if (a(o2))
            return null;
          const l2 = { target: t4.target, initialValue: o2.initialValue, params: o2.params }, c2 = e4.binding.reader(l2), u2 = null !== (r4 = null !== (n3 = s2.optional.number(t4.params.bufferSize).value) && void 0 !== n3 ? n3 : e4.binding.defaultBufferSize && e4.binding.defaultBufferSize(o2.params)) && void 0 !== r4 ? r4 : 1, p2 = s2.optional.number(t4.params.interval).value, d2 = new Ke({ reader: c2, target: t4.target, ticker: Bi(t4.document, p2), value: Xe(u2) }), h2 = s2.optional.boolean(t4.params.disabled).value, f2 = s2.optional.boolean(t4.params.hidden).value, m2 = e4.controller({ document: t4.document, params: o2.params, value: d2.value, viewProps: U.create({ disabled: h2, hidden: f2 }) }), _2 = null !== (i3 = s2.optional.string(t4.params.label).value) && void 0 !== i3 ? i3 : t4.target.key;
          return new pe(t4.document, { binding: d2, blade: ne(), props: T.fromObject({ label: _2 }), valueController: m2 });
        }(i2, { document: e3, params: n2, target: t3 }), null);
        if (r2)
          return r2;
        throw new p({ context: { key: t3.key }, type: "nomatchingcontroller" });
      }
      createBlade(e3, t3) {
        const n2 = this.pluginsMap_.blades.reduce((n3, r2) => null != n3 ? n3 : function(e4, t4) {
          const n4 = e4.accept(t4.params);
          if (!n4)
            return null;
          const r3 = R.optional.boolean(t4.params.disabled).value, i2 = R.optional.boolean(t4.params.hidden).value;
          return e4.controller({ blade: ne(), document: t4.document, params: Object.assign(Object.assign({}, n4.params), { disabled: r3, hidden: i2 }), viewProps: U.create({ disabled: r3, hidden: i2 }) });
        }(r2, { document: e3, params: t3 }), null);
        if (!n2)
          throw new p({ type: "nomatchingview", context: { params: t3 } });
        return n2;
      }
      createBladeApi(e3) {
        if (e3 instanceof ce)
          return new le(e3);
        if (e3 instanceof pe)
          return new ue(e3);
        if (e3 instanceof Ae)
          return new me(e3, this);
        const t3 = this.pluginsMap_.blades.reduce((t4, n2) => null != t4 ? t4 : n2.api({ controller: e3, pool: this }), null);
        if (!t3)
          throw p.shouldNeverHappen();
        return t3;
      }
    }
    function Li(e3) {
      return Zr.isObject(e3) ? new Zr(e3.x, e3.y) : new Zr();
    }
    function Ui(e3, t3) {
      e3.writeProperty("x", t3.x), e3.writeProperty("y", t3.y);
    }
    function Fi(e3, t3) {
      if (!e3)
        return;
      const n2 = [], r2 = Yr(e3, t3);
      r2 && n2.push(r2);
      const i2 = Kr(e3);
      return i2 && n2.push(i2), new Je(n2);
    }
    function Ni(e3, t3) {
      const [n2, r2] = e3 ? function(e4) {
        const t4 = Ze(e4, $e);
        if (t4)
          return [t4.values.get("min"), t4.values.get("max")];
        const n3 = Ze(e4, tt);
        return n3 ? [n3.minValue, n3.maxValue] : [void 0, void 0];
      }(e3) : [];
      if (!a(n2) || !a(r2))
        return Math.max(Math.abs(null != n2 ? n2 : 0), Math.abs(null != r2 ? r2 : 0));
      const i2 = hn(e3);
      return Math.max(10 * Math.abs(i2), 10 * Math.abs(t3));
    }
    function ji(e3, t3) {
      const n2 = t3 instanceof Qr ? t3.components[0] : void 0, r2 = t3 instanceof Qr ? t3.components[1] : void 0, i2 = Ni(n2, e3.x), s2 = Ni(r2, e3.y);
      return Math.max(i2, s2);
    }
    function zi(e3, t3) {
      return { baseStep: hn(t3), constraint: t3, textProps: T.fromObject({ draggingScale: fn(t3, e3), formatter: Bt(dn(t3, e3)) }) };
    }
    function Gi(e3) {
      if (!("y" in e3))
        return false;
      const t3 = e3.y;
      return !!t3 && "inverted" in t3 && !!t3.inverted;
    }
    const Vi = { id: "input-point2d", type: "input", accept: (e3, t3) => {
      if (!Zr.isObject(e3))
        return null;
      const n2 = R, r2 = k(t3, { expanded: n2.optional.boolean, picker: n2.optional.custom(ln), x: n2.optional.custom(cn), y: n2.optional.object({ inverted: n2.optional.boolean, max: n2.optional.number, min: n2.optional.number, step: n2.optional.number }) });
      return r2 ? { initialValue: e3, params: r2 } : null;
    }, binding: { reader: (e3) => Li, constraint: (e3) => {
      return t3 = e3.params, n2 = e3.initialValue, new Qr({ assembly: $r, components: [Fi("x" in t3 ? t3.x : void 0, n2.x), Fi("y" in t3 ? t3.y : void 0, n2.y)] });
      var t3, n2;
    }, equals: Zr.equals, writer: (e3) => Ui }, controller: (e3) => {
      const t3 = e3.document, n2 = e3.value, r2 = e3.constraint;
      if (!(r2 instanceof Qr))
        throw p.shouldNeverHappen();
      const i2 = "expanded" in e3.params ? e3.params.expanded : void 0, s2 = "picker" in e3.params ? e3.params.picker : void 0;
      return new oi(t3, { axes: [zi(n2.rawValue.x, r2.components[0]), zi(n2.rawValue.y, r2.components[1])], expanded: null != i2 && i2, invertsY: Gi(e3.params), maxValue: ji(n2.rawValue, r2), parser: Rt, pickerLayout: null != s2 ? s2 : "popup", value: n2, viewProps: e3.viewProps });
    } };
    class Hi extends t2 {
      constructor(e3) {
        super(e3), this.emitter_ = new f(), this.controller_.valueController.value.emitter.on("change", (e4) => {
          this.emitter_.emit("change", { event: new r(this, e4.rawValue) });
        });
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(e3) {
        this.controller_.props.set("label", e3);
      }
      get options() {
        return this.controller_.valueController.props.get("options");
      }
      set options(e3) {
        this.controller_.valueController.props.set("options", e3);
      }
      get value() {
        return this.controller_.valueController.value.rawValue;
      }
      set value(e3) {
        this.controller_.valueController.value.rawValue = e3;
      }
      on(e3, t3) {
        const n2 = t3.bind(this);
        return this.emitter_.on(e3, (e4) => {
          n2(e4.event);
        }), this;
      }
    }
    class Qi extends t2 {
      constructor(e3) {
        super(e3), this.emitter_ = new f(), this.controller_.valueController.value.emitter.on("change", (e4) => {
          this.emitter_.emit("change", { event: new r(this, e4.rawValue) });
        });
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(e3) {
        this.controller_.props.set("label", e3);
      }
      get maxValue() {
        return this.controller_.valueController.sliderController.props.get("maxValue");
      }
      set maxValue(e3) {
        this.controller_.valueController.sliderController.props.set("maxValue", e3);
      }
      get minValue() {
        return this.controller_.valueController.sliderController.props.get("minValue");
      }
      set minValue(e3) {
        this.controller_.valueController.sliderController.props.set("minValue", e3);
      }
      get value() {
        return this.controller_.valueController.value.rawValue;
      }
      set value(e3) {
        this.controller_.valueController.value.rawValue = e3;
      }
      on(e3, t3) {
        const n2 = t3.bind(this);
        return this.emitter_.on(e3, (e4) => {
          n2(e4.event);
        }), this;
      }
    }
    class Wi extends t2 {
      constructor(e3) {
        super(e3), this.emitter_ = new f(), this.controller_.valueController.value.emitter.on("change", (e4) => {
          this.emitter_.emit("change", { event: new r(this, e4.rawValue) });
        });
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(e3) {
        this.controller_.props.set("label", e3);
      }
      get formatter() {
        return this.controller_.valueController.props.get("formatter");
      }
      set formatter(e3) {
        this.controller_.valueController.props.set("formatter", e3);
      }
      get value() {
        return this.controller_.valueController.value.rawValue;
      }
      set value(e3) {
        this.controller_.valueController.value.rawValue = e3;
      }
      on(e3, t3) {
        const n2 = t3.bind(this);
        return this.emitter_.on(e3, (e4) => {
          n2(e4.event);
        }), this;
      }
    }
    const qi = { id: "list", type: "blade", accept(e3) {
      const t3 = R, n2 = k(e3, { options: t3.required.custom(an), value: t3.required.raw, view: t3.required.constant("list"), label: t3.optional.string });
      return n2 ? { params: n2 } : null;
    }, controller(e3) {
      const t3 = new et(un(e3.params.options)), n2 = M(e3.params.value, { constraint: t3 }), r2 = new st(e3.document, { props: new T({ options: t3.values.value("options") }), value: n2, viewProps: e3.viewProps });
      return new Me(e3.document, { blade: e3.blade, props: T.fromObject({ label: e3.params.label }), valueController: r2 });
    }, api(e3) {
      return e3.controller instanceof Me && e3.controller.valueController instanceof st ? new Hi(e3.controller) : null;
    } };
    class Xi extends _e {
      constructor(e3, t3) {
        super(e3, t3);
      }
      get element() {
        return this.controller_.view.element;
      }
      importPreset(e3) {
        (function(e4, t3) {
          e4.forEach((e5) => {
            const n2 = t3[e5.target.presetKey];
            void 0 !== n2 && e5.writer(e5.target, e5.reader(n2));
          });
        })(this.controller_.rackController.rack.find(ce).map((e4) => e4.binding), e3), this.refresh();
      }
      exportPreset() {
        return this.controller_.rackController.rack.find(ce).map((e3) => e3.binding.target).reduce((e3, t3) => Object.assign(e3, { [t3.presetKey]: t3.read() }), {});
      }
      refresh() {
        this.controller_.rackController.rack.find(ce).forEach((e3) => {
          e3.binding.read();
        }), this.controller_.rackController.rack.find(pe).forEach((e3) => {
          e3.binding.read();
        });
      }
    }
    class Yi extends Ce {
      constructor(e3, t3) {
        super(e3, { expanded: t3.expanded, blade: t3.blade, props: t3.props, root: true, viewProps: t3.viewProps });
      }
    }
    const Ki = { id: "slider", type: "blade", accept(e3) {
      const t3 = R, n2 = k(e3, { max: t3.required.number, min: t3.required.number, view: t3.required.constant("slider"), format: t3.optional.function, label: t3.optional.string, value: t3.optional.number });
      return n2 ? { params: n2 } : null;
    }, controller(e3) {
      var t3, n2;
      const r2 = null !== (t3 = e3.params.value) && void 0 !== t3 ? t3 : 0, i2 = new $e({ max: e3.params.max, min: e3.params.min }), s2 = new sn(e3.document, { baseStep: 1, parser: Rt, sliderProps: new T({ maxValue: i2.values.value("max"), minValue: i2.values.value("min") }), textProps: T.fromObject({ draggingScale: fn(void 0, r2), formatter: null !== (n2 = e3.params.format) && void 0 !== n2 ? n2 : Dt }), value: M(r2, { constraint: i2 }), viewProps: e3.viewProps });
      return new Me(e3.document, { blade: e3.blade, props: T.fromObject({ label: e3.params.label }), valueController: s2 });
    }, api(e3) {
      return e3.controller instanceof Me && e3.controller.valueController instanceof sn ? new Qi(e3.controller) : null;
    } }, Ji = { id: "text", type: "blade", accept(e3) {
      const t3 = R, n2 = k(e3, { parse: t3.required.function, value: t3.required.raw, view: t3.required.constant("text"), format: t3.optional.function, label: t3.optional.string });
      return n2 ? { params: n2 } : null;
    }, controller(e3) {
      var t3;
      const n2 = new pt(e3.document, { parser: e3.params.parse, props: T.fromObject({ formatter: null !== (t3 = e3.params.format) && void 0 !== t3 ? t3 : (e4) => String(e4) }), value: M(e3.params.value), viewProps: e3.viewProps });
      return new Me(e3.document, { blade: e3.blade, props: T.fromObject({ label: e3.params.label }), valueController: n2 });
    }, api(e3) {
      return e3.controller instanceof Me && e3.controller.valueController instanceof pt ? new Wi(e3.controller) : null;
    } };
    function Zi(e3, t3, n2) {
      if (e3.querySelector(`style[data-tp-style=${t3}]`))
        return;
      const r2 = e3.createElement("style");
      r2.dataset.tpStyle = t3, r2.textContent = n2, e3.head.appendChild(r2);
    }
    const $i = new class {
      constructor(e3) {
        const [t3, n2] = e3.split("-"), r2 = t3.split(".");
        this.major = parseInt(r2[0], 10), this.minor = parseInt(r2[1], 10), this.patch = parseInt(r2[2], 10), this.prerelease = null != n2 ? n2 : null;
      }
      toString() {
        const e3 = [this.major, this.minor, this.patch].join(".");
        return null !== this.prerelease ? [e3, this.prerelease].join("-") : e3;
      }
    }("3.1.6");
    e2.BladeApi = t2, e2.ButtonApi = h, e2.FolderApi = _e, e2.InputBindingApi = le, e2.ListApi = Hi, e2.MonitorBindingApi = ue, e2.Pane = class extends Xi {
      constructor(e3) {
        var t3, n2;
        const r2 = null != e3 ? e3 : {}, i2 = null !== (t3 = r2.document) && void 0 !== t3 ? t3 : H(), s2 = function() {
          const e4 = new Oi();
          return [Vi, di, gi, vi, Jr, Hr, Vr, jr, vn, Si, Di, ki, ee, Se, ke, Ve].forEach((t4) => {
            e4.register(t4);
          }), e4;
        }();
        super(new Yi(i2, { expanded: r2.expanded, blade: ne(), props: T.fromObject({ title: r2.title }), viewProps: U.create() }), s2), this.pool_ = s2, this.containerElem_ = null !== (n2 = r2.container) && void 0 !== n2 ? n2 : function(e4) {
          const t4 = e4.createElement("div");
          return t4.classList.add(_("dfw")()), e4.body && e4.body.appendChild(t4), t4;
        }(i2), this.containerElem_.appendChild(this.element), this.doc_ = i2, this.usesDefaultWrapper_ = !r2.container, this.setUpDefaultPlugins_();
      }
      get document() {
        if (!this.doc_)
          throw p.alreadyDisposed();
        return this.doc_;
      }
      dispose() {
        const e3 = this.containerElem_;
        if (!e3)
          throw p.alreadyDisposed();
        if (this.usesDefaultWrapper_) {
          const t3 = e3.parentElement;
          t3 && t3.removeChild(e3);
        }
        this.containerElem_ = null, this.doc_ = null, super.dispose();
      }
      registerPlugin(e3) {
        ("plugin" in e3 ? [e3.plugin] : "plugins" in e3 ? e3.plugins : []).forEach((e4) => {
          this.pool_.register(e4), this.embedPluginStyle_(e4);
        });
      }
      embedPluginStyle_(e3) {
        e3.css && Zi(this.document, `plugin-${e3.id}`, e3.css);
      }
      setUpDefaultPlugins_() {
        Zi(this.document, "default", '.tp-tbiv_b,.tp-coltxtv_ms,.tp-ckbv_i,.tp-rotv_b,.tp-fldv_b,.tp-mllv_i,.tp-sglv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-mllv_i,.tp-sglv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--mo-fg);height:var(--bld-us);scrollbar-color:currentColor rgba(0,0,0,0);scrollbar-width:thin;width:100%}.tp-mllv_i::-webkit-scrollbar,.tp-sglv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-mllv_i::-webkit-scrollbar-corner,.tp-sglv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:rgba(0,0,0,0)}.tp-mllv_i::-webkit-scrollbar-thumb,.tp-sglv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:rgba(0,0,0,0) solid 2px;border-radius:4px}.tp-rotv{--font-family: var(--tp-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-br: var(--tp-base-border-radius, 6px);--cnt-h-p: var(--tp-container-horizontal-padding, 4px);--cnt-v-p: var(--tp-container-vertical-padding, 4px);--elm-br: var(--tp-element-border-radius, 2px);--bld-s: var(--tp-blade-spacing, 4px);--bld-us: var(--tp-blade-unit-size, 20px);--bs-bg: var(--tp-base-background-color, hsl(230, 7%, 17%));--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--btn-bg: var(--tp-button-background-color, hsl(230, 7%, 70%));--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, hsl(230, 7%, 17%));--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, hsl(230, 7%, 75%));--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, hsl(230, 7%, 75%));--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tabv_c .tp-brkv>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-v-p))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tabv_c .tp-brkv>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--bld-s)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tabv_c .tp-brkv>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tabv_c .tp-brkv>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--elm-br);border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tabv_c .tp-brkv .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-cntv+.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-cntv+.tp-fldv>.tp-fldv_b{border-top-left-radius:0}.tp-tabv_c .tp-brkv>.tp-cntv+.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-cntv+.tp-tabv>.tp-tabv_t{border-top-left-radius:0}.tp-tabv_c .tp-brkv>.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-tabv>.tp-tabv_t{border-top-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--elm-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);overflow:hidden;padding-left:var(--cnt-h-p);padding-right:calc(4px + var(--bld-us) + var(--cnt-h-p));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(var(--cnt-h-p) + (var(--bld-us) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--elm-br);cursor:pointer;display:block;height:var(--bld-us);position:relative;width:var(--bld-us)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--bld-us)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--bld-s);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--bld-s)}.tp-colpv_rgb{display:flex;margin-top:var(--bld-s);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-v-p);padding-top:calc(var(--cnt-v-p) + 2px);position:relative}.tp-colpv_a::before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:0}.tp-colpv.tp-v-disabled .tp-colpv_a::before{opacity:.5}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--elm-br);outline:none;overflow:hidden;position:relative}.tp-svpv.tp-v-disabled{opacity:.5}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--bld-us)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative}.tp-hplv.tp-v-disabled{opacity:.5}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative;width:100%}.tp-aplv.tp-v-disabled{opacity:.5}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--elm-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--elm-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;cursor:pointer;display:block;height:var(--bld-us);left:0;margin:0;outline:none;padding:0;position:absolute;top:0;width:var(--bld-us)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--elm-br);bottom:0;content:"";display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--elm-br);color:var(--lbl-fg);cursor:pointer;height:var(--bld-us);line-height:var(--bld-us);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv.tp-v-disabled .tp-coltxtv_mm{opacity:.5}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv{position:relative}.tp-fldv.tp-fldv-not .tp-fldv_b{display:none}.tp-fldv_t{padding-left:4px}.tp-fldv_b:disabled .tp-fldv_m{display:none}.tp-fldv_c{padding-left:4px}.tp-fldv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--bld-us) + 4px);width:var(--bs-br)}.tp-fldv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-fldv_b:hover+.tp-fldv_i{color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_i{color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_i{color:var(--cnt-bg-a)}.tp-fldv.tp-v-disabled>.tp-fldv_i{opacity:.5}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--bld-us)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:160px}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding:0 4px}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--bld-us)*3);line-height:var(--bld-us);padding:0 4px;resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--bld-us);margin-right:4px;position:relative;width:var(--bld-us)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--bld-s);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-p2dpv{padding-left:calc(var(--bld-us) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv.tp-v-disabled .tp-p2dpv_p{opacity:.5}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:6px;box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:168px;padding:var(--cnt-v-p) var(--cnt-h-p);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sprv.tp-v-disabled .tp-sprv_r{opacity:.5}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--bld-us);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--elm-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv{position:relative}.tp-tabv_t{align-items:flex-end;color:var(--cnt-bg);display:flex;overflow:hidden;position:relative}.tp-tabv_t:hover{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus){color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active){color:var(--cnt-bg-a)}.tp-tabv_t::before{background-color:currentColor;bottom:0;content:"";height:2px;left:0;pointer-events:none;position:absolute;right:0}.tp-tabv.tp-v-disabled .tp-tabv_t::before{opacity:.5}.tp-tabv.tp-tabv-nop .tp-tabv_t{height:calc(var(--bld-us) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_t::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_c{padding-bottom:var(--cnt-v-p);padding-left:4px;padding-top:var(--cnt-v-p)}.tp-tabv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--bld-us) + 4px);width:var(--bs-br)}.tp-tabv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-tabv_t:hover+.tp-tabv_i{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus)+.tp-tabv_i{color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active)+.tp-tabv_i{color:var(--cnt-bg-a)}.tp-tabv.tp-v-disabled>.tp-tabv_i{opacity:.5}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv.tp-v-disabled::before{opacity:.5}.tp-tbiv_b{display:block;padding-left:calc(var(--cnt-h-p) + 4px);padding-right:calc(var(--cnt-h-p) + 4px);position:relative;width:100%}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_b::before{background-color:var(--cnt-bg);bottom:2px;content:"";left:0;pointer-events:none;position:absolute;right:0;top:0}.tp-tbiv_b:hover::before{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus::before{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active::before{background-color:var(--cnt-bg-a)}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);opacity:.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-txtv{position:relative}.tp-txtv_i{padding:0 4px}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:-3px;position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--bld-us) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--elm-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) rgba(0,0,0,0) rgba(0,0,0,0) rgba(0,0,0,0);border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--font-family);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--bld-us) + var(--cnt-h-p));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0}.tp-rotv.tp-rotv-not .tp-rotv_b{display:none}.tp-rotv_b:disabled .tp-rotv_m{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_t{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}'), this.pool_.getAll().forEach((e3) => {
          this.embedPluginStyle_(e3);
        }), this.registerPlugin({ plugins: [Ki, qi, Ve, Ji] });
      }
    }, e2.SeparatorApi = Te, e2.SliderApi = Qi, e2.TabApi = Fe, e2.TabPageApi = Ue, e2.TextApi = Wi, e2.TpChangeEvent = r, e2.VERSION = $i, Object.defineProperty(e2, "__esModule", { value: true });
  }(t);
}, 23: function(__unused_webpack_module, __webpackgi_exports__, __webpackgi_require__) {
  __webpackgi_require__.d(__webpackgi_exports__, { Q: function() {
    return DRACOLoader2;
  } });
  var three_examples_jsm_loaders_DRACOLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpackgi_require__(553), three__WEBPACK_IMPORTED_MODULE_1__ = __webpackgi_require__(988);
  class DRACOLoader2 extends three_examples_jsm_loaders_DRACOLoader__WEBPACK_IMPORTED_MODULE_0__._ {
    constructor(e) {
      super(e), this.encoderPending = null, this.encoderConfig = { type: "js" }, this.setDecoderPath(DRACOLoader2.LIB_CDN_PATH), this.setDecoderConfig({ type: "js" });
    }
    transform(e, t) {
      return e ? new three__WEBPACK_IMPORTED_MODULE_1__.Kj0(e, new three__WEBPACK_IMPORTED_MODULE_1__.Wid()) : void 0;
    }
    preload(e = true, t = false) {
      return e && super.preload(), t && this.initEncoder(), this;
    }
    async initEncoder() {
      if (this.encoderPending)
        return this.encoderPending;
      const useJS = "object" != typeof WebAssembly || "js" === this.encoderConfig.type, librariesPending = [], libLoader = this._loadLibrary.bind(this);
      return useJS ? librariesPending.push(libLoader("draco_encoder.js", "text")) : (librariesPending.push(libLoader("draco_wasm_wrapper.js", "text")), librariesPending.push(libLoader("draco_encoder.wasm", "arraybuffer"))), this.encoderPending = Promise.all(librariesPending).then((libraries) => {
        var _a;
        const jsContent = libraries[0];
        return useJS || (this.encoderConfig.wasmBinary = libraries[1]), null === (_a = eval(jsContent + "\nDracoEncoderModule;")) || void 0 === _a ? void 0 : _a();
      }), this.encoderPending;
    }
    async initDecoder() {
      var _a;
      await this._initDecoder();
      const jsContent = await fetch(this.workerSourceURL).then(async (e) => e.text()).then((e) => {
        const t = e.indexOf("/* worker */");
        if (t < 1)
          throw new Error("unable to load decoder module");
        return e.substring(0, t - 1);
      });
      return null === (_a = eval(jsContent + "\nDracoDecoderModule;")) || void 0 === _a ? void 0 : _a();
    }
    async _loadLibrary(e, t) {
      return DRACOLoader2.LibraryValueMap[e] ? DRACOLoader2.LibraryValueMap[e] : DRACOLoader2.LibraryValueMap[e] = await super._loadLibrary(e, t);
    }
    static SetDecoderJsString(e) {
      this.LibraryValueMap["draco_decoder.js"] = e;
    }
  }
  DRACOLoader2.LIB_CDN_PATH = "https://cdn.jsdelivr.net/gh/google/draco@1.4.1/javascript/", DRACOLoader2.LibraryValueMap = {};
}, 988: function(e, t, n) {
  n.d(t, { $TI: function() {
    return Ph;
  }, $V: function() {
    return Bh;
  }, $Vf: function() {
    return Sf;
  }, $YQ: function() {
    return Bl;
  }, A5E: function() {
    return Ki;
  }, AXT: function() {
    return gu;
  }, Aip: function() {
    return Bf;
  }, B02: function() {
    return c;
  }, BFQ: function() {
    return Qe;
  }, BG$: function() {
    return ot;
  }, BKK: function() {
    return If;
  }, BVF: function() {
    return j;
  }, BVQ: function() {
    return Tu;
  }, BbS: function() {
    return ah;
  }, Bf4: function() {
    return ae;
  }, BtG: function() {
    return qs;
  }, CJI: function() {
    return Oi;
  }, CP7: function() {
    return Nl;
  }, CaW: function() {
    return Je;
  }, CdI: function() {
    return $;
  }, Cne: function() {
    return Lf;
  }, CtA: function() {
    return Ge;
  }, CtF: function() {
    return id;
  }, D1R: function() {
    return be;
  }, D67: function() {
    return cn;
  }, D9w: function() {
    return je;
  }, DT1: function() {
    return Cf;
  }, Djp: function() {
    return st;
  }, DqL: function() {
    return dd;
  }, DvJ: function() {
    return Us;
  }, E2K: function() {
    return Ve;
  }, EB7: function() {
    return nu;
  }, EJi: function() {
    return Ip;
  }, EoG: function() {
    return Z;
  }, F1y: function() {
    return un;
  }, F5T: function() {
    return Ui;
  }, FDw: function() {
    return we;
  }, FE5: function() {
    return Ap;
  }, FIo: function() {
    return Tp;
  }, FM8: function() {
    return Qn;
  }, FT0: function() {
    return Lp;
  }, FUD: function() {
    return dt;
  }, FvO: function() {
    return Gh;
  }, GG6: function() {
    return ut;
  }, GQ: function() {
    return df;
  }, GUF: function() {
    return Gt;
  }, GVz: function() {
    return gr;
  }, GZb: function() {
    return Tf;
  }, G_r: function() {
    return Ht;
  }, Gih: function() {
    return pt;
  }, Gql: function() {
    return jd;
  }, H$k: function() {
    return bp;
  }, HTd: function() {
    return fe;
  }, HW6: function() {
    return Df;
  }, HdW: function() {
    return _t;
  }, HgB: function() {
    return An;
  }, HkE: function() {
    return Il;
  }, Hmr: function() {
    return Wd;
  }, Hw6: function() {
    return ur;
  }, Hy8: function() {
    return L;
  }, Hyl: function() {
    return su;
  }, IEO: function() {
    return xc;
  }, IFH: function() {
    return Pt;
  }, IKL: function() {
    return kp;
  }, ILR: function() {
    return qe;
  }, IOt: function() {
    return Ft;
  }, Ilk: function() {
    return Vi;
  }, Ir4: function() {
    return wn;
  }, JCZ: function() {
    return Pn;
  }, JOQ: function() {
    return Zs;
  }, JQ4: function() {
    return Me;
  }, JUT: function() {
    return vr;
  }, JWc: function() {
    return yn;
  }, Jjb: function() {
    return fn;
  }, KI_: function() {
    return zt;
  }, Kgo: function() {
    return Du;
  }, KhW: function() {
    return R;
  }, Kj0: function() {
    return Os;
  }, Kz5: function() {
    return Se;
  }, L5g: function() {
    return Of;
  }, L5s: function() {
    return Fd;
  }, LBq: function() {
    return Oh;
  }, LSk: function() {
    return Sn;
  }, LY2: function() {
    return te;
  }, L_r: function() {
    return Mn;
  }, Lcc: function() {
    return Ff;
  }, LgZ: function() {
    return B;
  }, LsT: function() {
    return Ce;
  }, Ltg: function() {
    return fr;
  }, Lun: function() {
    return xl;
  }, M$G: function() {
    return pn;
  }, M5h: function() {
    return A;
  }, M6v: function() {
    return q;
  }, M8C: function() {
    return Hn;
  }, Mig: function() {
    return kd;
  }, MyG: function() {
    return $t;
  }, N$j: function() {
    return Ac;
  }, N4l: function() {
    return w;
  }, NDo: function() {
    return K;
  }, NMF: function() {
    return Et;
  }, NYV: function() {
    return at;
  }, Ns1: function() {
    return X;
  }, NwF: function() {
    return ed;
  }, Ny0: function() {
    return ou;
  }, O78: function() {
    return hn;
  }, O7d: function() {
    return hp;
  }, OAl: function() {
    return rn;
  }, OM3: function() {
    return cs;
  }, OTo: function() {
    return De;
  }, OdW: function() {
    return Sc;
  }, OoA: function() {
    return pe;
  }, Ox3: function() {
    return Rd;
  }, PA7: function() {
    return Nt;
  }, PMe: function() {
    return Ed;
  }, Pa4: function() {
    return Ar;
  }, PeU: function() {
    return o;
  }, Pnf: function() {
    return St;
  }, PpQ: function() {
    return lr;
  }, QM0: function() {
    return bn;
  }, QRU: function() {
    return Hd;
  }, QZ1: function() {
    return vn;
  }, QmN: function() {
    return s;
  }, Qpg: function() {
    return Zh;
  }, R2R: function() {
    return Kp;
  }, REq: function() {
    return Pf;
  }, RNb: function() {
    return es;
  }, ROQ: function() {
    return iu;
  }, RSm: function() {
    return Dp;
  }, Rki: function() {
    return lf;
  }, RlZ: function() {
    return N;
  }, RsA: function() {
    return i;
  }, RvT: function() {
    return sn;
  }, S2y: function() {
    return l;
  }, S3k: function() {
    return hd;
  }, S9g: function() {
    return ci;
  }, SJI: function() {
    return oh;
  }, SPe: function() {
    return Oc;
  }, SUY: function() {
    return eh;
  }, Se2: function() {
    return z;
  }, Sm8: function() {
    return T;
  }, So8: function() {
    return Xd;
  }, SvJ: function() {
    return ft;
  }, Syv: function() {
    return xt;
  }, T6w: function() {
    return mn;
  }, T95: function() {
    return xe;
  }, TOt: function() {
    return Fu;
  }, TUj: function() {
    return Uh;
  }, TUv: function() {
    return wc;
  }, T_1: function() {
    return yf;
  }, T_J: function() {
    return Jt;
  }, T__: function() {
    return au;
  }, T_f: function() {
    return Dd;
  }, TlE: function() {
    return $i;
  }, Tme: function() {
    return xi;
  }, Tn7: function() {
    return Mp;
  }, TyD: function() {
    return de;
  }, U7: function() {
    return bu;
  }, USm: function() {
    return li;
  }, UY4: function() {
    return qc;
  }, UZH: function() {
    return r;
  }, Uk6: function() {
    return Ep;
  }, UlW: function() {
    return kt;
  }, Uol: function() {
    return ku;
  }, V1s: function() {
    return Vs;
  }, V4E: function() {
    return kf;
  }, VLJ: function() {
    return $h;
  }, VYz: function() {
    return dh;
  }, Vdb: function() {
    return U;
  }, Vj0: function() {
    return ao;
  }, Vkp: function() {
    return Wn;
  }, VzW: function() {
    return Te;
  }, W2J: function() {
    return _n;
  }, WMw: function() {
    return b;
  }, WTc: function() {
    return ts;
  }, WXh: function() {
    return xp;
  }, Wbm: function() {
    return C;
  }, WdD: function() {
    return so;
  }, Wid: function() {
    return Pp;
  }, Wjw: function() {
    return Mf;
  }, Wl3: function() {
    return f;
  }, Wpd: function() {
    return F;
  }, Wqd: function() {
    return Cu;
  }, WwZ: function() {
    return Rt;
  }, Wzm: function() {
    return tu;
  }, XZw: function() {
    return Uf;
  }, Xaj: function() {
    return x;
  }, Xcj: function() {
    return Ch;
  }, XvJ: function() {
    return wp;
  }, Y8D: function() {
    return Oe;
  }, YBo: function() {
    return Bp;
  }, YGz: function() {
    return ee;
  }, YKA: function() {
    return wt;
  }, YLQ: function() {
    return he;
  }, YN5: function() {
    return wf;
  }, YT8: function() {
    return hu;
  }, Ywn: function() {
    return yr;
  }, Z6B: function() {
    return En;
  }, ZAu: function() {
    return Rl;
  }, ZQ6: function() {
    return wu;
  }, ZRs: function() {
    return Xt;
  }, ZTh: function() {
    return vt;
  }, ZZA: function() {
    return Vp;
  }, Z_g: function() {
    return ru;
  }, Zen: function() {
    return dn;
  }, Zp0: function() {
    return Ud;
  }, Zr5: function() {
    return G;
  }, ZzF: function() {
    return Cr;
  }, Zzh: function() {
    return jh;
  }, _12: function() {
    return io;
  }, _3: function() {
    return xf;
  }, _AM: function() {
    return Xe;
  }, _C8: function() {
    return Hp;
  }, _Li: function() {
    return m;
  }, _MY: function() {
    return u;
  }, _RZ: function() {
    return Tn;
  }, _YM: function() {
    return Yp;
  }, _YX: function() {
    return Wh;
  }, _am: function() {
    return Ws;
  }, _fP: function() {
    return wr;
  }, _iA: function() {
    return p;
  }, _kC: function() {
    return gd;
  }, _lf: function() {
    return Mt;
  }, _sL: function() {
    return Tt;
  }, a$l: function() {
    return ls;
  }, aCh: function() {
    return jt;
  }, aH4: function() {
    return me;
  }, aLr: function() {
    return Vr;
  }, aNw: function() {
    return ad;
  }, aVm: function() {
    return rs;
  }, ad5: function() {
    return Qt;
  }, anP: function() {
    return Co;
  }, aq0: function() {
    return ef;
  }, av9: function() {
    return ze;
  }, b5g: function() {
    return jl;
  }, bBp: function() {
    return xh;
  }, bGH: function() {
    return E;
  }, b_z: function() {
    return Ru;
  }, bdR: function() {
    return y;
  }, blk: function() {
    return Wc;
  }, bnF: function() {
    return Nu;
  }, brP: function() {
    return Fe;
  }, bsb: function() {
    return mt;
  }, c8b: function() {
    return P;
  }, cBI: function() {
    return sf;
  }, cBK: function() {
    return fd;
  }, cJO: function() {
    return mp;
  }, cLu: function() {
    return Pe;
  }, cPb: function() {
    return Hs;
  }, cRx: function() {
    return Le;
  }, cU9: function() {
    return qp;
  }, ce8: function() {
    return qt;
  }, cek: function() {
    return Pd;
  }, cum: function() {
    return an;
  }, dSO: function() {
    return oe;
  }, dUE: function() {
    return Jp;
  }, dYG: function() {
    return Qp;
  }, dZ3: function() {
    return ne;
  }, dd2: function() {
    return mr;
  }, dj0: function() {
    return gn;
  }, dpR: function() {
    return _d;
  }, dwk: function() {
    return h;
  }, e62: function() {
    return as;
  }, eD: function() {
    return H;
  }, eMJ: function() {
    return Zt;
  }, eaV: function() {
    return Ke;
  }, ehD: function() {
    return _;
  }, ejS: function() {
    return Qc;
  }, ekQ: function() {
    return et;
  }, epp: function() {
    return or;
  }, fHI: function() {
    return Iu;
  }, fO1: function() {
    return eu;
  }, fQA: function() {
    return pf;
  }, fQK: function() {
    return Pl;
  }, fSK: function() {
    return O;
  }, fY$: function() {
    return ie;
  }, fto: function() {
    return Ze;
  }, g8_: function() {
    return le;
  }, gH0: function() {
    return Th;
  }, gSk: function() {
    return It;
  }, g_z: function() {
    return yu;
  }, ghN: function() {
    return I;
  }, gi4: function() {
    return it;
  }, gti: function() {
    return xu;
  }, hEm: function() {
    return Ne;
  }, hH6: function() {
    return ud;
  }, iAb: function() {
    return Ee;
  }, iDF: function() {
    return up;
  }, iKG: function() {
    return _o;
  }, iLg: function() {
    return $p;
  }, iMs: function() {
    return Rh;
  }, iUV: function() {
    return wh;
  }, iWC: function() {
    return k;
  }, iWj: function() {
    return to;
  }, i_9: function() {
    return Yd;
  }, iiP: function() {
    return ht;
  }, irR: function() {
    return Re;
  }, j4z: function() {
    return on;
  }, j87: function() {
    return ss;
  }, jAl: function() {
    return bt;
  }, jFi: function() {
    return v;
  }, jZA: function() {
    return nt;
  }, jfJ: function() {
    return Yt;
  }, jwo: function() {
    return tn;
  }, jyi: function() {
    return ac;
  }, jyz: function() {
    return Gs;
  }, k0A: function() {
    return Ie;
  }, k74: function() {
    return D;
  }, kB5: function() {
    return Wl;
  }, kFz: function() {
    return br;
  }, kaV: function() {
    return Op;
  }, knz: function() {
    return Ot;
  }, kqm: function() {
    return hh;
  }, ksN: function() {
    return Q;
  }, l0P: function() {
    return $e;
  }, l8J: function() {
    return xn;
  }, lCJ: function() {
    return os;
  }, lDi: function() {
    return Bd;
  }, lGU: function() {
    return yt;
  }, lLk: function() {
    return sd;
  }, lRF: function() {
    return Al;
  }, lRj: function() {
    return ye;
  }, lb7: function() {
    return Mc;
  }, lfu: function() {
    return Wp;
  }, lk7: function() {
    return Od;
  }, m7l: function() {
    return nd;
  }, mSO: function() {
    return Ut;
  }, mTL: function() {
    return qd;
  }, mXe: function() {
    return Au;
  }, m_w: function() {
    return Ef;
  }, mzJ: function() {
    return Ah;
  }, nls: function() {
    return Lc;
  }, ntZ: function() {
    return d;
  }, ntt: function() {
    return Vt;
  }, nvb: function() {
    return bf;
  }, o8S: function() {
    return gp;
  }, oAp: function() {
    return Xs;
  }, oa8: function() {
    return vp;
  }, oqc: function() {
    return Kt;
  }, p3g: function() {
    return _r;
  }, p7y: function() {
    return Mu;
  }, pBf: function() {
    return In;
  }, pIN: function() {
    return Ct;
  }, pKu: function() {
    return ct;
  }, pQR: function() {
    return _p;
  }, ptH: function() {
    return tt;
  }, qhX: function() {
    return Y;
  }, qkB: function() {
    return Ue;
  }, qlB: function() {
    return is;
  }, qyh: function() {
    return ve;
  }, rAo: function() {
    return ns;
  }, rBU: function() {
    return oo;
  }, rDY: function() {
    return zs;
  }, rOj: function() {
    return S;
  }, r_: function() {
    return M;
  }, rnI: function() {
    return Bt;
  }, rpg: function() {
    return ce;
  }, s4_: function() {
    return Nd;
  }, sYA: function() {
    return pd;
  }, tEQ: function() {
    return od;
  }, tGC: function() {
    return gf;
  }, tJx: function() {
    return hf;
  }, tUh: function() {
    return Xp;
  }, tf: function() {
    return fh;
  }, tm_: function() {
    return a;
  }, trn: function() {
    return Af;
  }, u37: function() {
    return $d;
  }, u7G: function() {
    return Ld;
  }, u9r: function() {
    return gs;
  }, uEv: function() {
    return At;
  }, uL9: function() {
    return J;
  }, uWy: function() {
    return ue;
  }, uXU: function() {
    return en;
  }, ub3: function() {
    return g;
  }, ujx: function() {
    return Rf;
  }, v3W: function() {
    return We;
  }, v9Y: function() {
    return Cn;
  }, vBJ: function() {
    return Qi;
  }, vCF: function() {
    return V;
  }, vCx: function() {
    return Ye;
  }, vZf: function() {
    return _e;
  }, vmT: function() {
    return vd;
  }, vpT: function() {
    return Hl;
  }, vuL: function() {
    return gt;
  }, vxC: function() {
    return se;
  }, w$m: function() {
    return W;
  }, wJv: function() {
    return ke;
  }, wem: function() {
    return ge;
  }, wk1: function() {
    return Be;
  }, woe: function() {
    return Zc;
  }, wuA: function() {
    return He;
  }, x12: function() {
    return Gc;
  }, x5V: function() {
    return Wt;
  }, xEZ: function() {
    return hr;
  }, xG9: function() {
    return Xh;
  }, xJs: function() {
    return lt;
  }, xWb: function() {
    return Sh;
  }, xeV: function() {
    return ql;
  }, xfE: function() {
    return re;
  }, xo$: function() {
    return yp;
  }, xoQ: function() {
    return ln;
  }, xoR: function() {
    return Rp;
  }, xsS: function() {
    return Vl;
  }, y$t: function() {
    return Su;
  }, y2t: function() {
    return rt;
  }, y8_: function() {
    return vf;
  }, yC1: function() {
    return td;
  }, yGw: function() {
    return Zr;
  }, ybr: function() {
    return Gl;
  }, yj7: function() {
    return vu;
  }, ylh: function() {
    return Ih;
  }, yo9: function() {
    return zl;
  }, yt0: function() {
    return nn;
  }, ywz: function() {
    return Ae;
  }, yxD: function() {
    return md;
  }, z$h: function() {
    return Dt;
  }, z81: function() {
    return Lt;
  }, z8B: function() {
    return pc;
  }, zHn: function() {
    return Jr;
  }, zbs: function() {
    return Zp;
  }, zf8: function() {
    return Pu;
  } });
  const r = "153", i = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, s = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, o = 0, a = 1, l = 2, c = 3, u = 0, p = 1, d = 2, h = 3, f = 0, m = 1, _ = 2, g = 2, v = 0, y = 1, b = 2, w = 3, A = 4, x = 5, E = 100, C = 101, S = 102, M = 103, T = 104, P = 200, I = 201, R = 202, k = 203, D = 204, B = 205, O = 206, L = 207, U = 208, F = 209, N = 210, j = 0, z = 1, G = 2, V = 3, H = 4, Q = 5, W = 6, q = 7, X = 0, Y = 1, K = 2, J = 0, Z = 1, $ = 2, ee = 3, te = 4, ne = 5, re = 300, ie = 301, se = 302, oe = 303, ae = 304, le = 306, ce = 1e3, ue = 1001, pe = 1002, de = 1003, he = 1004, fe = 1004, me = 1005, _e = 1005, ge = 1006, ve = 1007, ye = 1007, be = 1008, we = 1008, Ae = 1009, xe = 1010, Ee = 1011, Ce = 1012, Se = 1013, Me = 1014, Te = 1015, Pe = 1016, Ie = 1017, Re = 1018, ke = 1020, De = 1021, Be = 1023, Oe = 1024, Le = 1025, Ue = 1026, Fe = 1027, Ne = 1028, je = 1029, ze = 1030, Ge = 1031, Ve = 1033, He = 33776, Qe = 33777, We = 33778, qe = 33779, Xe = 35840, Ye = 35841, Ke = 35842, Je = 35843, Ze = 36196, $e = 37492, et = 37496, tt = 37808, nt = 37809, rt = 37810, it = 37811, st = 37812, ot = 37813, at = 37814, lt = 37815, ct = 37816, ut = 37817, pt = 37818, dt = 37819, ht = 37820, ft = 37821, mt = 36492, _t = 36283, gt = 36284, vt = 36285, yt = 36286, bt = 2200, wt = 2201, At = 2202, xt = 2300, Et = 2301, Ct = 2302, St = 2400, Mt = 2401, Tt = 2402, Pt = 2500, It = 2501, Rt = 0, kt = 1, Dt = 2, Bt = 3e3, Ot = 3001, Lt = 3200, Ut = 3201, Ft = 0, Nt = 1, jt = "", zt = "srgb", Gt = "srgb-linear", Vt = "display-p3", Ht = "rgbm-16", Qt = 0, Wt = 7680, qt = 7681, Xt = 7682, Yt = 7683, Kt = 34055, Jt = 34056, Zt = 5386, $t = 512, en = 513, tn = 514, nn = 515, rn = 516, sn = 517, on = 518, an = 519, ln = 512, cn = 513, un = 514, pn = 515, dn = 516, hn = 517, fn = 518, mn = 519, _n = 35044, gn = 35048, vn = 35040, yn = 35045, bn = 35049, wn = 35041, An = 35046, xn = 35050, En = 35042, Cn = "100", Sn = "300 es", Mn = 1035, Tn = 2e3, Pn = 2001;
  class In {
    addEventListener(e2, t2) {
      void 0 === this._listeners && (this._listeners = {});
      const n2 = this._listeners;
      void 0 === n2[e2] && (n2[e2] = []), -1 === n2[e2].indexOf(t2) && n2[e2].push(t2);
    }
    hasEventListener(e2, t2) {
      if (void 0 === this._listeners)
        return false;
      const n2 = this._listeners;
      return void 0 !== n2[e2] && -1 !== n2[e2].indexOf(t2);
    }
    removeEventListener(e2, t2) {
      if (void 0 === this._listeners)
        return;
      const n2 = this._listeners[e2];
      if (void 0 !== n2) {
        const e3 = n2.indexOf(t2);
        -1 !== e3 && n2.splice(e3, 1);
      }
    }
    dispatchEvent(e2) {
      if (void 0 === this._listeners)
        return;
      const t2 = this._listeners[e2.type];
      if (void 0 !== t2) {
        e2.target = this;
        const n2 = t2.slice(0);
        for (let t3 = 0, r2 = n2.length; t3 < r2; t3++)
          n2[t3].call(this, e2);
        e2.target = null;
      }
    }
  }
  const Rn = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
  let kn = 1234567;
  const Dn = Math.PI / 180, Bn = 180 / Math.PI;
  function On() {
    const e2 = 4294967295 * Math.random() | 0, t2 = 4294967295 * Math.random() | 0, n2 = 4294967295 * Math.random() | 0, r2 = 4294967295 * Math.random() | 0;
    return (Rn[255 & e2] + Rn[e2 >> 8 & 255] + Rn[e2 >> 16 & 255] + Rn[e2 >> 24 & 255] + "-" + Rn[255 & t2] + Rn[t2 >> 8 & 255] + "-" + Rn[t2 >> 16 & 15 | 64] + Rn[t2 >> 24 & 255] + "-" + Rn[63 & n2 | 128] + Rn[n2 >> 8 & 255] + "-" + Rn[n2 >> 16 & 255] + Rn[n2 >> 24 & 255] + Rn[255 & r2] + Rn[r2 >> 8 & 255] + Rn[r2 >> 16 & 255] + Rn[r2 >> 24 & 255]).toLowerCase();
  }
  function Ln(e2, t2, n2) {
    return Math.max(t2, Math.min(n2, e2));
  }
  function Un(e2, t2) {
    return (e2 % t2 + t2) % t2;
  }
  function Fn(e2, t2, n2) {
    return (1 - n2) * e2 + n2 * t2;
  }
  function Nn(e2) {
    return 0 == (e2 & e2 - 1) && 0 !== e2;
  }
  function jn(e2) {
    return Math.pow(2, Math.ceil(Math.log(e2) / Math.LN2));
  }
  function zn(e2) {
    return Math.pow(2, Math.floor(Math.log(e2) / Math.LN2));
  }
  function Gn(e2, t2) {
    switch (t2.constructor) {
      case Float32Array:
        return e2;
      case Uint32Array:
        return e2 / 4294967295;
      case Uint16Array:
        return e2 / 65535;
      case Uint8Array:
        return e2 / 255;
      case Int32Array:
        return Math.max(e2 / 2147483647, -1);
      case Int16Array:
        return Math.max(e2 / 32767, -1);
      case Int8Array:
        return Math.max(e2 / 127, -1);
      default:
        throw new Error("Invalid component type.");
    }
  }
  function Vn(e2, t2) {
    switch (t2.constructor) {
      case Float32Array:
        return e2;
      case Uint32Array:
        return Math.round(4294967295 * e2);
      case Uint16Array:
        return Math.round(65535 * e2);
      case Uint8Array:
        return Math.round(255 * e2);
      case Int32Array:
        return Math.round(2147483647 * e2);
      case Int16Array:
        return Math.round(32767 * e2);
      case Int8Array:
        return Math.round(127 * e2);
      default:
        throw new Error("Invalid component type.");
    }
  }
  const Hn = { DEG2RAD: Dn, RAD2DEG: Bn, generateUUID: On, clamp: Ln, euclideanModulo: Un, mapLinear: function(e2, t2, n2, r2, i2) {
    return r2 + (e2 - t2) * (i2 - r2) / (n2 - t2);
  }, inverseLerp: function(e2, t2, n2) {
    return e2 !== t2 ? (n2 - e2) / (t2 - e2) : 0;
  }, lerp: Fn, damp: function(e2, t2, n2, r2) {
    return Fn(e2, t2, 1 - Math.exp(-n2 * r2));
  }, pingpong: function(e2, t2 = 1) {
    return t2 - Math.abs(Un(e2, 2 * t2) - t2);
  }, smoothstep: function(e2, t2, n2) {
    return e2 <= t2 ? 0 : e2 >= n2 ? 1 : (e2 = (e2 - t2) / (n2 - t2)) * e2 * (3 - 2 * e2);
  }, smootherstep: function(e2, t2, n2) {
    return e2 <= t2 ? 0 : e2 >= n2 ? 1 : (e2 = (e2 - t2) / (n2 - t2)) * e2 * e2 * (e2 * (6 * e2 - 15) + 10);
  }, randInt: function(e2, t2) {
    return e2 + Math.floor(Math.random() * (t2 - e2 + 1));
  }, randFloat: function(e2, t2) {
    return e2 + Math.random() * (t2 - e2);
  }, randFloatSpread: function(e2) {
    return e2 * (0.5 - Math.random());
  }, seededRandom: function(e2) {
    void 0 !== e2 && (kn = e2);
    let t2 = kn += 1831565813;
    return t2 = Math.imul(t2 ^ t2 >>> 15, 1 | t2), t2 ^= t2 + Math.imul(t2 ^ t2 >>> 7, 61 | t2), ((t2 ^ t2 >>> 14) >>> 0) / 4294967296;
  }, degToRad: function(e2) {
    return e2 * Dn;
  }, radToDeg: function(e2) {
    return e2 * Bn;
  }, isPowerOfTwo: Nn, ceilPowerOfTwo: jn, floorPowerOfTwo: zn, setQuaternionFromProperEuler: function(e2, t2, n2, r2, i2) {
    const s2 = Math.cos, o2 = Math.sin, a2 = s2(n2 / 2), l2 = o2(n2 / 2), c2 = s2((t2 + r2) / 2), u2 = o2((t2 + r2) / 2), p2 = s2((t2 - r2) / 2), d2 = o2((t2 - r2) / 2), h2 = s2((r2 - t2) / 2), f2 = o2((r2 - t2) / 2);
    switch (i2) {
      case "XYX":
        e2.set(a2 * u2, l2 * p2, l2 * d2, a2 * c2);
        break;
      case "YZY":
        e2.set(l2 * d2, a2 * u2, l2 * p2, a2 * c2);
        break;
      case "ZXZ":
        e2.set(l2 * p2, l2 * d2, a2 * u2, a2 * c2);
        break;
      case "XZX":
        e2.set(a2 * u2, l2 * f2, l2 * h2, a2 * c2);
        break;
      case "YXY":
        e2.set(l2 * h2, a2 * u2, l2 * f2, a2 * c2);
        break;
      case "ZYZ":
        e2.set(l2 * f2, l2 * h2, a2 * u2, a2 * c2);
        break;
      default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i2);
    }
  }, normalize: Vn, denormalize: Gn };
  class Qn {
    constructor(e2 = 0, t2 = 0) {
      Qn.prototype.isVector2 = true, this.x = e2, this.y = t2;
    }
    get width() {
      return this.x;
    }
    set width(e2) {
      this.x = e2;
    }
    get height() {
      return this.y;
    }
    set height(e2) {
      this.y = e2;
    }
    set(e2, t2) {
      return this.x = e2, this.y = t2, this;
    }
    setScalar(e2) {
      return this.x = e2, this.y = e2, this;
    }
    setX(e2) {
      return this.x = e2, this;
    }
    setY(e2) {
      return this.y = e2, this;
    }
    setComponent(e2, t2) {
      switch (e2) {
        case 0:
          this.x = t2;
          break;
        case 1:
          this.y = t2;
          break;
        default:
          throw new Error("index is out of range: " + e2);
      }
      return this;
    }
    getComponent(e2) {
      switch (e2) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + e2);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(e2) {
      return this.x = e2.x, this.y = e2.y, this;
    }
    add(e2) {
      return this.x += e2.x, this.y += e2.y, this;
    }
    addScalar(e2) {
      return this.x += e2, this.y += e2, this;
    }
    addVectors(e2, t2) {
      return this.x = e2.x + t2.x, this.y = e2.y + t2.y, this;
    }
    addScaledVector(e2, t2) {
      return this.x += e2.x * t2, this.y += e2.y * t2, this;
    }
    sub(e2) {
      return this.x -= e2.x, this.y -= e2.y, this;
    }
    subScalar(e2) {
      return this.x -= e2, this.y -= e2, this;
    }
    subVectors(e2, t2) {
      return this.x = e2.x - t2.x, this.y = e2.y - t2.y, this;
    }
    multiply(e2) {
      return this.x *= e2.x, this.y *= e2.y, this;
    }
    multiplyScalar(e2) {
      return this.x *= e2, this.y *= e2, this;
    }
    divide(e2) {
      return this.x /= e2.x, this.y /= e2.y, this;
    }
    divideScalar(e2) {
      return this.multiplyScalar(1 / e2);
    }
    applyMatrix3(e2) {
      const t2 = this.x, n2 = this.y, r2 = e2.elements;
      return this.x = r2[0] * t2 + r2[3] * n2 + r2[6], this.y = r2[1] * t2 + r2[4] * n2 + r2[7], this;
    }
    min(e2) {
      return this.x = Math.min(this.x, e2.x), this.y = Math.min(this.y, e2.y), this;
    }
    max(e2) {
      return this.x = Math.max(this.x, e2.x), this.y = Math.max(this.y, e2.y), this;
    }
    clamp(e2, t2) {
      return this.x = Math.max(e2.x, Math.min(t2.x, this.x)), this.y = Math.max(e2.y, Math.min(t2.y, this.y)), this;
    }
    clampScalar(e2, t2) {
      return this.x = Math.max(e2, Math.min(t2, this.x)), this.y = Math.max(e2, Math.min(t2, this.y)), this;
    }
    clampLength(e2, t2) {
      const n2 = this.length();
      return this.divideScalar(n2 || 1).multiplyScalar(Math.max(e2, Math.min(t2, n2)));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    }
    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this;
    }
    dot(e2) {
      return this.x * e2.x + this.y * e2.y;
    }
    cross(e2) {
      return this.x * e2.y - this.y * e2.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      return Math.atan2(-this.y, -this.x) + Math.PI;
    }
    angleTo(e2) {
      const t2 = Math.sqrt(this.lengthSq() * e2.lengthSq());
      if (0 === t2)
        return Math.PI / 2;
      const n2 = this.dot(e2) / t2;
      return Math.acos(Ln(n2, -1, 1));
    }
    distanceTo(e2) {
      return Math.sqrt(this.distanceToSquared(e2));
    }
    distanceToSquared(e2) {
      const t2 = this.x - e2.x, n2 = this.y - e2.y;
      return t2 * t2 + n2 * n2;
    }
    manhattanDistanceTo(e2) {
      return Math.abs(this.x - e2.x) + Math.abs(this.y - e2.y);
    }
    setLength(e2) {
      return this.normalize().multiplyScalar(e2);
    }
    lerp(e2, t2) {
      return this.x += (e2.x - this.x) * t2, this.y += (e2.y - this.y) * t2, this;
    }
    lerpVectors(e2, t2, n2) {
      return this.x = e2.x + (t2.x - e2.x) * n2, this.y = e2.y + (t2.y - e2.y) * n2, this;
    }
    equals(e2) {
      return e2.x === this.x && e2.y === this.y;
    }
    fromArray(e2, t2 = 0) {
      return this.x = e2[t2], this.y = e2[t2 + 1], this;
    }
    toArray(e2 = [], t2 = 0) {
      return e2[t2] = this.x, e2[t2 + 1] = this.y, e2;
    }
    fromBufferAttribute(e2, t2) {
      return this.x = e2.getX(t2), this.y = e2.getY(t2), this;
    }
    rotateAround(e2, t2) {
      const n2 = Math.cos(t2), r2 = Math.sin(t2), i2 = this.x - e2.x, s2 = this.y - e2.y;
      return this.x = i2 * n2 - s2 * r2 + e2.x, this.y = i2 * r2 + s2 * n2 + e2.y, this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y;
    }
  }
  class Wn {
    constructor(e2, t2, n2, r2, i2, s2, o2, a2, l2) {
      Wn.prototype.isMatrix3 = true, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], void 0 !== e2 && this.set(e2, t2, n2, r2, i2, s2, o2, a2, l2);
    }
    set(e2, t2, n2, r2, i2, s2, o2, a2, l2) {
      const c2 = this.elements;
      return c2[0] = e2, c2[1] = r2, c2[2] = o2, c2[3] = t2, c2[4] = i2, c2[5] = a2, c2[6] = n2, c2[7] = s2, c2[8] = l2, this;
    }
    identity() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }
    copy(e2) {
      const t2 = this.elements, n2 = e2.elements;
      return t2[0] = n2[0], t2[1] = n2[1], t2[2] = n2[2], t2[3] = n2[3], t2[4] = n2[4], t2[5] = n2[5], t2[6] = n2[6], t2[7] = n2[7], t2[8] = n2[8], this;
    }
    extractBasis(e2, t2, n2) {
      return e2.setFromMatrix3Column(this, 0), t2.setFromMatrix3Column(this, 1), n2.setFromMatrix3Column(this, 2), this;
    }
    setFromMatrix4(e2) {
      const t2 = e2.elements;
      return this.set(t2[0], t2[4], t2[8], t2[1], t2[5], t2[9], t2[2], t2[6], t2[10]), this;
    }
    multiply(e2) {
      return this.multiplyMatrices(this, e2);
    }
    premultiply(e2) {
      return this.multiplyMatrices(e2, this);
    }
    multiplyMatrices(e2, t2) {
      const n2 = e2.elements, r2 = t2.elements, i2 = this.elements, s2 = n2[0], o2 = n2[3], a2 = n2[6], l2 = n2[1], c2 = n2[4], u2 = n2[7], p2 = n2[2], d2 = n2[5], h2 = n2[8], f2 = r2[0], m2 = r2[3], _2 = r2[6], g2 = r2[1], v2 = r2[4], y2 = r2[7], b2 = r2[2], w2 = r2[5], A2 = r2[8];
      return i2[0] = s2 * f2 + o2 * g2 + a2 * b2, i2[3] = s2 * m2 + o2 * v2 + a2 * w2, i2[6] = s2 * _2 + o2 * y2 + a2 * A2, i2[1] = l2 * f2 + c2 * g2 + u2 * b2, i2[4] = l2 * m2 + c2 * v2 + u2 * w2, i2[7] = l2 * _2 + c2 * y2 + u2 * A2, i2[2] = p2 * f2 + d2 * g2 + h2 * b2, i2[5] = p2 * m2 + d2 * v2 + h2 * w2, i2[8] = p2 * _2 + d2 * y2 + h2 * A2, this;
    }
    multiplyScalar(e2) {
      const t2 = this.elements;
      return t2[0] *= e2, t2[3] *= e2, t2[6] *= e2, t2[1] *= e2, t2[4] *= e2, t2[7] *= e2, t2[2] *= e2, t2[5] *= e2, t2[8] *= e2, this;
    }
    determinant() {
      const e2 = this.elements, t2 = e2[0], n2 = e2[1], r2 = e2[2], i2 = e2[3], s2 = e2[4], o2 = e2[5], a2 = e2[6], l2 = e2[7], c2 = e2[8];
      return t2 * s2 * c2 - t2 * o2 * l2 - n2 * i2 * c2 + n2 * o2 * a2 + r2 * i2 * l2 - r2 * s2 * a2;
    }
    invert() {
      const e2 = this.elements, t2 = e2[0], n2 = e2[1], r2 = e2[2], i2 = e2[3], s2 = e2[4], o2 = e2[5], a2 = e2[6], l2 = e2[7], c2 = e2[8], u2 = c2 * s2 - o2 * l2, p2 = o2 * a2 - c2 * i2, d2 = l2 * i2 - s2 * a2, h2 = t2 * u2 + n2 * p2 + r2 * d2;
      if (0 === h2)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const f2 = 1 / h2;
      return e2[0] = u2 * f2, e2[1] = (r2 * l2 - c2 * n2) * f2, e2[2] = (o2 * n2 - r2 * s2) * f2, e2[3] = p2 * f2, e2[4] = (c2 * t2 - r2 * a2) * f2, e2[5] = (r2 * i2 - o2 * t2) * f2, e2[6] = d2 * f2, e2[7] = (n2 * a2 - l2 * t2) * f2, e2[8] = (s2 * t2 - n2 * i2) * f2, this;
    }
    transpose() {
      let e2;
      const t2 = this.elements;
      return e2 = t2[1], t2[1] = t2[3], t2[3] = e2, e2 = t2[2], t2[2] = t2[6], t2[6] = e2, e2 = t2[5], t2[5] = t2[7], t2[7] = e2, this;
    }
    getNormalMatrix(e2) {
      return this.setFromMatrix4(e2).invert().transpose();
    }
    transposeIntoArray(e2) {
      const t2 = this.elements;
      return e2[0] = t2[0], e2[1] = t2[3], e2[2] = t2[6], e2[3] = t2[1], e2[4] = t2[4], e2[5] = t2[7], e2[6] = t2[2], e2[7] = t2[5], e2[8] = t2[8], this;
    }
    setUvTransform(e2, t2, n2, r2, i2, s2, o2) {
      const a2 = Math.cos(i2), l2 = Math.sin(i2);
      return this.set(n2 * a2, n2 * l2, -n2 * (a2 * s2 + l2 * o2) + s2 + e2, -r2 * l2, r2 * a2, -r2 * (-l2 * s2 + a2 * o2) + o2 + t2, 0, 0, 1), this;
    }
    scale(e2, t2) {
      return this.premultiply(qn.makeScale(e2, t2)), this;
    }
    rotate(e2) {
      return this.premultiply(qn.makeRotation(-e2)), this;
    }
    translate(e2, t2) {
      return this.premultiply(qn.makeTranslation(e2, t2)), this;
    }
    makeTranslation(e2, t2) {
      return e2.isVector2 ? this.set(1, 0, e2.x, 0, 1, e2.y, 0, 0, 1) : this.set(1, 0, e2, 0, 1, t2, 0, 0, 1), this;
    }
    makeRotation(e2) {
      const t2 = Math.cos(e2), n2 = Math.sin(e2);
      return this.set(t2, -n2, 0, n2, t2, 0, 0, 0, 1), this;
    }
    makeScale(e2, t2) {
      return this.set(e2, 0, 0, 0, t2, 0, 0, 0, 1), this;
    }
    equals(e2) {
      const t2 = this.elements, n2 = e2.elements;
      for (let e3 = 0; e3 < 9; e3++)
        if (t2[e3] !== n2[e3])
          return false;
      return true;
    }
    fromArray(e2, t2 = 0) {
      for (let n2 = 0; n2 < 9; n2++)
        this.elements[n2] = e2[n2 + t2];
      return this;
    }
    toArray(e2 = [], t2 = 0) {
      const n2 = this.elements;
      return e2[t2] = n2[0], e2[t2 + 1] = n2[1], e2[t2 + 2] = n2[2], e2[t2 + 3] = n2[3], e2[t2 + 4] = n2[4], e2[t2 + 5] = n2[5], e2[t2 + 6] = n2[6], e2[t2 + 7] = n2[7], e2[t2 + 8] = n2[8], e2;
    }
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
  }
  const qn = new Wn();
  function Xn(e2) {
    for (let t2 = e2.length - 1; t2 >= 0; --t2)
      if (e2[t2] >= 65535)
        return true;
    return false;
  }
  const Yn = { Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array };
  function Kn(e2, t2) {
    return new Yn[e2](t2);
  }
  function Jn(e2) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", e2);
  }
  const Zn = {};
  function $n(e2) {
    e2 in Zn || (Zn[e2] = true, console.warn(e2));
  }
  function er(e2) {
    return e2 < 0.04045 ? 0.0773993808 * e2 : Math.pow(0.9478672986 * e2 + 0.0521327014, 2.4);
  }
  function tr(e2) {
    return e2 < 31308e-7 ? 12.92 * e2 : 1.055 * Math.pow(e2, 0.41666) - 0.055;
  }
  const nr = new Wn().fromArray([0.8224621, 0.0331941, 0.0170827, 0.177538, 0.9668058, 0.0723974, -1e-7, 1e-7, 0.9105199]), rr = new Wn().fromArray([1.2249401, -0.0420569, -0.0196376, -0.2249404, 1.0420571, -0.0786361, 1e-7, 0, 1.0982735]), ir = { [Gt]: (e2) => e2, [zt]: (e2) => e2.convertSRGBToLinear(), [Vt]: function(e2) {
    return e2.convertSRGBToLinear().applyMatrix3(rr);
  } }, sr = { [Gt]: (e2) => e2, [zt]: (e2) => e2.convertLinearToSRGB(), [Vt]: function(e2) {
    return e2.applyMatrix3(nr).convertLinearToSRGB();
  } }, or = { enabled: true, get legacyMode() {
    return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), !this.enabled;
  }, set legacyMode(e2) {
    console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), this.enabled = !e2;
  }, get workingColorSpace() {
    return Gt;
  }, set workingColorSpace(e2) {
    console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
  }, convert: function(e2, t2, n2) {
    if (false === this.enabled || t2 === n2 || !t2 || !n2)
      return e2;
    const r2 = ir[t2], i2 = sr[n2];
    if (void 0 === r2 || void 0 === i2)
      throw new Error(`Unsupported color space conversion, "${t2}" to "${n2}".`);
    return i2(r2(e2));
  }, fromWorkingColorSpace: function(e2, t2) {
    return this.convert(e2, this.workingColorSpace, t2);
  }, toWorkingColorSpace: function(e2, t2) {
    return this.convert(e2, t2, this.workingColorSpace);
  } };
  let ar;
  class lr {
    static getDataURL(e2, t2 = false) {
      if (/^data:/i.test(e2.src))
        return e2.src;
      if ("undefined" == typeof HTMLCanvasElement)
        return e2.src;
      let n2;
      if (e2 instanceof HTMLCanvasElement)
        n2 = e2;
      else {
        void 0 === ar && (ar = Jn("canvas")), ar.width = e2.width, ar.height = e2.height;
        const t3 = ar.getContext("2d");
        e2 instanceof ImageData ? t3.putImageData(e2, 0, 0) : t3.drawImage(e2, 0, 0, e2.width, e2.height), n2 = ar;
      }
      return !t2 && (n2.width > 2048 || n2.height > 2048) ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e2), n2.toDataURL("image/jpeg", 0.6)) : n2.toDataURL("image/png");
    }
    static sRGBToLinear(e2) {
      if ("undefined" != typeof HTMLImageElement && e2 instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e2 instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e2 instanceof ImageBitmap) {
        const t2 = Jn("canvas");
        t2.width = e2.width, t2.height = e2.height;
        const n2 = t2.getContext("2d");
        n2.drawImage(e2, 0, 0, e2.width, e2.height);
        const r2 = n2.getImageData(0, 0, e2.width, e2.height), i2 = r2.data;
        for (let e3 = 0; e3 < i2.length; e3++)
          i2[e3] = 255 * er(i2[e3] / 255);
        return n2.putImageData(r2, 0, 0), t2;
      }
      if (e2.data) {
        const t2 = e2.data.slice(0);
        for (let e3 = 0; e3 < t2.length; e3++)
          t2 instanceof Uint8Array || t2 instanceof Uint8ClampedArray ? t2[e3] = Math.floor(255 * er(t2[e3] / 255)) : t2[e3] = er(t2[e3]);
        return { data: t2, width: e2.width, height: e2.height };
      }
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e2;
    }
  }
  let cr = 0;
  class ur {
    constructor(e2 = null) {
      this.isSource = true, Object.defineProperty(this, "id", { value: cr++ }), this.uuid = On(), this.data = e2, this.version = 0;
    }
    set needsUpdate(e2) {
      true === e2 && this.version++;
    }
    toJSON(e2) {
      const t2 = void 0 === e2 || "string" == typeof e2;
      if (!t2 && void 0 !== e2.images[this.uuid])
        return e2.images[this.uuid];
      const n2 = { uuid: this.uuid, url: "" }, r2 = this.data;
      if (null !== r2) {
        let e3;
        if (Array.isArray(r2)) {
          e3 = [];
          for (let t3 = 0, n3 = r2.length; t3 < n3; t3++)
            r2[t3].isDataTexture ? e3.push(pr(r2[t3].image)) : e3.push(pr(r2[t3]));
        } else
          e3 = pr(r2);
        n2.url = e3;
      }
      return t2 || (e2.images[this.uuid] = n2), n2;
    }
  }
  function pr(e2) {
    if ("undefined" != typeof HTMLImageElement && e2 instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e2 instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e2 instanceof ImageBitmap)
      return lr.getDataURL(e2);
    if (e2.data) {
      let t2 = [];
      try {
        t2 = Array.from(e2.data);
      } catch (n2) {
        n2.message.includes("Invalid array length") ? console.warn("Serializing large texture, might not be saved in JSON structure.") : console.error(n2), t2 = e2.data;
      }
      return { data: t2, width: e2.width, height: e2.height, type: e2.data.constructor.name };
    }
    return void 0 !== e2.url ? e2.url : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
  }
  let dr = 0;
  class hr extends In {
    constructor(e2 = hr.DEFAULT_IMAGE, t2 = hr.DEFAULT_MAPPING, n2 = ue, r2 = ue, i2 = ge, s2 = be, o2 = Be, a2 = Ae, l2 = hr.DEFAULT_ANISOTROPY, c2 = jt) {
      super(), this.isTexture = true, Object.defineProperty(this, "id", { value: dr++ }), this.uuid = On(), this.name = "", this.source = new ur(e2), this.mipmaps = [], this.mapping = t2, this.channel = 0, this.wrapS = n2, this.wrapT = r2, this.magFilter = i2, this.minFilter = s2, this.anisotropy = l2, this.format = o2, this.internalFormat = null, this.type = a2, this.offset = new Qn(0, 0), this.repeat = new Qn(1, 1), this.center = new Qn(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new Wn(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, "string" == typeof c2 ? this.colorSpace = c2 : ($n("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = c2 === Ot ? zt : jt), this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = false, this.needsPMREMUpdate = false;
    }
    get image() {
      return this.source.data;
    }
    set image(e2 = null) {
      this.source.data = e2;
    }
    updateMatrix() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e2) {
      return this.name = e2.name, this.source = e2.source, this.mipmaps = e2.mipmaps.slice(0), this.mapping = e2.mapping, this.channel = e2.channel, this.wrapS = e2.wrapS, this.wrapT = e2.wrapT, this.magFilter = e2.magFilter, this.minFilter = e2.minFilter, this.anisotropy = e2.anisotropy, this.format = e2.format, this.internalFormat = e2.internalFormat, this.type = e2.type, this.offset.copy(e2.offset), this.repeat.copy(e2.repeat), this.center.copy(e2.center), this.rotation = e2.rotation, this.matrixAutoUpdate = e2.matrixAutoUpdate, this.matrix.copy(e2.matrix), this.generateMipmaps = e2.generateMipmaps, this.premultiplyAlpha = e2.premultiplyAlpha, this.flipY = e2.flipY, this.unpackAlignment = e2.unpackAlignment, this.colorSpace = e2.colorSpace, this.userData = JSON.parse(JSON.stringify(e2.userData)), this.needsUpdate = true, this;
    }
    toJSON(e2) {
      const t2 = void 0 === e2 || "string" == typeof e2;
      if (!t2 && e2.textures && void 0 !== e2.textures[this.uuid])
        return e2.textures[this.uuid];
      const n2 = { metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(e2).uuid, mapping: this.mapping, channel: this.channel, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, internalFormat: this.internalFormat, type: this.type, colorSpace: this.colorSpace, encoding: this.colorSpace === zt ? Ot : Bt, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, generateMipmaps: this.generateMipmaps, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
      return Object.keys(this.userData).length > 0 && (n2.userData = this.userData), !t2 && e2.textures && (e2.textures[this.uuid] = n2), n2;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    transformUv(e2) {
      if (this.mapping !== re)
        return e2;
      if (e2.applyMatrix3(this.matrix), e2.x < 0 || e2.x > 1)
        switch (this.wrapS) {
          case ce:
            e2.x = e2.x - Math.floor(e2.x);
            break;
          case ue:
            e2.x = e2.x < 0 ? 0 : 1;
            break;
          case pe:
            1 === Math.abs(Math.floor(e2.x) % 2) ? e2.x = Math.ceil(e2.x) - e2.x : e2.x = e2.x - Math.floor(e2.x);
        }
      if (e2.y < 0 || e2.y > 1)
        switch (this.wrapT) {
          case ce:
            e2.y = e2.y - Math.floor(e2.y);
            break;
          case ue:
            e2.y = e2.y < 0 ? 0 : 1;
            break;
          case pe:
            1 === Math.abs(Math.floor(e2.y) % 2) ? e2.y = Math.ceil(e2.y) - e2.y : e2.y = e2.y - Math.floor(e2.y);
        }
      return this.flipY && (e2.y = 1 - e2.y), e2;
    }
    set needsUpdate(e2) {
      true === e2 && (this.version++, this.source.needsUpdate = true, this.dispatchEvent({ type: "update" }));
    }
    get encoding() {
      return $n("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace === zt ? Ot : Bt;
    }
    set encoding(e2) {
      $n("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = e2 === Ot ? zt : jt;
    }
  }
  hr.DEFAULT_IMAGE = null, hr.DEFAULT_MAPPING = re, hr.DEFAULT_ANISOTROPY = 1;
  class fr {
    constructor(e2 = 0, t2 = 0, n2 = 0, r2 = 1) {
      fr.prototype.isVector4 = true, this.x = e2, this.y = t2, this.z = n2, this.w = r2;
    }
    get width() {
      return this.z;
    }
    set width(e2) {
      this.z = e2;
    }
    get height() {
      return this.w;
    }
    set height(e2) {
      this.w = e2;
    }
    set(e2, t2, n2, r2) {
      return this.x = e2, this.y = t2, this.z = n2, this.w = r2, this;
    }
    setScalar(e2) {
      return this.x = e2, this.y = e2, this.z = e2, this.w = e2, this;
    }
    setX(e2) {
      return this.x = e2, this;
    }
    setY(e2) {
      return this.y = e2, this;
    }
    setZ(e2) {
      return this.z = e2, this;
    }
    setW(e2) {
      return this.w = e2, this;
    }
    setComponent(e2, t2) {
      switch (e2) {
        case 0:
          this.x = t2;
          break;
        case 1:
          this.y = t2;
          break;
        case 2:
          this.z = t2;
          break;
        case 3:
          this.w = t2;
          break;
        default:
          throw new Error("index is out of range: " + e2);
      }
      return this;
    }
    getComponent(e2) {
      switch (e2) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + e2);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(e2) {
      return this.x = e2.x, this.y = e2.y, this.z = e2.z, this.w = void 0 !== e2.w ? e2.w : 1, this;
    }
    add(e2) {
      return this.x += e2.x, this.y += e2.y, this.z += e2.z, this.w += e2.w, this;
    }
    addScalar(e2) {
      return this.x += e2, this.y += e2, this.z += e2, this.w += e2, this;
    }
    addVectors(e2, t2) {
      return this.x = e2.x + t2.x, this.y = e2.y + t2.y, this.z = e2.z + t2.z, this.w = e2.w + t2.w, this;
    }
    addScaledVector(e2, t2) {
      return this.x += e2.x * t2, this.y += e2.y * t2, this.z += e2.z * t2, this.w += e2.w * t2, this;
    }
    sub(e2) {
      return this.x -= e2.x, this.y -= e2.y, this.z -= e2.z, this.w -= e2.w, this;
    }
    subScalar(e2) {
      return this.x -= e2, this.y -= e2, this.z -= e2, this.w -= e2, this;
    }
    subVectors(e2, t2) {
      return this.x = e2.x - t2.x, this.y = e2.y - t2.y, this.z = e2.z - t2.z, this.w = e2.w - t2.w, this;
    }
    multiply(e2) {
      return this.x *= e2.x, this.y *= e2.y, this.z *= e2.z, this.w *= e2.w, this;
    }
    multiplyScalar(e2) {
      return this.x *= e2, this.y *= e2, this.z *= e2, this.w *= e2, this;
    }
    applyMatrix4(e2) {
      const t2 = this.x, n2 = this.y, r2 = this.z, i2 = this.w, s2 = e2.elements;
      return this.x = s2[0] * t2 + s2[4] * n2 + s2[8] * r2 + s2[12] * i2, this.y = s2[1] * t2 + s2[5] * n2 + s2[9] * r2 + s2[13] * i2, this.z = s2[2] * t2 + s2[6] * n2 + s2[10] * r2 + s2[14] * i2, this.w = s2[3] * t2 + s2[7] * n2 + s2[11] * r2 + s2[15] * i2, this;
    }
    divideScalar(e2) {
      return this.multiplyScalar(1 / e2);
    }
    setAxisAngleFromQuaternion(e2) {
      this.w = 2 * Math.acos(e2.w);
      const t2 = Math.sqrt(1 - e2.w * e2.w);
      return t2 < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e2.x / t2, this.y = e2.y / t2, this.z = e2.z / t2), this;
    }
    setAxisAngleFromRotationMatrix(e2) {
      let t2, n2, r2, i2;
      const s2 = 0.01, o2 = 0.1, a2 = e2.elements, l2 = a2[0], c2 = a2[4], u2 = a2[8], p2 = a2[1], d2 = a2[5], h2 = a2[9], f2 = a2[2], m2 = a2[6], _2 = a2[10];
      if (Math.abs(c2 - p2) < s2 && Math.abs(u2 - f2) < s2 && Math.abs(h2 - m2) < s2) {
        if (Math.abs(c2 + p2) < o2 && Math.abs(u2 + f2) < o2 && Math.abs(h2 + m2) < o2 && Math.abs(l2 + d2 + _2 - 3) < o2)
          return this.set(1, 0, 0, 0), this;
        t2 = Math.PI;
        const e3 = (l2 + 1) / 2, a3 = (d2 + 1) / 2, g3 = (_2 + 1) / 2, v2 = (c2 + p2) / 4, y2 = (u2 + f2) / 4, b2 = (h2 + m2) / 4;
        return e3 > a3 && e3 > g3 ? e3 < s2 ? (n2 = 0, r2 = 0.707106781, i2 = 0.707106781) : (n2 = Math.sqrt(e3), r2 = v2 / n2, i2 = y2 / n2) : a3 > g3 ? a3 < s2 ? (n2 = 0.707106781, r2 = 0, i2 = 0.707106781) : (r2 = Math.sqrt(a3), n2 = v2 / r2, i2 = b2 / r2) : g3 < s2 ? (n2 = 0.707106781, r2 = 0.707106781, i2 = 0) : (i2 = Math.sqrt(g3), n2 = y2 / i2, r2 = b2 / i2), this.set(n2, r2, i2, t2), this;
      }
      let g2 = Math.sqrt((m2 - h2) * (m2 - h2) + (u2 - f2) * (u2 - f2) + (p2 - c2) * (p2 - c2));
      return Math.abs(g2) < 1e-3 && (g2 = 1), this.x = (m2 - h2) / g2, this.y = (u2 - f2) / g2, this.z = (p2 - c2) / g2, this.w = Math.acos((l2 + d2 + _2 - 1) / 2), this;
    }
    min(e2) {
      return this.x = Math.min(this.x, e2.x), this.y = Math.min(this.y, e2.y), this.z = Math.min(this.z, e2.z), this.w = Math.min(this.w, e2.w), this;
    }
    max(e2) {
      return this.x = Math.max(this.x, e2.x), this.y = Math.max(this.y, e2.y), this.z = Math.max(this.z, e2.z), this.w = Math.max(this.w, e2.w), this;
    }
    clamp(e2, t2) {
      return this.x = Math.max(e2.x, Math.min(t2.x, this.x)), this.y = Math.max(e2.y, Math.min(t2.y, this.y)), this.z = Math.max(e2.z, Math.min(t2.z, this.z)), this.w = Math.max(e2.w, Math.min(t2.w, this.w)), this;
    }
    clampScalar(e2, t2) {
      return this.x = Math.max(e2, Math.min(t2, this.x)), this.y = Math.max(e2, Math.min(t2, this.y)), this.z = Math.max(e2, Math.min(t2, this.z)), this.w = Math.max(e2, Math.min(t2, this.w)), this;
    }
    clampLength(e2, t2) {
      const n2 = this.length();
      return this.divideScalar(n2 || 1).multiplyScalar(Math.max(e2, Math.min(t2, n2)));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
    }
    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
    }
    dot(e2) {
      return this.x * e2.x + this.y * e2.y + this.z * e2.z + this.w * e2.w;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(e2) {
      return this.normalize().multiplyScalar(e2);
    }
    lerp(e2, t2) {
      return this.x += (e2.x - this.x) * t2, this.y += (e2.y - this.y) * t2, this.z += (e2.z - this.z) * t2, this.w += (e2.w - this.w) * t2, this;
    }
    lerpVectors(e2, t2, n2) {
      return this.x = e2.x + (t2.x - e2.x) * n2, this.y = e2.y + (t2.y - e2.y) * n2, this.z = e2.z + (t2.z - e2.z) * n2, this.w = e2.w + (t2.w - e2.w) * n2, this;
    }
    equals(e2) {
      return e2.x === this.x && e2.y === this.y && e2.z === this.z && e2.w === this.w;
    }
    fromArray(e2, t2 = 0) {
      return this.x = e2[t2], this.y = e2[t2 + 1], this.z = e2[t2 + 2], this.w = e2[t2 + 3], this;
    }
    toArray(e2 = [], t2 = 0) {
      return e2[t2] = this.x, e2[t2 + 1] = this.y, e2[t2 + 2] = this.z, e2[t2 + 3] = this.w, e2;
    }
    fromBufferAttribute(e2, t2) {
      return this.x = e2.getX(t2), this.y = e2.getY(t2), this.z = e2.getZ(t2), this.w = e2.getW(t2), this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z, yield this.w;
    }
  }
  class mr extends In {
    constructor(e2 = 1, t2 = 1, n2 = {}) {
      super(), this.isWebGLRenderTarget = true, this.width = e2, this.height = t2, this.depth = 1, this.scissor = new fr(0, 0, e2, t2), this.scissorTest = false, this.viewport = new fr(0, 0, e2, t2);
      const r2 = { width: e2, height: t2, depth: 1 };
      void 0 !== n2.encoding && ($n("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."), n2.colorSpace = n2.encoding === Ot ? zt : jt), this.texture = new hr(r2, n2.mapping, n2.wrapS, n2.wrapT, n2.magFilter, n2.minFilter, n2.format, n2.type, n2.anisotropy, n2.colorSpace), this.texture.isRenderTargetTexture = true, this.texture.flipY = false, this.texture.generateMipmaps = void 0 !== n2.generateMipmaps && n2.generateMipmaps, this.texture.internalFormat = void 0 !== n2.internalFormat ? n2.internalFormat : null, this.texture.minFilter = void 0 !== n2.minFilter ? n2.minFilter : ge, this.depthBuffer = void 0 === n2.depthBuffer || n2.depthBuffer, this.stencilBuffer = void 0 !== n2.stencilBuffer && n2.stencilBuffer, this.depthTexture = void 0 !== n2.depthTexture ? n2.depthTexture : null, this.samples = void 0 !== n2.samples ? n2.samples : 0;
    }
    setSize(e2, t2, n2 = 1) {
      this.width === e2 && this.height === t2 && this.depth === n2 || (this.width = e2, this.height = t2, this.depth = n2, this.texture.image.width = e2, this.texture.image.height = t2, this.texture.image.depth = n2, this.dispose()), this.viewport.set(0, 0, e2, t2), this.scissor.set(0, 0, e2, t2);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e2) {
      this.width = e2.width, this.height = e2.height, this.depth = e2.depth, this.scissor.copy(e2.scissor), this.scissorTest = e2.scissorTest, this.viewport.copy(e2.viewport), this.texture = e2.texture.clone(), this.texture.isRenderTargetTexture = true;
      const t2 = Object.assign({}, e2.texture.image);
      return this.texture.source = new ur(t2), this.depthBuffer = e2.depthBuffer, this.stencilBuffer = e2.stencilBuffer, null !== e2.depthTexture && (this.depthTexture = e2.depthTexture.clone()), this.samples = e2.samples, this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  }
  class _r extends hr {
    constructor(e2 = null, t2 = 1, n2 = 1, r2 = 1) {
      super(null), this.isDataArrayTexture = true, this.image = { data: e2, width: t2, height: n2, depth: r2 }, this.magFilter = de, this.minFilter = de, this.wrapR = ue, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
    }
  }
  class gr extends mr {
    constructor(e2 = 1, t2 = 1, n2 = 1) {
      super(e2, t2), this.isWebGLArrayRenderTarget = true, this.depth = n2, this.texture = new _r(null, e2, t2, n2), this.texture.isRenderTargetTexture = true;
    }
  }
  class vr extends hr {
    constructor(e2 = null, t2 = 1, n2 = 1, r2 = 1) {
      super(null), this.isData3DTexture = true, this.image = { data: e2, width: t2, height: n2, depth: r2 }, this.magFilter = de, this.minFilter = de, this.wrapR = ue, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
    }
  }
  class yr extends mr {
    constructor(e2 = 1, t2 = 1, n2 = 1) {
      super(e2, t2), this.isWebGL3DRenderTarget = true, this.depth = n2, this.texture = new vr(null, e2, t2, n2), this.texture.isRenderTargetTexture = true;
    }
  }
  class br extends mr {
    constructor(e2 = 1, t2 = 1, n2 = 1, r2 = {}) {
      super(e2, t2, r2), this.isWebGLMultipleRenderTargets = true;
      const i2 = this.texture;
      this.texture = [];
      for (let e3 = 0; e3 < n2; e3++)
        this.texture[e3] = i2.clone(), this.texture[e3].isRenderTargetTexture = true;
    }
    setSize(e2, t2, n2 = 1) {
      if (this.width !== e2 || this.height !== t2 || this.depth !== n2) {
        this.width = e2, this.height = t2, this.depth = n2;
        for (let r2 = 0, i2 = this.texture.length; r2 < i2; r2++)
          this.texture[r2].image.width = e2, this.texture[r2].image.height = t2, this.texture[r2].image.depth = n2;
        this.dispose();
      }
      return this.viewport.set(0, 0, e2, t2), this.scissor.set(0, 0, e2, t2), this;
    }
    copy(e2) {
      this.dispose(), this.width = e2.width, this.height = e2.height, this.depth = e2.depth, this.scissor.copy(e2.scissor), this.scissorTest = e2.scissorTest, this.viewport.copy(e2.viewport), this.depthBuffer = e2.depthBuffer, this.stencilBuffer = e2.stencilBuffer, null !== e2.depthTexture && (this.depthTexture = e2.depthTexture.clone()), this.texture.length = 0;
      for (let t2 = 0, n2 = e2.texture.length; t2 < n2; t2++)
        this.texture[t2] = e2.texture[t2].clone(), this.texture[t2].isRenderTargetTexture = true;
      return this;
    }
  }
  class wr {
    constructor(e2 = 0, t2 = 0, n2 = 0, r2 = 1) {
      this.isQuaternion = true, this._x = e2, this._y = t2, this._z = n2, this._w = r2;
    }
    static slerpFlat(e2, t2, n2, r2, i2, s2, o2) {
      let a2 = n2[r2 + 0], l2 = n2[r2 + 1], c2 = n2[r2 + 2], u2 = n2[r2 + 3];
      const p2 = i2[s2 + 0], d2 = i2[s2 + 1], h2 = i2[s2 + 2], f2 = i2[s2 + 3];
      if (0 === o2)
        return e2[t2 + 0] = a2, e2[t2 + 1] = l2, e2[t2 + 2] = c2, void (e2[t2 + 3] = u2);
      if (1 === o2)
        return e2[t2 + 0] = p2, e2[t2 + 1] = d2, e2[t2 + 2] = h2, void (e2[t2 + 3] = f2);
      if (u2 !== f2 || a2 !== p2 || l2 !== d2 || c2 !== h2) {
        let e3 = 1 - o2;
        const t3 = a2 * p2 + l2 * d2 + c2 * h2 + u2 * f2, n3 = t3 >= 0 ? 1 : -1, r3 = 1 - t3 * t3;
        if (r3 > Number.EPSILON) {
          const i4 = Math.sqrt(r3), s3 = Math.atan2(i4, t3 * n3);
          e3 = Math.sin(e3 * s3) / i4, o2 = Math.sin(o2 * s3) / i4;
        }
        const i3 = o2 * n3;
        if (a2 = a2 * e3 + p2 * i3, l2 = l2 * e3 + d2 * i3, c2 = c2 * e3 + h2 * i3, u2 = u2 * e3 + f2 * i3, e3 === 1 - o2) {
          const e4 = 1 / Math.sqrt(a2 * a2 + l2 * l2 + c2 * c2 + u2 * u2);
          a2 *= e4, l2 *= e4, c2 *= e4, u2 *= e4;
        }
      }
      e2[t2] = a2, e2[t2 + 1] = l2, e2[t2 + 2] = c2, e2[t2 + 3] = u2;
    }
    static multiplyQuaternionsFlat(e2, t2, n2, r2, i2, s2) {
      const o2 = n2[r2], a2 = n2[r2 + 1], l2 = n2[r2 + 2], c2 = n2[r2 + 3], u2 = i2[s2], p2 = i2[s2 + 1], d2 = i2[s2 + 2], h2 = i2[s2 + 3];
      return e2[t2] = o2 * h2 + c2 * u2 + a2 * d2 - l2 * p2, e2[t2 + 1] = a2 * h2 + c2 * p2 + l2 * u2 - o2 * d2, e2[t2 + 2] = l2 * h2 + c2 * d2 + o2 * p2 - a2 * u2, e2[t2 + 3] = c2 * h2 - o2 * u2 - a2 * p2 - l2 * d2, e2;
    }
    get x() {
      return this._x;
    }
    set x(e2) {
      this._x = e2, this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(e2) {
      this._y = e2, this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(e2) {
      this._z = e2, this._onChangeCallback();
    }
    get w() {
      return this._w;
    }
    set w(e2) {
      this._w = e2, this._onChangeCallback();
    }
    set(e2, t2, n2, r2) {
      return this._x = e2, this._y = t2, this._z = n2, this._w = r2, this._onChangeCallback(), this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(e2) {
      return this._x = e2.x, this._y = e2.y, this._z = e2.z, this._w = e2.w, this._onChangeCallback(), this;
    }
    setFromEuler(e2, t2) {
      const n2 = e2._x, r2 = e2._y, i2 = e2._z, s2 = e2._order, o2 = Math.cos, a2 = Math.sin, l2 = o2(n2 / 2), c2 = o2(r2 / 2), u2 = o2(i2 / 2), p2 = a2(n2 / 2), d2 = a2(r2 / 2), h2 = a2(i2 / 2);
      switch (s2) {
        case "XYZ":
          this._x = p2 * c2 * u2 + l2 * d2 * h2, this._y = l2 * d2 * u2 - p2 * c2 * h2, this._z = l2 * c2 * h2 + p2 * d2 * u2, this._w = l2 * c2 * u2 - p2 * d2 * h2;
          break;
        case "YXZ":
          this._x = p2 * c2 * u2 + l2 * d2 * h2, this._y = l2 * d2 * u2 - p2 * c2 * h2, this._z = l2 * c2 * h2 - p2 * d2 * u2, this._w = l2 * c2 * u2 + p2 * d2 * h2;
          break;
        case "ZXY":
          this._x = p2 * c2 * u2 - l2 * d2 * h2, this._y = l2 * d2 * u2 + p2 * c2 * h2, this._z = l2 * c2 * h2 + p2 * d2 * u2, this._w = l2 * c2 * u2 - p2 * d2 * h2;
          break;
        case "ZYX":
          this._x = p2 * c2 * u2 - l2 * d2 * h2, this._y = l2 * d2 * u2 + p2 * c2 * h2, this._z = l2 * c2 * h2 - p2 * d2 * u2, this._w = l2 * c2 * u2 + p2 * d2 * h2;
          break;
        case "YZX":
          this._x = p2 * c2 * u2 + l2 * d2 * h2, this._y = l2 * d2 * u2 + p2 * c2 * h2, this._z = l2 * c2 * h2 - p2 * d2 * u2, this._w = l2 * c2 * u2 - p2 * d2 * h2;
          break;
        case "XZY":
          this._x = p2 * c2 * u2 - l2 * d2 * h2, this._y = l2 * d2 * u2 - p2 * c2 * h2, this._z = l2 * c2 * h2 + p2 * d2 * u2, this._w = l2 * c2 * u2 + p2 * d2 * h2;
          break;
        default:
          console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s2);
      }
      return false !== t2 && this._onChangeCallback(), this;
    }
    setFromAxisAngle(e2, t2) {
      const n2 = t2 / 2, r2 = Math.sin(n2);
      return this._x = e2.x * r2, this._y = e2.y * r2, this._z = e2.z * r2, this._w = Math.cos(n2), this._onChangeCallback(), this;
    }
    setFromRotationMatrix(e2) {
      const t2 = e2.elements, n2 = t2[0], r2 = t2[4], i2 = t2[8], s2 = t2[1], o2 = t2[5], a2 = t2[9], l2 = t2[2], c2 = t2[6], u2 = t2[10], p2 = n2 + o2 + u2;
      if (p2 > 0) {
        const e3 = 0.5 / Math.sqrt(p2 + 1);
        this._w = 0.25 / e3, this._x = (c2 - a2) * e3, this._y = (i2 - l2) * e3, this._z = (s2 - r2) * e3;
      } else if (n2 > o2 && n2 > u2) {
        const e3 = 2 * Math.sqrt(1 + n2 - o2 - u2);
        this._w = (c2 - a2) / e3, this._x = 0.25 * e3, this._y = (r2 + s2) / e3, this._z = (i2 + l2) / e3;
      } else if (o2 > u2) {
        const e3 = 2 * Math.sqrt(1 + o2 - n2 - u2);
        this._w = (i2 - l2) / e3, this._x = (r2 + s2) / e3, this._y = 0.25 * e3, this._z = (a2 + c2) / e3;
      } else {
        const e3 = 2 * Math.sqrt(1 + u2 - n2 - o2);
        this._w = (s2 - r2) / e3, this._x = (i2 + l2) / e3, this._y = (a2 + c2) / e3, this._z = 0.25 * e3;
      }
      return this._onChangeCallback(), this;
    }
    setFromUnitVectors(e2, t2) {
      let n2 = e2.dot(t2) + 1;
      return n2 < Number.EPSILON ? (n2 = 0, Math.abs(e2.x) > Math.abs(e2.z) ? (this._x = -e2.y, this._y = e2.x, this._z = 0, this._w = n2) : (this._x = 0, this._y = -e2.z, this._z = e2.y, this._w = n2)) : (this._x = e2.y * t2.z - e2.z * t2.y, this._y = e2.z * t2.x - e2.x * t2.z, this._z = e2.x * t2.y - e2.y * t2.x, this._w = n2), this.normalize();
    }
    angleTo(e2) {
      return 2 * Math.acos(Math.abs(Ln(this.dot(e2), -1, 1)));
    }
    rotateTowards(e2, t2) {
      const n2 = this.angleTo(e2);
      if (0 === n2)
        return this;
      const r2 = Math.min(1, t2 / n2);
      return this.slerp(e2, r2), this;
    }
    identity() {
      return this.set(0, 0, 0, 1);
    }
    invert() {
      return this.conjugate();
    }
    conjugate() {
      return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
    }
    dot(e2) {
      return this._x * e2._x + this._y * e2._y + this._z * e2._z + this._w * e2._w;
    }
    lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
    length() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
    normalize() {
      let e2 = this.length();
      return 0 === e2 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e2 = 1 / e2, this._x = this._x * e2, this._y = this._y * e2, this._z = this._z * e2, this._w = this._w * e2), this._onChangeCallback(), this;
    }
    multiply(e2) {
      return this.multiplyQuaternions(this, e2);
    }
    premultiply(e2) {
      return this.multiplyQuaternions(e2, this);
    }
    multiplyQuaternions(e2, t2) {
      const n2 = e2._x, r2 = e2._y, i2 = e2._z, s2 = e2._w, o2 = t2._x, a2 = t2._y, l2 = t2._z, c2 = t2._w;
      return this._x = n2 * c2 + s2 * o2 + r2 * l2 - i2 * a2, this._y = r2 * c2 + s2 * a2 + i2 * o2 - n2 * l2, this._z = i2 * c2 + s2 * l2 + n2 * a2 - r2 * o2, this._w = s2 * c2 - n2 * o2 - r2 * a2 - i2 * l2, this._onChangeCallback(), this;
    }
    slerp(e2, t2) {
      if (0 === t2)
        return this;
      if (1 === t2)
        return this.copy(e2);
      const n2 = this._x, r2 = this._y, i2 = this._z, s2 = this._w;
      let o2 = s2 * e2._w + n2 * e2._x + r2 * e2._y + i2 * e2._z;
      if (o2 < 0 ? (this._w = -e2._w, this._x = -e2._x, this._y = -e2._y, this._z = -e2._z, o2 = -o2) : this.copy(e2), o2 >= 1)
        return this._w = s2, this._x = n2, this._y = r2, this._z = i2, this;
      const a2 = 1 - o2 * o2;
      if (a2 <= Number.EPSILON) {
        const e3 = 1 - t2;
        return this._w = e3 * s2 + t2 * this._w, this._x = e3 * n2 + t2 * this._x, this._y = e3 * r2 + t2 * this._y, this._z = e3 * i2 + t2 * this._z, this.normalize(), this._onChangeCallback(), this;
      }
      const l2 = Math.sqrt(a2), c2 = Math.atan2(l2, o2), u2 = Math.sin((1 - t2) * c2) / l2, p2 = Math.sin(t2 * c2) / l2;
      return this._w = s2 * u2 + this._w * p2, this._x = n2 * u2 + this._x * p2, this._y = r2 * u2 + this._y * p2, this._z = i2 * u2 + this._z * p2, this._onChangeCallback(), this;
    }
    slerpQuaternions(e2, t2, n2) {
      return this.copy(e2).slerp(t2, n2);
    }
    random() {
      const e2 = Math.random(), t2 = Math.sqrt(1 - e2), n2 = Math.sqrt(e2), r2 = 2 * Math.PI * Math.random(), i2 = 2 * Math.PI * Math.random();
      return this.set(t2 * Math.cos(r2), n2 * Math.sin(i2), n2 * Math.cos(i2), t2 * Math.sin(r2));
    }
    equals(e2) {
      return e2._x === this._x && e2._y === this._y && e2._z === this._z && e2._w === this._w;
    }
    fromArray(e2, t2 = 0) {
      return this._x = e2[t2], this._y = e2[t2 + 1], this._z = e2[t2 + 2], this._w = e2[t2 + 3], this._onChangeCallback(), this;
    }
    toArray(e2 = [], t2 = 0) {
      return e2[t2] = this._x, e2[t2 + 1] = this._y, e2[t2 + 2] = this._z, e2[t2 + 3] = this._w, e2;
    }
    fromBufferAttribute(e2, t2) {
      return this._x = e2.getX(t2), this._y = e2.getY(t2), this._z = e2.getZ(t2), this._w = e2.getW(t2), this;
    }
    toJSON() {
      return this.toArray();
    }
    _onChange(e2) {
      return this._onChangeCallback = e2, this;
    }
    _onChangeCallback() {
    }
    *[Symbol.iterator]() {
      yield this._x, yield this._y, yield this._z, yield this._w;
    }
  }
  class Ar {
    constructor(e2 = 0, t2 = 0, n2 = 0) {
      Ar.prototype.isVector3 = true, this.x = e2, this.y = t2, this.z = n2;
    }
    set(e2, t2, n2) {
      return void 0 === n2 && (n2 = this.z), this.x = e2, this.y = t2, this.z = n2, this;
    }
    setScalar(e2) {
      return this.x = e2, this.y = e2, this.z = e2, this;
    }
    setX(e2) {
      return this.x = e2, this;
    }
    setY(e2) {
      return this.y = e2, this;
    }
    setZ(e2) {
      return this.z = e2, this;
    }
    setComponent(e2, t2) {
      switch (e2) {
        case 0:
          this.x = t2;
          break;
        case 1:
          this.y = t2;
          break;
        case 2:
          this.z = t2;
          break;
        default:
          throw new Error("index is out of range: " + e2);
      }
      return this;
    }
    getComponent(e2) {
      switch (e2) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + e2);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
    copy(e2) {
      return this.x = e2.x, this.y = e2.y, this.z = e2.z, this;
    }
    add(e2) {
      return this.x += e2.x, this.y += e2.y, this.z += e2.z, this;
    }
    addScalar(e2) {
      return this.x += e2, this.y += e2, this.z += e2, this;
    }
    addVectors(e2, t2) {
      return this.x = e2.x + t2.x, this.y = e2.y + t2.y, this.z = e2.z + t2.z, this;
    }
    addScaledVector(e2, t2) {
      return this.x += e2.x * t2, this.y += e2.y * t2, this.z += e2.z * t2, this;
    }
    sub(e2) {
      return this.x -= e2.x, this.y -= e2.y, this.z -= e2.z, this;
    }
    subScalar(e2) {
      return this.x -= e2, this.y -= e2, this.z -= e2, this;
    }
    subVectors(e2, t2) {
      return this.x = e2.x - t2.x, this.y = e2.y - t2.y, this.z = e2.z - t2.z, this;
    }
    multiply(e2) {
      return this.x *= e2.x, this.y *= e2.y, this.z *= e2.z, this;
    }
    multiplyScalar(e2) {
      return this.x *= e2, this.y *= e2, this.z *= e2, this;
    }
    multiplyVectors(e2, t2) {
      return this.x = e2.x * t2.x, this.y = e2.y * t2.y, this.z = e2.z * t2.z, this;
    }
    applyEuler(e2) {
      return this.applyQuaternion(Er.setFromEuler(e2));
    }
    applyAxisAngle(e2, t2) {
      return this.applyQuaternion(Er.setFromAxisAngle(e2, t2));
    }
    applyMatrix3(e2) {
      const t2 = this.x, n2 = this.y, r2 = this.z, i2 = e2.elements;
      return this.x = i2[0] * t2 + i2[3] * n2 + i2[6] * r2, this.y = i2[1] * t2 + i2[4] * n2 + i2[7] * r2, this.z = i2[2] * t2 + i2[5] * n2 + i2[8] * r2, this;
    }
    applyNormalMatrix(e2) {
      return this.applyMatrix3(e2).normalize();
    }
    applyMatrix4(e2) {
      const t2 = this.x, n2 = this.y, r2 = this.z, i2 = e2.elements, s2 = 1 / (i2[3] * t2 + i2[7] * n2 + i2[11] * r2 + i2[15]);
      return this.x = (i2[0] * t2 + i2[4] * n2 + i2[8] * r2 + i2[12]) * s2, this.y = (i2[1] * t2 + i2[5] * n2 + i2[9] * r2 + i2[13]) * s2, this.z = (i2[2] * t2 + i2[6] * n2 + i2[10] * r2 + i2[14]) * s2, this;
    }
    applyQuaternion(e2) {
      const t2 = this.x, n2 = this.y, r2 = this.z, i2 = e2.x, s2 = e2.y, o2 = e2.z, a2 = e2.w, l2 = a2 * t2 + s2 * r2 - o2 * n2, c2 = a2 * n2 + o2 * t2 - i2 * r2, u2 = a2 * r2 + i2 * n2 - s2 * t2, p2 = -i2 * t2 - s2 * n2 - o2 * r2;
      return this.x = l2 * a2 + p2 * -i2 + c2 * -o2 - u2 * -s2, this.y = c2 * a2 + p2 * -s2 + u2 * -i2 - l2 * -o2, this.z = u2 * a2 + p2 * -o2 + l2 * -s2 - c2 * -i2, this;
    }
    project(e2) {
      return this.applyMatrix4(e2.matrixWorldInverse).applyMatrix4(e2.projectionMatrix);
    }
    unproject(e2) {
      return this.applyMatrix4(e2.projectionMatrixInverse).applyMatrix4(e2.matrixWorld);
    }
    transformDirection(e2) {
      const t2 = this.x, n2 = this.y, r2 = this.z, i2 = e2.elements;
      return this.x = i2[0] * t2 + i2[4] * n2 + i2[8] * r2, this.y = i2[1] * t2 + i2[5] * n2 + i2[9] * r2, this.z = i2[2] * t2 + i2[6] * n2 + i2[10] * r2, this.normalize();
    }
    divide(e2) {
      return this.x /= e2.x, this.y /= e2.y, this.z /= e2.z, this;
    }
    divideScalar(e2) {
      return this.multiplyScalar(1 / e2);
    }
    min(e2) {
      return this.x = Math.min(this.x, e2.x), this.y = Math.min(this.y, e2.y), this.z = Math.min(this.z, e2.z), this;
    }
    max(e2) {
      return this.x = Math.max(this.x, e2.x), this.y = Math.max(this.y, e2.y), this.z = Math.max(this.z, e2.z), this;
    }
    clamp(e2, t2) {
      return this.x = Math.max(e2.x, Math.min(t2.x, this.x)), this.y = Math.max(e2.y, Math.min(t2.y, this.y)), this.z = Math.max(e2.z, Math.min(t2.z, this.z)), this;
    }
    clampScalar(e2, t2) {
      return this.x = Math.max(e2, Math.min(t2, this.x)), this.y = Math.max(e2, Math.min(t2, this.y)), this.z = Math.max(e2, Math.min(t2, this.z)), this;
    }
    clampLength(e2, t2) {
      const n2 = this.length();
      return this.divideScalar(n2 || 1).multiplyScalar(Math.max(e2, Math.min(t2, n2)));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
    }
    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
    }
    dot(e2) {
      return this.x * e2.x + this.y * e2.y + this.z * e2.z;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(e2) {
      return this.normalize().multiplyScalar(e2);
    }
    lerp(e2, t2) {
      return this.x += (e2.x - this.x) * t2, this.y += (e2.y - this.y) * t2, this.z += (e2.z - this.z) * t2, this;
    }
    lerpVectors(e2, t2, n2) {
      return this.x = e2.x + (t2.x - e2.x) * n2, this.y = e2.y + (t2.y - e2.y) * n2, this.z = e2.z + (t2.z - e2.z) * n2, this;
    }
    cross(e2) {
      return this.crossVectors(this, e2);
    }
    crossVectors(e2, t2) {
      const n2 = e2.x, r2 = e2.y, i2 = e2.z, s2 = t2.x, o2 = t2.y, a2 = t2.z;
      return this.x = r2 * a2 - i2 * o2, this.y = i2 * s2 - n2 * a2, this.z = n2 * o2 - r2 * s2, this;
    }
    projectOnVector(e2) {
      const t2 = e2.lengthSq();
      if (0 === t2)
        return this.set(0, 0, 0);
      const n2 = e2.dot(this) / t2;
      return this.copy(e2).multiplyScalar(n2);
    }
    projectOnPlane(e2) {
      return xr.copy(this).projectOnVector(e2), this.sub(xr);
    }
    reflect(e2) {
      return this.sub(xr.copy(e2).multiplyScalar(2 * this.dot(e2)));
    }
    angleTo(e2) {
      const t2 = Math.sqrt(this.lengthSq() * e2.lengthSq());
      if (0 === t2)
        return Math.PI / 2;
      const n2 = this.dot(e2) / t2;
      return Math.acos(Ln(n2, -1, 1));
    }
    distanceTo(e2) {
      return Math.sqrt(this.distanceToSquared(e2));
    }
    distanceToSquared(e2) {
      const t2 = this.x - e2.x, n2 = this.y - e2.y, r2 = this.z - e2.z;
      return t2 * t2 + n2 * n2 + r2 * r2;
    }
    manhattanDistanceTo(e2) {
      return Math.abs(this.x - e2.x) + Math.abs(this.y - e2.y) + Math.abs(this.z - e2.z);
    }
    setFromSpherical(e2) {
      return this.setFromSphericalCoords(e2.radius, e2.phi, e2.theta);
    }
    setFromSphericalCoords(e2, t2, n2) {
      const r2 = Math.sin(t2) * e2;
      return this.x = r2 * Math.sin(n2), this.y = Math.cos(t2) * e2, this.z = r2 * Math.cos(n2), this;
    }
    setFromCylindrical(e2) {
      return this.setFromCylindricalCoords(e2.radius, e2.theta, e2.y);
    }
    setFromCylindricalCoords(e2, t2, n2) {
      return this.x = e2 * Math.sin(t2), this.y = n2, this.z = e2 * Math.cos(t2), this;
    }
    setFromMatrixPosition(e2) {
      const t2 = e2.elements;
      return this.x = t2[12], this.y = t2[13], this.z = t2[14], this;
    }
    setFromMatrixScale(e2) {
      const t2 = this.setFromMatrixColumn(e2, 0).length(), n2 = this.setFromMatrixColumn(e2, 1).length(), r2 = this.setFromMatrixColumn(e2, 2).length();
      return this.x = t2, this.y = n2, this.z = r2, this;
    }
    setFromMatrixColumn(e2, t2) {
      return this.fromArray(e2.elements, 4 * t2);
    }
    setFromMatrix3Column(e2, t2) {
      return this.fromArray(e2.elements, 3 * t2);
    }
    setFromEuler(e2) {
      return this.x = e2._x, this.y = e2._y, this.z = e2._z, this;
    }
    setFromColor(e2) {
      return this.x = e2.r, this.y = e2.g, this.z = e2.b, this;
    }
    equals(e2) {
      return e2.x === this.x && e2.y === this.y && e2.z === this.z;
    }
    fromArray(e2, t2 = 0) {
      return this.x = e2[t2], this.y = e2[t2 + 1], this.z = e2[t2 + 2], this;
    }
    toArray(e2 = [], t2 = 0) {
      return e2[t2] = this.x, e2[t2 + 1] = this.y, e2[t2 + 2] = this.z, e2;
    }
    fromBufferAttribute(e2, t2) {
      return this.x = e2.getX(t2), this.y = e2.getY(t2), this.z = e2.getZ(t2), this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
    }
    randomDirection() {
      const e2 = 2 * (Math.random() - 0.5), t2 = Math.random() * Math.PI * 2, n2 = Math.sqrt(1 - e2 ** 2);
      return this.x = n2 * Math.cos(t2), this.y = n2 * Math.sin(t2), this.z = e2, this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z;
    }
  }
  const xr = new Ar(), Er = new wr();
  class Cr {
    constructor(e2 = new Ar(1 / 0, 1 / 0, 1 / 0), t2 = new Ar(-1 / 0, -1 / 0, -1 / 0)) {
      this.isBox3 = true, this.min = e2, this.max = t2;
    }
    set(e2, t2) {
      return this.min.copy(e2), this.max.copy(t2), this;
    }
    setFromArray(e2) {
      this.makeEmpty();
      for (let t2 = 0, n2 = e2.length; t2 < n2; t2 += 3)
        this.expandByPoint(Mr.fromArray(e2, t2));
      return this;
    }
    setFromBufferAttribute(e2) {
      this.makeEmpty();
      for (let t2 = 0, n2 = e2.count; t2 < n2; t2++)
        this.expandByPoint(Mr.fromBufferAttribute(e2, t2));
      return this;
    }
    setFromPoints(e2) {
      this.makeEmpty();
      for (let t2 = 0, n2 = e2.length; t2 < n2; t2++)
        this.expandByPoint(e2[t2]);
      return this;
    }
    setFromCenterAndSize(e2, t2) {
      const n2 = Mr.copy(t2).multiplyScalar(0.5);
      return this.min.copy(e2).sub(n2), this.max.copy(e2).add(n2), this;
    }
    setFromObject(e2, t2 = false) {
      return this.makeEmpty(), this.expandByObject(e2, t2);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e2) {
      return this.min.copy(e2.min), this.max.copy(e2.max), this;
    }
    makeEmpty() {
      return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
    getCenter(e2) {
      return this.isEmpty() ? e2.set(0, 0, 0) : e2.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(e2) {
      return this.isEmpty() ? e2.set(0, 0, 0) : e2.subVectors(this.max, this.min);
    }
    expandByPoint(e2) {
      return this.min.min(e2), this.max.max(e2), this;
    }
    expandByVector(e2) {
      return this.min.sub(e2), this.max.add(e2), this;
    }
    expandByScalar(e2) {
      return this.min.addScalar(-e2), this.max.addScalar(e2), this;
    }
    expandByObject(e2, t2 = false) {
      if (e2.updateWorldMatrix(false, false), void 0 !== e2.boundingBox)
        null === e2.boundingBox && e2.computeBoundingBox(), Tr.copy(e2.boundingBox), Tr.applyMatrix4(e2.matrixWorld), this.union(Tr);
      else {
        const n3 = e2.geometry;
        if (void 0 !== n3)
          if (t2 && void 0 !== n3.attributes && void 0 !== n3.attributes.position) {
            const t3 = n3.attributes.position;
            for (let n4 = 0, r2 = t3.count; n4 < r2; n4++)
              Mr.fromBufferAttribute(t3, n4).applyMatrix4(e2.matrixWorld), this.expandByPoint(Mr);
          } else
            null === n3.boundingBox && n3.computeBoundingBox(), Tr.copy(n3.boundingBox), Tr.applyMatrix4(e2.matrixWorld), this.union(Tr);
      }
      const n2 = e2.children;
      for (let e3 = 0, r2 = n2.length; e3 < r2; e3++)
        this.expandByObject(n2[e3], t2);
      return this;
    }
    containsPoint(e2) {
      return !(e2.x < this.min.x || e2.x > this.max.x || e2.y < this.min.y || e2.y > this.max.y || e2.z < this.min.z || e2.z > this.max.z);
    }
    containsBox(e2) {
      return this.min.x <= e2.min.x && e2.max.x <= this.max.x && this.min.y <= e2.min.y && e2.max.y <= this.max.y && this.min.z <= e2.min.z && e2.max.z <= this.max.z;
    }
    getParameter(e2, t2) {
      return t2.set((e2.x - this.min.x) / (this.max.x - this.min.x), (e2.y - this.min.y) / (this.max.y - this.min.y), (e2.z - this.min.z) / (this.max.z - this.min.z));
    }
    intersectsBox(e2) {
      return !(e2.max.x < this.min.x || e2.min.x > this.max.x || e2.max.y < this.min.y || e2.min.y > this.max.y || e2.max.z < this.min.z || e2.min.z > this.max.z);
    }
    intersectsSphere(e2) {
      return this.clampPoint(e2.center, Mr), Mr.distanceToSquared(e2.center) <= e2.radius * e2.radius;
    }
    intersectsPlane(e2) {
      let t2, n2;
      return e2.normal.x > 0 ? (t2 = e2.normal.x * this.min.x, n2 = e2.normal.x * this.max.x) : (t2 = e2.normal.x * this.max.x, n2 = e2.normal.x * this.min.x), e2.normal.y > 0 ? (t2 += e2.normal.y * this.min.y, n2 += e2.normal.y * this.max.y) : (t2 += e2.normal.y * this.max.y, n2 += e2.normal.y * this.min.y), e2.normal.z > 0 ? (t2 += e2.normal.z * this.min.z, n2 += e2.normal.z * this.max.z) : (t2 += e2.normal.z * this.max.z, n2 += e2.normal.z * this.min.z), t2 <= -e2.constant && n2 >= -e2.constant;
    }
    intersectsTriangle(e2) {
      if (this.isEmpty())
        return false;
      this.getCenter(Or), Lr.subVectors(this.max, Or), Pr.subVectors(e2.a, Or), Ir.subVectors(e2.b, Or), Rr.subVectors(e2.c, Or), kr.subVectors(Ir, Pr), Dr.subVectors(Rr, Ir), Br.subVectors(Pr, Rr);
      let t2 = [0, -kr.z, kr.y, 0, -Dr.z, Dr.y, 0, -Br.z, Br.y, kr.z, 0, -kr.x, Dr.z, 0, -Dr.x, Br.z, 0, -Br.x, -kr.y, kr.x, 0, -Dr.y, Dr.x, 0, -Br.y, Br.x, 0];
      return !!Nr(t2, Pr, Ir, Rr, Lr) && (t2 = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Nr(t2, Pr, Ir, Rr, Lr) && (Ur.crossVectors(kr, Dr), t2 = [Ur.x, Ur.y, Ur.z], Nr(t2, Pr, Ir, Rr, Lr)));
    }
    clampPoint(e2, t2) {
      return t2.copy(e2).clamp(this.min, this.max);
    }
    distanceToPoint(e2) {
      return this.clampPoint(e2, Mr).distanceTo(e2);
    }
    getBoundingSphere(e2) {
      return this.isEmpty() ? e2.makeEmpty() : (this.getCenter(e2.center), e2.radius = 0.5 * this.getSize(Mr).length()), e2;
    }
    intersect(e2) {
      return this.min.max(e2.min), this.max.min(e2.max), this.isEmpty() && this.makeEmpty(), this;
    }
    union(e2) {
      return this.min.min(e2.min), this.max.max(e2.max), this;
    }
    applyMatrix4(e2) {
      return this.isEmpty() || (Sr[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e2), Sr[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e2), Sr[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e2), Sr[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e2), Sr[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e2), Sr[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e2), Sr[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e2), Sr[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e2), this.setFromPoints(Sr)), this;
    }
    translate(e2) {
      return this.min.add(e2), this.max.add(e2), this;
    }
    equals(e2) {
      return e2.min.equals(this.min) && e2.max.equals(this.max);
    }
  }
  const Sr = [new Ar(), new Ar(), new Ar(), new Ar(), new Ar(), new Ar(), new Ar(), new Ar()], Mr = new Ar(), Tr = new Cr(), Pr = new Ar(), Ir = new Ar(), Rr = new Ar(), kr = new Ar(), Dr = new Ar(), Br = new Ar(), Or = new Ar(), Lr = new Ar(), Ur = new Ar(), Fr = new Ar();
  function Nr(e2, t2, n2, r2, i2) {
    for (let s2 = 0, o2 = e2.length - 3; s2 <= o2; s2 += 3) {
      Fr.fromArray(e2, s2);
      const o3 = i2.x * Math.abs(Fr.x) + i2.y * Math.abs(Fr.y) + i2.z * Math.abs(Fr.z), a2 = t2.dot(Fr), l2 = n2.dot(Fr), c2 = r2.dot(Fr);
      if (Math.max(-Math.max(a2, l2, c2), Math.min(a2, l2, c2)) > o3)
        return false;
    }
    return true;
  }
  const jr = new Cr(), zr = new Ar(), Gr = new Ar();
  class Vr {
    constructor(e2 = new Ar(), t2 = -1) {
      this.center = e2, this.radius = t2;
    }
    set(e2, t2) {
      return this.center.copy(e2), this.radius = t2, this;
    }
    setFromPoints(e2, t2) {
      const n2 = this.center;
      void 0 !== t2 ? n2.copy(t2) : jr.setFromPoints(e2).getCenter(n2);
      let r2 = 0;
      for (let t3 = 0, i2 = e2.length; t3 < i2; t3++)
        r2 = Math.max(r2, n2.distanceToSquared(e2[t3]));
      return this.radius = Math.sqrt(r2), this;
    }
    copy(e2) {
      return this.center.copy(e2.center), this.radius = e2.radius, this;
    }
    isEmpty() {
      return this.radius < 0;
    }
    makeEmpty() {
      return this.center.set(0, 0, 0), this.radius = -1, this;
    }
    containsPoint(e2) {
      return e2.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(e2) {
      return e2.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(e2) {
      const t2 = this.radius + e2.radius;
      return e2.center.distanceToSquared(this.center) <= t2 * t2;
    }
    intersectsBox(e2) {
      return e2.intersectsSphere(this);
    }
    intersectsPlane(e2) {
      return Math.abs(e2.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(e2, t2) {
      const n2 = this.center.distanceToSquared(e2);
      return t2.copy(e2), n2 > this.radius * this.radius && (t2.sub(this.center).normalize(), t2.multiplyScalar(this.radius).add(this.center)), t2;
    }
    getBoundingBox(e2) {
      return this.isEmpty() ? (e2.makeEmpty(), e2) : (e2.set(this.center, this.center), e2.expandByScalar(this.radius), e2);
    }
    applyMatrix4(e2) {
      return this.center.applyMatrix4(e2), this.radius = this.radius * e2.getMaxScaleOnAxis(), this;
    }
    translate(e2) {
      return this.center.add(e2), this;
    }
    expandByPoint(e2) {
      if (this.isEmpty())
        return this.center.copy(e2), this.radius = 0, this;
      zr.subVectors(e2, this.center);
      const t2 = zr.lengthSq();
      if (t2 > this.radius * this.radius) {
        const e3 = Math.sqrt(t2), n2 = 0.5 * (e3 - this.radius);
        this.center.addScaledVector(zr, n2 / e3), this.radius += n2;
      }
      return this;
    }
    union(e2) {
      return e2.isEmpty() ? this : this.isEmpty() ? (this.copy(e2), this) : (true === this.center.equals(e2.center) ? this.radius = Math.max(this.radius, e2.radius) : (Gr.subVectors(e2.center, this.center).setLength(e2.radius), this.expandByPoint(zr.copy(e2.center).add(Gr)), this.expandByPoint(zr.copy(e2.center).sub(Gr))), this);
    }
    equals(e2) {
      return e2.center.equals(this.center) && e2.radius === this.radius;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const Hr = new Ar(), Qr = new Ar(), Wr = new Ar(), qr = new Ar(), Xr = new Ar(), Yr = new Ar(), Kr = new Ar();
  class Jr {
    constructor(e2 = new Ar(), t2 = new Ar(0, 0, -1)) {
      this.origin = e2, this.direction = t2;
    }
    set(e2, t2) {
      return this.origin.copy(e2), this.direction.copy(t2), this;
    }
    copy(e2) {
      return this.origin.copy(e2.origin), this.direction.copy(e2.direction), this;
    }
    at(e2, t2) {
      return t2.copy(this.origin).addScaledVector(this.direction, e2);
    }
    lookAt(e2) {
      return this.direction.copy(e2).sub(this.origin).normalize(), this;
    }
    recast(e2) {
      return this.origin.copy(this.at(e2, Hr)), this;
    }
    closestPointToPoint(e2, t2) {
      t2.subVectors(e2, this.origin);
      const n2 = t2.dot(this.direction);
      return n2 < 0 ? t2.copy(this.origin) : t2.copy(this.origin).addScaledVector(this.direction, n2);
    }
    distanceToPoint(e2) {
      return Math.sqrt(this.distanceSqToPoint(e2));
    }
    distanceSqToPoint(e2) {
      const t2 = Hr.subVectors(e2, this.origin).dot(this.direction);
      return t2 < 0 ? this.origin.distanceToSquared(e2) : (Hr.copy(this.origin).addScaledVector(this.direction, t2), Hr.distanceToSquared(e2));
    }
    distanceSqToSegment(e2, t2, n2, r2) {
      Qr.copy(e2).add(t2).multiplyScalar(0.5), Wr.copy(t2).sub(e2).normalize(), qr.copy(this.origin).sub(Qr);
      const i2 = 0.5 * e2.distanceTo(t2), s2 = -this.direction.dot(Wr), o2 = qr.dot(this.direction), a2 = -qr.dot(Wr), l2 = qr.lengthSq(), c2 = Math.abs(1 - s2 * s2);
      let u2, p2, d2, h2;
      if (c2 > 0)
        if (u2 = s2 * a2 - o2, p2 = s2 * o2 - a2, h2 = i2 * c2, u2 >= 0)
          if (p2 >= -h2)
            if (p2 <= h2) {
              const e3 = 1 / c2;
              u2 *= e3, p2 *= e3, d2 = u2 * (u2 + s2 * p2 + 2 * o2) + p2 * (s2 * u2 + p2 + 2 * a2) + l2;
            } else
              p2 = i2, u2 = Math.max(0, -(s2 * p2 + o2)), d2 = -u2 * u2 + p2 * (p2 + 2 * a2) + l2;
          else
            p2 = -i2, u2 = Math.max(0, -(s2 * p2 + o2)), d2 = -u2 * u2 + p2 * (p2 + 2 * a2) + l2;
        else
          p2 <= -h2 ? (u2 = Math.max(0, -(-s2 * i2 + o2)), p2 = u2 > 0 ? -i2 : Math.min(Math.max(-i2, -a2), i2), d2 = -u2 * u2 + p2 * (p2 + 2 * a2) + l2) : p2 <= h2 ? (u2 = 0, p2 = Math.min(Math.max(-i2, -a2), i2), d2 = p2 * (p2 + 2 * a2) + l2) : (u2 = Math.max(0, -(s2 * i2 + o2)), p2 = u2 > 0 ? i2 : Math.min(Math.max(-i2, -a2), i2), d2 = -u2 * u2 + p2 * (p2 + 2 * a2) + l2);
      else
        p2 = s2 > 0 ? -i2 : i2, u2 = Math.max(0, -(s2 * p2 + o2)), d2 = -u2 * u2 + p2 * (p2 + 2 * a2) + l2;
      return n2 && n2.copy(this.origin).addScaledVector(this.direction, u2), r2 && r2.copy(Qr).addScaledVector(Wr, p2), d2;
    }
    intersectSphere(e2, t2) {
      Hr.subVectors(e2.center, this.origin);
      const n2 = Hr.dot(this.direction), r2 = Hr.dot(Hr) - n2 * n2, i2 = e2.radius * e2.radius;
      if (r2 > i2)
        return null;
      const s2 = Math.sqrt(i2 - r2), o2 = n2 - s2, a2 = n2 + s2;
      return a2 < 0 ? null : o2 < 0 ? this.at(a2, t2) : this.at(o2, t2);
    }
    intersectsSphere(e2) {
      return this.distanceSqToPoint(e2.center) <= e2.radius * e2.radius;
    }
    distanceToPlane(e2) {
      const t2 = e2.normal.dot(this.direction);
      if (0 === t2)
        return 0 === e2.distanceToPoint(this.origin) ? 0 : null;
      const n2 = -(this.origin.dot(e2.normal) + e2.constant) / t2;
      return n2 >= 0 ? n2 : null;
    }
    intersectPlane(e2, t2) {
      const n2 = this.distanceToPlane(e2);
      return null === n2 ? null : this.at(n2, t2);
    }
    intersectsPlane(e2) {
      const t2 = e2.distanceToPoint(this.origin);
      return 0 === t2 || e2.normal.dot(this.direction) * t2 < 0;
    }
    intersectBox(e2, t2) {
      let n2, r2, i2, s2, o2, a2;
      const l2 = 1 / this.direction.x, c2 = 1 / this.direction.y, u2 = 1 / this.direction.z, p2 = this.origin;
      return l2 >= 0 ? (n2 = (e2.min.x - p2.x) * l2, r2 = (e2.max.x - p2.x) * l2) : (n2 = (e2.max.x - p2.x) * l2, r2 = (e2.min.x - p2.x) * l2), c2 >= 0 ? (i2 = (e2.min.y - p2.y) * c2, s2 = (e2.max.y - p2.y) * c2) : (i2 = (e2.max.y - p2.y) * c2, s2 = (e2.min.y - p2.y) * c2), n2 > s2 || i2 > r2 ? null : ((i2 > n2 || isNaN(n2)) && (n2 = i2), (s2 < r2 || isNaN(r2)) && (r2 = s2), u2 >= 0 ? (o2 = (e2.min.z - p2.z) * u2, a2 = (e2.max.z - p2.z) * u2) : (o2 = (e2.max.z - p2.z) * u2, a2 = (e2.min.z - p2.z) * u2), n2 > a2 || o2 > r2 ? null : ((o2 > n2 || n2 != n2) && (n2 = o2), (a2 < r2 || r2 != r2) && (r2 = a2), r2 < 0 ? null : this.at(n2 >= 0 ? n2 : r2, t2)));
    }
    intersectsBox(e2) {
      return null !== this.intersectBox(e2, Hr);
    }
    intersectTriangle(e2, t2, n2, r2, i2) {
      Xr.subVectors(t2, e2), Yr.subVectors(n2, e2), Kr.crossVectors(Xr, Yr);
      let s2, o2 = this.direction.dot(Kr);
      if (o2 > 0) {
        if (r2)
          return null;
        s2 = 1;
      } else {
        if (!(o2 < 0))
          return null;
        s2 = -1, o2 = -o2;
      }
      qr.subVectors(this.origin, e2);
      const a2 = s2 * this.direction.dot(Yr.crossVectors(qr, Yr));
      if (a2 < 0)
        return null;
      const l2 = s2 * this.direction.dot(Xr.cross(qr));
      if (l2 < 0)
        return null;
      if (a2 + l2 > o2)
        return null;
      const c2 = -s2 * qr.dot(Kr);
      return c2 < 0 ? null : this.at(c2 / o2, i2);
    }
    applyMatrix4(e2) {
      return this.origin.applyMatrix4(e2), this.direction.transformDirection(e2), this;
    }
    equals(e2) {
      return e2.origin.equals(this.origin) && e2.direction.equals(this.direction);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class Zr {
    constructor(e2, t2, n2, r2, i2, s2, o2, a2, l2, c2, u2, p2, d2, h2, f2, m2) {
      Zr.prototype.isMatrix4 = true, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], void 0 !== e2 && this.set(e2, t2, n2, r2, i2, s2, o2, a2, l2, c2, u2, p2, d2, h2, f2, m2);
    }
    set(e2, t2, n2, r2, i2, s2, o2, a2, l2, c2, u2, p2, d2, h2, f2, m2) {
      const _2 = this.elements;
      return _2[0] = e2, _2[4] = t2, _2[8] = n2, _2[12] = r2, _2[1] = i2, _2[5] = s2, _2[9] = o2, _2[13] = a2, _2[2] = l2, _2[6] = c2, _2[10] = u2, _2[14] = p2, _2[3] = d2, _2[7] = h2, _2[11] = f2, _2[15] = m2, this;
    }
    identity() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    clone() {
      return new Zr().fromArray(this.elements);
    }
    copy(e2) {
      const t2 = this.elements, n2 = e2.elements;
      return t2[0] = n2[0], t2[1] = n2[1], t2[2] = n2[2], t2[3] = n2[3], t2[4] = n2[4], t2[5] = n2[5], t2[6] = n2[6], t2[7] = n2[7], t2[8] = n2[8], t2[9] = n2[9], t2[10] = n2[10], t2[11] = n2[11], t2[12] = n2[12], t2[13] = n2[13], t2[14] = n2[14], t2[15] = n2[15], this;
    }
    copyPosition(e2) {
      const t2 = this.elements, n2 = e2.elements;
      return t2[12] = n2[12], t2[13] = n2[13], t2[14] = n2[14], this;
    }
    setFromMatrix3(e2) {
      const t2 = e2.elements;
      return this.set(t2[0], t2[3], t2[6], 0, t2[1], t2[4], t2[7], 0, t2[2], t2[5], t2[8], 0, 0, 0, 0, 1), this;
    }
    extractBasis(e2, t2, n2) {
      return e2.setFromMatrixColumn(this, 0), t2.setFromMatrixColumn(this, 1), n2.setFromMatrixColumn(this, 2), this;
    }
    makeBasis(e2, t2, n2) {
      return this.set(e2.x, t2.x, n2.x, 0, e2.y, t2.y, n2.y, 0, e2.z, t2.z, n2.z, 0, 0, 0, 0, 1), this;
    }
    extractRotation(e2) {
      const t2 = this.elements, n2 = e2.elements, r2 = 1 / $r.setFromMatrixColumn(e2, 0).length(), i2 = 1 / $r.setFromMatrixColumn(e2, 1).length(), s2 = 1 / $r.setFromMatrixColumn(e2, 2).length();
      return t2[0] = n2[0] * r2, t2[1] = n2[1] * r2, t2[2] = n2[2] * r2, t2[3] = 0, t2[4] = n2[4] * i2, t2[5] = n2[5] * i2, t2[6] = n2[6] * i2, t2[7] = 0, t2[8] = n2[8] * s2, t2[9] = n2[9] * s2, t2[10] = n2[10] * s2, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, this;
    }
    makeRotationFromEuler(e2) {
      const t2 = this.elements, n2 = e2.x, r2 = e2.y, i2 = e2.z, s2 = Math.cos(n2), o2 = Math.sin(n2), a2 = Math.cos(r2), l2 = Math.sin(r2), c2 = Math.cos(i2), u2 = Math.sin(i2);
      if ("XYZ" === e2.order) {
        const e3 = s2 * c2, n3 = s2 * u2, r3 = o2 * c2, i3 = o2 * u2;
        t2[0] = a2 * c2, t2[4] = -a2 * u2, t2[8] = l2, t2[1] = n3 + r3 * l2, t2[5] = e3 - i3 * l2, t2[9] = -o2 * a2, t2[2] = i3 - e3 * l2, t2[6] = r3 + n3 * l2, t2[10] = s2 * a2;
      } else if ("YXZ" === e2.order) {
        const e3 = a2 * c2, n3 = a2 * u2, r3 = l2 * c2, i3 = l2 * u2;
        t2[0] = e3 + i3 * o2, t2[4] = r3 * o2 - n3, t2[8] = s2 * l2, t2[1] = s2 * u2, t2[5] = s2 * c2, t2[9] = -o2, t2[2] = n3 * o2 - r3, t2[6] = i3 + e3 * o2, t2[10] = s2 * a2;
      } else if ("ZXY" === e2.order) {
        const e3 = a2 * c2, n3 = a2 * u2, r3 = l2 * c2, i3 = l2 * u2;
        t2[0] = e3 - i3 * o2, t2[4] = -s2 * u2, t2[8] = r3 + n3 * o2, t2[1] = n3 + r3 * o2, t2[5] = s2 * c2, t2[9] = i3 - e3 * o2, t2[2] = -s2 * l2, t2[6] = o2, t2[10] = s2 * a2;
      } else if ("ZYX" === e2.order) {
        const e3 = s2 * c2, n3 = s2 * u2, r3 = o2 * c2, i3 = o2 * u2;
        t2[0] = a2 * c2, t2[4] = r3 * l2 - n3, t2[8] = e3 * l2 + i3, t2[1] = a2 * u2, t2[5] = i3 * l2 + e3, t2[9] = n3 * l2 - r3, t2[2] = -l2, t2[6] = o2 * a2, t2[10] = s2 * a2;
      } else if ("YZX" === e2.order) {
        const e3 = s2 * a2, n3 = s2 * l2, r3 = o2 * a2, i3 = o2 * l2;
        t2[0] = a2 * c2, t2[4] = i3 - e3 * u2, t2[8] = r3 * u2 + n3, t2[1] = u2, t2[5] = s2 * c2, t2[9] = -o2 * c2, t2[2] = -l2 * c2, t2[6] = n3 * u2 + r3, t2[10] = e3 - i3 * u2;
      } else if ("XZY" === e2.order) {
        const e3 = s2 * a2, n3 = s2 * l2, r3 = o2 * a2, i3 = o2 * l2;
        t2[0] = a2 * c2, t2[4] = -u2, t2[8] = l2 * c2, t2[1] = e3 * u2 + i3, t2[5] = s2 * c2, t2[9] = n3 * u2 - r3, t2[2] = r3 * u2 - n3, t2[6] = o2 * c2, t2[10] = i3 * u2 + e3;
      }
      return t2[3] = 0, t2[7] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, this;
    }
    makeRotationFromQuaternion(e2) {
      return this.compose(ti, e2, ni);
    }
    lookAt(e2, t2, n2) {
      const r2 = this.elements;
      return si.subVectors(e2, t2), 0 === si.lengthSq() && (si.z = 1), si.normalize(), ri.crossVectors(n2, si), 0 === ri.lengthSq() && (1 === Math.abs(n2.z) ? si.x += 1e-4 : si.z += 1e-4, si.normalize(), ri.crossVectors(n2, si)), ri.normalize(), ii.crossVectors(si, ri), r2[0] = ri.x, r2[4] = ii.x, r2[8] = si.x, r2[1] = ri.y, r2[5] = ii.y, r2[9] = si.y, r2[2] = ri.z, r2[6] = ii.z, r2[10] = si.z, this;
    }
    multiply(e2) {
      return this.multiplyMatrices(this, e2);
    }
    premultiply(e2) {
      return this.multiplyMatrices(e2, this);
    }
    multiplyMatrices(e2, t2) {
      const n2 = e2.elements, r2 = t2.elements, i2 = this.elements, s2 = n2[0], o2 = n2[4], a2 = n2[8], l2 = n2[12], c2 = n2[1], u2 = n2[5], p2 = n2[9], d2 = n2[13], h2 = n2[2], f2 = n2[6], m2 = n2[10], _2 = n2[14], g2 = n2[3], v2 = n2[7], y2 = n2[11], b2 = n2[15], w2 = r2[0], A2 = r2[4], x2 = r2[8], E2 = r2[12], C2 = r2[1], S2 = r2[5], M2 = r2[9], T2 = r2[13], P2 = r2[2], I2 = r2[6], R2 = r2[10], k2 = r2[14], D2 = r2[3], B2 = r2[7], O2 = r2[11], L2 = r2[15];
      return i2[0] = s2 * w2 + o2 * C2 + a2 * P2 + l2 * D2, i2[4] = s2 * A2 + o2 * S2 + a2 * I2 + l2 * B2, i2[8] = s2 * x2 + o2 * M2 + a2 * R2 + l2 * O2, i2[12] = s2 * E2 + o2 * T2 + a2 * k2 + l2 * L2, i2[1] = c2 * w2 + u2 * C2 + p2 * P2 + d2 * D2, i2[5] = c2 * A2 + u2 * S2 + p2 * I2 + d2 * B2, i2[9] = c2 * x2 + u2 * M2 + p2 * R2 + d2 * O2, i2[13] = c2 * E2 + u2 * T2 + p2 * k2 + d2 * L2, i2[2] = h2 * w2 + f2 * C2 + m2 * P2 + _2 * D2, i2[6] = h2 * A2 + f2 * S2 + m2 * I2 + _2 * B2, i2[10] = h2 * x2 + f2 * M2 + m2 * R2 + _2 * O2, i2[14] = h2 * E2 + f2 * T2 + m2 * k2 + _2 * L2, i2[3] = g2 * w2 + v2 * C2 + y2 * P2 + b2 * D2, i2[7] = g2 * A2 + v2 * S2 + y2 * I2 + b2 * B2, i2[11] = g2 * x2 + v2 * M2 + y2 * R2 + b2 * O2, i2[15] = g2 * E2 + v2 * T2 + y2 * k2 + b2 * L2, this;
    }
    multiplyScalar(e2) {
      const t2 = this.elements;
      return t2[0] *= e2, t2[4] *= e2, t2[8] *= e2, t2[12] *= e2, t2[1] *= e2, t2[5] *= e2, t2[9] *= e2, t2[13] *= e2, t2[2] *= e2, t2[6] *= e2, t2[10] *= e2, t2[14] *= e2, t2[3] *= e2, t2[7] *= e2, t2[11] *= e2, t2[15] *= e2, this;
    }
    determinant() {
      const e2 = this.elements, t2 = e2[0], n2 = e2[4], r2 = e2[8], i2 = e2[12], s2 = e2[1], o2 = e2[5], a2 = e2[9], l2 = e2[13], c2 = e2[2], u2 = e2[6], p2 = e2[10], d2 = e2[14];
      return e2[3] * (+i2 * a2 * u2 - r2 * l2 * u2 - i2 * o2 * p2 + n2 * l2 * p2 + r2 * o2 * d2 - n2 * a2 * d2) + e2[7] * (+t2 * a2 * d2 - t2 * l2 * p2 + i2 * s2 * p2 - r2 * s2 * d2 + r2 * l2 * c2 - i2 * a2 * c2) + e2[11] * (+t2 * l2 * u2 - t2 * o2 * d2 - i2 * s2 * u2 + n2 * s2 * d2 + i2 * o2 * c2 - n2 * l2 * c2) + e2[15] * (-r2 * o2 * c2 - t2 * a2 * u2 + t2 * o2 * p2 + r2 * s2 * u2 - n2 * s2 * p2 + n2 * a2 * c2);
    }
    transpose() {
      const e2 = this.elements;
      let t2;
      return t2 = e2[1], e2[1] = e2[4], e2[4] = t2, t2 = e2[2], e2[2] = e2[8], e2[8] = t2, t2 = e2[6], e2[6] = e2[9], e2[9] = t2, t2 = e2[3], e2[3] = e2[12], e2[12] = t2, t2 = e2[7], e2[7] = e2[13], e2[13] = t2, t2 = e2[11], e2[11] = e2[14], e2[14] = t2, this;
    }
    setPosition(e2, t2, n2) {
      const r2 = this.elements;
      return e2.isVector3 ? (r2[12] = e2.x, r2[13] = e2.y, r2[14] = e2.z) : (r2[12] = e2, r2[13] = t2, r2[14] = n2), this;
    }
    invert() {
      const e2 = this.elements, t2 = e2[0], n2 = e2[1], r2 = e2[2], i2 = e2[3], s2 = e2[4], o2 = e2[5], a2 = e2[6], l2 = e2[7], c2 = e2[8], u2 = e2[9], p2 = e2[10], d2 = e2[11], h2 = e2[12], f2 = e2[13], m2 = e2[14], _2 = e2[15], g2 = u2 * m2 * l2 - f2 * p2 * l2 + f2 * a2 * d2 - o2 * m2 * d2 - u2 * a2 * _2 + o2 * p2 * _2, v2 = h2 * p2 * l2 - c2 * m2 * l2 - h2 * a2 * d2 + s2 * m2 * d2 + c2 * a2 * _2 - s2 * p2 * _2, y2 = c2 * f2 * l2 - h2 * u2 * l2 + h2 * o2 * d2 - s2 * f2 * d2 - c2 * o2 * _2 + s2 * u2 * _2, b2 = h2 * u2 * a2 - c2 * f2 * a2 - h2 * o2 * p2 + s2 * f2 * p2 + c2 * o2 * m2 - s2 * u2 * m2, w2 = t2 * g2 + n2 * v2 + r2 * y2 + i2 * b2;
      if (0 === w2)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      const A2 = 1 / w2;
      return e2[0] = g2 * A2, e2[1] = (f2 * p2 * i2 - u2 * m2 * i2 - f2 * r2 * d2 + n2 * m2 * d2 + u2 * r2 * _2 - n2 * p2 * _2) * A2, e2[2] = (o2 * m2 * i2 - f2 * a2 * i2 + f2 * r2 * l2 - n2 * m2 * l2 - o2 * r2 * _2 + n2 * a2 * _2) * A2, e2[3] = (u2 * a2 * i2 - o2 * p2 * i2 - u2 * r2 * l2 + n2 * p2 * l2 + o2 * r2 * d2 - n2 * a2 * d2) * A2, e2[4] = v2 * A2, e2[5] = (c2 * m2 * i2 - h2 * p2 * i2 + h2 * r2 * d2 - t2 * m2 * d2 - c2 * r2 * _2 + t2 * p2 * _2) * A2, e2[6] = (h2 * a2 * i2 - s2 * m2 * i2 - h2 * r2 * l2 + t2 * m2 * l2 + s2 * r2 * _2 - t2 * a2 * _2) * A2, e2[7] = (s2 * p2 * i2 - c2 * a2 * i2 + c2 * r2 * l2 - t2 * p2 * l2 - s2 * r2 * d2 + t2 * a2 * d2) * A2, e2[8] = y2 * A2, e2[9] = (h2 * u2 * i2 - c2 * f2 * i2 - h2 * n2 * d2 + t2 * f2 * d2 + c2 * n2 * _2 - t2 * u2 * _2) * A2, e2[10] = (s2 * f2 * i2 - h2 * o2 * i2 + h2 * n2 * l2 - t2 * f2 * l2 - s2 * n2 * _2 + t2 * o2 * _2) * A2, e2[11] = (c2 * o2 * i2 - s2 * u2 * i2 - c2 * n2 * l2 + t2 * u2 * l2 + s2 * n2 * d2 - t2 * o2 * d2) * A2, e2[12] = b2 * A2, e2[13] = (c2 * f2 * r2 - h2 * u2 * r2 + h2 * n2 * p2 - t2 * f2 * p2 - c2 * n2 * m2 + t2 * u2 * m2) * A2, e2[14] = (h2 * o2 * r2 - s2 * f2 * r2 - h2 * n2 * a2 + t2 * f2 * a2 + s2 * n2 * m2 - t2 * o2 * m2) * A2, e2[15] = (s2 * u2 * r2 - c2 * o2 * r2 + c2 * n2 * a2 - t2 * u2 * a2 - s2 * n2 * p2 + t2 * o2 * p2) * A2, this;
    }
    scale(e2) {
      const t2 = this.elements, n2 = e2.x, r2 = e2.y, i2 = e2.z;
      return t2[0] *= n2, t2[4] *= r2, t2[8] *= i2, t2[1] *= n2, t2[5] *= r2, t2[9] *= i2, t2[2] *= n2, t2[6] *= r2, t2[10] *= i2, t2[3] *= n2, t2[7] *= r2, t2[11] *= i2, this;
    }
    getMaxScaleOnAxis() {
      const e2 = this.elements, t2 = e2[0] * e2[0] + e2[1] * e2[1] + e2[2] * e2[2], n2 = e2[4] * e2[4] + e2[5] * e2[5] + e2[6] * e2[6], r2 = e2[8] * e2[8] + e2[9] * e2[9] + e2[10] * e2[10];
      return Math.sqrt(Math.max(t2, n2, r2));
    }
    makeTranslation(e2, t2, n2) {
      return e2.isVector3 ? this.set(1, 0, 0, e2.x, 0, 1, 0, e2.y, 0, 0, 1, e2.z, 0, 0, 0, 1) : this.set(1, 0, 0, e2, 0, 1, 0, t2, 0, 0, 1, n2, 0, 0, 0, 1), this;
    }
    makeRotationX(e2) {
      const t2 = Math.cos(e2), n2 = Math.sin(e2);
      return this.set(1, 0, 0, 0, 0, t2, -n2, 0, 0, n2, t2, 0, 0, 0, 0, 1), this;
    }
    makeRotationY(e2) {
      const t2 = Math.cos(e2), n2 = Math.sin(e2);
      return this.set(t2, 0, n2, 0, 0, 1, 0, 0, -n2, 0, t2, 0, 0, 0, 0, 1), this;
    }
    makeRotationZ(e2) {
      const t2 = Math.cos(e2), n2 = Math.sin(e2);
      return this.set(t2, -n2, 0, 0, n2, t2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    makeRotationAxis(e2, t2) {
      const n2 = Math.cos(t2), r2 = Math.sin(t2), i2 = 1 - n2, s2 = e2.x, o2 = e2.y, a2 = e2.z, l2 = i2 * s2, c2 = i2 * o2;
      return this.set(l2 * s2 + n2, l2 * o2 - r2 * a2, l2 * a2 + r2 * o2, 0, l2 * o2 + r2 * a2, c2 * o2 + n2, c2 * a2 - r2 * s2, 0, l2 * a2 - r2 * o2, c2 * a2 + r2 * s2, i2 * a2 * a2 + n2, 0, 0, 0, 0, 1), this;
    }
    makeScale(e2, t2, n2) {
      return this.set(e2, 0, 0, 0, 0, t2, 0, 0, 0, 0, n2, 0, 0, 0, 0, 1), this;
    }
    makeShear(e2, t2, n2, r2, i2, s2) {
      return this.set(1, n2, i2, 0, e2, 1, s2, 0, t2, r2, 1, 0, 0, 0, 0, 1), this;
    }
    compose(e2, t2, n2) {
      const r2 = this.elements, i2 = t2._x, s2 = t2._y, o2 = t2._z, a2 = t2._w, l2 = i2 + i2, c2 = s2 + s2, u2 = o2 + o2, p2 = i2 * l2, d2 = i2 * c2, h2 = i2 * u2, f2 = s2 * c2, m2 = s2 * u2, _2 = o2 * u2, g2 = a2 * l2, v2 = a2 * c2, y2 = a2 * u2, b2 = n2.x, w2 = n2.y, A2 = n2.z;
      return r2[0] = (1 - (f2 + _2)) * b2, r2[1] = (d2 + y2) * b2, r2[2] = (h2 - v2) * b2, r2[3] = 0, r2[4] = (d2 - y2) * w2, r2[5] = (1 - (p2 + _2)) * w2, r2[6] = (m2 + g2) * w2, r2[7] = 0, r2[8] = (h2 + v2) * A2, r2[9] = (m2 - g2) * A2, r2[10] = (1 - (p2 + f2)) * A2, r2[11] = 0, r2[12] = e2.x, r2[13] = e2.y, r2[14] = e2.z, r2[15] = 1, this;
    }
    decompose(e2, t2, n2) {
      const r2 = this.elements;
      let i2 = $r.set(r2[0], r2[1], r2[2]).length();
      const s2 = $r.set(r2[4], r2[5], r2[6]).length(), o2 = $r.set(r2[8], r2[9], r2[10]).length();
      this.determinant() < 0 && (i2 = -i2), e2.x = r2[12], e2.y = r2[13], e2.z = r2[14], ei.copy(this);
      const a2 = 1 / i2, l2 = 1 / s2, c2 = 1 / o2;
      return ei.elements[0] *= a2, ei.elements[1] *= a2, ei.elements[2] *= a2, ei.elements[4] *= l2, ei.elements[5] *= l2, ei.elements[6] *= l2, ei.elements[8] *= c2, ei.elements[9] *= c2, ei.elements[10] *= c2, t2.setFromRotationMatrix(ei), n2.x = i2, n2.y = s2, n2.z = o2, this;
    }
    makePerspective(e2, t2, n2, r2, i2, s2, o2 = Tn) {
      const a2 = this.elements, l2 = 2 * i2 / (t2 - e2), c2 = 2 * i2 / (n2 - r2), u2 = (t2 + e2) / (t2 - e2), p2 = (n2 + r2) / (n2 - r2);
      let d2, h2;
      if (o2 === Tn)
        d2 = -(s2 + i2) / (s2 - i2), h2 = -2 * s2 * i2 / (s2 - i2);
      else {
        if (o2 !== Pn)
          throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o2);
        d2 = -s2 / (s2 - i2), h2 = -s2 * i2 / (s2 - i2);
      }
      return a2[0] = l2, a2[4] = 0, a2[8] = u2, a2[12] = 0, a2[1] = 0, a2[5] = c2, a2[9] = p2, a2[13] = 0, a2[2] = 0, a2[6] = 0, a2[10] = d2, a2[14] = h2, a2[3] = 0, a2[7] = 0, a2[11] = -1, a2[15] = 0, this;
    }
    makeOrthographic(e2, t2, n2, r2, i2, s2, o2 = Tn) {
      const a2 = this.elements, l2 = 1 / (t2 - e2), c2 = 1 / (n2 - r2), u2 = 1 / (s2 - i2), p2 = (t2 + e2) * l2, d2 = (n2 + r2) * c2;
      let h2, f2;
      if (o2 === Tn)
        h2 = (s2 + i2) * u2, f2 = -2 * u2;
      else {
        if (o2 !== Pn)
          throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o2);
        h2 = i2 * u2, f2 = -1 * u2;
      }
      return a2[0] = 2 * l2, a2[4] = 0, a2[8] = 0, a2[12] = -p2, a2[1] = 0, a2[5] = 2 * c2, a2[9] = 0, a2[13] = -d2, a2[2] = 0, a2[6] = 0, a2[10] = f2, a2[14] = -h2, a2[3] = 0, a2[7] = 0, a2[11] = 0, a2[15] = 1, this;
    }
    equals(e2) {
      const t2 = this.elements, n2 = e2.elements;
      for (let e3 = 0; e3 < 16; e3++)
        if (t2[e3] !== n2[e3])
          return false;
      return true;
    }
    fromArray(e2, t2 = 0) {
      for (let n2 = 0; n2 < 16; n2++)
        this.elements[n2] = e2[n2 + t2];
      return this;
    }
    toArray(e2 = [], t2 = 0) {
      const n2 = this.elements;
      return e2[t2] = n2[0], e2[t2 + 1] = n2[1], e2[t2 + 2] = n2[2], e2[t2 + 3] = n2[3], e2[t2 + 4] = n2[4], e2[t2 + 5] = n2[5], e2[t2 + 6] = n2[6], e2[t2 + 7] = n2[7], e2[t2 + 8] = n2[8], e2[t2 + 9] = n2[9], e2[t2 + 10] = n2[10], e2[t2 + 11] = n2[11], e2[t2 + 12] = n2[12], e2[t2 + 13] = n2[13], e2[t2 + 14] = n2[14], e2[t2 + 15] = n2[15], e2;
    }
  }
  const $r = new Ar(), ei = new Zr(), ti = new Ar(0, 0, 0), ni = new Ar(1, 1, 1), ri = new Ar(), ii = new Ar(), si = new Ar(), oi = new Zr(), ai = new wr();
  class li {
    constructor(e2 = 0, t2 = 0, n2 = 0, r2 = li.DEFAULT_ORDER) {
      this.isEuler = true, this._x = e2, this._y = t2, this._z = n2, this._order = r2;
    }
    get x() {
      return this._x;
    }
    set x(e2) {
      this._x = e2, this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(e2) {
      this._y = e2, this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(e2) {
      this._z = e2, this._onChangeCallback();
    }
    get order() {
      return this._order;
    }
    set order(e2) {
      this._order = e2, this._onChangeCallback();
    }
    set(e2, t2, n2, r2 = this._order) {
      return this._x = e2, this._y = t2, this._z = n2, this._order = r2, this._onChangeCallback(), this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(e2) {
      return this._x = e2._x, this._y = e2._y, this._z = e2._z, this._order = e2._order, this._onChangeCallback(), this;
    }
    setFromRotationMatrix(e2, t2 = this._order, n2 = true) {
      const r2 = e2.elements, i2 = r2[0], s2 = r2[4], o2 = r2[8], a2 = r2[1], l2 = r2[5], c2 = r2[9], u2 = r2[2], p2 = r2[6], d2 = r2[10];
      switch (t2) {
        case "XYZ":
          this._y = Math.asin(Ln(o2, -1, 1)), Math.abs(o2) < 0.9999999 ? (this._x = Math.atan2(-c2, d2), this._z = Math.atan2(-s2, i2)) : (this._x = Math.atan2(p2, l2), this._z = 0);
          break;
        case "YXZ":
          this._x = Math.asin(-Ln(c2, -1, 1)), Math.abs(c2) < 0.9999999 ? (this._y = Math.atan2(o2, d2), this._z = Math.atan2(a2, l2)) : (this._y = Math.atan2(-u2, i2), this._z = 0);
          break;
        case "ZXY":
          this._x = Math.asin(Ln(p2, -1, 1)), Math.abs(p2) < 0.9999999 ? (this._y = Math.atan2(-u2, d2), this._z = Math.atan2(-s2, l2)) : (this._y = 0, this._z = Math.atan2(a2, i2));
          break;
        case "ZYX":
          this._y = Math.asin(-Ln(u2, -1, 1)), Math.abs(u2) < 0.9999999 ? (this._x = Math.atan2(p2, d2), this._z = Math.atan2(a2, i2)) : (this._x = 0, this._z = Math.atan2(-s2, l2));
          break;
        case "YZX":
          this._z = Math.asin(Ln(a2, -1, 1)), Math.abs(a2) < 0.9999999 ? (this._x = Math.atan2(-c2, l2), this._y = Math.atan2(-u2, i2)) : (this._x = 0, this._y = Math.atan2(o2, d2));
          break;
        case "XZY":
          this._z = Math.asin(-Ln(s2, -1, 1)), Math.abs(s2) < 0.9999999 ? (this._x = Math.atan2(p2, l2), this._y = Math.atan2(o2, i2)) : (this._x = Math.atan2(-c2, d2), this._y = 0);
          break;
        default:
          console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t2);
      }
      return this._order = t2, true === n2 && this._onChangeCallback(), this;
    }
    setFromQuaternion(e2, t2, n2) {
      return oi.makeRotationFromQuaternion(e2), this.setFromRotationMatrix(oi, t2, n2);
    }
    setFromVector3(e2, t2 = this._order) {
      return this.set(e2.x, e2.y, e2.z, t2);
    }
    reorder(e2) {
      return ai.setFromEuler(this), this.setFromQuaternion(ai, e2);
    }
    equals(e2) {
      return e2._x === this._x && e2._y === this._y && e2._z === this._z && e2._order === this._order;
    }
    fromArray(e2) {
      return this._x = e2[0], this._y = e2[1], this._z = e2[2], void 0 !== e2[3] && (this._order = e2[3]), this._onChangeCallback(), this;
    }
    toArray(e2 = [], t2 = 0) {
      return e2[t2] = this._x, e2[t2 + 1] = this._y, e2[t2 + 2] = this._z, e2[t2 + 3] = this._order, e2;
    }
    _onChange(e2) {
      return this._onChangeCallback = e2, this;
    }
    _onChangeCallback() {
    }
    *[Symbol.iterator]() {
      yield this._x, yield this._y, yield this._z, yield this._order;
    }
  }
  li.DEFAULT_ORDER = "XYZ";
  class ci {
    constructor() {
      this.mask = 1;
    }
    set(e2) {
      this.mask = (1 << e2 | 0) >>> 0;
    }
    enable(e2) {
      this.mask |= 1 << e2 | 0;
    }
    enableAll() {
      this.mask = -1;
    }
    toggle(e2) {
      this.mask ^= 1 << e2 | 0;
    }
    disable(e2) {
      this.mask &= ~(1 << e2 | 0);
    }
    disableAll() {
      this.mask = 0;
    }
    test(e2) {
      return 0 != (this.mask & e2.mask);
    }
    isEnabled(e2) {
      return 0 != (this.mask & (1 << e2 | 0));
    }
  }
  let ui = 0;
  const pi = new Ar(), di = new wr(), hi = new Zr(), fi = new Ar(), mi = new Ar(), _i = new Ar(), gi = new wr(), vi = new Ar(1, 0, 0), yi = new Ar(0, 1, 0), bi = new Ar(0, 0, 1), wi = { type: "added" }, Ai = { type: "removed" };
  class xi extends In {
    constructor() {
      super(), this.isObject3D = true, Object.defineProperty(this, "id", { value: ui++ }), this.uuid = On(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = xi.DEFAULT_UP.clone();
      const e2 = new Ar(), t2 = new li(), n2 = new wr(), r2 = new Ar(1, 1, 1);
      t2._onChange(function() {
        n2.setFromEuler(t2, false);
      }), n2._onChange(function() {
        t2.setFromQuaternion(n2, void 0, false);
      }), Object.defineProperties(this, { position: { configurable: true, enumerable: true, value: e2 }, rotation: { configurable: true, enumerable: true, value: t2 }, quaternion: { configurable: true, enumerable: true, value: n2 }, scale: { configurable: true, enumerable: true, value: r2 }, modelViewMatrix: { value: new Zr() }, normalMatrix: { value: new Wn() } }), this.matrix = new Zr(), this.matrixWorld = new Zr(), this.matrixAutoUpdate = xi.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldNeedsUpdate = false, this.matrixWorldAutoUpdate = xi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.layers = new ci(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.userData = {};
    }
    onBeforeRender(e2, t2, n2, r2, i2, s2) {
      this.dispatchEvent({ type: "beforeRender", renderer: e2, scene: t2, camera: n2, geometry: r2, material: i2, group: s2 });
    }
    onAfterRender(e2, t2, n2, r2, i2, s2) {
      this.dispatchEvent({ type: "afterRender", renderer: e2, scene: t2, camera: n2, geometry: r2, material: i2, group: s2 });
    }
    applyMatrix4(e2) {
      this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e2), this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(e2) {
      return this.quaternion.premultiply(e2), this;
    }
    setRotationFromAxisAngle(e2, t2) {
      this.quaternion.setFromAxisAngle(e2, t2);
    }
    setRotationFromEuler(e2) {
      this.quaternion.setFromEuler(e2, true);
    }
    setRotationFromMatrix(e2) {
      this.quaternion.setFromRotationMatrix(e2);
    }
    setRotationFromQuaternion(e2) {
      this.quaternion.copy(e2);
    }
    rotateOnAxis(e2, t2) {
      return di.setFromAxisAngle(e2, t2), this.quaternion.multiply(di), this;
    }
    rotateOnWorldAxis(e2, t2) {
      return di.setFromAxisAngle(e2, t2), this.quaternion.premultiply(di), this;
    }
    rotateX(e2) {
      return this.rotateOnAxis(vi, e2);
    }
    rotateY(e2) {
      return this.rotateOnAxis(yi, e2);
    }
    rotateZ(e2) {
      return this.rotateOnAxis(bi, e2);
    }
    translateOnAxis(e2, t2) {
      return pi.copy(e2).applyQuaternion(this.quaternion), this.position.add(pi.multiplyScalar(t2)), this;
    }
    translateX(e2) {
      return this.translateOnAxis(vi, e2);
    }
    translateY(e2) {
      return this.translateOnAxis(yi, e2);
    }
    translateZ(e2) {
      return this.translateOnAxis(bi, e2);
    }
    localToWorld(e2) {
      return this.updateWorldMatrix(true, false), e2.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(e2) {
      return this.updateWorldMatrix(true, false), e2.applyMatrix4(hi.copy(this.matrixWorld).invert());
    }
    lookAt(e2, t2, n2) {
      e2.isVector3 ? fi.copy(e2) : fi.set(e2, t2, n2);
      const r2 = this.parent;
      this.updateWorldMatrix(true, false), mi.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? hi.lookAt(mi, fi, this.up) : hi.lookAt(fi, mi, this.up), this.quaternion.setFromRotationMatrix(hi), r2 && (hi.extractRotation(r2.matrixWorld), di.setFromRotationMatrix(hi), this.quaternion.premultiply(di.invert()));
    }
    add(e2) {
      if (arguments.length > 1) {
        for (let e3 = 0; e3 < arguments.length; e3++)
          this.add(arguments[e3]);
        return this;
      }
      return e2 === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e2), this) : (e2 && e2.isObject3D ? (null !== e2.parent && e2.parent.remove(e2), e2.parent = this, this.children.push(e2), e2.dispatchEvent(wi)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e2), this);
    }
    remove(e2) {
      if (arguments.length > 1) {
        for (let e3 = 0; e3 < arguments.length; e3++)
          this.remove(arguments[e3]);
        return this;
      }
      const t2 = this.children.indexOf(e2);
      return -1 !== t2 && (e2.parent = null, this.children.splice(t2, 1), e2.dispatchEvent(Ai)), this;
    }
    removeFromParent() {
      const e2 = this.parent;
      return null !== e2 && e2.remove(this), this;
    }
    clear() {
      for (let e2 = 0; e2 < this.children.length; e2++) {
        const t2 = this.children[e2];
        t2.parent = null, t2.dispatchEvent(Ai);
      }
      return this.children.length = 0, this;
    }
    attach(e2) {
      return this.updateWorldMatrix(true, false), hi.copy(this.matrixWorld).invert(), null !== e2.parent && (e2.parent.updateWorldMatrix(true, false), hi.multiply(e2.parent.matrixWorld)), e2.applyMatrix4(hi), this.add(e2), e2.updateWorldMatrix(false, true), this;
    }
    getObjectById(e2) {
      return this.getObjectByProperty("id", e2);
    }
    getObjectByName(e2) {
      return this.getObjectByProperty("name", e2);
    }
    getObjectByProperty(e2, t2) {
      if (this[e2] === t2)
        return this;
      for (let n2 = 0, r2 = this.children.length; n2 < r2; n2++) {
        const r3 = this.children[n2].getObjectByProperty(e2, t2);
        if (void 0 !== r3)
          return r3;
      }
    }
    getObjectsByProperty(e2, t2) {
      let n2 = [];
      this[e2] === t2 && n2.push(this);
      for (let r2 = 0, i2 = this.children.length; r2 < i2; r2++) {
        const i3 = this.children[r2].getObjectsByProperty(e2, t2);
        i3.length > 0 && (n2 = n2.concat(i3));
      }
      return n2;
    }
    getWorldPosition(e2) {
      return this.updateWorldMatrix(true, false), e2.setFromMatrixPosition(this.matrixWorld);
    }
    getWorldQuaternion(e2) {
      return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(mi, e2, _i), e2;
    }
    getWorldScale(e2) {
      return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(mi, gi, e2), e2;
    }
    getWorldDirection(e2) {
      this.updateWorldMatrix(true, false);
      const t2 = this.matrixWorld.elements;
      return e2.set(t2[8], t2[9], t2[10]).normalize();
    }
    raycast() {
    }
    traverse(e2) {
      e2(this);
      const t2 = this.children;
      for (let n2 = 0, r2 = t2.length; n2 < r2; n2++)
        t2[n2].traverse(e2);
    }
    traverseVisible(e2) {
      if (false === this.visible)
        return;
      e2(this);
      const t2 = this.children;
      for (let n2 = 0, r2 = t2.length; n2 < r2; n2++)
        t2[n2].traverseVisible(e2);
    }
    traverseAncestors(e2) {
      const t2 = this.parent;
      null !== t2 && (e2(t2), t2.traverseAncestors(e2));
    }
    updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
    }
    updateMatrixWorld(e2) {
      this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e2) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = false, e2 = true);
      const t2 = this.children;
      for (let n2 = 0, r2 = t2.length; n2 < r2; n2++) {
        const r3 = t2[n2];
        true !== r3.matrixWorldAutoUpdate && true !== e2 || r3.updateMatrixWorld(e2);
      }
    }
    updateWorldMatrix(e2, t2) {
      const n2 = this.parent;
      if (true === e2 && null !== n2 && true === n2.matrixWorldAutoUpdate && n2.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), true === t2) {
        const e3 = this.children;
        for (let t3 = 0, n3 = e3.length; t3 < n3; t3++) {
          const n4 = e3[t3];
          true === n4.matrixWorldAutoUpdate && n4.updateWorldMatrix(false, true);
        }
      }
    }
    toJSON(e2) {
      const t2 = void 0 === e2 || "string" == typeof e2, n2 = {};
      t2 && (e2 = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {}, extras: {} }, n2.metadata = { version: 4.6, type: "Object", generator: "Object3D.toJSON" });
      const r2 = {};
      function i2(t3, n3) {
        return void 0 === t3[n3.uuid] && (t3[n3.uuid] = n3.toJSON(e2)), n3.uuid;
      }
      if (r2.uuid = this.uuid, r2.type = this.type, "" !== this.name && (r2.name = this.name), true === this.castShadow && (r2.castShadow = true), true === this.receiveShadow && (r2.receiveShadow = true), false === this.visible && (r2.visible = false), false === this.frustumCulled && (r2.frustumCulled = false), 0 !== this.renderOrder && (r2.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r2.userData = this.userData), r2.layers = this.layers.mask, r2.matrix = this.matrix.toArray(), r2.up = this.up.toArray(), false === this.matrixAutoUpdate && (r2.matrixAutoUpdate = false), this.isInstancedMesh && (r2.type = "InstancedMesh", r2.count = this.count, r2.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (r2.instanceColor = this.instanceColor.toJSON())), this.isScene)
        this.background && (this.background.isColor ? r2.background = this.background.toJSON() : this.background.isTexture && (r2.background = this.background.toJSON(e2).uuid)), this.environment && this.environment.isTexture && true !== this.environment.isRenderTargetTexture && (r2.environment = this.environment.toJSON(e2).uuid);
      else if (this.isMesh || this.isLine || this.isPoints) {
        r2.geometry = i2(e2.geometries, this.geometry);
        const t3 = this.geometry.parameters;
        if (void 0 !== t3 && void 0 !== t3.shapes) {
          const n3 = t3.shapes;
          if (Array.isArray(n3))
            for (let t4 = 0, r3 = n3.length; t4 < r3; t4++) {
              const r4 = n3[t4];
              i2(e2.shapes, r4);
            }
          else
            i2(e2.shapes, n3);
        }
      }
      if (this.isSkinnedMesh && (r2.bindMode = this.bindMode, r2.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (i2(e2.skeletons, this.skeleton), r2.skeleton = this.skeleton.uuid)), void 0 !== this.material)
        if (Array.isArray(this.material)) {
          const t3 = [];
          for (let n3 = 0, r3 = this.material.length; n3 < r3; n3++)
            t3.push(i2(e2.materials, this.material[n3]));
          r2.material = t3;
        } else
          r2.material = i2(e2.materials, this.material);
      if (this.children.length > 0) {
        r2.children = [];
        for (let t3 = 0; t3 < this.children.length; t3++)
          r2.children.push(this.children[t3].toJSON(e2).object);
      }
      if (this.animations.length > 0) {
        r2.animations = [];
        for (let t3 = 0; t3 < this.animations.length; t3++) {
          const n3 = this.animations[t3];
          r2.animations.push(i2(e2.animations, n3));
        }
      }
      if (t2) {
        const t3 = s2(e2.geometries), r3 = s2(e2.materials), i3 = s2(e2.textures), o2 = s2(e2.images), a2 = s2(e2.shapes), l2 = s2(e2.skeletons), c2 = s2(e2.animations), u2 = s2(e2.nodes);
        t3.length > 0 && (n2.geometries = t3), r3.length > 0 && (n2.materials = r3), i3.length > 0 && (n2.textures = i3), o2.length > 0 && (n2.images = o2), a2.length > 0 && (n2.shapes = a2), l2.length > 0 && (n2.skeletons = l2), c2.length > 0 && (n2.animations = c2), u2.length > 0 && (n2.nodes = u2);
      }
      return n2.object = r2, n2;
      function s2(e3) {
        const t3 = [];
        for (const n3 in e3) {
          const r3 = e3[n3];
          delete r3.metadata, t3.push(r3);
        }
        return t3;
      }
    }
    clone(e2) {
      return new this.constructor().copy(this, e2);
    }
    copy(e2, t2 = true) {
      this.name = e2.name, this.up.copy(e2.up), this.position.copy(e2.position), this.rotation.order = e2.rotation.order, this.quaternion.copy(e2.quaternion), this.scale.copy(e2.scale), this.matrix.copy(e2.matrix), this.matrixWorld.copy(e2.matrixWorld), this.matrixAutoUpdate = e2.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e2.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e2.matrixWorldAutoUpdate, this.layers.mask = e2.layers.mask, this.visible = e2.visible, this.castShadow = e2.castShadow, this.receiveShadow = e2.receiveShadow, this.frustumCulled = e2.frustumCulled, this.renderOrder = e2.renderOrder, this.animations = e2.animations, this.userData = {};
      for (const [t3, n2] of Object.entries(e2.userData))
        this.userData[t3] = !n2 || n2 && (n2.isTexture || n2.isObject3D) ? n2 : JSON.parse(JSON.stringify(n2));
      if (true === t2)
        for (let t3 = 0; t3 < e2.children.length; t3++) {
          const n2 = e2.children[t3];
          this.add(n2.clone());
        }
      return this;
    }
  }
  xi.DEFAULT_UP = new Ar(0, 1, 0), xi.DEFAULT_MATRIX_AUTO_UPDATE = true, xi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
  const Ei = new Ar(), Ci = new Ar(), Si = new Ar(), Mi = new Ar(), Ti = new Ar(), Pi = new Ar(), Ii = new Ar(), Ri = new Ar(), ki = new Ar(), Di = new Ar();
  let Bi = false;
  class Oi {
    constructor(e2 = new Ar(), t2 = new Ar(), n2 = new Ar()) {
      this.a = e2, this.b = t2, this.c = n2;
    }
    static getNormal(e2, t2, n2, r2) {
      r2.subVectors(n2, t2), Ei.subVectors(e2, t2), r2.cross(Ei);
      const i2 = r2.lengthSq();
      return i2 > 0 ? r2.multiplyScalar(1 / Math.sqrt(i2)) : r2.set(0, 0, 0);
    }
    static getBarycoord(e2, t2, n2, r2, i2) {
      Ei.subVectors(r2, t2), Ci.subVectors(n2, t2), Si.subVectors(e2, t2);
      const s2 = Ei.dot(Ei), o2 = Ei.dot(Ci), a2 = Ei.dot(Si), l2 = Ci.dot(Ci), c2 = Ci.dot(Si), u2 = s2 * l2 - o2 * o2;
      if (0 === u2)
        return i2.set(-2, -1, -1);
      const p2 = 1 / u2, d2 = (l2 * a2 - o2 * c2) * p2, h2 = (s2 * c2 - o2 * a2) * p2;
      return i2.set(1 - d2 - h2, h2, d2);
    }
    static containsPoint(e2, t2, n2, r2) {
      return this.getBarycoord(e2, t2, n2, r2, Mi), Mi.x >= 0 && Mi.y >= 0 && Mi.x + Mi.y <= 1;
    }
    static getUV(e2, t2, n2, r2, i2, s2, o2, a2) {
      return false === Bi && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), Bi = true), this.getInterpolation(e2, t2, n2, r2, i2, s2, o2, a2);
    }
    static getInterpolation(e2, t2, n2, r2, i2, s2, o2, a2) {
      return this.getBarycoord(e2, t2, n2, r2, Mi), a2.setScalar(0), a2.addScaledVector(i2, Mi.x), a2.addScaledVector(s2, Mi.y), a2.addScaledVector(o2, Mi.z), a2;
    }
    static isFrontFacing(e2, t2, n2, r2) {
      return Ei.subVectors(n2, t2), Ci.subVectors(e2, t2), Ei.cross(Ci).dot(r2) < 0;
    }
    set(e2, t2, n2) {
      return this.a.copy(e2), this.b.copy(t2), this.c.copy(n2), this;
    }
    setFromPointsAndIndices(e2, t2, n2, r2) {
      return this.a.copy(e2[t2]), this.b.copy(e2[n2]), this.c.copy(e2[r2]), this;
    }
    setFromAttributeAndIndices(e2, t2, n2, r2) {
      return this.a.fromBufferAttribute(e2, t2), this.b.fromBufferAttribute(e2, n2), this.c.fromBufferAttribute(e2, r2), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e2) {
      return this.a.copy(e2.a), this.b.copy(e2.b), this.c.copy(e2.c), this;
    }
    getArea() {
      return Ei.subVectors(this.c, this.b), Ci.subVectors(this.a, this.b), 0.5 * Ei.cross(Ci).length();
    }
    getMidpoint(e2) {
      return e2.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
    getNormal(e2) {
      return Oi.getNormal(this.a, this.b, this.c, e2);
    }
    getPlane(e2) {
      return e2.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(e2, t2) {
      return Oi.getBarycoord(e2, this.a, this.b, this.c, t2);
    }
    getUV(e2, t2, n2, r2, i2) {
      return false === Bi && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), Bi = true), Oi.getInterpolation(e2, this.a, this.b, this.c, t2, n2, r2, i2);
    }
    getInterpolation(e2, t2, n2, r2, i2) {
      return Oi.getInterpolation(e2, this.a, this.b, this.c, t2, n2, r2, i2);
    }
    containsPoint(e2) {
      return Oi.containsPoint(e2, this.a, this.b, this.c);
    }
    isFrontFacing(e2) {
      return Oi.isFrontFacing(this.a, this.b, this.c, e2);
    }
    intersectsBox(e2) {
      return e2.intersectsTriangle(this);
    }
    closestPointToPoint(e2, t2) {
      const n2 = this.a, r2 = this.b, i2 = this.c;
      let s2, o2;
      Ti.subVectors(r2, n2), Pi.subVectors(i2, n2), Ri.subVectors(e2, n2);
      const a2 = Ti.dot(Ri), l2 = Pi.dot(Ri);
      if (a2 <= 0 && l2 <= 0)
        return t2.copy(n2);
      ki.subVectors(e2, r2);
      const c2 = Ti.dot(ki), u2 = Pi.dot(ki);
      if (c2 >= 0 && u2 <= c2)
        return t2.copy(r2);
      const p2 = a2 * u2 - c2 * l2;
      if (p2 <= 0 && a2 >= 0 && c2 <= 0)
        return s2 = a2 / (a2 - c2), t2.copy(n2).addScaledVector(Ti, s2);
      Di.subVectors(e2, i2);
      const d2 = Ti.dot(Di), h2 = Pi.dot(Di);
      if (h2 >= 0 && d2 <= h2)
        return t2.copy(i2);
      const f2 = d2 * l2 - a2 * h2;
      if (f2 <= 0 && l2 >= 0 && h2 <= 0)
        return o2 = l2 / (l2 - h2), t2.copy(n2).addScaledVector(Pi, o2);
      const m2 = c2 * h2 - d2 * u2;
      if (m2 <= 0 && u2 - c2 >= 0 && d2 - h2 >= 0)
        return Ii.subVectors(i2, r2), o2 = (u2 - c2) / (u2 - c2 + (d2 - h2)), t2.copy(r2).addScaledVector(Ii, o2);
      const _2 = 1 / (m2 + f2 + p2);
      return s2 = f2 * _2, o2 = p2 * _2, t2.copy(n2).addScaledVector(Ti, s2).addScaledVector(Pi, o2);
    }
    equals(e2) {
      return e2.a.equals(this.a) && e2.b.equals(this.b) && e2.c.equals(this.c);
    }
  }
  let Li = 0;
  class Ui extends In {
    constructor() {
      super(), this.isMaterial = true, Object.defineProperty(this, "id", { value: Li++ }), this.uuid = On(), this.name = "", this.type = "Material", this.blending = y, this.side = f, this.vertexColors = false, this.opacity = 1, this.transparent = false, this.blendSrc = D, this.blendDst = B, this.blendEquation = E, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = V, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = an, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Wt, this.stencilZFail = Wt, this.stencilZPass = Wt, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.forceSinglePass = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0, this._alphaTest = 0;
    }
    get alphaTest() {
      return this._alphaTest;
    }
    set alphaTest(e2) {
      this._alphaTest > 0 != e2 > 0 && this.version++, this._alphaTest = e2;
    }
    onBuild() {
    }
    onBeforeRender() {
    }
    onAfterRender() {
    }
    onBeforeCompile() {
    }
    customProgramCacheKey() {
      return this.onBeforeCompile.toString();
    }
    setValues(e2) {
      if (void 0 !== e2)
        for (const t2 in e2) {
          const n2 = e2[t2];
          if (void 0 === n2) {
            console.warn(`THREE.Material: parameter '${t2}' has value of undefined.`);
            continue;
          }
          const r2 = this[t2];
          void 0 !== r2 && (r2 && r2.isColor ? r2.set(n2) : r2 && r2.isVector3 && n2 && n2.isVector3 ? r2.copy(n2) : Array.isArray(n2) && r2 && "function" == typeof r2.fromArray ? r2.fromArray(n2) : this[t2] = n2);
        }
    }
    toJSON(e2) {
      const t2 = void 0 === e2 || "string" == typeof e2;
      t2 && (e2 = { textures: {}, images: {} });
      const n2 = { metadata: { version: 4.6, type: "Material", generator: "Material.toJSON" } };
      function r2(e3) {
        const t3 = [];
        for (const n3 in e3) {
          const r3 = e3[n3];
          delete r3.metadata, t3.push(r3);
        }
        return t3;
      }
      if (n2.uuid = this.uuid, n2.type = this.type, "" !== this.name && (n2.name = this.name), this.color && this.color.isColor && (n2.color = this.color.getHex()), void 0 !== this.roughness && (n2.roughness = this.roughness), void 0 !== this.metalness && (n2.metalness = this.metalness), void 0 !== this.sheen && (n2.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n2.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n2.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n2.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n2.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n2.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n2.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n2.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n2.shininess = this.shininess), void 0 !== this.clearcoat && (n2.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n2.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n2.clearcoatMap = this.clearcoatMap.toJSON(e2).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n2.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e2).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n2.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e2).uuid, n2.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.iridescence && (n2.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (n2.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (n2.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n2.iridescenceMap = this.iridescenceMap.toJSON(e2).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n2.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e2).uuid), void 0 !== this.anisotropy && (n2.anisotropy = this.anisotropy), void 0 !== this.anisotropyRotation && (n2.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n2.anisotropyMap = this.anisotropyMap.toJSON(e2).uuid), this.map && this.map.isTexture && (n2.map = this.map.toJSON(e2).uuid), this.matcap && this.matcap.isTexture && (n2.matcap = this.matcap.toJSON(e2).uuid), this.alphaMap && this.alphaMap.isTexture && (n2.alphaMap = this.alphaMap.toJSON(e2).uuid), this.lightMap && this.lightMap.isTexture && (n2.lightMap = this.lightMap.toJSON(e2).uuid, n2.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n2.aoMap = this.aoMap.toJSON(e2).uuid, n2.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n2.bumpMap = this.bumpMap.toJSON(e2).uuid, n2.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n2.normalMap = this.normalMap.toJSON(e2).uuid, n2.normalMapType = this.normalMapType, n2.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n2.displacementMap = this.displacementMap.toJSON(e2).uuid, n2.displacementScale = this.displacementScale, n2.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n2.roughnessMap = this.roughnessMap.toJSON(e2).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n2.metalnessMap = this.metalnessMap.toJSON(e2).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n2.emissiveMap = this.emissiveMap.toJSON(e2).uuid), this.specularMap && this.specularMap.isTexture && (n2.specularMap = this.specularMap.toJSON(e2).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n2.specularIntensityMap = this.specularIntensityMap.toJSON(e2).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n2.specularColorMap = this.specularColorMap.toJSON(e2).uuid), this.envMap && this.envMap.isTexture && (n2.envMap = this.envMap.toJSON(e2).uuid, void 0 !== this.combine && (n2.combine = this.combine)), void 0 !== this.envMapIntensity && (n2.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n2.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n2.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n2.gradientMap = this.gradientMap.toJSON(e2).uuid), void 0 !== this.transmission && (n2.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n2.transmissionMap = this.transmissionMap.toJSON(e2).uuid), void 0 !== this.thickness && (n2.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n2.thicknessMap = this.thicknessMap.toJSON(e2).uuid), void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (n2.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n2.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n2.size = this.size), null !== this.shadowSide && (n2.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n2.sizeAttenuation = this.sizeAttenuation), this.blending !== y && (n2.blending = this.blending), this.side !== f && (n2.side = this.side), this.vertexColors && (n2.vertexColors = true), this.opacity < 1 && (n2.opacity = this.opacity), true === this.transparent && (n2.transparent = this.transparent), n2.depthFunc = this.depthFunc, n2.depthTest = this.depthTest, n2.depthWrite = this.depthWrite, n2.colorWrite = this.colorWrite, n2.stencilWrite = this.stencilWrite, n2.stencilWriteMask = this.stencilWriteMask, n2.stencilFunc = this.stencilFunc, n2.stencilRef = this.stencilRef, n2.stencilFuncMask = this.stencilFuncMask, n2.stencilFail = this.stencilFail, n2.stencilZFail = this.stencilZFail, n2.stencilZPass = this.stencilZPass, void 0 !== this.rotation && 0 !== this.rotation && (n2.rotation = this.rotation), true === this.polygonOffset && (n2.polygonOffset = true), 0 !== this.polygonOffsetFactor && (n2.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n2.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (n2.linewidth = this.linewidth), void 0 !== this.dashSize && (n2.dashSize = this.dashSize), void 0 !== this.gapSize && (n2.gapSize = this.gapSize), void 0 !== this.scale && (n2.scale = this.scale), true === this.dithering && (n2.dithering = true), this.alphaTest > 0 && (n2.alphaTest = this.alphaTest), true === this.alphaToCoverage && (n2.alphaToCoverage = this.alphaToCoverage), true === this.premultipliedAlpha && (n2.premultipliedAlpha = this.premultipliedAlpha), true === this.forceSinglePass && (n2.forceSinglePass = this.forceSinglePass), true === this.wireframe && (n2.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n2.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n2.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n2.wireframeLinejoin = this.wireframeLinejoin), true === this.flatShading && (n2.flatShading = this.flatShading), false === this.visible && (n2.visible = false), false === this.toneMapped && (n2.toneMapped = false), false === this.fog && (n2.fog = false), Object.keys(this.userData).length > 0 && (n2.userData = this.userData), t2) {
        const t3 = r2(e2.textures), i2 = r2(e2.images);
        t3.length > 0 && (n2.textures = t3), i2.length > 0 && (n2.images = i2);
      }
      return n2;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e2) {
      this.name = e2.name, this.blending = e2.blending, this.side = e2.side, this.vertexColors = e2.vertexColors, this.opacity = e2.opacity, this.transparent = e2.transparent, this.blendSrc = e2.blendSrc, this.blendDst = e2.blendDst, this.blendEquation = e2.blendEquation, this.blendSrcAlpha = e2.blendSrcAlpha, this.blendDstAlpha = e2.blendDstAlpha, this.blendEquationAlpha = e2.blendEquationAlpha, this.depthFunc = e2.depthFunc, this.depthTest = e2.depthTest, this.depthWrite = e2.depthWrite, this.stencilWriteMask = e2.stencilWriteMask, this.stencilFunc = e2.stencilFunc, this.stencilRef = e2.stencilRef, this.stencilFuncMask = e2.stencilFuncMask, this.stencilFail = e2.stencilFail, this.stencilZFail = e2.stencilZFail, this.stencilZPass = e2.stencilZPass, this.stencilWrite = e2.stencilWrite;
      const t2 = e2.clippingPlanes;
      let n2 = null;
      if (null !== t2) {
        const e3 = t2.length;
        n2 = new Array(e3);
        for (let r2 = 0; r2 !== e3; ++r2)
          n2[r2] = t2[r2].clone();
      }
      return this.clippingPlanes = n2, this.clipIntersection = e2.clipIntersection, this.clipShadows = e2.clipShadows, this.shadowSide = e2.shadowSide, this.colorWrite = e2.colorWrite, this.precision = e2.precision, this.polygonOffset = e2.polygonOffset, this.polygonOffsetFactor = e2.polygonOffsetFactor, this.polygonOffsetUnits = e2.polygonOffsetUnits, this.dithering = e2.dithering, this.alphaTest = e2.alphaTest, this.alphaToCoverage = e2.alphaToCoverage, this.premultipliedAlpha = e2.premultipliedAlpha, this.forceSinglePass = e2.forceSinglePass, this.visible = e2.visible, this.toneMapped = e2.toneMapped, this.userData = Fi({}, e2.userData), this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    set needsUpdate(e2) {
      true === e2 && this.version++;
    }
  }
  function Fi(e2, t2) {
    if (!t2)
      return e2;
    for (const n2 of Object.keys(t2)) {
      if (n2.startsWith("__"))
        continue;
      if ("function" == typeof e2[n2] || "function" == typeof t2[n2])
        continue;
      const r2 = t2[n2], i2 = !r2 || r2.isTexture || r2.isObject3D || r2.isMaterial;
      i2 || "function" != typeof t2[n2].clone ? i2 || "object" != typeof t2[n2] && !Array.isArray(t2[n2]) ? e2[n2] = t2[n2] : e2[n2] = Fi(Array.isArray(t2[n2]) ? [] : {}, t2[n2]) : e2[n2] = t2[n2].clone();
    }
    return e2;
  }
  const Ni = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, ji = { h: 0, s: 0, l: 0 }, zi = { h: 0, s: 0, l: 0 };
  function Gi(e2, t2, n2) {
    return n2 < 0 && (n2 += 1), n2 > 1 && (n2 -= 1), n2 < 1 / 6 ? e2 + 6 * (t2 - e2) * n2 : n2 < 0.5 ? t2 : n2 < 2 / 3 ? e2 + 6 * (t2 - e2) * (2 / 3 - n2) : e2;
  }
  class Vi {
    constructor(e2, t2, n2) {
      return this.isColor = true, this.r = 1, this.g = 1, this.b = 1, this.set(e2, t2, n2);
    }
    set(e2, t2, n2) {
      if (void 0 === t2 && void 0 === n2) {
        const t3 = e2;
        t3 && t3.isColor ? this.copy(t3) : "number" == typeof t3 ? this.setHex(t3) : "string" == typeof t3 && this.setStyle(t3);
      } else
        this.setRGB(e2, t2, n2);
      return this;
    }
    setScalar(e2) {
      return this.r = e2, this.g = e2, this.b = e2, this;
    }
    setHex(e2, t2 = zt) {
      return e2 = Math.floor(e2), this.r = (e2 >> 16 & 255) / 255, this.g = (e2 >> 8 & 255) / 255, this.b = (255 & e2) / 255, or.toWorkingColorSpace(this, t2), this;
    }
    setRGB(e2, t2, n2, r2 = or.workingColorSpace) {
      return this.r = e2, this.g = t2, this.b = n2, or.toWorkingColorSpace(this, r2), this;
    }
    setHSL(e2, t2, n2, r2 = or.workingColorSpace) {
      if (e2 = Un(e2, 1), t2 = Ln(t2, 0, 1), n2 = Ln(n2, 0, 1), 0 === t2)
        this.r = this.g = this.b = n2;
      else {
        const r3 = n2 <= 0.5 ? n2 * (1 + t2) : n2 + t2 - n2 * t2, i2 = 2 * n2 - r3;
        this.r = Gi(i2, r3, e2 + 1 / 3), this.g = Gi(i2, r3, e2), this.b = Gi(i2, r3, e2 - 1 / 3);
      }
      return or.toWorkingColorSpace(this, r2), this;
    }
    setStyle(e2, t2 = zt) {
      function n2(t3) {
        void 0 !== t3 && parseFloat(t3) < 1 && console.warn("THREE.Color: Alpha component of " + e2 + " will be ignored.");
      }
      let r2;
      if (r2 = /^(\w+)\(([^\)]*)\)/.exec(e2)) {
        let i2;
        const s2 = r2[1], o2 = r2[2];
        switch (s2) {
          case "rgb":
          case "rgba":
            if (i2 = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o2))
              return n2(i2[4]), this.setRGB(Math.min(255, parseInt(i2[1], 10)) / 255, Math.min(255, parseInt(i2[2], 10)) / 255, Math.min(255, parseInt(i2[3], 10)) / 255, t2);
            if (i2 = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o2))
              return n2(i2[4]), this.setRGB(Math.min(100, parseInt(i2[1], 10)) / 100, Math.min(100, parseInt(i2[2], 10)) / 100, Math.min(100, parseInt(i2[3], 10)) / 100, t2);
            break;
          case "hsl":
          case "hsla":
            if (i2 = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o2))
              return n2(i2[4]), this.setHSL(parseFloat(i2[1]) / 360, parseFloat(i2[2]) / 100, parseFloat(i2[3]) / 100, t2);
            break;
          default:
            console.warn("THREE.Color: Unknown color model " + e2);
        }
      } else if (r2 = /^\#([A-Fa-f\d]+)$/.exec(e2)) {
        const n3 = r2[1], i2 = n3.length;
        if (3 === i2)
          return this.setRGB(parseInt(n3.charAt(0), 16) / 15, parseInt(n3.charAt(1), 16) / 15, parseInt(n3.charAt(2), 16) / 15, t2);
        if (6 === i2)
          return this.setHex(parseInt(n3, 16), t2);
        console.warn("THREE.Color: Invalid hex color " + e2);
      } else if (e2 && e2.length > 0)
        return this.setColorName(e2, t2);
      return this;
    }
    setColorName(e2, t2 = zt) {
      const n2 = Ni[e2.toLowerCase()];
      return void 0 !== n2 ? this.setHex(n2, t2) : console.warn("THREE.Color: Unknown color " + e2), this;
    }
    clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
    copy(e2) {
      return this.r = e2.r, this.g = e2.g, this.b = e2.b, this;
    }
    copySRGBToLinear(e2) {
      return this.r = er(e2.r), this.g = er(e2.g), this.b = er(e2.b), this;
    }
    copyLinearToSRGB(e2) {
      return this.r = tr(e2.r), this.g = tr(e2.g), this.b = tr(e2.b), this;
    }
    convertSRGBToLinear() {
      return this.copySRGBToLinear(this), this;
    }
    convertLinearToSRGB() {
      return this.copyLinearToSRGB(this), this;
    }
    getHex(e2 = zt) {
      return or.fromWorkingColorSpace(Hi.copy(this), e2), 65536 * Math.round(Ln(255 * Hi.r, 0, 255)) + 256 * Math.round(Ln(255 * Hi.g, 0, 255)) + Math.round(Ln(255 * Hi.b, 0, 255));
    }
    getHexString(e2 = zt) {
      return ("000000" + this.getHex(e2).toString(16)).slice(-6);
    }
    getHSL(e2, t2 = or.workingColorSpace) {
      or.fromWorkingColorSpace(Hi.copy(this), t2);
      const n2 = Hi.r, r2 = Hi.g, i2 = Hi.b, s2 = Math.max(n2, r2, i2), o2 = Math.min(n2, r2, i2);
      let a2, l2;
      const c2 = (o2 + s2) / 2;
      if (o2 === s2)
        a2 = 0, l2 = 0;
      else {
        const e3 = s2 - o2;
        switch (l2 = c2 <= 0.5 ? e3 / (s2 + o2) : e3 / (2 - s2 - o2), s2) {
          case n2:
            a2 = (r2 - i2) / e3 + (r2 < i2 ? 6 : 0);
            break;
          case r2:
            a2 = (i2 - n2) / e3 + 2;
            break;
          case i2:
            a2 = (n2 - r2) / e3 + 4;
        }
        a2 /= 6;
      }
      return e2.h = a2, e2.s = l2, e2.l = c2, e2;
    }
    getRGB(e2, t2 = or.workingColorSpace) {
      return or.fromWorkingColorSpace(Hi.copy(this), t2), e2.r = Hi.r, e2.g = Hi.g, e2.b = Hi.b, e2;
    }
    getStyle(e2 = zt) {
      or.fromWorkingColorSpace(Hi.copy(this), e2);
      const t2 = Hi.r, n2 = Hi.g, r2 = Hi.b;
      return e2 !== zt ? `color(${e2} ${t2.toFixed(3)} ${n2.toFixed(3)} ${r2.toFixed(3)})` : `rgb(${Math.round(255 * t2)},${Math.round(255 * n2)},${Math.round(255 * r2)})`;
    }
    offsetHSL(e2, t2, n2) {
      return this.getHSL(ji), ji.h += e2, ji.s += t2, ji.l += n2, this.setHSL(ji.h, ji.s, ji.l), this;
    }
    add(e2) {
      return this.r += e2.r, this.g += e2.g, this.b += e2.b, this;
    }
    addColors(e2, t2) {
      return this.r = e2.r + t2.r, this.g = e2.g + t2.g, this.b = e2.b + t2.b, this;
    }
    addScalar(e2) {
      return this.r += e2, this.g += e2, this.b += e2, this;
    }
    sub(e2) {
      return this.r = Math.max(0, this.r - e2.r), this.g = Math.max(0, this.g - e2.g), this.b = Math.max(0, this.b - e2.b), this;
    }
    multiply(e2) {
      return this.r *= e2.r, this.g *= e2.g, this.b *= e2.b, this;
    }
    multiplyScalar(e2) {
      return this.r *= e2, this.g *= e2, this.b *= e2, this;
    }
    lerp(e2, t2) {
      return this.r += (e2.r - this.r) * t2, this.g += (e2.g - this.g) * t2, this.b += (e2.b - this.b) * t2, this;
    }
    lerpColors(e2, t2, n2) {
      return this.r = e2.r + (t2.r - e2.r) * n2, this.g = e2.g + (t2.g - e2.g) * n2, this.b = e2.b + (t2.b - e2.b) * n2, this;
    }
    lerpHSL(e2, t2) {
      this.getHSL(ji), e2.getHSL(zi);
      const n2 = Fn(ji.h, zi.h, t2), r2 = Fn(ji.s, zi.s, t2), i2 = Fn(ji.l, zi.l, t2);
      return this.setHSL(n2, r2, i2), this;
    }
    setFromVector3(e2) {
      return this.r = e2.x, this.g = e2.y, this.b = e2.z, this;
    }
    applyMatrix3(e2) {
      const t2 = this.r, n2 = this.g, r2 = this.b, i2 = e2.elements;
      return this.r = i2[0] * t2 + i2[3] * n2 + i2[6] * r2, this.g = i2[1] * t2 + i2[4] * n2 + i2[7] * r2, this.b = i2[2] * t2 + i2[5] * n2 + i2[8] * r2, this;
    }
    equals(e2) {
      return e2.r === this.r && e2.g === this.g && e2.b === this.b;
    }
    fromArray(e2, t2 = 0) {
      return this.r = e2[t2], this.g = e2[t2 + 1], this.b = e2[t2 + 2], this;
    }
    toArray(e2 = [], t2 = 0) {
      return e2[t2] = this.r, e2[t2 + 1] = this.g, e2[t2 + 2] = this.b, e2;
    }
    fromBufferAttribute(e2, t2) {
      return this.r = e2.getX(t2), this.g = e2.getY(t2), this.b = e2.getZ(t2), this;
    }
    toJSON() {
      return this.getHex();
    }
    *[Symbol.iterator]() {
      yield this.r, yield this.g, yield this.b;
    }
  }
  const Hi = new Vi();
  Vi.NAMES = Ni;
  class Qi extends Ui {
    constructor(e2) {
      super(), this.isMeshBasicMaterial = true, this.type = "MeshBasicMaterial", this.color = new Vi(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = X, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = true, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.color.copy(e2.color), this.map = e2.map, this.lightMap = e2.lightMap, this.lightMapIntensity = e2.lightMapIntensity, this.aoMap = e2.aoMap, this.aoMapIntensity = e2.aoMapIntensity, this.specularMap = e2.specularMap, this.alphaMap = e2.alphaMap, this.envMap = e2.envMap, this.combine = e2.combine, this.reflectivity = e2.reflectivity, this.refractionRatio = e2.refractionRatio, this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this.wireframeLinecap = e2.wireframeLinecap, this.wireframeLinejoin = e2.wireframeLinejoin, this.fog = e2.fog, this;
    }
  }
  const Wi = qi();
  function qi() {
    const e2 = new ArrayBuffer(4), t2 = new Float32Array(e2), n2 = new Uint32Array(e2), r2 = new Uint32Array(512), i2 = new Uint32Array(512);
    for (let e3 = 0; e3 < 256; ++e3) {
      const t3 = e3 - 127;
      t3 < -27 ? (r2[e3] = 0, r2[256 | e3] = 32768, i2[e3] = 24, i2[256 | e3] = 24) : t3 < -14 ? (r2[e3] = 1024 >> -t3 - 14, r2[256 | e3] = 1024 >> -t3 - 14 | 32768, i2[e3] = -t3 - 1, i2[256 | e3] = -t3 - 1) : t3 <= 15 ? (r2[e3] = t3 + 15 << 10, r2[256 | e3] = t3 + 15 << 10 | 32768, i2[e3] = 13, i2[256 | e3] = 13) : t3 < 128 ? (r2[e3] = 31744, r2[256 | e3] = 64512, i2[e3] = 24, i2[256 | e3] = 24) : (r2[e3] = 31744, r2[256 | e3] = 64512, i2[e3] = 13, i2[256 | e3] = 13);
    }
    const s2 = new Uint32Array(2048), o2 = new Uint32Array(64), a2 = new Uint32Array(64);
    for (let e3 = 1; e3 < 1024; ++e3) {
      let t3 = e3 << 13, n3 = 0;
      for (; 0 == (8388608 & t3); )
        t3 <<= 1, n3 -= 8388608;
      t3 &= -8388609, n3 += 947912704, s2[e3] = t3 | n3;
    }
    for (let e3 = 1024; e3 < 2048; ++e3)
      s2[e3] = 939524096 + (e3 - 1024 << 13);
    for (let e3 = 1; e3 < 31; ++e3)
      o2[e3] = e3 << 23;
    o2[31] = 1199570944, o2[32] = 2147483648;
    for (let e3 = 33; e3 < 63; ++e3)
      o2[e3] = 2147483648 + (e3 - 32 << 23);
    o2[63] = 3347054592;
    for (let e3 = 1; e3 < 64; ++e3)
      32 !== e3 && (a2[e3] = 1024);
    return { floatView: t2, uint32View: n2, baseTable: r2, shiftTable: i2, mantissaTable: s2, exponentTable: o2, offsetTable: a2 };
  }
  function Xi(e2) {
    Math.abs(e2) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), e2 = Ln(e2, -65504, 65504), Wi.floatView[0] = e2;
    const t2 = Wi.uint32View[0], n2 = t2 >> 23 & 511;
    return Wi.baseTable[n2] + ((8388607 & t2) >> Wi.shiftTable[n2]);
  }
  function Yi(e2) {
    const t2 = e2 >> 10;
    return Wi.uint32View[0] = Wi.mantissaTable[Wi.offsetTable[t2] + (1023 & e2)] + Wi.exponentTable[t2], Wi.floatView[0];
  }
  const Ki = { toHalfFloat: Xi, fromHalfFloat: Yi }, Ji = new Ar(), Zi = new Qn();
  class $i {
    constructor(e2, t2, n2 = false) {
      if (Array.isArray(e2))
        throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
      this.isBufferAttribute = true, this.name = "", this.array = e2, this.itemSize = t2, this.count = void 0 !== e2 ? e2.length / t2 : 0, this.normalized = n2, this.usage = _n, this.updateRange = { offset: 0, count: -1 }, this.gpuType = Te, this.version = 0;
    }
    onUploadCallback() {
    }
    set needsUpdate(e2) {
      true === e2 && this.version++;
    }
    setUsage(e2) {
      return this.usage = e2, this;
    }
    copy(e2) {
      return this.name = e2.name, this.array = new e2.array.constructor(e2.array), this.itemSize = e2.itemSize, this.count = e2.count, this.normalized = e2.normalized, this.usage = e2.usage, this.gpuType = e2.gpuType, this;
    }
    copyAt(e2, t2, n2) {
      e2 *= this.itemSize, n2 *= t2.itemSize;
      for (let r2 = 0, i2 = this.itemSize; r2 < i2; r2++)
        this.array[e2 + r2] = t2.array[n2 + r2];
      return this;
    }
    copyArray(e2) {
      return this.array.set(e2), this;
    }
    applyMatrix3(e2) {
      if (2 === this.itemSize)
        for (let t2 = 0, n2 = this.count; t2 < n2; t2++)
          Zi.fromBufferAttribute(this, t2), Zi.applyMatrix3(e2), this.setXY(t2, Zi.x, Zi.y);
      else if (3 === this.itemSize)
        for (let t2 = 0, n2 = this.count; t2 < n2; t2++)
          Ji.fromBufferAttribute(this, t2), Ji.applyMatrix3(e2), this.setXYZ(t2, Ji.x, Ji.y, Ji.z);
      return this;
    }
    applyMatrix4(e2) {
      for (let t2 = 0, n2 = this.count; t2 < n2; t2++)
        Ji.fromBufferAttribute(this, t2), Ji.applyMatrix4(e2), this.setXYZ(t2, Ji.x, Ji.y, Ji.z);
      return this;
    }
    applyNormalMatrix(e2) {
      for (let t2 = 0, n2 = this.count; t2 < n2; t2++)
        Ji.fromBufferAttribute(this, t2), Ji.applyNormalMatrix(e2), this.setXYZ(t2, Ji.x, Ji.y, Ji.z);
      return this;
    }
    transformDirection(e2) {
      for (let t2 = 0, n2 = this.count; t2 < n2; t2++)
        Ji.fromBufferAttribute(this, t2), Ji.transformDirection(e2), this.setXYZ(t2, Ji.x, Ji.y, Ji.z);
      return this;
    }
    set(e2, t2 = 0) {
      return this.array.set(e2, t2), this;
    }
    getX(e2) {
      let t2 = this.array[e2 * this.itemSize];
      return this.normalized && (t2 = Gn(t2, this.array)), t2;
    }
    setX(e2, t2) {
      return this.normalized && (t2 = Vn(t2, this.array)), this.array[e2 * this.itemSize] = t2, this;
    }
    getY(e2) {
      let t2 = this.array[e2 * this.itemSize + 1];
      return this.normalized && (t2 = Gn(t2, this.array)), t2;
    }
    setY(e2, t2) {
      return this.normalized && (t2 = Vn(t2, this.array)), this.array[e2 * this.itemSize + 1] = t2, this;
    }
    getZ(e2) {
      let t2 = this.array[e2 * this.itemSize + 2];
      return this.normalized && (t2 = Gn(t2, this.array)), t2;
    }
    setZ(e2, t2) {
      return this.normalized && (t2 = Vn(t2, this.array)), this.array[e2 * this.itemSize + 2] = t2, this;
    }
    getW(e2) {
      let t2 = this.array[e2 * this.itemSize + 3];
      return this.normalized && (t2 = Gn(t2, this.array)), t2;
    }
    setW(e2, t2) {
      return this.normalized && (t2 = Vn(t2, this.array)), this.array[e2 * this.itemSize + 3] = t2, this;
    }
    setXY(e2, t2, n2) {
      return e2 *= this.itemSize, this.normalized && (t2 = Vn(t2, this.array), n2 = Vn(n2, this.array)), this.array[e2 + 0] = t2, this.array[e2 + 1] = n2, this;
    }
    setXYZ(e2, t2, n2, r2) {
      return e2 *= this.itemSize, this.normalized && (t2 = Vn(t2, this.array), n2 = Vn(n2, this.array), r2 = Vn(r2, this.array)), this.array[e2 + 0] = t2, this.array[e2 + 1] = n2, this.array[e2 + 2] = r2, this;
    }
    setXYZW(e2, t2, n2, r2, i2) {
      return e2 *= this.itemSize, this.normalized && (t2 = Vn(t2, this.array), n2 = Vn(n2, this.array), r2 = Vn(r2, this.array), i2 = Vn(i2, this.array)), this.array[e2 + 0] = t2, this.array[e2 + 1] = n2, this.array[e2 + 2] = r2, this.array[e2 + 3] = i2, this;
    }
    onUpload(e2) {
      return this.onUploadCallback = e2, this;
    }
    clone() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
    toJSON() {
      const e2 = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.from(this.array), normalized: this.normalized };
      return "" !== this.name && (e2.name = this.name), this.usage !== _n && (e2.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (e2.updateRange = this.updateRange), e2;
    }
    copyColorsArray() {
      console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.");
    }
    copyVector2sArray() {
      console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.");
    }
    copyVector3sArray() {
      console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.");
    }
    copyVector4sArray() {
      console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.");
    }
  }
  class es extends $i {
    constructor(e2, t2, n2) {
      super(new Int8Array(e2), t2, n2);
    }
  }
  class ts extends $i {
    constructor(e2, t2, n2) {
      super(new Uint8Array(e2), t2, n2);
    }
  }
  class ns extends $i {
    constructor(e2, t2, n2) {
      super(new Uint8ClampedArray(e2), t2, n2);
    }
  }
  class rs extends $i {
    constructor(e2, t2, n2) {
      super(new Int16Array(e2), t2, n2);
    }
  }
  class is extends $i {
    constructor(e2, t2, n2) {
      super(new Uint16Array(e2), t2, n2);
    }
  }
  class ss extends $i {
    constructor(e2, t2, n2) {
      super(new Int32Array(e2), t2, n2);
    }
  }
  class os extends $i {
    constructor(e2, t2, n2) {
      super(new Uint32Array(e2), t2, n2);
    }
  }
  class as extends $i {
    constructor(e2, t2, n2) {
      super(new Uint16Array(e2), t2, n2), this.isFloat16BufferAttribute = true;
    }
    getX(e2) {
      let t2 = Yi(this.array[e2 * this.itemSize]);
      return this.normalized && (t2 = Gn(t2, this.array)), t2;
    }
    setX(e2, t2) {
      return this.normalized && (t2 = Vn(t2, this.array)), this.array[e2 * this.itemSize] = Xi(t2), this;
    }
    getY(e2) {
      let t2 = Yi(this.array[e2 * this.itemSize + 1]);
      return this.normalized && (t2 = Gn(t2, this.array)), t2;
    }
    setY(e2, t2) {
      return this.normalized && (t2 = Vn(t2, this.array)), this.array[e2 * this.itemSize + 1] = Xi(t2), this;
    }
    getZ(e2) {
      let t2 = Yi(this.array[e2 * this.itemSize + 2]);
      return this.normalized && (t2 = Gn(t2, this.array)), t2;
    }
    setZ(e2, t2) {
      return this.normalized && (t2 = Vn(t2, this.array)), this.array[e2 * this.itemSize + 2] = Xi(t2), this;
    }
    getW(e2) {
      let t2 = Yi(this.array[e2 * this.itemSize + 3]);
      return this.normalized && (t2 = Gn(t2, this.array)), t2;
    }
    setW(e2, t2) {
      return this.normalized && (t2 = Vn(t2, this.array)), this.array[e2 * this.itemSize + 3] = Xi(t2), this;
    }
    setXY(e2, t2, n2) {
      return e2 *= this.itemSize, this.normalized && (t2 = Vn(t2, this.array), n2 = Vn(n2, this.array)), this.array[e2 + 0] = Xi(t2), this.array[e2 + 1] = Xi(n2), this;
    }
    setXYZ(e2, t2, n2, r2) {
      return e2 *= this.itemSize, this.normalized && (t2 = Vn(t2, this.array), n2 = Vn(n2, this.array), r2 = Vn(r2, this.array)), this.array[e2 + 0] = Xi(t2), this.array[e2 + 1] = Xi(n2), this.array[e2 + 2] = Xi(r2), this;
    }
    setXYZW(e2, t2, n2, r2, i2) {
      return e2 *= this.itemSize, this.normalized && (t2 = Vn(t2, this.array), n2 = Vn(n2, this.array), r2 = Vn(r2, this.array), i2 = Vn(i2, this.array)), this.array[e2 + 0] = Xi(t2), this.array[e2 + 1] = Xi(n2), this.array[e2 + 2] = Xi(r2), this.array[e2 + 3] = Xi(i2), this;
    }
  }
  class ls extends $i {
    constructor(e2, t2, n2) {
      super(new Float32Array(e2), t2, n2);
    }
  }
  class cs extends $i {
    constructor(e2, t2, n2) {
      super(new Float64Array(e2), t2, n2);
    }
  }
  let us = 0;
  const ps = new Zr(), ds = new xi(), hs = new Ar(), fs = new Cr(), ms = new Cr(), _s = new Ar();
  class gs extends In {
    constructor() {
      super(), this.isBufferGeometry = true, Object.defineProperty(this, "id", { value: us++ }), this.uuid = On(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
    }
    getIndex() {
      return this.index;
    }
    setIndex(e2) {
      return Array.isArray(e2) ? this.index = new (Xn(e2) ? os : is)(e2, 1) : this.index = e2, this;
    }
    getAttribute(e2) {
      return this.attributes[e2];
    }
    setAttribute(e2, t2) {
      return this.attributes[e2] = t2, this;
    }
    deleteAttribute(e2) {
      return delete this.attributes[e2], this;
    }
    hasAttribute(e2) {
      return void 0 !== this.attributes[e2];
    }
    addGroup(e2, t2, n2 = 0) {
      this.groups.push({ start: e2, count: t2, materialIndex: n2 });
    }
    clearGroups() {
      this.groups = [];
    }
    setDrawRange(e2, t2) {
      this.drawRange.start = e2, this.drawRange.count = t2;
    }
    applyMatrix4(e2) {
      const t2 = this.attributes.position;
      void 0 !== t2 && (t2.applyMatrix4(e2), t2.needsUpdate = true);
      const n2 = this.attributes.normal;
      if (void 0 !== n2) {
        const t3 = new Wn().getNormalMatrix(e2);
        n2.applyNormalMatrix(t3), n2.needsUpdate = true;
      }
      const r2 = this.attributes.tangent;
      return void 0 !== r2 && (r2.transformDirection(e2), r2.needsUpdate = true), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this;
    }
    applyQuaternion(e2) {
      return ps.makeRotationFromQuaternion(e2), this.applyMatrix4(ps), this;
    }
    rotateX(e2) {
      return ps.makeRotationX(e2), this.applyMatrix4(ps), this;
    }
    rotateY(e2) {
      return ps.makeRotationY(e2), this.applyMatrix4(ps), this;
    }
    rotateZ(e2) {
      return ps.makeRotationZ(e2), this.applyMatrix4(ps), this;
    }
    translate(e2, t2, n2) {
      return ps.makeTranslation(e2, t2, n2), this.applyMatrix4(ps), this;
    }
    scale(e2, t2, n2) {
      return ps.makeScale(e2, t2, n2), this.applyMatrix4(ps), this;
    }
    lookAt(e2) {
      return ds.lookAt(e2), ds.updateMatrix(), this.applyMatrix4(ds.matrix), this;
    }
    center(e2 = void 0) {
      return this.computeBoundingBox(), this.boundingBox.getCenter(hs).negate(), this.translate(hs.x, hs.y, hs.z), e2 && e2.copy(hs), this;
    }
    setFromPoints(e2) {
      const t2 = [];
      for (let n2 = 0, r2 = e2.length; n2 < r2; n2++) {
        const r3 = e2[n2];
        t2.push(r3.x, r3.y, r3.z || 0);
      }
      return this.setAttribute("position", new ls(t2, 3)), this;
    }
    computeBoundingBox() {
      null === this.boundingBox && (this.boundingBox = new Cr());
      const e2 = this.attributes.position, t2 = this.morphAttributes.position;
      if (e2 && e2.isGLBufferAttribute)
        return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new Ar(-1 / 0, -1 / 0, -1 / 0), new Ar(1 / 0, 1 / 0, 1 / 0));
      if (void 0 !== e2) {
        if (this.boundingBox.setFromBufferAttribute(e2), t2)
          for (let e3 = 0, n2 = t2.length; e3 < n2; e3++) {
            const n3 = t2[e3];
            fs.setFromBufferAttribute(n3), this.morphTargetsRelative ? (_s.addVectors(this.boundingBox.min, fs.min), this.boundingBox.expandByPoint(_s), _s.addVectors(this.boundingBox.max, fs.max), this.boundingBox.expandByPoint(_s)) : (this.boundingBox.expandByPoint(fs.min), this.boundingBox.expandByPoint(fs.max));
          }
      } else
        this.boundingBox.makeEmpty();
      (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
    computeBoundingSphere() {
      null === this.boundingSphere && (this.boundingSphere = new Vr());
      const e2 = this.attributes.position, t2 = this.morphAttributes.position;
      if (e2 && e2.isGLBufferAttribute)
        return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new Ar(), 1 / 0);
      if (e2) {
        const n2 = this.boundingSphere.center;
        if (fs.setFromBufferAttribute(e2), t2)
          for (let e3 = 0, n3 = t2.length; e3 < n3; e3++) {
            const n4 = t2[e3];
            ms.setFromBufferAttribute(n4), this.morphTargetsRelative ? (_s.addVectors(fs.min, ms.min), fs.expandByPoint(_s), _s.addVectors(fs.max, ms.max), fs.expandByPoint(_s)) : (fs.expandByPoint(ms.min), fs.expandByPoint(ms.max));
          }
        fs.getCenter(n2);
        let r2 = 0;
        for (let t3 = 0, i2 = e2.count; t3 < i2; t3++)
          _s.fromBufferAttribute(e2, t3), r2 = Math.max(r2, n2.distanceToSquared(_s));
        if (t2)
          for (let i2 = 0, s2 = t2.length; i2 < s2; i2++) {
            const s3 = t2[i2], o2 = this.morphTargetsRelative;
            for (let t3 = 0, i3 = s3.count; t3 < i3; t3++)
              _s.fromBufferAttribute(s3, t3), o2 && (hs.fromBufferAttribute(e2, t3), _s.add(hs)), r2 = Math.max(r2, n2.distanceToSquared(_s));
          }
        this.boundingSphere.radius = Math.sqrt(r2), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
    computeTangents() {
      const e2 = this.index, t2 = this.attributes;
      if (null === e2 || void 0 === t2.position || void 0 === t2.normal || void 0 === t2.uv)
        return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      const n2 = e2.array, r2 = t2.position.array, i2 = t2.normal.array, s2 = t2.uv.array, o2 = r2.length / 3;
      false === this.hasAttribute("tangent") && this.setAttribute("tangent", new $i(new Float32Array(4 * o2), 4));
      const a2 = this.getAttribute("tangent").array, l2 = [], c2 = [];
      for (let e3 = 0; e3 < o2; e3++)
        l2[e3] = new Ar(), c2[e3] = new Ar();
      const u2 = new Ar(), p2 = new Ar(), d2 = new Ar(), h2 = new Qn(), f2 = new Qn(), m2 = new Qn(), _2 = new Ar(), g2 = new Ar();
      function v2(e3, t3, n3) {
        u2.fromArray(r2, 3 * e3), p2.fromArray(r2, 3 * t3), d2.fromArray(r2, 3 * n3), h2.fromArray(s2, 2 * e3), f2.fromArray(s2, 2 * t3), m2.fromArray(s2, 2 * n3), p2.sub(u2), d2.sub(u2), f2.sub(h2), m2.sub(h2);
        const i3 = 1 / (f2.x * m2.y - m2.x * f2.y);
        isFinite(i3) && (_2.copy(p2).multiplyScalar(m2.y).addScaledVector(d2, -f2.y).multiplyScalar(i3), g2.copy(d2).multiplyScalar(f2.x).addScaledVector(p2, -m2.x).multiplyScalar(i3), l2[e3].add(_2), l2[t3].add(_2), l2[n3].add(_2), c2[e3].add(g2), c2[t3].add(g2), c2[n3].add(g2));
      }
      let y2 = this.groups;
      0 === y2.length && (y2 = [{ start: 0, count: n2.length }]);
      for (let e3 = 0, t3 = y2.length; e3 < t3; ++e3) {
        const t4 = y2[e3], r3 = t4.start;
        for (let e4 = r3, i3 = r3 + t4.count; e4 < i3; e4 += 3)
          v2(n2[e4 + 0], n2[e4 + 1], n2[e4 + 2]);
      }
      const b2 = new Ar(), w2 = new Ar(), A2 = new Ar(), x2 = new Ar();
      function E2(e3) {
        A2.fromArray(i2, 3 * e3), x2.copy(A2);
        const t3 = l2[e3];
        b2.copy(t3), b2.sub(A2.multiplyScalar(A2.dot(t3))).normalize(), w2.crossVectors(x2, t3);
        const n3 = w2.dot(c2[e3]) < 0 ? -1 : 1;
        a2[4 * e3] = b2.x, a2[4 * e3 + 1] = b2.y, a2[4 * e3 + 2] = b2.z, a2[4 * e3 + 3] = n3;
      }
      for (let e3 = 0, t3 = y2.length; e3 < t3; ++e3) {
        const t4 = y2[e3], r3 = t4.start;
        for (let e4 = r3, i3 = r3 + t4.count; e4 < i3; e4 += 3)
          E2(n2[e4 + 0]), E2(n2[e4 + 1]), E2(n2[e4 + 2]);
      }
    }
    computeVertexNormals() {
      const e2 = this.index, t2 = this.getAttribute("position");
      if (void 0 !== t2) {
        let n2 = this.getAttribute("normal");
        if (void 0 === n2)
          n2 = new $i(new Float32Array(3 * t2.count), 3), this.setAttribute("normal", n2);
        else
          for (let e3 = 0, t3 = n2.count; e3 < t3; e3++)
            n2.setXYZ(e3, 0, 0, 0);
        const r2 = new Ar(), i2 = new Ar(), s2 = new Ar(), o2 = new Ar(), a2 = new Ar(), l2 = new Ar(), c2 = new Ar(), u2 = new Ar();
        if (e2)
          for (let p2 = 0, d2 = e2.count; p2 < d2; p2 += 3) {
            const d3 = e2.getX(p2 + 0), h2 = e2.getX(p2 + 1), f2 = e2.getX(p2 + 2);
            r2.fromBufferAttribute(t2, d3), i2.fromBufferAttribute(t2, h2), s2.fromBufferAttribute(t2, f2), c2.subVectors(s2, i2), u2.subVectors(r2, i2), c2.cross(u2), o2.fromBufferAttribute(n2, d3), a2.fromBufferAttribute(n2, h2), l2.fromBufferAttribute(n2, f2), o2.add(c2), a2.add(c2), l2.add(c2), n2.setXYZ(d3, o2.x, o2.y, o2.z), n2.setXYZ(h2, a2.x, a2.y, a2.z), n2.setXYZ(f2, l2.x, l2.y, l2.z);
          }
        else
          for (let e3 = 0, o3 = t2.count; e3 < o3; e3 += 3)
            r2.fromBufferAttribute(t2, e3 + 0), i2.fromBufferAttribute(t2, e3 + 1), s2.fromBufferAttribute(t2, e3 + 2), c2.subVectors(s2, i2), u2.subVectors(r2, i2), c2.cross(u2), n2.setXYZ(e3 + 0, c2.x, c2.y, c2.z), n2.setXYZ(e3 + 1, c2.x, c2.y, c2.z), n2.setXYZ(e3 + 2, c2.x, c2.y, c2.z);
        this.normalizeNormals(), n2.needsUpdate = true;
      }
    }
    merge() {
      return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeGeometries() instead."), this;
    }
    normalizeNormals() {
      const e2 = this.attributes.normal;
      for (let t2 = 0, n2 = e2.count; t2 < n2; t2++)
        _s.fromBufferAttribute(e2, t2), _s.normalize(), e2.setXYZ(t2, _s.x, _s.y, _s.z);
    }
    toNonIndexed() {
      function e2(e3, t3) {
        const n3 = e3.array, r3 = e3.itemSize, i3 = e3.normalized, s3 = new n3.constructor(t3.length * r3);
        let o2 = 0, a2 = 0;
        for (let i4 = 0, l2 = t3.length; i4 < l2; i4++) {
          o2 = e3.isInterleavedBufferAttribute ? t3[i4] * e3.data.stride + e3.offset : t3[i4] * r3;
          for (let e4 = 0; e4 < r3; e4++)
            s3[a2++] = n3[o2++];
        }
        return new $i(s3, r3, i3);
      }
      if (null === this.index)
        return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
      const t2 = new gs(), n2 = this.index.array, r2 = this.attributes;
      for (const i3 in r2) {
        const s3 = e2(r2[i3], n2);
        t2.setAttribute(i3, s3);
      }
      const i2 = this.morphAttributes;
      for (const r3 in i2) {
        const s3 = [], o2 = i2[r3];
        for (let t3 = 0, r4 = o2.length; t3 < r4; t3++) {
          const r5 = e2(o2[t3], n2);
          s3.push(r5);
        }
        t2.morphAttributes[r3] = s3;
      }
      t2.morphTargetsRelative = this.morphTargetsRelative;
      const s2 = this.groups;
      for (let e3 = 0, n3 = s2.length; e3 < n3; e3++) {
        const n4 = s2[e3];
        t2.addGroup(n4.start, n4.count, n4.materialIndex);
      }
      return t2;
    }
    toJSON() {
      const e2 = { metadata: { version: 4.6, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
      if (e2.uuid = this.uuid, e2.type = this.type, "" !== this.name && (e2.name = this.name), Object.keys(this.userData).length > 0 && (e2.userData = this.userData), void 0 !== this.parameters) {
        const t3 = this.parameters;
        for (const n3 in t3)
          void 0 !== t3[n3] && (e2[n3] = t3[n3]);
        return e2;
      }
      e2.data = { attributes: {} };
      const t2 = this.index;
      null !== t2 && (e2.data.index = { type: t2.array.constructor.name, array: Array.prototype.slice.call(t2.array) });
      const n2 = this.attributes;
      for (const t3 in n2) {
        const r3 = n2[t3];
        e2.data.attributes[t3] = r3.toJSON(e2.data);
      }
      const r2 = {};
      let i2 = false;
      for (const t3 in this.morphAttributes) {
        const n3 = this.morphAttributes[t3], s3 = [];
        for (let t4 = 0, r3 = n3.length; t4 < r3; t4++) {
          const r4 = n3[t4];
          s3.push(r4.toJSON(e2.data));
        }
        s3.length > 0 && (r2[t3] = s3, i2 = true);
      }
      i2 && (e2.data.morphAttributes = r2, e2.data.morphTargetsRelative = this.morphTargetsRelative);
      const s2 = this.groups;
      s2.length > 0 && (e2.data.groups = JSON.parse(JSON.stringify(s2)));
      const o2 = this.boundingSphere;
      return null !== o2 && (e2.data.boundingSphere = { center: o2.center.toArray(), radius: o2.radius }), e2;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e2) {
      this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
      const t2 = {};
      this.name = e2.name;
      const n2 = e2.index;
      null !== n2 && this.setIndex(n2.clone(t2));
      const r2 = e2.attributes;
      for (const e3 in r2) {
        const n3 = r2[e3];
        this.setAttribute(e3, n3.clone(t2));
      }
      const i2 = e2.morphAttributes;
      for (const e3 in i2) {
        const n3 = [], r3 = i2[e3];
        for (let e4 = 0, i3 = r3.length; e4 < i3; e4++)
          n3.push(r3[e4].clone(t2));
        this.morphAttributes[e3] = n3;
      }
      this.morphTargetsRelative = e2.morphTargetsRelative;
      const s2 = e2.groups;
      for (let e3 = 0, t3 = s2.length; e3 < t3; e3++) {
        const t4 = s2[e3];
        this.addGroup(t4.start, t4.count, t4.materialIndex);
      }
      const o2 = e2.boundingBox;
      null !== o2 && (this.boundingBox = o2.clone());
      const a2 = e2.boundingSphere;
      return null !== a2 && (this.boundingSphere = a2.clone()), this.drawRange.start = e2.drawRange.start, this.drawRange.count = e2.drawRange.count, this.userData = e2.userData, this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  }
  const vs = new Zr(), ys = new Jr(), bs = new Vr(), ws = new Ar(), As = new Ar(), xs = new Ar(), Es = new Ar(), Cs = new Ar(), Ss = new Ar(), Ms = new Qn(), Ts = new Qn(), Ps = new Qn(), Is = new Ar(), Rs = new Ar(), ks = new Ar(), Ds = new Ar(), Bs = new Ar();
  class Os extends xi {
    constructor(e2 = new gs(), t2 = new Qi()) {
      super(), this.isMesh = true, this.type = "Mesh", this.geometry = e2, this.material = t2, this.updateMorphTargets();
    }
    copy(e2, t2) {
      return super.copy(e2, t2), e2.isMesh ? (void 0 !== e2.morphTargetInfluences && (this.morphTargetInfluences = e2.morphTargetInfluences.slice()), void 0 !== e2.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e2.morphTargetDictionary)), this.material = e2.material, this.geometry = e2.geometry, this) : this;
    }
    updateMorphTargets() {
      const e2 = this.geometry.morphAttributes, t2 = Object.keys(e2);
      if (t2.length > 0) {
        const n2 = e2[t2[0]];
        if (void 0 !== n2) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let e3 = 0, t3 = n2.length; e3 < t3; e3++) {
            const t4 = n2[e3].name || String(e3);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[t4] = e3;
          }
        }
      }
    }
    getVertexPosition(e2, t2) {
      const n2 = this.geometry, r2 = n2.attributes.position, i2 = n2.morphAttributes.position, s2 = n2.morphTargetsRelative;
      t2.fromBufferAttribute(r2, e2);
      const o2 = this.morphTargetInfluences;
      if (i2 && o2) {
        Ss.set(0, 0, 0);
        for (let n3 = 0, r3 = i2.length; n3 < r3; n3++) {
          const r4 = o2[n3], a2 = i2[n3];
          0 !== r4 && (Cs.fromBufferAttribute(a2, e2), s2 ? Ss.addScaledVector(Cs, r4) : Ss.addScaledVector(Cs.sub(t2), r4));
        }
        t2.add(Ss);
      }
      return t2;
    }
    raycast(e2, t2) {
      const n2 = this.geometry, r2 = this.material, i2 = this.matrixWorld;
      if (void 0 !== r2) {
        if (null === n2.boundingSphere && n2.computeBoundingSphere(), bs.copy(n2.boundingSphere), bs.applyMatrix4(i2), ys.copy(e2.ray).recast(e2.near), false === bs.containsPoint(ys.origin)) {
          if (null === ys.intersectSphere(bs, ws))
            return;
          if (ys.origin.distanceToSquared(ws) > (e2.far - e2.near) ** 2)
            return;
        }
        vs.copy(i2).invert(), ys.copy(e2.ray).applyMatrix4(vs), null !== n2.boundingBox && false === ys.intersectsBox(n2.boundingBox) || this._computeIntersections(e2, t2, ys);
      }
    }
    _computeIntersections(e2, t2, n2) {
      let r2;
      const i2 = this.geometry, s2 = this.material, o2 = i2.index, a2 = i2.attributes.position, l2 = i2.attributes.uv, c2 = i2.attributes.uv1, u2 = i2.attributes.normal, p2 = i2.groups, d2 = i2.drawRange;
      if (null !== o2)
        if (Array.isArray(s2))
          for (let i3 = 0, a3 = p2.length; i3 < a3; i3++) {
            const a4 = p2[i3], h2 = s2[a4.materialIndex];
            for (let i4 = Math.max(a4.start, d2.start), s3 = Math.min(o2.count, Math.min(a4.start + a4.count, d2.start + d2.count)); i4 < s3; i4 += 3)
              r2 = Ls(this, h2, e2, n2, l2, c2, u2, o2.getX(i4), o2.getX(i4 + 1), o2.getX(i4 + 2)), r2 && (r2.faceIndex = Math.floor(i4 / 3), r2.face.materialIndex = a4.materialIndex, t2.push(r2));
          }
        else
          for (let i3 = Math.max(0, d2.start), a3 = Math.min(o2.count, d2.start + d2.count); i3 < a3; i3 += 3)
            r2 = Ls(this, s2, e2, n2, l2, c2, u2, o2.getX(i3), o2.getX(i3 + 1), o2.getX(i3 + 2)), r2 && (r2.faceIndex = Math.floor(i3 / 3), t2.push(r2));
      else if (void 0 !== a2)
        if (Array.isArray(s2))
          for (let i3 = 0, o3 = p2.length; i3 < o3; i3++) {
            const o4 = p2[i3], h2 = s2[o4.materialIndex];
            for (let i4 = Math.max(o4.start, d2.start), s3 = Math.min(a2.count, Math.min(o4.start + o4.count, d2.start + d2.count)); i4 < s3; i4 += 3)
              r2 = Ls(this, h2, e2, n2, l2, c2, u2, i4, i4 + 1, i4 + 2), r2 && (r2.faceIndex = Math.floor(i4 / 3), r2.face.materialIndex = o4.materialIndex, t2.push(r2));
          }
        else
          for (let i3 = Math.max(0, d2.start), o3 = Math.min(a2.count, d2.start + d2.count); i3 < o3; i3 += 3)
            r2 = Ls(this, s2, e2, n2, l2, c2, u2, i3, i3 + 1, i3 + 2), r2 && (r2.faceIndex = Math.floor(i3 / 3), t2.push(r2));
    }
  }
  function Ls(e2, t2, n2, r2, i2, s2, o2, a2, l2, c2) {
    e2.getVertexPosition(a2, As), e2.getVertexPosition(l2, xs), e2.getVertexPosition(c2, Es);
    const u2 = function(e3, t3, n3, r3, i3, s3, o3, a3) {
      let l3;
      if (l3 = t3.side === m ? r3.intersectTriangle(o3, s3, i3, true, a3) : r3.intersectTriangle(i3, s3, o3, t3.side === f, a3), null === l3)
        return null;
      Bs.copy(a3), Bs.applyMatrix4(e3.matrixWorld);
      const c3 = n3.ray.origin.distanceTo(Bs);
      return c3 < n3.near || c3 > n3.far ? null : { distance: c3, point: Bs.clone(), object: e3 };
    }(e2, t2, n2, r2, As, xs, Es, Ds);
    if (u2) {
      i2 && (Ms.fromBufferAttribute(i2, a2), Ts.fromBufferAttribute(i2, l2), Ps.fromBufferAttribute(i2, c2), u2.uv = Oi.getInterpolation(Ds, As, xs, Es, Ms, Ts, Ps, new Qn())), s2 && (Ms.fromBufferAttribute(s2, a2), Ts.fromBufferAttribute(s2, l2), Ps.fromBufferAttribute(s2, c2), u2.uv1 = Oi.getInterpolation(Ds, As, xs, Es, Ms, Ts, Ps, new Qn()), u2.uv2 = u2.uv1), o2 && (Is.fromBufferAttribute(o2, a2), Rs.fromBufferAttribute(o2, l2), ks.fromBufferAttribute(o2, c2), u2.normal = Oi.getInterpolation(Ds, As, xs, Es, Is, Rs, ks, new Ar()), u2.normal.dot(r2.direction) > 0 && u2.normal.multiplyScalar(-1));
      const e3 = { a: a2, b: l2, c: c2, normal: new Ar(), materialIndex: 0 };
      Oi.getNormal(As, xs, Es, e3.normal), u2.face = e3;
    }
    return u2;
  }
  class Us extends gs {
    constructor(e2 = 1, t2 = 1, n2 = 1, r2 = 1, i2 = 1, s2 = 1) {
      super(), this.type = "BoxGeometry", this.parameters = { width: e2, height: t2, depth: n2, widthSegments: r2, heightSegments: i2, depthSegments: s2 };
      const o2 = this;
      r2 = Math.floor(r2), i2 = Math.floor(i2), s2 = Math.floor(s2);
      const a2 = [], l2 = [], c2 = [], u2 = [];
      let p2 = 0, d2 = 0;
      function h2(e3, t3, n3, r3, i3, s3, h3, f2, m2, _2, g2) {
        const v2 = s3 / m2, y2 = h3 / _2, b2 = s3 / 2, w2 = h3 / 2, A2 = f2 / 2, x2 = m2 + 1, E2 = _2 + 1;
        let C2 = 0, S2 = 0;
        const M2 = new Ar();
        for (let s4 = 0; s4 < E2; s4++) {
          const o3 = s4 * y2 - w2;
          for (let a3 = 0; a3 < x2; a3++) {
            const p3 = a3 * v2 - b2;
            M2[e3] = p3 * r3, M2[t3] = o3 * i3, M2[n3] = A2, l2.push(M2.x, M2.y, M2.z), M2[e3] = 0, M2[t3] = 0, M2[n3] = f2 > 0 ? 1 : -1, c2.push(M2.x, M2.y, M2.z), u2.push(a3 / m2), u2.push(1 - s4 / _2), C2 += 1;
          }
        }
        for (let e4 = 0; e4 < _2; e4++)
          for (let t4 = 0; t4 < m2; t4++) {
            const n4 = p2 + t4 + x2 * e4, r4 = p2 + t4 + x2 * (e4 + 1), i4 = p2 + (t4 + 1) + x2 * (e4 + 1), s4 = p2 + (t4 + 1) + x2 * e4;
            a2.push(n4, r4, s4), a2.push(r4, i4, s4), S2 += 6;
          }
        o2.addGroup(d2, S2, g2), d2 += S2, p2 += C2;
      }
      h2("z", "y", "x", -1, -1, n2, t2, e2, s2, i2, 0), h2("z", "y", "x", 1, -1, n2, t2, -e2, s2, i2, 1), h2("x", "z", "y", 1, 1, e2, n2, t2, r2, s2, 2), h2("x", "z", "y", 1, -1, e2, n2, -t2, r2, s2, 3), h2("x", "y", "z", 1, -1, e2, t2, n2, r2, i2, 4), h2("x", "y", "z", -1, -1, e2, t2, -n2, r2, i2, 5), this.setIndex(a2), this.setAttribute("position", new ls(l2, 3)), this.setAttribute("normal", new ls(c2, 3)), this.setAttribute("uv", new ls(u2, 2));
    }
    copy(e2) {
      return super.copy(e2), this.parameters = Object.assign({}, e2.parameters), this;
    }
    static fromJSON(e2) {
      return new Us(e2.width, e2.height, e2.depth, e2.widthSegments, e2.heightSegments, e2.depthSegments);
    }
  }
  function Fs(e2) {
    const t2 = {};
    for (const n2 in e2) {
      t2[n2] = {};
      for (const r2 in e2[n2]) {
        const i2 = e2[n2][r2];
        i2 && (i2.isColor || i2.isMatrix3 || i2.isMatrix4 || i2.isVector2 || i2.isVector3 || i2.isVector4 || i2.isTexture || i2.isQuaternion) ? i2.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), t2[n2][r2] = null) : t2[n2][r2] = i2.clone() : Array.isArray(i2) ? t2[n2][r2] = i2.slice() : t2[n2][r2] = i2;
      }
    }
    return t2;
  }
  function Ns(e2) {
    const t2 = {};
    for (let n2 = 0; n2 < e2.length; n2++) {
      const r2 = Fs(e2[n2]);
      for (const e3 in r2)
        t2[e3] = r2[e3];
    }
    return t2;
  }
  function js(e2) {
    return null === e2.getRenderTarget() ? e2.outputColorSpace : Gt;
  }
  const zs = { clone: Fs, merge: Ns };
  class Gs extends Ui {
    constructor(e2) {
      super(), this.isShaderMaterial = true, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.forceSinglePass = true, this.extensions = { derivatives: false, fragDepth: false, drawBuffers: false, shaderTextureLOD: false }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv1: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, void 0 !== e2 && this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.fragmentShader = e2.fragmentShader, this.vertexShader = e2.vertexShader, this.uniforms = Fs(e2.uniforms), this.uniformsGroups = function(e3) {
        const t2 = [];
        for (let n2 = 0; n2 < e3.length; n2++)
          t2.push(e3[n2].clone());
        return t2;
      }(e2.uniformsGroups), this.defines = Object.assign({}, e2.defines), this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this.fog = e2.fog, this.lights = e2.lights, this.clipping = e2.clipping, this.extensions = Object.assign({}, e2.extensions), this.glslVersion = e2.glslVersion, this;
    }
    toJSON(e2) {
      const t2 = super.toJSON(e2);
      t2.glslVersion = this.glslVersion, t2.uniforms = {};
      for (const n3 in this.uniforms) {
        const r2 = this.uniforms[n3].value;
        r2 && r2.isTexture ? t2.uniforms[n3] = { type: "t", value: r2.toJSON(e2).uuid } : r2 && r2.isColor ? t2.uniforms[n3] = { type: "c", value: r2.getHex() } : r2 && r2.isVector2 ? t2.uniforms[n3] = { type: "v2", value: r2.toArray() } : r2 && r2.isVector3 ? t2.uniforms[n3] = { type: "v3", value: r2.toArray() } : r2 && r2.isVector4 ? t2.uniforms[n3] = { type: "v4", value: r2.toArray() } : r2 && r2.isMatrix3 ? t2.uniforms[n3] = { type: "m3", value: r2.toArray() } : r2 && r2.isMatrix4 ? t2.uniforms[n3] = { type: "m4", value: r2.toArray() } : t2.uniforms[n3] = { value: r2 };
      }
      Object.keys(this.defines).length > 0 && (t2.defines = this.defines), t2.vertexShader = this.vertexShader, t2.fragmentShader = this.fragmentShader, t2.lights = this.lights, t2.clipping = this.clipping;
      const n2 = {};
      for (const e3 in this.extensions)
        true === this.extensions[e3] && (n2[e3] = true);
      return Object.keys(n2).length > 0 && (t2.extensions = n2), t2;
    }
  }
  class Vs extends xi {
    constructor() {
      super(), this.isCamera = true, this.type = "Camera", this.matrixWorldInverse = new Zr(), this.projectionMatrix = new Zr(), this.projectionMatrixInverse = new Zr(), this.coordinateSystem = Tn;
    }
    copy(e2, t2) {
      return super.copy(e2, t2), this.matrixWorldInverse.copy(e2.matrixWorldInverse), this.projectionMatrix.copy(e2.projectionMatrix), this.projectionMatrixInverse.copy(e2.projectionMatrixInverse), this.coordinateSystem = e2.coordinateSystem, this;
    }
    getWorldDirection(e2) {
      this.updateWorldMatrix(true, false);
      const t2 = this.matrixWorld.elements;
      return e2.set(-t2[8], -t2[9], -t2[10]).normalize();
    }
    updateMatrixWorld(e2) {
      super.updateMatrixWorld(e2), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(e2, t2) {
      super.updateWorldMatrix(e2, t2), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class Hs extends Vs {
    constructor(e2 = 50, t2 = 1, n2 = 0.1, r2 = 2e3) {
      super(), this.isPerspectiveCamera = true, this.type = "PerspectiveCamera", this.fov = e2, this.zoom = 1, this.near = n2, this.far = r2, this.focus = 10, this.aspect = t2, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
    }
    copy(e2, t2) {
      return super.copy(e2, t2), this.fov = e2.fov, this.zoom = e2.zoom, this.near = e2.near, this.far = e2.far, this.focus = e2.focus, this.aspect = e2.aspect, this.view = null === e2.view ? null : Object.assign({}, e2.view), this.filmGauge = e2.filmGauge, this.filmOffset = e2.filmOffset, this;
    }
    setFocalLength(e2) {
      const t2 = 0.5 * this.getFilmHeight() / e2;
      this.fov = 2 * Bn * Math.atan(t2), this.updateProjectionMatrix();
    }
    getFocalLength() {
      const e2 = Math.tan(0.5 * Dn * this.fov);
      return 0.5 * this.getFilmHeight() / e2;
    }
    getEffectiveFOV() {
      return 2 * Bn * Math.atan(Math.tan(0.5 * Dn * this.fov) / this.zoom);
    }
    getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1);
    }
    setViewOffset(e2, t2, n2, r2, i2, s2) {
      this.aspect = e2 / t2, null === this.view && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = e2, this.view.fullHeight = t2, this.view.offsetX = n2, this.view.offsetY = r2, this.view.width = i2, this.view.height = s2, this.updateProjectionMatrix();
    }
    clearViewOffset() {
      null !== this.view && (this.view.enabled = false), this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const e2 = this.near;
      let t2 = e2 * Math.tan(0.5 * Dn * this.fov) / this.zoom, n2 = 2 * t2, r2 = this.aspect * n2, i2 = -0.5 * r2;
      const s2 = this.view;
      if (null !== this.view && this.view.enabled) {
        const e3 = s2.fullWidth, o3 = s2.fullHeight;
        i2 += s2.offsetX * r2 / e3, t2 -= s2.offsetY * n2 / o3, r2 *= s2.width / e3, n2 *= s2.height / o3;
      }
      const o2 = this.filmOffset;
      0 !== o2 && (i2 += e2 * o2 / this.getFilmWidth()), this.projectionMatrix.makePerspective(i2, i2 + r2, t2, t2 - n2, e2, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(e2) {
      const t2 = super.toJSON(e2);
      return t2.object.fov = this.fov, t2.object.zoom = this.zoom, t2.object.near = this.near, t2.object.far = this.far, t2.object.focus = this.focus, t2.object.aspect = this.aspect, null !== this.view && (t2.object.view = Object.assign({}, this.view)), t2.object.filmGauge = this.filmGauge, t2.object.filmOffset = this.filmOffset, t2;
    }
  }
  const Qs = -90;
  class Ws extends xi {
    constructor(e2, t2, n2) {
      super(), this.type = "CubeCamera", this.renderTarget = n2, this.coordinateSystem = null;
      const r2 = new Hs(Qs, 1, e2, t2);
      r2.layers = this.layers, this.add(r2);
      const i2 = new Hs(Qs, 1, e2, t2);
      i2.layers = this.layers, this.add(i2);
      const s2 = new Hs(Qs, 1, e2, t2);
      s2.layers = this.layers, this.add(s2);
      const o2 = new Hs(Qs, 1, e2, t2);
      o2.layers = this.layers, this.add(o2);
      const a2 = new Hs(Qs, 1, e2, t2);
      a2.layers = this.layers, this.add(a2);
      const l2 = new Hs(Qs, 1, e2, t2);
      l2.layers = this.layers, this.add(l2);
    }
    updateCoordinateSystem() {
      const e2 = this.coordinateSystem, t2 = this.children.concat(), [n2, r2, i2, s2, o2, a2] = t2;
      for (const e3 of t2)
        this.remove(e3);
      if (e2 === Tn)
        n2.up.set(0, 1, 0), n2.lookAt(1, 0, 0), r2.up.set(0, 1, 0), r2.lookAt(-1, 0, 0), i2.up.set(0, 0, -1), i2.lookAt(0, 1, 0), s2.up.set(0, 0, 1), s2.lookAt(0, -1, 0), o2.up.set(0, 1, 0), o2.lookAt(0, 0, 1), a2.up.set(0, 1, 0), a2.lookAt(0, 0, -1);
      else {
        if (e2 !== Pn)
          throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e2);
        n2.up.set(0, -1, 0), n2.lookAt(-1, 0, 0), r2.up.set(0, -1, 0), r2.lookAt(1, 0, 0), i2.up.set(0, 0, 1), i2.lookAt(0, 1, 0), s2.up.set(0, 0, -1), s2.lookAt(0, -1, 0), o2.up.set(0, -1, 0), o2.lookAt(0, 0, 1), a2.up.set(0, -1, 0), a2.lookAt(0, 0, -1);
      }
      for (const e3 of t2)
        this.add(e3), e3.updateMatrixWorld();
    }
    update(e2, t2) {
      null === this.parent && this.updateMatrixWorld();
      const n2 = this.renderTarget;
      this.coordinateSystem !== e2.coordinateSystem && (this.coordinateSystem = e2.coordinateSystem, this.updateCoordinateSystem());
      const [r2, i2, s2, o2, a2, l2] = this.children, c2 = e2.getRenderTarget(), u2 = e2.toneMapping, p2 = e2.xr.enabled;
      e2.toneMapping = J, e2.xr.enabled = false;
      const d2 = n2.texture.generateMipmaps;
      n2.texture.generateMipmaps = false, e2.setRenderTarget(n2, 0), e2.render(t2, r2), e2.setRenderTarget(n2, 1), e2.render(t2, i2), e2.setRenderTarget(n2, 2), e2.render(t2, s2), e2.setRenderTarget(n2, 3), e2.render(t2, o2), e2.setRenderTarget(n2, 4), e2.render(t2, a2), n2.texture.generateMipmaps = d2, e2.setRenderTarget(n2, 5), e2.render(t2, l2), e2.setRenderTarget(c2), e2.toneMapping = u2, e2.xr.enabled = p2, n2.texture.needsPMREMUpdate = true;
    }
  }
  class qs extends hr {
    constructor(e2, t2, n2, r2, i2, s2, o2, a2, l2, c2) {
      super(e2 = void 0 !== e2 ? e2 : [], t2 = void 0 !== t2 ? t2 : ie, n2, r2, i2, s2, o2, a2, l2, c2), this.isCubeTexture = true, this.flipY = false;
    }
    get images() {
      return this.image;
    }
    set images(e2) {
      this.image = e2;
    }
  }
  class Xs extends mr {
    constructor(e2 = 1, t2 = {}) {
      super(e2, e2, t2), this.isWebGLCubeRenderTarget = true;
      const n2 = { width: e2, height: e2, depth: 1 }, r2 = [n2, n2, n2, n2, n2, n2];
      void 0 !== t2.encoding && ($n("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."), t2.colorSpace = t2.encoding === Ot ? zt : jt), this.texture = new qs(r2, t2.mapping, t2.wrapS, t2.wrapT, t2.magFilter, t2.minFilter, t2.format, t2.type, t2.anisotropy, t2.colorSpace), this.texture.isRenderTargetTexture = true, this.texture.generateMipmaps = void 0 !== t2.generateMipmaps && t2.generateMipmaps, this.texture.minFilter = void 0 !== t2.minFilter ? t2.minFilter : ge;
    }
    fromEquirectangularTexture(e2, t2) {
      this.texture.type = t2.type, this.texture.colorSpace = t2.colorSpace, this.texture.generateMipmaps = t2.generateMipmaps, this.texture.minFilter = t2.minFilter, this.texture.magFilter = t2.magFilter;
      const n2 = { tEquirect: { value: null } }, r2 = "\n\n				varying vec3 vWorldDirection;\n\n				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n				}\n\n				void main() {\n\n					vWorldDirection = transformDirection( position, modelMatrix );\n\n					#include <begin_vertex>\n					#include <project_vertex>\n\n				}\n			", i2 = "\n\n				uniform sampler2D tEquirect;\n\n				varying vec3 vWorldDirection;\n\n				#include <common>\n\n				void main() {\n\n					vec3 direction = normalize( vWorldDirection );\n\n					vec2 sampleUV = equirectUv( direction );\n\n					gl_FragColor = texture2D( tEquirect, sampleUV );\n\n				}\n			", s2 = new Us(5, 5, 5), o2 = new Gs({ name: "CubemapFromEquirect", uniforms: Fs(n2), vertexShader: r2, fragmentShader: i2, side: m, blending: v });
      o2.uniforms.tEquirect.value = t2;
      const a2 = new Os(s2, o2), l2 = t2.minFilter;
      return t2.minFilter === be && (t2.minFilter = ge), new Ws(1, 10, this).update(e2, a2), t2.minFilter = l2, a2.geometry.dispose(), a2.material.dispose(), this;
    }
    clear(e2, t2, n2, r2) {
      const i2 = e2.getRenderTarget();
      for (let i3 = 0; i3 < 6; i3++)
        e2.setRenderTarget(this, i3), e2.clear(t2, n2, r2);
      e2.setRenderTarget(i2);
    }
  }
  const Ys = new Ar(), Ks = new Ar(), Js = new Wn();
  class Zs {
    constructor(e2 = new Ar(1, 0, 0), t2 = 0) {
      this.isPlane = true, this.normal = e2, this.constant = t2;
    }
    set(e2, t2) {
      return this.normal.copy(e2), this.constant = t2, this;
    }
    setComponents(e2, t2, n2, r2) {
      return this.normal.set(e2, t2, n2), this.constant = r2, this;
    }
    setFromNormalAndCoplanarPoint(e2, t2) {
      return this.normal.copy(e2), this.constant = -t2.dot(this.normal), this;
    }
    setFromCoplanarPoints(e2, t2, n2) {
      const r2 = Ys.subVectors(n2, t2).cross(Ks.subVectors(e2, t2)).normalize();
      return this.setFromNormalAndCoplanarPoint(r2, e2), this;
    }
    copy(e2) {
      return this.normal.copy(e2.normal), this.constant = e2.constant, this;
    }
    normalize() {
      const e2 = 1 / this.normal.length();
      return this.normal.multiplyScalar(e2), this.constant *= e2, this;
    }
    negate() {
      return this.constant *= -1, this.normal.negate(), this;
    }
    distanceToPoint(e2) {
      return this.normal.dot(e2) + this.constant;
    }
    distanceToSphere(e2) {
      return this.distanceToPoint(e2.center) - e2.radius;
    }
    projectPoint(e2, t2) {
      return t2.copy(e2).addScaledVector(this.normal, -this.distanceToPoint(e2));
    }
    intersectLine(e2, t2) {
      const n2 = e2.delta(Ys), r2 = this.normal.dot(n2);
      if (0 === r2)
        return 0 === this.distanceToPoint(e2.start) ? t2.copy(e2.start) : null;
      const i2 = -(e2.start.dot(this.normal) + this.constant) / r2;
      return i2 < 0 || i2 > 1 ? null : t2.copy(e2.start).addScaledVector(n2, i2);
    }
    intersectsLine(e2) {
      const t2 = this.distanceToPoint(e2.start), n2 = this.distanceToPoint(e2.end);
      return t2 < 0 && n2 > 0 || n2 < 0 && t2 > 0;
    }
    intersectsBox(e2) {
      return e2.intersectsPlane(this);
    }
    intersectsSphere(e2) {
      return e2.intersectsPlane(this);
    }
    coplanarPoint(e2) {
      return e2.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(e2, t2) {
      const n2 = t2 || Js.getNormalMatrix(e2), r2 = this.coplanarPoint(Ys).applyMatrix4(e2), i2 = this.normal.applyMatrix3(n2).normalize();
      return this.constant = -r2.dot(i2), this;
    }
    translate(e2) {
      return this.constant -= e2.dot(this.normal), this;
    }
    equals(e2) {
      return e2.normal.equals(this.normal) && e2.constant === this.constant;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const $s = new Vr(), eo = new Ar();
  class to {
    constructor(e2 = new Zs(), t2 = new Zs(), n2 = new Zs(), r2 = new Zs(), i2 = new Zs(), s2 = new Zs()) {
      this.planes = [e2, t2, n2, r2, i2, s2];
    }
    set(e2, t2, n2, r2, i2, s2) {
      const o2 = this.planes;
      return o2[0].copy(e2), o2[1].copy(t2), o2[2].copy(n2), o2[3].copy(r2), o2[4].copy(i2), o2[5].copy(s2), this;
    }
    copy(e2) {
      const t2 = this.planes;
      for (let n2 = 0; n2 < 6; n2++)
        t2[n2].copy(e2.planes[n2]);
      return this;
    }
    setFromProjectionMatrix(e2, t2 = Tn) {
      const n2 = this.planes, r2 = e2.elements, i2 = r2[0], s2 = r2[1], o2 = r2[2], a2 = r2[3], l2 = r2[4], c2 = r2[5], u2 = r2[6], p2 = r2[7], d2 = r2[8], h2 = r2[9], f2 = r2[10], m2 = r2[11], _2 = r2[12], g2 = r2[13], v2 = r2[14], y2 = r2[15];
      if (n2[0].setComponents(a2 - i2, p2 - l2, m2 - d2, y2 - _2).normalize(), n2[1].setComponents(a2 + i2, p2 + l2, m2 + d2, y2 + _2).normalize(), n2[2].setComponents(a2 + s2, p2 + c2, m2 + h2, y2 + g2).normalize(), n2[3].setComponents(a2 - s2, p2 - c2, m2 - h2, y2 - g2).normalize(), n2[4].setComponents(a2 - o2, p2 - u2, m2 - f2, y2 - v2).normalize(), t2 === Tn)
        n2[5].setComponents(a2 + o2, p2 + u2, m2 + f2, y2 + v2).normalize();
      else {
        if (t2 !== Pn)
          throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t2);
        n2[5].setComponents(o2, u2, f2, v2).normalize();
      }
      return this;
    }
    intersectsObject(e2) {
      if (void 0 !== e2.boundingSphere)
        null === e2.boundingSphere && e2.computeBoundingSphere(), $s.copy(e2.boundingSphere).applyMatrix4(e2.matrixWorld);
      else {
        const t2 = e2.geometry;
        null === t2.boundingSphere && t2.computeBoundingSphere(), $s.copy(t2.boundingSphere).applyMatrix4(e2.matrixWorld);
      }
      return this.intersectsSphere($s);
    }
    intersectsSprite(e2) {
      return $s.center.set(0, 0, 0), $s.radius = 0.7071067811865476, $s.applyMatrix4(e2.matrixWorld), this.intersectsSphere($s);
    }
    intersectsSphere(e2) {
      const t2 = this.planes, n2 = e2.center, r2 = -e2.radius;
      for (let e3 = 0; e3 < 6; e3++)
        if (t2[e3].distanceToPoint(n2) < r2)
          return false;
      return true;
    }
    intersectsBox(e2) {
      const t2 = this.planes;
      for (let n2 = 0; n2 < 6; n2++) {
        const r2 = t2[n2];
        if (eo.x = r2.normal.x > 0 ? e2.max.x : e2.min.x, eo.y = r2.normal.y > 0 ? e2.max.y : e2.min.y, eo.z = r2.normal.z > 0 ? e2.max.z : e2.min.z, r2.distanceToPoint(eo) < 0)
          return false;
      }
      return true;
    }
    containsPoint(e2) {
      const t2 = this.planes;
      for (let n2 = 0; n2 < 6; n2++)
        if (t2[n2].distanceToPoint(e2) < 0)
          return false;
      return true;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  function no() {
    let e2 = null, t2 = false, n2 = null, r2 = null;
    function i2(t3, s2) {
      n2(t3, s2), r2 = e2.requestAnimationFrame(i2);
    }
    return { start: function() {
      true !== t2 && null !== n2 && (r2 = e2.requestAnimationFrame(i2), t2 = true);
    }, stop: function() {
      e2.cancelAnimationFrame(r2), t2 = false;
    }, setAnimationLoop: function(e3) {
      n2 = e3;
    }, setContext: function(t3) {
      e2 = t3;
    } };
  }
  function ro(e2, t2) {
    const n2 = t2.isWebGL2, r2 = /* @__PURE__ */ new WeakMap();
    return { get: function(e3) {
      return e3.isInterleavedBufferAttribute && (e3 = e3.data), r2.get(e3);
    }, remove: function(t3) {
      t3.isInterleavedBufferAttribute && (t3 = t3.data);
      const n3 = r2.get(t3);
      n3 && (e2.deleteBuffer(n3.buffer), r2.delete(t3));
    }, update: function(t3, i2) {
      if (t3.isGLBufferAttribute) {
        const e3 = r2.get(t3);
        return void ((!e3 || e3.version < t3.version) && r2.set(t3, { buffer: t3.buffer, type: t3.type, bytesPerElement: t3.elementSize, version: t3.version }));
      }
      t3.isInterleavedBufferAttribute && (t3 = t3.data);
      const s2 = r2.get(t3);
      void 0 === s2 ? r2.set(t3, function(t4, r3) {
        const i3 = t4.array, s3 = t4.usage, o2 = e2.createBuffer();
        let a2;
        if (e2.bindBuffer(r3, o2), e2.bufferData(r3, i3, s3), t4.onUploadCallback(), i3 instanceof Float32Array)
          a2 = e2.FLOAT;
        else if (i3 instanceof Uint16Array)
          if (t4.isFloat16BufferAttribute) {
            if (!n2)
              throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
            a2 = e2.HALF_FLOAT;
          } else
            a2 = e2.UNSIGNED_SHORT;
        else if (i3 instanceof Int16Array)
          a2 = e2.SHORT;
        else if (i3 instanceof Uint32Array)
          a2 = e2.UNSIGNED_INT;
        else if (i3 instanceof Int32Array)
          a2 = e2.INT;
        else if (i3 instanceof Int8Array)
          a2 = e2.BYTE;
        else if (i3 instanceof Uint8Array)
          a2 = e2.UNSIGNED_BYTE;
        else {
          if (!(i3 instanceof Uint8ClampedArray))
            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + i3);
          a2 = e2.UNSIGNED_BYTE;
        }
        return { buffer: o2, type: a2, bytesPerElement: i3.BYTES_PER_ELEMENT, version: t4.version };
      }(t3, i2)) : s2.version < t3.version && (function(t4, r3, i3) {
        const s3 = r3.array, o2 = r3.updateRange;
        e2.bindBuffer(i3, t4), -1 === o2.count ? e2.bufferSubData(i3, 0, s3) : (n2 ? e2.bufferSubData(i3, o2.offset * s3.BYTES_PER_ELEMENT, s3, o2.offset, o2.count) : e2.bufferSubData(i3, o2.offset * s3.BYTES_PER_ELEMENT, s3.subarray(o2.offset, o2.offset + o2.count)), o2.count = -1), r3.onUploadCallback();
      }(s2.buffer, t3, i2), s2.version = t3.version);
    } };
  }
  class io extends gs {
    constructor(e2 = 1, t2 = 1, n2 = 1, r2 = 1) {
      super(), this.type = "PlaneGeometry", this.parameters = { width: e2, height: t2, widthSegments: n2, heightSegments: r2 };
      const i2 = e2 / 2, s2 = t2 / 2, o2 = Math.floor(n2), a2 = Math.floor(r2), l2 = o2 + 1, c2 = a2 + 1, u2 = e2 / o2, p2 = t2 / a2, d2 = [], h2 = [], f2 = [], m2 = [];
      for (let e3 = 0; e3 < c2; e3++) {
        const t3 = e3 * p2 - s2;
        for (let n3 = 0; n3 < l2; n3++) {
          const r3 = n3 * u2 - i2;
          h2.push(r3, -t3, 0), f2.push(0, 0, 1), m2.push(n3 / o2), m2.push(1 - e3 / a2);
        }
      }
      for (let e3 = 0; e3 < a2; e3++)
        for (let t3 = 0; t3 < o2; t3++) {
          const n3 = t3 + l2 * e3, r3 = t3 + l2 * (e3 + 1), i3 = t3 + 1 + l2 * (e3 + 1), s3 = t3 + 1 + l2 * e3;
          d2.push(n3, r3, s3), d2.push(r3, i3, s3);
        }
      this.setIndex(d2), this.setAttribute("position", new ls(h2, 3)), this.setAttribute("normal", new ls(f2, 3)), this.setAttribute("uv", new ls(m2, 2));
    }
    copy(e2) {
      return super.copy(e2), this.parameters = Object.assign({}, e2.parameters), this;
    }
    static fromJSON(e2) {
      return new io(e2.width, e2.height, e2.widthSegments, e2.heightSegments);
    }
  }
  const so = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n	#if defined(INVERSE_ALPHAMAP) && INVERSE_ALPHAMAP >= 1\n	diffuseColor.a *= 1.0-texture2D( alphaMap, vAlphaMapUv ).g;\n	#else\n	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n	#endif\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif", alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "float G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n} // validated", iridescence_fragment: "#ifdef USE_IRIDESCENCE\n	const mat3 XYZ_TO_REC709 = mat3(\n		 3.2404542, -0.9692660,  0.0556434,\n		-1.5371385,  1.8760108, -0.2040259,\n		-0.4985314,  0.0415560,  1.0572252\n	);\n	vec3 Fresnel0ToIor( vec3 fresnel0 ) {\n		vec3 sqrtF0 = sqrt( fresnel0 );\n		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n	}\n	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n	}\n	float IorToFresnel0( float transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n	}\n	vec3 evalSensitivity( float OPD, vec3 shift ) {\n		float phase = 2.0 * PI * OPD * 1.0e-9;\n		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n		xyz /= 1.0685e-7;\n		vec3 rgb = XYZ_TO_REC709 * xyz;\n		return rgb;\n	}\n	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n		vec3 I;\n		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n		float cosTheta2Sq = 1.0 - sinTheta2Sq;\n		if ( cosTheta2Sq < 0.0 ) {\n			 return vec3( 1.0 );\n		}\n		float cosTheta2 = sqrt( cosTheta2Sq );\n		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n		float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n		float R21 = R12;\n		float T121 = 1.0 - R12;\n		float phi12 = 0.0;\n		if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n		float phi21 = PI - phi12;\n		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n		vec3 phi23 = vec3( 0.0 );\n		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n		vec3 phi = vec3( phi21 ) + phi23;\n		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n		vec3 r123 = sqrt( R123 );\n		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n		vec3 C0 = R12 + Rs;\n		I = C0;\n		vec3 Cm = Rs - T121;\n		for ( int m = 1; m <= 2; ++ m ) {\n			Cm *= r123;\n			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n			I += Cm * Sm;\n		}\n		return max( I, vec3( 0.0 ) );\n	}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vBumpMapUv );\n		vec2 dSTdy = dFdy( vBumpMapUv );\n		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = dFdx( surf_pos.xyz );\n		vec3 vSigmaY = dFdy( surf_pos.xyz );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n	return dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define cubeUV_r0 1.0\n	#define cubeUV_v0 0.339\n	#define cubeUV_m0 - 2.0\n	#define cubeUV_r1 0.8\n	#define cubeUV_v1 0.276\n	#define cubeUV_m1 - 1.0\n	#define cubeUV_r4 0.4\n	#define cubeUV_v4 0.046\n	#define cubeUV_m4 2.0\n	#define cubeUV_r5 0.305\n	#define cubeUV_v5 0.016\n	#define cubeUV_m5 3.0\n	#define cubeUV_r6 0.21\n	#define cubeUV_v6 0.0038\n	#define cubeUV_m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= cubeUV_r1 ) {\n			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n		} else if ( roughness >= cubeUV_r4 ) {\n			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n		} else if ( roughness >= cubeUV_r5 ) {\n			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n		} else if ( roughness >= cubeUV_r6 ) {\n			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "vec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	reflectVec = transformDirection(reflectVec, rotationMatrix(vec3(0,1,0), envMapRotation));\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n	mat4 rotationMatrix(vec3 axis, float angle) {\n		axis = normalize(axis);\n		float s = sin(angle);\n		float c = cos(angle);\n		float oc = 1.0 - c;\n		return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n					oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n					oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n					0.0,                                0.0,                                0.0,                                1.0);\n	}\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform float envMapRotation;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif", envmap_physical_pars_fragment: "#ifdef USE_ENVMAP\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n		#if defined( FIX_ENV_DIRECTION )\n			vec3 worldNormal = normal;\n		#else\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#endif\n			worldNormal = transformDirection(worldNormal, rotationMatrix(vec3(0,1,0), envMapRotation));\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			#if !defined( FIX_ENV_DIRECTION )\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			#endif\n			reflectVec = transformDirection(reflectVec, rotationMatrix(vec3(0,1,0), envMapRotation));\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	#ifdef USE_ANISOTROPY\n		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n			#ifdef ENVMAP_TYPE_CUBE_UV\n				vec3 bentNormal = cross( bitangent, viewDir );\n				bentNormal = normalize( cross( bentNormal, bitangent ) );\n				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n				return getIBLRadiance( viewDir, bentNormal, roughness );\n			#else\n				return vec3( 0.0 );\n			#endif\n		}\n	#endif\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		vec2 fw = fwidth( coord ) * 0.5;\n		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n	#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif", lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;", lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n	vec3 diffuseColor;\n	float specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Lambert\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( LEGACY_LIGHTS )\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#else\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	material.ior = ior;\n	#ifdef USE_SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULAR_COLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n		#endif\n		#ifdef USE_SPECULAR_INTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEEN_COLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	#ifdef USE_ANISOTROPYMAP\n		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n	#else\n		vec2 anisotropyV = anisotropyVector;\n	#endif\n	material.anisotropy = length( anisotropyV );\n	anisotropyV /= material.anisotropy;\n	material.anisotropy = saturate( material.anisotropy );\n	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;\n	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n	#ifdef IOR\n		float ior;\n	#endif\n	#ifdef USE_TRANSMISSION\n		float transmission;\n		float transmissionAlpha;\n		float thickness;\n		float attenuationDistance;\n		vec3 attenuationColor;\n	#endif\n	#ifdef USE_ANISOTROPY\n		float anisotropy;\n		float alphaT;\n		vec3 anisotropyT;\n		vec3 anisotropyB;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n		float v = 0.5 / ( gv + gl );\n		return saturate(v);\n	}\n	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n		float a2 = alphaT * alphaB;\n		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n		highp float v2 = dot( v, v );\n		float w2 = a2 / v2;\n		return RECIPROCAL_PI * a2 * pow2 ( w2 );\n	}\n#endif\n#ifdef USE_CLEARCOAT\n	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n		vec3 f0 = material.clearcoatF0;\n		float f90 = material.clearcoatF90;\n		float roughness = material.clearcoatRoughness;\n		float alpha = pow2( roughness );\n		vec3 halfDir = normalize( lightDir + viewDir );\n		float dotNL = saturate( dot( normal, lightDir ) );\n		float dotNV = saturate( dot( normal, viewDir ) );\n		float dotNH = saturate( dot( normal, halfDir ) );\n		float dotVH = saturate( dot( viewDir, halfDir ) );\n		vec3 F = F_Schlick( f0, f90, dotVH );\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n		return F * ( V * D );\n	}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n	vec3 f0 = material.specularColor;\n	float f90 = material.specularF90;\n	float roughness = material.roughness;\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	#ifdef USE_IRIDESCENCE\n		F = mix( F, material.iridescenceFresnel, material.iridescence );\n	#endif\n	#ifdef USE_ANISOTROPY\n		float dotTL = dot( material.anisotropyT, lightDir );\n		float dotTV = dot( material.anisotropyT, viewDir );\n		float dotTH = dot( material.anisotropyT, halfDir );\n		float dotBL = dot( material.anisotropyB, lightDir );\n		float dotBV = dot( material.anisotropyB, viewDir );\n		float dotBH = dot( material.anisotropyB, halfDir );\n		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n	#else\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n	#endif\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n	float dotNVi = saturate( dot( normal, geometry.viewDir ) );\n	if ( material.iridescenceThickness == 0.0 ) {\n		material.iridescence = 0.0;\n	} else {\n		material.iridescence = saturate( material.iridescence );\n	}\n	if ( material.iridescence > 0.0 ) {\n		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n	}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	vec4 spotColor;\n	vec3 spotLightCoord;\n	bool inSpotLightMap;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n		#else\n		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#endif\n		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n		#endif\n		#undef SPOT_LIGHT_MAP_INDEX\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	#ifdef USE_ANISOTROPY\n		radiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );\n	#else\n		radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#endif\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif", map_fragment: "#ifdef USE_MAP\n	diffuseColor *= texture2D( map, vMapUv );\n#endif", map_pars_fragment: "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	#if defined( USE_POINTS_UV )\n		vec2 uv = vUv;\n	#else\n		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n	#endif\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_POINTS_UV )\n	varying vec2 vUv;\n#else\n	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n		uniform mat3 uvTransform;\n	#endif\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n	metalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif", morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform ivec2 morphTargetsTextureSize;\n		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n			int y = texelIndex / morphTargetsTextureSize.x;\n			int x = texelIndex - y * morphTargetsTextureSize.x;\n			ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n			return texelFetch( morphTargetsTexture, morphUV, 0 );\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif", normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal *= faceDirection;\n	#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n	#ifdef USE_TANGENT\n		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn = getTangentFrame( - vViewPosition, normal, vNormalMapUv );\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn[0] *= faceDirection;\n		tbn[1] *= faceDirection;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	#ifdef USE_TANGENT\n		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn2[0] *= faceDirection;\n		tbn2[1] *= faceDirection;\n	#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef USE_NORMALMAP_OBJECTSPACE\n	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	normal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif", normal_pars_fragment: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif", normal_pars_vertex: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif", normal_vertex: "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( uv.st );\n		vec2 st1 = dFdy( uv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n		return mat3( T * scale, B * scale, N );\n	}\n#endif", clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	clearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif", iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif", output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\ndiffuseColor.a = min(max(diffuseColor.a, 0.), 1.);\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n	return packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * depth - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n	roughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif", shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif", shadowmap_vertex: "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n	vec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n		shadowWorldPosition = worldPosition;\n		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n		#endif\n		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	uniform int boneTextureSize;\n	mat4 getBoneMatrix( const in float i ) {\n		float j = i * 4.0;\n		float x = mod( j, float( boneTextureSize ) );\n		float y = floor( j / float( boneTextureSize ) );\n		float dx = 1.0 / float( boneTextureSize );\n		float dy = 1.0 / float( boneTextureSize );\n		y = dy * ( y + 0.5 );\n		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n		mat4 bone = mat4( v1, v2, v3, v4 );\n		return bone;\n	}\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmission_fragment: "#ifdef USE_TRANSMISSION\n	material.transmission = transmission;\n	material.transmissionAlpha = 1.0;\n	material.thickness = thickness;\n	material.attenuationDistance = attenuationDistance;\n	material.attenuationColor = attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmitted = getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n		material.attenuationColor, material.attenuationDistance );\n	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif", transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	float w0( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n	}\n	float w1( float a ) {\n		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n	}\n	float w2( float a ){\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n	}\n	float w3( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * a * a );\n	}\n	float g0( float a ) {\n		return w0( a ) + w1( a );\n	}\n	float g1( float a ) {\n		return w2( a ) + w3( a );\n	}\n	float h0( float a ) {\n		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n	}\n	float h1( float a ) {\n		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n	}\n	#ifndef WebGL2Context\n	#define textureLod texture2DLodEXT\n	#define textureSize(s, lod) vec2(1024./pow(2.,float(lod)),1024./pow(2.,float(lod)))\n	#define isinf(x) (x > 1e20 || x < -1e20)\n	#endif\n	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n		uv = uv * texelSize.zw + 0.5;\n		vec2 iuv = floor( uv );\n		vec2 fuv = fract( uv );\n		float g0x = g0( fuv.x );\n		float g1x = g1( fuv.x );\n		float h0x = h0( fuv.x );\n		float h1x = h1( fuv.x );\n		float h0y = h0( fuv.y );\n		float h1y = h1( fuv.y );\n		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n	}\n	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n		vec2 fLodSizeInv = 1.0 / fLodSize;\n		vec2 cLodSizeInv = 1.0 / cLodSize;\n		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n		return mix( fSample, cSample, fract( lod ) );\n	}\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		if(roughness == 0.0) return transmissionSamplerMapTexelToLinear( texture2D( transmissionSamplerMap, fragCoord.xy ) );\n		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		return transmissionSamplerMapTexelToLinear( textureBicubic( transmissionSamplerMap, fragCoord.xy, lod ) );\n	}\n	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( isinf( attenuationDistance ) || attenuationDistance == 0.0) {\n			return vec3( 1.0 );\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 attenuatedColor = transmittance * transmittedLight.rgb;\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n	}\n#endif", uv_pars_fragment: "#ifdef USE_UV\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	uniform mat3 mapTransform;\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform mat3 alphaMapTransform;\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	uniform mat3 lightMapTransform;\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	uniform mat3 aoMapTransform;\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	uniform mat3 bumpMapTransform;\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	uniform mat3 normalMapTransform;\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	uniform mat3 displacementMapTransform;\n	varying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	uniform mat3 emissiveMapTransform;\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	uniform mat3 metalnessMapTransform;\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	uniform mat3 roughnessMapTransform;\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	uniform mat3 anisotropyMapTransform;\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	uniform mat3 clearcoatMapTransform;\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform mat3 clearcoatNormalMapTransform;\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform mat3 clearcoatRoughnessMapTransform;\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	uniform mat3 sheenColorMapTransform;\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	uniform mat3 sheenRoughnessMapTransform;\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	uniform mat3 iridescenceMapTransform;\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform mat3 iridescenceThicknessMapTransform;\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	uniform mat3 specularMapTransform;\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	uniform mat3 specularColorMapTransform;\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	uniform mat3 specularIntensityMapTransform;\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif", uv_vertex: "#ifdef USE_UV\n	vUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif", background_vert: "#ifdef HAS_TEXTURE\nvarying vec2 vUv;\nuniform mat3 uvTransform;\nuniform bool flipX;\nuniform bool flipY;\n#endif\nvoid main() {\n#ifdef HAS_TEXTURE\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n    vUv = flipX ? vec2( 1.0 - vUv.x, vUv.y ) : vUv;\n    vUv = flipY ? vec2( vUv.x, 1.0 - vUv.y ) : vUv;\n#endif\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}", background_frag: "#ifdef HAS_TEXTURE\nuniform sampler2D t2D;\nvarying vec2 vUv;\n#endif\nuniform float backgroundIntensity;\nuniform vec3 backgroundColor;\nvoid main() {\n#ifdef HAS_TEXTURE\n	vec4 texColor = texture2D( t2D, vUv );\n#else\n	vec4 texColor = vec4( 1.0 );\n#endif\n	texColor.rgb *= backgroundColor * backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}", backgroundCube_frag: "#include <envmap_common_pars_fragment>\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	vReflect = transformDirection(vReflect, rotationMatrix(vec3(0,1,0), envMapRotation));\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vReflect.x, vReflect.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 texColor = textureCubeUV( envMap, vReflect, backgroundBlurriness );\n	#else\n		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	texColor.rgb *= envMapIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}", cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = texColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_lambert_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}", meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef USE_SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULAR_COLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n	#ifdef USE_SPECULAR_INTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEEN_COLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	uniform vec2 anisotropyVector;\n	#ifdef USE_ANISOTROPYMAP\n		uniform sampler2D anisotropyMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n	varying vec2 vUv;\n	uniform mat3 uvTransform;\n#endif\nvoid main() {\n	#ifdef USE_POINTS_UV\n		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	#endif\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}" }, oo = { common: { diffuse: { value: new Vi(16777215) }, opacity: { value: 1 }, map: { value: null }, mapTransform: { value: new Wn() }, alphaMap: { value: null }, alphaMapTransform: { value: new Wn() }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null }, specularMapTransform: { value: new Wn() } }, envmap: { envMap: { value: null }, envMapRotation: { value: 0 }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: 0.98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 }, aoMapTransform: { value: new Wn() } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 }, lightMapTransform: { value: new Wn() } }, bumpmap: { bumpMap: { value: null }, bumpMapTransform: { value: new Wn() }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalMapTransform: { value: new Wn() }, normalScale: { value: new Qn(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementMapTransform: { value: new Wn() }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, emissivemap: { emissiveMap: { value: null }, emissiveMapTransform: { value: new Wn() } }, metalnessmap: { metalnessMap: { value: null }, metalnessMapTransform: { value: new Wn() } }, roughnessmap: { roughnessMap: { value: null }, roughnessMapTransform: { value: new Wn() } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Vi(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotLightMap: { value: [] }, spotShadowMap: { value: [] }, spotLightMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Vi(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaMapTransform: { value: new Wn() }, alphaTest: { value: 0 }, uvTransform: { value: new Wn() } }, sprite: { diffuse: { value: new Vi(16777215) }, opacity: { value: 1 }, center: { value: new Qn(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, mapTransform: { value: new Wn() }, alphaMap: { value: null }, alphaMapTransform: { value: new Wn() }, alphaTest: { value: 0 } } }, ao = { basic: { uniforms: Ns([oo.common, oo.specularmap, oo.envmap, oo.aomap, oo.lightmap, oo.fog]), vertexShader: so.meshbasic_vert, fragmentShader: so.meshbasic_frag }, lambert: { uniforms: Ns([oo.common, oo.specularmap, oo.envmap, oo.aomap, oo.lightmap, oo.emissivemap, oo.bumpmap, oo.normalmap, oo.displacementmap, oo.fog, oo.lights, { emissive: { value: new Vi(0) } }]), vertexShader: so.meshlambert_vert, fragmentShader: so.meshlambert_frag }, phong: { uniforms: Ns([oo.common, oo.specularmap, oo.envmap, oo.aomap, oo.lightmap, oo.emissivemap, oo.bumpmap, oo.normalmap, oo.displacementmap, oo.fog, oo.lights, { emissive: { value: new Vi(0) }, specular: { value: new Vi(1118481) }, shininess: { value: 30 } }]), vertexShader: so.meshphong_vert, fragmentShader: so.meshphong_frag }, standard: { uniforms: Ns([oo.common, oo.envmap, oo.aomap, oo.lightmap, oo.emissivemap, oo.bumpmap, oo.normalmap, oo.displacementmap, oo.roughnessmap, oo.metalnessmap, oo.fog, oo.lights, { emissive: { value: new Vi(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: so.meshphysical_vert, fragmentShader: so.meshphysical_frag }, toon: { uniforms: Ns([oo.common, oo.aomap, oo.lightmap, oo.emissivemap, oo.bumpmap, oo.normalmap, oo.displacementmap, oo.gradientmap, oo.fog, oo.lights, { emissive: { value: new Vi(0) } }]), vertexShader: so.meshtoon_vert, fragmentShader: so.meshtoon_frag }, matcap: { uniforms: Ns([oo.common, oo.bumpmap, oo.normalmap, oo.displacementmap, oo.fog, { matcap: { value: null } }]), vertexShader: so.meshmatcap_vert, fragmentShader: so.meshmatcap_frag }, points: { uniforms: Ns([oo.points, oo.fog]), vertexShader: so.points_vert, fragmentShader: so.points_frag }, dashed: { uniforms: Ns([oo.common, oo.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: so.linedashed_vert, fragmentShader: so.linedashed_frag }, depth: { uniforms: Ns([oo.common, oo.displacementmap]), vertexShader: so.depth_vert, fragmentShader: so.depth_frag }, normal: { uniforms: Ns([oo.common, oo.bumpmap, oo.normalmap, oo.displacementmap, { opacity: { value: 1 } }]), vertexShader: so.meshnormal_vert, fragmentShader: so.meshnormal_frag }, sprite: { uniforms: Ns([oo.sprite, oo.fog]), vertexShader: so.sprite_vert, fragmentShader: so.sprite_frag }, background: { uniforms: { uvTransform: { value: new Wn() }, t2D: { value: null }, backgroundIntensity: { value: 1 }, backgroundColor: { value: new Vi(16777215) }, flipX: { value: false }, flipY: { value: false } }, vertexShader: so.background_vert, fragmentShader: so.background_frag }, backgroundCube: { uniforms: { envMap: { value: null }, envMapRotation: { value: 0 }, envMapIntensity: { value: 1 }, flipEnvMap: { value: -1 }, backgroundBlurriness: { value: 0 }, backgroundIntensity: { value: 1 } }, vertexShader: so.backgroundCube_vert, fragmentShader: so.backgroundCube_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: so.cube_vert, fragmentShader: so.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: so.equirect_vert, fragmentShader: so.equirect_frag }, distanceRGBA: { uniforms: Ns([oo.common, oo.displacementmap, { referencePosition: { value: new Ar() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: so.distanceRGBA_vert, fragmentShader: so.distanceRGBA_frag }, shadow: { uniforms: Ns([oo.lights, oo.fog, { color: { value: new Vi(0) }, opacity: { value: 1 } }]), vertexShader: so.shadow_vert, fragmentShader: so.shadow_frag } };
  ao.physical = { uniforms: Ns([ao.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatMapTransform: { value: new Wn() }, clearcoatNormalMap: { value: null }, clearcoatNormalMapTransform: { value: new Wn() }, clearcoatNormalScale: { value: new Qn(1, 1) }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatRoughnessMapTransform: { value: new Wn() }, iridescence: { value: 0 }, iridescenceMap: { value: null }, iridescenceMapTransform: { value: new Wn() }, iridescenceIOR: { value: 1.3 }, iridescenceThicknessMinimum: { value: 100 }, iridescenceThicknessMaximum: { value: 400 }, iridescenceThicknessMap: { value: null }, iridescenceThicknessMapTransform: { value: new Wn() }, sheen: { value: 0 }, sheenColor: { value: new Vi(0) }, sheenColorMap: { value: null }, sheenColorMapTransform: { value: new Wn() }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, sheenRoughnessMapTransform: { value: new Wn() }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionMapTransform: { value: new Wn() }, transmissionSamplerSize: { value: new Qn() }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, thicknessMapTransform: { value: new Wn() }, attenuationDistance: { value: 0 }, attenuationColor: { value: new Vi(0) }, specularColor: { value: new Vi(1, 1, 1) }, specularColorMap: { value: null }, specularColorMapTransform: { value: new Wn() }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularIntensityMapTransform: { value: new Wn() }, anisotropyVector: { value: new Qn() }, anisotropyMap: { value: null }, anisotropyMapTransform: { value: new Wn() } }]), vertexShader: so.meshphysical_vert, fragmentShader: so.meshphysical_frag };
  const lo = { r: 0, b: 0, g: 0 };
  function co(e2, t2, n2, r2, i2, s2, o2) {
    const a2 = new Vi(0);
    let l2, c2, u2 = true === s2 ? 0 : 1, p2 = null, d2 = 0, h2 = null;
    function _2(t3, n3) {
      t3.getRGB(lo, js(e2)), r2.buffers.color.setClear(lo.r, lo.g, lo.b, n3, o2);
    }
    return { getClearColor: function() {
      return a2;
    }, setClearColor: function(e3, t3 = 1) {
      a2.set(e3), u2 = t3, _2(a2, u2);
    }, getClearAlpha: function() {
      return u2;
    }, setClearAlpha: function(e3) {
      u2 = e3, _2(a2, u2);
    }, getPlaneMesh: function() {
      return l2;
    }, getBoxMesh: function() {
      return c2;
    }, getBoxMesh2: function() {
      return void 0 === c2 && (c2 = new Os(new Us(1, 1, 1), new Gs({ name: "BackgroundCubeMaterial", uniforms: Fs(ao.backgroundCube.uniforms), vertexShader: ao.backgroundCube.vertexShader, fragmentShader: ao.backgroundCube.fragmentShader, side: m, depthTest: false, depthWrite: false, fog: false })), c2.geometry.deleteAttribute("normal"), c2.geometry.deleteAttribute("uv"), c2.onBeforeRender = function(e3, t3, n3) {
        this.matrixWorld.copyPosition(n3.matrixWorld);
      }, Object.defineProperty(c2.material, "envMap", { get: function() {
        return this.uniforms.envMap.value;
      } }), i2.update(c2)), c2;
    }, render: function(s3, g2) {
      let v2 = false, y2 = true === g2.isScene ? g2.background : null;
      const b2 = g2.isScene && void 0 !== g2.backgroundColor ? g2.backgroundColor : null;
      switch ("environment" === y2 && (y2 = g2.environment), y2 && y2.isTexture && (y2 = (g2.backgroundBlurriness > 0 ? n2 : t2).get(y2)), null === y2 ? _2(a2, u2) : y2 && y2.isColor && (_2(y2, 1), v2 = true), e2.xr.getEnvironmentBlendMode()) {
        case "opaque":
          v2 = true;
          break;
        case "additive":
          r2.buffers.color.setClear(0, 0, 0, 1, o2), v2 = true;
          break;
        case "alpha-blend":
          r2.buffers.color.setClear(0, 0, 0, 0, o2), v2 = true;
      }
      if ((e2.autoClear || v2) && e2.clear(e2.autoClearColor, e2.autoClearDepth, e2.autoClearStencil), y2 && (y2.isCubeTexture || y2.mapping === le))
        void 0 === c2 && (c2 = new Os(new Us(1, 1, 1), new Gs({ name: "BackgroundCubeMaterial", uniforms: Fs(ao.backgroundCube.uniforms), vertexShader: ao.backgroundCube.vertexShader, fragmentShader: ao.backgroundCube.fragmentShader, side: m, depthTest: false, depthWrite: false, fog: false })), c2.geometry.deleteAttribute("normal"), c2.geometry.deleteAttribute("uv"), c2.onBeforeRender = function(e3, t3, n3) {
          this.matrixWorld.copyPosition(n3.matrixWorld);
        }, Object.defineProperty(c2.material, "envMap", { get: function() {
          return this.uniforms.envMap.value;
        } }), i2.update(c2)), c2.material.uniforms.envMap.value = y2, c2.material.uniforms.envMapRotation.value = y2 && y2.rotation || 0, c2.material.uniforms.envMapIntensity.value = y2 === g2.environment && g2.envMapIntensity || 1, c2.material.uniforms.flipEnvMap.value = y2.isCubeTexture && false === y2.isRenderTargetTexture ? -1 : 1, c2.material.uniforms.backgroundBlurriness.value = g2.backgroundBlurriness, c2.material.uniforms.backgroundIntensity.value = g2.backgroundIntensity, c2.material.toneMapped = y2.colorSpace !== zt, p2 === y2 && d2 === y2.version && h2 === e2.toneMapping || (c2.material.needsUpdate = true, p2 = y2, d2 = y2.version, h2 = e2.toneMapping), c2.layers.enableAll(), s3.unshift(c2, c2.geometry, c2.material, 0, 0, null);
      else if (y2 && y2.isTexture || !y2 && b2) {
        void 0 === l2 && (l2 = new Os(new io(2, 2), new Gs({ name: "BackgroundMaterial", uniforms: Fs(ao.background.uniforms), vertexShader: ao.background.vertexShader, fragmentShader: ao.background.fragmentShader, side: f, depthTest: false, depthWrite: false, fog: false })), l2.geometry.deleteAttribute("normal"), Object.defineProperty(l2.material, "map", { get: function() {
          return this.uniforms.t2D.value;
        } }), i2.update(l2)), l2.material.uniforms.backgroundColor.value.set(b2 || 16777215), l2.material.uniforms.t2D.value = y2, l2.material.uniforms.backgroundIntensity.value = g2.backgroundIntensity, y2 ? (l2.material.toneMapped = y2.colorSpace !== zt, l2.material.uniforms.flipX.value = y2.userData.flipX || false, l2.material.uniforms.flipY.value = y2.userData.flipY || false, true === y2.matrixAutoUpdate && y2.updateMatrix(), l2.material.uniforms.uvTransform.value.copy(y2.matrix), l2.material.defines.HAS_TEXTURE = "1") : l2.material.defines.HAS_TEXTURE && delete l2.material.defines.HAS_TEXTURE;
        const t3 = y2 ? y2.version : -1;
        p2 === y2 && d2 === t3 && h2 === e2.toneMapping || (l2.material.needsUpdate = true, p2 = y2, d2 = t3, h2 = e2.toneMapping), l2.layers.enableAll(), s3.unshift(l2, l2.geometry, l2.material, 0, 0, null);
      }
    } };
  }
  function uo(e2, t2, n2, r2) {
    const i2 = e2.getParameter(e2.MAX_VERTEX_ATTRIBS), s2 = r2.isWebGL2 ? null : t2.get("OES_vertex_array_object"), o2 = r2.isWebGL2 || null !== s2, a2 = {}, l2 = h2(null);
    let c2 = l2, u2 = false;
    function p2(t3) {
      return r2.isWebGL2 ? e2.bindVertexArray(t3) : s2.bindVertexArrayOES(t3);
    }
    function d2(t3) {
      return r2.isWebGL2 ? e2.deleteVertexArray(t3) : s2.deleteVertexArrayOES(t3);
    }
    function h2(e3) {
      const t3 = [], n3 = [], r3 = [];
      for (let e4 = 0; e4 < i2; e4++)
        t3[e4] = 0, n3[e4] = 0, r3[e4] = 0;
      return { geometry: null, program: null, wireframe: false, newAttributes: t3, enabledAttributes: n3, attributeDivisors: r3, object: e3, attributes: {}, index: null };
    }
    function f2() {
      const e3 = c2.newAttributes;
      for (let t3 = 0, n3 = e3.length; t3 < n3; t3++)
        e3[t3] = 0;
    }
    function m2(e3) {
      _2(e3, 0);
    }
    function _2(n3, i3) {
      const s3 = c2.newAttributes, o3 = c2.enabledAttributes, a3 = c2.attributeDivisors;
      s3[n3] = 1, 0 === o3[n3] && (e2.enableVertexAttribArray(n3), o3[n3] = 1), a3[n3] !== i3 && ((r2.isWebGL2 ? e2 : t2.get("ANGLE_instanced_arrays"))[r2.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n3, i3), a3[n3] = i3);
    }
    function g2() {
      const t3 = c2.newAttributes, n3 = c2.enabledAttributes;
      for (let r3 = 0, i3 = n3.length; r3 < i3; r3++)
        n3[r3] !== t3[r3] && (e2.disableVertexAttribArray(r3), n3[r3] = 0);
    }
    function v2(t3, n3, r3, i3, s3, o3, a3) {
      true === a3 ? e2.vertexAttribIPointer(t3, n3, r3, s3, o3) : e2.vertexAttribPointer(t3, n3, r3, i3, s3, o3);
    }
    function y2() {
      b2(), u2 = true, c2 !== l2 && (c2 = l2, p2(c2.object));
    }
    function b2() {
      l2.geometry = null, l2.program = null, l2.wireframe = false;
    }
    return { setup: function(i3, l3, d3, y3, b3) {
      let w2 = false;
      if (o2) {
        const t3 = function(t4, n3, i4) {
          const o3 = true === i4.wireframe;
          let l4 = a2[t4.id];
          void 0 === l4 && (l4 = {}, a2[t4.id] = l4);
          let c3 = l4[n3.id];
          void 0 === c3 && (c3 = {}, l4[n3.id] = c3);
          let u3 = c3[o3];
          return void 0 === u3 && (u3 = h2(r2.isWebGL2 ? e2.createVertexArray() : s2.createVertexArrayOES()), c3[o3] = u3), u3;
        }(y3, d3, l3);
        c2 !== t3 && (c2 = t3, p2(c2.object)), w2 = function(e3, t4, n3, r3) {
          const i4 = c2.attributes, s3 = t4.attributes;
          let o3 = 0;
          const a3 = n3.getAttributes();
          for (const t5 in a3)
            if (a3[t5].location >= 0) {
              const n4 = i4[t5];
              let r4 = s3[t5];
              if (void 0 === r4 && ("instanceMatrix" === t5 && e3.instanceMatrix && (r4 = e3.instanceMatrix), "instanceColor" === t5 && e3.instanceColor && (r4 = e3.instanceColor)), void 0 === n4)
                return true;
              if (n4.attribute !== r4)
                return true;
              if (r4 && n4.data !== r4.data)
                return true;
              o3++;
            }
          return c2.attributesNum !== o3 || c2.index !== r3;
        }(i3, y3, d3, b3), w2 && function(e3, t4, n3, r3) {
          const i4 = {}, s3 = t4.attributes;
          let o3 = 0;
          const a3 = n3.getAttributes();
          for (const t5 in a3)
            if (a3[t5].location >= 0) {
              let n4 = s3[t5];
              void 0 === n4 && ("instanceMatrix" === t5 && e3.instanceMatrix && (n4 = e3.instanceMatrix), "instanceColor" === t5 && e3.instanceColor && (n4 = e3.instanceColor));
              const r4 = {};
              r4.attribute = n4, n4 && n4.data && (r4.data = n4.data), i4[t5] = r4, o3++;
            }
          c2.attributes = i4, c2.attributesNum = o3, c2.index = r3;
        }(i3, y3, d3, b3);
      } else {
        const e3 = true === l3.wireframe;
        c2.geometry === y3.id && c2.program === d3.id && c2.wireframe === e3 || (c2.geometry = y3.id, c2.program = d3.id, c2.wireframe = e3, w2 = true);
      }
      null !== b3 && n2.update(b3, e2.ELEMENT_ARRAY_BUFFER), (w2 || u2) && (u2 = false, function(i4, s3, o3, a3) {
        if (false === r2.isWebGL2 && (i4.isInstancedMesh || a3.isInstancedBufferGeometry) && null === t2.get("ANGLE_instanced_arrays"))
          return;
        f2();
        const l4 = a3.attributes, c3 = o3.getAttributes(), u3 = s3.defaultAttributeValues;
        for (const t3 in c3) {
          const s4 = c3[t3];
          if (s4.location >= 0) {
            let o4 = l4[t3];
            if (void 0 === o4 && ("instanceMatrix" === t3 && i4.instanceMatrix && (o4 = i4.instanceMatrix), "instanceColor" === t3 && i4.instanceColor && (o4 = i4.instanceColor)), void 0 !== o4) {
              const t4 = o4.normalized, l5 = o4.itemSize, c4 = n2.get(o4);
              if (void 0 === c4)
                continue;
              const u4 = c4.buffer, p3 = c4.type, d4 = c4.bytesPerElement, h3 = true === r2.isWebGL2 && (p3 === e2.INT || p3 === e2.UNSIGNED_INT || o4.gpuType === Se);
              if (o4.isInterleavedBufferAttribute) {
                const n3 = o4.data, r3 = n3.stride, c5 = o4.offset;
                if (n3.isInstancedInterleavedBuffer) {
                  for (let e3 = 0; e3 < s4.locationSize; e3++)
                    _2(s4.location + e3, n3.meshPerAttribute);
                  true !== i4.isInstancedMesh && void 0 === a3._maxInstanceCount && (a3._maxInstanceCount = n3.meshPerAttribute * n3.count);
                } else
                  for (let e3 = 0; e3 < s4.locationSize; e3++)
                    m2(s4.location + e3);
                e2.bindBuffer(e2.ARRAY_BUFFER, u4);
                for (let e3 = 0; e3 < s4.locationSize; e3++)
                  v2(s4.location + e3, l5 / s4.locationSize, p3, t4, r3 * d4, (c5 + l5 / s4.locationSize * e3) * d4, h3);
              } else {
                if (o4.isInstancedBufferAttribute) {
                  for (let e3 = 0; e3 < s4.locationSize; e3++)
                    _2(s4.location + e3, o4.meshPerAttribute);
                  true !== i4.isInstancedMesh && void 0 === a3._maxInstanceCount && (a3._maxInstanceCount = o4.meshPerAttribute * o4.count);
                } else
                  for (let e3 = 0; e3 < s4.locationSize; e3++)
                    m2(s4.location + e3);
                e2.bindBuffer(e2.ARRAY_BUFFER, u4);
                for (let e3 = 0; e3 < s4.locationSize; e3++)
                  v2(s4.location + e3, l5 / s4.locationSize, p3, t4, l5 * d4, l5 / s4.locationSize * e3 * d4, h3);
              }
            } else if (void 0 !== u3) {
              const n3 = u3[t3];
              if (void 0 !== n3)
                switch (n3.length) {
                  case 2:
                    e2.vertexAttrib2fv(s4.location, n3);
                    break;
                  case 3:
                    e2.vertexAttrib3fv(s4.location, n3);
                    break;
                  case 4:
                    e2.vertexAttrib4fv(s4.location, n3);
                    break;
                  default:
                    e2.vertexAttrib1fv(s4.location, n3);
                }
            }
          }
        }
        g2();
      }(i3, l3, d3, y3), null !== b3 && e2.bindBuffer(e2.ELEMENT_ARRAY_BUFFER, n2.get(b3).buffer));
    }, reset: y2, resetDefaultState: b2, dispose: function() {
      y2();
      for (const e3 in a2) {
        const t3 = a2[e3];
        for (const e4 in t3) {
          const n3 = t3[e4];
          for (const e5 in n3)
            d2(n3[e5].object), delete n3[e5];
          delete t3[e4];
        }
        delete a2[e3];
      }
    }, releaseStatesOfGeometry: function(e3) {
      if (void 0 === a2[e3.id])
        return;
      const t3 = a2[e3.id];
      for (const e4 in t3) {
        const n3 = t3[e4];
        for (const e5 in n3)
          d2(n3[e5].object), delete n3[e5];
        delete t3[e4];
      }
      delete a2[e3.id];
    }, releaseStatesOfProgram: function(e3) {
      for (const t3 in a2) {
        const n3 = a2[t3];
        if (void 0 === n3[e3.id])
          continue;
        const r3 = n3[e3.id];
        for (const e4 in r3)
          d2(r3[e4].object), delete r3[e4];
        delete n3[e3.id];
      }
    }, initAttributes: f2, enableAttribute: m2, disableUnusedAttributes: g2 };
  }
  function po(e2, t2, n2, r2) {
    const i2 = r2.isWebGL2;
    let s2;
    this.setMode = function(e3) {
      s2 = e3;
    }, this.render = function(t3, r3) {
      e2.drawArrays(s2, t3, r3), n2.update(r3, s2, 1);
    }, this.renderInstances = function(r3, o2, a2) {
      if (0 === a2)
        return;
      let l2, c2;
      if (i2)
        l2 = e2, c2 = "drawArraysInstanced";
      else if (l2 = t2.get("ANGLE_instanced_arrays"), c2 = "drawArraysInstancedANGLE", null === l2)
        return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      l2[c2](s2, r3, o2, a2), n2.update(o2, s2, a2);
    };
  }
  function ho(e2, t2, n2) {
    let r2;
    function i2(t3) {
      if ("highp" === t3) {
        if (e2.getShaderPrecisionFormat(e2.VERTEX_SHADER, e2.HIGH_FLOAT).precision > 0 && e2.getShaderPrecisionFormat(e2.FRAGMENT_SHADER, e2.HIGH_FLOAT).precision > 0)
          return "highp";
        t3 = "mediump";
      }
      return "mediump" === t3 && e2.getShaderPrecisionFormat(e2.VERTEX_SHADER, e2.MEDIUM_FLOAT).precision > 0 && e2.getShaderPrecisionFormat(e2.FRAGMENT_SHADER, e2.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
    }
    const s2 = "undefined" != typeof WebGL2RenderingContext && "WebGL2RenderingContext" === e2.constructor.name;
    let o2 = void 0 !== n2.precision ? n2.precision : "highp";
    const a2 = i2(o2);
    a2 !== o2 && (console.warn("THREE.WebGLRenderer:", o2, "not supported, using", a2, "instead."), o2 = a2);
    const l2 = s2 || t2.has("WEBGL_draw_buffers"), c2 = true === n2.logarithmicDepthBuffer, u2 = e2.getParameter(e2.MAX_TEXTURE_IMAGE_UNITS), p2 = e2.getParameter(e2.MAX_VERTEX_TEXTURE_IMAGE_UNITS), d2 = e2.getParameter(e2.MAX_TEXTURE_SIZE), h2 = e2.getParameter(e2.MAX_CUBE_MAP_TEXTURE_SIZE), f2 = e2.getParameter(e2.MAX_VERTEX_ATTRIBS), m2 = e2.getParameter(e2.MAX_VERTEX_UNIFORM_VECTORS), _2 = e2.getParameter(e2.MAX_VARYING_VECTORS), g2 = e2.getParameter(e2.MAX_FRAGMENT_UNIFORM_VECTORS), v2 = p2 > 0, y2 = s2 || t2.has("OES_texture_float");
    return { isWebGL2: s2, drawBuffers: l2, getMaxAnisotropy: function() {
      if (void 0 !== r2)
        return r2;
      if (true === t2.has("EXT_texture_filter_anisotropic")) {
        const n3 = t2.get("EXT_texture_filter_anisotropic");
        r2 = e2.getParameter(n3.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      } else
        r2 = 0;
      return r2;
    }, getMaxPrecision: i2, precision: o2, logarithmicDepthBuffer: c2, maxTextures: u2, maxVertexTextures: p2, maxTextureSize: d2, maxCubemapSize: h2, maxAttributes: f2, maxVertexUniforms: m2, maxVaryings: _2, maxFragmentUniforms: g2, vertexTextures: v2, floatFragmentTextures: y2, floatVertexTextures: v2 && y2, maxSamples: s2 ? e2.getParameter(e2.MAX_SAMPLES) : 0 };
  }
  function fo(e2) {
    const t2 = this;
    let n2 = null, r2 = 0, i2 = false, s2 = false;
    const o2 = new Zs(), a2 = new Wn(), l2 = { value: null, needsUpdate: false };
    function c2(e3, n3, r3, i3) {
      const s3 = null !== e3 ? e3.length : 0;
      let c3 = null;
      if (0 !== s3) {
        if (c3 = l2.value, true !== i3 || null === c3) {
          const t3 = r3 + 4 * s3, i4 = n3.matrixWorldInverse;
          a2.getNormalMatrix(i4), (null === c3 || c3.length < t3) && (c3 = new Float32Array(t3));
          for (let t4 = 0, n4 = r3; t4 !== s3; ++t4, n4 += 4)
            o2.copy(e3[t4]).applyMatrix4(i4, a2), o2.normal.toArray(c3, n4), c3[n4 + 3] = o2.constant;
        }
        l2.value = c3, l2.needsUpdate = true;
      }
      return t2.numPlanes = s3, t2.numIntersection = 0, c3;
    }
    this.uniform = l2, this.numPlanes = 0, this.numIntersection = 0, this.init = function(e3, t3) {
      const n3 = 0 !== e3.length || t3 || 0 !== r2 || i2;
      return i2 = t3, r2 = e3.length, n3;
    }, this.beginShadows = function() {
      s2 = true, c2(null);
    }, this.endShadows = function() {
      s2 = false;
    }, this.setGlobalState = function(e3, t3) {
      n2 = c2(e3, t3, 0);
    }, this.setState = function(o3, a3, u2) {
      const p2 = o3.clippingPlanes, d2 = o3.clipIntersection, h2 = o3.clipShadows, f2 = e2.get(o3);
      if (!i2 || null === p2 || 0 === p2.length || s2 && !h2)
        s2 ? c2(null) : (l2.value !== n2 && (l2.value = n2, l2.needsUpdate = r2 > 0), t2.numPlanes = r2, t2.numIntersection = 0);
      else {
        const e3 = s2 ? 0 : r2, t3 = 4 * e3;
        let i3 = f2.clippingState || null;
        l2.value = i3, i3 = c2(p2, a3, t3, u2);
        for (let e4 = 0; e4 !== t3; ++e4)
          i3[e4] = n2[e4];
        f2.clippingState = i3, this.numIntersection = d2 ? this.numPlanes : 0, this.numPlanes += e3;
      }
    };
  }
  function mo(e2) {
    let t2 = /* @__PURE__ */ new WeakMap();
    function n2(e3, t3) {
      return t3 === oe ? e3.mapping = ie : t3 === ae && (e3.mapping = se), e3;
    }
    function r2(e3) {
      const n3 = e3.target;
      n3.removeEventListener("dispose", r2);
      const i2 = t2.get(n3);
      void 0 !== i2 && (t2.delete(n3), i2.dispose());
    }
    return { get: function(i2) {
      if (i2 && i2.isTexture && false === i2.isRenderTargetTexture) {
        const s2 = i2.mapping;
        if (s2 === oe || s2 === ae) {
          if (t2.has(i2)) {
            const e3 = t2.get(i2).texture;
            return e3.rotation = i2.rotation, n2(e3, i2.mapping);
          }
          {
            const s3 = i2.image;
            if (s3 && s3.height > 0) {
              const o2 = new Xs(s3.height / 2);
              return o2.fromEquirectangularTexture(e2, i2), o2.texture.rotation = i2.rotation, t2.set(i2, o2), i2.addEventListener("dispose", r2), n2(o2.texture, i2.mapping);
            }
            return null;
          }
        }
      }
      return i2;
    }, dispose: function() {
      t2 = /* @__PURE__ */ new WeakMap();
    } };
  }
  class _o extends Vs {
    constructor(e2 = -1, t2 = 1, n2 = 1, r2 = -1, i2 = 0.1, s2 = 2e3) {
      super(), this.isOrthographicCamera = true, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e2, this.right = t2, this.top = n2, this.bottom = r2, this.near = i2, this.far = s2, this.updateProjectionMatrix();
    }
    copy(e2, t2) {
      return super.copy(e2, t2), this.left = e2.left, this.right = e2.right, this.top = e2.top, this.bottom = e2.bottom, this.near = e2.near, this.far = e2.far, this.zoom = e2.zoom, this.view = null === e2.view ? null : Object.assign({}, e2.view), this;
    }
    setViewOffset(e2, t2, n2, r2, i2, s2) {
      null === this.view && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = e2, this.view.fullHeight = t2, this.view.offsetX = n2, this.view.offsetY = r2, this.view.width = i2, this.view.height = s2, this.updateProjectionMatrix();
    }
    clearViewOffset() {
      null !== this.view && (this.view.enabled = false), this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const e2 = (this.right - this.left) / (2 * this.zoom), t2 = (this.top - this.bottom) / (2 * this.zoom), n2 = (this.right + this.left) / 2, r2 = (this.top + this.bottom) / 2;
      let i2 = n2 - e2, s2 = n2 + e2, o2 = r2 + t2, a2 = r2 - t2;
      if (null !== this.view && this.view.enabled) {
        const e3 = (this.right - this.left) / this.view.fullWidth / this.zoom, t3 = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        i2 += e3 * this.view.offsetX, s2 = i2 + e3 * this.view.width, o2 -= t3 * this.view.offsetY, a2 = o2 - t3 * this.view.height;
      }
      this.projectionMatrix.makeOrthographic(i2, s2, o2, a2, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(e2) {
      const t2 = super.toJSON(e2);
      return t2.object.zoom = this.zoom, t2.object.left = this.left, t2.object.right = this.right, t2.object.top = this.top, t2.object.bottom = this.bottom, t2.object.near = this.near, t2.object.far = this.far, null !== this.view && (t2.object.view = Object.assign({}, this.view)), t2;
    }
  }
  const go = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], vo = 20, yo = new _o(), bo = new Vi();
  let wo = null;
  const Ao = (1 + Math.sqrt(5)) / 2, xo = 1 / Ao, Eo = [new Ar(1, 1, 1), new Ar(-1, 1, 1), new Ar(1, 1, -1), new Ar(-1, 1, -1), new Ar(0, Ao, xo), new Ar(0, Ao, -xo), new Ar(xo, 0, Ao), new Ar(-xo, 0, Ao), new Ar(Ao, xo, 0), new Ar(-Ao, xo, 0)];
  class Co {
    constructor(e2) {
      this._renderer = e2, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
    }
    fromScene(e2, t2 = 0, n2 = 0.1, r2 = 100) {
      wo = this._renderer.getRenderTarget(), this._setSize(256);
      const i2 = this._allocateTargets();
      return i2.depthBuffer = true, this._sceneToCubeUV(e2, n2, r2, i2), t2 > 0 && this._blur(i2, 0, 0, t2), this._applyPMREM(i2), this._cleanup(i2), i2;
    }
    fromEquirectangular(e2, t2 = null) {
      return this._fromTexture(e2, t2);
    }
    fromCubemap(e2, t2 = null) {
      return this._fromTexture(e2, t2);
    }
    compileCubemapShader() {
      null === this._cubemapMaterial && (this._cubemapMaterial = Po(), this._compileMaterial(this._cubemapMaterial));
    }
    compileEquirectangularShader() {
      null === this._equirectMaterial && (this._equirectMaterial = To(), this._compileMaterial(this._equirectMaterial));
    }
    dispose() {
      this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose();
    }
    _setSize(e2) {
      this._lodMax = Math.floor(Math.log2(e2)), this._cubeSize = Math.pow(2, this._lodMax);
    }
    _dispose() {
      null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
      for (let e2 = 0; e2 < this._lodPlanes.length; e2++)
        this._lodPlanes[e2].dispose();
    }
    _cleanup(e2) {
      this._renderer.setRenderTarget(wo), e2.scissorTest = false, Mo(e2, 0, 0, e2.width, e2.height);
    }
    _fromTexture(e2, t2) {
      e2.mapping === ie || e2.mapping === se ? this._setSize(0 === e2.image.length ? 16 : e2.image[0].width || e2.image[0].image.width) : this._setSize(e2.image.width / 4), wo = this._renderer.getRenderTarget();
      const n2 = t2 || this._allocateTargets();
      return this._textureToCubeUV(e2, n2), this._applyPMREM(n2), this._cleanup(n2), n2;
    }
    _allocateTargets() {
      const e2 = 3 * Math.max(this._cubeSize, 112), t2 = 4 * this._cubeSize, n2 = { magFilter: ge, minFilter: ge, generateMipmaps: false, type: Pe, format: Be, colorSpace: Gt, depthBuffer: false }, r2 = So(e2, t2, n2);
      if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e2 || this._pingPongRenderTarget.height !== t2) {
        null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = So(e2, t2, n2);
        const { _lodMax: r3 } = this;
        ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = function(e3) {
          const t3 = [], n3 = [], r4 = [];
          let i2 = e3;
          const s2 = e3 - 4 + 1 + go.length;
          for (let o2 = 0; o2 < s2; o2++) {
            const s3 = Math.pow(2, i2);
            n3.push(s3);
            let a2 = 1 / s3;
            o2 > e3 - 4 ? a2 = go[o2 - e3 + 4 - 1] : 0 === o2 && (a2 = 0), r4.push(a2);
            const l2 = 1 / (s3 - 2), c2 = -l2, u2 = 1 + l2, p2 = [c2, c2, u2, c2, u2, u2, c2, c2, u2, u2, c2, u2], d2 = 6, h2 = 6, f2 = 3, m2 = 2, _2 = 1, g2 = new Float32Array(f2 * h2 * d2), v2 = new Float32Array(m2 * h2 * d2), y2 = new Float32Array(_2 * h2 * d2);
            for (let e4 = 0; e4 < d2; e4++) {
              const t4 = e4 % 3 * 2 / 3 - 1, n4 = e4 > 2 ? 0 : -1, r5 = [t4, n4, 0, t4 + 2 / 3, n4, 0, t4 + 2 / 3, n4 + 1, 0, t4, n4, 0, t4 + 2 / 3, n4 + 1, 0, t4, n4 + 1, 0];
              g2.set(r5, f2 * h2 * e4), v2.set(p2, m2 * h2 * e4);
              const i3 = [e4, e4, e4, e4, e4, e4];
              y2.set(i3, _2 * h2 * e4);
            }
            const b2 = new gs();
            b2.setAttribute("position", new $i(g2, f2)), b2.setAttribute("uv", new $i(v2, m2)), b2.setAttribute("faceIndex", new $i(y2, _2)), t3.push(b2), i2 > 4 && i2--;
          }
          return { lodPlanes: t3, sizeLods: n3, sigmas: r4 };
        }(r3)), this._blurMaterial = function(e3, t3, n3) {
          const r4 = new Float32Array(vo), i2 = new Ar(0, 1, 0);
          return new Gs({ name: "SphericalGaussianBlur", defines: { n: vo, CUBEUV_TEXEL_WIDTH: 1 / t3, CUBEUV_TEXEL_HEIGHT: 1 / n3, CUBEUV_MAX_MIP: `${e3}.0` }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: r4 }, latitudinal: { value: false }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: i2 } }, vertexShader: "\n\n		precision mediump float;\n		precision mediump int;\n\n		attribute float faceIndex;\n\n		varying vec3 vOutputDirection;\n\n		// RH coordinate system; PMREM face-indexing convention\n		vec3 getDirection( vec2 uv, float face ) {\n\n			uv = 2.0 * uv - 1.0;\n\n			vec3 direction = vec3( uv, 1.0 );\n\n			if ( face == 0.0 ) {\n\n				direction = direction.zyx; // ( 1, v, u ) pos x\n\n			} else if ( face == 1.0 ) {\n\n				direction = direction.xzy;\n				direction.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n			} else if ( face == 2.0 ) {\n\n				direction.x *= -1.0; // ( -u, v, 1 ) pos z\n\n			} else if ( face == 3.0 ) {\n\n				direction = direction.zyx;\n				direction.xz *= -1.0; // ( -1, v, -u ) neg x\n\n			} else if ( face == 4.0 ) {\n\n				direction = direction.xzy;\n				direction.xy *= -1.0; // ( -u, -1, v ) neg y\n\n			} else if ( face == 5.0 ) {\n\n				direction.z *= -1.0; // ( u, v, -1 ) neg z\n\n			}\n\n			return direction;\n\n		}\n\n		void main() {\n\n			vOutputDirection = getDirection( uv, faceIndex );\n			gl_Position = vec4( position, 1.0 );\n\n		}\n	", fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform sampler2D envMap;\n			uniform int samples;\n			uniform float weights[ n ];\n			uniform bool latitudinal;\n			uniform float dTheta;\n			uniform float mipInt;\n			uniform vec3 poleAxis;\n\n			#define ENVMAP_TYPE_CUBE_UV\n			#include <cube_uv_reflection_fragment>\n\n			vec3 getSample( float theta, vec3 axis ) {\n\n				float cosTheta = cos( theta );\n				// Rodrigues' axis-angle rotation\n				vec3 sampleDirection = vOutputDirection * cosTheta\n					+ cross( axis, vOutputDirection ) * sin( theta )\n					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n				return bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n			}\n\n			void main() {\n\n				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n				}\n\n				axis = normalize( axis );\n\n				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n				for ( int i = 1; i < n; i++ ) {\n\n					if ( i >= samples ) {\n\n						break;\n\n					}\n\n					float theta = dTheta * float( i );\n					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n				}\n\n			}\n		", blending: v, depthTest: false, depthWrite: false });
        }(r3, e2, t2);
      }
      return r2;
    }
    _compileMaterial(e2) {
      const t2 = new Os(this._lodPlanes[0], e2);
      this._renderer.compile(t2, yo);
    }
    _sceneToCubeUV(e2, t2, n2, r2) {
      const i2 = new Hs(90, 1, t2, n2), s2 = [1, -1, 1, 1, 1, 1], o2 = [1, 1, 1, -1, -1, -1], a2 = this._renderer, l2 = a2.autoClear, c2 = a2.toneMapping;
      a2.getClearColor(bo), a2.toneMapping = J, a2.autoClear = false;
      const u2 = new Qi({ name: "PMREM.Background", side: m, depthWrite: false, depthTest: false }), p2 = new Os(new Us(), u2);
      let d2 = false;
      const h2 = e2.background;
      h2 ? h2.isColor && (u2.color.copy(h2), e2.background = null, d2 = true) : (u2.color.copy(bo), d2 = true);
      for (let t3 = 0; t3 < 6; t3++) {
        const n3 = t3 % 3;
        0 === n3 ? (i2.up.set(0, s2[t3], 0), i2.lookAt(o2[t3], 0, 0)) : 1 === n3 ? (i2.up.set(0, 0, s2[t3]), i2.lookAt(0, o2[t3], 0)) : (i2.up.set(0, s2[t3], 0), i2.lookAt(0, 0, o2[t3]));
        const l3 = this._cubeSize;
        Mo(r2, n3 * l3, t3 > 2 ? l3 : 0, l3, l3), a2.setRenderTarget(r2), d2 && a2.render(p2, i2), a2.render(e2, i2);
      }
      p2.geometry.dispose(), p2.material.dispose(), a2.toneMapping = c2, a2.autoClear = l2, e2.background = h2;
    }
    _textureToCubeUV(e2, t2) {
      const n2 = this._renderer, r2 = e2.mapping === ie || e2.mapping === se;
      r2 ? (null === this._cubemapMaterial && (this._cubemapMaterial = Po()), this._cubemapMaterial.uniforms.flipEnvMap.value = false === e2.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = To());
      const i2 = r2 ? this._cubemapMaterial : this._equirectMaterial, s2 = new Os(this._lodPlanes[0], i2);
      i2.uniforms.envMap.value = e2;
      const o2 = this._cubeSize;
      Mo(t2, 0, 0, 3 * o2, 2 * o2), n2.setRenderTarget(t2), n2.render(s2, yo);
    }
    _applyPMREM(e2) {
      const t2 = this._renderer, n2 = t2.autoClear;
      t2.autoClear = false;
      for (let t3 = 1; t3 < this._lodPlanes.length; t3++) {
        const n3 = Math.sqrt(this._sigmas[t3] * this._sigmas[t3] - this._sigmas[t3 - 1] * this._sigmas[t3 - 1]), r2 = Eo[(t3 - 1) % Eo.length];
        this._blur(e2, t3 - 1, t3, n3, r2);
      }
      t2.autoClear = n2;
    }
    _blur(e2, t2, n2, r2, i2) {
      const s2 = this._pingPongRenderTarget;
      this._halfBlur(e2, s2, t2, n2, r2, "latitudinal", i2), this._halfBlur(s2, e2, n2, n2, r2, "longitudinal", i2);
    }
    _halfBlur(e2, t2, n2, r2, i2, s2, o2) {
      const a2 = this._renderer, l2 = this._blurMaterial;
      "latitudinal" !== s2 && "longitudinal" !== s2 && console.error("blur direction must be either latitudinal or longitudinal!");
      const c2 = new Os(this._lodPlanes[r2], l2), u2 = l2.uniforms, p2 = this._sizeLods[n2] - 1, d2 = isFinite(i2) ? Math.PI / (2 * p2) : 2 * Math.PI / 39, h2 = i2 / d2, f2 = isFinite(i2) ? 1 + Math.floor(3 * h2) : vo;
      f2 > vo && console.warn(`sigmaRadians, ${i2}, is too large and will clip, as it requested ${f2} samples when the maximum is set to 20`);
      const m2 = [];
      let _2 = 0;
      for (let e3 = 0; e3 < vo; ++e3) {
        const t3 = e3 / h2, n3 = Math.exp(-t3 * t3 / 2);
        m2.push(n3), 0 === e3 ? _2 += n3 : e3 < f2 && (_2 += 2 * n3);
      }
      for (let e3 = 0; e3 < m2.length; e3++)
        m2[e3] = m2[e3] / _2;
      u2.envMap.value = e2.texture, u2.samples.value = f2, u2.weights.value = m2, u2.latitudinal.value = "latitudinal" === s2, o2 && (u2.poleAxis.value = o2);
      const { _lodMax: g2 } = this;
      u2.dTheta.value = d2, u2.mipInt.value = g2 - n2;
      const v2 = this._sizeLods[r2];
      Mo(t2, 3 * v2 * (r2 > g2 - 4 ? r2 - g2 + 4 : 0), 4 * (this._cubeSize - v2), 3 * v2, 2 * v2), a2.setRenderTarget(t2), a2.render(c2, yo);
    }
  }
  function So(e2, t2, n2) {
    const r2 = new mr(e2, t2, n2);
    return r2.texture.mapping = le, r2.texture.name = "PMREM.cubeUv", r2.scissorTest = true, r2;
  }
  function Mo(e2, t2, n2, r2, i2) {
    e2.viewport.set(t2, n2, r2, i2), e2.scissor.set(t2, n2, r2, i2);
  }
  function To() {
    return new Gs({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: "\n\n		precision mediump float;\n		precision mediump int;\n\n		attribute float faceIndex;\n\n		varying vec3 vOutputDirection;\n\n		// RH coordinate system; PMREM face-indexing convention\n		vec3 getDirection( vec2 uv, float face ) {\n\n			uv = 2.0 * uv - 1.0;\n\n			vec3 direction = vec3( uv, 1.0 );\n\n			if ( face == 0.0 ) {\n\n				direction = direction.zyx; // ( 1, v, u ) pos x\n\n			} else if ( face == 1.0 ) {\n\n				direction = direction.xzy;\n				direction.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n			} else if ( face == 2.0 ) {\n\n				direction.x *= -1.0; // ( -u, v, 1 ) pos z\n\n			} else if ( face == 3.0 ) {\n\n				direction = direction.zyx;\n				direction.xz *= -1.0; // ( -1, v, -u ) neg x\n\n			} else if ( face == 4.0 ) {\n\n				direction = direction.xzy;\n				direction.xy *= -1.0; // ( -u, -1, v ) neg y\n\n			} else if ( face == 5.0 ) {\n\n				direction.z *= -1.0; // ( u, v, -1 ) neg z\n\n			}\n\n			return direction;\n\n		}\n\n		void main() {\n\n			vOutputDirection = getDirection( uv, faceIndex );\n			gl_Position = vec4( position, 1.0 );\n\n		}\n	", fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform sampler2D envMap;\n\n			#include <common>\n\n			void main() {\n\n				vec3 outputDirection = normalize( vOutputDirection );\n				vec2 uv = equirectUv( outputDirection );\n\n				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n			}\n		", blending: v, depthTest: false, depthWrite: false });
  }
  function Po() {
    return new Gs({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: "\n\n		precision mediump float;\n		precision mediump int;\n\n		attribute float faceIndex;\n\n		varying vec3 vOutputDirection;\n\n		// RH coordinate system; PMREM face-indexing convention\n		vec3 getDirection( vec2 uv, float face ) {\n\n			uv = 2.0 * uv - 1.0;\n\n			vec3 direction = vec3( uv, 1.0 );\n\n			if ( face == 0.0 ) {\n\n				direction = direction.zyx; // ( 1, v, u ) pos x\n\n			} else if ( face == 1.0 ) {\n\n				direction = direction.xzy;\n				direction.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n			} else if ( face == 2.0 ) {\n\n				direction.x *= -1.0; // ( -u, v, 1 ) pos z\n\n			} else if ( face == 3.0 ) {\n\n				direction = direction.zyx;\n				direction.xz *= -1.0; // ( -1, v, -u ) neg x\n\n			} else if ( face == 4.0 ) {\n\n				direction = direction.xzy;\n				direction.xy *= -1.0; // ( -u, -1, v ) neg y\n\n			} else if ( face == 5.0 ) {\n\n				direction.z *= -1.0; // ( u, v, -1 ) neg z\n\n			}\n\n			return direction;\n\n		}\n\n		void main() {\n\n			vOutputDirection = getDirection( uv, faceIndex );\n			gl_Position = vec4( position, 1.0 );\n\n		}\n	", fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			uniform float flipEnvMap;\n\n			varying vec3 vOutputDirection;\n\n			uniform samplerCube envMap;\n\n			void main() {\n\n				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n			}\n		", blending: v, depthTest: false, depthWrite: false });
  }
  function Io(e2) {
    let t2 = /* @__PURE__ */ new WeakMap(), n2 = null;
    function r2(e3) {
      const n3 = e3.target;
      n3.removeEventListener("dispose", r2);
      const i2 = t2.get(n3);
      void 0 !== i2 && (t2.delete(n3), i2.dispose());
    }
    return { get: function(i2) {
      if (i2 && i2.isTexture) {
        const s2 = i2.mapping, o2 = s2 === oe || s2 === ae, a2 = s2 === ie || s2 === se;
        if (o2 || a2) {
          if (i2.isRenderTargetTexture && true === i2.needsPMREMUpdate) {
            i2.needsPMREMUpdate = false;
            let r3 = t2.get(i2);
            return null === n2 && (n2 = new Co(e2)), r3 = o2 ? n2.fromEquirectangular(i2, r3) : n2.fromCubemap(i2, r3), t2.set(i2, r3), r3.texture;
          }
          if (t2.has(i2))
            return t2.get(i2).texture;
          {
            const s3 = i2.image;
            if (o2 && s3 && s3.height > 0 || a2 && s3 && function(e3) {
              let t3 = 0;
              for (let n3 = 0; n3 < 6; n3++)
                void 0 !== e3[n3] && t3++;
              return 6 === t3;
            }(s3)) {
              null === n2 && (n2 = new Co(e2));
              const s4 = o2 ? n2.fromEquirectangular(i2) : n2.fromCubemap(i2);
              return t2.set(i2, s4), i2.addEventListener("dispose", r2), s4.texture;
            }
            return null;
          }
        }
      }
      return i2;
    }, dispose: function() {
      t2 = /* @__PURE__ */ new WeakMap(), null !== n2 && (n2.dispose(), n2 = null);
    } };
  }
  function Ro(e2) {
    const t2 = {};
    function n2(n3) {
      if (void 0 !== t2[n3])
        return t2[n3];
      let r2;
      switch (n3) {
        case "WEBGL_depth_texture":
          r2 = e2.getExtension("WEBGL_depth_texture") || e2.getExtension("MOZ_WEBGL_depth_texture") || e2.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          r2 = e2.getExtension("EXT_texture_filter_anisotropic") || e2.getExtension("MOZ_EXT_texture_filter_anisotropic") || e2.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          r2 = e2.getExtension("WEBGL_compressed_texture_s3tc") || e2.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e2.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          r2 = e2.getExtension("WEBGL_compressed_texture_pvrtc") || e2.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          r2 = e2.getExtension(n3);
      }
      return t2[n3] = r2, r2;
    }
    return { has: function(e3) {
      return null !== n2(e3);
    }, init: function(e3) {
      e3.isWebGL2 ? n2("EXT_color_buffer_float") : (n2("WEBGL_depth_texture"), n2("OES_texture_float"), n2("OES_texture_half_float"), n2("OES_texture_half_float_linear"), n2("OES_standard_derivatives"), n2("OES_element_index_uint"), n2("OES_vertex_array_object"), n2("ANGLE_instanced_arrays")), n2("OES_texture_float_linear"), n2("EXT_color_buffer_half_float"), n2("WEBGL_multisampled_render_to_texture");
    }, get: function(e3) {
      const t3 = n2(e3);
      return null === t3 && console.warn("THREE.WebGLRenderer: " + e3 + " extension not supported."), t3;
    } };
  }
  function ko(e2, t2, n2, r2) {
    const i2 = {}, s2 = /* @__PURE__ */ new WeakMap();
    function o2(e3) {
      const a3 = e3.target;
      null !== a3.index && t2.remove(a3.index);
      for (const e4 in a3.attributes)
        t2.remove(a3.attributes[e4]);
      for (const e4 in a3.morphAttributes) {
        const n3 = a3.morphAttributes[e4];
        for (let e5 = 0, r3 = n3.length; e5 < r3; e5++)
          t2.remove(n3[e5]);
      }
      a3.removeEventListener("dispose", o2), delete i2[a3.id];
      const l2 = s2.get(a3);
      l2 && (t2.remove(l2), s2.delete(a3)), r2.releaseStatesOfGeometry(a3), true === a3.isInstancedBufferGeometry && delete a3._maxInstanceCount, n2.memory.geometries--;
    }
    function a2(e3) {
      const n3 = [], r3 = e3.index, i3 = e3.attributes.position;
      let o3 = 0;
      if (null !== r3) {
        const e4 = r3.array;
        o3 = r3.version;
        for (let t3 = 0, r4 = e4.length; t3 < r4; t3 += 3) {
          const r5 = e4[t3 + 0], i4 = e4[t3 + 1], s3 = e4[t3 + 2];
          n3.push(r5, i4, i4, s3, s3, r5);
        }
      } else {
        const e4 = i3.array;
        o3 = i3.version;
        for (let t3 = 0, r4 = e4.length / 3 - 1; t3 < r4; t3 += 3) {
          const e5 = t3 + 0, r5 = t3 + 1, i4 = t3 + 2;
          n3.push(e5, r5, r5, i4, i4, e5);
        }
      }
      const a3 = new (Xn(n3) ? os : is)(n3, 1);
      a3.version = o3;
      const l2 = s2.get(e3);
      l2 && t2.remove(l2), s2.set(e3, a3);
    }
    return { get: function(e3, t3) {
      return true === i2[t3.id] || (t3.addEventListener("dispose", o2), i2[t3.id] = true, n2.memory.geometries++), t3;
    }, update: function(n3) {
      const r3 = n3.attributes;
      for (const n4 in r3)
        t2.update(r3[n4], e2.ARRAY_BUFFER);
      const i3 = n3.morphAttributes;
      for (const n4 in i3) {
        const r4 = i3[n4];
        for (let n5 = 0, i4 = r4.length; n5 < i4; n5++)
          t2.update(r4[n5], e2.ARRAY_BUFFER);
      }
    }, getWireframeAttribute: function(e3) {
      const t3 = s2.get(e3);
      if (t3) {
        const n3 = e3.index;
        null !== n3 && t3.version < n3.version && a2(e3);
      } else
        a2(e3);
      return s2.get(e3);
    } };
  }
  function Do(e2, t2, n2, r2) {
    const i2 = r2.isWebGL2;
    let s2, o2, a2;
    this.setMode = function(e3) {
      s2 = e3;
    }, this.setIndex = function(e3) {
      o2 = e3.type, a2 = e3.bytesPerElement;
    }, this.render = function(t3, r3) {
      e2.drawElements(s2, r3, o2, t3 * a2), n2.update(r3, s2, 1);
    }, this.renderInstances = function(r3, l2, c2) {
      if (0 === c2)
        return;
      let u2, p2;
      if (i2)
        u2 = e2, p2 = "drawElementsInstanced";
      else if (u2 = t2.get("ANGLE_instanced_arrays"), p2 = "drawElementsInstancedANGLE", null === u2)
        return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      u2[p2](s2, l2, o2, r3 * a2, c2), n2.update(l2, s2, c2);
    };
  }
  function Bo(e2) {
    const t2 = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
    return { memory: { geometries: 0, textures: 0 }, render: t2, programs: null, autoReset: true, reset: function() {
      t2.calls = 0, t2.triangles = 0, t2.points = 0, t2.lines = 0;
    }, update: function(n2, r2, i2) {
      switch (t2.calls++, r2) {
        case e2.TRIANGLES:
          t2.triangles += i2 * (n2 / 3);
          break;
        case e2.LINES:
          t2.lines += i2 * (n2 / 2);
          break;
        case e2.LINE_STRIP:
          t2.lines += i2 * (n2 - 1);
          break;
        case e2.LINE_LOOP:
          t2.lines += i2 * n2;
          break;
        case e2.POINTS:
          t2.points += i2 * n2;
          break;
        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", r2);
      }
    } };
  }
  function Oo(e2, t2) {
    return e2[0] - t2[0];
  }
  function Lo(e2, t2) {
    return Math.abs(t2[1]) - Math.abs(e2[1]);
  }
  function Uo(e2, t2, n2) {
    const r2 = {}, i2 = new Float32Array(8), s2 = /* @__PURE__ */ new WeakMap(), o2 = new fr(), a2 = [];
    for (let e3 = 0; e3 < 8; e3++)
      a2[e3] = [e3, 0];
    return { update: function(l2, c2, u2) {
      const p2 = l2.morphTargetInfluences;
      if (true === t2.isWebGL2) {
        const r3 = c2.morphAttributes.position || c2.morphAttributes.normal || c2.morphAttributes.color, i3 = void 0 !== r3 ? r3.length : 0;
        let a3 = s2.get(c2);
        if (void 0 === a3 || a3.count !== i3) {
          void 0 !== a3 && a3.texture.dispose();
          const e3 = void 0 !== c2.morphAttributes.position, n3 = void 0 !== c2.morphAttributes.normal, r4 = void 0 !== c2.morphAttributes.color, l4 = c2.morphAttributes.position || [], u3 = c2.morphAttributes.normal || [], p3 = c2.morphAttributes.color || [];
          let d3 = 0;
          true === e3 && (d3 = 1), true === n3 && (d3 = 2), true === r4 && (d3 = 3);
          let h2 = c2.attributes.position.count * d3, f2 = 1;
          h2 > t2.maxTextureSize && (f2 = Math.ceil(h2 / t2.maxTextureSize), h2 = t2.maxTextureSize);
          const m2 = new Float32Array(h2 * f2 * 4 * i3), _2 = new _r(m2, h2, f2, i3);
          _2.type = Te, _2.needsUpdate = true;
          const g2 = 4 * d3;
          for (let t3 = 0; t3 < i3; t3++) {
            const i4 = l4[t3], s3 = u3[t3], a4 = p3[t3], c3 = h2 * f2 * 4 * t3;
            for (let t4 = 0; t4 < i4.count; t4++) {
              const l5 = t4 * g2;
              true === e3 && (o2.fromBufferAttribute(i4, t4), m2[c3 + l5 + 0] = o2.x, m2[c3 + l5 + 1] = o2.y, m2[c3 + l5 + 2] = o2.z, m2[c3 + l5 + 3] = 0), true === n3 && (o2.fromBufferAttribute(s3, t4), m2[c3 + l5 + 4] = o2.x, m2[c3 + l5 + 5] = o2.y, m2[c3 + l5 + 6] = o2.z, m2[c3 + l5 + 7] = 0), true === r4 && (o2.fromBufferAttribute(a4, t4), m2[c3 + l5 + 8] = o2.x, m2[c3 + l5 + 9] = o2.y, m2[c3 + l5 + 10] = o2.z, m2[c3 + l5 + 11] = 4 === a4.itemSize ? o2.w : 1);
            }
          }
          a3 = { count: i3, texture: _2, size: new Qn(h2, f2) }, s2.set(c2, a3), c2.addEventListener("dispose", function e4() {
            _2.dispose(), s2.delete(c2), c2.removeEventListener("dispose", e4);
          });
        }
        let l3 = 0;
        for (let e3 = 0; e3 < p2.length; e3++)
          l3 += p2[e3];
        const d2 = c2.morphTargetsRelative ? 1 : 1 - l3;
        u2.getUniforms().setValue(e2, "morphTargetBaseInfluence", d2), u2.getUniforms().setValue(e2, "morphTargetInfluences", p2), u2.getUniforms().setValue(e2, "morphTargetsTexture", a3.texture, n2), u2.getUniforms().setValue(e2, "morphTargetsTextureSize", a3.size);
      } else {
        const t3 = void 0 === p2 ? 0 : p2.length;
        let n3 = r2[c2.id];
        if (void 0 === n3 || n3.length !== t3) {
          n3 = [];
          for (let e3 = 0; e3 < t3; e3++)
            n3[e3] = [e3, 0];
          r2[c2.id] = n3;
        }
        for (let e3 = 0; e3 < t3; e3++) {
          const t4 = n3[e3];
          t4[0] = e3, t4[1] = p2[e3];
        }
        n3.sort(Lo);
        for (let e3 = 0; e3 < 8; e3++)
          e3 < t3 && n3[e3][1] ? (a2[e3][0] = n3[e3][0], a2[e3][1] = n3[e3][1]) : (a2[e3][0] = Number.MAX_SAFE_INTEGER, a2[e3][1] = 0);
        a2.sort(Oo);
        const s3 = c2.morphAttributes.position, o3 = c2.morphAttributes.normal;
        let l3 = 0;
        for (let e3 = 0; e3 < 8; e3++) {
          const t4 = a2[e3], n4 = t4[0], r3 = t4[1];
          n4 !== Number.MAX_SAFE_INTEGER && r3 ? (s3 && c2.getAttribute("morphTarget" + e3) !== s3[n4] && c2.setAttribute("morphTarget" + e3, s3[n4]), o3 && c2.getAttribute("morphNormal" + e3) !== o3[n4] && c2.setAttribute("morphNormal" + e3, o3[n4]), i2[e3] = r3, l3 += r3) : (s3 && true === c2.hasAttribute("morphTarget" + e3) && c2.deleteAttribute("morphTarget" + e3), o3 && true === c2.hasAttribute("morphNormal" + e3) && c2.deleteAttribute("morphNormal" + e3), i2[e3] = 0);
        }
        const d2 = c2.morphTargetsRelative ? 1 : 1 - l3;
        u2.getUniforms().setValue(e2, "morphTargetBaseInfluence", d2), u2.getUniforms().setValue(e2, "morphTargetInfluences", i2);
      }
    } };
  }
  function Fo(e2, t2, n2, r2) {
    let i2 = /* @__PURE__ */ new WeakMap();
    function s2(e3) {
      const t3 = e3.target;
      t3.removeEventListener("dispose", s2), n2.remove(t3.instanceMatrix), null !== t3.instanceColor && n2.remove(t3.instanceColor);
    }
    return { update: function(o2) {
      const a2 = r2.render.frame, l2 = o2.geometry, c2 = t2.get(o2, l2);
      return i2.get(c2) !== a2 && (t2.update(c2), i2.set(c2, a2)), o2.isInstancedMesh && (false === o2.hasEventListener("dispose", s2) && o2.addEventListener("dispose", s2), n2.update(o2.instanceMatrix, e2.ARRAY_BUFFER), null !== o2.instanceColor && n2.update(o2.instanceColor, e2.ARRAY_BUFFER)), c2;
    }, dispose: function() {
      i2 = /* @__PURE__ */ new WeakMap();
    } };
  }
  const No = new hr(), jo = new _r(), zo = new vr(), Go = new qs(), Vo = [], Ho = [], Qo = new Float32Array(16), Wo = new Float32Array(9), qo = new Float32Array(4);
  function Xo(e2, t2, n2) {
    const r2 = e2[0];
    if (r2 <= 0 || r2 > 0)
      return e2;
    const i2 = t2 * n2;
    let s2 = Vo[i2];
    if (void 0 === s2 && (s2 = new Float32Array(i2), Vo[i2] = s2), 0 !== t2) {
      r2.toArray(s2, 0);
      for (let r3 = 1, i3 = 0; r3 !== t2; ++r3)
        i3 += n2, e2[r3].toArray(s2, i3);
    }
    return s2;
  }
  function Yo(e2, t2) {
    if (e2.length !== t2.length)
      return false;
    for (let n2 = 0, r2 = e2.length; n2 < r2; n2++)
      if (e2[n2] !== t2[n2])
        return false;
    return true;
  }
  function Ko(e2, t2) {
    for (let n2 = 0, r2 = t2.length; n2 < r2; n2++)
      e2[n2] = t2[n2];
  }
  function Jo(e2, t2) {
    let n2 = Ho[t2];
    void 0 === n2 && (n2 = new Int32Array(t2), Ho[t2] = n2);
    for (let r2 = 0; r2 !== t2; ++r2)
      n2[r2] = e2.allocateTextureUnit();
    return n2;
  }
  function Zo(e2, t2) {
    const n2 = this.cache;
    n2[0] !== t2 && (e2.uniform1f(this.addr, t2), n2[0] = t2);
  }
  function $o(e2, t2) {
    const n2 = this.cache;
    if (void 0 !== t2.x)
      n2[0] === t2.x && n2[1] === t2.y || (e2.uniform2f(this.addr, t2.x, t2.y), n2[0] = t2.x, n2[1] = t2.y);
    else {
      if (Yo(n2, t2))
        return;
      e2.uniform2fv(this.addr, t2), Ko(n2, t2);
    }
  }
  function ea(e2, t2) {
    const n2 = this.cache;
    if (void 0 !== t2.x)
      n2[0] === t2.x && n2[1] === t2.y && n2[2] === t2.z || (e2.uniform3f(this.addr, t2.x, t2.y, t2.z), n2[0] = t2.x, n2[1] = t2.y, n2[2] = t2.z);
    else if (void 0 !== t2.r)
      n2[0] === t2.r && n2[1] === t2.g && n2[2] === t2.b || (e2.uniform3f(this.addr, t2.r, t2.g, t2.b), n2[0] = t2.r, n2[1] = t2.g, n2[2] = t2.b);
    else {
      if (Yo(n2, t2))
        return;
      e2.uniform3fv(this.addr, t2), Ko(n2, t2);
    }
  }
  function ta(e2, t2) {
    const n2 = this.cache;
    if (void 0 !== t2.x)
      n2[0] === t2.x && n2[1] === t2.y && n2[2] === t2.z && n2[3] === t2.w || (e2.uniform4f(this.addr, t2.x, t2.y, t2.z, t2.w), n2[0] = t2.x, n2[1] = t2.y, n2[2] = t2.z, n2[3] = t2.w);
    else {
      if (Yo(n2, t2))
        return;
      e2.uniform4fv(this.addr, t2), Ko(n2, t2);
    }
  }
  function na(e2, t2) {
    const n2 = this.cache, r2 = t2.elements;
    if (void 0 === r2) {
      if (Yo(n2, t2))
        return;
      e2.uniformMatrix2fv(this.addr, false, t2), Ko(n2, t2);
    } else {
      if (Yo(n2, r2))
        return;
      qo.set(r2), e2.uniformMatrix2fv(this.addr, false, qo), Ko(n2, r2);
    }
  }
  function ra(e2, t2) {
    const n2 = this.cache, r2 = t2.elements;
    if (void 0 === r2) {
      if (Yo(n2, t2))
        return;
      e2.uniformMatrix3fv(this.addr, false, t2), Ko(n2, t2);
    } else {
      if (Yo(n2, r2))
        return;
      Wo.set(r2), e2.uniformMatrix3fv(this.addr, false, Wo), Ko(n2, r2);
    }
  }
  function ia(e2, t2) {
    const n2 = this.cache, r2 = t2.elements;
    if (void 0 === r2) {
      if (Yo(n2, t2))
        return;
      e2.uniformMatrix4fv(this.addr, false, t2), Ko(n2, t2);
    } else {
      if (Yo(n2, r2))
        return;
      Qo.set(r2), e2.uniformMatrix4fv(this.addr, false, Qo), Ko(n2, r2);
    }
  }
  function sa(e2, t2) {
    const n2 = this.cache;
    n2[0] !== t2 && (e2.uniform1i(this.addr, t2), n2[0] = t2);
  }
  function oa(e2, t2) {
    const n2 = this.cache;
    if (void 0 !== t2.x)
      n2[0] === t2.x && n2[1] === t2.y || (e2.uniform2i(this.addr, t2.x, t2.y), n2[0] = t2.x, n2[1] = t2.y);
    else {
      if (Yo(n2, t2))
        return;
      e2.uniform2iv(this.addr, t2), Ko(n2, t2);
    }
  }
  function aa(e2, t2) {
    const n2 = this.cache;
    if (void 0 !== t2.x)
      n2[0] === t2.x && n2[1] === t2.y && n2[2] === t2.z || (e2.uniform3i(this.addr, t2.x, t2.y, t2.z), n2[0] = t2.x, n2[1] = t2.y, n2[2] = t2.z);
    else {
      if (Yo(n2, t2))
        return;
      e2.uniform3iv(this.addr, t2), Ko(n2, t2);
    }
  }
  function la(e2, t2) {
    const n2 = this.cache;
    if (void 0 !== t2.x)
      n2[0] === t2.x && n2[1] === t2.y && n2[2] === t2.z && n2[3] === t2.w || (e2.uniform4i(this.addr, t2.x, t2.y, t2.z, t2.w), n2[0] = t2.x, n2[1] = t2.y, n2[2] = t2.z, n2[3] = t2.w);
    else {
      if (Yo(n2, t2))
        return;
      e2.uniform4iv(this.addr, t2), Ko(n2, t2);
    }
  }
  function ca(e2, t2) {
    const n2 = this.cache;
    n2[0] !== t2 && (e2.uniform1ui(this.addr, t2), n2[0] = t2);
  }
  function ua(e2, t2) {
    const n2 = this.cache;
    if (void 0 !== t2.x)
      n2[0] === t2.x && n2[1] === t2.y || (e2.uniform2ui(this.addr, t2.x, t2.y), n2[0] = t2.x, n2[1] = t2.y);
    else {
      if (Yo(n2, t2))
        return;
      e2.uniform2uiv(this.addr, t2), Ko(n2, t2);
    }
  }
  function pa(e2, t2) {
    const n2 = this.cache;
    if (void 0 !== t2.x)
      n2[0] === t2.x && n2[1] === t2.y && n2[2] === t2.z || (e2.uniform3ui(this.addr, t2.x, t2.y, t2.z), n2[0] = t2.x, n2[1] = t2.y, n2[2] = t2.z);
    else {
      if (Yo(n2, t2))
        return;
      e2.uniform3uiv(this.addr, t2), Ko(n2, t2);
    }
  }
  function da(e2, t2) {
    const n2 = this.cache;
    if (void 0 !== t2.x)
      n2[0] === t2.x && n2[1] === t2.y && n2[2] === t2.z && n2[3] === t2.w || (e2.uniform4ui(this.addr, t2.x, t2.y, t2.z, t2.w), n2[0] = t2.x, n2[1] = t2.y, n2[2] = t2.z, n2[3] = t2.w);
    else {
      if (Yo(n2, t2))
        return;
      e2.uniform4uiv(this.addr, t2), Ko(n2, t2);
    }
  }
  function ha(e2, t2, n2) {
    const r2 = this.cache, i2 = n2.allocateTextureUnit();
    r2[0] !== i2 && (e2.uniform1i(this.addr, i2), r2[0] = i2), n2.setTexture2D(t2 || No, i2);
  }
  function fa(e2, t2, n2) {
    const r2 = this.cache, i2 = n2.allocateTextureUnit();
    r2[0] !== i2 && (e2.uniform1i(this.addr, i2), r2[0] = i2), n2.setTexture3D(t2 || zo, i2);
  }
  function ma(e2, t2, n2) {
    const r2 = this.cache, i2 = n2.allocateTextureUnit();
    r2[0] !== i2 && (e2.uniform1i(this.addr, i2), r2[0] = i2), n2.setTextureCube(t2 || Go, i2);
  }
  function _a2(e2, t2, n2) {
    const r2 = this.cache, i2 = n2.allocateTextureUnit();
    r2[0] !== i2 && (e2.uniform1i(this.addr, i2), r2[0] = i2), n2.setTexture2DArray(t2 || jo, i2);
  }
  function ga(e2, t2) {
    e2.uniform1fv(this.addr, t2);
  }
  function va(e2, t2) {
    const n2 = Xo(t2, this.size, 2);
    e2.uniform2fv(this.addr, n2);
  }
  function ya(e2, t2) {
    const n2 = Xo(t2, this.size, 3);
    e2.uniform3fv(this.addr, n2);
  }
  function ba(e2, t2) {
    const n2 = Xo(t2, this.size, 4);
    e2.uniform4fv(this.addr, n2);
  }
  function wa(e2, t2) {
    const n2 = Xo(t2, this.size, 4);
    e2.uniformMatrix2fv(this.addr, false, n2);
  }
  function Aa(e2, t2) {
    const n2 = Xo(t2, this.size, 9);
    e2.uniformMatrix3fv(this.addr, false, n2);
  }
  function xa(e2, t2) {
    const n2 = Xo(t2, this.size, 16);
    e2.uniformMatrix4fv(this.addr, false, n2);
  }
  function Ea(e2, t2) {
    e2.uniform1iv(this.addr, t2);
  }
  function Ca(e2, t2) {
    e2.uniform2iv(this.addr, t2);
  }
  function Sa(e2, t2) {
    e2.uniform3iv(this.addr, t2);
  }
  function Ma(e2, t2) {
    e2.uniform4iv(this.addr, t2);
  }
  function Ta(e2, t2) {
    e2.uniform1uiv(this.addr, t2);
  }
  function Pa(e2, t2) {
    e2.uniform2uiv(this.addr, t2);
  }
  function Ia(e2, t2) {
    e2.uniform3uiv(this.addr, t2);
  }
  function Ra(e2, t2) {
    e2.uniform4uiv(this.addr, t2);
  }
  function ka(e2, t2, n2) {
    const r2 = this.cache, i2 = t2.length, s2 = Jo(n2, i2);
    Yo(r2, s2) || (e2.uniform1iv(this.addr, s2), Ko(r2, s2));
    for (let e3 = 0; e3 !== i2; ++e3)
      n2.setTexture2D(t2[e3] || No, s2[e3]);
  }
  function Da(e2, t2, n2) {
    const r2 = this.cache, i2 = t2.length, s2 = Jo(n2, i2);
    Yo(r2, s2) || (e2.uniform1iv(this.addr, s2), Ko(r2, s2));
    for (let e3 = 0; e3 !== i2; ++e3)
      n2.setTexture3D(t2[e3] || zo, s2[e3]);
  }
  function Ba(e2, t2, n2) {
    const r2 = this.cache, i2 = t2.length, s2 = Jo(n2, i2);
    Yo(r2, s2) || (e2.uniform1iv(this.addr, s2), Ko(r2, s2));
    for (let e3 = 0; e3 !== i2; ++e3)
      n2.setTextureCube(t2[e3] || Go, s2[e3]);
  }
  function Oa(e2, t2, n2) {
    const r2 = this.cache, i2 = t2.length, s2 = Jo(n2, i2);
    Yo(r2, s2) || (e2.uniform1iv(this.addr, s2), Ko(r2, s2));
    for (let e3 = 0; e3 !== i2; ++e3)
      n2.setTexture2DArray(t2[e3] || jo, s2[e3]);
  }
  class La {
    constructor(e2, t2, n2) {
      this.id = e2, this.addr = n2, this.cache = [], this.setValue = function(e3) {
        switch (e3) {
          case 5126:
            return Zo;
          case 35664:
            return $o;
          case 35665:
            return ea;
          case 35666:
            return ta;
          case 35674:
            return na;
          case 35675:
            return ra;
          case 35676:
            return ia;
          case 5124:
          case 35670:
            return sa;
          case 35667:
          case 35671:
            return oa;
          case 35668:
          case 35672:
            return aa;
          case 35669:
          case 35673:
            return la;
          case 5125:
            return ca;
          case 36294:
            return ua;
          case 36295:
            return pa;
          case 36296:
            return da;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return ha;
          case 35679:
          case 36299:
          case 36307:
            return fa;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return ma;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return _a2;
        }
      }(t2.type);
    }
  }
  class Ua {
    constructor(e2, t2, n2) {
      this.id = e2, this.addr = n2, this.cache = [], this.size = t2.size, this.setValue = function(e3) {
        switch (e3) {
          case 5126:
            return ga;
          case 35664:
            return va;
          case 35665:
            return ya;
          case 35666:
            return ba;
          case 35674:
            return wa;
          case 35675:
            return Aa;
          case 35676:
            return xa;
          case 5124:
          case 35670:
            return Ea;
          case 35667:
          case 35671:
            return Ca;
          case 35668:
          case 35672:
            return Sa;
          case 35669:
          case 35673:
            return Ma;
          case 5125:
            return Ta;
          case 36294:
            return Pa;
          case 36295:
            return Ia;
          case 36296:
            return Ra;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return ka;
          case 35679:
          case 36299:
          case 36307:
            return Da;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return Ba;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return Oa;
        }
      }(t2.type);
    }
  }
  class Fa {
    constructor(e2) {
      this.id = e2, this.seq = [], this.map = {};
    }
    setValue(e2, t2, n2) {
      const r2 = this.seq;
      for (let i2 = 0, s2 = r2.length; i2 !== s2; ++i2) {
        const s3 = r2[i2];
        s3.setValue(e2, t2[s3.id], n2);
      }
    }
  }
  const Na = /(\w+)(\])?(\[|\.)?/g;
  function ja(e2, t2) {
    e2.seq.push(t2), e2.map[t2.id] = t2;
  }
  function za(e2, t2, n2) {
    const r2 = e2.name, i2 = r2.length;
    for (Na.lastIndex = 0; ; ) {
      const s2 = Na.exec(r2), o2 = Na.lastIndex;
      let a2 = s2[1];
      const l2 = "]" === s2[2], c2 = s2[3];
      if (l2 && (a2 |= 0), void 0 === c2 || "[" === c2 && o2 + 2 === i2) {
        ja(n2, void 0 === c2 ? new La(a2, e2, t2) : new Ua(a2, e2, t2));
        break;
      }
      {
        let e3 = n2.map[a2];
        void 0 === e3 && (e3 = new Fa(a2), ja(n2, e3)), n2 = e3;
      }
    }
  }
  class Ga {
    constructor(e2, t2) {
      this.seq = [], this.map = {};
      const n2 = e2.getProgramParameter(t2, e2.ACTIVE_UNIFORMS);
      for (let r2 = 0; r2 < n2; ++r2) {
        const n3 = e2.getActiveUniform(t2, r2);
        za(n3, e2.getUniformLocation(t2, n3.name), this);
      }
    }
    setValue(e2, t2, n2, r2) {
      const i2 = this.map[t2];
      void 0 !== i2 && i2.setValue(e2, n2, r2);
    }
    setOptional(e2, t2, n2) {
      const r2 = t2[n2];
      void 0 !== r2 && this.setValue(e2, n2, r2);
    }
    static upload(e2, t2, n2, r2) {
      for (let i2 = 0, s2 = t2.length; i2 !== s2; ++i2) {
        const s3 = t2[i2], o2 = n2[s3.id];
        false !== o2.needsUpdate && s3.setValue(e2, o2.value, r2);
      }
    }
    static seqWithValue(e2, t2) {
      const n2 = [];
      for (let r2 = 0, i2 = e2.length; r2 !== i2; ++r2) {
        const i3 = e2[r2];
        i3.id in t2 && n2.push(i3);
      }
      return n2;
    }
  }
  function Va(e2, t2, n2) {
    const r2 = e2.createShader(t2);
    return e2.shaderSource(r2, n2), e2.compileShader(r2), r2;
  }
  let Ha = 0;
  function Qa(e2) {
    switch (e2) {
      case jt:
      case Gt:
        return ["Linear", "( value )"];
      case zt:
        return ["sRGB", "( value )"];
      case Ht:
        return ["RGBM", "( value, 16.0 )"];
      default:
        return console.warn("THREE.WebGLProgram: Unsupported color space:", e2), ["Linear", "( value )"];
    }
  }
  function Wa(e2, t2, n2) {
    const r2 = e2.getShaderParameter(t2, e2.COMPILE_STATUS), i2 = e2.getShaderInfoLog(t2).trim();
    if (r2 && "" === i2)
      return "";
    const s2 = /ERROR: 0:(\d+)/.exec(i2);
    if (s2) {
      const r3 = parseInt(s2[1]);
      return n2.toUpperCase() + "\n\n" + i2 + "\n\n" + function(e3, t3) {
        const n3 = e3.split("\n"), r4 = [], i3 = Math.max(t3 - 6, 0), s3 = Math.min(t3 + 6, n3.length);
        for (let e4 = i3; e4 < s3; e4++) {
          const i4 = e4 + 1;
          r4.push(`${i4 === t3 ? ">" : " "} ${i4}: ${n3[e4]}`);
        }
        return r4.join("\n");
      }(e2.getShaderSource(t2), r3);
    }
    return i2;
  }
  function qa(e2, t2) {
    const n2 = Qa(t2);
    return "vec4 " + e2 + "( vec4 value ) { return " + n2[0] + "ToLinear" + n2[1] + "; }";
  }
  function Xa(e2, t2) {
    const n2 = Qa(t2);
    return "vec4 " + e2 + "( vec4 value ) { return LinearTo" + n2[0] + n2[1] + "; }";
  }
  function Ya(e2, t2) {
    let n2;
    switch (t2) {
      case Z:
        n2 = "Linear";
        break;
      case $:
        n2 = "Reinhard";
        break;
      case ee:
        n2 = "OptimizedCineon";
        break;
      case te:
        n2 = "ACESFilmic";
        break;
      case ne:
        n2 = "Custom";
        break;
      default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t2), n2 = "Linear";
    }
    return "vec3 " + e2 + "( vec3 color ) { return " + n2 + "ToneMapping( color ); }";
  }
  function Ka(e2) {
    return "" !== e2;
  }
  function Ja(e2, t2) {
    const n2 = t2.numSpotLightShadows + t2.numSpotLightMaps - t2.numSpotLightShadowsWithMaps;
    return e2.replace(/NUM_DIR_LIGHTS/g, t2.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t2.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t2.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n2).replace(/NUM_RECT_AREA_LIGHTS/g, t2.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t2.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t2.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t2.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t2.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t2.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t2.numPointLightShadows);
  }
  function Za(e2, t2) {
    return e2.replace(/NUM_CLIPPING_PLANES/g, t2.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t2.numClippingPlanes - t2.numClipIntersection);
  }
  const $a = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function el(e2) {
    return e2.replace($a, tl);
  }
  function tl(e2, t2) {
    const n2 = so[t2];
    if (void 0 === n2)
      throw new Error("Can not resolve #include <" + t2 + ">");
    return el(n2);
  }
  const nl = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
  function rl(e2) {
    return e2.replace(nl, il);
  }
  function il(e2, t2, n2, r2) {
    let i2 = "";
    for (let e3 = parseInt(t2); e3 < parseInt(n2); e3++)
      i2 += r2.replace(/\[\s*i\s*\]/g, "[ " + e3 + " ]").replace(/UNROLLED_LOOP_INDEX/g, e3);
    return i2;
  }
  function sl(e2) {
    let t2 = "precision " + e2.precision + " float;\nprecision " + e2.precision + " int;";
    return "highp" === e2.precision ? t2 += "\n#define HIGH_PRECISION" : "mediump" === e2.precision ? t2 += "\n#define MEDIUM_PRECISION" : "lowp" === e2.precision && (t2 += "\n#define LOW_PRECISION"), t2;
  }
  function ol(e2, t2, n2, r2) {
    const i2 = e2.getContext(), s2 = n2.defines;
    let o2 = n2.vertexShader, a2 = n2.fragmentShader;
    const l2 = function(e3) {
      let t3 = "SHADOWMAP_TYPE_BASIC";
      return e3.shadowMapType === p ? t3 = "SHADOWMAP_TYPE_PCF" : e3.shadowMapType === d ? t3 = "SHADOWMAP_TYPE_PCF_SOFT" : e3.shadowMapType === h && (t3 = "SHADOWMAP_TYPE_VSM"), t3;
    }(n2), c2 = function(e3) {
      let t3 = "ENVMAP_TYPE_CUBE";
      if (e3.envMap)
        switch (e3.envMapMode) {
          case ie:
          case se:
            t3 = "ENVMAP_TYPE_CUBE";
            break;
          case le:
            t3 = "ENVMAP_TYPE_CUBE_UV";
        }
      return t3;
    }(n2), u2 = function(e3) {
      let t3 = "ENVMAP_MODE_REFLECTION";
      return e3.envMap && e3.envMapMode === se && (t3 = "ENVMAP_MODE_REFRACTION"), t3;
    }(n2), f2 = function(e3) {
      let t3 = "ENVMAP_BLENDING_NONE";
      if (e3.envMap)
        switch (e3.combine) {
          case X:
            t3 = "ENVMAP_BLENDING_MULTIPLY";
            break;
          case Y:
            t3 = "ENVMAP_BLENDING_MIX";
            break;
          case K:
            t3 = "ENVMAP_BLENDING_ADD";
        }
      return t3;
    }(n2), m2 = function(e3) {
      const t3 = e3.envMapCubeUVHeight;
      if (null === t3)
        return null;
      const n3 = Math.log2(t3) - 2, r3 = 1 / t3;
      return { texelWidth: 1 / (3 * Math.max(Math.pow(2, n3), 112)), texelHeight: r3, maxMip: n3 };
    }(n2), _2 = n2.isWebGL2 ? "" : function(e3) {
      return [e3.extensionDerivatives || e3.envMapCubeUVHeight || e3.bumpMap || e3.normalMapTangentSpace || e3.clearcoatNormalMap || e3.flatShading || "physical" === e3.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e3.extensionFragDepth || e3.logarithmicDepthBuffer) && e3.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e3.extensionDrawBuffers && e3.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e3.extensionShaderTextureLOD || e3.envMap || e3.transmission) && e3.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Ka).join("\n");
    }(n2), g2 = function(e3) {
      const t3 = [];
      for (const n3 in e3) {
        const r3 = e3[n3];
        false !== r3 && t3.push("#define " + n3 + " " + r3);
      }
      return t3.join("\n");
    }(s2), v2 = i2.createProgram();
    let y2, b2, w2 = n2.glslVersion ? "#version " + n2.glslVersion + "\n" : "";
    n2.isRawShaderMaterial ? (y2 = ["#define SHADER_TYPE " + n2.shaderType, "#define SHADER_NAME " + n2.shaderName, g2].filter(Ka).join("\n"), y2.length > 0 && (y2 += "\n"), b2 = [_2, "#define SHADER_TYPE " + n2.shaderType, "#define SHADER_NAME " + n2.shaderName, g2].filter(Ka).join("\n"), b2.length > 0 && (b2 += "\n")) : (y2 = [sl(n2), "#define SHADER_TYPE " + n2.shaderType, "#define SHADER_NAME " + n2.shaderName, g2, n2.instancing ? "#define USE_INSTANCING" : "", n2.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n2.useFog && n2.fog ? "#define USE_FOG" : "", n2.useFog && n2.fogExp2 ? "#define FOG_EXP2" : "", n2.map ? "#define USE_MAP" : "", n2.envMap ? "#define USE_ENVMAP" : "", n2.envMap ? "#define " + u2 : "", n2.lightMap ? "#define USE_LIGHTMAP" : "", n2.aoMap ? "#define USE_AOMAP" : "", n2.bumpMap ? "#define USE_BUMPMAP" : "", n2.normalMap ? "#define USE_NORMALMAP" : "", n2.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n2.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n2.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n2.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n2.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n2.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n2.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n2.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n2.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n2.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n2.specularMap ? "#define USE_SPECULARMAP" : "", n2.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n2.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n2.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n2.metalnessMap ? "#define USE_METALNESSMAP" : "", n2.alphaMap ? "#define USE_ALPHAMAP" : "", n2.transmission ? "#define USE_TRANSMISSION" : "", n2.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n2.thicknessMap ? "#define USE_THICKNESSMAP" : "", n2.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n2.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n2.mapUv ? "#define MAP_UV " + n2.mapUv : "", n2.alphaMapUv ? "#define ALPHAMAP_UV " + n2.alphaMapUv : "", n2.lightMapUv ? "#define LIGHTMAP_UV " + n2.lightMapUv : "", n2.aoMapUv ? "#define AOMAP_UV " + n2.aoMapUv : "", n2.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n2.emissiveMapUv : "", n2.bumpMapUv ? "#define BUMPMAP_UV " + n2.bumpMapUv : "", n2.normalMapUv ? "#define NORMALMAP_UV " + n2.normalMapUv : "", n2.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n2.displacementMapUv : "", n2.metalnessMapUv ? "#define METALNESSMAP_UV " + n2.metalnessMapUv : "", n2.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n2.roughnessMapUv : "", n2.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n2.anisotropyMapUv : "", n2.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n2.clearcoatMapUv : "", n2.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n2.clearcoatNormalMapUv : "", n2.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n2.clearcoatRoughnessMapUv : "", n2.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n2.iridescenceMapUv : "", n2.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n2.iridescenceThicknessMapUv : "", n2.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n2.sheenColorMapUv : "", n2.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n2.sheenRoughnessMapUv : "", n2.specularMapUv ? "#define SPECULARMAP_UV " + n2.specularMapUv : "", n2.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n2.specularColorMapUv : "", n2.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n2.specularIntensityMapUv : "", n2.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n2.transmissionMapUv : "", n2.thicknessMapUv ? "#define THICKNESSMAP_UV " + n2.thicknessMapUv : "", n2.vertexTangents ? "#define USE_TANGENT" : "", n2.vertexColors ? "#define USE_COLOR" : "", n2.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n2.vertexUv1s ? "#define USE_UV1" : "", n2.vertexUv2s ? "#define USE_UV2" : "", n2.vertexUv3s ? "#define USE_UV3" : "", n2.pointsUvs ? "#define USE_POINTS_UV" : "", n2.flatShading ? "#define FLAT_SHADED" : "", n2.skinning ? "#define USE_SKINNING" : "", n2.morphTargets ? "#define USE_MORPHTARGETS" : "", n2.morphNormals && false === n2.flatShading ? "#define USE_MORPHNORMALS" : "", n2.morphColors && n2.isWebGL2 ? "#define USE_MORPHCOLORS" : "", n2.morphTargetsCount > 0 && n2.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n2.morphTargetsCount > 0 && n2.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n2.morphTextureStride : "", n2.morphTargetsCount > 0 && n2.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n2.morphTargetsCount : "", n2.doubleSided ? "#define DOUBLE_SIDED" : "", n2.flipSided ? "#define FLIP_SIDED" : "", n2.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n2.shadowMapEnabled ? "#define " + l2 : "", n2.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n2.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n2.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n2.logarithmicDepthBuffer && n2.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(Ka).join("\n"), b2 = [_2, sl(n2), "#define SHADER_TYPE " + n2.shaderType, "#define SHADER_NAME " + n2.shaderName, g2, n2.instancing ? "#define USE_INSTANCING" : "", n2.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n2.useFog && n2.fog ? "#define USE_FOG" : "", n2.useFog && n2.fogExp2 ? "#define FOG_EXP2" : "", n2.map ? "#define USE_MAP" : "", n2.matcap ? "#define USE_MATCAP" : "", n2.envMap ? "#define USE_ENVMAP" : "", n2.envMap ? "#define " + c2 : "", n2.envMap ? "#define " + u2 : "", n2.envMap ? "#define " + f2 : "", m2 ? "#define CUBEUV_TEXEL_WIDTH " + m2.texelWidth : "", m2 ? "#define CUBEUV_TEXEL_HEIGHT " + m2.texelHeight : "", m2 ? "#define CUBEUV_MAX_MIP " + m2.maxMip + ".0" : "", n2.lightMap ? "#define USE_LIGHTMAP" : "", n2.aoMap ? "#define USE_AOMAP" : "", n2.bumpMap ? "#define USE_BUMPMAP" : "", n2.normalMap ? "#define USE_NORMALMAP" : "", n2.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n2.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n2.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n2.anisotropy ? "#define USE_ANISOTROPY" : "", n2.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n2.clearcoat ? "#define USE_CLEARCOAT" : "", n2.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n2.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n2.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n2.iridescence ? "#define USE_IRIDESCENCE" : "", n2.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n2.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n2.specularMap ? "#define USE_SPECULARMAP" : "", n2.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n2.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n2.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n2.metalnessMap ? "#define USE_METALNESSMAP" : "", n2.alphaMap ? "#define USE_ALPHAMAP" : "", n2.alphaTest ? "#define USE_ALPHATEST" : "", n2.sheen ? "#define USE_SHEEN" : "", n2.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n2.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n2.transmission ? "#define USE_TRANSMISSION" : "", n2.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n2.thicknessMap ? "#define USE_THICKNESSMAP" : "", n2.vertexTangents ? "#define USE_TANGENT" : "", n2.vertexColors || n2.instancingColor ? "#define USE_COLOR" : "", n2.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n2.vertexUv1s ? "#define USE_UV1" : "", n2.vertexUv2s ? "#define USE_UV2" : "", n2.vertexUv3s ? "#define USE_UV3" : "", n2.pointsUvs ? "#define USE_POINTS_UV" : "", n2.gradientMap ? "#define USE_GRADIENTMAP" : "", n2.flatShading ? "#define FLAT_SHADED" : "", n2.doubleSided ? "#define DOUBLE_SIDED" : "", n2.flipSided ? "#define FLIP_SIDED" : "", n2.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n2.shadowMapEnabled ? "#define " + l2 : "", n2.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n2.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n2.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n2.logarithmicDepthBuffer && n2.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n2.toneMapping !== J ? "#define TONE_MAPPING" : "", n2.toneMapping !== J ? so.tonemapping_pars_fragment : "", n2.toneMapping !== J ? Ya("toneMapping", n2.toneMapping) : "", n2.dithering ? "#define DITHERING" : "", n2.opaque ? "#define OPAQUE" : "", so.encodings_pars_fragment, Xa("linearToOutputTexel", n2.outputColorSpace), n2.transmissionSamplerMapEncoding ? qa("transmissionSamplerMapTexelToLinear", n2.transmissionSamplerMapEncoding) : "", n2.useDepthPacking ? "#define DEPTH_PACKING " + n2.depthPacking : "", "\n"].filter(Ka).join("\n")), o2 = el(o2), o2 = Ja(o2, n2), o2 = Za(o2, n2), a2 = el(a2), a2 = Ja(a2, n2), a2 = Za(a2, n2), o2 = rl(o2), a2 = rl(a2), n2.isWebGL2 && true !== n2.isRawShaderMaterial && (w2 = "#version 300 es\n", y2 = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + y2, b2 = ["#define varying in", n2.glslVersion === Sn ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n2.glslVersion === Sn ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad", "#define WebGL2Context 1"].join("\n") + "\n" + b2);
    const A2 = w2 + y2 + o2, x2 = w2 + b2 + a2, E2 = Va(i2, i2.VERTEX_SHADER, A2), C2 = Va(i2, i2.FRAGMENT_SHADER, x2);
    if (i2.attachShader(v2, E2), i2.attachShader(v2, C2), void 0 !== n2.index0AttributeName ? i2.bindAttribLocation(v2, 0, n2.index0AttributeName) : true === n2.morphTargets && i2.bindAttribLocation(v2, 0, "position"), i2.linkProgram(v2), e2.debug.checkShaderErrors) {
      const t3 = i2.getProgramInfoLog(v2).trim(), n3 = i2.getShaderInfoLog(E2).trim(), r3 = i2.getShaderInfoLog(C2).trim();
      let s3 = true, o3 = true;
      if (false === i2.getProgramParameter(v2, i2.LINK_STATUS))
        if (s3 = false, "function" == typeof e2.debug.onShaderError)
          e2.debug.onShaderError(i2, v2, E2, C2);
        else {
          const e3 = Wa(i2, E2, "vertex"), n4 = Wa(i2, C2, "fragment");
          console.error("THREE.WebGLProgram: Shader Error " + i2.getError() + " - VALIDATE_STATUS " + i2.getProgramParameter(v2, i2.VALIDATE_STATUS) + "\n\nProgram Info Log: " + t3 + "\n" + e3 + "\n" + n4);
        }
      else
        "" !== t3 ? console.warn("THREE.WebGLProgram: Program Info Log:", t3) : "" !== n3 && "" !== r3 || (o3 = false);
      o3 && (this.diagnostics = { runnable: s3, programLog: t3, vertexShader: { log: n3, prefix: y2 }, fragmentShader: { log: r3, prefix: b2 } });
    }
    let S2, M2;
    return i2.deleteShader(E2), i2.deleteShader(C2), this.getUniforms = function() {
      return void 0 === S2 && (S2 = new Ga(i2, v2)), S2;
    }, this.getAttributes = function() {
      return void 0 === M2 && (M2 = function(e3, t3) {
        const n3 = {}, r3 = e3.getProgramParameter(t3, e3.ACTIVE_ATTRIBUTES);
        for (let i3 = 0; i3 < r3; i3++) {
          const r4 = e3.getActiveAttrib(t3, i3), s3 = r4.name;
          let o3 = 1;
          r4.type === e3.FLOAT_MAT2 && (o3 = 2), r4.type === e3.FLOAT_MAT3 && (o3 = 3), r4.type === e3.FLOAT_MAT4 && (o3 = 4), n3[s3] = { type: r4.type, location: e3.getAttribLocation(t3, s3), locationSize: o3 };
        }
        return n3;
      }(i2, v2)), M2;
    }, this.destroy = function() {
      r2.releaseStatesOfProgram(this), i2.deleteProgram(v2), this.program = void 0;
    }, this.type = n2.shaderType, this.name = n2.shaderName, this.id = Ha++, this.cacheKey = t2, this.usedTimes = 1, this.program = v2, this.vertexShader = E2, this.fragmentShader = C2, this;
  }
  let al = 0;
  class ll {
    constructor() {
      this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
    }
    update(e2) {
      const t2 = e2.vertexShader, n2 = e2.fragmentShader, r2 = this._getShaderStage(t2), i2 = this._getShaderStage(n2), s2 = this._getShaderCacheForMaterial(e2);
      return false === s2.has(r2) && (s2.add(r2), r2.usedTimes++), false === s2.has(i2) && (s2.add(i2), i2.usedTimes++), this;
    }
    remove(e2) {
      const t2 = this.materialCache.get(e2);
      for (const e3 of t2)
        e3.usedTimes--, 0 === e3.usedTimes && this.shaderCache.delete(e3.code);
      return this.materialCache.delete(e2), this;
    }
    getVertexShaderID(e2) {
      return this._getShaderStage(e2.vertexShader).id;
    }
    getFragmentShaderID(e2) {
      return this._getShaderStage(e2.fragmentShader).id;
    }
    dispose() {
      this.shaderCache.clear(), this.materialCache.clear();
    }
    _getShaderCacheForMaterial(e2) {
      const t2 = this.materialCache;
      let n2 = t2.get(e2);
      return void 0 === n2 && (n2 = /* @__PURE__ */ new Set(), t2.set(e2, n2)), n2;
    }
    _getShaderStage(e2) {
      const t2 = this.shaderCache;
      let n2 = t2.get(e2);
      return void 0 === n2 && (n2 = new cl(e2), t2.set(e2, n2)), n2;
    }
  }
  class cl {
    constructor(e2) {
      this.id = al++, this.code = e2, this.usedTimes = 0;
    }
  }
  function ul(e2, t2, n2, r2, i2, s2, o2) {
    const a2 = new ci(), l2 = new ll(), c2 = [], u2 = i2.isWebGL2, p2 = i2.logarithmicDepthBuffer, d2 = i2.vertexTextures;
    let h2 = i2.precision;
    const f2 = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" };
    function g2(e3) {
      return 0 === e3 ? "uv" : `uv${e3}`;
    }
    return { getParameters: function(s3, a3, c3, v2, b2) {
      const w2 = v2.fog, A2 = b2.geometry, x2 = s3.isMeshStandardMaterial ? v2.environment : null, E2 = (s3.isMeshStandardMaterial ? n2 : t2).get(s3.envMap || x2), C2 = E2 && E2.mapping === le ? E2.image.height : null, S2 = f2[s3.type];
      null !== s3.precision && (h2 = i2.getMaxPrecision(s3.precision), h2 !== s3.precision && console.warn("THREE.WebGLProgram.getParameters:", s3.precision, "not supported, using", h2, "instead."));
      const M2 = A2.morphAttributes.position || A2.morphAttributes.normal || A2.morphAttributes.color, T2 = void 0 !== M2 ? M2.length : 0;
      let P2, I2, R2, k2, D2 = 0;
      if (void 0 !== A2.morphAttributes.position && (D2 = 1), void 0 !== A2.morphAttributes.normal && (D2 = 2), void 0 !== A2.morphAttributes.color && (D2 = 3), S2) {
        const e3 = ao[S2];
        P2 = e3.vertexShader, I2 = e3.fragmentShader;
      } else
        P2 = s3.vertexShader, I2 = s3.fragmentShader, l2.update(s3), R2 = l2.getVertexShaderID(s3), k2 = l2.getFragmentShaderID(s3);
      const B2 = e2.getRenderTarget(), O2 = e2.userData && e2.userData.transmissionRenderTarget, L2 = B2 ? Array.isArray(B2.texture) ? B2.texture[0] : B2.texture : null, U2 = true === b2.isInstancedMesh, F2 = !!s3.map, N2 = !!s3.matcap, j2 = !!E2, z2 = !!s3.aoMap, G2 = !!s3.lightMap, V2 = !!s3.bumpMap, H2 = !!s3.normalMap, Q2 = !!s3.displacementMap, W2 = !!s3.emissiveMap, q2 = !!s3.metalnessMap, X2 = !!s3.roughnessMap, Y2 = s3.anisotropy > 0, K2 = s3.clearcoat > 0, Z2 = s3.iridescence > 0, $2 = s3.sheen > 0, ee2 = s3.transmission > 0, te2 = Y2 && !!s3.anisotropyMap, ne2 = K2 && !!s3.clearcoatMap, re2 = K2 && !!s3.clearcoatNormalMap, ie2 = K2 && !!s3.clearcoatRoughnessMap, se2 = Z2 && !!s3.iridescenceMap, oe2 = Z2 && !!s3.iridescenceThicknessMap, ae2 = $2 && !!s3.sheenColorMap, ce2 = $2 && !!s3.sheenRoughnessMap, ue2 = !!s3.specularMap, pe2 = !!s3.specularColorMap, de2 = !!s3.specularIntensityMap, he2 = ee2 && !!s3.transmissionMap, fe2 = ee2 && !!s3.thicknessMap, me2 = !!s3.gradientMap, _e2 = !!s3.alphaMap, ge2 = s3.alphaTest > 0, ve2 = !!s3.extensions, ye2 = !!A2.attributes.uv1, be2 = !!A2.attributes.uv2, we2 = !!A2.attributes.uv3;
      return { isWebGL2: u2, shaderID: S2, shaderType: s3.type, shaderName: s3.name, vertexShader: P2, fragmentShader: I2, defines: s3.defines, customVertexShaderID: R2, customFragmentShaderID: k2, isRawShaderMaterial: true === s3.isRawShaderMaterial, glslVersion: s3.glslVersion, precision: h2, instancing: U2, instancingColor: U2 && null !== b2.instanceColor, supportsVertexTextures: d2, outputColorSpace: null === B2 ? e2.outputColorSpace : true === B2.isXRRenderTarget || L2.colorSpace && L2.colorSpace !== zt ? L2.colorSpace : Gt, map: F2, matcap: N2, envMap: j2, envMapMode: j2 && E2.mapping, envMapCubeUVHeight: C2, aoMap: z2, lightMap: G2, bumpMap: V2, normalMap: H2, displacementMap: d2 && Q2, emissiveMap: W2, normalMapObjectSpace: H2 && s3.normalMapType === Nt, normalMapTangentSpace: H2 && s3.normalMapType === Ft, metalnessMap: q2, roughnessMap: X2, anisotropy: Y2, anisotropyMap: te2, clearcoat: K2, clearcoatMap: ne2, clearcoatNormalMap: re2, clearcoatRoughnessMap: ie2, iridescence: Z2, iridescenceMap: se2, iridescenceThicknessMap: oe2, sheen: $2, sheenColorMap: ae2, sheenRoughnessMap: ce2, specularMap: ue2, specularColorMap: pe2, specularIntensityMap: de2, transmission: ee2, transmissionMap: he2, thicknessMap: fe2, transmissionSamplerMapEncoding: O2 && O2.texture.colorSpace || Gt, gradientMap: me2, opaque: false === s3.transparent && s3.blending === y && !(s3.transmission > 0), alphaMap: _e2, alphaTest: ge2, combine: s3.combine, mapUv: F2 && g2(s3.map.channel), aoMapUv: z2 && g2(s3.aoMap.channel), lightMapUv: G2 && g2(s3.lightMap.channel), bumpMapUv: V2 && g2(s3.bumpMap.channel), normalMapUv: H2 && g2(s3.normalMap.channel), displacementMapUv: Q2 && g2(s3.displacementMap.channel), emissiveMapUv: W2 && g2(s3.emissiveMap.channel), metalnessMapUv: q2 && g2(s3.metalnessMap.channel), roughnessMapUv: X2 && g2(s3.roughnessMap.channel), anisotropyMapUv: te2 && g2(s3.anisotropyMap.channel), clearcoatMapUv: ne2 && g2(s3.clearcoatMap.channel), clearcoatNormalMapUv: re2 && g2(s3.clearcoatNormalMap.channel), clearcoatRoughnessMapUv: ie2 && g2(s3.clearcoatRoughnessMap.channel), iridescenceMapUv: se2 && g2(s3.iridescenceMap.channel), iridescenceThicknessMapUv: oe2 && g2(s3.iridescenceThicknessMap.channel), sheenColorMapUv: ae2 && g2(s3.sheenColorMap.channel), sheenRoughnessMapUv: ce2 && g2(s3.sheenRoughnessMap.channel), specularMapUv: ue2 && g2(s3.specularMap.channel), specularColorMapUv: pe2 && g2(s3.specularColorMap.channel), specularIntensityMapUv: de2 && g2(s3.specularIntensityMap.channel), transmissionMapUv: he2 && g2(s3.transmissionMap.channel), thicknessMapUv: fe2 && g2(s3.thicknessMap.channel), alphaMapUv: _e2 && g2(s3.alphaMap.channel), vertexTangents: !!A2.attributes.tangent && (H2 || Y2), vertexColors: s3.vertexColors, vertexAlphas: true === s3.vertexColors && !!A2.attributes.color && 4 === A2.attributes.color.itemSize, vertexUv1s: ye2, vertexUv2s: be2, vertexUv3s: we2, pointsUvs: true === b2.isPoints && !!A2.attributes.uv && (F2 || _e2), fog: !!w2, useFog: true === s3.fog, fogExp2: w2 && w2.isFogExp2, flatShading: true === s3.flatShading, sizeAttenuation: true === s3.sizeAttenuation, logarithmicDepthBuffer: p2, skinning: true === b2.isSkinnedMesh, morphTargets: void 0 !== A2.morphAttributes.position, morphNormals: void 0 !== A2.morphAttributes.normal, morphColors: void 0 !== A2.morphAttributes.color, morphTargetsCount: T2, morphTextureStride: D2, numDirLights: a3.directional.length, numPointLights: a3.point.length, numSpotLights: a3.spot.length, numSpotLightMaps: a3.spotLightMap.length, numRectAreaLights: a3.rectArea.length, numHemiLights: a3.hemi.length, numDirLightShadows: a3.directionalShadowMap.length, numPointLightShadows: a3.pointShadowMap.length, numSpotLightShadows: a3.spotShadowMap.length, numSpotLightShadowsWithMaps: a3.numSpotLightShadowsWithMaps, numClippingPlanes: o2.numPlanes, numClipIntersection: o2.numIntersection, dithering: s3.dithering, shadowMapEnabled: e2.shadowMap.enabled && c3.length > 0, shadowMapType: e2.shadowMap.type, toneMapping: s3.toneMapped ? e2.toneMapping : J, useLegacyLights: e2.useLegacyLights, premultipliedAlpha: s3.premultipliedAlpha, doubleSided: s3.side === _, flipSided: s3.side === m, useDepthPacking: s3.depthPacking >= 0, depthPacking: s3.depthPacking || 0, index0AttributeName: s3.index0AttributeName, extensionDerivatives: ve2 && true === s3.extensions.derivatives, extensionFragDepth: ve2 && true === s3.extensions.fragDepth, extensionDrawBuffers: ve2 && true === s3.extensions.drawBuffers, extensionShaderTextureLOD: ve2 && true === s3.extensions.shaderTextureLOD, rendererExtensionFragDepth: u2 || r2.has("EXT_frag_depth"), rendererExtensionDrawBuffers: u2 || r2.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: u2 || r2.has("EXT_shader_texture_lod"), customProgramCacheKey: s3.customProgramCacheKey() };
    }, getProgramCacheKey: function(t3) {
      const n3 = [];
      if (t3.shaderID ? n3.push(t3.shaderID) : (n3.push(t3.customVertexShaderID), n3.push(t3.customFragmentShaderID)), void 0 !== t3.defines)
        for (const e3 in t3.defines)
          n3.push(e3), n3.push(t3.defines[e3]);
      return false === t3.isRawShaderMaterial && (function(e3, t4) {
        e3.push(t4.precision), e3.push(t4.outputColorSpace), e3.push(t4.envMapMode), e3.push(t4.envMapCubeUVHeight), e3.push(t4.mapUv), e3.push(t4.alphaMapUv), e3.push(t4.lightMapUv), e3.push(t4.aoMapUv), e3.push(t4.bumpMapUv), e3.push(t4.normalMapUv), e3.push(t4.displacementMapUv), e3.push(t4.emissiveMapUv), e3.push(t4.metalnessMapUv), e3.push(t4.roughnessMapUv), e3.push(t4.anisotropyMapUv), e3.push(t4.clearcoatMapUv), e3.push(t4.clearcoatNormalMapUv), e3.push(t4.clearcoatRoughnessMapUv), e3.push(t4.iridescenceMapUv), e3.push(t4.iridescenceThicknessMapUv), e3.push(t4.sheenColorMapUv), e3.push(t4.sheenRoughnessMapUv), e3.push(t4.specularMapUv), e3.push(t4.specularColorMapUv), e3.push(t4.specularIntensityMapUv), e3.push(t4.transmissionMapUv), e3.push(t4.thicknessMapUv), e3.push(t4.combine), e3.push(t4.fogExp2), e3.push(t4.sizeAttenuation), e3.push(t4.morphTargetsCount), e3.push(t4.morphAttributeCount), e3.push(t4.numDirLights), e3.push(t4.numPointLights), e3.push(t4.numSpotLights), e3.push(t4.numSpotLightMaps), e3.push(t4.numHemiLights), e3.push(t4.numRectAreaLights), e3.push(t4.numDirLightShadows), e3.push(t4.numPointLightShadows), e3.push(t4.numSpotLightShadows), e3.push(t4.numSpotLightShadowsWithMaps), e3.push(t4.shadowMapType), e3.push(t4.toneMapping), e3.push(t4.numClippingPlanes), e3.push(t4.numClipIntersection), e3.push(t4.depthPacking);
      }(n3, t3), function(e3, t4) {
        a2.disableAll(), t4.isWebGL2 && a2.enable(0), t4.supportsVertexTextures && a2.enable(1), t4.instancing && a2.enable(2), t4.instancingColor && a2.enable(3), t4.matcap && a2.enable(4), t4.envMap && a2.enable(5), t4.normalMapObjectSpace && a2.enable(6), t4.normalMapTangentSpace && a2.enable(7), t4.clearcoat && a2.enable(8), t4.iridescence && a2.enable(9), t4.alphaTest && a2.enable(10), t4.vertexColors && a2.enable(11), t4.vertexAlphas && a2.enable(12), t4.vertexUv1s && a2.enable(13), t4.vertexUv2s && a2.enable(14), t4.vertexUv3s && a2.enable(15), t4.vertexTangents && a2.enable(16), t4.anisotropy && a2.enable(17), e3.push(a2.mask), a2.disableAll(), t4.fog && a2.enable(0), t4.useFog && a2.enable(1), t4.flatShading && a2.enable(2), t4.logarithmicDepthBuffer && a2.enable(3), t4.skinning && a2.enable(4), t4.morphTargets && a2.enable(5), t4.morphNormals && a2.enable(6), t4.morphColors && a2.enable(7), t4.premultipliedAlpha && a2.enable(8), t4.shadowMapEnabled && a2.enable(9), t4.useLegacyLights && a2.enable(10), t4.doubleSided && a2.enable(11), t4.flipSided && a2.enable(12), t4.useDepthPacking && a2.enable(13), t4.dithering && a2.enable(14), t4.transmission && a2.enable(15), t4.sheen && a2.enable(16), t4.opaque && a2.enable(17), t4.pointsUvs && a2.enable(18), e3.push(a2.mask);
      }(n3, t3), n3.push(e2.outputColorSpace)), n3.push(t3.customProgramCacheKey), n3.join();
    }, getUniforms: function(e3) {
      const t3 = f2[e3.type];
      let n3;
      if (t3) {
        const e4 = ao[t3];
        n3 = zs.clone(e4.uniforms);
      } else
        n3 = e3.uniforms;
      return n3;
    }, acquireProgram: function(t3, n3) {
      let r3;
      for (let e3 = 0, t4 = c2.length; e3 < t4; e3++) {
        const t5 = c2[e3];
        if (t5.cacheKey === n3) {
          r3 = t5, ++r3.usedTimes;
          break;
        }
      }
      return void 0 === r3 && (r3 = new ol(e2, n3, t3, s2), c2.push(r3)), r3;
    }, releaseProgram: function(e3) {
      if (0 == --e3.usedTimes) {
        const t3 = c2.indexOf(e3);
        c2[t3] = c2[c2.length - 1], c2.pop(), e3.destroy();
      }
    }, releaseShaderCache: function(e3) {
      l2.remove(e3);
    }, programs: c2, dispose: function() {
      l2.dispose();
    } };
  }
  function pl() {
    let e2 = /* @__PURE__ */ new WeakMap();
    return { get: function(t2) {
      let n2 = e2.get(t2);
      return void 0 === n2 && (n2 = {}, e2.set(t2, n2)), n2;
    }, remove: function(t2) {
      e2.delete(t2);
    }, update: function(t2, n2, r2) {
      e2.get(t2)[n2] = r2;
    }, dispose: function() {
      e2 = /* @__PURE__ */ new WeakMap();
    } };
  }
  function dl(e2, t2) {
    return e2.groupOrder !== t2.groupOrder ? e2.groupOrder - t2.groupOrder : e2.renderOrder !== t2.renderOrder ? e2.renderOrder - t2.renderOrder : e2.material.id !== t2.material.id ? e2.material.id - t2.material.id : e2.z !== t2.z ? e2.z - t2.z : e2.id - t2.id;
  }
  function hl(e2, t2) {
    return e2.groupOrder !== t2.groupOrder ? e2.groupOrder - t2.groupOrder : e2.renderOrder !== t2.renderOrder ? e2.renderOrder - t2.renderOrder : e2.z !== t2.z ? t2.z - e2.z : e2.id - t2.id;
  }
  function fl() {
    const e2 = [];
    let t2 = 0;
    const n2 = [], r2 = [], i2 = [];
    function s2(n3, r3, i3, s3, o2, a2) {
      let l2 = e2[t2];
      return void 0 === l2 ? (l2 = { id: n3.id, object: n3, geometry: r3, material: i3, groupOrder: s3, renderOrder: n3.renderOrder, z: o2, group: a2 }, e2[t2] = l2) : (l2.id = n3.id, l2.object = n3, l2.geometry = r3, l2.material = i3, l2.groupOrder = s3, l2.renderOrder = n3.renderOrder, l2.z = o2, l2.group = a2), t2++, l2;
    }
    return { opaque: n2, transmissive: r2, transparent: i2, init: function() {
      t2 = 0, n2.length = 0, r2.length = 0, i2.length = 0;
    }, push: function(e3, t3, o2, a2, l2, c2) {
      const u2 = s2(e3, t3, o2, a2, l2, c2);
      o2.transmission > 0 ? r2.push(u2) : true === o2.transparent ? i2.push(u2) : n2.push(u2);
    }, unshift: function(e3, t3, o2, a2, l2, c2) {
      const u2 = s2(e3, t3, o2, a2, l2, c2);
      o2.transmission > 0 ? r2.unshift(u2) : true === o2.transparent ? i2.unshift(u2) : n2.unshift(u2);
    }, finish: function() {
      for (let n3 = t2, r3 = e2.length; n3 < r3; n3++) {
        const t3 = e2[n3];
        if (null === t3.id)
          break;
        t3.id = null, t3.object = null, t3.geometry = null, t3.material = null, t3.group = null;
      }
    }, sort: function(e3, t3) {
      n2.length > 1 && n2.sort(e3 || dl), r2.length > 1 && r2.sort(t3 || hl), i2.length > 1 && i2.sort(t3 || hl);
    } };
  }
  function ml() {
    let e2 = /* @__PURE__ */ new WeakMap();
    return { get: function(t2, n2) {
      const r2 = e2.get(t2);
      let i2;
      return void 0 === r2 ? (i2 = new fl(), e2.set(t2, [i2])) : n2 >= r2.length ? (i2 = new fl(), r2.push(i2)) : i2 = r2[n2], i2;
    }, dispose: function() {
      e2 = /* @__PURE__ */ new WeakMap();
    } };
  }
  function _l() {
    const e2 = {};
    return { get: function(t2) {
      if (void 0 !== e2[t2.id])
        return e2[t2.id];
      let n2;
      switch (t2.type) {
        case "DirectionalLight":
          n2 = { direction: new Ar(), color: new Vi() };
          break;
        case "SpotLight":
          n2 = { position: new Ar(), direction: new Ar(), color: new Vi(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
          break;
        case "PointLight":
          n2 = { position: new Ar(), color: new Vi(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          n2 = { direction: new Ar(), skyColor: new Vi(), groundColor: new Vi() };
          break;
        case "RectAreaLight":
          n2 = { color: new Vi(), position: new Ar(), halfWidth: new Ar(), halfHeight: new Ar() };
      }
      return e2[t2.id] = n2, n2;
    } };
  }
  let gl = 0;
  function vl(e2, t2) {
    return (t2.castShadow ? 2 : 0) - (e2.castShadow ? 2 : 0) + (t2.map ? 1 : 0) - (e2.map ? 1 : 0);
  }
  function yl(e2, t2) {
    const n2 = new _l(), r2 = function() {
      const e3 = {};
      return { get: function(t3) {
        if (void 0 !== e3[t3.id])
          return e3[t3.id];
        let n3;
        switch (t3.type) {
          case "DirectionalLight":
          case "SpotLight":
            n3 = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Qn() };
            break;
          case "PointLight":
            n3 = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Qn(), shadowCameraNear: 1, shadowCameraFar: 1e3 };
        }
        return e3[t3.id] = n3, n3;
      } };
    }(), i2 = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1, numSpotMaps: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotLightMap: [], spotShadow: [], spotShadowMap: [], spotLightMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], numSpotLightShadowsWithMaps: 0 };
    for (let e3 = 0; e3 < 9; e3++)
      i2.probe.push(new Ar());
    const s2 = new Ar(), o2 = new Zr(), a2 = new Zr();
    return { setup: function(s3, o3) {
      let a3 = 0, l2 = 0, c2 = 0;
      for (let e3 = 0; e3 < 9; e3++)
        i2.probe[e3].set(0, 0, 0);
      let u2 = 0, p2 = 0, d2 = 0, h2 = 0, f2 = 0, m2 = 0, _2 = 0, g2 = 0, v2 = 0, y2 = 0;
      s3.sort(vl);
      const b2 = true === o3 ? Math.PI : 1;
      for (let e3 = 0, t3 = s3.length; e3 < t3; e3++) {
        const t4 = s3[e3], o4 = t4.color, w3 = t4.intensity, A2 = t4.distance, x2 = t4.shadow && t4.shadow.map ? t4.shadow.map.texture : null;
        if (t4.isAmbientLight)
          a3 += o4.r * w3 * b2, l2 += o4.g * w3 * b2, c2 += o4.b * w3 * b2;
        else if (t4.isLightProbe)
          for (let e4 = 0; e4 < 9; e4++)
            i2.probe[e4].addScaledVector(t4.sh.coefficients[e4], w3);
        else if (t4.isDirectionalLight) {
          const e4 = n2.get(t4);
          if (e4.color.copy(t4.color).multiplyScalar(t4.intensity * b2), t4.castShadow) {
            const e5 = t4.shadow, n3 = r2.get(t4);
            n3.shadowBias = e5.bias, n3.shadowNormalBias = e5.normalBias, n3.shadowRadius = e5.radius, n3.shadowMapSize = e5.mapSize, i2.directionalShadow[u2] = n3, i2.directionalShadowMap[u2] = x2, i2.directionalShadowMatrix[u2] = t4.shadow.matrix, m2++;
          }
          i2.directional[u2] = e4, u2++;
        } else if (t4.isSpotLight) {
          const e4 = n2.get(t4);
          e4.position.setFromMatrixPosition(t4.matrixWorld), e4.color.copy(o4).multiplyScalar(w3 * b2), e4.distance = A2, e4.coneCos = Math.cos(t4.angle), e4.penumbraCos = Math.cos(t4.angle * (1 - t4.penumbra)), e4.decay = t4.decay, i2.spot[d2] = e4;
          const s4 = t4.shadow;
          if (t4.map && (i2.spotLightMap[v2] = t4.map, v2++, s4.updateMatrices(t4), t4.castShadow && y2++), i2.spotLightMatrix[d2] = s4.matrix, t4.castShadow) {
            const e5 = r2.get(t4);
            e5.shadowBias = s4.bias, e5.shadowNormalBias = s4.normalBias, e5.shadowRadius = s4.radius, e5.shadowMapSize = s4.mapSize, i2.spotShadow[d2] = e5, i2.spotShadowMap[d2] = x2, g2++;
          }
          d2++;
        } else if (t4.isRectAreaLight) {
          const e4 = n2.get(t4);
          e4.color.copy(o4).multiplyScalar(w3), e4.halfWidth.set(0.5 * t4.width, 0, 0), e4.halfHeight.set(0, 0.5 * t4.height, 0), i2.rectArea[h2] = e4, h2++;
        } else if (t4.isPointLight) {
          const e4 = n2.get(t4);
          if (e4.color.copy(t4.color).multiplyScalar(t4.intensity * b2), e4.distance = t4.distance, e4.decay = t4.decay, t4.castShadow) {
            const e5 = t4.shadow, n3 = r2.get(t4);
            n3.shadowBias = e5.bias, n3.shadowNormalBias = e5.normalBias, n3.shadowRadius = e5.radius, n3.shadowMapSize = e5.mapSize, n3.shadowCameraNear = e5.camera.near, n3.shadowCameraFar = e5.camera.far, i2.pointShadow[p2] = n3, i2.pointShadowMap[p2] = x2, i2.pointShadowMatrix[p2] = t4.shadow.matrix, _2++;
          }
          i2.point[p2] = e4, p2++;
        } else if (t4.isHemisphereLight) {
          const e4 = n2.get(t4);
          e4.skyColor.copy(t4.color).multiplyScalar(w3 * b2), e4.groundColor.copy(t4.groundColor).multiplyScalar(w3 * b2), i2.hemi[f2] = e4, f2++;
        }
      }
      h2 > 0 && (t2.isWebGL2 || true === e2.has("OES_texture_float_linear") ? (i2.rectAreaLTC1 = oo.LTC_FLOAT_1, i2.rectAreaLTC2 = oo.LTC_FLOAT_2) : true === e2.has("OES_texture_half_float_linear") ? (i2.rectAreaLTC1 = oo.LTC_HALF_1, i2.rectAreaLTC2 = oo.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i2.ambient[0] = a3, i2.ambient[1] = l2, i2.ambient[2] = c2;
      const w2 = i2.hash;
      w2.directionalLength === u2 && w2.pointLength === p2 && w2.spotLength === d2 && w2.rectAreaLength === h2 && w2.hemiLength === f2 && w2.numDirectionalShadows === m2 && w2.numPointShadows === _2 && w2.numSpotShadows === g2 && w2.numSpotMaps === v2 || (i2.directional.length = u2, i2.spot.length = d2, i2.rectArea.length = h2, i2.point.length = p2, i2.hemi.length = f2, i2.directionalShadow.length = m2, i2.directionalShadowMap.length = m2, i2.pointShadow.length = _2, i2.pointShadowMap.length = _2, i2.spotShadow.length = g2, i2.spotShadowMap.length = g2, i2.directionalShadowMatrix.length = m2, i2.pointShadowMatrix.length = _2, i2.spotLightMatrix.length = g2 + v2 - y2, i2.spotLightMap.length = v2, i2.numSpotLightShadowsWithMaps = y2, w2.directionalLength = u2, w2.pointLength = p2, w2.spotLength = d2, w2.rectAreaLength = h2, w2.hemiLength = f2, w2.numDirectionalShadows = m2, w2.numPointShadows = _2, w2.numSpotShadows = g2, w2.numSpotMaps = v2, i2.version = gl++);
    }, setupView: function(e3, t3) {
      let n3 = 0, r3 = 0, l2 = 0, c2 = 0, u2 = 0;
      const p2 = t3.matrixWorldInverse;
      for (let t4 = 0, d2 = e3.length; t4 < d2; t4++) {
        const d3 = e3[t4];
        if (d3.isDirectionalLight) {
          const e4 = i2.directional[n3];
          e4.direction.setFromMatrixPosition(d3.matrixWorld), s2.setFromMatrixPosition(d3.target.matrixWorld), e4.direction.sub(s2), e4.direction.transformDirection(p2), n3++;
        } else if (d3.isSpotLight) {
          const e4 = i2.spot[l2];
          e4.position.setFromMatrixPosition(d3.matrixWorld), e4.position.applyMatrix4(p2), e4.direction.setFromMatrixPosition(d3.matrixWorld), s2.setFromMatrixPosition(d3.target.matrixWorld), e4.direction.sub(s2), e4.direction.transformDirection(p2), l2++;
        } else if (d3.isRectAreaLight) {
          const e4 = i2.rectArea[c2];
          e4.position.setFromMatrixPosition(d3.matrixWorld), e4.position.applyMatrix4(p2), a2.identity(), o2.copy(d3.matrixWorld), o2.premultiply(p2), a2.extractRotation(o2), e4.halfWidth.set(0.5 * d3.width, 0, 0), e4.halfHeight.set(0, 0.5 * d3.height, 0), e4.halfWidth.applyMatrix4(a2), e4.halfHeight.applyMatrix4(a2), c2++;
        } else if (d3.isPointLight) {
          const e4 = i2.point[r3];
          e4.position.setFromMatrixPosition(d3.matrixWorld), e4.position.applyMatrix4(p2), r3++;
        } else if (d3.isHemisphereLight) {
          const e4 = i2.hemi[u2];
          e4.direction.setFromMatrixPosition(d3.matrixWorld), e4.direction.transformDirection(p2), u2++;
        }
      }
    }, state: i2 };
  }
  function bl(e2, t2) {
    const n2 = new yl(e2, t2), r2 = [], i2 = [];
    return { init: function() {
      r2.length = 0, i2.length = 0;
    }, state: { lightsArray: r2, shadowsArray: i2, lights: n2 }, setupLights: function(e3) {
      n2.setup(r2, e3);
    }, setupLightsView: function(e3) {
      n2.setupView(r2, e3);
    }, pushLight: function(e3) {
      r2.push(e3);
    }, pushShadow: function(e3) {
      i2.push(e3);
    } };
  }
  function wl(e2, t2) {
    let n2 = /* @__PURE__ */ new WeakMap();
    return { get: function(r2, i2 = 0) {
      const s2 = n2.get(r2);
      let o2;
      return void 0 === s2 ? (o2 = new bl(e2, t2), n2.set(r2, [o2])) : i2 >= s2.length ? (o2 = new bl(e2, t2), s2.push(o2)) : o2 = s2[i2], o2;
    }, dispose: function() {
      n2 = /* @__PURE__ */ new WeakMap();
    } };
  }
  class Al extends Ui {
    constructor(e2) {
      super(), this.isMeshDepthMaterial = true, this.type = "MeshDepthMaterial", this.depthPacking = Lt, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.depthPacking = e2.depthPacking, this.map = e2.map, this.alphaMap = e2.alphaMap, this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this;
    }
  }
  class xl extends Ui {
    constructor(e2) {
      super(), this.isMeshDistanceMaterial = true, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.map = e2.map, this.alphaMap = e2.alphaMap, this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this;
    }
  }
  const El = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}", Cl = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
  function Sl(e2, t2, n2) {
    let r2 = new to();
    const i2 = new Qn(), s2 = new Qn(), o2 = new fr(), a2 = new Al({ depthPacking: Ut }), l2 = new xl(), c2 = {}, u2 = n2.maxTextureSize, d2 = { [f]: m, [m]: f, [_]: _ }, g2 = new Gs({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new Qn() }, radius: { value: 4 } }, vertexShader: El, fragmentShader: Cl }), y2 = g2.clone();
    y2.defines.HORIZONTAL_PASS = 1;
    const b2 = new gs();
    b2.setAttribute("position", new $i(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
    const w2 = new Os(b2, g2), A2 = this;
    this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = p;
    let x2 = this.type;
    function E2(n3, r3) {
      const s3 = t2.update(w2);
      g2.defines.VSM_SAMPLES !== n3.blurSamples && (g2.defines.VSM_SAMPLES = n3.blurSamples, y2.defines.VSM_SAMPLES = n3.blurSamples, g2.needsUpdate = true, y2.needsUpdate = true), null === n3.mapPass && (n3.mapPass = new mr(i2.x, i2.y)), g2.uniforms.shadow_pass.value = n3.map.texture, g2.uniforms.resolution.value = n3.mapSize, g2.uniforms.radius.value = n3.radius, e2.setRenderTarget(n3.mapPass), e2.clear(), e2.renderBufferDirect(r3, null, s3, g2, w2, null), y2.uniforms.shadow_pass.value = n3.mapPass.texture, y2.uniforms.resolution.value = n3.mapSize, y2.uniforms.radius.value = n3.radius, e2.setRenderTarget(n3.map), e2.clear(), e2.renderBufferDirect(r3, null, s3, y2, w2, null);
    }
    function C2(t3, n3, r3, i3) {
      let s3 = null;
      const o3 = true === r3.isPointLight ? t3.customDistanceMaterial : t3.customDepthMaterial;
      if (void 0 !== o3)
        s3 = o3;
      else if (s3 = true === r3.isPointLight ? l2 : a2, e2.localClippingEnabled && true === n3.clipShadows && Array.isArray(n3.clippingPlanes) && 0 !== n3.clippingPlanes.length || n3.displacementMap && 0 !== n3.displacementScale || n3.alphaMap && n3.alphaTest > 0 || n3.map && n3.alphaTest > 0) {
        const e3 = s3.uuid, t4 = n3.uuid;
        let r4 = c2[e3];
        void 0 === r4 && (r4 = {}, c2[e3] = r4);
        let i4 = r4[t4];
        void 0 === i4 && (i4 = s3.clone(), r4[t4] = i4), s3 = i4;
      }
      return s3.visible = n3.visible, s3.wireframe = n3.wireframe, s3.side = i3 === h ? null !== n3.shadowSide ? n3.shadowSide : n3.side : null !== n3.shadowSide ? n3.shadowSide : d2[n3.side], s3.alphaMap = n3.alphaMap, s3.alphaTest = n3.alphaTest, s3.map = n3.map, s3.clipShadows = n3.clipShadows, s3.clippingPlanes = n3.clippingPlanes, s3.clipIntersection = n3.clipIntersection, s3.displacementMap = n3.displacementMap, s3.displacementScale = n3.displacementScale, s3.displacementBias = n3.displacementBias, s3.wireframeLinewidth = n3.wireframeLinewidth, s3.linewidth = n3.linewidth, true === r3.isPointLight && true === s3.isMeshDistanceMaterial && (e2.properties.get(s3).light = r3), s3;
    }
    function S2(n3, i3, s3, o3, a3) {
      if (false === n3.visible)
        return;
      if (n3.layers.test(i3.layers) && (n3.isMesh || n3.isLine || n3.isPoints) && (n3.castShadow || n3.receiveShadow && a3 === h) && (!n3.frustumCulled || r2.intersectsObject(n3))) {
        n3.modelViewMatrix.multiplyMatrices(s3.matrixWorldInverse, n3.matrixWorld);
        const r3 = t2.update(n3), i4 = n3.material;
        if (Array.isArray(i4)) {
          const t3 = r3.groups;
          for (let l4 = 0, c3 = t3.length; l4 < c3; l4++) {
            const c4 = t3[l4], u3 = i4[c4.materialIndex];
            if (u3 && u3.visible) {
              const t4 = C2(n3, u3, o3, a3);
              e2.renderBufferDirect(s3, null, r3, t4, n3, c4);
            }
          }
        } else if (i4.visible) {
          const t3 = C2(n3, i4, o3, a3);
          e2.renderBufferDirect(s3, null, r3, t3, n3, null);
        }
      }
      const l3 = n3.children;
      for (let e3 = 0, t3 = l3.length; e3 < t3; e3++)
        S2(l3[e3], i3, s3, o3, a3);
    }
    this.render = function(t3, n3, a3) {
      if (false === A2.enabled)
        return;
      if (false === A2.autoUpdate && false === A2.needsUpdate)
        return;
      if (0 === t3.length)
        return;
      const l3 = e2.getRenderTarget(), c3 = e2.getActiveCubeFace(), p2 = e2.getActiveMipmapLevel(), d3 = e2.state;
      d3.setBlending(v), d3.buffers.color.setClear(1, 1, 1, 1), d3.buffers.depth.setTest(true), d3.setScissorTest(false);
      const f2 = x2 !== h && this.type === h, m2 = x2 === h && this.type !== h;
      for (let l4 = 0, c4 = t3.length; l4 < c4; l4++) {
        const c5 = t3[l4], p3 = c5.shadow;
        if (void 0 === p3) {
          console.warn("THREE.WebGLShadowMap:", c5, "has no shadow.");
          continue;
        }
        if (false === p3.autoUpdate && false === p3.needsUpdate)
          continue;
        i2.copy(p3.mapSize);
        const _2 = p3.getFrameExtents();
        if (i2.multiply(_2), s2.copy(p3.mapSize), (i2.x > u2 || i2.y > u2) && (i2.x > u2 && (s2.x = Math.floor(u2 / _2.x), i2.x = s2.x * _2.x, p3.mapSize.x = s2.x), i2.y > u2 && (s2.y = Math.floor(u2 / _2.y), i2.y = s2.y * _2.y, p3.mapSize.y = s2.y)), null === p3.map || true === f2 || true === m2) {
          const e3 = this.type !== h ? { minFilter: de, magFilter: de } : {};
          null !== p3.map && p3.map.dispose(), p3.map = new mr(i2.x, i2.y, e3), p3.map.texture.name = c5.name + ".shadowMap", p3.camera.updateProjectionMatrix();
        }
        e2.setRenderTarget(p3.map), e2.clear();
        const g3 = p3.getViewportCount();
        for (let e3 = 0; e3 < g3; e3++) {
          const t4 = p3.getViewport(e3);
          o2.set(s2.x * t4.x, s2.y * t4.y, s2.x * t4.z, s2.y * t4.w), d3.viewport(o2), p3.updateMatrices(c5, e3), r2 = p3.getFrustum(), S2(n3, a3, p3.camera, c5, this.type);
        }
        true !== p3.isPointLightShadow && this.type === h && E2(p3, a3), p3.needsUpdate = false;
      }
      x2 = this.type, A2.needsUpdate = false, e2.setRenderTarget(l3, c3, p2);
    };
  }
  function Ml(e2, t2, n2) {
    const r2 = n2.isWebGL2, i2 = new function() {
      let t3 = false;
      const n3 = new fr();
      let r3 = null;
      const i3 = new fr(0, 0, 0, 0);
      return { setMask: function(n4) {
        r3 === n4 || t3 || (e2.colorMask(n4, n4, n4, n4), r3 = n4);
      }, setLocked: function(e3) {
        t3 = e3;
      }, setClear: function(t4, r4, s3, o2, a2) {
        true === a2 && (t4 *= o2, r4 *= o2, s3 *= o2), n3.set(t4, r4, s3, o2), false === i3.equals(n3) && (e2.clearColor(t4, r4, s3, o2), i3.copy(n3));
      }, reset: function() {
        t3 = false, r3 = null, i3.set(-1, 0, 0, 0);
      } };
    }(), s2 = new function() {
      let t3 = false, n3 = null, r3 = null, i3 = null;
      return { setTest: function(t4) {
        t4 ? we2(e2.DEPTH_TEST) : Ae2(e2.DEPTH_TEST);
      }, setMask: function(r4) {
        n3 === r4 || t3 || (e2.depthMask(r4), n3 = r4);
      }, setFunc: function(t4) {
        if (r3 !== t4) {
          switch (t4) {
            case j:
              e2.depthFunc(e2.NEVER);
              break;
            case z:
              e2.depthFunc(e2.ALWAYS);
              break;
            case G:
              e2.depthFunc(e2.LESS);
              break;
            case V:
              e2.depthFunc(e2.LEQUAL);
              break;
            case H:
              e2.depthFunc(e2.EQUAL);
              break;
            case Q:
              e2.depthFunc(e2.GEQUAL);
              break;
            case W:
              e2.depthFunc(e2.GREATER);
              break;
            case q:
              e2.depthFunc(e2.NOTEQUAL);
              break;
            default:
              e2.depthFunc(e2.LEQUAL);
          }
          r3 = t4;
        }
      }, setLocked: function(e3) {
        t3 = e3;
      }, setClear: function(t4) {
        i3 !== t4 && (e2.clearDepth(t4), i3 = t4);
      }, reset: function() {
        t3 = false, n3 = null, r3 = null, i3 = null;
      } };
    }(), c2 = new function() {
      let t3 = false, n3 = null, r3 = null, i3 = null, s3 = null, o2 = null, a2 = null, l2 = null, c3 = null;
      return { setTest: function(n4) {
        t3 || (n4 ? we2(e2.STENCIL_TEST) : Ae2(e2.STENCIL_TEST));
      }, setMask: function(r4) {
        n3 === r4 || t3 || (e2.stencilMask(r4), n3 = r4);
      }, setFunc: function(t4, n4, o3) {
        r3 === t4 && i3 === n4 && s3 === o3 || (e2.stencilFunc(t4, n4, o3), r3 = t4, i3 = n4, s3 = o3);
      }, setOp: function(t4, n4, r4) {
        o2 === t4 && a2 === n4 && l2 === r4 || (e2.stencilOp(t4, n4, r4), o2 = t4, a2 = n4, l2 = r4);
      }, setLocked: function(e3) {
        t3 = e3;
      }, setClear: function(t4) {
        c3 !== t4 && (e2.clearStencil(t4), c3 = t4);
      }, reset: function() {
        t3 = false, n3 = null, r3 = null, i3 = null, s3 = null, o2 = null, a2 = null, l2 = null, c3 = null;
      } };
    }(), u2 = /* @__PURE__ */ new WeakMap(), p2 = /* @__PURE__ */ new WeakMap();
    let d2 = {}, h2 = {}, f2 = /* @__PURE__ */ new WeakMap(), g2 = [], X2 = null, Y2 = false, K2 = null, J2 = null, Z2 = null, $2 = null, ee2 = null, te2 = null, ne2 = null, re2 = false, ie2 = null, se2 = null, oe2 = null, ae2 = null, le2 = null;
    const ce2 = e2.getParameter(e2.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let ue2 = false, pe2 = 0;
    const de2 = e2.getParameter(e2.VERSION);
    -1 !== de2.indexOf("WebGL") ? (pe2 = parseFloat(/^WebGL (\d)/.exec(de2)[1]), ue2 = pe2 >= 1) : -1 !== de2.indexOf("OpenGL ES") && (pe2 = parseFloat(/^OpenGL ES (\d)/.exec(de2)[1]), ue2 = pe2 >= 2);
    let he2 = null, fe2 = {};
    const me2 = e2.getParameter(e2.SCISSOR_BOX), _e2 = e2.getParameter(e2.VIEWPORT), ge2 = new fr().fromArray(me2), ve2 = new fr().fromArray(_e2);
    function ye2(t3, n3, i3, s3) {
      const o2 = new Uint8Array(4), a2 = e2.createTexture();
      e2.bindTexture(t3, a2), e2.texParameteri(t3, e2.TEXTURE_MIN_FILTER, e2.NEAREST), e2.texParameteri(t3, e2.TEXTURE_MAG_FILTER, e2.NEAREST);
      for (let a3 = 0; a3 < i3; a3++)
        !r2 || t3 !== e2.TEXTURE_3D && t3 !== e2.TEXTURE_2D_ARRAY ? e2.texImage2D(n3 + a3, 0, e2.RGBA, 1, 1, 0, e2.RGBA, e2.UNSIGNED_BYTE, o2) : e2.texImage3D(n3, 0, e2.RGBA, 1, 1, s3, 0, e2.RGBA, e2.UNSIGNED_BYTE, o2);
      return a2;
    }
    const be2 = {};
    function we2(t3) {
      true !== d2[t3] && (e2.enable(t3), d2[t3] = true);
    }
    function Ae2(t3) {
      false !== d2[t3] && (e2.disable(t3), d2[t3] = false);
    }
    be2[e2.TEXTURE_2D] = ye2(e2.TEXTURE_2D, e2.TEXTURE_2D, 1), be2[e2.TEXTURE_CUBE_MAP] = ye2(e2.TEXTURE_CUBE_MAP, e2.TEXTURE_CUBE_MAP_POSITIVE_X, 6), r2 && (be2[e2.TEXTURE_2D_ARRAY] = ye2(e2.TEXTURE_2D_ARRAY, e2.TEXTURE_2D_ARRAY, 1, 1), be2[e2.TEXTURE_3D] = ye2(e2.TEXTURE_3D, e2.TEXTURE_3D, 1, 1)), i2.setClear(0, 0, 0, 1), s2.setClear(1), c2.setClear(0), we2(e2.DEPTH_TEST), s2.setFunc(V), Se2(false), Me2(a), we2(e2.CULL_FACE), Ce2(v);
    const xe2 = { [E]: e2.FUNC_ADD, [C]: e2.FUNC_SUBTRACT, [S]: e2.FUNC_REVERSE_SUBTRACT };
    if (r2)
      xe2[M] = e2.MIN, xe2[T] = e2.MAX;
    else {
      const e3 = t2.get("EXT_blend_minmax");
      null !== e3 && (xe2[M] = e3.MIN_EXT, xe2[T] = e3.MAX_EXT);
    }
    const Ee2 = { [P]: e2.ZERO, [I]: e2.ONE, [R]: e2.SRC_COLOR, [D]: e2.SRC_ALPHA, [N]: e2.SRC_ALPHA_SATURATE, [U]: e2.DST_COLOR, [O]: e2.DST_ALPHA, [k]: e2.ONE_MINUS_SRC_COLOR, [B]: e2.ONE_MINUS_SRC_ALPHA, [F]: e2.ONE_MINUS_DST_COLOR, [L]: e2.ONE_MINUS_DST_ALPHA };
    function Ce2(t3, n3, r3, i3, s3, o2, a2, l2) {
      if (t3 !== v) {
        if (false === Y2 && (we2(e2.BLEND), Y2 = true), t3 === x)
          s3 = s3 || n3, o2 = o2 || r3, a2 = a2 || i3, n3 === J2 && s3 === ee2 || (e2.blendEquationSeparate(xe2[n3], xe2[s3]), J2 = n3, ee2 = s3), r3 === Z2 && i3 === $2 && o2 === te2 && a2 === ne2 || (e2.blendFuncSeparate(Ee2[r3], Ee2[i3], Ee2[o2], Ee2[a2]), Z2 = r3, $2 = i3, te2 = o2, ne2 = a2), K2 = t3, re2 = false;
        else if (t3 !== K2 || l2 !== re2) {
          if (J2 === E && ee2 === E || (e2.blendEquation(e2.FUNC_ADD), J2 = E, ee2 = E), l2)
            switch (t3) {
              case y:
                e2.blendFuncSeparate(e2.ONE, e2.ONE_MINUS_SRC_ALPHA, e2.ONE, e2.ONE_MINUS_SRC_ALPHA);
                break;
              case b:
                e2.blendFunc(e2.ONE, e2.ONE);
                break;
              case w:
                e2.blendFuncSeparate(e2.ZERO, e2.ONE_MINUS_SRC_COLOR, e2.ZERO, e2.ONE);
                break;
              case A:
                e2.blendFuncSeparate(e2.ZERO, e2.SRC_COLOR, e2.ZERO, e2.SRC_ALPHA);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", t3);
            }
          else
            switch (t3) {
              case y:
                e2.blendFuncSeparate(e2.SRC_ALPHA, e2.ONE_MINUS_SRC_ALPHA, e2.ONE, e2.ONE_MINUS_SRC_ALPHA);
                break;
              case b:
                e2.blendFunc(e2.SRC_ALPHA, e2.ONE);
                break;
              case w:
                e2.blendFuncSeparate(e2.ZERO, e2.ONE_MINUS_SRC_COLOR, e2.ZERO, e2.ONE);
                break;
              case A:
                e2.blendFunc(e2.ZERO, e2.SRC_COLOR);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", t3);
            }
          Z2 = null, $2 = null, te2 = null, ne2 = null, K2 = t3, re2 = l2;
        }
      } else
        true === Y2 && (Ae2(e2.BLEND), Y2 = false);
    }
    function Se2(t3) {
      ie2 !== t3 && (t3 ? e2.frontFace(e2.CW) : e2.frontFace(e2.CCW), ie2 = t3);
    }
    function Me2(t3) {
      t3 !== o ? (we2(e2.CULL_FACE), t3 !== se2 && (t3 === a ? e2.cullFace(e2.BACK) : t3 === l ? e2.cullFace(e2.FRONT) : e2.cullFace(e2.FRONT_AND_BACK))) : Ae2(e2.CULL_FACE), se2 = t3;
    }
    function Te2(t3, n3, r3) {
      t3 ? (we2(e2.POLYGON_OFFSET_FILL), ae2 === n3 && le2 === r3 || (e2.polygonOffset(n3, r3), ae2 = n3, le2 = r3)) : Ae2(e2.POLYGON_OFFSET_FILL);
    }
    return { buffers: { color: i2, depth: s2, stencil: c2 }, enable: we2, disable: Ae2, bindFramebuffer: function(t3, n3) {
      return h2[t3] !== n3 && (e2.bindFramebuffer(t3, n3), h2[t3] = n3, r2 && (t3 === e2.DRAW_FRAMEBUFFER && (h2[e2.FRAMEBUFFER] = n3), t3 === e2.FRAMEBUFFER && (h2[e2.DRAW_FRAMEBUFFER] = n3)), true);
    }, drawBuffers: function(r3, i3) {
      let s3 = g2, o2 = false;
      if (r3)
        if (s3 = f2.get(i3), void 0 === s3 && (s3 = [], f2.set(i3, s3)), r3.isWebGLMultipleRenderTargets) {
          const t3 = r3.texture;
          if (s3.length !== t3.length || s3[0] !== e2.COLOR_ATTACHMENT0) {
            for (let n3 = 0, r4 = t3.length; n3 < r4; n3++)
              s3[n3] = e2.COLOR_ATTACHMENT0 + n3;
            s3.length = t3.length, o2 = true;
          }
        } else
          s3[0] !== e2.COLOR_ATTACHMENT0 && (s3[0] = e2.COLOR_ATTACHMENT0, o2 = true);
      else
        s3[0] !== e2.BACK && (s3[0] = e2.BACK, o2 = true);
      o2 && (n2.isWebGL2 ? e2.drawBuffers(s3) : t2.get("WEBGL_draw_buffers").drawBuffersWEBGL(s3));
    }, useProgram: function(t3) {
      return X2 !== t3 && (e2.useProgram(t3), X2 = t3, true);
    }, setBlending: Ce2, setMaterial: function(t3, n3) {
      t3.side === _ ? Ae2(e2.CULL_FACE) : we2(e2.CULL_FACE);
      let r3 = t3.side === m;
      n3 && (r3 = !r3), Se2(r3), t3.blending === y && false === t3.transparent ? Ce2(v) : Ce2(t3.blending, t3.blendEquation, t3.blendSrc, t3.blendDst, t3.blendEquationAlpha, t3.blendSrcAlpha, t3.blendDstAlpha, t3.premultipliedAlpha), s2.setFunc(t3.depthFunc), s2.setTest(t3.depthTest), s2.setMask(t3.depthWrite), i2.setMask(t3.colorWrite);
      const o2 = t3.stencilWrite;
      c2.setTest(o2), o2 && (c2.setMask(t3.stencilWriteMask), c2.setFunc(t3.stencilFunc, t3.stencilRef, t3.stencilFuncMask), c2.setOp(t3.stencilFail, t3.stencilZFail, t3.stencilZPass)), Te2(t3.polygonOffset, t3.polygonOffsetFactor, t3.polygonOffsetUnits), true === t3.alphaToCoverage ? we2(e2.SAMPLE_ALPHA_TO_COVERAGE) : Ae2(e2.SAMPLE_ALPHA_TO_COVERAGE);
    }, setFlipSided: Se2, setCullFace: Me2, setLineWidth: function(t3) {
      t3 !== oe2 && (ue2 && e2.lineWidth(t3), oe2 = t3);
    }, setPolygonOffset: Te2, setScissorTest: function(t3) {
      t3 ? we2(e2.SCISSOR_TEST) : Ae2(e2.SCISSOR_TEST);
    }, activeTexture: function(t3) {
      void 0 === t3 && (t3 = e2.TEXTURE0 + ce2 - 1), he2 !== t3 && (e2.activeTexture(t3), he2 = t3);
    }, bindTexture: function(t3, n3, r3) {
      void 0 === r3 && (r3 = null === he2 ? e2.TEXTURE0 + ce2 - 1 : he2);
      let i3 = fe2[r3];
      void 0 === i3 && (i3 = { type: void 0, texture: void 0 }, fe2[r3] = i3), i3.type === t3 && i3.texture === n3 || (he2 !== r3 && (e2.activeTexture(r3), he2 = r3), e2.bindTexture(t3, n3 || be2[t3]), i3.type = t3, i3.texture = n3);
    }, unbindTexture: function() {
      const t3 = fe2[he2];
      void 0 !== t3 && void 0 !== t3.type && (e2.bindTexture(t3.type, null), t3.type = void 0, t3.texture = void 0);
    }, compressedTexImage2D: function() {
      try {
        e2.compressedTexImage2D.apply(e2, arguments);
      } catch (e3) {
        console.error("THREE.WebGLState:", e3);
      }
    }, compressedTexImage3D: function() {
      try {
        e2.compressedTexImage3D.apply(e2, arguments);
      } catch (e3) {
        console.error("THREE.WebGLState:", e3);
      }
    }, texImage2D: function() {
      try {
        e2.texImage2D.apply(e2, arguments);
      } catch (e3) {
        console.error("THREE.WebGLState:", e3);
      }
    }, texImage3D: function() {
      try {
        e2.texImage3D.apply(e2, arguments);
      } catch (e3) {
        console.error("THREE.WebGLState:", e3);
      }
    }, updateUBOMapping: function(t3, n3) {
      let r3 = p2.get(n3);
      void 0 === r3 && (r3 = /* @__PURE__ */ new WeakMap(), p2.set(n3, r3));
      let i3 = r3.get(t3);
      void 0 === i3 && (i3 = e2.getUniformBlockIndex(n3, t3.name), r3.set(t3, i3));
    }, uniformBlockBinding: function(t3, n3) {
      const r3 = p2.get(n3).get(t3);
      u2.get(n3) !== r3 && (e2.uniformBlockBinding(n3, r3, t3.__bindingPointIndex), u2.set(n3, r3));
    }, texStorage2D: function() {
      try {
        e2.texStorage2D.apply(e2, arguments);
      } catch (e3) {
        console.error("THREE.WebGLState:", e3);
      }
    }, texStorage3D: function() {
      try {
        e2.texStorage3D.apply(e2, arguments);
      } catch (e3) {
        console.error("THREE.WebGLState:", e3);
      }
    }, texSubImage2D: function() {
      try {
        e2.texSubImage2D.apply(e2, arguments);
      } catch (e3) {
        console.error("THREE.WebGLState:", e3);
      }
    }, texSubImage3D: function() {
      try {
        e2.texSubImage3D.apply(e2, arguments);
      } catch (e3) {
        console.error("THREE.WebGLState:", e3);
      }
    }, compressedTexSubImage2D: function() {
      try {
        e2.compressedTexSubImage2D.apply(e2, arguments);
      } catch (e3) {
        console.error("THREE.WebGLState:", e3);
      }
    }, compressedTexSubImage3D: function() {
      try {
        e2.compressedTexSubImage3D.apply(e2, arguments);
      } catch (e3) {
        console.error("THREE.WebGLState:", e3);
      }
    }, scissor: function(t3) {
      false === ge2.equals(t3) && (e2.scissor(t3.x, t3.y, t3.z, t3.w), ge2.copy(t3));
    }, viewport: function(t3) {
      false === ve2.equals(t3) && (e2.viewport(t3.x, t3.y, t3.z, t3.w), ve2.copy(t3));
    }, reset: function() {
      e2.disable(e2.BLEND), e2.disable(e2.CULL_FACE), e2.disable(e2.DEPTH_TEST), e2.disable(e2.POLYGON_OFFSET_FILL), e2.disable(e2.SCISSOR_TEST), e2.disable(e2.STENCIL_TEST), e2.disable(e2.SAMPLE_ALPHA_TO_COVERAGE), e2.blendEquation(e2.FUNC_ADD), e2.blendFunc(e2.ONE, e2.ZERO), e2.blendFuncSeparate(e2.ONE, e2.ZERO, e2.ONE, e2.ZERO), e2.colorMask(true, true, true, true), e2.clearColor(0, 0, 0, 0), e2.depthMask(true), e2.depthFunc(e2.LESS), e2.clearDepth(1), e2.stencilMask(4294967295), e2.stencilFunc(e2.ALWAYS, 0, 4294967295), e2.stencilOp(e2.KEEP, e2.KEEP, e2.KEEP), e2.clearStencil(0), e2.cullFace(e2.BACK), e2.frontFace(e2.CCW), e2.polygonOffset(0, 0), e2.activeTexture(e2.TEXTURE0), e2.bindFramebuffer(e2.FRAMEBUFFER, null), true === r2 && (e2.bindFramebuffer(e2.DRAW_FRAMEBUFFER, null), e2.bindFramebuffer(e2.READ_FRAMEBUFFER, null)), e2.useProgram(null), e2.lineWidth(1), e2.scissor(0, 0, e2.canvas.width, e2.canvas.height), e2.viewport(0, 0, e2.canvas.width, e2.canvas.height), d2 = {}, he2 = null, fe2 = {}, h2 = {}, f2 = /* @__PURE__ */ new WeakMap(), g2 = [], X2 = null, Y2 = false, K2 = null, J2 = null, Z2 = null, $2 = null, ee2 = null, te2 = null, ne2 = null, re2 = false, ie2 = null, se2 = null, oe2 = null, ae2 = null, le2 = null, ge2.set(0, 0, e2.canvas.width, e2.canvas.height), ve2.set(0, 0, e2.canvas.width, e2.canvas.height), i2.reset(), s2.reset(), c2.reset();
    } };
  }
  function Tl(e2, t2, n2, r2, i2, s2, o2) {
    const a2 = i2.isWebGL2, l2 = i2.maxTextures, c2 = i2.maxCubemapSize, u2 = i2.maxTextureSize, p2 = i2.maxSamples, d2 = t2.has("WEBGL_multisampled_render_to_texture") ? t2.get("WEBGL_multisampled_render_to_texture") : null, h2 = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent), f2 = /* @__PURE__ */ new WeakMap();
    let m2;
    const _2 = /* @__PURE__ */ new WeakMap();
    let g2 = false;
    try {
      g2 = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d");
    } catch (e3) {
    }
    function v2(e3, t3) {
      return g2 ? new OffscreenCanvas(e3, t3) : Jn("canvas");
    }
    function y2(e3, t3, n3, r3) {
      let i3 = 1;
      if ((e3.width > r3 || e3.height > r3) && (i3 = r3 / Math.max(e3.width, e3.height)), i3 < 1 || true === t3) {
        if ("undefined" != typeof HTMLImageElement && e3 instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e3 instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e3 instanceof ImageBitmap) {
          const r4 = t3 ? zn : Math.floor, s3 = r4(i3 * e3.width), o3 = r4(i3 * e3.height);
          void 0 === m2 && (m2 = v2(s3, o3));
          const a3 = n3 ? v2(s3, o3) : m2;
          return a3.width = s3, a3.height = o3, a3.getContext("2d").drawImage(e3, 0, 0, s3, o3), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e3.width + "x" + e3.height + ") to (" + s3 + "x" + o3 + ")."), a3;
        }
        return "data" in e3 && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e3.width + "x" + e3.height + ")."), e3;
      }
      return e3;
    }
    function b2(e3) {
      return Nn(e3.width) && Nn(e3.height);
    }
    function w2(e3, t3) {
      return e3.generateMipmaps && t3 && e3.minFilter !== de && e3.minFilter !== ge;
    }
    function A2(t3) {
      e2.generateMipmap(t3);
    }
    function x2(n3, r3, i3, s3, o3 = false) {
      if (false === a2)
        return r3;
      if (null !== n3) {
        if (void 0 !== e2[n3])
          return e2[n3];
        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n3 + "'");
      }
      let l3 = r3;
      return r3 === e2.RED && (i3 === e2.FLOAT && (l3 = e2.R32F), i3 === e2.HALF_FLOAT && (l3 = e2.R16F), i3 === e2.UNSIGNED_BYTE && (l3 = e2.R8)), r3 === e2.RG && (i3 === e2.FLOAT && (l3 = e2.RG32F), i3 === e2.HALF_FLOAT && (l3 = e2.RG16F), i3 === e2.UNSIGNED_BYTE && (l3 = e2.RG8)), r3 === e2.RGBA && (i3 === e2.FLOAT && (l3 = e2.RGBA32F), i3 === e2.HALF_FLOAT && (l3 = e2.RGBA16F), i3 === e2.UNSIGNED_BYTE && (l3 = s3 === zt && false === o3 ? e2.SRGB8_ALPHA8 : e2.RGBA8), i3 === e2.UNSIGNED_SHORT_4_4_4_4 && (l3 = e2.RGBA4), i3 === e2.UNSIGNED_SHORT_5_5_5_1 && (l3 = e2.RGB5_A1)), l3 !== e2.R16F && l3 !== e2.R32F && l3 !== e2.RG16F && l3 !== e2.RG32F && l3 !== e2.RGBA16F && l3 !== e2.RGBA32F || t2.get("EXT_color_buffer_float"), l3;
    }
    function E2(e3, t3, n3) {
      return true === w2(e3, n3) || e3.isFramebufferTexture && e3.minFilter !== de && e3.minFilter !== ge ? Math.log2(Math.max(t3.width, t3.height)) + 1 : void 0 !== e3.mipmaps && e3.mipmaps.length > 0 ? e3.mipmaps.length : e3.isCompressedTexture && Array.isArray(e3.image) ? t3.mipmaps.length : 1;
    }
    function C2(t3) {
      return t3 === de || t3 === he || t3 === me ? e2.NEAREST : e2.LINEAR;
    }
    function S2(e3) {
      const t3 = e3.target;
      t3.removeEventListener("dispose", S2), function(e4) {
        const t4 = r2.get(e4);
        if (void 0 === t4.__webglInit)
          return;
        const n3 = e4.source, i3 = _2.get(n3);
        if (i3) {
          const r3 = i3[t4.__cacheKey];
          r3.usedTimes--, 0 === r3.usedTimes && T2(e4), 0 === Object.keys(i3).length && _2.delete(n3);
        }
        r2.remove(e4);
      }(t3), t3.isVideoTexture && f2.delete(t3);
    }
    function M2(t3) {
      const n3 = t3.target;
      n3.removeEventListener("dispose", M2), function(t4) {
        const n4 = t4.texture, i3 = r2.get(t4), s3 = r2.get(n4);
        if (void 0 !== s3.__webglTexture && (e2.deleteTexture(s3.__webglTexture), o2.memory.textures--), t4.depthTexture && t4.depthTexture.dispose(), t4.isWebGLCubeRenderTarget)
          for (let t5 = 0; t5 < 6; t5++)
            e2.deleteFramebuffer(i3.__webglFramebuffer[t5]), i3.__webglDepthbuffer && e2.deleteRenderbuffer(i3.__webglDepthbuffer[t5]);
        else {
          if (e2.deleteFramebuffer(i3.__webglFramebuffer), i3.__webglDepthbuffer && e2.deleteRenderbuffer(i3.__webglDepthbuffer), i3.__webglMultisampledFramebuffer && e2.deleteFramebuffer(i3.__webglMultisampledFramebuffer), i3.__webglColorRenderbuffer)
            for (let t5 = 0; t5 < i3.__webglColorRenderbuffer.length; t5++)
              i3.__webglColorRenderbuffer[t5] && e2.deleteRenderbuffer(i3.__webglColorRenderbuffer[t5]);
          i3.__webglDepthRenderbuffer && e2.deleteRenderbuffer(i3.__webglDepthRenderbuffer);
        }
        if (t4.isWebGLMultipleRenderTargets)
          for (let t5 = 0, i4 = n4.length; t5 < i4; t5++) {
            const i5 = r2.get(n4[t5]);
            i5.__webglTexture && (e2.deleteTexture(i5.__webglTexture), o2.memory.textures--), r2.remove(n4[t5]);
          }
        r2.remove(n4), r2.remove(t4);
      }(n3);
    }
    function T2(t3) {
      const n3 = r2.get(t3);
      e2.deleteTexture(n3.__webglTexture);
      const i3 = t3.source;
      delete _2.get(i3)[n3.__cacheKey], o2.memory.textures--;
    }
    let P2 = 0;
    function I2(t3, i3) {
      const s3 = r2.get(t3);
      if (t3.isVideoTexture && function(e3) {
        const t4 = o2.render.frame;
        f2.get(e3) !== t4 && (f2.set(e3, t4), e3.update());
      }(t3), false === t3.isRenderTargetTexture && t3.version > 0 && s3.__version !== t3.version) {
        const e3 = t3.image;
        if (null === e3)
          console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
        else {
          if (false !== e3.complete)
            return void L2(s3, t3, i3);
          console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
        }
      }
      n2.bindTexture(e2.TEXTURE_2D, s3.__webglTexture, e2.TEXTURE0 + i3);
    }
    const R2 = { [ce]: e2.REPEAT, [ue]: e2.CLAMP_TO_EDGE, [pe]: e2.MIRRORED_REPEAT }, k2 = { [de]: e2.NEAREST, [he]: e2.NEAREST_MIPMAP_NEAREST, [me]: e2.NEAREST_MIPMAP_LINEAR, [ge]: e2.LINEAR, [ve]: e2.LINEAR_MIPMAP_NEAREST, [be]: e2.LINEAR_MIPMAP_LINEAR }, D2 = { [ln]: e2.NEVER, [mn]: e2.ALWAYS, [cn]: e2.LESS, [pn]: e2.LEQUAL, [un]: e2.EQUAL, [fn]: e2.GEQUAL, [dn]: e2.GREATER, [hn]: e2.NOTEQUAL };
    function B2(n3, s3, o3) {
      if (o3 ? (e2.texParameteri(n3, e2.TEXTURE_WRAP_S, R2[s3.wrapS]), e2.texParameteri(n3, e2.TEXTURE_WRAP_T, R2[s3.wrapT]), n3 !== e2.TEXTURE_3D && n3 !== e2.TEXTURE_2D_ARRAY || e2.texParameteri(n3, e2.TEXTURE_WRAP_R, R2[s3.wrapR]), e2.texParameteri(n3, e2.TEXTURE_MAG_FILTER, k2[s3.magFilter]), e2.texParameteri(n3, e2.TEXTURE_MIN_FILTER, k2[s3.minFilter])) : (e2.texParameteri(n3, e2.TEXTURE_WRAP_S, e2.CLAMP_TO_EDGE), e2.texParameteri(n3, e2.TEXTURE_WRAP_T, e2.CLAMP_TO_EDGE), n3 !== e2.TEXTURE_3D && n3 !== e2.TEXTURE_2D_ARRAY || e2.texParameteri(n3, e2.TEXTURE_WRAP_R, e2.CLAMP_TO_EDGE), s3.wrapS === ue && s3.wrapT === ue || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e2.texParameteri(n3, e2.TEXTURE_MAG_FILTER, C2(s3.magFilter)), e2.texParameteri(n3, e2.TEXTURE_MIN_FILTER, C2(s3.minFilter)), s3.minFilter !== de && s3.minFilter !== ge && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), s3.compareFunction && (e2.texParameteri(n3, e2.TEXTURE_COMPARE_MODE, e2.COMPARE_REF_TO_TEXTURE), e2.texParameteri(n3, e2.TEXTURE_COMPARE_FUNC, D2[s3.compareFunction])), true === t2.has("EXT_texture_filter_anisotropic")) {
        const o4 = t2.get("EXT_texture_filter_anisotropic");
        if (s3.magFilter === de)
          return;
        if (s3.minFilter !== me && s3.minFilter !== be)
          return;
        if (s3.type === Te && false === t2.has("OES_texture_float_linear"))
          return;
        if (false === a2 && s3.type === Pe && false === t2.has("OES_texture_half_float_linear"))
          return;
        (s3.anisotropy > 1 || r2.get(s3).__currentAnisotropy) && (e2.texParameterf(n3, o4.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s3.anisotropy, i2.getMaxAnisotropy())), r2.get(s3).__currentAnisotropy = s3.anisotropy);
      }
    }
    function O2(t3, n3) {
      let r3 = false;
      void 0 === t3.__webglInit && (t3.__webglInit = true, n3.addEventListener("dispose", S2));
      const i3 = n3.source;
      let s3 = _2.get(i3);
      void 0 === s3 && (s3 = {}, _2.set(i3, s3));
      const a3 = function(e3) {
        const t4 = [];
        return t4.push(e3.wrapS), t4.push(e3.wrapT), t4.push(e3.wrapR || 0), t4.push(e3.magFilter), t4.push(e3.minFilter), t4.push(e3.anisotropy), t4.push(e3.internalFormat), t4.push(e3.format), t4.push(e3.type), t4.push(e3.generateMipmaps), t4.push(e3.premultiplyAlpha), t4.push(e3.flipY), t4.push(e3.unpackAlignment), t4.push(e3.colorSpace), t4.join();
      }(n3);
      if (a3 !== t3.__cacheKey) {
        void 0 === s3[a3] && (s3[a3] = { texture: e2.createTexture(), usedTimes: 0 }, o2.memory.textures++, r3 = true), s3[a3].usedTimes++;
        const i4 = s3[t3.__cacheKey];
        void 0 !== i4 && (s3[t3.__cacheKey].usedTimes--, 0 === i4.usedTimes && T2(n3)), t3.__cacheKey = a3, t3.__webglTexture = s3[a3].texture;
      }
      return r3;
    }
    function L2(t3, i3, o3) {
      let l3 = e2.TEXTURE_2D;
      (i3.isDataArrayTexture || i3.isCompressedArrayTexture) && (l3 = e2.TEXTURE_2D_ARRAY), i3.isData3DTexture && (l3 = e2.TEXTURE_3D);
      const c3 = O2(t3, i3), p3 = i3.source;
      n2.bindTexture(l3, t3.__webglTexture, e2.TEXTURE0 + o3);
      const d3 = r2.get(p3);
      if (p3.version !== d3.__version || true === c3) {
        n2.activeTexture(e2.TEXTURE0 + o3), e2.pixelStorei(e2.UNPACK_FLIP_Y_WEBGL, i3.flipY), e2.pixelStorei(e2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i3.premultiplyAlpha), e2.pixelStorei(e2.UNPACK_ALIGNMENT, i3.unpackAlignment), e2.pixelStorei(e2.UNPACK_COLORSPACE_CONVERSION_WEBGL, e2.NONE);
        const t4 = function(e3) {
          return !a2 && (e3.wrapS !== ue || e3.wrapT !== ue || e3.minFilter !== de && e3.minFilter !== ge);
        }(i3) && false === b2(i3.image);
        let r3 = y2(i3.image, t4, false, u2);
        r3 = G2(i3, r3);
        const h3 = b2(r3) || a2, f3 = s2.convert(i3.format, i3.colorSpace);
        let m3, _3 = s2.convert(i3.type), g3 = x2(i3.internalFormat, f3, _3, i3.colorSpace);
        B2(l3, i3, h3);
        const v3 = i3.mipmaps, C3 = a2 && true !== i3.isVideoTexture, S3 = void 0 === d3.__version || true === c3, M3 = E2(i3, r3, h3);
        if (i3.isDepthTexture)
          g3 = e2.DEPTH_COMPONENT, a2 ? g3 = i3.type === Te ? e2.DEPTH_COMPONENT32F : i3.type === Me ? e2.DEPTH_COMPONENT24 : i3.type === ke ? e2.DEPTH24_STENCIL8 : e2.DEPTH_COMPONENT16 : i3.type === Te && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i3.format === Ue && g3 === e2.DEPTH_COMPONENT && i3.type !== Ce && i3.type !== Me && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i3.type = Me, _3 = s2.convert(i3.type)), i3.format === Fe && g3 === e2.DEPTH_COMPONENT && (g3 = e2.DEPTH_STENCIL, i3.type !== ke && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i3.type = ke, _3 = s2.convert(i3.type))), S3 && (C3 ? n2.texStorage2D(e2.TEXTURE_2D, 1, g3, r3.width, r3.height) : n2.texImage2D(e2.TEXTURE_2D, 0, g3, r3.width, r3.height, 0, f3, _3, null));
        else if (i3.isDataTexture)
          if (v3.length > 0 && h3) {
            C3 && S3 && n2.texStorage2D(e2.TEXTURE_2D, M3, g3, v3[0].width, v3[0].height);
            for (let t5 = 0, r4 = v3.length; t5 < r4; t5++)
              m3 = v3[t5], C3 ? n2.texSubImage2D(e2.TEXTURE_2D, t5, 0, 0, m3.width, m3.height, f3, _3, m3.data) : n2.texImage2D(e2.TEXTURE_2D, t5, g3, m3.width, m3.height, 0, f3, _3, m3.data);
            i3.generateMipmaps = false;
          } else
            C3 ? (S3 && n2.texStorage2D(e2.TEXTURE_2D, M3, g3, r3.width, r3.height), n2.texSubImage2D(e2.TEXTURE_2D, 0, 0, 0, r3.width, r3.height, f3, _3, r3.data)) : n2.texImage2D(e2.TEXTURE_2D, 0, g3, r3.width, r3.height, 0, f3, _3, r3.data);
        else if (i3.isCompressedTexture)
          if (i3.isCompressedArrayTexture) {
            C3 && S3 && n2.texStorage3D(e2.TEXTURE_2D_ARRAY, M3, g3, v3[0].width, v3[0].height, r3.depth);
            for (let t5 = 0, s3 = v3.length; t5 < s3; t5++)
              m3 = v3[t5], i3.format !== Be ? null !== f3 ? C3 ? n2.compressedTexSubImage3D(e2.TEXTURE_2D_ARRAY, t5, 0, 0, 0, m3.width, m3.height, r3.depth, f3, m3.data, 0, 0) : n2.compressedTexImage3D(e2.TEXTURE_2D_ARRAY, t5, g3, m3.width, m3.height, r3.depth, 0, m3.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : C3 ? n2.texSubImage3D(e2.TEXTURE_2D_ARRAY, t5, 0, 0, 0, m3.width, m3.height, r3.depth, f3, _3, m3.data) : n2.texImage3D(e2.TEXTURE_2D_ARRAY, t5, g3, m3.width, m3.height, r3.depth, 0, f3, _3, m3.data);
          } else {
            C3 && S3 && n2.texStorage2D(e2.TEXTURE_2D, M3, g3, v3[0].width, v3[0].height);
            for (let t5 = 0, r4 = v3.length; t5 < r4; t5++)
              m3 = v3[t5], i3.format !== Be ? null !== f3 ? C3 ? n2.compressedTexSubImage2D(e2.TEXTURE_2D, t5, 0, 0, m3.width, m3.height, f3, m3.data) : n2.compressedTexImage2D(e2.TEXTURE_2D, t5, g3, m3.width, m3.height, 0, m3.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : C3 ? n2.texSubImage2D(e2.TEXTURE_2D, t5, 0, 0, m3.width, m3.height, f3, _3, m3.data) : n2.texImage2D(e2.TEXTURE_2D, t5, g3, m3.width, m3.height, 0, f3, _3, m3.data);
          }
        else if (i3.isDataArrayTexture)
          C3 ? (S3 && n2.texStorage3D(e2.TEXTURE_2D_ARRAY, M3, g3, r3.width, r3.height, r3.depth), n2.texSubImage3D(e2.TEXTURE_2D_ARRAY, 0, 0, 0, 0, r3.width, r3.height, r3.depth, f3, _3, r3.data)) : n2.texImage3D(e2.TEXTURE_2D_ARRAY, 0, g3, r3.width, r3.height, r3.depth, 0, f3, _3, r3.data);
        else if (i3.isData3DTexture)
          C3 ? (S3 && n2.texStorage3D(e2.TEXTURE_3D, M3, g3, r3.width, r3.height, r3.depth), n2.texSubImage3D(e2.TEXTURE_3D, 0, 0, 0, 0, r3.width, r3.height, r3.depth, f3, _3, r3.data)) : n2.texImage3D(e2.TEXTURE_3D, 0, g3, r3.width, r3.height, r3.depth, 0, f3, _3, r3.data);
        else if (i3.isFramebufferTexture) {
          if (S3)
            if (C3)
              n2.texStorage2D(e2.TEXTURE_2D, M3, g3, r3.width, r3.height);
            else {
              let t5 = r3.width, i4 = r3.height;
              for (let r4 = 0; r4 < M3; r4++)
                n2.texImage2D(e2.TEXTURE_2D, r4, g3, t5, i4, 0, f3, _3, null), t5 >>= 1, i4 >>= 1;
            }
        } else if (v3.length > 0 && h3) {
          C3 && S3 && n2.texStorage2D(e2.TEXTURE_2D, M3, g3, v3[0].width, v3[0].height);
          for (let t5 = 0, r4 = v3.length; t5 < r4; t5++)
            m3 = v3[t5], C3 ? n2.texSubImage2D(e2.TEXTURE_2D, t5, 0, 0, f3, _3, m3) : n2.texImage2D(e2.TEXTURE_2D, t5, g3, f3, _3, m3);
          i3.generateMipmaps = false;
        } else
          C3 ? (S3 && n2.texStorage2D(e2.TEXTURE_2D, M3, g3, r3.width, r3.height), n2.texSubImage2D(e2.TEXTURE_2D, 0, 0, 0, f3, _3, r3)) : n2.texImage2D(e2.TEXTURE_2D, 0, g3, f3, _3, r3);
        w2(i3, h3) && A2(l3), d3.__version = p3.version, i3.onUpdate && i3.onUpdate(i3);
      }
      t3.__version = i3.version;
    }
    function U2(t3, i3, o3, a3, l3) {
      const c3 = s2.convert(o3.format, o3.colorSpace), u3 = s2.convert(o3.type), p3 = x2(o3.internalFormat, c3, u3, o3.colorSpace);
      r2.get(i3).__hasExternalTextures || (l3 === e2.TEXTURE_3D || l3 === e2.TEXTURE_2D_ARRAY ? n2.texImage3D(l3, 0, p3, i3.width, i3.height, i3.depth, 0, c3, u3, null) : n2.texImage2D(l3, 0, p3, i3.width, i3.height, 0, c3, u3, null)), n2.bindFramebuffer(e2.FRAMEBUFFER, t3), z2(i3) ? d2.framebufferTexture2DMultisampleEXT(e2.FRAMEBUFFER, a3, l3, r2.get(o3).__webglTexture, 0, j2(i3)) : (l3 === e2.TEXTURE_2D || l3 >= e2.TEXTURE_CUBE_MAP_POSITIVE_X && l3 <= e2.TEXTURE_CUBE_MAP_NEGATIVE_Z) && e2.framebufferTexture2D(e2.FRAMEBUFFER, a3, l3, r2.get(o3).__webglTexture, 0), n2.bindFramebuffer(e2.FRAMEBUFFER, null);
    }
    function F2(t3, n3, r3) {
      if (e2.bindRenderbuffer(e2.RENDERBUFFER, t3), n3.depthBuffer && !n3.stencilBuffer) {
        let i3 = e2.DEPTH_COMPONENT16;
        if (r3 || z2(n3)) {
          const t4 = n3.depthTexture;
          t4 && t4.isDepthTexture && (t4.type === Te ? i3 = e2.DEPTH_COMPONENT32F : t4.type === Me && (i3 = e2.DEPTH_COMPONENT24));
          const r4 = j2(n3);
          z2(n3) ? d2.renderbufferStorageMultisampleEXT(e2.RENDERBUFFER, r4, i3, n3.width, n3.height) : e2.renderbufferStorageMultisample(e2.RENDERBUFFER, r4, i3, n3.width, n3.height);
        } else
          e2.renderbufferStorage(e2.RENDERBUFFER, i3, n3.width, n3.height);
        e2.framebufferRenderbuffer(e2.FRAMEBUFFER, e2.DEPTH_ATTACHMENT, e2.RENDERBUFFER, t3);
      } else if (n3.depthBuffer && n3.stencilBuffer) {
        const i3 = j2(n3);
        r3 && false === z2(n3) ? e2.renderbufferStorageMultisample(e2.RENDERBUFFER, i3, e2.DEPTH24_STENCIL8, n3.width, n3.height) : z2(n3) ? d2.renderbufferStorageMultisampleEXT(e2.RENDERBUFFER, i3, e2.DEPTH24_STENCIL8, n3.width, n3.height) : e2.renderbufferStorage(e2.RENDERBUFFER, e2.DEPTH_STENCIL, n3.width, n3.height), e2.framebufferRenderbuffer(e2.FRAMEBUFFER, e2.DEPTH_STENCIL_ATTACHMENT, e2.RENDERBUFFER, t3);
      } else {
        const t4 = true === n3.isWebGLMultipleRenderTargets ? n3.texture : [n3.texture];
        for (let i3 = 0; i3 < t4.length; i3++) {
          const o3 = t4[i3], a3 = s2.convert(o3.format, o3.colorSpace), l3 = s2.convert(o3.type), c3 = x2(o3.internalFormat, a3, l3, o3.colorSpace), u3 = j2(n3);
          r3 && false === z2(n3) ? e2.renderbufferStorageMultisample(e2.RENDERBUFFER, u3, c3, n3.width, n3.height) : z2(n3) ? d2.renderbufferStorageMultisampleEXT(e2.RENDERBUFFER, u3, c3, n3.width, n3.height) : e2.renderbufferStorage(e2.RENDERBUFFER, c3, n3.width, n3.height);
        }
      }
      e2.bindRenderbuffer(e2.RENDERBUFFER, null);
    }
    function N2(t3) {
      const i3 = r2.get(t3), s3 = true === t3.isWebGLCubeRenderTarget;
      if (t3.depthTexture && !i3.__autoAllocateDepthBuffer) {
        if (s3)
          throw new Error("target.depthTexture not supported in Cube render targets");
        !function(t4, i4) {
          if (i4 && i4.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
          if (n2.bindFramebuffer(e2.FRAMEBUFFER, t4), !i4.depthTexture || !i4.depthTexture.isDepthTexture)
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
          r2.get(i4.depthTexture).__webglTexture && i4.depthTexture.image.width === i4.width && i4.depthTexture.image.height === i4.height || (i4.depthTexture.image.width = i4.width, i4.depthTexture.image.height = i4.height, i4.depthTexture.needsUpdate = true), I2(i4.depthTexture, 0);
          const s4 = r2.get(i4.depthTexture).__webglTexture, o3 = j2(i4);
          if (i4.depthTexture.format === Ue)
            z2(i4) ? d2.framebufferTexture2DMultisampleEXT(e2.FRAMEBUFFER, e2.DEPTH_ATTACHMENT, e2.TEXTURE_2D, s4, 0, o3) : e2.framebufferTexture2D(e2.FRAMEBUFFER, e2.DEPTH_ATTACHMENT, e2.TEXTURE_2D, s4, 0);
          else {
            if (i4.depthTexture.format !== Fe)
              throw new Error("Unknown depthTexture format");
            z2(i4) ? d2.framebufferTexture2DMultisampleEXT(e2.FRAMEBUFFER, e2.DEPTH_STENCIL_ATTACHMENT, e2.TEXTURE_2D, s4, 0, o3) : e2.framebufferTexture2D(e2.FRAMEBUFFER, e2.DEPTH_STENCIL_ATTACHMENT, e2.TEXTURE_2D, s4, 0);
          }
        }(i3.__webglFramebuffer, t3);
      } else if (s3) {
        i3.__webglDepthbuffer = [];
        for (let r3 = 0; r3 < 6; r3++)
          n2.bindFramebuffer(e2.FRAMEBUFFER, i3.__webglFramebuffer[r3]), i3.__webglDepthbuffer[r3] = e2.createRenderbuffer(), F2(i3.__webglDepthbuffer[r3], t3, false);
      } else
        n2.bindFramebuffer(e2.FRAMEBUFFER, i3.__webglFramebuffer), i3.__webglDepthbuffer = e2.createRenderbuffer(), F2(i3.__webglDepthbuffer, t3, false);
      n2.bindFramebuffer(e2.FRAMEBUFFER, null);
    }
    function j2(e3) {
      return Math.min(p2, e3.samples);
    }
    function z2(e3) {
      const n3 = r2.get(e3);
      return a2 && e3.samples > 0 && true === t2.has("WEBGL_multisampled_render_to_texture") && false !== n3.__useRenderToTexture;
    }
    function G2(e3, n3) {
      const r3 = e3.colorSpace, i3 = e3.format, s3 = e3.type;
      return true === e3.isCompressedTexture || e3.format === Mn || r3 !== Gt && r3 !== jt && (r3 === zt ? false === a2 ? true === t2.has("EXT_sRGB") && i3 === Be ? (e3.format = Mn, e3.minFilter = ge, e3.generateMipmaps = false) : n3 = lr.sRGBToLinear(n3) : i3 === Be && s3 === Ae || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : r3 === Ht || console.error("THREE.WebGLTextures: Unsupported texture color space:", r3)), n3;
    }
    this.allocateTextureUnit = function() {
      const e3 = P2;
      return e3 >= l2 && console.warn("THREE.WebGLTextures: Trying to use " + e3 + " texture units while this GPU supports only " + l2), P2 += 1, e3;
    }, this.resetTextureUnits = function() {
      P2 = 0;
    }, this.setTexture2D = I2, this.setTexture2DArray = function(t3, i3) {
      const s3 = r2.get(t3);
      t3.version > 0 && s3.__version !== t3.version ? L2(s3, t3, i3) : n2.bindTexture(e2.TEXTURE_2D_ARRAY, s3.__webglTexture, e2.TEXTURE0 + i3);
    }, this.setTexture3D = function(t3, i3) {
      const s3 = r2.get(t3);
      t3.version > 0 && s3.__version !== t3.version ? L2(s3, t3, i3) : n2.bindTexture(e2.TEXTURE_3D, s3.__webglTexture, e2.TEXTURE0 + i3);
    }, this.setTextureCube = function(t3, i3) {
      const o3 = r2.get(t3);
      t3.version > 0 && o3.__version !== t3.version ? function(t4, i4, o4) {
        if (6 !== i4.image.length)
          return;
        const l3 = O2(t4, i4), u3 = i4.source;
        n2.bindTexture(e2.TEXTURE_CUBE_MAP, t4.__webglTexture, e2.TEXTURE0 + o4);
        const p3 = r2.get(u3);
        if (u3.version !== p3.__version || true === l3) {
          n2.activeTexture(e2.TEXTURE0 + o4), e2.pixelStorei(e2.UNPACK_FLIP_Y_WEBGL, i4.flipY), e2.pixelStorei(e2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i4.premultiplyAlpha), e2.pixelStorei(e2.UNPACK_ALIGNMENT, i4.unpackAlignment), e2.pixelStorei(e2.UNPACK_COLORSPACE_CONVERSION_WEBGL, e2.NONE);
          const t5 = i4.isCompressedTexture || i4.image[0].isCompressedTexture, r3 = i4.image[0] && i4.image[0].isDataTexture, d3 = [];
          for (let e3 = 0; e3 < 6; e3++)
            d3[e3] = t5 || r3 ? r3 ? i4.image[e3].image : i4.image[e3] : y2(i4.image[e3], false, true, c2), d3[e3] = G2(i4, d3[e3]);
          const h3 = d3[0], f3 = b2(h3) || a2, m3 = s2.convert(i4.format, i4.colorSpace), _3 = s2.convert(i4.type), g3 = x2(i4.internalFormat, m3, _3, i4.colorSpace), v3 = a2 && true !== i4.isVideoTexture, C3 = void 0 === p3.__version || true === l3;
          let S3, M3 = E2(i4, h3, f3);
          if (B2(e2.TEXTURE_CUBE_MAP, i4, f3), t5) {
            v3 && C3 && n2.texStorage2D(e2.TEXTURE_CUBE_MAP, M3, g3, h3.width, h3.height);
            for (let t6 = 0; t6 < 6; t6++) {
              S3 = d3[t6].mipmaps;
              for (let r4 = 0; r4 < S3.length; r4++) {
                const s3 = S3[r4];
                i4.format !== Be ? null !== m3 ? v3 ? n2.compressedTexSubImage2D(e2.TEXTURE_CUBE_MAP_POSITIVE_X + t6, r4, 0, 0, s3.width, s3.height, m3, s3.data) : n2.compressedTexImage2D(e2.TEXTURE_CUBE_MAP_POSITIVE_X + t6, r4, g3, s3.width, s3.height, 0, s3.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : v3 ? n2.texSubImage2D(e2.TEXTURE_CUBE_MAP_POSITIVE_X + t6, r4, 0, 0, s3.width, s3.height, m3, _3, s3.data) : n2.texImage2D(e2.TEXTURE_CUBE_MAP_POSITIVE_X + t6, r4, g3, s3.width, s3.height, 0, m3, _3, s3.data);
              }
            }
          } else {
            S3 = i4.mipmaps, v3 && C3 && (S3.length > 0 && M3++, n2.texStorage2D(e2.TEXTURE_CUBE_MAP, M3, g3, d3[0].width, d3[0].height));
            for (let t6 = 0; t6 < 6; t6++)
              if (r3) {
                v3 ? n2.texSubImage2D(e2.TEXTURE_CUBE_MAP_POSITIVE_X + t6, 0, 0, 0, d3[t6].width, d3[t6].height, m3, _3, d3[t6].data) : n2.texImage2D(e2.TEXTURE_CUBE_MAP_POSITIVE_X + t6, 0, g3, d3[t6].width, d3[t6].height, 0, m3, _3, d3[t6].data);
                for (let r4 = 0; r4 < S3.length; r4++) {
                  const i5 = S3[r4].image[t6].image;
                  v3 ? n2.texSubImage2D(e2.TEXTURE_CUBE_MAP_POSITIVE_X + t6, r4 + 1, 0, 0, i5.width, i5.height, m3, _3, i5.data) : n2.texImage2D(e2.TEXTURE_CUBE_MAP_POSITIVE_X + t6, r4 + 1, g3, i5.width, i5.height, 0, m3, _3, i5.data);
                }
              } else {
                v3 ? n2.texSubImage2D(e2.TEXTURE_CUBE_MAP_POSITIVE_X + t6, 0, 0, 0, m3, _3, d3[t6]) : n2.texImage2D(e2.TEXTURE_CUBE_MAP_POSITIVE_X + t6, 0, g3, m3, _3, d3[t6]);
                for (let r4 = 0; r4 < S3.length; r4++) {
                  const i5 = S3[r4];
                  v3 ? n2.texSubImage2D(e2.TEXTURE_CUBE_MAP_POSITIVE_X + t6, r4 + 1, 0, 0, m3, _3, i5.image[t6]) : n2.texImage2D(e2.TEXTURE_CUBE_MAP_POSITIVE_X + t6, r4 + 1, g3, m3, _3, i5.image[t6]);
                }
              }
          }
          w2(i4, f3) && A2(e2.TEXTURE_CUBE_MAP), p3.__version = u3.version, i4.onUpdate && i4.onUpdate(i4);
        }
        t4.__version = i4.version;
      }(o3, t3, i3) : n2.bindTexture(e2.TEXTURE_CUBE_MAP, o3.__webglTexture, e2.TEXTURE0 + i3);
    }, this.rebindTextures = function(t3, n3, i3) {
      const s3 = r2.get(t3);
      void 0 !== n3 && U2(s3.__webglFramebuffer, t3, t3.texture, e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D), void 0 !== i3 && N2(t3);
    }, this.setupRenderTarget = function(t3) {
      const l3 = t3.texture, c3 = r2.get(t3), u3 = r2.get(l3);
      t3.addEventListener("dispose", M2), true !== t3.isWebGLMultipleRenderTargets && (void 0 === u3.__webglTexture && (u3.__webglTexture = e2.createTexture()), u3.__version = l3.version, o2.memory.textures++);
      const p3 = true === t3.isWebGLCubeRenderTarget, d3 = true === t3.isWebGLMultipleRenderTargets, h3 = b2(t3) || a2;
      if (p3) {
        c3.__webglFramebuffer = [];
        for (let t4 = 0; t4 < 6; t4++)
          c3.__webglFramebuffer[t4] = e2.createFramebuffer();
      } else {
        if (c3.__webglFramebuffer = e2.createFramebuffer(), d3)
          if (i2.drawBuffers) {
            const n3 = t3.texture;
            for (let t4 = 0, i3 = n3.length; t4 < i3; t4++) {
              const i4 = r2.get(n3[t4]);
              void 0 === i4.__webglTexture && (i4.__webglTexture = e2.createTexture(), o2.memory.textures++);
            }
          } else
            console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
        if (a2 && t3.samples > 0 && false === z2(t3)) {
          const r3 = d3 ? l3 : [l3];
          c3.__webglMultisampledFramebuffer = e2.createFramebuffer(), c3.__webglColorRenderbuffer = [], n2.bindFramebuffer(e2.FRAMEBUFFER, c3.__webglMultisampledFramebuffer);
          for (let n3 = 0; n3 < r3.length; n3++) {
            const i3 = r3[n3];
            c3.__webglColorRenderbuffer[n3] = e2.createRenderbuffer(), e2.bindRenderbuffer(e2.RENDERBUFFER, c3.__webglColorRenderbuffer[n3]);
            const o3 = s2.convert(i3.format, i3.colorSpace), a3 = s2.convert(i3.type), l4 = x2(i3.internalFormat, o3, a3, i3.colorSpace, true === t3.isXRRenderTarget), u4 = j2(t3);
            e2.renderbufferStorageMultisample(e2.RENDERBUFFER, u4, l4, t3.width, t3.height), e2.framebufferRenderbuffer(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0 + n3, e2.RENDERBUFFER, c3.__webglColorRenderbuffer[n3]);
          }
          e2.bindRenderbuffer(e2.RENDERBUFFER, null), t3.depthBuffer && (c3.__webglDepthRenderbuffer = e2.createRenderbuffer(), F2(c3.__webglDepthRenderbuffer, t3, true)), n2.bindFramebuffer(e2.FRAMEBUFFER, null);
        }
      }
      if (p3) {
        n2.bindTexture(e2.TEXTURE_CUBE_MAP, u3.__webglTexture), B2(e2.TEXTURE_CUBE_MAP, l3, h3);
        for (let n3 = 0; n3 < 6; n3++)
          U2(c3.__webglFramebuffer[n3], t3, l3, e2.COLOR_ATTACHMENT0, e2.TEXTURE_CUBE_MAP_POSITIVE_X + n3);
        w2(l3, h3) && A2(e2.TEXTURE_CUBE_MAP), n2.unbindTexture();
      } else if (d3) {
        const i3 = t3.texture;
        for (let s3 = 0, o3 = i3.length; s3 < o3; s3++) {
          const o4 = i3[s3], a3 = r2.get(o4);
          n2.bindTexture(e2.TEXTURE_2D, a3.__webglTexture), B2(e2.TEXTURE_2D, o4, h3), U2(c3.__webglFramebuffer, t3, o4, e2.COLOR_ATTACHMENT0 + s3, e2.TEXTURE_2D), w2(o4, h3) && A2(e2.TEXTURE_2D);
        }
        n2.unbindTexture();
      } else {
        let r3 = e2.TEXTURE_2D;
        (t3.isWebGL3DRenderTarget || t3.isWebGLArrayRenderTarget) && (a2 ? r3 = t3.isWebGL3DRenderTarget ? e2.TEXTURE_3D : e2.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), n2.bindTexture(r3, u3.__webglTexture), B2(r3, l3, h3), U2(c3.__webglFramebuffer, t3, l3, e2.COLOR_ATTACHMENT0, r3), w2(l3, h3) && A2(r3), n2.unbindTexture();
      }
      t3.depthBuffer && N2(t3);
    }, this.updateRenderTargetMipmap = function(t3) {
      const i3 = b2(t3) || a2, s3 = true === t3.isWebGLMultipleRenderTargets ? t3.texture : [t3.texture], o3 = t3.isWebGLCubeRenderTarget ? e2.TEXTURE_CUBE_MAP : e2.TEXTURE_2D;
      for (let e3 = 0, t4 = s3.length; e3 < t4; e3++) {
        const t5 = s3[e3], a3 = r2.get(t5), l3 = a3.__webglTexture;
        a3.__version !== t5.version && (n2.bindTexture(o3, l3), B2(o3, t5, i3), n2.unbindTexture(), a3.__version = t5.version), w2(t5, i3) && (n2.bindTexture(o3, l3), A2(o3), n2.unbindTexture());
      }
    }, this.updateMultisampleRenderTarget = function(t3) {
      if (a2 && t3.samples > 0 && false === z2(t3)) {
        const i3 = t3.isWebGLMultipleRenderTargets ? t3.texture : [t3.texture], s3 = t3.width, o3 = t3.height;
        let a3 = e2.COLOR_BUFFER_BIT;
        const l3 = [], c3 = t3.stencilBuffer ? e2.DEPTH_STENCIL_ATTACHMENT : e2.DEPTH_ATTACHMENT, u3 = r2.get(t3), p3 = true === t3.isWebGLMultipleRenderTargets;
        if (p3)
          for (let t4 = 0; t4 < i3.length; t4++)
            n2.bindFramebuffer(e2.FRAMEBUFFER, u3.__webglMultisampledFramebuffer), e2.framebufferRenderbuffer(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0 + t4, e2.RENDERBUFFER, null), n2.bindFramebuffer(e2.FRAMEBUFFER, u3.__webglFramebuffer), e2.framebufferTexture2D(e2.DRAW_FRAMEBUFFER, e2.COLOR_ATTACHMENT0 + t4, e2.TEXTURE_2D, null, 0);
        n2.bindFramebuffer(e2.READ_FRAMEBUFFER, u3.__webglMultisampledFramebuffer), n2.bindFramebuffer(e2.DRAW_FRAMEBUFFER, u3.__webglFramebuffer);
        for (let n3 = 0; n3 < i3.length; n3++) {
          l3.push(e2.COLOR_ATTACHMENT0 + n3), t3.depthBuffer && l3.push(c3);
          const d3 = void 0 !== u3.__ignoreDepthValues && u3.__ignoreDepthValues;
          if (false === d3 && (t3.depthBuffer && (a3 |= e2.DEPTH_BUFFER_BIT), t3.stencilBuffer && (a3 |= e2.STENCIL_BUFFER_BIT)), p3 && e2.framebufferRenderbuffer(e2.READ_FRAMEBUFFER, e2.COLOR_ATTACHMENT0, e2.RENDERBUFFER, u3.__webglColorRenderbuffer[n3]), true === d3 && (e2.invalidateFramebuffer(e2.READ_FRAMEBUFFER, [c3]), e2.invalidateFramebuffer(e2.DRAW_FRAMEBUFFER, [c3])), p3) {
            const t4 = r2.get(i3[n3]).__webglTexture;
            e2.framebufferTexture2D(e2.DRAW_FRAMEBUFFER, e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, t4, 0);
          }
          e2.blitFramebuffer(0, 0, s3, o3, 0, 0, s3, o3, a3, e2.NEAREST), h2 && e2.invalidateFramebuffer(e2.READ_FRAMEBUFFER, l3);
        }
        if (n2.bindFramebuffer(e2.READ_FRAMEBUFFER, null), n2.bindFramebuffer(e2.DRAW_FRAMEBUFFER, null), p3)
          for (let t4 = 0; t4 < i3.length; t4++) {
            n2.bindFramebuffer(e2.FRAMEBUFFER, u3.__webglMultisampledFramebuffer), e2.framebufferRenderbuffer(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0 + t4, e2.RENDERBUFFER, u3.__webglColorRenderbuffer[t4]);
            const s4 = r2.get(i3[t4]).__webglTexture;
            n2.bindFramebuffer(e2.FRAMEBUFFER, u3.__webglFramebuffer), e2.framebufferTexture2D(e2.DRAW_FRAMEBUFFER, e2.COLOR_ATTACHMENT0 + t4, e2.TEXTURE_2D, s4, 0);
          }
        n2.bindFramebuffer(e2.DRAW_FRAMEBUFFER, u3.__webglMultisampledFramebuffer);
      }
    }, this.setupDepthRenderbuffer = N2, this.setupFrameBufferTexture = U2, this.useMultisampledRTT = z2;
  }
  function Pl(e2, t2, n2) {
    const r2 = n2.isWebGL2;
    return { convert: function(n3, i2 = jt) {
      let s2;
      if (n3 === Ae)
        return e2.UNSIGNED_BYTE;
      if (n3 === Ie)
        return e2.UNSIGNED_SHORT_4_4_4_4;
      if (n3 === Re)
        return e2.UNSIGNED_SHORT_5_5_5_1;
      if (n3 === xe)
        return e2.BYTE;
      if (n3 === Ee)
        return e2.SHORT;
      if (n3 === Ce)
        return e2.UNSIGNED_SHORT;
      if (n3 === Se)
        return e2.INT;
      if (n3 === Me)
        return e2.UNSIGNED_INT;
      if (n3 === Te)
        return e2.FLOAT;
      if (n3 === Pe)
        return r2 ? e2.HALF_FLOAT : (s2 = t2.get("OES_texture_half_float"), null !== s2 ? s2.HALF_FLOAT_OES : null);
      if (n3 === De)
        return e2.ALPHA;
      if (n3 === Be)
        return e2.RGBA;
      if (n3 === Oe)
        return e2.LUMINANCE;
      if (n3 === Le)
        return e2.LUMINANCE_ALPHA;
      if (n3 === Ue)
        return e2.DEPTH_COMPONENT;
      if (n3 === Fe)
        return e2.DEPTH_STENCIL;
      if (n3 === Mn)
        return s2 = t2.get("EXT_sRGB"), null !== s2 ? s2.SRGB_ALPHA_EXT : null;
      if (n3 === Ne)
        return e2.RED;
      if (n3 === je)
        return e2.RED_INTEGER;
      if (n3 === ze)
        return e2.RG;
      if (n3 === Ge)
        return e2.RG_INTEGER;
      if (n3 === Ve)
        return e2.RGBA_INTEGER;
      if (n3 === He || n3 === Qe || n3 === We || n3 === qe)
        if (i2 === zt) {
          if (s2 = t2.get("WEBGL_compressed_texture_s3tc_srgb"), null === s2)
            return null;
          if (n3 === He)
            return s2.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (n3 === Qe)
            return s2.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (n3 === We)
            return s2.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (n3 === qe)
            return s2.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else {
          if (s2 = t2.get("WEBGL_compressed_texture_s3tc"), null === s2)
            return null;
          if (n3 === He)
            return s2.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (n3 === Qe)
            return s2.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (n3 === We)
            return s2.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (n3 === qe)
            return s2.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
      if (n3 === Xe || n3 === Ye || n3 === Ke || n3 === Je) {
        if (s2 = t2.get("WEBGL_compressed_texture_pvrtc"), null === s2)
          return null;
        if (n3 === Xe)
          return s2.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (n3 === Ye)
          return s2.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (n3 === Ke)
          return s2.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (n3 === Je)
          return s2.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      }
      if (n3 === Ze)
        return s2 = t2.get("WEBGL_compressed_texture_etc1"), null !== s2 ? s2.COMPRESSED_RGB_ETC1_WEBGL : null;
      if (n3 === $e || n3 === et) {
        if (s2 = t2.get("WEBGL_compressed_texture_etc"), null === s2)
          return null;
        if (n3 === $e)
          return i2 === zt ? s2.COMPRESSED_SRGB8_ETC2 : s2.COMPRESSED_RGB8_ETC2;
        if (n3 === et)
          return i2 === zt ? s2.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s2.COMPRESSED_RGBA8_ETC2_EAC;
      }
      if (n3 === tt || n3 === nt || n3 === rt || n3 === it || n3 === st || n3 === ot || n3 === at || n3 === lt || n3 === ct || n3 === ut || n3 === pt || n3 === dt || n3 === ht || n3 === ft) {
        if (s2 = t2.get("WEBGL_compressed_texture_astc"), null === s2)
          return null;
        if (n3 === tt)
          return i2 === zt ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s2.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (n3 === nt)
          return i2 === zt ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s2.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (n3 === rt)
          return i2 === zt ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s2.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (n3 === it)
          return i2 === zt ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s2.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (n3 === st)
          return i2 === zt ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s2.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (n3 === ot)
          return i2 === zt ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s2.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (n3 === at)
          return i2 === zt ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s2.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (n3 === lt)
          return i2 === zt ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s2.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (n3 === ct)
          return i2 === zt ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s2.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (n3 === ut)
          return i2 === zt ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s2.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (n3 === pt)
          return i2 === zt ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s2.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (n3 === dt)
          return i2 === zt ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s2.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (n3 === ht)
          return i2 === zt ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s2.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (n3 === ft)
          return i2 === zt ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s2.COMPRESSED_RGBA_ASTC_12x12_KHR;
      }
      if (n3 === mt) {
        if (s2 = t2.get("EXT_texture_compression_bptc"), null === s2)
          return null;
        if (n3 === mt)
          return i2 === zt ? s2.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s2.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      }
      if (n3 === _t || n3 === gt || n3 === vt || n3 === yt) {
        if (s2 = t2.get("EXT_texture_compression_rgtc"), null === s2)
          return null;
        if (n3 === mt)
          return s2.COMPRESSED_RED_RGTC1_EXT;
        if (n3 === gt)
          return s2.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (n3 === vt)
          return s2.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (n3 === yt)
          return s2.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      }
      return n3 === ke ? r2 ? e2.UNSIGNED_INT_24_8 : (s2 = t2.get("WEBGL_depth_texture"), null !== s2 ? s2.UNSIGNED_INT_24_8_WEBGL : null) : void 0 !== e2[n3] ? e2[n3] : null;
    } };
  }
  class Il extends Hs {
    constructor(e2 = []) {
      super(), this.isArrayCamera = true, this.cameras = e2;
    }
  }
  class Rl extends xi {
    constructor() {
      super(), this.isGroup = true, this.type = "Group";
    }
  }
  const kl = { type: "move" };
  class Dl {
    constructor() {
      this._targetRay = null, this._grip = null, this._hand = null;
    }
    getHandSpace() {
      return null === this._hand && (this._hand = new Rl(), this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = { pinching: false }), this._hand;
    }
    getTargetRaySpace() {
      return null === this._targetRay && (this._targetRay = new Rl(), this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new Ar(), this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new Ar()), this._targetRay;
    }
    getGripSpace() {
      return null === this._grip && (this._grip = new Rl(), this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new Ar(), this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new Ar()), this._grip;
    }
    dispatchEvent(e2) {
      return null !== this._targetRay && this._targetRay.dispatchEvent(e2), null !== this._grip && this._grip.dispatchEvent(e2), null !== this._hand && this._hand.dispatchEvent(e2), this;
    }
    connect(e2) {
      if (e2 && e2.hand) {
        const t2 = this._hand;
        if (t2)
          for (const n2 of e2.hand.values())
            this._getHandJoint(t2, n2);
      }
      return this.dispatchEvent({ type: "connected", data: e2 }), this;
    }
    disconnect(e2) {
      return this.dispatchEvent({ type: "disconnected", data: e2 }), null !== this._targetRay && (this._targetRay.visible = false), null !== this._grip && (this._grip.visible = false), null !== this._hand && (this._hand.visible = false), this;
    }
    update(e2, t2, n2) {
      let r2 = null, i2 = null, s2 = null;
      const o2 = this._targetRay, a2 = this._grip, l2 = this._hand;
      if (e2 && "visible-blurred" !== t2.session.visibilityState) {
        if (l2 && e2.hand) {
          s2 = true;
          for (const r4 of e2.hand.values()) {
            const e3 = t2.getJointPose(r4, n2), i4 = this._getHandJoint(l2, r4);
            null !== e3 && (i4.matrix.fromArray(e3.transform.matrix), i4.matrix.decompose(i4.position, i4.rotation, i4.scale), i4.matrixWorldNeedsUpdate = true, i4.jointRadius = e3.radius), i4.visible = null !== e3;
          }
          const r3 = l2.joints["index-finger-tip"], i3 = l2.joints["thumb-tip"], o3 = r3.position.distanceTo(i3.position), a3 = 0.02, c2 = 5e-3;
          l2.inputState.pinching && o3 > a3 + c2 ? (l2.inputState.pinching = false, this.dispatchEvent({ type: "pinchend", handedness: e2.handedness, target: this })) : !l2.inputState.pinching && o3 <= a3 - c2 && (l2.inputState.pinching = true, this.dispatchEvent({ type: "pinchstart", handedness: e2.handedness, target: this }));
        } else
          null !== a2 && e2.gripSpace && (i2 = t2.getPose(e2.gripSpace, n2), null !== i2 && (a2.matrix.fromArray(i2.transform.matrix), a2.matrix.decompose(a2.position, a2.rotation, a2.scale), a2.matrixWorldNeedsUpdate = true, i2.linearVelocity ? (a2.hasLinearVelocity = true, a2.linearVelocity.copy(i2.linearVelocity)) : a2.hasLinearVelocity = false, i2.angularVelocity ? (a2.hasAngularVelocity = true, a2.angularVelocity.copy(i2.angularVelocity)) : a2.hasAngularVelocity = false));
        null !== o2 && (r2 = t2.getPose(e2.targetRaySpace, n2), null === r2 && null !== i2 && (r2 = i2), null !== r2 && (o2.matrix.fromArray(r2.transform.matrix), o2.matrix.decompose(o2.position, o2.rotation, o2.scale), o2.matrixWorldNeedsUpdate = true, r2.linearVelocity ? (o2.hasLinearVelocity = true, o2.linearVelocity.copy(r2.linearVelocity)) : o2.hasLinearVelocity = false, r2.angularVelocity ? (o2.hasAngularVelocity = true, o2.angularVelocity.copy(r2.angularVelocity)) : o2.hasAngularVelocity = false, this.dispatchEvent(kl)));
      }
      return null !== o2 && (o2.visible = null !== r2), null !== a2 && (a2.visible = null !== i2), null !== l2 && (l2.visible = null !== s2), this;
    }
    _getHandJoint(e2, t2) {
      if (void 0 === e2.joints[t2.jointName]) {
        const n2 = new Rl();
        n2.matrixAutoUpdate = false, n2.visible = false, e2.joints[t2.jointName] = n2, e2.add(n2);
      }
      return e2.joints[t2.jointName];
    }
  }
  class Bl extends hr {
    constructor(e2, t2, n2, r2, i2, s2, o2, a2, l2, c2) {
      if ((c2 = void 0 !== c2 ? c2 : Ue) !== Ue && c2 !== Fe)
        throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
      void 0 === n2 && c2 === Ue && (n2 = Me), void 0 === n2 && c2 === Fe && (n2 = ke), super(null, r2, i2, s2, o2, a2, c2, n2, l2), this.isDepthTexture = true, this.image = { width: e2, height: t2 }, this.magFilter = void 0 !== o2 ? o2 : de, this.minFilter = void 0 !== a2 ? a2 : de, this.flipY = false, this.generateMipmaps = false, this.compareFunction = null;
    }
    copy(e2) {
      return super.copy(e2), this.compareFunction = e2.compareFunction, this;
    }
    toJSON(e2) {
      const t2 = super.toJSON(e2);
      return null !== this.compareFunction && (t2.compareFunction = this.compareFunction), t2;
    }
  }
  class Ol extends In {
    constructor(e2, t2) {
      super();
      const n2 = this;
      let r2 = null, i2 = 1, s2 = null, o2 = "local-floor", a2 = 1, l2 = null, c2 = null, u2 = null, p2 = null, d2 = null, h2 = null;
      const f2 = t2.getContextAttributes();
      let m2 = null, _2 = null;
      const g2 = [], v2 = [];
      let y2 = null;
      const b2 = new Hs();
      b2.layers.enable(1), b2.viewport = new fr();
      const w2 = new Hs();
      w2.layers.enable(2), w2.viewport = new fr();
      const A2 = [b2, w2], x2 = new Il();
      x2.layers.enable(1), x2.layers.enable(2);
      let E2 = null, C2 = null;
      function S2(e3) {
        const t3 = v2.indexOf(e3.inputSource);
        if (-1 === t3)
          return;
        const n3 = g2[t3];
        void 0 !== n3 && (n3.update(e3.inputSource, e3.frame, l2 || s2), n3.dispatchEvent({ type: e3.type, data: e3.inputSource }));
      }
      function M2() {
        r2.removeEventListener("select", S2), r2.removeEventListener("selectstart", S2), r2.removeEventListener("selectend", S2), r2.removeEventListener("squeeze", S2), r2.removeEventListener("squeezestart", S2), r2.removeEventListener("squeezeend", S2), r2.removeEventListener("end", M2), r2.removeEventListener("inputsourceschange", T2);
        for (let e3 = 0; e3 < g2.length; e3++) {
          const t3 = v2[e3];
          null !== t3 && (v2[e3] = null, g2[e3].disconnect(t3));
        }
        E2 = null, C2 = null, e2.setRenderTarget(m2), d2 = null, p2 = null, u2 = null, r2 = null, _2 = null, D2.stop(), n2.isPresenting = false, n2.dispatchEvent({ type: "sessionend" });
      }
      function T2(e3) {
        for (let t3 = 0; t3 < e3.removed.length; t3++) {
          const n3 = e3.removed[t3], r3 = v2.indexOf(n3);
          r3 >= 0 && (v2[r3] = null, g2[r3].disconnect(n3));
        }
        for (let t3 = 0; t3 < e3.added.length; t3++) {
          const n3 = e3.added[t3];
          let r3 = v2.indexOf(n3);
          if (-1 === r3) {
            for (let e4 = 0; e4 < g2.length; e4++) {
              if (e4 >= v2.length) {
                v2.push(n3), r3 = e4;
                break;
              }
              if (null === v2[e4]) {
                v2[e4] = n3, r3 = e4;
                break;
              }
            }
            if (-1 === r3)
              break;
          }
          const i3 = g2[r3];
          i3 && i3.connect(n3);
        }
      }
      this.cameraAutoUpdate = true, this.enabled = false, this.isPresenting = false, this.getCamera = function() {
      }, this.setUserCamera = function(e3) {
        y2 = e3;
      }, this.getController = function(e3) {
        let t3 = g2[e3];
        return void 0 === t3 && (t3 = new Dl(), g2[e3] = t3), t3.getTargetRaySpace();
      }, this.getControllerGrip = function(e3) {
        let t3 = g2[e3];
        return void 0 === t3 && (t3 = new Dl(), g2[e3] = t3), t3.getGripSpace();
      }, this.getHand = function(e3) {
        let t3 = g2[e3];
        return void 0 === t3 && (t3 = new Dl(), g2[e3] = t3), t3.getHandSpace();
      }, this.setFramebufferScaleFactor = function(e3) {
        i2 = e3, true === n2.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
      }, this.setReferenceSpaceType = function(e3) {
        o2 = e3, true === n2.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
      }, this.getReferenceSpace = function() {
        return l2 || s2;
      }, this.setReferenceSpace = function(e3) {
        l2 = e3;
      }, this.getBaseLayer = function() {
        return null !== p2 ? p2 : d2;
      }, this.getBinding = function() {
        return u2;
      }, this.getFrame = function() {
        return h2;
      }, this.getSession = function() {
        return r2;
      }, this.setSession = async function(c3) {
        if (r2 = c3, null !== r2) {
          if (m2 = e2.getRenderTarget(), r2.addEventListener("select", S2), r2.addEventListener("selectstart", S2), r2.addEventListener("selectend", S2), r2.addEventListener("squeeze", S2), r2.addEventListener("squeezestart", S2), r2.addEventListener("squeezeend", S2), r2.addEventListener("end", M2), r2.addEventListener("inputsourceschange", T2), true !== f2.xrCompatible && await t2.makeXRCompatible(), void 0 === r2.renderState.layers || false === e2.capabilities.isWebGL2) {
            const n3 = { antialias: void 0 !== r2.renderState.layers || f2.antialias, alpha: true, depth: f2.depth, stencil: f2.stencil, framebufferScaleFactor: i2 };
            d2 = new XRWebGLLayer(r2, t2, n3), r2.updateRenderState({ baseLayer: d2 }), _2 = new mr(d2.framebufferWidth, d2.framebufferHeight, { format: Be, type: Ae, colorSpace: e2.outputColorSpace, stencilBuffer: f2.stencil });
          } else {
            let n3 = null, s3 = null, o3 = null;
            f2.depth && (o3 = f2.stencil ? t2.DEPTH24_STENCIL8 : t2.DEPTH_COMPONENT24, n3 = f2.stencil ? Fe : Ue, s3 = f2.stencil ? ke : Me);
            const a3 = { colorFormat: t2.RGBA8, depthFormat: o3, scaleFactor: i2 };
            u2 = new XRWebGLBinding(r2, t2), p2 = u2.createProjectionLayer(a3), r2.updateRenderState({ layers: [p2] }), _2 = new mr(p2.textureWidth, p2.textureHeight, { format: Be, type: Ae, depthTexture: new Bl(p2.textureWidth, p2.textureHeight, s3, void 0, void 0, void 0, void 0, void 0, void 0, n3), stencilBuffer: f2.stencil, colorSpace: e2.outputColorSpace, samples: f2.antialias ? 4 : 0 }), e2.properties.get(_2).__ignoreDepthValues = p2.ignoreDepthValues;
          }
          _2.isXRRenderTarget = true, this.setFoveation(a2), l2 = null, s2 = await r2.requestReferenceSpace(o2), D2.setContext(r2), D2.start(), n2.isPresenting = true, n2.dispatchEvent({ type: "sessionstart" });
        }
      }, this.getEnvironmentBlendMode = function() {
        if (null !== r2)
          return r2.environmentBlendMode;
      };
      const P2 = new Ar(), I2 = new Ar();
      function R2(e3, t3) {
        null === t3 ? e3.matrixWorld.copy(e3.matrix) : e3.matrixWorld.multiplyMatrices(t3.matrixWorld, e3.matrix), e3.matrixWorldInverse.copy(e3.matrixWorld).invert();
      }
      this.updateCameraXR = function(e3) {
        if (null === r2)
          return e3;
        y2 && (e3 = y2), x2.near = w2.near = b2.near = e3.near, x2.far = w2.far = b2.far = e3.far, E2 === x2.near && C2 === x2.far || (r2.updateRenderState({ depthNear: x2.near, depthFar: x2.far }), E2 = x2.near, C2 = x2.far);
        const t3 = e3.parent, n3 = x2.cameras;
        R2(x2, t3);
        for (let e4 = 0; e4 < n3.length; e4++)
          R2(n3[e4], t3);
        return 2 === n3.length ? function(e4, t4, n4) {
          P2.setFromMatrixPosition(t4.matrixWorld), I2.setFromMatrixPosition(n4.matrixWorld);
          const r3 = P2.distanceTo(I2), i3 = t4.projectionMatrix.elements, s3 = n4.projectionMatrix.elements, o3 = i3[14] / (i3[10] - 1), a3 = i3[14] / (i3[10] + 1), l3 = (i3[9] + 1) / i3[5], c3 = (i3[9] - 1) / i3[5], u3 = (i3[8] - 1) / i3[0], p3 = (s3[8] + 1) / s3[0], d3 = o3 * u3, h3 = o3 * p3, f3 = r3 / (-u3 + p3), m3 = f3 * -u3;
          t4.matrixWorld.decompose(e4.position, e4.quaternion, e4.scale), e4.translateX(m3), e4.translateZ(f3), e4.matrixWorld.compose(e4.position, e4.quaternion, e4.scale), e4.matrixWorldInverse.copy(e4.matrixWorld).invert();
          const _3 = o3 + f3, g3 = a3 + f3, v3 = d3 - m3, y3 = h3 + (r3 - m3), b3 = l3 * a3 / g3 * _3, w3 = c3 * a3 / g3 * _3;
          e4.projectionMatrix.makePerspective(v3, y3, b3, w3, _3, g3), e4.projectionMatrixInverse.copy(e4.projectionMatrix).invert();
        }(x2, b2, w2) : x2.projectionMatrix.copy(b2.projectionMatrix), y2 && function(e4, t4) {
          const n4 = y2;
          null === t4 ? n4.matrix.copy(e4.matrixWorld) : (n4.matrix.copy(t4.matrixWorld), n4.matrix.invert(), n4.matrix.multiply(e4.matrixWorld)), n4.matrix.decompose(n4.position, n4.quaternion, n4.scale), n4.updateMatrixWorld(true);
          const r3 = n4.children;
          for (let e5 = 0, t5 = r3.length; e5 < t5; e5++)
            r3[e5].updateMatrixWorld(true);
          n4.projectionMatrix.copy(e4.projectionMatrix), n4.projectionMatrixInverse.copy(e4.projectionMatrixInverse), n4.isPerspectiveCamera && (n4.fov = 2 * Bn * Math.atan(1 / n4.projectionMatrix.elements[5]), n4.zoom = 1);
        }(x2, t3), x2;
      }, this.getFoveation = function() {
        if (null !== p2 || null !== d2)
          return a2;
      }, this.setFoveation = function(e3) {
        a2 = e3, null !== p2 && (p2.fixedFoveation = e3), null !== d2 && void 0 !== d2.fixedFoveation && (d2.fixedFoveation = e3);
      };
      let k2 = null;
      this.onPreAnimationFrameCallback = null;
      const D2 = new no();
      D2.setAnimationLoop(function(t3, r3) {
        if (n2.onPreAnimationFrameCallback && n2.onPreAnimationFrameCallback(t3, r3), c2 = r3.getViewerPose(l2 || s2), h2 = r3, null !== c2) {
          const t4 = c2.views;
          null !== d2 && (e2.setRenderTargetFramebuffer(_2, d2.framebuffer), e2.setRenderTarget(_2));
          let n3 = false;
          t4.length !== x2.cameras.length && (x2.cameras.length = 0, n3 = true);
          for (let r4 = 0; r4 < t4.length; r4++) {
            const i3 = t4[r4];
            let s3 = null;
            if (null !== d2)
              s3 = d2.getViewport(i3);
            else {
              const t5 = u2.getViewSubImage(p2, i3);
              s3 = t5.viewport, 0 === r4 && (e2.setRenderTargetTextures(_2, t5.colorTexture, p2.ignoreDepthValues ? void 0 : t5.depthStencilTexture), e2.setRenderTarget(_2));
            }
            let o3 = A2[r4];
            void 0 === o3 && (o3 = new Hs(), o3.layers.enable(r4), o3.viewport = new fr(), A2[r4] = o3), o3.matrix.fromArray(i3.transform.matrix), o3.matrix.decompose(o3.position, o3.quaternion, o3.scale), o3.projectionMatrix.fromArray(i3.projectionMatrix), o3.projectionMatrixInverse.copy(o3.projectionMatrix).invert(), o3.viewport.set(s3.x, s3.y, s3.width, s3.height), 0 === r4 && (x2.matrix.copy(o3.matrix), x2.matrix.decompose(x2.position, x2.quaternion, x2.scale)), true === n3 && x2.cameras.push(o3);
          }
        }
        for (let e3 = 0; e3 < g2.length; e3++) {
          const t4 = v2[e3], n3 = g2[e3];
          null !== t4 && void 0 !== n3 && n3.update(t4, r3, l2 || s2);
        }
        k2 && k2(t3, r3), r3.detectedPlanes && n2.dispatchEvent({ type: "planesdetected", data: r3 }), h2 = null;
      }), this.setAnimationLoop = function(e3) {
        k2 = e3;
      }, this.dispose = function() {
      };
    }
  }
  function Ll(e2, t2) {
    function n2(e3, t3) {
      true === e3.matrixAutoUpdate && e3.updateMatrix(), t3.value.copy(e3.matrix);
    }
    function r2(r3, i2) {
      r3.opacity.value = i2.opacity, i2.color && r3.diffuse.value.copy(i2.color), i2.emissive && r3.emissive.value.copy(i2.emissive).multiplyScalar(i2.emissiveIntensity), i2.map && (r3.map.value = i2.map, n2(i2.map, r3.mapTransform)), i2.alphaMap && (r3.alphaMap.value = i2.alphaMap, n2(i2.alphaMap, r3.alphaMapTransform)), i2.bumpMap && (r3.bumpMap.value = i2.bumpMap, n2(i2.bumpMap, r3.bumpMapTransform), r3.bumpScale.value = i2.bumpScale, i2.side === m && (r3.bumpScale.value *= -1)), i2.normalMap && (r3.normalMap.value = i2.normalMap, n2(i2.normalMap, r3.normalMapTransform), r3.normalScale.value.copy(i2.normalScale), i2.side === m && r3.normalScale.value.negate()), i2.displacementMap && (r3.displacementMap.value = i2.displacementMap, n2(i2.displacementMap, r3.displacementMapTransform), r3.displacementScale.value = i2.displacementScale, r3.displacementBias.value = i2.displacementBias), i2.emissiveMap && (r3.emissiveMap.value = i2.emissiveMap, n2(i2.emissiveMap, r3.emissiveMapTransform)), i2.specularMap && (r3.specularMap.value = i2.specularMap, n2(i2.specularMap, r3.specularMapTransform)), i2.alphaTest > 0 && (r3.alphaTest.value = i2.alphaTest);
      const s2 = t2.get(i2).envMap;
      if (s2) {
        r3.envMap.value = s2;
        const e3 = i2.envMap || t2.get(i2).environment || s2;
        r3.envMapRotation.value = e3 ? e3.rotation : 0, r3.flipEnvMap.value = s2.isCubeTexture && false === s2.isRenderTargetTexture ? -1 : 1, r3.reflectivity.value = i2.reflectivity, r3.ior.value = i2.ior, r3.refractionRatio.value = i2.refractionRatio;
      }
      if (i2.lightMap) {
        r3.lightMap.value = i2.lightMap;
        const t3 = true === e2.useLegacyLights ? Math.PI : 1;
        r3.lightMapIntensity.value = i2.lightMapIntensity * t3, n2(i2.lightMap, r3.lightMapTransform);
      }
      i2.aoMap && (r3.aoMap.value = i2.aoMap, r3.aoMapIntensity.value = i2.aoMapIntensity, n2(i2.aoMap, r3.aoMapTransform));
    }
    return { refreshTransformUniform: n2, refreshFogUniforms: function(t3, n3) {
      n3.color.getRGB(t3.fogColor.value, js(e2)), n3.isFog ? (t3.fogNear.value = n3.near, t3.fogFar.value = n3.far) : n3.isFogExp2 && (t3.fogDensity.value = n3.density);
    }, refreshMaterialUniforms: function(e3, i2, s2, o2, a2) {
      i2.isMeshBasicMaterial || i2.isMeshLambertMaterial ? r2(e3, i2) : i2.isMeshToonMaterial ? (r2(e3, i2), function(e4, t3) {
        t3.gradientMap && (e4.gradientMap.value = t3.gradientMap);
      }(e3, i2)) : i2.isMeshPhongMaterial ? (r2(e3, i2), function(e4, t3) {
        e4.specular.value.copy(t3.specular), e4.shininess.value = Math.max(t3.shininess, 1e-4);
      }(e3, i2)) : i2.isMeshStandardMaterial ? (r2(e3, i2), function(e4, r3) {
        e4.metalness.value = r3.metalness, r3.metalnessMap && (e4.metalnessMap.value = r3.metalnessMap, n2(r3.metalnessMap, e4.metalnessMapTransform)), e4.roughness.value = r3.roughness, r3.roughnessMap && (e4.roughnessMap.value = r3.roughnessMap, n2(r3.roughnessMap, e4.roughnessMapTransform));
        t2.get(r3).envMap && (e4.envMapIntensity.value = r3.envMapIntensity);
      }(e3, i2), i2.isMeshPhysicalMaterial && function(e4, t3, r3) {
        e4.ior.value = t3.ior, t3.sheen > 0 && (e4.sheenColor.value.copy(t3.sheenColor).multiplyScalar(t3.sheen), e4.sheenRoughness.value = t3.sheenRoughness, t3.sheenColorMap && (e4.sheenColorMap.value = t3.sheenColorMap, n2(t3.sheenColorMap, e4.sheenColorMapTransform)), t3.sheenRoughnessMap && (e4.sheenRoughnessMap.value = t3.sheenRoughnessMap, n2(t3.sheenRoughnessMap, e4.sheenRoughnessMapTransform))), t3.clearcoat > 0 && (e4.clearcoat.value = t3.clearcoat, e4.clearcoatRoughness.value = t3.clearcoatRoughness, t3.clearcoatMap && (e4.clearcoatMap.value = t3.clearcoatMap, n2(t3.clearcoatMap, e4.clearcoatMapTransform)), t3.clearcoatRoughnessMap && (e4.clearcoatRoughnessMap.value = t3.clearcoatRoughnessMap, n2(t3.clearcoatRoughnessMap, e4.clearcoatRoughnessMapTransform)), t3.clearcoatNormalMap && (e4.clearcoatNormalMap.value = t3.clearcoatNormalMap, n2(t3.clearcoatNormalMap, e4.clearcoatNormalMapTransform), e4.clearcoatNormalScale.value.copy(t3.clearcoatNormalScale), t3.side === m && e4.clearcoatNormalScale.value.negate())), t3.iridescence > 0 && (e4.iridescence.value = t3.iridescence, e4.iridescenceIOR.value = t3.iridescenceIOR, e4.iridescenceThicknessMinimum.value = t3.iridescenceThicknessRange[0], e4.iridescenceThicknessMaximum.value = t3.iridescenceThicknessRange[1], t3.iridescenceMap && (e4.iridescenceMap.value = t3.iridescenceMap, n2(t3.iridescenceMap, e4.iridescenceMapTransform)), t3.iridescenceThicknessMap && (e4.iridescenceThicknessMap.value = t3.iridescenceThicknessMap, n2(t3.iridescenceThicknessMap, e4.iridescenceThicknessMapTransform))), t3.transmission > 0 && (e4.transmission.value = t3.transmission, e4.transmissionSamplerMap.value = r3.texture, e4.transmissionSamplerSize.value.set(r3.width, r3.height), t3.transmissionMap && (e4.transmissionMap.value = t3.transmissionMap, n2(t3.transmissionMap, e4.transmissionMapTransform)), e4.thickness.value = t3.thickness, t3.thicknessMap && (e4.thicknessMap.value = t3.thicknessMap, n2(t3.thicknessMap, e4.thicknessMapTransform)), e4.attenuationDistance.value = t3.attenuationDistance, e4.attenuationColor.value.copy(t3.attenuationColor)), t3.anisotropy > 0 && (e4.anisotropyVector.value.set(t3.anisotropy * Math.cos(t3.anisotropyRotation), t3.anisotropy * Math.sin(t3.anisotropyRotation)), t3.anisotropyMap && (e4.anisotropyMap.value = t3.anisotropyMap, n2(t3.anisotropyMap, e4.anisotropyMapTransform))), e4.specularIntensity.value = t3.specularIntensity, e4.specularColor.value.copy(t3.specularColor), t3.specularColorMap && (e4.specularColorMap.value = t3.specularColorMap, n2(t3.specularColorMap, e4.specularColorMapTransform)), t3.specularIntensityMap && (e4.specularIntensityMap.value = t3.specularIntensityMap, n2(t3.specularIntensityMap, e4.specularIntensityMapTransform));
      }(e3, i2, a2)) : i2.isMeshMatcapMaterial ? (r2(e3, i2), function(e4, t3) {
        t3.matcap && (e4.matcap.value = t3.matcap);
      }(e3, i2)) : i2.isMeshDepthMaterial ? r2(e3, i2) : i2.isMeshDistanceMaterial ? (r2(e3, i2), function(e4, n3) {
        const r3 = t2.get(n3).light;
        e4.referencePosition.value.setFromMatrixPosition(r3.matrixWorld), e4.nearDistance.value = r3.shadow.camera.near, e4.farDistance.value = r3.shadow.camera.far;
      }(e3, i2)) : i2.isMeshNormalMaterial ? r2(e3, i2) : i2.isLineBasicMaterial ? (function(e4, t3) {
        e4.diffuse.value.copy(t3.color), e4.opacity.value = t3.opacity, t3.map && (e4.map.value = t3.map, n2(t3.map, e4.mapTransform));
      }(e3, i2), i2.isLineDashedMaterial && function(e4, t3) {
        e4.dashSize.value = t3.dashSize, e4.totalSize.value = t3.dashSize + t3.gapSize, e4.scale.value = t3.scale;
      }(e3, i2)) : i2.isPointsMaterial ? function(e4, t3, r3, i3) {
        e4.diffuse.value.copy(t3.color), e4.opacity.value = t3.opacity, e4.size.value = t3.size * r3, e4.scale.value = 0.5 * i3, t3.map && (e4.map.value = t3.map, n2(t3.map, e4.uvTransform)), t3.alphaMap && (e4.alphaMap.value = t3.alphaMap, n2(t3.alphaMap, e4.alphaMapTransform)), t3.alphaTest > 0 && (e4.alphaTest.value = t3.alphaTest);
      }(e3, i2, s2, o2) : i2.isSpriteMaterial ? function(e4, t3) {
        e4.diffuse.value.copy(t3.color), e4.opacity.value = t3.opacity, e4.rotation.value = t3.rotation, t3.map && (e4.map.value = t3.map, n2(t3.map, e4.mapTransform)), t3.alphaMap && (e4.alphaMap.value = t3.alphaMap, n2(t3.alphaMap, e4.alphaMapTransform)), t3.alphaTest > 0 && (e4.alphaTest.value = t3.alphaTest);
      }(e3, i2) : i2.isShadowMaterial ? (e3.color.value.copy(i2.color), e3.opacity.value = i2.opacity) : i2.isShaderMaterial && (void 0 !== i2.transmission && (e3.transmission && (e3.transmission.value = i2.transmission), e3.transmissionSamplerMap && a2 && (e3.transmissionSamplerMap.value = a2 ? a2.texture : null), e3.transmissionSamplerSize && a2 && e3.transmissionSamplerSize.value.set(a2.width, a2.height)), i2.uniformsNeedUpdate = false);
    } };
  }
  function Ul(e2, t2, n2, r2) {
    let i2 = {}, s2 = {}, o2 = [];
    const a2 = n2.isWebGL2 ? e2.getParameter(e2.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
    function l2(e3, t3, n3) {
      const r3 = e3.value;
      if (void 0 === n3[t3]) {
        if ("number" == typeof r3)
          n3[t3] = r3;
        else {
          const e4 = Array.isArray(r3) ? r3 : [r3], i3 = [];
          for (let t4 = 0; t4 < e4.length; t4++)
            i3.push(e4[t4].clone());
          n3[t3] = i3;
        }
        return true;
      }
      if ("number" == typeof r3) {
        if (n3[t3] !== r3)
          return n3[t3] = r3, true;
      } else {
        const e4 = Array.isArray(n3[t3]) ? n3[t3] : [n3[t3]], i3 = Array.isArray(r3) ? r3 : [r3];
        for (let t4 = 0; t4 < e4.length; t4++) {
          const n4 = e4[t4];
          if (false === n4.equals(i3[t4]))
            return n4.copy(i3[t4]), true;
        }
      }
      return false;
    }
    function c2(e3) {
      const t3 = { boundary: 0, storage: 0 };
      return "number" == typeof e3 ? (t3.boundary = 4, t3.storage = 4) : e3.isVector2 ? (t3.boundary = 8, t3.storage = 8) : e3.isVector3 || e3.isColor ? (t3.boundary = 16, t3.storage = 12) : e3.isVector4 ? (t3.boundary = 16, t3.storage = 16) : e3.isMatrix3 ? (t3.boundary = 48, t3.storage = 48) : e3.isMatrix4 ? (t3.boundary = 64, t3.storage = 64) : e3.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", e3), t3;
    }
    function u2(t3) {
      const n3 = t3.target;
      n3.removeEventListener("dispose", u2);
      const r3 = o2.indexOf(n3.__bindingPointIndex);
      o2.splice(r3, 1), e2.deleteBuffer(i2[n3.id]), delete i2[n3.id], delete s2[n3.id];
    }
    return { bind: function(e3, t3) {
      const n3 = t3.program;
      r2.uniformBlockBinding(e3, n3);
    }, update: function(n3, p2) {
      let d2 = i2[n3.id];
      void 0 === d2 && (function(e3) {
        const t3 = e3.uniforms;
        let n4 = 0;
        let r3 = 0;
        for (let e4 = 0, i3 = t3.length; e4 < i3; e4++) {
          const i4 = t3[e4], s3 = { boundary: 0, storage: 0 }, o3 = Array.isArray(i4.value) ? i4.value : [i4.value];
          for (let e5 = 0, t4 = o3.length; e5 < t4; e5++) {
            const t5 = c2(o3[e5]);
            s3.boundary += t5.boundary, s3.storage += t5.storage;
          }
          i4.__data = new Float32Array(s3.storage / Float32Array.BYTES_PER_ELEMENT), i4.__offset = n4, e4 > 0 && (r3 = n4 % 16, 0 !== r3 && 16 - r3 - s3.boundary < 0 && (n4 += 16 - r3, i4.__offset = n4)), n4 += s3.storage;
        }
        r3 = n4 % 16, r3 > 0 && (n4 += 16 - r3), e3.__size = n4, e3.__cache = {};
      }(n3), d2 = function(t3) {
        const n4 = function() {
          for (let e3 = 0; e3 < a2; e3++)
            if (-1 === o2.indexOf(e3))
              return o2.push(e3), e3;
          return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
        }();
        t3.__bindingPointIndex = n4;
        const r3 = e2.createBuffer(), i3 = t3.__size, s3 = t3.usage;
        return e2.bindBuffer(e2.UNIFORM_BUFFER, r3), e2.bufferData(e2.UNIFORM_BUFFER, i3, s3), e2.bindBuffer(e2.UNIFORM_BUFFER, null), e2.bindBufferBase(e2.UNIFORM_BUFFER, n4, r3), r3;
      }(n3), i2[n3.id] = d2, n3.addEventListener("dispose", u2));
      const h2 = p2.program;
      r2.updateUBOMapping(n3, h2);
      const f2 = t2.render.frame;
      s2[n3.id] !== f2 && (function(t3) {
        const n4 = i2[t3.id], r3 = t3.uniforms, s3 = t3.__cache;
        e2.bindBuffer(e2.UNIFORM_BUFFER, n4);
        for (let t4 = 0, n5 = r3.length; t4 < n5; t4++) {
          const n6 = r3[t4];
          if (true === l2(n6, t4, s3)) {
            const t5 = n6.__offset, r4 = Array.isArray(n6.value) ? n6.value : [n6.value];
            let i3 = 0;
            for (let s4 = 0; s4 < r4.length; s4++) {
              const o3 = r4[s4], a3 = c2(o3);
              "number" == typeof o3 ? (n6.__data[0] = o3, e2.bufferSubData(e2.UNIFORM_BUFFER, t5 + i3, n6.__data)) : o3.isMatrix3 ? (n6.__data[0] = o3.elements[0], n6.__data[1] = o3.elements[1], n6.__data[2] = o3.elements[2], n6.__data[3] = o3.elements[0], n6.__data[4] = o3.elements[3], n6.__data[5] = o3.elements[4], n6.__data[6] = o3.elements[5], n6.__data[7] = o3.elements[0], n6.__data[8] = o3.elements[6], n6.__data[9] = o3.elements[7], n6.__data[10] = o3.elements[8], n6.__data[11] = o3.elements[0]) : (o3.toArray(n6.__data, i3), i3 += a3.storage / Float32Array.BYTES_PER_ELEMENT);
            }
            e2.bufferSubData(e2.UNIFORM_BUFFER, t5, n6.__data);
          }
        }
        e2.bindBuffer(e2.UNIFORM_BUFFER, null);
      }(n3), s2[n3.id] = f2);
    }, dispose: function() {
      for (const t3 in i2)
        e2.deleteBuffer(i2[t3]);
      o2 = [], i2 = {}, s2 = {};
    } };
  }
  function Fl() {
    const e2 = Jn("canvas");
    return e2.style.display = "block", e2;
  }
  class Nl {
    constructor(e2 = {}) {
      const { canvas: t2 = Fl(), context: n2 = null, depth: i2 = true, stencil: s2 = true, alpha: o2 = false, antialias: a2 = false, premultipliedAlpha: l2 = true, preserveDrawingBuffer: c2 = false, powerPreference: u2 = "default", failIfMajorPerformanceCaveat: p2 = false } = e2;
      let d2;
      this.isWebGLRenderer = true, d2 = null !== n2 ? n2.getContextAttributes().alpha : o2;
      const h2 = new Uint32Array(4), g2 = new Int32Array(4);
      let v2 = null, y2 = null;
      const b2 = [], w2 = [];
      this.domElement = t2, this.debug = { checkShaderErrors: true, onShaderError: null }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this.outputColorSpace = zt, this.useLegacyLights = true, this.toneMapping = J, this.toneMappingExposure = 1, this.userData = {}, this.onContextLost = () => {
      }, this.onContextRestore = () => {
      }, this.onContextCreationError = () => {
      };
      const A2 = this;
      let x2 = false, E2 = 0, C2 = 0, S2 = null, M2 = -1, T2 = null;
      const P2 = new fr(), I2 = new fr();
      let R2 = null;
      const k2 = new Vi(0);
      let D2 = 0, B2 = t2.width, O2 = t2.height, L2 = 1, U2 = null, F2 = null;
      const N2 = new fr(0, 0, B2, O2), j2 = new fr(0, 0, B2, O2);
      let z2 = false;
      const G2 = new to();
      let V2 = false, H2 = false, Q2 = null;
      const W2 = new Zr(), q2 = new Qn(), X2 = new Ar(), Y2 = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
      function K2() {
        return null === S2 ? L2 : 1;
      }
      let Z2, $2, ee2, te2, ne2, re2, ie2, se2, oe2, ae2, le2, ce2, ue2, pe2, de2, he2, fe2, me2, _e2, ge2, ve2, ye2, we2, xe2, Ee2 = n2;
      function Se2(e3, n3) {
        for (let r2 = 0; r2 < e3.length; r2++) {
          const i3 = e3[r2], s3 = t2.getContext(i3, n3);
          if (null !== s3)
            return s3;
        }
        return null;
      }
      try {
        const e3 = { alpha: true, depth: i2, stencil: s2, antialias: a2, premultipliedAlpha: l2, preserveDrawingBuffer: c2, powerPreference: u2, failIfMajorPerformanceCaveat: p2 };
        if ("setAttribute" in t2 && t2.setAttribute("data-engine", `three.js r${r}`), t2.addEventListener("webglcontextlost", Le2, false), t2.addEventListener("webglcontextrestored", Ue2, false), t2.addEventListener("webglcontextcreationerror", Fe2, false), null === Ee2) {
          const t3 = ["webgl2", "webgl", "experimental-webgl"];
          if (true === A2.isWebGL1Renderer && t3.shift(), Ee2 = Se2(t3, e3), null === Ee2)
            throw Se2(t3) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
        }
        Ee2 instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), void 0 === Ee2.getShaderPrecisionFormat && (Ee2.getShaderPrecisionFormat = function() {
          return { rangeMin: 1, rangeMax: 1, precision: 1 };
        });
      } catch (e3) {
        throw console.error("THREE.WebGLRenderer: " + e3.message), e3;
      }
      function De2() {
        Z2 = new Ro(Ee2), $2 = new ho(Ee2, Z2, e2), Z2.init($2), ye2 = new Pl(Ee2, Z2, $2), ee2 = new Ml(Ee2, Z2, $2), te2 = new Bo(Ee2), ne2 = new pl(), re2 = new Tl(Ee2, Z2, ee2, ne2, $2, ye2, te2), ie2 = new mo(A2), se2 = new Io(A2), oe2 = new ro(Ee2, $2), we2 = new uo(Ee2, Z2, oe2, $2), ae2 = new ko(Ee2, oe2, te2, we2), le2 = new Fo(Ee2, ae2, oe2, te2), _e2 = new Uo(Ee2, $2, re2), he2 = new fo(ne2), ce2 = new ul(A2, ie2, se2, Z2, $2, we2, he2), ue2 = new Ll(A2, ne2), pe2 = new ml(), de2 = new wl(Z2, $2), me2 = new co(A2, ie2, se2, ee2, le2, d2, l2), fe2 = new Sl(A2, le2, $2), xe2 = new Ul(Ee2, te2, $2, ee2), ge2 = new po(Ee2, Z2, te2, $2), ve2 = new Do(Ee2, Z2, te2, $2), te2.programs = ce2.programs, A2.capabilities = $2, A2.extensions = Z2, A2.properties = ne2, A2.renderLists = pe2, A2.shadowMap = fe2, A2.state = ee2, A2.info = te2, A2.background = me2, A2.cubemaps = ie2, A2.cubeuvmaps = se2, A2.materials = ue2;
      }
      De2();
      const Oe2 = new Ol(A2, Ee2);
      function Le2(e3) {
        e3.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), x2 = true, A2.onContextLost(e3);
      }
      function Ue2() {
        console.log("THREE.WebGLRenderer: Context Restored."), x2 = false;
        const e3 = A2.info ? A2.info.autoReset : void 0, t3 = fe2.enabled, n3 = fe2.autoUpdate, r2 = fe2.needsUpdate, i3 = fe2.type;
        De2(), A2.info && void 0 !== e3 && (A2.info.autoReset = e3), fe2.enabled = t3, fe2.autoUpdate = n3, fe2.needsUpdate = r2, fe2.type = i3, A2.onContextRestore && A2.onContextRestore(), console.log("restored");
      }
      function Fe2(e3) {
        console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", e3.statusMessage), A2.onContextCreationError(e3);
      }
      function Ne2(e3) {
        const t3 = e3.target;
        t3.removeEventListener("dispose", Ne2), function(e4) {
          (function(e5) {
            const t4 = ne2.get(e5).programs;
            void 0 !== t4 && (t4.forEach(function(e6) {
              ce2.releaseProgram(e6);
            }), e5.isShaderMaterial && ce2.releaseShaderCache(e5));
          })(e4), ne2.remove(e4);
        }(t3);
      }
      this.xr = Oe2, this.getContext = function() {
        return Ee2;
      }, this.getContextAttributes = function() {
        return Ee2.getContextAttributes();
      }, this.forceContextLoss = function() {
        const e3 = Z2.get("WEBGL_lose_context");
        e3 && e3.loseContext();
      }, this.forceContextRestore = function() {
        const e3 = Z2.get("WEBGL_lose_context");
        e3 && e3.restoreContext();
      }, this.getPixelRatio = function() {
        return L2;
      }, this.setPixelRatio = function(e3) {
        void 0 !== e3 && (L2 = e3, this.setSize(B2, O2, false));
      }, this.getSize = function(e3) {
        return e3.set(B2, O2);
      }, this.setSize = function(e3, n3, r2 = true) {
        Oe2.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (B2 = e3, O2 = n3, t2.width = Math.floor(e3 * L2), t2.height = Math.floor(n3 * L2), true === r2 && (t2.style.width = e3 + "px", t2.style.height = n3 + "px"), this.setViewport(0, 0, e3, n3));
      }, this.getDrawingBufferSize = function(e3) {
        return e3.set(B2 * L2, O2 * L2).floor();
      }, this.setDrawingBufferSize = function(e3, n3, r2) {
        B2 = e3, O2 = n3, L2 = r2, t2.width = Math.floor(e3 * r2), t2.height = Math.floor(n3 * r2), this.setViewport(0, 0, e3, n3);
      }, this.getCurrentViewport = function(e3) {
        return e3.copy(P2);
      }, this.getViewport = function(e3) {
        return e3.copy(N2);
      }, this.setViewport = function(e3, t3, n3, r2) {
        e3.isVector4 ? N2.set(e3.x, e3.y, e3.z, e3.w) : N2.set(e3, t3, n3, r2), ee2.viewport(P2.copy(N2).multiplyScalar(L2).floor());
      }, this.getScissor = function(e3) {
        return e3.copy(j2);
      }, this.setScissor = function(e3, t3, n3, r2) {
        e3.isVector4 ? j2.set(e3.x, e3.y, e3.z, e3.w) : j2.set(e3, t3, n3, r2), ee2.scissor(I2.copy(j2).multiplyScalar(L2).floor());
      }, this.getScissorTest = function() {
        return z2;
      }, this.setScissorTest = function(e3) {
        ee2.setScissorTest(z2 = e3);
      }, this.setOpaqueSort = function(e3) {
        U2 = e3;
      }, this.setTransparentSort = function(e3) {
        F2 = e3;
      }, this.getClearColor = function(e3) {
        return e3.copy(me2.getClearColor());
      }, this.setClearColor = function() {
        me2.setClearColor.apply(me2, arguments);
      }, this.getClearAlpha = function() {
        return me2.getClearAlpha();
      }, this.setClearAlpha = function() {
        me2.setClearAlpha.apply(me2, arguments);
      }, this.clear = function(e3 = true, t3 = true, n3 = true) {
        let r2 = 0;
        if (e3) {
          let e4 = false;
          if (null !== S2) {
            const t4 = S2.texture.format;
            e4 = t4 === Ve || t4 === Ge || t4 === je;
          }
          if (e4) {
            const e5 = S2.texture.type, t4 = e5 === Ae || e5 === Me || e5 === Ce || e5 === ke || e5 === Ie || e5 === Re, n4 = me2.getClearColor(), r3 = me2.getClearAlpha(), i3 = n4.r, s3 = n4.g, o3 = n4.b, a3 = ne2.get(S2).__webglFramebuffer;
            t4 ? (h2[0] = i3, h2[1] = s3, h2[2] = o3, h2[3] = r3, Ee2.clearBufferuiv(Ee2.COLOR, a3, h2)) : (g2[0] = i3, g2[1] = s3, g2[2] = o3, g2[3] = r3, Ee2.clearBufferiv(Ee2.COLOR, a3, g2));
          } else
            r2 |= Ee2.COLOR_BUFFER_BIT;
        }
        t3 && (r2 |= Ee2.DEPTH_BUFFER_BIT), n3 && (r2 |= Ee2.STENCIL_BUFFER_BIT), Ee2.clear(r2);
      }, this.clearColor = function() {
        this.clear(true, false, false);
      }, this.clearDepth = function() {
        this.clear(false, true, false);
      }, this.clearStencil = function() {
        this.clear(false, false, true);
      }, this.dispose = function() {
        t2.removeEventListener("webglcontextlost", Le2, false), t2.removeEventListener("webglcontextrestored", Ue2, false), t2.removeEventListener("webglcontextcreationerror", Fe2, false), pe2.dispose(), de2.dispose(), ne2.dispose(), ie2.dispose(), se2.dispose(), le2.dispose(), we2.dispose(), xe2.dispose(), ce2.dispose(), Oe2.dispose(), Oe2.removeEventListener("sessionstart", He2), Oe2.removeEventListener("sessionend", Qe2), Q2 && (Q2.dispose(), Q2 = null), We2.stop();
      }, this.renderBufferDirect = function(e3, t3, n3, r2, i3, s3) {
        null === t3 && (t3 = Y2);
        const o3 = i3.isMesh && i3.matrixWorld.determinant() < 0, a3 = function(e4, t4, n4, r3, i4) {
          true !== t4.isScene && (t4 = Y2), re2.resetTextureUnits();
          const s4 = t4.fog, o4 = r3.userData && r3.userData.envMapSlotKey && t4.textureSlots && t4.textureSlots[r3.userData.envMapSlotKey] ? t4.textureSlots[r3.userData.envMapSlotKey] : r3.isMeshStandardMaterial ? t4.environment : null, a4 = null === S2 ? A2.outputColorSpace : true === S2.isXRRenderTarget || S2.texture.colorSpace && S2.texture.colorSpace !== zt ? S2.texture.colorSpace : Gt, l4 = (r3.isMeshStandardMaterial ? se2 : ie2).get(r3.envMap || o4), c4 = true === r3.vertexColors && !!n4.attributes.color && 4 === n4.attributes.color.itemSize, u4 = !!n4.attributes.tangent && (!!r3.normalMap || r3.anisotropy > 0), p4 = !!n4.morphAttributes.position, d4 = !!n4.morphAttributes.normal, h4 = !!n4.morphAttributes.color, f3 = r3.toneMapped ? A2.toneMapping : J, m3 = n4.morphAttributes.position || n4.morphAttributes.normal || n4.morphAttributes.color, _3 = void 0 !== m3 ? m3.length : 0, g3 = ne2.get(r3), v3 = y2.state.lights;
          if (true === V2 && (true === H2 || e4 !== T2)) {
            const t5 = e4 === T2 && r3.id === M2;
            he2.setState(r3, e4, t5);
          }
          let b3 = false;
          r3.version === g3.__version ? g3.needsLights && g3.lightsStateVersion !== v3.state.version || g3.outputColorSpace !== a4 || i4.isInstancedMesh && false === g3.instancing ? b3 = true : i4.isInstancedMesh || true !== g3.instancing ? i4.isSkinnedMesh && false === g3.skinning ? b3 = true : i4.isSkinnedMesh || true !== g3.skinning ? g3.envMap !== l4 || true === r3.fog && g3.fog !== s4 ? b3 = true : void 0 === g3.numClippingPlanes || g3.numClippingPlanes === he2.numPlanes && g3.numIntersection === he2.numIntersection ? (g3.vertexAlphas !== c4 || g3.vertexTangents !== u4 || g3.morphTargets !== p4 || g3.morphNormals !== d4 || g3.morphColors !== h4 || g3.toneMapping !== f3 || true === $2.isWebGL2 && g3.morphTargetsCount !== _3) && (b3 = true) : b3 = true : b3 = true : b3 = true : (b3 = true, g3.__version = r3.version);
          let w3 = g3.currentProgram;
          true === b3 && (w3 = Je2(r3, t4, i4));
          let x3 = false, E3 = false, C3 = false;
          const P3 = w3.getUniforms(), I3 = g3.uniforms;
          if (ee2.useProgram(w3.program) && (x3 = true, E3 = true, C3 = true), r3.id !== M2 && (M2 = r3.id, E3 = true), x3 || T2 !== e4) {
            if (P3.setValue(Ee2, "projectionMatrix", e4.projectionMatrix), $2.logarithmicDepthBuffer && P3.setValue(Ee2, "logDepthBufFC", 2 / (Math.log(e4.far + 1) / Math.LN2)), T2 !== e4 && (T2 = e4, E3 = true, C3 = true), r3.isShaderMaterial || r3.isMeshPhongMaterial || r3.isMeshToonMaterial || r3.isMeshStandardMaterial || r3.envMap) {
              const t5 = P3.map.cameraPosition;
              void 0 !== t5 && t5.setValue(Ee2, X2.setFromMatrixPosition(e4.matrixWorld));
            }
            (r3.isMeshPhongMaterial || r3.isMeshToonMaterial || r3.isMeshLambertMaterial || r3.isMeshBasicMaterial || r3.isMeshStandardMaterial || r3.isShaderMaterial) && P3.setValue(Ee2, "isOrthographic", true === e4.isOrthographicCamera), (r3.isMeshPhongMaterial || r3.isMeshToonMaterial || r3.isMeshLambertMaterial || r3.isMeshBasicMaterial || r3.isMeshStandardMaterial || r3.isShaderMaterial || r3.isShadowMaterial || i4.isSkinnedMesh) && P3.setValue(Ee2, "viewMatrix", e4.matrixWorldInverse);
          }
          if (i4.isSkinnedMesh) {
            P3.setOptional(Ee2, i4, "bindMatrix"), P3.setOptional(Ee2, i4, "bindMatrixInverse");
            const e5 = i4.skeleton;
            e5 && ($2.floatVertexTextures ? (null === e5.boneTexture && e5.computeBoneTexture(), P3.setValue(Ee2, "boneTexture", e5.boneTexture, re2), P3.setValue(Ee2, "boneTextureSize", e5.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
          }
          const R3 = n4.morphAttributes;
          var k3, D3;
          (void 0 !== R3.position || void 0 !== R3.normal || void 0 !== R3.color && true === $2.isWebGL2) && _e2.update(i4, n4, w3), (E3 || g3.receiveShadow !== i4.receiveShadow) && (g3.receiveShadow = i4.receiveShadow, P3.setValue(Ee2, "receiveShadow", i4.receiveShadow)), r3.isMeshGouraudMaterial && null !== r3.envMap && (I3.envMap.value = l4, I3.flipEnvMap.value = l4.isCubeTexture && false === l4.isRenderTargetTexture ? -1 : 1), E3 && (P3.setValue(Ee2, "toneMappingExposure", A2.toneMappingExposure), g3.needsLights && (D3 = C3, (k3 = I3).ambientLightColor.needsUpdate = D3, k3.lightProbe.needsUpdate = D3, k3.directionalLights.needsUpdate = D3, k3.directionalLightShadows.needsUpdate = D3, k3.pointLights.needsUpdate = D3, k3.pointLightShadows.needsUpdate = D3, k3.spotLights.needsUpdate = D3, k3.spotLightShadows.needsUpdate = D3, k3.rectAreaLights.needsUpdate = D3, k3.hemisphereLights.needsUpdate = D3), s4 && true === r3.fog && ue2.refreshFogUniforms(I3, s4), ue2.refreshMaterialUniforms(I3, r3, L2, O2, A2.userData.transmissionRenderTarget || Q2), Ga.upload(Ee2, g3.uniformsList, I3, re2)), r3.isShaderMaterial && true === r3.uniformsNeedUpdate && (Ga.upload(Ee2, g3.uniformsList, I3, re2), r3.uniformsNeedUpdate = false), r3.isSpriteMaterial && P3.setValue(Ee2, "center", i4.center), P3.setValue(Ee2, "modelViewMatrix", i4.modelViewMatrix), P3.setValue(Ee2, "normalMatrix", i4.normalMatrix), P3.setValue(Ee2, "modelMatrix", i4.matrixWorld);
          const B3 = r3.extraUniformsToUpload;
          if (B3 && Object.entries(B3).forEach(([e5, t5]) => P3.setValue(Ee2, e5, t5.value, re2)), r3.isShaderMaterial || r3.isRawShaderMaterial) {
            const e5 = r3.uniformsGroups;
            for (let t5 = 0, n5 = e5.length; t5 < n5; t5++)
              if ($2.isWebGL2) {
                const n6 = e5[t5];
                xe2.update(n6, w3), xe2.bind(n6, w3);
              } else
                console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
          }
          return w3;
        }(e3, t3, n3, r2, i3);
        ee2.setMaterial(r2, o3);
        let l3 = n3.index, c3 = 1;
        true === r2.wireframe && (l3 = ae2.getWireframeAttribute(n3), c3 = 2);
        const u3 = n3.drawRange, p3 = n3.attributes.position;
        let d3 = u3.start * c3, h3 = (u3.start + u3.count) * c3;
        null !== s3 && (d3 = Math.max(d3, s3.start * c3), h3 = Math.min(h3, (s3.start + s3.count) * c3)), null !== l3 ? (d3 = Math.max(d3, 0), h3 = Math.min(h3, l3.count)) : null != p3 && (d3 = Math.max(d3, 0), h3 = Math.min(h3, p3.count));
        const f2 = h3 - d3;
        if (f2 < 0 || f2 === 1 / 0)
          return;
        let m2;
        we2.setup(i3, r2, a3, n3, l3);
        let _2 = ge2;
        if (null !== l3 && (m2 = oe2.get(l3), _2 = ve2, _2.setIndex(m2)), i3.isMesh)
          true === r2.wireframe ? (ee2.setLineWidth(r2.wireframeLinewidth * K2()), _2.setMode(Ee2.LINES)) : _2.setMode(Ee2.TRIANGLES);
        else if (i3.isLine) {
          let e4 = r2.linewidth;
          void 0 === e4 && (e4 = 1), ee2.setLineWidth(e4 * K2()), i3.isLineSegments ? _2.setMode(Ee2.LINES) : i3.isLineLoop ? _2.setMode(Ee2.LINE_LOOP) : _2.setMode(Ee2.LINE_STRIP);
        } else
          i3.isPoints ? _2.setMode(Ee2.POINTS) : i3.isSprite && _2.setMode(Ee2.TRIANGLES);
        if (i3.isInstancedMesh)
          _2.renderInstances(d3, f2, i3.count);
        else if (n3.isInstancedBufferGeometry) {
          const e4 = void 0 !== n3._maxInstanceCount ? n3._maxInstanceCount : 1 / 0, t4 = Math.min(n3.instanceCount, e4);
          _2.renderInstances(d3, f2, t4);
        } else
          _2.render(d3, f2);
      }, this.compile = function(e3, t3) {
        function n3(e4, t4, n4) {
          true === e4.transparent && e4.side === _ && false === e4.forceSinglePass ? (e4.side = m, e4.needsUpdate = true, Je2(e4, t4, n4), e4.side = f, e4.needsUpdate = true, Je2(e4, t4, n4), e4.side = _) : Je2(e4, t4, n4);
        }
        y2 = de2.get(e3), y2.init(), w2.push(y2), e3.traverseVisible(function(e4) {
          e4.isLight && e4.layers.test(t3.layers) && (y2.pushLight(e4), e4.castShadow && y2.pushShadow(e4));
        }), y2.setupLights(A2.useLegacyLights), e3.traverse(function(t4) {
          const r2 = t4.material;
          if (r2)
            if (Array.isArray(r2))
              for (let i3 = 0; i3 < r2.length; i3++)
                n3(r2[i3], e3, t4);
            else
              n3(r2, e3, t4);
        }), w2.pop(), y2 = null;
      };
      let ze2 = null;
      function He2() {
        We2.stop();
      }
      function Qe2() {
        We2.start();
      }
      const We2 = new no();
      function qe2(e3, t3, n3, r2) {
        if (false === e3.visible)
          return;
        if (e3.layers.test(t3.layers)) {
          if (e3.isGroup)
            n3 = e3.renderOrder;
          else if (e3.isLOD)
            true === e3.autoUpdate && e3.update(t3);
          else if (e3.isLight)
            y2.pushLight(e3), e3.castShadow && y2.pushShadow(e3);
          else if (e3.isSprite) {
            if (!e3.frustumCulled || G2.intersectsSprite(e3)) {
              r2 && X2.setFromMatrixPosition(e3.matrixWorld).applyMatrix4(W2);
              const t4 = le2.update(e3), i4 = e3.material;
              i4.visible && v2.push(e3, t4, i4, n3, X2.z, null);
            }
          } else if ((e3.isMesh || e3.isLine || e3.isPoints) && (!e3.frustumCulled || G2.intersectsObject(e3))) {
            e3.isSkinnedMesh && e3.skeleton.frame !== te2.render.frame && (e3.skeleton.update(), e3.skeleton.frame = te2.render.frame);
            const t4 = le2.update(e3), i4 = e3.material;
            if (r2 && (void 0 !== e3.boundingSphere ? (null === e3.boundingSphere && e3.computeBoundingSphere(), X2.copy(e3.boundingSphere.center)) : (null === t4.boundingSphere && t4.computeBoundingSphere(), X2.copy(t4.boundingSphere.center)), X2.applyMatrix4(e3.matrixWorld).applyMatrix4(W2)), Array.isArray(i4)) {
              const r3 = t4.groups;
              for (let s3 = 0, o3 = r3.length; s3 < o3; s3++) {
                const o4 = r3[s3], a3 = i4[o4.materialIndex];
                a3 && a3.visible && v2.push(e3, t4, a3, n3, X2.z, o4);
              }
            } else
              i4.visible && v2.push(e3, t4, i4, n3, X2.z, null);
          }
        }
        const i3 = e3.children;
        for (let e4 = 0, s3 = i3.length; e4 < s3; e4++)
          qe2(i3[e4], t3, n3, r2);
      }
      function Xe2(e3, t3, n3, r2) {
        const i3 = e3.opaque, s3 = e3.transmissive, o3 = e3.transparent;
        if (y2.setupLightsView(n3), true === V2 && he2.setGlobalState(A2.clippingPlanes, n3), void 0 === A2.userData.transmissionRender && false !== A2.userData.renderTransmissionPass && s3.length > 0 && function(e4, t4, n4, r3) {
          console.warn("three.js internal render transmission pass should not be called");
          const i4 = $2.isWebGL2;
          null === Q2 && (Q2 = new mr(1, 1, { generateMipmaps: true, type: Z2.has("EXT_color_buffer_half_float") ? Pe : Ae, minFilter: be, samples: i4 && true === a2 ? 4 : 0 })), A2.getDrawingBufferSize(q2), i4 ? Q2.setSize(q2.x, q2.y) : Q2.setSize(zn(q2.x), zn(q2.y));
          const s4 = A2.getRenderTarget();
          A2.setRenderTarget(Q2), A2.getClearColor(k2), D2 = A2.getClearAlpha(), D2 < 1 && A2.setClearColor(16777215, 0.5), A2.clear();
          const o4 = A2.toneMapping;
          A2.toneMapping = J, Ye2(e4, n4, r3), re2.updateMultisampleRenderTarget(Q2), re2.updateRenderTargetMipmap(Q2);
          let l3 = false;
          for (let e5 = 0, i5 = t4.length; e5 < i5; e5++) {
            const i6 = t4[e5], s5 = i6.object, o5 = i6.geometry, a3 = i6.material, c3 = i6.group;
            if (a3.side === _ && s5.layers.test(r3.layers)) {
              const e6 = a3.side;
              a3.side = m, a3.needsUpdate = true, Ke2(s5, n4, r3, o5, a3, c3), a3.side = e6, a3.needsUpdate = true, l3 = true;
            }
          }
          true === l3 && (re2.updateMultisampleRenderTarget(Q2), re2.updateRenderTargetMipmap(Q2)), A2.setRenderTarget(s4), A2.setClearColor(k2, D2), A2.toneMapping = o4;
        }([...i3, ...o3], s3, t3, n3), r2 && ee2.viewport(P2.copy(r2)), false !== A2.userData.opaqueRender && i3.length > 0 && Ye2(i3, t3, n3), false !== A2.userData.transparentRender && o3.length > 0 && Ye2(o3, t3, n3), false !== A2.userData.transmissionRender && s3.length > 0) {
          Q2 || (Q2 = new mr(1, 1));
          const e4 = (A2.userData.transmissionRenderTarget || Q2).texture, r3 = $2.isWebGL2, i4 = e4.generateMipmaps, o4 = e4.minFilter;
          r3 && A2.userData.blurTransmissionTarget && A2.userData.transmissionRenderTarget && (e4.generateMipmaps = true, e4.minFilter = be, e4.needsUpdate = true, re2.updateMultisampleRenderTarget(A2.userData.transmissionRenderTarget), re2.updateRenderTargetMipmap(A2.userData.transmissionRenderTarget)), Ye2(s3, t3, n3), r3 && A2.userData.blurTransmissionTarget && A2.userData.transmissionRenderTarget && (e4.generateMipmaps = i4, e4.minFilter = o4, e4.needsUpdate = true, re2.updateMultisampleRenderTarget(A2.userData.transmissionRenderTarget), re2.updateRenderTargetMipmap(A2.userData.transmissionRenderTarget));
        }
        ee2.buffers.depth.setTest(true), ee2.buffers.depth.setMask(true), ee2.buffers.color.setMask(true), ee2.setPolygonOffset(false);
      }
      function Ye2(e3, t3, n3) {
        const r2 = { ...A2.userData };
        A2.userData.opaqueRender = void 0, A2.userData.transparentRender = void 0, A2.userData.transmissionRender = void 0, A2.userData.backgroundRender = void 0;
        const i3 = true === t3.isScene ? t3.overrideMaterial : null;
        for (let r3 = 0, s3 = e3.length; r3 < s3; r3++) {
          const s4 = e3[r3], o3 = s4.object, a3 = s4.geometry, l3 = null === i3 ? s4.material : i3, c3 = s4.group;
          o3.layers.test(n3.layers) && Ke2(o3, t3, n3, a3, l3, c3);
        }
        Object.assign(A2.userData, r2);
      }
      function Ke2(e3, t3, n3, r2, i3, s3) {
        e3.onBeforeRender(A2, t3, n3, r2, i3, s3), e3.modelViewMatrix.multiplyMatrices(n3.matrixWorldInverse, e3.matrixWorld), e3.normalMatrix.getNormalMatrix(e3.modelViewMatrix), i3.onBeforeRender(A2, t3, n3, r2, e3, s3), true === i3.transparent && i3.side === _ && false === i3.forceSinglePass ? (i3.side = m, i3.needsUpdate = true, A2.renderBufferDirect(n3, t3, r2, i3, e3, s3), i3.side = f, i3.needsUpdate = true, A2.renderBufferDirect(n3, t3, r2, i3, e3, s3), i3.side = _) : A2.renderBufferDirect(n3, t3, r2, i3, e3, s3), e3.onAfterRender(A2, t3, n3, r2, i3, s3), i3.onAfterRender(A2, t3, n3, r2, e3, s3);
      }
      function Je2(e3, t3, n3) {
        true !== t3.isScene && (t3 = Y2);
        const r2 = ne2.get(e3), i3 = y2.state.lights, s3 = y2.state.shadowsArray, o3 = i3.state.version, a3 = ce2.getParameters(e3, i3.state, s3, t3, n3), l3 = ce2.getProgramCacheKey(a3);
        let c3 = r2.programs;
        r2.environment = e3.userData && e3.userData.envMapSlotKey && t3.textureSlots && t3.textureSlots[e3.userData.envMapSlotKey] ? t3.textureSlots[e3.userData.envMapSlotKey] : e3.isMeshStandardMaterial ? t3.environment : null, r2.fog = t3.fog, r2.envMap = (e3.isMeshStandardMaterial ? se2 : ie2).get(e3.envMap || r2.environment), void 0 === c3 && (e3.addEventListener("dispose", Ne2), c3 = /* @__PURE__ */ new Map(), r2.programs = c3);
        let u3 = c3.get(l3);
        if (void 0 !== u3) {
          if (r2.currentProgram === u3 && r2.lightsStateVersion === o3)
            return Ze2(e3, a3), u3;
        } else
          a3.uniforms = ce2.getUniforms(e3), e3.onBuild(n3, a3, A2), e3.onBeforeCompile(a3, A2), u3 = ce2.acquireProgram(a3, l3), c3.set(l3, u3), r2.uniforms = a3.uniforms;
        const p3 = r2.uniforms;
        (e3.isShaderMaterial || e3.isRawShaderMaterial) && true !== e3.clipping || (p3.clippingPlanes = he2.uniform), Ze2(e3, a3), r2.needsLights = function(e4) {
          return e4.isMeshLambertMaterial || e4.isMeshToonMaterial || e4.isMeshPhongMaterial || e4.isMeshStandardMaterial || e4.isShadowMaterial || e4.isShaderMaterial && true === e4.lights;
        }(e3), r2.lightsStateVersion = o3, r2.needsLights && (p3.ambientLightColor.value = i3.state.ambient, p3.lightProbe.value = i3.state.probe, p3.directionalLights.value = i3.state.directional, p3.directionalLightShadows.value = i3.state.directionalShadow, p3.spotLights.value = i3.state.spot, p3.spotLightShadows.value = i3.state.spotShadow, p3.rectAreaLights.value = i3.state.rectArea, p3.ltc_1.value = i3.state.rectAreaLTC1, p3.ltc_2.value = i3.state.rectAreaLTC2, p3.pointLights.value = i3.state.point, p3.pointLightShadows.value = i3.state.pointShadow, p3.hemisphereLights.value = i3.state.hemi, p3.directionalShadowMap.value = i3.state.directionalShadowMap, p3.directionalShadowMatrix.value = i3.state.directionalShadowMatrix, p3.spotShadowMap.value = i3.state.spotShadowMap, p3.spotLightMatrix.value = i3.state.spotLightMatrix, p3.spotLightMap.value = i3.state.spotLightMap, p3.pointShadowMap.value = i3.state.pointShadowMap, p3.pointShadowMatrix.value = i3.state.pointShadowMatrix);
        const d3 = u3.getUniforms(), h3 = Ga.seqWithValue(d3.seq, p3);
        return r2.currentProgram = u3, r2.uniformsList = h3, u3;
      }
      function Ze2(e3, t3) {
        const n3 = ne2.get(e3);
        n3.outputColorSpace = t3.outputColorSpace, n3.instancing = t3.instancing, n3.skinning = t3.skinning, n3.morphTargets = t3.morphTargets, n3.morphNormals = t3.morphNormals, n3.morphColors = t3.morphColors, n3.morphTargetsCount = t3.morphTargetsCount, n3.numClippingPlanes = t3.numClippingPlanes, n3.numIntersection = t3.numClipIntersection, n3.vertexAlphas = t3.vertexAlphas, n3.vertexTangents = t3.vertexTangents, n3.toneMapping = t3.toneMapping;
      }
      We2.setAnimationLoop(function(e3) {
        ze2 && ze2(e3);
      }), "undefined" != typeof self && We2.setContext(self), this.setAnimationLoop = function(e3) {
        ze2 = e3, Oe2.setAnimationLoop(e3), null === e3 ? We2.stop() : We2.start();
      }, Oe2.addEventListener("sessionstart", He2), Oe2.addEventListener("sessionend", Qe2), this.render = function(e3, t3) {
        if (void 0 === t3 || true === t3.isCamera) {
          if (true !== x2) {
            if (true === e3.matrixWorldAutoUpdate && e3.updateMatrixWorld(), null === t3.parent && true === t3.matrixWorldAutoUpdate && t3.updateMatrixWorld(), true === Oe2.enabled && true === Oe2.isPresenting && (t3 = Oe2.updateCameraXR(t3)), true === e3.isScene && e3.onBeforeRender(A2, e3, t3, S2), y2 = de2.get(e3, w2.length), y2.init(), w2.push(y2), W2.multiplyMatrices(t3.projectionMatrix, t3.matrixWorldInverse), G2.setFromProjectionMatrix(W2), H2 = this.localClippingEnabled, V2 = he2.init(this.clippingPlanes, H2), v2 = pe2.get(e3, b2.length), v2.init(), b2.push(v2), qe2(e3, t3, 0, A2.sortObjects), v2.finish(), true === A2.sortObjects && v2.sort(U2, F2), false !== A2.userData.shadowMapRender) {
              true === V2 && he2.beginShadows();
              const n3 = y2.state.shadowsArray;
              n3.length > 0 && fe2.render(n3, e3, t3), true === V2 && he2.endShadows();
            }
            if (true === this.info.autoReset && this.info.reset(), this.info.render.frame++, false !== A2.userData.backgroundRender && me2.render(v2, e3), false !== A2.userData.sceneRender)
              if (y2.setupLights(A2.useLegacyLights), t3.isArrayCamera) {
                const n3 = t3.cameras;
                for (let t4 = 0, r2 = n3.length; t4 < r2; t4++) {
                  const r3 = n3[t4];
                  Xe2(v2, e3, r3, r3.viewport);
                }
              } else
                Xe2(v2, e3, t3);
            null !== S2 && (re2.updateMultisampleRenderTarget(S2), re2.updateRenderTargetMipmap(S2)), true === e3.isScene && e3.onAfterRender(A2, e3, t3), we2.resetDefaultState(), M2 = -1, T2 = null, w2.pop(), y2 = w2.length > 0 ? w2[w2.length - 1] : null, b2.pop(), v2 = b2.length > 0 ? b2[b2.length - 1] : null;
          }
        } else
          console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      }, this.getActiveCubeFace = function() {
        return E2;
      }, this.getActiveMipmapLevel = function() {
        return C2;
      }, this.getRenderTarget = function() {
        return S2;
      }, this.setRenderTargetTextures = function(e3, t3, n3) {
        ne2.get(e3.texture).__webglTexture = t3, ne2.get(e3.depthTexture).__webglTexture = n3;
        const r2 = ne2.get(e3);
        r2.__hasExternalTextures = true, r2.__hasExternalTextures && (r2.__autoAllocateDepthBuffer = void 0 === n3, r2.__autoAllocateDepthBuffer || true === Z2.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), r2.__useRenderToTexture = false));
      }, this.setRenderTargetFramebuffer = function(e3, t3) {
        const n3 = ne2.get(e3);
        n3.__webglFramebuffer = t3, n3.__useDefaultFramebuffer = void 0 === t3;
      }, this.setRenderTarget = function(e3, t3 = 0, n3 = 0) {
        S2 = e3, E2 = t3, C2 = n3;
        let r2 = true, i3 = null, s3 = false, o3 = false;
        if (e3) {
          const n4 = ne2.get(e3);
          void 0 !== n4.__useDefaultFramebuffer ? (ee2.bindFramebuffer(Ee2.FRAMEBUFFER, null), r2 = false) : void 0 === n4.__webglFramebuffer ? re2.setupRenderTarget(e3) : n4.__hasExternalTextures && re2.rebindTextures(e3, ne2.get(e3.texture).__webglTexture, ne2.get(e3.depthTexture).__webglTexture);
          const a3 = e3.texture;
          (a3.isData3DTexture || a3.isDataArrayTexture || a3.isCompressedArrayTexture) && (o3 = true);
          const l3 = ne2.get(e3).__webglFramebuffer;
          e3.isWebGLCubeRenderTarget ? (i3 = l3[t3], s3 = true) : i3 = $2.isWebGL2 && e3.samples > 0 && false === re2.useMultisampledRTT(e3) ? ne2.get(e3).__webglMultisampledFramebuffer : l3, P2.copy(e3.viewport), I2.copy(e3.scissor), R2 = e3.scissorTest;
        } else
          P2.copy(N2).multiplyScalar(L2).floor(), I2.copy(j2).multiplyScalar(L2).floor(), R2 = z2;
        if (ee2.bindFramebuffer(Ee2.FRAMEBUFFER, i3) && $2.drawBuffers && r2 && ee2.drawBuffers(e3, i3), ee2.viewport(P2), ee2.scissor(I2), ee2.setScissorTest(R2), s3) {
          const r3 = ne2.get(e3.texture);
          Ee2.framebufferTexture2D(Ee2.FRAMEBUFFER, Ee2.COLOR_ATTACHMENT0, Ee2.TEXTURE_CUBE_MAP_POSITIVE_X + t3, r3.__webglTexture, n3);
        } else if (o3) {
          const r3 = ne2.get(e3.texture), i4 = t3 || 0;
          Ee2.framebufferTextureLayer(Ee2.FRAMEBUFFER, Ee2.COLOR_ATTACHMENT0, r3.__webglTexture, n3 || 0, i4);
        }
        M2 = -1;
      }, this.readRenderTargetPixels = function(e3, t3, n3, r2, i3, s3, o3, a3) {
        if (!e3 || !e3.isWebGLRenderTarget)
          return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        let l3 = ne2.get(e3).__webglFramebuffer;
        if (e3.isWebGLCubeRenderTarget && void 0 !== o3 && (l3 = l3[o3]), l3) {
          ee2.bindFramebuffer(Ee2.FRAMEBUFFER, l3);
          try {
            const o4 = Array.isArray(e3.texture) ? e3.texture[a3 || 0] : e3.texture, l4 = o4.format, c3 = o4.type;
            if (l4 !== Be && ye2.convert(l4) !== Ee2.getParameter(Ee2.IMPLEMENTATION_COLOR_READ_FORMAT))
              return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            const u3 = c3 === Pe && (Z2.has("EXT_color_buffer_half_float") || $2.isWebGL2 && Z2.has("EXT_color_buffer_float"));
            if (!(c3 === Ae || ye2.convert(c3) === Ee2.getParameter(Ee2.IMPLEMENTATION_COLOR_READ_TYPE) || c3 === Te && ($2.isWebGL2 || Z2.has("OES_texture_float") || Z2.has("WEBGL_color_buffer_float")) || u3))
              return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            t3 >= 0 && t3 <= e3.width - r2 && n3 >= 0 && n3 <= e3.height - i3 && (e3.isWebGLMultipleRenderTargets && Ee2.readBuffer(Ee2.COLOR_ATTACHMENT0 + a3), Ee2.readPixels(t3, n3, r2, i3, ye2.convert(l4), ye2.convert(c3), s3));
          } finally {
            const e4 = S2 ? ne2.get(S2).__webglFramebuffer : null;
            ee2.bindFramebuffer(Ee2.FRAMEBUFFER, e4);
          }
        }
      }, this.copyFramebufferToTexture = function(e3, t3, n3 = 0) {
        const r2 = Math.pow(2, -n3), i3 = Math.floor(t3.image.width * r2), s3 = Math.floor(t3.image.height * r2);
        re2.setTexture2D(t3, 0), Ee2.copyTexSubImage2D(Ee2.TEXTURE_2D, n3, 0, 0, e3.x, e3.y, i3, s3), ee2.unbindTexture();
      }, this.copyTextureToTexture = function(e3, t3, n3, r2 = 0) {
        const i3 = t3.image.width, s3 = t3.image.height, o3 = ye2.convert(n3.format), a3 = ye2.convert(n3.type);
        re2.setTexture2D(n3, 0), Ee2.pixelStorei(Ee2.UNPACK_FLIP_Y_WEBGL, n3.flipY), Ee2.pixelStorei(Ee2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n3.premultiplyAlpha), Ee2.pixelStorei(Ee2.UNPACK_ALIGNMENT, n3.unpackAlignment), t3.isDataTexture ? Ee2.texSubImage2D(Ee2.TEXTURE_2D, r2, e3.x, e3.y, i3, s3, o3, a3, t3.image.data) : t3.isCompressedTexture ? Ee2.compressedTexSubImage2D(Ee2.TEXTURE_2D, r2, e3.x, e3.y, t3.mipmaps[0].width, t3.mipmaps[0].height, o3, t3.mipmaps[0].data) : Ee2.texSubImage2D(Ee2.TEXTURE_2D, r2, e3.x, e3.y, o3, a3, t3.image), 0 === r2 && n3.generateMipmaps && Ee2.generateMipmap(Ee2.TEXTURE_2D), ee2.unbindTexture();
      }, this.copyTextureToTexture3D = function(e3, t3, n3, r2, i3 = 0) {
        if (A2.isWebGL1Renderer)
          return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        const s3 = e3.max.x - e3.min.x + 1, o3 = e3.max.y - e3.min.y + 1, a3 = e3.max.z - e3.min.z + 1, l3 = ye2.convert(r2.format), c3 = ye2.convert(r2.type);
        let u3;
        if (r2.isData3DTexture)
          re2.setTexture3D(r2, 0), u3 = Ee2.TEXTURE_3D;
        else {
          if (!r2.isDataArrayTexture)
            return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
          re2.setTexture2DArray(r2, 0), u3 = Ee2.TEXTURE_2D_ARRAY;
        }
        Ee2.pixelStorei(Ee2.UNPACK_FLIP_Y_WEBGL, r2.flipY), Ee2.pixelStorei(Ee2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r2.premultiplyAlpha), Ee2.pixelStorei(Ee2.UNPACK_ALIGNMENT, r2.unpackAlignment);
        const p3 = Ee2.getParameter(Ee2.UNPACK_ROW_LENGTH), d3 = Ee2.getParameter(Ee2.UNPACK_IMAGE_HEIGHT), h3 = Ee2.getParameter(Ee2.UNPACK_SKIP_PIXELS), f2 = Ee2.getParameter(Ee2.UNPACK_SKIP_ROWS), m2 = Ee2.getParameter(Ee2.UNPACK_SKIP_IMAGES), _2 = n3.isCompressedTexture ? n3.mipmaps[0] : n3.image;
        Ee2.pixelStorei(Ee2.UNPACK_ROW_LENGTH, _2.width), Ee2.pixelStorei(Ee2.UNPACK_IMAGE_HEIGHT, _2.height), Ee2.pixelStorei(Ee2.UNPACK_SKIP_PIXELS, e3.min.x), Ee2.pixelStorei(Ee2.UNPACK_SKIP_ROWS, e3.min.y), Ee2.pixelStorei(Ee2.UNPACK_SKIP_IMAGES, e3.min.z), n3.isDataTexture || n3.isData3DTexture ? Ee2.texSubImage3D(u3, i3, t3.x, t3.y, t3.z, s3, o3, a3, l3, c3, _2.data) : n3.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), Ee2.compressedTexSubImage3D(u3, i3, t3.x, t3.y, t3.z, s3, o3, a3, l3, _2.data)) : Ee2.texSubImage3D(u3, i3, t3.x, t3.y, t3.z, s3, o3, a3, l3, c3, _2), Ee2.pixelStorei(Ee2.UNPACK_ROW_LENGTH, p3), Ee2.pixelStorei(Ee2.UNPACK_IMAGE_HEIGHT, d3), Ee2.pixelStorei(Ee2.UNPACK_SKIP_PIXELS, h3), Ee2.pixelStorei(Ee2.UNPACK_SKIP_ROWS, f2), Ee2.pixelStorei(Ee2.UNPACK_SKIP_IMAGES, m2), 0 === i3 && r2.generateMipmaps && Ee2.generateMipmap(u3), ee2.unbindTexture();
      }, this.initTexture = function(e3) {
        e3.isCubeTexture ? re2.setTextureCube(e3, 0) : e3.isData3DTexture ? re2.setTexture3D(e3, 0) : e3.isDataArrayTexture || e3.isCompressedArrayTexture ? re2.setTexture2DArray(e3, 0) : re2.setTexture2D(e3, 0), ee2.unbindTexture();
      }, this.resetState = function() {
        E2 = 0, C2 = 0, S2 = null, ee2.reset(), we2.reset();
      }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
    get coordinateSystem() {
      return Tn;
    }
    get physicallyCorrectLights() {
      return console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), !this.useLegacyLights;
    }
    set physicallyCorrectLights(e2) {
      console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), this.useLegacyLights = !e2;
    }
    get outputEncoding() {
      return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace === zt ? Ot : Bt;
    }
    set outputEncoding(e2) {
      console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace = e2 === Ot ? zt : Gt;
    }
  }
  class jl extends Nl {
  }
  jl.prototype.isWebGL1Renderer = true;
  class zl {
    constructor(e2, t2 = 25e-5) {
      this.isFogExp2 = true, this.name = "", this.color = new Vi(e2), this.density = t2;
    }
    clone() {
      return new zl(this.color, this.density);
    }
    toJSON() {
      return { type: "FogExp2", color: this.color.getHex(), density: this.density };
    }
  }
  class Gl {
    constructor(e2, t2 = 1, n2 = 1e3) {
      this.isFog = true, this.name = "", this.color = new Vi(e2), this.near = t2, this.far = n2;
    }
    clone() {
      return new Gl(this.color, this.near, this.far);
    }
    toJSON() {
      return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far };
    }
  }
  class Vl extends xi {
    constructor() {
      super(), this.isScene = true, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
    copy(e2, t2) {
      return super.copy(e2, t2), null !== e2.background && (this.background = e2.background.clone()), null !== e2.environment && (this.environment = e2.environment.clone()), null !== e2.fog && (this.fog = e2.fog.clone()), this.backgroundBlurriness = e2.backgroundBlurriness, this.backgroundIntensity = e2.backgroundIntensity, null !== e2.overrideMaterial && (this.overrideMaterial = e2.overrideMaterial.clone()), this.matrixAutoUpdate = e2.matrixAutoUpdate, this;
    }
    toJSON(e2) {
      const t2 = super.toJSON(e2);
      return null !== this.fog && (t2.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t2.object.backgroundBlurriness = this.backgroundBlurriness), 1 !== this.backgroundIntensity && (t2.object.backgroundIntensity = this.backgroundIntensity), t2;
    }
    get autoUpdate() {
      return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate;
    }
    set autoUpdate(e2) {
      console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate = e2;
    }
  }
  class Hl {
    constructor(e2, t2) {
      this.isInterleavedBuffer = true, this.array = e2, this.stride = t2, this.count = void 0 !== e2 ? e2.length / t2 : 0, this.usage = _n, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = On();
    }
    onUploadCallback() {
    }
    set needsUpdate(e2) {
      true === e2 && this.version++;
    }
    setUsage(e2) {
      return this.usage = e2, this;
    }
    copy(e2) {
      return this.array = new e2.array.constructor(e2.array), this.count = e2.count, this.stride = e2.stride, this.usage = e2.usage, this;
    }
    copyAt(e2, t2, n2) {
      e2 *= this.stride, n2 *= t2.stride;
      for (let r2 = 0, i2 = this.stride; r2 < i2; r2++)
        this.array[e2 + r2] = t2.array[n2 + r2];
      return this;
    }
    set(e2, t2 = 0) {
      return this.array.set(e2, t2), this;
    }
    clone(e2) {
      void 0 === e2.arrayBuffers && (e2.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = On()), void 0 === e2.arrayBuffers[this.array.buffer._uuid] && (e2.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
      const t2 = new this.array.constructor(e2.arrayBuffers[this.array.buffer._uuid]), n2 = new this.constructor(t2, this.stride);
      return n2.setUsage(this.usage), n2;
    }
    onUpload(e2) {
      return this.onUploadCallback = e2, this;
    }
    toJSON(e2) {
      return void 0 === e2.arrayBuffers && (e2.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = On()), void 0 === e2.arrayBuffers[this.array.buffer._uuid] && (e2.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride };
    }
  }
  const Ql = new Ar();
  class Wl {
    constructor(e2, t2, n2, r2 = false) {
      this.isInterleavedBufferAttribute = true, this.name = "", this.data = e2, this.itemSize = t2, this.offset = n2, this.normalized = r2;
    }
    get count() {
      return this.data.count;
    }
    get array() {
      return this.data.array;
    }
    set needsUpdate(e2) {
      this.data.needsUpdate = e2;
    }
    applyMatrix4(e2) {
      for (let t2 = 0, n2 = this.data.count; t2 < n2; t2++)
        Ql.fromBufferAttribute(this, t2), Ql.applyMatrix4(e2), this.setXYZ(t2, Ql.x, Ql.y, Ql.z);
      return this;
    }
    applyNormalMatrix(e2) {
      for (let t2 = 0, n2 = this.count; t2 < n2; t2++)
        Ql.fromBufferAttribute(this, t2), Ql.applyNormalMatrix(e2), this.setXYZ(t2, Ql.x, Ql.y, Ql.z);
      return this;
    }
    transformDirection(e2) {
      for (let t2 = 0, n2 = this.count; t2 < n2; t2++)
        Ql.fromBufferAttribute(this, t2), Ql.transformDirection(e2), this.setXYZ(t2, Ql.x, Ql.y, Ql.z);
      return this;
    }
    setX(e2, t2) {
      return this.normalized && (t2 = Vn(t2, this.array)), this.data.array[e2 * this.data.stride + this.offset] = t2, this;
    }
    setY(e2, t2) {
      return this.normalized && (t2 = Vn(t2, this.array)), this.data.array[e2 * this.data.stride + this.offset + 1] = t2, this;
    }
    setZ(e2, t2) {
      return this.normalized && (t2 = Vn(t2, this.array)), this.data.array[e2 * this.data.stride + this.offset + 2] = t2, this;
    }
    setW(e2, t2) {
      return this.normalized && (t2 = Vn(t2, this.array)), this.data.array[e2 * this.data.stride + this.offset + 3] = t2, this;
    }
    getX(e2) {
      let t2 = this.data.array[e2 * this.data.stride + this.offset];
      return this.normalized && (t2 = Gn(t2, this.array)), t2;
    }
    getY(e2) {
      let t2 = this.data.array[e2 * this.data.stride + this.offset + 1];
      return this.normalized && (t2 = Gn(t2, this.array)), t2;
    }
    getZ(e2) {
      let t2 = this.data.array[e2 * this.data.stride + this.offset + 2];
      return this.normalized && (t2 = Gn(t2, this.array)), t2;
    }
    getW(e2) {
      let t2 = this.data.array[e2 * this.data.stride + this.offset + 3];
      return this.normalized && (t2 = Gn(t2, this.array)), t2;
    }
    setXY(e2, t2, n2) {
      return e2 = e2 * this.data.stride + this.offset, this.normalized && (t2 = Vn(t2, this.array), n2 = Vn(n2, this.array)), this.data.array[e2 + 0] = t2, this.data.array[e2 + 1] = n2, this;
    }
    setXYZ(e2, t2, n2, r2) {
      return e2 = e2 * this.data.stride + this.offset, this.normalized && (t2 = Vn(t2, this.array), n2 = Vn(n2, this.array), r2 = Vn(r2, this.array)), this.data.array[e2 + 0] = t2, this.data.array[e2 + 1] = n2, this.data.array[e2 + 2] = r2, this;
    }
    setXYZW(e2, t2, n2, r2, i2) {
      return e2 = e2 * this.data.stride + this.offset, this.normalized && (t2 = Vn(t2, this.array), n2 = Vn(n2, this.array), r2 = Vn(r2, this.array), i2 = Vn(i2, this.array)), this.data.array[e2 + 0] = t2, this.data.array[e2 + 1] = n2, this.data.array[e2 + 2] = r2, this.data.array[e2 + 3] = i2, this;
    }
    clone(e2) {
      if (void 0 === e2) {
        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
        const e3 = [];
        for (let t2 = 0; t2 < this.count; t2++) {
          const n2 = t2 * this.data.stride + this.offset;
          for (let t3 = 0; t3 < this.itemSize; t3++)
            e3.push(this.data.array[n2 + t3]);
        }
        return new $i(new this.array.constructor(e3), this.itemSize, this.normalized);
      }
      return void 0 === e2.interleavedBuffers && (e2.interleavedBuffers = {}), void 0 === e2.interleavedBuffers[this.data.uuid] && (e2.interleavedBuffers[this.data.uuid] = this.data.clone(e2)), new Wl(e2.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
    toJSON(e2) {
      if (void 0 === e2) {
        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
        const e3 = [];
        for (let t2 = 0; t2 < this.count; t2++) {
          const n2 = t2 * this.data.stride + this.offset;
          for (let t3 = 0; t3 < this.itemSize; t3++)
            e3.push(this.data.array[n2 + t3]);
        }
        return { itemSize: this.itemSize, type: this.array.constructor.name, array: e3, normalized: this.normalized };
      }
      return void 0 === e2.interleavedBuffers && (e2.interleavedBuffers = {}), void 0 === e2.interleavedBuffers[this.data.uuid] && (e2.interleavedBuffers[this.data.uuid] = this.data.toJSON(e2)), { isInterleavedBufferAttribute: true, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized };
    }
  }
  class ql extends Ui {
    constructor(e2) {
      super(), this.isSpriteMaterial = true, this.type = "SpriteMaterial", this.color = new Vi(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = true, this.transparent = true, this.fog = true, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.color.copy(e2.color), this.map = e2.map, this.alphaMap = e2.alphaMap, this.rotation = e2.rotation, this.sizeAttenuation = e2.sizeAttenuation, this.fog = e2.fog, this;
    }
  }
  let Xl;
  const Yl = new Ar(), Kl = new Ar(), Jl = new Ar(), Zl = new Qn(), $l = new Qn(), ec = new Zr(), tc = new Ar(), nc = new Ar(), rc = new Ar(), ic = new Qn(), sc = new Qn(), oc = new Qn();
  class ac extends xi {
    constructor(e2) {
      if (super(), this.isSprite = true, this.type = "Sprite", void 0 === Xl) {
        Xl = new gs();
        const e3 = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]), t2 = new Hl(e3, 5);
        Xl.setIndex([0, 1, 2, 0, 2, 3]), Xl.setAttribute("position", new Wl(t2, 3, 0, false)), Xl.setAttribute("uv", new Wl(t2, 2, 3, false));
      }
      this.geometry = Xl, this.material = void 0 !== e2 ? e2 : new ql(), this.center = new Qn(0.5, 0.5);
    }
    raycast(e2, t2) {
      null === e2.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Kl.setFromMatrixScale(this.matrixWorld), ec.copy(e2.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e2.camera.matrixWorldInverse, this.matrixWorld), Jl.setFromMatrixPosition(this.modelViewMatrix), e2.camera.isPerspectiveCamera && false === this.material.sizeAttenuation && Kl.multiplyScalar(-Jl.z);
      const n2 = this.material.rotation;
      let r2, i2;
      0 !== n2 && (i2 = Math.cos(n2), r2 = Math.sin(n2));
      const s2 = this.center;
      lc(tc.set(-0.5, -0.5, 0), Jl, s2, Kl, r2, i2), lc(nc.set(0.5, -0.5, 0), Jl, s2, Kl, r2, i2), lc(rc.set(0.5, 0.5, 0), Jl, s2, Kl, r2, i2), ic.set(0, 0), sc.set(1, 0), oc.set(1, 1);
      let o2 = e2.ray.intersectTriangle(tc, nc, rc, false, Yl);
      if (null === o2 && (lc(nc.set(-0.5, 0.5, 0), Jl, s2, Kl, r2, i2), sc.set(0, 1), o2 = e2.ray.intersectTriangle(tc, rc, nc, false, Yl), null === o2))
        return;
      const a2 = e2.ray.origin.distanceTo(Yl);
      a2 < e2.near || a2 > e2.far || t2.push({ distance: a2, point: Yl.clone(), uv: Oi.getInterpolation(Yl, tc, nc, rc, ic, sc, oc, new Qn()), face: null, object: this });
    }
    copy(e2, t2) {
      return super.copy(e2, t2), void 0 !== e2.center && this.center.copy(e2.center), this.material = e2.material, this;
    }
  }
  function lc(e2, t2, n2, r2, i2, s2) {
    Zl.subVectors(e2, n2).addScalar(0.5).multiply(r2), void 0 !== i2 ? ($l.x = s2 * Zl.x - i2 * Zl.y, $l.y = i2 * Zl.x + s2 * Zl.y) : $l.copy(Zl), e2.copy(t2), e2.x += $l.x, e2.y += $l.y, e2.applyMatrix4(ec);
  }
  const cc = new Ar(), uc = new Ar();
  class pc extends xi {
    constructor() {
      super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: true, value: [] }, isLOD: { value: true } }), this.autoUpdate = true;
    }
    copy(e2) {
      super.copy(e2, false);
      const t2 = e2.levels;
      for (let e3 = 0, n2 = t2.length; e3 < n2; e3++) {
        const n3 = t2[e3];
        this.addLevel(n3.object.clone(), n3.distance, n3.hysteresis);
      }
      return this.autoUpdate = e2.autoUpdate, this;
    }
    addLevel(e2, t2 = 0, n2 = 0) {
      t2 = Math.abs(t2);
      const r2 = this.levels;
      let i2;
      for (i2 = 0; i2 < r2.length && !(t2 < r2[i2].distance); i2++)
        ;
      return r2.splice(i2, 0, { distance: t2, hysteresis: n2, object: e2 }), this.add(e2), this;
    }
    getCurrentLevel() {
      return this._currentLevel;
    }
    getObjectForDistance(e2) {
      const t2 = this.levels;
      if (t2.length > 0) {
        let n2, r2;
        for (n2 = 1, r2 = t2.length; n2 < r2; n2++) {
          let r3 = t2[n2].distance;
          if (t2[n2].object.visible && (r3 -= r3 * t2[n2].hysteresis), e2 < r3)
            break;
        }
        return t2[n2 - 1].object;
      }
      return null;
    }
    raycast(e2, t2) {
      if (this.levels.length > 0) {
        cc.setFromMatrixPosition(this.matrixWorld);
        const n2 = e2.ray.origin.distanceTo(cc);
        this.getObjectForDistance(n2).raycast(e2, t2);
      }
    }
    update(e2) {
      const t2 = this.levels;
      if (t2.length > 1) {
        cc.setFromMatrixPosition(e2.matrixWorld), uc.setFromMatrixPosition(this.matrixWorld);
        const n2 = cc.distanceTo(uc) / e2.zoom;
        let r2, i2;
        for (t2[0].object.visible = true, r2 = 1, i2 = t2.length; r2 < i2; r2++) {
          let e3 = t2[r2].distance;
          if (t2[r2].object.visible && (e3 -= e3 * t2[r2].hysteresis), !(n2 >= e3))
            break;
          t2[r2 - 1].object.visible = false, t2[r2].object.visible = true;
        }
        for (this._currentLevel = r2 - 1; r2 < i2; r2++)
          t2[r2].object.visible = false;
      }
    }
    toJSON(e2) {
      const t2 = super.toJSON(e2);
      false === this.autoUpdate && (t2.object.autoUpdate = false), t2.object.levels = [];
      const n2 = this.levels;
      for (let e3 = 0, r2 = n2.length; e3 < r2; e3++) {
        const r3 = n2[e3];
        t2.object.levels.push({ object: r3.object.uuid, distance: r3.distance, hysteresis: r3.hysteresis });
      }
      return t2;
    }
  }
  const dc = new Ar(), hc = new fr(), fc = new fr(), mc = new Ar(), _c = new Zr(), gc = new Ar(), vc = new Vr(), yc = new Zr(), bc = new Jr();
  class wc extends Os {
    constructor(e2, t2) {
      super(e2, t2), this.isSkinnedMesh = true, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Zr(), this.bindMatrixInverse = new Zr(), this.boundingBox = null, this.boundingSphere = null;
    }
    computeBoundingBox() {
      const e2 = this.geometry;
      null === this.boundingBox && (this.boundingBox = new Cr()), this.boundingBox.makeEmpty();
      const t2 = e2.getAttribute("position");
      for (let e3 = 0; e3 < t2.count; e3++)
        gc.fromBufferAttribute(t2, e3), this.applyBoneTransform(e3, gc), this.boundingBox.expandByPoint(gc);
    }
    computeBoundingSphere() {
      const e2 = this.geometry;
      null === this.boundingSphere && (this.boundingSphere = new Vr()), this.boundingSphere.makeEmpty();
      const t2 = e2.getAttribute("position");
      for (let e3 = 0; e3 < t2.count; e3++)
        gc.fromBufferAttribute(t2, e3), this.applyBoneTransform(e3, gc), this.boundingSphere.expandByPoint(gc);
    }
    copy(e2, t2) {
      return super.copy(e2, t2), this.bindMode = e2.bindMode, this.bindMatrix.copy(e2.bindMatrix), this.bindMatrixInverse.copy(e2.bindMatrixInverse), this.skeleton = e2.skeleton, null !== e2.boundingBox && (this.boundingBox = e2.boundingBox.clone()), null !== e2.boundingSphere && (this.boundingSphere = e2.boundingSphere.clone()), this;
    }
    raycast(e2, t2) {
      const n2 = this.material, r2 = this.matrixWorld;
      void 0 !== n2 && (null === this.boundingSphere && this.computeBoundingSphere(), vc.copy(this.boundingSphere), vc.applyMatrix4(r2), false !== e2.ray.intersectsSphere(vc) && (yc.copy(r2).invert(), bc.copy(e2.ray).applyMatrix4(yc), null !== this.boundingBox && false === bc.intersectsBox(this.boundingBox) || this._computeIntersections(e2, t2, bc)));
    }
    getVertexPosition(e2, t2) {
      return super.getVertexPosition(e2, t2), this.applyBoneTransform(e2, t2), t2;
    }
    bind(e2, t2) {
      this.skeleton = e2, void 0 === t2 && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), t2 = this.matrixWorld), this.bindMatrix.copy(t2), this.bindMatrixInverse.copy(t2).invert();
    }
    pose() {
      this.skeleton.pose();
    }
    normalizeSkinWeights() {
      const e2 = new fr(), t2 = this.geometry.attributes.skinWeight;
      for (let n2 = 0, r2 = t2.count; n2 < r2; n2++) {
        e2.fromBufferAttribute(t2, n2);
        const r3 = 1 / e2.manhattanLength();
        r3 !== 1 / 0 ? e2.multiplyScalar(r3) : e2.set(1, 0, 0, 0), t2.setXYZW(n2, e2.x, e2.y, e2.z, e2.w);
      }
    }
    updateMatrixWorld(e2) {
      super.updateMatrixWorld(e2), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
    applyBoneTransform(e2, t2) {
      const n2 = this.skeleton, r2 = this.geometry;
      hc.fromBufferAttribute(r2.attributes.skinIndex, e2), fc.fromBufferAttribute(r2.attributes.skinWeight, e2), dc.copy(t2).applyMatrix4(this.bindMatrix), t2.set(0, 0, 0);
      for (let e3 = 0; e3 < 4; e3++) {
        const r3 = fc.getComponent(e3);
        if (0 !== r3) {
          const i2 = hc.getComponent(e3);
          _c.multiplyMatrices(n2.bones[i2].matrixWorld, n2.boneInverses[i2]), t2.addScaledVector(mc.copy(dc).applyMatrix4(_c), r3);
        }
      }
      return t2.applyMatrix4(this.bindMatrixInverse);
    }
    boneTransform(e2, t2) {
      return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."), this.applyBoneTransform(e2, t2);
    }
  }
  class Ac extends xi {
    constructor() {
      super(), this.isBone = true, this.type = "Bone";
    }
  }
  class xc extends hr {
    constructor(e2 = null, t2 = 1, n2 = 1, r2, i2, s2, o2, a2, l2 = de, c2 = de, u2, p2) {
      super(null, s2, o2, a2, l2, c2, r2, i2, u2, p2), this.isDataTexture = true, this.image = { data: e2, width: t2, height: n2 }, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
    }
  }
  const Ec = new Zr(), Cc = new Zr();
  class Sc {
    constructor(e2 = [], t2 = []) {
      this.uuid = On(), this.bones = e2.slice(0), this.boneInverses = t2, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init();
    }
    init() {
      const e2 = this.bones, t2 = this.boneInverses;
      if (this.boneMatrices = new Float32Array(16 * e2.length), 0 === t2.length)
        this.calculateInverses();
      else if (e2.length !== t2.length) {
        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
        for (let e3 = 0, t3 = this.bones.length; e3 < t3; e3++)
          this.boneInverses.push(new Zr());
      }
    }
    calculateInverses() {
      this.boneInverses.length = 0;
      for (let e2 = 0, t2 = this.bones.length; e2 < t2; e2++) {
        const t3 = new Zr();
        this.bones[e2] && t3.copy(this.bones[e2].matrixWorld).invert(), this.boneInverses.push(t3);
      }
    }
    pose() {
      for (let e2 = 0, t2 = this.bones.length; e2 < t2; e2++) {
        const t3 = this.bones[e2];
        t3 && t3.matrixWorld.copy(this.boneInverses[e2]).invert();
      }
      for (let e2 = 0, t2 = this.bones.length; e2 < t2; e2++) {
        const t3 = this.bones[e2];
        t3 && (t3.parent && t3.parent.isBone ? (t3.matrix.copy(t3.parent.matrixWorld).invert(), t3.matrix.multiply(t3.matrixWorld)) : t3.matrix.copy(t3.matrixWorld), t3.matrix.decompose(t3.position, t3.quaternion, t3.scale));
      }
    }
    update() {
      const e2 = this.bones, t2 = this.boneInverses, n2 = this.boneMatrices, r2 = this.boneTexture;
      for (let r3 = 0, i2 = e2.length; r3 < i2; r3++) {
        const i3 = e2[r3] ? e2[r3].matrixWorld : Cc;
        Ec.multiplyMatrices(i3, t2[r3]), Ec.toArray(n2, 16 * r3);
      }
      null !== r2 && (r2.needsUpdate = true);
    }
    clone() {
      return new Sc(this.bones, this.boneInverses);
    }
    computeBoneTexture() {
      let e2 = Math.sqrt(4 * this.bones.length);
      e2 = jn(e2), e2 = Math.max(e2, 4);
      const t2 = new Float32Array(e2 * e2 * 4);
      t2.set(this.boneMatrices);
      const n2 = new xc(t2, e2, e2, Be, Te);
      return n2.needsUpdate = true, this.boneMatrices = t2, this.boneTexture = n2, this.boneTextureSize = e2, this;
    }
    getBoneByName(e2) {
      for (let t2 = 0, n2 = this.bones.length; t2 < n2; t2++) {
        const n3 = this.bones[t2];
        if (n3.name === e2)
          return n3;
      }
    }
    dispose() {
      null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null);
    }
    fromJSON(e2, t2) {
      this.uuid = e2.uuid;
      for (let n2 = 0, r2 = e2.bones.length; n2 < r2; n2++) {
        const r3 = e2.bones[n2];
        let i2 = t2[r3];
        void 0 === i2 && (console.warn("THREE.Skeleton: No bone found with UUID:", r3), i2 = new Ac()), this.bones.push(i2), this.boneInverses.push(new Zr().fromArray(e2.boneInverses[n2]));
      }
      return this.init(), this;
    }
    toJSON() {
      const e2 = { metadata: { version: 4.6, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] };
      e2.uuid = this.uuid;
      const t2 = this.bones, n2 = this.boneInverses;
      for (let r2 = 0, i2 = t2.length; r2 < i2; r2++) {
        const i3 = t2[r2];
        e2.bones.push(i3.uuid);
        const s2 = n2[r2];
        e2.boneInverses.push(s2.toArray());
      }
      return e2;
    }
  }
  class Mc extends $i {
    constructor(e2, t2, n2, r2 = 1) {
      super(e2, t2, n2), this.isInstancedBufferAttribute = true, this.meshPerAttribute = r2;
    }
    copy(e2) {
      return super.copy(e2), this.meshPerAttribute = e2.meshPerAttribute, this;
    }
    toJSON() {
      const e2 = super.toJSON();
      return e2.meshPerAttribute = this.meshPerAttribute, e2.isInstancedBufferAttribute = true, e2;
    }
  }
  const Tc = new Zr(), Pc = new Zr(), Ic = [], Rc = new Cr(), kc = new Zr(), Dc = new Os(), Bc = new Vr();
  class Oc extends Os {
    constructor(e2, t2, n2) {
      super(e2, t2), this.isInstancedMesh = true, this.instanceMatrix = new Mc(new Float32Array(16 * n2), 16), this.instanceColor = null, this.sourceTrs = null, this.count = n2, this.boundingBox = null, this.boundingSphere = null;
      for (let e3 = 0; e3 < n2; e3++)
        this.setMatrixAt(e3, kc);
    }
    computeBoundingBox() {
      const e2 = this.geometry, t2 = this.count;
      null === this.boundingBox && (this.boundingBox = new Cr()), null === e2.boundingBox && e2.computeBoundingBox(), this.boundingBox.makeEmpty();
      for (let n2 = 0; n2 < t2; n2++)
        this.getMatrixAt(n2, Tc), Rc.copy(e2.boundingBox).applyMatrix4(Tc), this.boundingBox.union(Rc);
    }
    computeBoundingSphere() {
      const e2 = this.geometry, t2 = this.count;
      null === this.boundingSphere && (this.boundingSphere = new Vr()), null === e2.boundingSphere && e2.computeBoundingSphere(), this.boundingSphere.makeEmpty();
      for (let n2 = 0; n2 < t2; n2++)
        this.getMatrixAt(n2, Tc), Bc.copy(e2.boundingSphere).applyMatrix4(Tc), this.boundingSphere.union(Bc);
    }
    copy(e2, t2) {
      return super.copy(e2, t2), e2.isInstancedMesh ? (this.instanceMatrix.copy(e2.instanceMatrix), null !== e2.instanceColor && (this.instanceColor = e2.instanceColor.clone()), this.count = e2.count, null !== e2.boundingBox && (this.boundingBox = e2.boundingBox.clone()), null !== e2.boundingSphere && (this.boundingSphere = e2.boundingSphere.clone()), this) : this;
    }
    getColorAt(e2, t2) {
      t2.fromArray(this.instanceColor.array, 3 * e2);
    }
    getMatrixAt(e2, t2) {
      t2.fromArray(this.instanceMatrix.array, 16 * e2);
    }
    raycast(e2, t2) {
      const n2 = this.matrixWorld, r2 = this.count;
      if (Dc.geometry = this.geometry, Dc.material = this.material, void 0 !== Dc.material && (null === this.boundingSphere && this.computeBoundingSphere(), Bc.copy(this.boundingSphere), Bc.applyMatrix4(n2), false !== e2.ray.intersectsSphere(Bc)))
        for (let i2 = 0; i2 < r2; i2++) {
          this.getMatrixAt(i2, Tc), Pc.multiplyMatrices(n2, Tc), Dc.matrixWorld = Pc, Dc.raycast(e2, Ic);
          for (let e3 = 0, n3 = Ic.length; e3 < n3; e3++) {
            const n4 = Ic[e3];
            n4.instanceId = i2, n4.object = this, t2.push(n4);
          }
          Ic.length = 0;
        }
    }
    setColorAt(e2, t2) {
      null === this.instanceColor && (this.instanceColor = new Mc(new Float32Array(3 * this.instanceMatrix.count), 3)), t2.toArray(this.instanceColor.array, 3 * e2);
    }
    setMatrixAt(e2, t2) {
      t2.toArray(this.instanceMatrix.array, 16 * e2);
    }
    updateMorphTargets() {
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  }
  class Lc extends Ui {
    constructor(e2) {
      super(), this.isLineBasicMaterial = true, this.type = "LineBasicMaterial", this.color = new Vi(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = true, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.color.copy(e2.color), this.map = e2.map, this.linewidth = e2.linewidth, this.linecap = e2.linecap, this.linejoin = e2.linejoin, this.fog = e2.fog, this;
    }
  }
  const Uc = new Ar(), Fc = new Ar(), Nc = new Zr(), jc = new Jr(), zc = new Vr();
  class Gc extends xi {
    constructor(e2 = new gs(), t2 = new Lc()) {
      super(), this.isLine = true, this.type = "Line", this.geometry = e2, this.material = t2, this.updateMorphTargets();
    }
    copy(e2, t2) {
      return super.copy(e2, t2), this.material = e2.material, this.geometry = e2.geometry, this;
    }
    computeLineDistances() {
      const e2 = this.geometry;
      if (null === e2.index) {
        const t2 = e2.attributes.position, n2 = [0];
        for (let e3 = 1, r2 = t2.count; e3 < r2; e3++)
          Uc.fromBufferAttribute(t2, e3 - 1), Fc.fromBufferAttribute(t2, e3), n2[e3] = n2[e3 - 1], n2[e3] += Uc.distanceTo(Fc);
        e2.setAttribute("lineDistance", new ls(n2, 1));
      } else
        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      return this;
    }
    raycast(e2, t2) {
      const n2 = this.geometry, r2 = this.matrixWorld, i2 = e2.params.Line.threshold, s2 = n2.drawRange;
      if (null === n2.boundingSphere && n2.computeBoundingSphere(), zc.copy(n2.boundingSphere), zc.applyMatrix4(r2), zc.radius += i2, false === e2.ray.intersectsSphere(zc))
        return;
      Nc.copy(r2).invert(), jc.copy(e2.ray).applyMatrix4(Nc);
      const o2 = i2 / ((this.scale.x + this.scale.y + this.scale.z) / 3), a2 = o2 * o2, l2 = new Ar(), c2 = new Ar(), u2 = new Ar(), p2 = new Ar(), d2 = this.isLineSegments ? 2 : 1, h2 = n2.index, f2 = n2.attributes.position;
      if (null !== h2)
        for (let n3 = Math.max(0, s2.start), r3 = Math.min(h2.count, s2.start + s2.count) - 1; n3 < r3; n3 += d2) {
          const r4 = h2.getX(n3), i3 = h2.getX(n3 + 1);
          if (l2.fromBufferAttribute(f2, r4), c2.fromBufferAttribute(f2, i3), jc.distanceSqToSegment(l2, c2, p2, u2) > a2)
            continue;
          p2.applyMatrix4(this.matrixWorld);
          const s3 = e2.ray.origin.distanceTo(p2);
          s3 < e2.near || s3 > e2.far || t2.push({ distance: s3, point: u2.clone().applyMatrix4(this.matrixWorld), index: n3, face: null, faceIndex: null, object: this });
        }
      else
        for (let n3 = Math.max(0, s2.start), r3 = Math.min(f2.count, s2.start + s2.count) - 1; n3 < r3; n3 += d2) {
          if (l2.fromBufferAttribute(f2, n3), c2.fromBufferAttribute(f2, n3 + 1), jc.distanceSqToSegment(l2, c2, p2, u2) > a2)
            continue;
          p2.applyMatrix4(this.matrixWorld);
          const r4 = e2.ray.origin.distanceTo(p2);
          r4 < e2.near || r4 > e2.far || t2.push({ distance: r4, point: u2.clone().applyMatrix4(this.matrixWorld), index: n3, face: null, faceIndex: null, object: this });
        }
    }
    updateMorphTargets() {
      const e2 = this.geometry.morphAttributes, t2 = Object.keys(e2);
      if (t2.length > 0) {
        const n2 = e2[t2[0]];
        if (void 0 !== n2) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let e3 = 0, t3 = n2.length; e3 < t3; e3++) {
            const t4 = n2[e3].name || String(e3);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[t4] = e3;
          }
        }
      }
    }
  }
  const Vc = new Ar(), Hc = new Ar();
  class Qc extends Gc {
    constructor(e2, t2) {
      super(e2, t2), this.isLineSegments = true, this.type = "LineSegments";
    }
    computeLineDistances() {
      const e2 = this.geometry;
      if (null === e2.index) {
        const t2 = e2.attributes.position, n2 = [];
        for (let e3 = 0, r2 = t2.count; e3 < r2; e3 += 2)
          Vc.fromBufferAttribute(t2, e3), Hc.fromBufferAttribute(t2, e3 + 1), n2[e3] = 0 === e3 ? 0 : n2[e3 - 1], n2[e3 + 1] = n2[e3] + Vc.distanceTo(Hc);
        e2.setAttribute("lineDistance", new ls(n2, 1));
      } else
        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      return this;
    }
  }
  class Wc extends Gc {
    constructor(e2, t2) {
      super(e2, t2), this.isLineLoop = true, this.type = "LineLoop";
    }
  }
  class qc extends Ui {
    constructor(e2) {
      super(), this.isPointsMaterial = true, this.type = "PointsMaterial", this.color = new Vi(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = true, this.fog = true, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.color.copy(e2.color), this.map = e2.map, this.alphaMap = e2.alphaMap, this.size = e2.size, this.sizeAttenuation = e2.sizeAttenuation, this.fog = e2.fog, this;
    }
  }
  const Xc = new Zr(), Yc = new Jr(), Kc = new Vr(), Jc = new Ar();
  class Zc extends xi {
    constructor(e2 = new gs(), t2 = new qc()) {
      super(), this.isPoints = true, this.type = "Points", this.geometry = e2, this.material = t2, this.updateMorphTargets();
    }
    copy(e2, t2) {
      return super.copy(e2, t2), this.material = e2.material, this.geometry = e2.geometry, this;
    }
    raycast(e2, t2) {
      const n2 = this.geometry, r2 = this.matrixWorld, i2 = e2.params.Points.threshold, s2 = n2.drawRange;
      if (null === n2.boundingSphere && n2.computeBoundingSphere(), Kc.copy(n2.boundingSphere), Kc.applyMatrix4(r2), Kc.radius += i2, false === e2.ray.intersectsSphere(Kc))
        return;
      Xc.copy(r2).invert(), Yc.copy(e2.ray).applyMatrix4(Xc);
      const o2 = i2 / ((this.scale.x + this.scale.y + this.scale.z) / 3), a2 = o2 * o2, l2 = n2.index, c2 = n2.attributes.position;
      if (null !== l2)
        for (let n3 = Math.max(0, s2.start), i3 = Math.min(l2.count, s2.start + s2.count); n3 < i3; n3++) {
          const i4 = l2.getX(n3);
          Jc.fromBufferAttribute(c2, i4), $c(Jc, i4, a2, r2, e2, t2, this);
        }
      else
        for (let n3 = Math.max(0, s2.start), i3 = Math.min(c2.count, s2.start + s2.count); n3 < i3; n3++)
          Jc.fromBufferAttribute(c2, n3), $c(Jc, n3, a2, r2, e2, t2, this);
    }
    updateMorphTargets() {
      const e2 = this.geometry.morphAttributes, t2 = Object.keys(e2);
      if (t2.length > 0) {
        const n2 = e2[t2[0]];
        if (void 0 !== n2) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let e3 = 0, t3 = n2.length; e3 < t3; e3++) {
            const t4 = n2[e3].name || String(e3);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[t4] = e3;
          }
        }
      }
    }
  }
  function $c(e2, t2, n2, r2, i2, s2, o2) {
    const a2 = Yc.distanceSqToPoint(e2);
    if (a2 < n2) {
      const n3 = new Ar();
      Yc.closestPointToPoint(e2, n3), n3.applyMatrix4(r2);
      const l2 = i2.ray.origin.distanceTo(n3);
      if (l2 < i2.near || l2 > i2.far)
        return;
      s2.push({ distance: l2, distanceToRay: Math.sqrt(a2), point: n3, index: t2, face: null, object: o2 });
    }
  }
  class eu extends hr {
    constructor(e2, t2, n2, r2, i2, s2, o2, a2, l2) {
      super(e2, t2, n2, r2, i2, s2, o2, a2, l2), this.isVideoTexture = true, this.minFilter = void 0 !== s2 ? s2 : ge, this.magFilter = void 0 !== i2 ? i2 : ge, this.generateMipmaps = false;
      const c2 = this;
      "requestVideoFrameCallback" in e2 && e2.requestVideoFrameCallback(function t3() {
        c2.needsUpdate = true, e2.requestVideoFrameCallback(t3);
      });
    }
    clone() {
      return new this.constructor(this.image).copy(this);
    }
    update() {
      const e2 = this.image;
      false == "requestVideoFrameCallback" in e2 && e2.readyState >= e2.HAVE_CURRENT_DATA && (this.needsUpdate = true);
    }
  }
  class tu extends hr {
    constructor(e2, t2) {
      super({ width: e2, height: t2 }), this.isFramebufferTexture = true, this.magFilter = de, this.minFilter = de, this.generateMipmaps = false, this.needsUpdate = true;
    }
  }
  class nu extends hr {
    constructor(e2, t2, n2, r2, i2, s2, o2, a2, l2, c2, u2, p2) {
      super(null, s2, o2, a2, l2, c2, r2, i2, u2, p2), this.isCompressedTexture = true, this.image = { width: t2, height: n2 }, this.mipmaps = e2, this.flipY = false, this.generateMipmaps = false;
    }
  }
  class ru extends nu {
    constructor(e2, t2, n2, r2, i2, s2) {
      super(e2, t2, n2, i2, s2), this.isCompressedArrayTexture = true, this.image.depth = r2, this.wrapR = ue;
    }
  }
  class iu extends hr {
    constructor(e2, t2, n2, r2, i2, s2, o2, a2, l2) {
      super(e2, t2, n2, r2, i2, s2, o2, a2, l2), this.isCanvasTexture = true, this.needsUpdate = true;
    }
  }
  class su {
    constructor() {
      this.type = "Curve", this.arcLengthDivisions = 200;
    }
    getPoint() {
      return console.warn("THREE.Curve: .getPoint() not implemented."), null;
    }
    getPointAt(e2, t2) {
      const n2 = this.getUtoTmapping(e2);
      return this.getPoint(n2, t2);
    }
    getPoints(e2 = 5) {
      const t2 = [];
      for (let n2 = 0; n2 <= e2; n2++)
        t2.push(this.getPoint(n2 / e2));
      return t2;
    }
    getSpacedPoints(e2 = 5) {
      const t2 = [];
      for (let n2 = 0; n2 <= e2; n2++)
        t2.push(this.getPointAt(n2 / e2));
      return t2;
    }
    getLength() {
      const e2 = this.getLengths();
      return e2[e2.length - 1];
    }
    getLengths(e2 = this.arcLengthDivisions) {
      if (this.cacheArcLengths && this.cacheArcLengths.length === e2 + 1 && !this.needsUpdate)
        return this.cacheArcLengths;
      this.needsUpdate = false;
      const t2 = [];
      let n2, r2 = this.getPoint(0), i2 = 0;
      t2.push(0);
      for (let s2 = 1; s2 <= e2; s2++)
        n2 = this.getPoint(s2 / e2), i2 += n2.distanceTo(r2), t2.push(i2), r2 = n2;
      return this.cacheArcLengths = t2, t2;
    }
    updateArcLengths() {
      this.needsUpdate = true, this.getLengths();
    }
    getUtoTmapping(e2, t2) {
      const n2 = this.getLengths();
      let r2 = 0;
      const i2 = n2.length;
      let s2;
      s2 = t2 || e2 * n2[i2 - 1];
      let o2, a2 = 0, l2 = i2 - 1;
      for (; a2 <= l2; )
        if (r2 = Math.floor(a2 + (l2 - a2) / 2), o2 = n2[r2] - s2, o2 < 0)
          a2 = r2 + 1;
        else {
          if (!(o2 > 0)) {
            l2 = r2;
            break;
          }
          l2 = r2 - 1;
        }
      if (r2 = l2, n2[r2] === s2)
        return r2 / (i2 - 1);
      const c2 = n2[r2];
      return (r2 + (s2 - c2) / (n2[r2 + 1] - c2)) / (i2 - 1);
    }
    getTangent(e2, t2) {
      const n2 = 1e-4;
      let r2 = e2 - n2, i2 = e2 + n2;
      r2 < 0 && (r2 = 0), i2 > 1 && (i2 = 1);
      const s2 = this.getPoint(r2), o2 = this.getPoint(i2), a2 = t2 || (s2.isVector2 ? new Qn() : new Ar());
      return a2.copy(o2).sub(s2).normalize(), a2;
    }
    getTangentAt(e2, t2) {
      const n2 = this.getUtoTmapping(e2);
      return this.getTangent(n2, t2);
    }
    computeFrenetFrames(e2, t2) {
      const n2 = new Ar(), r2 = [], i2 = [], s2 = [], o2 = new Ar(), a2 = new Zr();
      for (let t3 = 0; t3 <= e2; t3++) {
        const n3 = t3 / e2;
        r2[t3] = this.getTangentAt(n3, new Ar());
      }
      i2[0] = new Ar(), s2[0] = new Ar();
      let l2 = Number.MAX_VALUE;
      const c2 = Math.abs(r2[0].x), u2 = Math.abs(r2[0].y), p2 = Math.abs(r2[0].z);
      c2 <= l2 && (l2 = c2, n2.set(1, 0, 0)), u2 <= l2 && (l2 = u2, n2.set(0, 1, 0)), p2 <= l2 && n2.set(0, 0, 1), o2.crossVectors(r2[0], n2).normalize(), i2[0].crossVectors(r2[0], o2), s2[0].crossVectors(r2[0], i2[0]);
      for (let t3 = 1; t3 <= e2; t3++) {
        if (i2[t3] = i2[t3 - 1].clone(), s2[t3] = s2[t3 - 1].clone(), o2.crossVectors(r2[t3 - 1], r2[t3]), o2.length() > Number.EPSILON) {
          o2.normalize();
          const e3 = Math.acos(Ln(r2[t3 - 1].dot(r2[t3]), -1, 1));
          i2[t3].applyMatrix4(a2.makeRotationAxis(o2, e3));
        }
        s2[t3].crossVectors(r2[t3], i2[t3]);
      }
      if (true === t2) {
        let t3 = Math.acos(Ln(i2[0].dot(i2[e2]), -1, 1));
        t3 /= e2, r2[0].dot(o2.crossVectors(i2[0], i2[e2])) > 0 && (t3 = -t3);
        for (let n3 = 1; n3 <= e2; n3++)
          i2[n3].applyMatrix4(a2.makeRotationAxis(r2[n3], t3 * n3)), s2[n3].crossVectors(r2[n3], i2[n3]);
      }
      return { tangents: r2, normals: i2, binormals: s2 };
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e2) {
      return this.arcLengthDivisions = e2.arcLengthDivisions, this;
    }
    toJSON() {
      const e2 = { metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" } };
      return e2.arcLengthDivisions = this.arcLengthDivisions, e2.type = this.type, e2;
    }
    fromJSON(e2) {
      return this.arcLengthDivisions = e2.arcLengthDivisions, this;
    }
  }
  class ou extends su {
    constructor(e2 = 0, t2 = 0, n2 = 1, r2 = 1, i2 = 0, s2 = 2 * Math.PI, o2 = false, a2 = 0) {
      super(), this.isEllipseCurve = true, this.type = "EllipseCurve", this.aX = e2, this.aY = t2, this.xRadius = n2, this.yRadius = r2, this.aStartAngle = i2, this.aEndAngle = s2, this.aClockwise = o2, this.aRotation = a2;
    }
    getPoint(e2, t2) {
      const n2 = t2 || new Qn(), r2 = 2 * Math.PI;
      let i2 = this.aEndAngle - this.aStartAngle;
      const s2 = Math.abs(i2) < Number.EPSILON;
      for (; i2 < 0; )
        i2 += r2;
      for (; i2 > r2; )
        i2 -= r2;
      i2 < Number.EPSILON && (i2 = s2 ? 0 : r2), true !== this.aClockwise || s2 || (i2 === r2 ? i2 = -r2 : i2 -= r2);
      const o2 = this.aStartAngle + e2 * i2;
      let a2 = this.aX + this.xRadius * Math.cos(o2), l2 = this.aY + this.yRadius * Math.sin(o2);
      if (0 !== this.aRotation) {
        const e3 = Math.cos(this.aRotation), t3 = Math.sin(this.aRotation), n3 = a2 - this.aX, r3 = l2 - this.aY;
        a2 = n3 * e3 - r3 * t3 + this.aX, l2 = n3 * t3 + r3 * e3 + this.aY;
      }
      return n2.set(a2, l2);
    }
    copy(e2) {
      return super.copy(e2), this.aX = e2.aX, this.aY = e2.aY, this.xRadius = e2.xRadius, this.yRadius = e2.yRadius, this.aStartAngle = e2.aStartAngle, this.aEndAngle = e2.aEndAngle, this.aClockwise = e2.aClockwise, this.aRotation = e2.aRotation, this;
    }
    toJSON() {
      const e2 = super.toJSON();
      return e2.aX = this.aX, e2.aY = this.aY, e2.xRadius = this.xRadius, e2.yRadius = this.yRadius, e2.aStartAngle = this.aStartAngle, e2.aEndAngle = this.aEndAngle, e2.aClockwise = this.aClockwise, e2.aRotation = this.aRotation, e2;
    }
    fromJSON(e2) {
      return super.fromJSON(e2), this.aX = e2.aX, this.aY = e2.aY, this.xRadius = e2.xRadius, this.yRadius = e2.yRadius, this.aStartAngle = e2.aStartAngle, this.aEndAngle = e2.aEndAngle, this.aClockwise = e2.aClockwise, this.aRotation = e2.aRotation, this;
    }
  }
  class au extends ou {
    constructor(e2, t2, n2, r2, i2, s2) {
      super(e2, t2, n2, n2, r2, i2, s2), this.isArcCurve = true, this.type = "ArcCurve";
    }
  }
  function lu() {
    let e2 = 0, t2 = 0, n2 = 0, r2 = 0;
    function i2(i3, s2, o2, a2) {
      e2 = i3, t2 = o2, n2 = -3 * i3 + 3 * s2 - 2 * o2 - a2, r2 = 2 * i3 - 2 * s2 + o2 + a2;
    }
    return { initCatmullRom: function(e3, t3, n3, r3, s2) {
      i2(t3, n3, s2 * (n3 - e3), s2 * (r3 - t3));
    }, initNonuniformCatmullRom: function(e3, t3, n3, r3, s2, o2, a2) {
      let l2 = (t3 - e3) / s2 - (n3 - e3) / (s2 + o2) + (n3 - t3) / o2, c2 = (n3 - t3) / o2 - (r3 - t3) / (o2 + a2) + (r3 - n3) / a2;
      l2 *= o2, c2 *= o2, i2(t3, n3, l2, c2);
    }, calc: function(i3) {
      const s2 = i3 * i3;
      return e2 + t2 * i3 + n2 * s2 + r2 * (s2 * i3);
    } };
  }
  const cu = new Ar(), uu = new lu(), pu = new lu(), du = new lu();
  class hu extends su {
    constructor(e2 = [], t2 = false, n2 = "centripetal", r2 = 0.5) {
      super(), this.isCatmullRomCurve3 = true, this.type = "CatmullRomCurve3", this.points = e2, this.closed = t2, this.curveType = n2, this.tension = r2;
    }
    getPoint(e2, t2 = new Ar()) {
      const n2 = t2, r2 = this.points, i2 = r2.length, s2 = (i2 - (this.closed ? 0 : 1)) * e2;
      let o2, a2, l2 = Math.floor(s2), c2 = s2 - l2;
      this.closed ? l2 += l2 > 0 ? 0 : (Math.floor(Math.abs(l2) / i2) + 1) * i2 : 0 === c2 && l2 === i2 - 1 && (l2 = i2 - 2, c2 = 1), this.closed || l2 > 0 ? o2 = r2[(l2 - 1) % i2] : (cu.subVectors(r2[0], r2[1]).add(r2[0]), o2 = cu);
      const u2 = r2[l2 % i2], p2 = r2[(l2 + 1) % i2];
      if (this.closed || l2 + 2 < i2 ? a2 = r2[(l2 + 2) % i2] : (cu.subVectors(r2[i2 - 1], r2[i2 - 2]).add(r2[i2 - 1]), a2 = cu), "centripetal" === this.curveType || "chordal" === this.curveType) {
        const e3 = "chordal" === this.curveType ? 0.5 : 0.25;
        let t3 = Math.pow(o2.distanceToSquared(u2), e3), n3 = Math.pow(u2.distanceToSquared(p2), e3), r3 = Math.pow(p2.distanceToSquared(a2), e3);
        n3 < 1e-4 && (n3 = 1), t3 < 1e-4 && (t3 = n3), r3 < 1e-4 && (r3 = n3), uu.initNonuniformCatmullRom(o2.x, u2.x, p2.x, a2.x, t3, n3, r3), pu.initNonuniformCatmullRom(o2.y, u2.y, p2.y, a2.y, t3, n3, r3), du.initNonuniformCatmullRom(o2.z, u2.z, p2.z, a2.z, t3, n3, r3);
      } else
        "catmullrom" === this.curveType && (uu.initCatmullRom(o2.x, u2.x, p2.x, a2.x, this.tension), pu.initCatmullRom(o2.y, u2.y, p2.y, a2.y, this.tension), du.initCatmullRom(o2.z, u2.z, p2.z, a2.z, this.tension));
      return n2.set(uu.calc(c2), pu.calc(c2), du.calc(c2)), n2;
    }
    copy(e2) {
      super.copy(e2), this.points = [];
      for (let t2 = 0, n2 = e2.points.length; t2 < n2; t2++) {
        const n3 = e2.points[t2];
        this.points.push(n3.clone());
      }
      return this.closed = e2.closed, this.curveType = e2.curveType, this.tension = e2.tension, this;
    }
    toJSON() {
      const e2 = super.toJSON();
      e2.points = [];
      for (let t2 = 0, n2 = this.points.length; t2 < n2; t2++) {
        const n3 = this.points[t2];
        e2.points.push(n3.toArray());
      }
      return e2.closed = this.closed, e2.curveType = this.curveType, e2.tension = this.tension, e2;
    }
    fromJSON(e2) {
      super.fromJSON(e2), this.points = [];
      for (let t2 = 0, n2 = e2.points.length; t2 < n2; t2++) {
        const n3 = e2.points[t2];
        this.points.push(new Ar().fromArray(n3));
      }
      return this.closed = e2.closed, this.curveType = e2.curveType, this.tension = e2.tension, this;
    }
  }
  function fu(e2, t2, n2, r2, i2) {
    const s2 = 0.5 * (r2 - t2), o2 = 0.5 * (i2 - n2), a2 = e2 * e2;
    return (2 * n2 - 2 * r2 + s2 + o2) * (e2 * a2) + (-3 * n2 + 3 * r2 - 2 * s2 - o2) * a2 + s2 * e2 + n2;
  }
  function mu(e2, t2, n2, r2) {
    return function(e3, t3) {
      const n3 = 1 - e3;
      return n3 * n3 * t3;
    }(e2, t2) + function(e3, t3) {
      return 2 * (1 - e3) * e3 * t3;
    }(e2, n2) + function(e3, t3) {
      return e3 * e3 * t3;
    }(e2, r2);
  }
  function _u(e2, t2, n2, r2, i2) {
    return function(e3, t3) {
      const n3 = 1 - e3;
      return n3 * n3 * n3 * t3;
    }(e2, t2) + function(e3, t3) {
      const n3 = 1 - e3;
      return 3 * n3 * n3 * e3 * t3;
    }(e2, n2) + function(e3, t3) {
      return 3 * (1 - e3) * e3 * e3 * t3;
    }(e2, r2) + function(e3, t3) {
      return e3 * e3 * e3 * t3;
    }(e2, i2);
  }
  class gu extends su {
    constructor(e2 = new Qn(), t2 = new Qn(), n2 = new Qn(), r2 = new Qn()) {
      super(), this.isCubicBezierCurve = true, this.type = "CubicBezierCurve", this.v0 = e2, this.v1 = t2, this.v2 = n2, this.v3 = r2;
    }
    getPoint(e2, t2 = new Qn()) {
      const n2 = t2, r2 = this.v0, i2 = this.v1, s2 = this.v2, o2 = this.v3;
      return n2.set(_u(e2, r2.x, i2.x, s2.x, o2.x), _u(e2, r2.y, i2.y, s2.y, o2.y)), n2;
    }
    copy(e2) {
      return super.copy(e2), this.v0.copy(e2.v0), this.v1.copy(e2.v1), this.v2.copy(e2.v2), this.v3.copy(e2.v3), this;
    }
    toJSON() {
      const e2 = super.toJSON();
      return e2.v0 = this.v0.toArray(), e2.v1 = this.v1.toArray(), e2.v2 = this.v2.toArray(), e2.v3 = this.v3.toArray(), e2;
    }
    fromJSON(e2) {
      return super.fromJSON(e2), this.v0.fromArray(e2.v0), this.v1.fromArray(e2.v1), this.v2.fromArray(e2.v2), this.v3.fromArray(e2.v3), this;
    }
  }
  class vu extends su {
    constructor(e2 = new Ar(), t2 = new Ar(), n2 = new Ar(), r2 = new Ar()) {
      super(), this.isCubicBezierCurve3 = true, this.type = "CubicBezierCurve3", this.v0 = e2, this.v1 = t2, this.v2 = n2, this.v3 = r2;
    }
    getPoint(e2, t2 = new Ar()) {
      const n2 = t2, r2 = this.v0, i2 = this.v1, s2 = this.v2, o2 = this.v3;
      return n2.set(_u(e2, r2.x, i2.x, s2.x, o2.x), _u(e2, r2.y, i2.y, s2.y, o2.y), _u(e2, r2.z, i2.z, s2.z, o2.z)), n2;
    }
    copy(e2) {
      return super.copy(e2), this.v0.copy(e2.v0), this.v1.copy(e2.v1), this.v2.copy(e2.v2), this.v3.copy(e2.v3), this;
    }
    toJSON() {
      const e2 = super.toJSON();
      return e2.v0 = this.v0.toArray(), e2.v1 = this.v1.toArray(), e2.v2 = this.v2.toArray(), e2.v3 = this.v3.toArray(), e2;
    }
    fromJSON(e2) {
      return super.fromJSON(e2), this.v0.fromArray(e2.v0), this.v1.fromArray(e2.v1), this.v2.fromArray(e2.v2), this.v3.fromArray(e2.v3), this;
    }
  }
  class yu extends su {
    constructor(e2 = new Qn(), t2 = new Qn()) {
      super(), this.isLineCurve = true, this.type = "LineCurve", this.v1 = e2, this.v2 = t2;
    }
    getPoint(e2, t2 = new Qn()) {
      const n2 = t2;
      return 1 === e2 ? n2.copy(this.v2) : (n2.copy(this.v2).sub(this.v1), n2.multiplyScalar(e2).add(this.v1)), n2;
    }
    getPointAt(e2, t2) {
      return this.getPoint(e2, t2);
    }
    getTangent(e2, t2 = new Qn()) {
      return t2.subVectors(this.v2, this.v1).normalize();
    }
    getTangentAt(e2, t2) {
      return this.getTangent(e2, t2);
    }
    copy(e2) {
      return super.copy(e2), this.v1.copy(e2.v1), this.v2.copy(e2.v2), this;
    }
    toJSON() {
      const e2 = super.toJSON();
      return e2.v1 = this.v1.toArray(), e2.v2 = this.v2.toArray(), e2;
    }
    fromJSON(e2) {
      return super.fromJSON(e2), this.v1.fromArray(e2.v1), this.v2.fromArray(e2.v2), this;
    }
  }
  class bu extends su {
    constructor(e2 = new Ar(), t2 = new Ar()) {
      super(), this.isLineCurve3 = true, this.type = "LineCurve3", this.v1 = e2, this.v2 = t2;
    }
    getPoint(e2, t2 = new Ar()) {
      const n2 = t2;
      return 1 === e2 ? n2.copy(this.v2) : (n2.copy(this.v2).sub(this.v1), n2.multiplyScalar(e2).add(this.v1)), n2;
    }
    getPointAt(e2, t2) {
      return this.getPoint(e2, t2);
    }
    getTangent(e2, t2 = new Ar()) {
      return t2.subVectors(this.v2, this.v1).normalize();
    }
    getTangentAt(e2, t2) {
      return this.getTangent(e2, t2);
    }
    copy(e2) {
      return super.copy(e2), this.v1.copy(e2.v1), this.v2.copy(e2.v2), this;
    }
    toJSON() {
      const e2 = super.toJSON();
      return e2.v1 = this.v1.toArray(), e2.v2 = this.v2.toArray(), e2;
    }
    fromJSON(e2) {
      return super.fromJSON(e2), this.v1.fromArray(e2.v1), this.v2.fromArray(e2.v2), this;
    }
  }
  class wu extends su {
    constructor(e2 = new Qn(), t2 = new Qn(), n2 = new Qn()) {
      super(), this.isQuadraticBezierCurve = true, this.type = "QuadraticBezierCurve", this.v0 = e2, this.v1 = t2, this.v2 = n2;
    }
    getPoint(e2, t2 = new Qn()) {
      const n2 = t2, r2 = this.v0, i2 = this.v1, s2 = this.v2;
      return n2.set(mu(e2, r2.x, i2.x, s2.x), mu(e2, r2.y, i2.y, s2.y)), n2;
    }
    copy(e2) {
      return super.copy(e2), this.v0.copy(e2.v0), this.v1.copy(e2.v1), this.v2.copy(e2.v2), this;
    }
    toJSON() {
      const e2 = super.toJSON();
      return e2.v0 = this.v0.toArray(), e2.v1 = this.v1.toArray(), e2.v2 = this.v2.toArray(), e2;
    }
    fromJSON(e2) {
      return super.fromJSON(e2), this.v0.fromArray(e2.v0), this.v1.fromArray(e2.v1), this.v2.fromArray(e2.v2), this;
    }
  }
  class Au extends su {
    constructor(e2 = new Ar(), t2 = new Ar(), n2 = new Ar()) {
      super(), this.isQuadraticBezierCurve3 = true, this.type = "QuadraticBezierCurve3", this.v0 = e2, this.v1 = t2, this.v2 = n2;
    }
    getPoint(e2, t2 = new Ar()) {
      const n2 = t2, r2 = this.v0, i2 = this.v1, s2 = this.v2;
      return n2.set(mu(e2, r2.x, i2.x, s2.x), mu(e2, r2.y, i2.y, s2.y), mu(e2, r2.z, i2.z, s2.z)), n2;
    }
    copy(e2) {
      return super.copy(e2), this.v0.copy(e2.v0), this.v1.copy(e2.v1), this.v2.copy(e2.v2), this;
    }
    toJSON() {
      const e2 = super.toJSON();
      return e2.v0 = this.v0.toArray(), e2.v1 = this.v1.toArray(), e2.v2 = this.v2.toArray(), e2;
    }
    fromJSON(e2) {
      return super.fromJSON(e2), this.v0.fromArray(e2.v0), this.v1.fromArray(e2.v1), this.v2.fromArray(e2.v2), this;
    }
  }
  class xu extends su {
    constructor(e2 = []) {
      super(), this.isSplineCurve = true, this.type = "SplineCurve", this.points = e2;
    }
    getPoint(e2, t2 = new Qn()) {
      const n2 = t2, r2 = this.points, i2 = (r2.length - 1) * e2, s2 = Math.floor(i2), o2 = i2 - s2, a2 = r2[0 === s2 ? s2 : s2 - 1], l2 = r2[s2], c2 = r2[s2 > r2.length - 2 ? r2.length - 1 : s2 + 1], u2 = r2[s2 > r2.length - 3 ? r2.length - 1 : s2 + 2];
      return n2.set(fu(o2, a2.x, l2.x, c2.x, u2.x), fu(o2, a2.y, l2.y, c2.y, u2.y)), n2;
    }
    copy(e2) {
      super.copy(e2), this.points = [];
      for (let t2 = 0, n2 = e2.points.length; t2 < n2; t2++) {
        const n3 = e2.points[t2];
        this.points.push(n3.clone());
      }
      return this;
    }
    toJSON() {
      const e2 = super.toJSON();
      e2.points = [];
      for (let t2 = 0, n2 = this.points.length; t2 < n2; t2++) {
        const n3 = this.points[t2];
        e2.points.push(n3.toArray());
      }
      return e2;
    }
    fromJSON(e2) {
      super.fromJSON(e2), this.points = [];
      for (let t2 = 0, n2 = e2.points.length; t2 < n2; t2++) {
        const n3 = e2.points[t2];
        this.points.push(new Qn().fromArray(n3));
      }
      return this;
    }
  }
  var Eu = Object.freeze({ __proto__: null, ArcCurve: au, CatmullRomCurve3: hu, CubicBezierCurve: gu, CubicBezierCurve3: vu, EllipseCurve: ou, LineCurve: yu, LineCurve3: bu, QuadraticBezierCurve: wu, QuadraticBezierCurve3: Au, SplineCurve: xu });
  class Cu extends su {
    constructor() {
      super(), this.type = "CurvePath", this.curves = [], this.autoClose = false;
    }
    add(e2) {
      this.curves.push(e2);
    }
    closePath() {
      const e2 = this.curves[0].getPoint(0), t2 = this.curves[this.curves.length - 1].getPoint(1);
      e2.equals(t2) || this.curves.push(new yu(t2, e2));
    }
    getPoint(e2, t2) {
      const n2 = e2 * this.getLength(), r2 = this.getCurveLengths();
      let i2 = 0;
      for (; i2 < r2.length; ) {
        if (r2[i2] >= n2) {
          const e3 = r2[i2] - n2, s2 = this.curves[i2], o2 = s2.getLength(), a2 = 0 === o2 ? 0 : 1 - e3 / o2;
          return s2.getPointAt(a2, t2);
        }
        i2++;
      }
      return null;
    }
    getLength() {
      const e2 = this.getCurveLengths();
      return e2[e2.length - 1];
    }
    updateArcLengths() {
      this.needsUpdate = true, this.cacheLengths = null, this.getCurveLengths();
    }
    getCurveLengths() {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
        return this.cacheLengths;
      const e2 = [];
      let t2 = 0;
      for (let n2 = 0, r2 = this.curves.length; n2 < r2; n2++)
        t2 += this.curves[n2].getLength(), e2.push(t2);
      return this.cacheLengths = e2, e2;
    }
    getSpacedPoints(e2 = 40) {
      const t2 = [];
      for (let n2 = 0; n2 <= e2; n2++)
        t2.push(this.getPoint(n2 / e2));
      return this.autoClose && t2.push(t2[0]), t2;
    }
    getPoints(e2 = 12) {
      const t2 = [];
      let n2;
      for (let r2 = 0, i2 = this.curves; r2 < i2.length; r2++) {
        const s2 = i2[r2], o2 = s2.isEllipseCurve ? 2 * e2 : s2.isLineCurve || s2.isLineCurve3 ? 1 : s2.isSplineCurve ? e2 * s2.points.length : e2, a2 = s2.getPoints(o2);
        for (let e3 = 0; e3 < a2.length; e3++) {
          const r3 = a2[e3];
          n2 && n2.equals(r3) || (t2.push(r3), n2 = r3);
        }
      }
      return this.autoClose && t2.length > 1 && !t2[t2.length - 1].equals(t2[0]) && t2.push(t2[0]), t2;
    }
    copy(e2) {
      super.copy(e2), this.curves = [];
      for (let t2 = 0, n2 = e2.curves.length; t2 < n2; t2++) {
        const n3 = e2.curves[t2];
        this.curves.push(n3.clone());
      }
      return this.autoClose = e2.autoClose, this;
    }
    toJSON() {
      const e2 = super.toJSON();
      e2.autoClose = this.autoClose, e2.curves = [];
      for (let t2 = 0, n2 = this.curves.length; t2 < n2; t2++) {
        const n3 = this.curves[t2];
        e2.curves.push(n3.toJSON());
      }
      return e2;
    }
    fromJSON(e2) {
      super.fromJSON(e2), this.autoClose = e2.autoClose, this.curves = [];
      for (let t2 = 0, n2 = e2.curves.length; t2 < n2; t2++) {
        const n3 = e2.curves[t2];
        this.curves.push(new Eu[n3.type]().fromJSON(n3));
      }
      return this;
    }
  }
  class Su extends Cu {
    constructor(e2) {
      super(), this.type = "Path", this.currentPoint = new Qn(), e2 && this.setFromPoints(e2);
    }
    setFromPoints(e2) {
      this.moveTo(e2[0].x, e2[0].y);
      for (let t2 = 1, n2 = e2.length; t2 < n2; t2++)
        this.lineTo(e2[t2].x, e2[t2].y);
      return this;
    }
    moveTo(e2, t2) {
      return this.currentPoint.set(e2, t2), this;
    }
    lineTo(e2, t2) {
      const n2 = new yu(this.currentPoint.clone(), new Qn(e2, t2));
      return this.curves.push(n2), this.currentPoint.set(e2, t2), this;
    }
    quadraticCurveTo(e2, t2, n2, r2) {
      const i2 = new wu(this.currentPoint.clone(), new Qn(e2, t2), new Qn(n2, r2));
      return this.curves.push(i2), this.currentPoint.set(n2, r2), this;
    }
    bezierCurveTo(e2, t2, n2, r2, i2, s2) {
      const o2 = new gu(this.currentPoint.clone(), new Qn(e2, t2), new Qn(n2, r2), new Qn(i2, s2));
      return this.curves.push(o2), this.currentPoint.set(i2, s2), this;
    }
    splineThru(e2) {
      const t2 = [this.currentPoint.clone()].concat(e2), n2 = new xu(t2);
      return this.curves.push(n2), this.currentPoint.copy(e2[e2.length - 1]), this;
    }
    arc(e2, t2, n2, r2, i2, s2) {
      const o2 = this.currentPoint.x, a2 = this.currentPoint.y;
      return this.absarc(e2 + o2, t2 + a2, n2, r2, i2, s2), this;
    }
    absarc(e2, t2, n2, r2, i2, s2) {
      return this.absellipse(e2, t2, n2, n2, r2, i2, s2), this;
    }
    ellipse(e2, t2, n2, r2, i2, s2, o2, a2) {
      const l2 = this.currentPoint.x, c2 = this.currentPoint.y;
      return this.absellipse(e2 + l2, t2 + c2, n2, r2, i2, s2, o2, a2), this;
    }
    absellipse(e2, t2, n2, r2, i2, s2, o2, a2) {
      const l2 = new ou(e2, t2, n2, r2, i2, s2, o2, a2);
      if (this.curves.length > 0) {
        const e3 = l2.getPoint(0);
        e3.equals(this.currentPoint) || this.lineTo(e3.x, e3.y);
      }
      this.curves.push(l2);
      const c2 = l2.getPoint(1);
      return this.currentPoint.copy(c2), this;
    }
    copy(e2) {
      return super.copy(e2), this.currentPoint.copy(e2.currentPoint), this;
    }
    toJSON() {
      const e2 = super.toJSON();
      return e2.currentPoint = this.currentPoint.toArray(), e2;
    }
    fromJSON(e2) {
      return super.fromJSON(e2), this.currentPoint.fromArray(e2.currentPoint), this;
    }
  }
  class Mu extends gs {
    constructor(e2 = [new Qn(0, -0.5), new Qn(0.5, 0), new Qn(0, 0.5)], t2 = 12, n2 = 0, r2 = 2 * Math.PI) {
      super(), this.type = "LatheGeometry", this.parameters = { points: e2, segments: t2, phiStart: n2, phiLength: r2 }, t2 = Math.floor(t2), r2 = Ln(r2, 0, 2 * Math.PI);
      const i2 = [], s2 = [], o2 = [], a2 = [], l2 = [], c2 = 1 / t2, u2 = new Ar(), p2 = new Qn(), d2 = new Ar(), h2 = new Ar(), f2 = new Ar();
      let m2 = 0, _2 = 0;
      for (let t3 = 0; t3 <= e2.length - 1; t3++)
        switch (t3) {
          case 0:
            m2 = e2[t3 + 1].x - e2[t3].x, _2 = e2[t3 + 1].y - e2[t3].y, d2.x = 1 * _2, d2.y = -m2, d2.z = 0 * _2, f2.copy(d2), d2.normalize(), a2.push(d2.x, d2.y, d2.z);
            break;
          case e2.length - 1:
            a2.push(f2.x, f2.y, f2.z);
            break;
          default:
            m2 = e2[t3 + 1].x - e2[t3].x, _2 = e2[t3 + 1].y - e2[t3].y, d2.x = 1 * _2, d2.y = -m2, d2.z = 0 * _2, h2.copy(d2), d2.x += f2.x, d2.y += f2.y, d2.z += f2.z, d2.normalize(), a2.push(d2.x, d2.y, d2.z), f2.copy(h2);
        }
      for (let i3 = 0; i3 <= t2; i3++) {
        const d3 = n2 + i3 * c2 * r2, h3 = Math.sin(d3), f3 = Math.cos(d3);
        for (let n3 = 0; n3 <= e2.length - 1; n3++) {
          u2.x = e2[n3].x * h3, u2.y = e2[n3].y, u2.z = e2[n3].x * f3, s2.push(u2.x, u2.y, u2.z), p2.x = i3 / t2, p2.y = n3 / (e2.length - 1), o2.push(p2.x, p2.y);
          const r3 = a2[3 * n3 + 0] * h3, c3 = a2[3 * n3 + 1], d4 = a2[3 * n3 + 0] * f3;
          l2.push(r3, c3, d4);
        }
      }
      for (let n3 = 0; n3 < t2; n3++)
        for (let t3 = 0; t3 < e2.length - 1; t3++) {
          const r3 = t3 + n3 * e2.length, s3 = r3, o3 = r3 + e2.length, a3 = r3 + e2.length + 1, l3 = r3 + 1;
          i2.push(s3, o3, l3), i2.push(a3, l3, o3);
        }
      this.setIndex(i2), this.setAttribute("position", new ls(s2, 3)), this.setAttribute("uv", new ls(o2, 2)), this.setAttribute("normal", new ls(l2, 3));
    }
    copy(e2) {
      return super.copy(e2), this.parameters = Object.assign({}, e2.parameters), this;
    }
    static fromJSON(e2) {
      return new Mu(e2.points, e2.segments, e2.phiStart, e2.phiLength);
    }
  }
  class Tu extends Mu {
    constructor(e2 = 1, t2 = 1, n2 = 4, r2 = 8) {
      const i2 = new Su();
      i2.absarc(0, -t2 / 2, e2, 1.5 * Math.PI, 0), i2.absarc(0, t2 / 2, e2, 0, 0.5 * Math.PI), super(i2.getPoints(n2), r2), this.type = "CapsuleGeometry", this.parameters = { radius: e2, height: t2, capSegments: n2, radialSegments: r2 };
    }
    static fromJSON(e2) {
      return new Tu(e2.radius, e2.length, e2.capSegments, e2.radialSegments);
    }
  }
  class Pu extends gs {
    constructor(e2 = 1, t2 = 32, n2 = 0, r2 = 2 * Math.PI) {
      super(), this.type = "CircleGeometry", this.parameters = { radius: e2, segments: t2, thetaStart: n2, thetaLength: r2 }, t2 = Math.max(3, t2);
      const i2 = [], s2 = [], o2 = [], a2 = [], l2 = new Ar(), c2 = new Qn();
      s2.push(0, 0, 0), o2.push(0, 0, 1), a2.push(0.5, 0.5);
      for (let i3 = 0, u2 = 3; i3 <= t2; i3++, u2 += 3) {
        const p2 = n2 + i3 / t2 * r2;
        l2.x = e2 * Math.cos(p2), l2.y = e2 * Math.sin(p2), s2.push(l2.x, l2.y, l2.z), o2.push(0, 0, 1), c2.x = (s2[u2] / e2 + 1) / 2, c2.y = (s2[u2 + 1] / e2 + 1) / 2, a2.push(c2.x, c2.y);
      }
      for (let e3 = 1; e3 <= t2; e3++)
        i2.push(e3, e3 + 1, 0);
      this.setIndex(i2), this.setAttribute("position", new ls(s2, 3)), this.setAttribute("normal", new ls(o2, 3)), this.setAttribute("uv", new ls(a2, 2));
    }
    copy(e2) {
      return super.copy(e2), this.parameters = Object.assign({}, e2.parameters), this;
    }
    static fromJSON(e2) {
      return new Pu(e2.radius, e2.segments, e2.thetaStart, e2.thetaLength);
    }
  }
  class Iu extends gs {
    constructor(e2 = 1, t2 = 1, n2 = 1, r2 = 32, i2 = 1, s2 = false, o2 = 0, a2 = 2 * Math.PI) {
      super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: e2, radiusBottom: t2, height: n2, radialSegments: r2, heightSegments: i2, openEnded: s2, thetaStart: o2, thetaLength: a2 };
      const l2 = this;
      r2 = Math.floor(r2), i2 = Math.floor(i2);
      const c2 = [], u2 = [], p2 = [], d2 = [];
      let h2 = 0;
      const f2 = [], m2 = n2 / 2;
      let _2 = 0;
      function g2(n3) {
        const i3 = h2, s3 = new Qn(), f3 = new Ar();
        let g3 = 0;
        const v2 = true === n3 ? e2 : t2, y2 = true === n3 ? 1 : -1;
        for (let e3 = 1; e3 <= r2; e3++)
          u2.push(0, m2 * y2, 0), p2.push(0, y2, 0), d2.push(0.5, 0.5), h2++;
        const b2 = h2;
        for (let e3 = 0; e3 <= r2; e3++) {
          const t3 = e3 / r2 * a2 + o2, n4 = Math.cos(t3), i4 = Math.sin(t3);
          f3.x = v2 * i4, f3.y = m2 * y2, f3.z = v2 * n4, u2.push(f3.x, f3.y, f3.z), p2.push(0, y2, 0), s3.x = 0.5 * n4 + 0.5, s3.y = 0.5 * i4 * y2 + 0.5, d2.push(s3.x, s3.y), h2++;
        }
        for (let e3 = 0; e3 < r2; e3++) {
          const t3 = i3 + e3, r3 = b2 + e3;
          true === n3 ? c2.push(r3, r3 + 1, t3) : c2.push(r3 + 1, r3, t3), g3 += 3;
        }
        l2.addGroup(_2, g3, true === n3 ? 1 : 2), _2 += g3;
      }
      !function() {
        const s3 = new Ar(), g3 = new Ar();
        let v2 = 0;
        const y2 = (t2 - e2) / n2;
        for (let l3 = 0; l3 <= i2; l3++) {
          const c3 = [], _3 = l3 / i2, v3 = _3 * (t2 - e2) + e2;
          for (let e3 = 0; e3 <= r2; e3++) {
            const t3 = e3 / r2, i3 = t3 * a2 + o2, l4 = Math.sin(i3), f3 = Math.cos(i3);
            g3.x = v3 * l4, g3.y = -_3 * n2 + m2, g3.z = v3 * f3, u2.push(g3.x, g3.y, g3.z), s3.set(l4, y2, f3).normalize(), p2.push(s3.x, s3.y, s3.z), d2.push(t3, 1 - _3), c3.push(h2++);
          }
          f2.push(c3);
        }
        for (let e3 = 0; e3 < r2; e3++)
          for (let t3 = 0; t3 < i2; t3++) {
            const n3 = f2[t3][e3], r3 = f2[t3 + 1][e3], i3 = f2[t3 + 1][e3 + 1], s4 = f2[t3][e3 + 1];
            c2.push(n3, r3, s4), c2.push(r3, i3, s4), v2 += 6;
          }
        l2.addGroup(_2, v2, 0), _2 += v2;
      }(), false === s2 && (e2 > 0 && g2(true), t2 > 0 && g2(false)), this.setIndex(c2), this.setAttribute("position", new ls(u2, 3)), this.setAttribute("normal", new ls(p2, 3)), this.setAttribute("uv", new ls(d2, 2));
    }
    copy(e2) {
      return super.copy(e2), this.parameters = Object.assign({}, e2.parameters), this;
    }
    static fromJSON(e2) {
      return new Iu(e2.radiusTop, e2.radiusBottom, e2.height, e2.radialSegments, e2.heightSegments, e2.openEnded, e2.thetaStart, e2.thetaLength);
    }
  }
  class Ru extends Iu {
    constructor(e2 = 1, t2 = 1, n2 = 32, r2 = 1, i2 = false, s2 = 0, o2 = 2 * Math.PI) {
      super(0, e2, t2, n2, r2, i2, s2, o2), this.type = "ConeGeometry", this.parameters = { radius: e2, height: t2, radialSegments: n2, heightSegments: r2, openEnded: i2, thetaStart: s2, thetaLength: o2 };
    }
    static fromJSON(e2) {
      return new Ru(e2.radius, e2.height, e2.radialSegments, e2.heightSegments, e2.openEnded, e2.thetaStart, e2.thetaLength);
    }
  }
  class ku extends gs {
    constructor(e2 = [], t2 = [], n2 = 1, r2 = 0) {
      super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: e2, indices: t2, radius: n2, detail: r2 };
      const i2 = [], s2 = [];
      function o2(e3, t3, n3, r3) {
        const i3 = r3 + 1, s3 = [];
        for (let r4 = 0; r4 <= i3; r4++) {
          s3[r4] = [];
          const o3 = e3.clone().lerp(n3, r4 / i3), a3 = t3.clone().lerp(n3, r4 / i3), l3 = i3 - r4;
          for (let e4 = 0; e4 <= l3; e4++)
            s3[r4][e4] = 0 === e4 && r4 === i3 ? o3 : o3.clone().lerp(a3, e4 / l3);
        }
        for (let e4 = 0; e4 < i3; e4++)
          for (let t4 = 0; t4 < 2 * (i3 - e4) - 1; t4++) {
            const n4 = Math.floor(t4 / 2);
            t4 % 2 == 0 ? (a2(s3[e4][n4 + 1]), a2(s3[e4 + 1][n4]), a2(s3[e4][n4])) : (a2(s3[e4][n4 + 1]), a2(s3[e4 + 1][n4 + 1]), a2(s3[e4 + 1][n4]));
          }
      }
      function a2(e3) {
        i2.push(e3.x, e3.y, e3.z);
      }
      function l2(t3, n3) {
        const r3 = 3 * t3;
        n3.x = e2[r3 + 0], n3.y = e2[r3 + 1], n3.z = e2[r3 + 2];
      }
      function c2(e3, t3, n3, r3) {
        r3 < 0 && 1 === e3.x && (s2[t3] = e3.x - 1), 0 === n3.x && 0 === n3.z && (s2[t3] = r3 / 2 / Math.PI + 0.5);
      }
      function u2(e3) {
        return Math.atan2(e3.z, -e3.x);
      }
      !function(e3) {
        const n3 = new Ar(), r3 = new Ar(), i3 = new Ar();
        for (let s3 = 0; s3 < t2.length; s3 += 3)
          l2(t2[s3 + 0], n3), l2(t2[s3 + 1], r3), l2(t2[s3 + 2], i3), o2(n3, r3, i3, e3);
      }(r2), function(e3) {
        const t3 = new Ar();
        for (let n3 = 0; n3 < i2.length; n3 += 3)
          t3.x = i2[n3 + 0], t3.y = i2[n3 + 1], t3.z = i2[n3 + 2], t3.normalize().multiplyScalar(e3), i2[n3 + 0] = t3.x, i2[n3 + 1] = t3.y, i2[n3 + 2] = t3.z;
      }(n2), function() {
        const e3 = new Ar();
        for (let n3 = 0; n3 < i2.length; n3 += 3) {
          e3.x = i2[n3 + 0], e3.y = i2[n3 + 1], e3.z = i2[n3 + 2];
          const r3 = u2(e3) / 2 / Math.PI + 0.5, o3 = (t3 = e3, Math.atan2(-t3.y, Math.sqrt(t3.x * t3.x + t3.z * t3.z)) / Math.PI + 0.5);
          s2.push(r3, 1 - o3);
        }
        var t3;
        (function() {
          const e4 = new Ar(), t4 = new Ar(), n3 = new Ar(), r3 = new Ar(), o3 = new Qn(), a3 = new Qn(), l3 = new Qn();
          for (let p2 = 0, d2 = 0; p2 < i2.length; p2 += 9, d2 += 6) {
            e4.set(i2[p2 + 0], i2[p2 + 1], i2[p2 + 2]), t4.set(i2[p2 + 3], i2[p2 + 4], i2[p2 + 5]), n3.set(i2[p2 + 6], i2[p2 + 7], i2[p2 + 8]), o3.set(s2[d2 + 0], s2[d2 + 1]), a3.set(s2[d2 + 2], s2[d2 + 3]), l3.set(s2[d2 + 4], s2[d2 + 5]), r3.copy(e4).add(t4).add(n3).divideScalar(3);
            const h2 = u2(r3);
            c2(o3, d2 + 0, e4, h2), c2(a3, d2 + 2, t4, h2), c2(l3, d2 + 4, n3, h2);
          }
        })(), function() {
          for (let e4 = 0; e4 < s2.length; e4 += 6) {
            const t4 = s2[e4 + 0], n3 = s2[e4 + 2], r3 = s2[e4 + 4], i3 = Math.max(t4, n3, r3), o3 = Math.min(t4, n3, r3);
            i3 > 0.9 && o3 < 0.1 && (t4 < 0.2 && (s2[e4 + 0] += 1), n3 < 0.2 && (s2[e4 + 2] += 1), r3 < 0.2 && (s2[e4 + 4] += 1));
          }
        }();
      }(), this.setAttribute("position", new ls(i2, 3)), this.setAttribute("normal", new ls(i2.slice(), 3)), this.setAttribute("uv", new ls(s2, 2)), 0 === r2 ? this.computeVertexNormals() : this.normalizeNormals();
    }
    copy(e2) {
      return super.copy(e2), this.parameters = Object.assign({}, e2.parameters), this;
    }
    static fromJSON(e2) {
      return new ku(e2.vertices, e2.indices, e2.radius, e2.details);
    }
  }
  class Du extends ku {
    constructor(e2 = 1, t2 = 0) {
      const n2 = (1 + Math.sqrt(5)) / 2, r2 = 1 / n2;
      super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r2, -n2, 0, -r2, n2, 0, r2, -n2, 0, r2, n2, -r2, -n2, 0, -r2, n2, 0, r2, -n2, 0, r2, n2, 0, -n2, 0, -r2, n2, 0, -r2, -n2, 0, r2, n2, 0, r2], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e2, t2), this.type = "DodecahedronGeometry", this.parameters = { radius: e2, detail: t2 };
    }
    static fromJSON(e2) {
      return new Du(e2.radius, e2.detail);
    }
  }
  const Bu = new Ar(), Ou = new Ar(), Lu = new Ar(), Uu = new Oi();
  class Fu extends gs {
    constructor(e2 = null, t2 = 1) {
      if (super(), this.type = "EdgesGeometry", this.parameters = { geometry: e2, thresholdAngle: t2 }, null !== e2) {
        const n2 = 4, r2 = Math.pow(10, n2), i2 = Math.cos(Dn * t2), s2 = e2.getIndex(), o2 = e2.getAttribute("position"), a2 = s2 ? s2.count : o2.count, l2 = [0, 0, 0], c2 = ["a", "b", "c"], u2 = new Array(3), p2 = {}, d2 = [];
        for (let e3 = 0; e3 < a2; e3 += 3) {
          s2 ? (l2[0] = s2.getX(e3), l2[1] = s2.getX(e3 + 1), l2[2] = s2.getX(e3 + 2)) : (l2[0] = e3, l2[1] = e3 + 1, l2[2] = e3 + 2);
          const { a: t3, b: n3, c: a3 } = Uu;
          if (t3.fromBufferAttribute(o2, l2[0]), n3.fromBufferAttribute(o2, l2[1]), a3.fromBufferAttribute(o2, l2[2]), Uu.getNormal(Lu), u2[0] = `${Math.round(t3.x * r2)},${Math.round(t3.y * r2)},${Math.round(t3.z * r2)}`, u2[1] = `${Math.round(n3.x * r2)},${Math.round(n3.y * r2)},${Math.round(n3.z * r2)}`, u2[2] = `${Math.round(a3.x * r2)},${Math.round(a3.y * r2)},${Math.round(a3.z * r2)}`, u2[0] !== u2[1] && u2[1] !== u2[2] && u2[2] !== u2[0])
            for (let e4 = 0; e4 < 3; e4++) {
              const t4 = (e4 + 1) % 3, n4 = u2[e4], r3 = u2[t4], s3 = Uu[c2[e4]], o3 = Uu[c2[t4]], a4 = `${n4}_${r3}`, h2 = `${r3}_${n4}`;
              h2 in p2 && p2[h2] ? (Lu.dot(p2[h2].normal) <= i2 && (d2.push(s3.x, s3.y, s3.z), d2.push(o3.x, o3.y, o3.z)), p2[h2] = null) : a4 in p2 || (p2[a4] = { index0: l2[e4], index1: l2[t4], normal: Lu.clone() });
            }
        }
        for (const e3 in p2)
          if (p2[e3]) {
            const { index0: t3, index1: n3 } = p2[e3];
            Bu.fromBufferAttribute(o2, t3), Ou.fromBufferAttribute(o2, n3), d2.push(Bu.x, Bu.y, Bu.z), d2.push(Ou.x, Ou.y, Ou.z);
          }
        this.setAttribute("position", new ls(d2, 3));
      }
    }
    copy(e2) {
      return super.copy(e2), this.parameters = Object.assign({}, e2.parameters), this;
    }
  }
  class Nu extends Su {
    constructor(e2) {
      super(e2), this.uuid = On(), this.type = "Shape", this.holes = [];
    }
    getPointsHoles(e2) {
      const t2 = [];
      for (let n2 = 0, r2 = this.holes.length; n2 < r2; n2++)
        t2[n2] = this.holes[n2].getPoints(e2);
      return t2;
    }
    extractPoints(e2) {
      return { shape: this.getPoints(e2), holes: this.getPointsHoles(e2) };
    }
    copy(e2) {
      super.copy(e2), this.holes = [];
      for (let t2 = 0, n2 = e2.holes.length; t2 < n2; t2++) {
        const n3 = e2.holes[t2];
        this.holes.push(n3.clone());
      }
      return this;
    }
    toJSON() {
      const e2 = super.toJSON();
      e2.uuid = this.uuid, e2.holes = [];
      for (let t2 = 0, n2 = this.holes.length; t2 < n2; t2++) {
        const n3 = this.holes[t2];
        e2.holes.push(n3.toJSON());
      }
      return e2;
    }
    fromJSON(e2) {
      super.fromJSON(e2), this.uuid = e2.uuid, this.holes = [];
      for (let t2 = 0, n2 = e2.holes.length; t2 < n2; t2++) {
        const n3 = e2.holes[t2];
        this.holes.push(new Su().fromJSON(n3));
      }
      return this;
    }
  }
  function ju(e2, t2, n2, r2, i2) {
    let s2, o2;
    if (i2 === function(e3, t3, n3, r3) {
      let i3 = 0;
      for (let s3 = t3, o3 = n3 - r3; s3 < n3; s3 += r3)
        i3 += (e3[o3] - e3[s3]) * (e3[s3 + 1] + e3[o3 + 1]), o3 = s3;
      return i3;
    }(e2, t2, n2, r2) > 0)
      for (s2 = t2; s2 < n2; s2 += r2)
        o2 = ap(s2, e2[s2], e2[s2 + 1], o2);
    else
      for (s2 = n2 - r2; s2 >= t2; s2 -= r2)
        o2 = ap(s2, e2[s2], e2[s2 + 1], o2);
    return o2 && tp(o2, o2.next) && (lp(o2), o2 = o2.next), o2;
  }
  function zu(e2, t2) {
    if (!e2)
      return e2;
    t2 || (t2 = e2);
    let n2, r2 = e2;
    do {
      if (n2 = false, r2.steiner || !tp(r2, r2.next) && 0 !== ep(r2.prev, r2, r2.next))
        r2 = r2.next;
      else {
        if (lp(r2), r2 = t2 = r2.prev, r2 === r2.next)
          break;
        n2 = true;
      }
    } while (n2 || r2 !== t2);
    return t2;
  }
  function Gu(e2, t2, n2, r2, i2, s2, o2) {
    if (!e2)
      return;
    !o2 && s2 && function(e3, t3, n3, r3) {
      let i3 = e3;
      do {
        0 === i3.z && (i3.z = Ku(i3.x, i3.y, t3, n3, r3)), i3.prevZ = i3.prev, i3.nextZ = i3.next, i3 = i3.next;
      } while (i3 !== e3);
      i3.prevZ.nextZ = null, i3.prevZ = null, function(e4) {
        let t4, n4, r4, i4, s3, o3, a3, l3, c3 = 1;
        do {
          for (n4 = e4, e4 = null, s3 = null, o3 = 0; n4; ) {
            for (o3++, r4 = n4, a3 = 0, t4 = 0; t4 < c3 && (a3++, r4 = r4.nextZ, r4); t4++)
              ;
            for (l3 = c3; a3 > 0 || l3 > 0 && r4; )
              0 !== a3 && (0 === l3 || !r4 || n4.z <= r4.z) ? (i4 = n4, n4 = n4.nextZ, a3--) : (i4 = r4, r4 = r4.nextZ, l3--), s3 ? s3.nextZ = i4 : e4 = i4, i4.prevZ = s3, s3 = i4;
            n4 = r4;
          }
          s3.nextZ = null, c3 *= 2;
        } while (o3 > 1);
      }(i3);
    }(e2, r2, i2, s2);
    let a2, l2, c2 = e2;
    for (; e2.prev !== e2.next; )
      if (a2 = e2.prev, l2 = e2.next, s2 ? Hu(e2, r2, i2, s2) : Vu(e2))
        t2.push(a2.i / n2 | 0), t2.push(e2.i / n2 | 0), t2.push(l2.i / n2 | 0), lp(e2), e2 = l2.next, c2 = l2.next;
      else if ((e2 = l2) === c2) {
        o2 ? 1 === o2 ? Gu(e2 = Qu(zu(e2), t2, n2), t2, n2, r2, i2, s2, 2) : 2 === o2 && Wu(e2, t2, n2, r2, i2, s2) : Gu(zu(e2), t2, n2, r2, i2, s2, 1);
        break;
      }
  }
  function Vu(e2) {
    const t2 = e2.prev, n2 = e2, r2 = e2.next;
    if (ep(t2, n2, r2) >= 0)
      return false;
    const i2 = t2.x, s2 = n2.x, o2 = r2.x, a2 = t2.y, l2 = n2.y, c2 = r2.y, u2 = i2 < s2 ? i2 < o2 ? i2 : o2 : s2 < o2 ? s2 : o2, p2 = a2 < l2 ? a2 < c2 ? a2 : c2 : l2 < c2 ? l2 : c2, d2 = i2 > s2 ? i2 > o2 ? i2 : o2 : s2 > o2 ? s2 : o2, h2 = a2 > l2 ? a2 > c2 ? a2 : c2 : l2 > c2 ? l2 : c2;
    let f2 = r2.next;
    for (; f2 !== t2; ) {
      if (f2.x >= u2 && f2.x <= d2 && f2.y >= p2 && f2.y <= h2 && Zu(i2, a2, s2, l2, o2, c2, f2.x, f2.y) && ep(f2.prev, f2, f2.next) >= 0)
        return false;
      f2 = f2.next;
    }
    return true;
  }
  function Hu(e2, t2, n2, r2) {
    const i2 = e2.prev, s2 = e2, o2 = e2.next;
    if (ep(i2, s2, o2) >= 0)
      return false;
    const a2 = i2.x, l2 = s2.x, c2 = o2.x, u2 = i2.y, p2 = s2.y, d2 = o2.y, h2 = a2 < l2 ? a2 < c2 ? a2 : c2 : l2 < c2 ? l2 : c2, f2 = u2 < p2 ? u2 < d2 ? u2 : d2 : p2 < d2 ? p2 : d2, m2 = a2 > l2 ? a2 > c2 ? a2 : c2 : l2 > c2 ? l2 : c2, _2 = u2 > p2 ? u2 > d2 ? u2 : d2 : p2 > d2 ? p2 : d2, g2 = Ku(h2, f2, t2, n2, r2), v2 = Ku(m2, _2, t2, n2, r2);
    let y2 = e2.prevZ, b2 = e2.nextZ;
    for (; y2 && y2.z >= g2 && b2 && b2.z <= v2; ) {
      if (y2.x >= h2 && y2.x <= m2 && y2.y >= f2 && y2.y <= _2 && y2 !== i2 && y2 !== o2 && Zu(a2, u2, l2, p2, c2, d2, y2.x, y2.y) && ep(y2.prev, y2, y2.next) >= 0)
        return false;
      if (y2 = y2.prevZ, b2.x >= h2 && b2.x <= m2 && b2.y >= f2 && b2.y <= _2 && b2 !== i2 && b2 !== o2 && Zu(a2, u2, l2, p2, c2, d2, b2.x, b2.y) && ep(b2.prev, b2, b2.next) >= 0)
        return false;
      b2 = b2.nextZ;
    }
    for (; y2 && y2.z >= g2; ) {
      if (y2.x >= h2 && y2.x <= m2 && y2.y >= f2 && y2.y <= _2 && y2 !== i2 && y2 !== o2 && Zu(a2, u2, l2, p2, c2, d2, y2.x, y2.y) && ep(y2.prev, y2, y2.next) >= 0)
        return false;
      y2 = y2.prevZ;
    }
    for (; b2 && b2.z <= v2; ) {
      if (b2.x >= h2 && b2.x <= m2 && b2.y >= f2 && b2.y <= _2 && b2 !== i2 && b2 !== o2 && Zu(a2, u2, l2, p2, c2, d2, b2.x, b2.y) && ep(b2.prev, b2, b2.next) >= 0)
        return false;
      b2 = b2.nextZ;
    }
    return true;
  }
  function Qu(e2, t2, n2) {
    let r2 = e2;
    do {
      const i2 = r2.prev, s2 = r2.next.next;
      !tp(i2, s2) && np(i2, r2, r2.next, s2) && sp(i2, s2) && sp(s2, i2) && (t2.push(i2.i / n2 | 0), t2.push(r2.i / n2 | 0), t2.push(s2.i / n2 | 0), lp(r2), lp(r2.next), r2 = e2 = s2), r2 = r2.next;
    } while (r2 !== e2);
    return zu(r2);
  }
  function Wu(e2, t2, n2, r2, i2, s2) {
    let o2 = e2;
    do {
      let e3 = o2.next.next;
      for (; e3 !== o2.prev; ) {
        if (o2.i !== e3.i && $u(o2, e3)) {
          let a2 = op(o2, e3);
          return o2 = zu(o2, o2.next), a2 = zu(a2, a2.next), Gu(o2, t2, n2, r2, i2, s2, 0), void Gu(a2, t2, n2, r2, i2, s2, 0);
        }
        e3 = e3.next;
      }
      o2 = o2.next;
    } while (o2 !== e2);
  }
  function qu(e2, t2) {
    return e2.x - t2.x;
  }
  function Xu(e2, t2) {
    const n2 = function(e3, t3) {
      let n3, r3 = t3, i2 = -1 / 0;
      const s2 = e3.x, o2 = e3.y;
      do {
        if (o2 <= r3.y && o2 >= r3.next.y && r3.next.y !== r3.y) {
          const e4 = r3.x + (o2 - r3.y) * (r3.next.x - r3.x) / (r3.next.y - r3.y);
          if (e4 <= s2 && e4 > i2 && (i2 = e4, n3 = r3.x < r3.next.x ? r3 : r3.next, e4 === s2))
            return n3;
        }
        r3 = r3.next;
      } while (r3 !== t3);
      if (!n3)
        return null;
      const a2 = n3, l2 = n3.x, c2 = n3.y;
      let u2, p2 = 1 / 0;
      r3 = n3;
      do {
        s2 >= r3.x && r3.x >= l2 && s2 !== r3.x && Zu(o2 < c2 ? s2 : i2, o2, l2, c2, o2 < c2 ? i2 : s2, o2, r3.x, r3.y) && (u2 = Math.abs(o2 - r3.y) / (s2 - r3.x), sp(r3, e3) && (u2 < p2 || u2 === p2 && (r3.x > n3.x || r3.x === n3.x && Yu(n3, r3))) && (n3 = r3, p2 = u2)), r3 = r3.next;
      } while (r3 !== a2);
      return n3;
    }(e2, t2);
    if (!n2)
      return t2;
    const r2 = op(n2, e2);
    return zu(r2, r2.next), zu(n2, n2.next);
  }
  function Yu(e2, t2) {
    return ep(e2.prev, e2, t2.prev) < 0 && ep(t2.next, e2, e2.next) < 0;
  }
  function Ku(e2, t2, n2, r2, i2) {
    return (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = (e2 - n2) * i2 | 0) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) | (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = (t2 - r2) * i2 | 0) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) << 1;
  }
  function Ju(e2) {
    let t2 = e2, n2 = e2;
    do {
      (t2.x < n2.x || t2.x === n2.x && t2.y < n2.y) && (n2 = t2), t2 = t2.next;
    } while (t2 !== e2);
    return n2;
  }
  function Zu(e2, t2, n2, r2, i2, s2, o2, a2) {
    return (i2 - o2) * (t2 - a2) >= (e2 - o2) * (s2 - a2) && (e2 - o2) * (r2 - a2) >= (n2 - o2) * (t2 - a2) && (n2 - o2) * (s2 - a2) >= (i2 - o2) * (r2 - a2);
  }
  function $u(e2, t2) {
    return e2.next.i !== t2.i && e2.prev.i !== t2.i && !function(e3, t3) {
      let n2 = e3;
      do {
        if (n2.i !== e3.i && n2.next.i !== e3.i && n2.i !== t3.i && n2.next.i !== t3.i && np(n2, n2.next, e3, t3))
          return true;
        n2 = n2.next;
      } while (n2 !== e3);
      return false;
    }(e2, t2) && (sp(e2, t2) && sp(t2, e2) && function(e3, t3) {
      let n2 = e3, r2 = false;
      const i2 = (e3.x + t3.x) / 2, s2 = (e3.y + t3.y) / 2;
      do {
        n2.y > s2 != n2.next.y > s2 && n2.next.y !== n2.y && i2 < (n2.next.x - n2.x) * (s2 - n2.y) / (n2.next.y - n2.y) + n2.x && (r2 = !r2), n2 = n2.next;
      } while (n2 !== e3);
      return r2;
    }(e2, t2) && (ep(e2.prev, e2, t2.prev) || ep(e2, t2.prev, t2)) || tp(e2, t2) && ep(e2.prev, e2, e2.next) > 0 && ep(t2.prev, t2, t2.next) > 0);
  }
  function ep(e2, t2, n2) {
    return (t2.y - e2.y) * (n2.x - t2.x) - (t2.x - e2.x) * (n2.y - t2.y);
  }
  function tp(e2, t2) {
    return e2.x === t2.x && e2.y === t2.y;
  }
  function np(e2, t2, n2, r2) {
    const i2 = ip(ep(e2, t2, n2)), s2 = ip(ep(e2, t2, r2)), o2 = ip(ep(n2, r2, e2)), a2 = ip(ep(n2, r2, t2));
    return i2 !== s2 && o2 !== a2 || !(0 !== i2 || !rp(e2, n2, t2)) || !(0 !== s2 || !rp(e2, r2, t2)) || !(0 !== o2 || !rp(n2, e2, r2)) || !(0 !== a2 || !rp(n2, t2, r2));
  }
  function rp(e2, t2, n2) {
    return t2.x <= Math.max(e2.x, n2.x) && t2.x >= Math.min(e2.x, n2.x) && t2.y <= Math.max(e2.y, n2.y) && t2.y >= Math.min(e2.y, n2.y);
  }
  function ip(e2) {
    return e2 > 0 ? 1 : e2 < 0 ? -1 : 0;
  }
  function sp(e2, t2) {
    return ep(e2.prev, e2, e2.next) < 0 ? ep(e2, t2, e2.next) >= 0 && ep(e2, e2.prev, t2) >= 0 : ep(e2, t2, e2.prev) < 0 || ep(e2, e2.next, t2) < 0;
  }
  function op(e2, t2) {
    const n2 = new cp(e2.i, e2.x, e2.y), r2 = new cp(t2.i, t2.x, t2.y), i2 = e2.next, s2 = t2.prev;
    return e2.next = t2, t2.prev = e2, n2.next = i2, i2.prev = n2, r2.next = n2, n2.prev = r2, s2.next = r2, r2.prev = s2, r2;
  }
  function ap(e2, t2, n2, r2) {
    const i2 = new cp(e2, t2, n2);
    return r2 ? (i2.next = r2.next, i2.prev = r2, r2.next.prev = i2, r2.next = i2) : (i2.prev = i2, i2.next = i2), i2;
  }
  function lp(e2) {
    e2.next.prev = e2.prev, e2.prev.next = e2.next, e2.prevZ && (e2.prevZ.nextZ = e2.nextZ), e2.nextZ && (e2.nextZ.prevZ = e2.prevZ);
  }
  function cp(e2, t2, n2) {
    this.i = e2, this.x = t2, this.y = n2, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
  }
  class up {
    static area(e2) {
      const t2 = e2.length;
      let n2 = 0;
      for (let r2 = t2 - 1, i2 = 0; i2 < t2; r2 = i2++)
        n2 += e2[r2].x * e2[i2].y - e2[i2].x * e2[r2].y;
      return 0.5 * n2;
    }
    static isClockWise(e2) {
      return up.area(e2) < 0;
    }
    static triangulateShape(e2, t2) {
      const n2 = [], r2 = [], i2 = [];
      pp(e2), dp(n2, e2);
      let s2 = e2.length;
      t2.forEach(pp);
      for (let e3 = 0; e3 < t2.length; e3++)
        r2.push(s2), s2 += t2[e3].length, dp(n2, t2[e3]);
      const o2 = function(e3, t3, n3 = 2) {
        const r3 = t3 && t3.length, i3 = r3 ? t3[0] * n3 : e3.length;
        let s3 = ju(e3, 0, i3, n3, true);
        const o3 = [];
        if (!s3 || s3.next === s3.prev)
          return o3;
        let a2, l2, c2, u2, p2, d2, h2;
        if (r3 && (s3 = function(e4, t4, n4, r4) {
          const i4 = [];
          let s4, o4, a3, l3, c3;
          for (s4 = 0, o4 = t4.length; s4 < o4; s4++)
            a3 = t4[s4] * r4, l3 = s4 < o4 - 1 ? t4[s4 + 1] * r4 : e4.length, c3 = ju(e4, a3, l3, r4, false), c3 === c3.next && (c3.steiner = true), i4.push(Ju(c3));
          for (i4.sort(qu), s4 = 0; s4 < i4.length; s4++)
            n4 = Xu(i4[s4], n4);
          return n4;
        }(e3, t3, s3, n3)), e3.length > 80 * n3) {
          a2 = c2 = e3[0], l2 = u2 = e3[1];
          for (let t4 = n3; t4 < i3; t4 += n3)
            p2 = e3[t4], d2 = e3[t4 + 1], p2 < a2 && (a2 = p2), d2 < l2 && (l2 = d2), p2 > c2 && (c2 = p2), d2 > u2 && (u2 = d2);
          h2 = Math.max(c2 - a2, u2 - l2), h2 = 0 !== h2 ? 32767 / h2 : 0;
        }
        return Gu(s3, o3, n3, a2, l2, h2, 0), o3;
      }(n2, r2);
      for (let e3 = 0; e3 < o2.length; e3 += 3)
        i2.push(o2.slice(e3, e3 + 3));
      return i2;
    }
  }
  function pp(e2) {
    const t2 = e2.length;
    t2 > 2 && e2[t2 - 1].equals(e2[0]) && e2.pop();
  }
  function dp(e2, t2) {
    for (let n2 = 0; n2 < t2.length; n2++)
      e2.push(t2[n2].x), e2.push(t2[n2].y);
  }
  class hp extends gs {
    constructor(e2 = new Nu([new Qn(0.5, 0.5), new Qn(-0.5, 0.5), new Qn(-0.5, -0.5), new Qn(0.5, -0.5)]), t2 = {}) {
      super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: e2, options: t2 }, e2 = Array.isArray(e2) ? e2 : [e2];
      const n2 = this, r2 = [], i2 = [];
      for (let t3 = 0, n3 = e2.length; t3 < n3; t3++)
        s2(e2[t3]);
      function s2(e3) {
        const s3 = [], o2 = void 0 !== t2.curveSegments ? t2.curveSegments : 12, a2 = void 0 !== t2.steps ? t2.steps : 1, l2 = void 0 !== t2.depth ? t2.depth : 1;
        let c2 = void 0 === t2.bevelEnabled || t2.bevelEnabled, u2 = void 0 !== t2.bevelThickness ? t2.bevelThickness : 0.2, p2 = void 0 !== t2.bevelSize ? t2.bevelSize : u2 - 0.1, d2 = void 0 !== t2.bevelOffset ? t2.bevelOffset : 0, h2 = void 0 !== t2.bevelSegments ? t2.bevelSegments : 3;
        const f2 = t2.extrudePath, m2 = void 0 !== t2.UVGenerator ? t2.UVGenerator : fp;
        let _2, g2, v2, y2, b2, w2 = false;
        f2 && (_2 = f2.getSpacedPoints(a2), w2 = true, c2 = false, g2 = f2.computeFrenetFrames(a2, false), v2 = new Ar(), y2 = new Ar(), b2 = new Ar()), c2 || (h2 = 0, u2 = 0, p2 = 0, d2 = 0);
        const A2 = e3.extractPoints(o2);
        let x2 = A2.shape;
        const E2 = A2.holes;
        if (!up.isClockWise(x2)) {
          x2 = x2.reverse();
          for (let e4 = 0, t3 = E2.length; e4 < t3; e4++) {
            const t4 = E2[e4];
            up.isClockWise(t4) && (E2[e4] = t4.reverse());
          }
        }
        const C2 = up.triangulateShape(x2, E2), S2 = x2;
        for (let e4 = 0, t3 = E2.length; e4 < t3; e4++) {
          const t4 = E2[e4];
          x2 = x2.concat(t4);
        }
        function M2(e4, t3, n3) {
          return t3 || console.error("THREE.ExtrudeGeometry: vec does not exist"), e4.clone().addScaledVector(t3, n3);
        }
        const T2 = x2.length, P2 = C2.length;
        function I2(e4, t3, n3) {
          let r3, i3, s4;
          const o3 = e4.x - t3.x, a3 = e4.y - t3.y, l3 = n3.x - e4.x, c3 = n3.y - e4.y, u3 = o3 * o3 + a3 * a3, p3 = o3 * c3 - a3 * l3;
          if (Math.abs(p3) > Number.EPSILON) {
            const p4 = Math.sqrt(u3), d3 = Math.sqrt(l3 * l3 + c3 * c3), h3 = t3.x - a3 / p4, f3 = t3.y + o3 / p4, m3 = ((n3.x - c3 / d3 - h3) * c3 - (n3.y + l3 / d3 - f3) * l3) / (o3 * c3 - a3 * l3);
            r3 = h3 + o3 * m3 - e4.x, i3 = f3 + a3 * m3 - e4.y;
            const _3 = r3 * r3 + i3 * i3;
            if (_3 <= 2)
              return new Qn(r3, i3);
            s4 = Math.sqrt(_3 / 2);
          } else {
            let e5 = false;
            o3 > Number.EPSILON ? l3 > Number.EPSILON && (e5 = true) : o3 < -Number.EPSILON ? l3 < -Number.EPSILON && (e5 = true) : Math.sign(a3) === Math.sign(c3) && (e5 = true), e5 ? (r3 = -a3, i3 = o3, s4 = Math.sqrt(u3)) : (r3 = o3, i3 = a3, s4 = Math.sqrt(u3 / 2));
          }
          return new Qn(r3 / s4, i3 / s4);
        }
        const R2 = [];
        for (let e4 = 0, t3 = S2.length, n3 = t3 - 1, r3 = e4 + 1; e4 < t3; e4++, n3++, r3++)
          n3 === t3 && (n3 = 0), r3 === t3 && (r3 = 0), R2[e4] = I2(S2[e4], S2[n3], S2[r3]);
        const k2 = [];
        let D2, B2 = R2.concat();
        for (let e4 = 0, t3 = E2.length; e4 < t3; e4++) {
          const t4 = E2[e4];
          D2 = [];
          for (let e5 = 0, n3 = t4.length, r3 = n3 - 1, i3 = e5 + 1; e5 < n3; e5++, r3++, i3++)
            r3 === n3 && (r3 = 0), i3 === n3 && (i3 = 0), D2[e5] = I2(t4[e5], t4[r3], t4[i3]);
          k2.push(D2), B2 = B2.concat(D2);
        }
        for (let e4 = 0; e4 < h2; e4++) {
          const t3 = e4 / h2, n3 = u2 * Math.cos(t3 * Math.PI / 2), r3 = p2 * Math.sin(t3 * Math.PI / 2) + d2;
          for (let e5 = 0, t4 = S2.length; e5 < t4; e5++) {
            const t5 = M2(S2[e5], R2[e5], r3);
            U2(t5.x, t5.y, -n3);
          }
          for (let e5 = 0, t4 = E2.length; e5 < t4; e5++) {
            const t5 = E2[e5];
            D2 = k2[e5];
            for (let e6 = 0, i3 = t5.length; e6 < i3; e6++) {
              const i4 = M2(t5[e6], D2[e6], r3);
              U2(i4.x, i4.y, -n3);
            }
          }
        }
        const O2 = p2 + d2;
        for (let e4 = 0; e4 < T2; e4++) {
          const t3 = c2 ? M2(x2[e4], B2[e4], O2) : x2[e4];
          w2 ? (y2.copy(g2.normals[0]).multiplyScalar(t3.x), v2.copy(g2.binormals[0]).multiplyScalar(t3.y), b2.copy(_2[0]).add(y2).add(v2), U2(b2.x, b2.y, b2.z)) : U2(t3.x, t3.y, 0);
        }
        for (let e4 = 1; e4 <= a2; e4++)
          for (let t3 = 0; t3 < T2; t3++) {
            const n3 = c2 ? M2(x2[t3], B2[t3], O2) : x2[t3];
            w2 ? (y2.copy(g2.normals[e4]).multiplyScalar(n3.x), v2.copy(g2.binormals[e4]).multiplyScalar(n3.y), b2.copy(_2[e4]).add(y2).add(v2), U2(b2.x, b2.y, b2.z)) : U2(n3.x, n3.y, l2 / a2 * e4);
          }
        for (let e4 = h2 - 1; e4 >= 0; e4--) {
          const t3 = e4 / h2, n3 = u2 * Math.cos(t3 * Math.PI / 2), r3 = p2 * Math.sin(t3 * Math.PI / 2) + d2;
          for (let e5 = 0, t4 = S2.length; e5 < t4; e5++) {
            const t5 = M2(S2[e5], R2[e5], r3);
            U2(t5.x, t5.y, l2 + n3);
          }
          for (let e5 = 0, t4 = E2.length; e5 < t4; e5++) {
            const t5 = E2[e5];
            D2 = k2[e5];
            for (let e6 = 0, i3 = t5.length; e6 < i3; e6++) {
              const i4 = M2(t5[e6], D2[e6], r3);
              w2 ? U2(i4.x, i4.y + _2[a2 - 1].y, _2[a2 - 1].x + n3) : U2(i4.x, i4.y, l2 + n3);
            }
          }
        }
        function L2(e4, t3) {
          let n3 = e4.length;
          for (; --n3 >= 0; ) {
            const r3 = n3;
            let i3 = n3 - 1;
            i3 < 0 && (i3 = e4.length - 1);
            for (let e5 = 0, n4 = a2 + 2 * h2; e5 < n4; e5++) {
              const n5 = T2 * e5, s4 = T2 * (e5 + 1);
              N2(t3 + r3 + n5, t3 + i3 + n5, t3 + i3 + s4, t3 + r3 + s4);
            }
          }
        }
        function U2(e4, t3, n3) {
          s3.push(e4), s3.push(t3), s3.push(n3);
        }
        function F2(e4, t3, i3) {
          j2(e4), j2(t3), j2(i3);
          const s4 = r2.length / 3, o3 = m2.generateTopUV(n2, r2, s4 - 3, s4 - 2, s4 - 1);
          z2(o3[0]), z2(o3[1]), z2(o3[2]);
        }
        function N2(e4, t3, i3, s4) {
          j2(e4), j2(t3), j2(s4), j2(t3), j2(i3), j2(s4);
          const o3 = r2.length / 3, a3 = m2.generateSideWallUV(n2, r2, o3 - 6, o3 - 3, o3 - 2, o3 - 1);
          z2(a3[0]), z2(a3[1]), z2(a3[3]), z2(a3[1]), z2(a3[2]), z2(a3[3]);
        }
        function j2(e4) {
          r2.push(s3[3 * e4 + 0]), r2.push(s3[3 * e4 + 1]), r2.push(s3[3 * e4 + 2]);
        }
        function z2(e4) {
          i2.push(e4.x), i2.push(e4.y);
        }
        !function() {
          const e4 = r2.length / 3;
          if (c2) {
            let e5 = 0, t3 = T2 * e5;
            for (let e6 = 0; e6 < P2; e6++) {
              const n3 = C2[e6];
              F2(n3[2] + t3, n3[1] + t3, n3[0] + t3);
            }
            e5 = a2 + 2 * h2, t3 = T2 * e5;
            for (let e6 = 0; e6 < P2; e6++) {
              const n3 = C2[e6];
              F2(n3[0] + t3, n3[1] + t3, n3[2] + t3);
            }
          } else {
            for (let e5 = 0; e5 < P2; e5++) {
              const t3 = C2[e5];
              F2(t3[2], t3[1], t3[0]);
            }
            for (let e5 = 0; e5 < P2; e5++) {
              const t3 = C2[e5];
              F2(t3[0] + T2 * a2, t3[1] + T2 * a2, t3[2] + T2 * a2);
            }
          }
          n2.addGroup(e4, r2.length / 3 - e4, 0);
        }(), function() {
          const e4 = r2.length / 3;
          let t3 = 0;
          L2(S2, t3), t3 += S2.length;
          for (let e5 = 0, n3 = E2.length; e5 < n3; e5++) {
            const n4 = E2[e5];
            L2(n4, t3), t3 += n4.length;
          }
          n2.addGroup(e4, r2.length / 3 - e4, 1);
        }();
      }
      this.setAttribute("position", new ls(r2, 3)), this.setAttribute("uv", new ls(i2, 2)), this.computeVertexNormals();
    }
    copy(e2) {
      return super.copy(e2), this.parameters = Object.assign({}, e2.parameters), this;
    }
    toJSON() {
      const e2 = super.toJSON();
      return function(e3, t2, n2) {
        if (n2.shapes = [], Array.isArray(e3))
          for (let t3 = 0, r2 = e3.length; t3 < r2; t3++) {
            const r3 = e3[t3];
            n2.shapes.push(r3.uuid);
          }
        else
          n2.shapes.push(e3.uuid);
        return n2.options = Object.assign({}, t2), void 0 !== t2.extrudePath && (n2.options.extrudePath = t2.extrudePath.toJSON()), n2;
      }(this.parameters.shapes, this.parameters.options, e2);
    }
    static fromJSON(e2, t2) {
      const n2 = [];
      for (let r3 = 0, i2 = e2.shapes.length; r3 < i2; r3++) {
        const i3 = t2[e2.shapes[r3]];
        n2.push(i3);
      }
      const r2 = e2.options.extrudePath;
      return void 0 !== r2 && (e2.options.extrudePath = new Eu[r2.type]().fromJSON(r2)), new hp(n2, e2.options);
    }
  }
  const fp = { generateTopUV: function(e2, t2, n2, r2, i2) {
    const s2 = t2[3 * n2], o2 = t2[3 * n2 + 1], a2 = t2[3 * r2], l2 = t2[3 * r2 + 1], c2 = t2[3 * i2], u2 = t2[3 * i2 + 1];
    return [new Qn(s2, o2), new Qn(a2, l2), new Qn(c2, u2)];
  }, generateSideWallUV: function(e2, t2, n2, r2, i2, s2) {
    const o2 = t2[3 * n2], a2 = t2[3 * n2 + 1], l2 = t2[3 * n2 + 2], c2 = t2[3 * r2], u2 = t2[3 * r2 + 1], p2 = t2[3 * r2 + 2], d2 = t2[3 * i2], h2 = t2[3 * i2 + 1], f2 = t2[3 * i2 + 2], m2 = t2[3 * s2], _2 = t2[3 * s2 + 1], g2 = t2[3 * s2 + 2];
    return Math.abs(a2 - u2) < Math.abs(o2 - c2) ? [new Qn(o2, 1 - l2), new Qn(c2, 1 - p2), new Qn(d2, 1 - f2), new Qn(m2, 1 - g2)] : [new Qn(a2, 1 - l2), new Qn(u2, 1 - p2), new Qn(h2, 1 - f2), new Qn(_2, 1 - g2)];
  } };
  class mp extends ku {
    constructor(e2 = 1, t2 = 0) {
      const n2 = (1 + Math.sqrt(5)) / 2;
      super([-1, n2, 0, 1, n2, 0, -1, -n2, 0, 1, -n2, 0, 0, -1, n2, 0, 1, n2, 0, -1, -n2, 0, 1, -n2, n2, 0, -1, n2, 0, 1, -n2, 0, -1, -n2, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e2, t2), this.type = "IcosahedronGeometry", this.parameters = { radius: e2, detail: t2 };
    }
    static fromJSON(e2) {
      return new mp(e2.radius, e2.detail);
    }
  }
  class _p extends ku {
    constructor(e2 = 1, t2 = 0) {
      super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e2, t2), this.type = "OctahedronGeometry", this.parameters = { radius: e2, detail: t2 };
    }
    static fromJSON(e2) {
      return new _p(e2.radius, e2.detail);
    }
  }
  class gp extends gs {
    constructor(e2 = 0.5, t2 = 1, n2 = 32, r2 = 1, i2 = 0, s2 = 2 * Math.PI) {
      super(), this.type = "RingGeometry", this.parameters = { innerRadius: e2, outerRadius: t2, thetaSegments: n2, phiSegments: r2, thetaStart: i2, thetaLength: s2 }, n2 = Math.max(3, n2);
      const o2 = [], a2 = [], l2 = [], c2 = [];
      let u2 = e2;
      const p2 = (t2 - e2) / (r2 = Math.max(1, r2)), d2 = new Ar(), h2 = new Qn();
      for (let e3 = 0; e3 <= r2; e3++) {
        for (let e4 = 0; e4 <= n2; e4++) {
          const r3 = i2 + e4 / n2 * s2;
          d2.x = u2 * Math.cos(r3), d2.y = u2 * Math.sin(r3), a2.push(d2.x, d2.y, d2.z), l2.push(0, 0, 1), h2.x = (d2.x / t2 + 1) / 2, h2.y = (d2.y / t2 + 1) / 2, c2.push(h2.x, h2.y);
        }
        u2 += p2;
      }
      for (let e3 = 0; e3 < r2; e3++) {
        const t3 = e3 * (n2 + 1);
        for (let e4 = 0; e4 < n2; e4++) {
          const r3 = e4 + t3, i3 = r3, s3 = r3 + n2 + 1, a3 = r3 + n2 + 2, l3 = r3 + 1;
          o2.push(i3, s3, l3), o2.push(s3, a3, l3);
        }
      }
      this.setIndex(o2), this.setAttribute("position", new ls(a2, 3)), this.setAttribute("normal", new ls(l2, 3)), this.setAttribute("uv", new ls(c2, 2));
    }
    copy(e2) {
      return super.copy(e2), this.parameters = Object.assign({}, e2.parameters), this;
    }
    static fromJSON(e2) {
      return new gp(e2.innerRadius, e2.outerRadius, e2.thetaSegments, e2.phiSegments, e2.thetaStart, e2.thetaLength);
    }
  }
  class vp extends gs {
    constructor(e2 = new Nu([new Qn(0, 0.5), new Qn(-0.5, -0.5), new Qn(0.5, -0.5)]), t2 = 12) {
      super(), this.type = "ShapeGeometry", this.parameters = { shapes: e2, curveSegments: t2 };
      const n2 = [], r2 = [], i2 = [], s2 = [];
      let o2 = 0, a2 = 0;
      if (false === Array.isArray(e2))
        l2(e2);
      else
        for (let t3 = 0; t3 < e2.length; t3++)
          l2(e2[t3]), this.addGroup(o2, a2, t3), o2 += a2, a2 = 0;
      function l2(e3) {
        const o3 = r2.length / 3, l3 = e3.extractPoints(t2);
        let c2 = l3.shape;
        const u2 = l3.holes;
        false === up.isClockWise(c2) && (c2 = c2.reverse());
        for (let e4 = 0, t3 = u2.length; e4 < t3; e4++) {
          const t4 = u2[e4];
          true === up.isClockWise(t4) && (u2[e4] = t4.reverse());
        }
        const p2 = up.triangulateShape(c2, u2);
        for (let e4 = 0, t3 = u2.length; e4 < t3; e4++) {
          const t4 = u2[e4];
          c2 = c2.concat(t4);
        }
        for (let e4 = 0, t3 = c2.length; e4 < t3; e4++) {
          const t4 = c2[e4];
          r2.push(t4.x, t4.y, 0), i2.push(0, 0, 1), s2.push(t4.x, t4.y);
        }
        for (let e4 = 0, t3 = p2.length; e4 < t3; e4++) {
          const t4 = p2[e4], r3 = t4[0] + o3, i3 = t4[1] + o3, s3 = t4[2] + o3;
          n2.push(r3, i3, s3), a2 += 3;
        }
      }
      this.setIndex(n2), this.setAttribute("position", new ls(r2, 3)), this.setAttribute("normal", new ls(i2, 3)), this.setAttribute("uv", new ls(s2, 2));
    }
    copy(e2) {
      return super.copy(e2), this.parameters = Object.assign({}, e2.parameters), this;
    }
    toJSON() {
      const e2 = super.toJSON();
      return function(e3, t2) {
        if (t2.shapes = [], Array.isArray(e3))
          for (let n2 = 0, r2 = e3.length; n2 < r2; n2++) {
            const r3 = e3[n2];
            t2.shapes.push(r3.uuid);
          }
        else
          t2.shapes.push(e3.uuid);
        return t2;
      }(this.parameters.shapes, e2);
    }
    static fromJSON(e2, t2) {
      const n2 = [];
      for (let r2 = 0, i2 = e2.shapes.length; r2 < i2; r2++) {
        const i3 = t2[e2.shapes[r2]];
        n2.push(i3);
      }
      return new vp(n2, e2.curveSegments);
    }
  }
  class yp extends gs {
    constructor(e2 = 1, t2 = 32, n2 = 16, r2 = 0, i2 = 2 * Math.PI, s2 = 0, o2 = Math.PI) {
      super(), this.type = "SphereGeometry", this.parameters = { radius: e2, widthSegments: t2, heightSegments: n2, phiStart: r2, phiLength: i2, thetaStart: s2, thetaLength: o2 }, t2 = Math.max(3, Math.floor(t2)), n2 = Math.max(2, Math.floor(n2));
      const a2 = Math.min(s2 + o2, Math.PI);
      let l2 = 0;
      const c2 = [], u2 = new Ar(), p2 = new Ar(), d2 = [], h2 = [], f2 = [], m2 = [];
      for (let d3 = 0; d3 <= n2; d3++) {
        const _2 = [], g2 = d3 / n2;
        let v2 = 0;
        0 === d3 && 0 === s2 ? v2 = 0.5 / t2 : d3 === n2 && a2 === Math.PI && (v2 = -0.5 / t2);
        for (let n3 = 0; n3 <= t2; n3++) {
          const a3 = n3 / t2;
          u2.x = -e2 * Math.cos(r2 + a3 * i2) * Math.sin(s2 + g2 * o2), u2.y = e2 * Math.cos(s2 + g2 * o2), u2.z = e2 * Math.sin(r2 + a3 * i2) * Math.sin(s2 + g2 * o2), h2.push(u2.x, u2.y, u2.z), p2.copy(u2).normalize(), f2.push(p2.x, p2.y, p2.z), m2.push(a3 + v2, 1 - g2), _2.push(l2++);
        }
        c2.push(_2);
      }
      for (let e3 = 0; e3 < n2; e3++)
        for (let r3 = 0; r3 < t2; r3++) {
          const t3 = c2[e3][r3 + 1], i3 = c2[e3][r3], o3 = c2[e3 + 1][r3], l3 = c2[e3 + 1][r3 + 1];
          (0 !== e3 || s2 > 0) && d2.push(t3, i3, l3), (e3 !== n2 - 1 || a2 < Math.PI) && d2.push(i3, o3, l3);
        }
      this.setIndex(d2), this.setAttribute("position", new ls(h2, 3)), this.setAttribute("normal", new ls(f2, 3)), this.setAttribute("uv", new ls(m2, 2));
    }
    copy(e2) {
      return super.copy(e2), this.parameters = Object.assign({}, e2.parameters), this;
    }
    static fromJSON(e2) {
      return new yp(e2.radius, e2.widthSegments, e2.heightSegments, e2.phiStart, e2.phiLength, e2.thetaStart, e2.thetaLength);
    }
  }
  class bp extends ku {
    constructor(e2 = 1, t2 = 0) {
      super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e2, t2), this.type = "TetrahedronGeometry", this.parameters = { radius: e2, detail: t2 };
    }
    static fromJSON(e2) {
      return new bp(e2.radius, e2.detail);
    }
  }
  class wp extends gs {
    constructor(e2 = 1, t2 = 0.4, n2 = 12, r2 = 48, i2 = 2 * Math.PI) {
      super(), this.type = "TorusGeometry", this.parameters = { radius: e2, tube: t2, radialSegments: n2, tubularSegments: r2, arc: i2 }, n2 = Math.floor(n2), r2 = Math.floor(r2);
      const s2 = [], o2 = [], a2 = [], l2 = [], c2 = new Ar(), u2 = new Ar(), p2 = new Ar();
      for (let s3 = 0; s3 <= n2; s3++)
        for (let d2 = 0; d2 <= r2; d2++) {
          const h2 = d2 / r2 * i2, f2 = s3 / n2 * Math.PI * 2;
          u2.x = (e2 + t2 * Math.cos(f2)) * Math.cos(h2), u2.y = (e2 + t2 * Math.cos(f2)) * Math.sin(h2), u2.z = t2 * Math.sin(f2), o2.push(u2.x, u2.y, u2.z), c2.x = e2 * Math.cos(h2), c2.y = e2 * Math.sin(h2), p2.subVectors(u2, c2).normalize(), a2.push(p2.x, p2.y, p2.z), l2.push(d2 / r2), l2.push(s3 / n2);
        }
      for (let e3 = 1; e3 <= n2; e3++)
        for (let t3 = 1; t3 <= r2; t3++) {
          const n3 = (r2 + 1) * e3 + t3 - 1, i3 = (r2 + 1) * (e3 - 1) + t3 - 1, o3 = (r2 + 1) * (e3 - 1) + t3, a3 = (r2 + 1) * e3 + t3;
          s2.push(n3, i3, a3), s2.push(i3, o3, a3);
        }
      this.setIndex(s2), this.setAttribute("position", new ls(o2, 3)), this.setAttribute("normal", new ls(a2, 3)), this.setAttribute("uv", new ls(l2, 2));
    }
    copy(e2) {
      return super.copy(e2), this.parameters = Object.assign({}, e2.parameters), this;
    }
    static fromJSON(e2) {
      return new wp(e2.radius, e2.tube, e2.radialSegments, e2.tubularSegments, e2.arc);
    }
  }
  class Ap extends gs {
    constructor(e2 = 1, t2 = 0.4, n2 = 64, r2 = 8, i2 = 2, s2 = 3) {
      super(), this.type = "TorusKnotGeometry", this.parameters = { radius: e2, tube: t2, tubularSegments: n2, radialSegments: r2, p: i2, q: s2 }, n2 = Math.floor(n2), r2 = Math.floor(r2);
      const o2 = [], a2 = [], l2 = [], c2 = [], u2 = new Ar(), p2 = new Ar(), d2 = new Ar(), h2 = new Ar(), f2 = new Ar(), m2 = new Ar(), _2 = new Ar();
      for (let o3 = 0; o3 <= n2; ++o3) {
        const v2 = o3 / n2 * i2 * Math.PI * 2;
        g2(v2, i2, s2, e2, d2), g2(v2 + 0.01, i2, s2, e2, h2), m2.subVectors(h2, d2), _2.addVectors(h2, d2), f2.crossVectors(m2, _2), _2.crossVectors(f2, m2), f2.normalize(), _2.normalize();
        for (let e3 = 0; e3 <= r2; ++e3) {
          const i3 = e3 / r2 * Math.PI * 2, s3 = -t2 * Math.cos(i3), h3 = t2 * Math.sin(i3);
          u2.x = d2.x + (s3 * _2.x + h3 * f2.x), u2.y = d2.y + (s3 * _2.y + h3 * f2.y), u2.z = d2.z + (s3 * _2.z + h3 * f2.z), a2.push(u2.x, u2.y, u2.z), p2.subVectors(u2, d2).normalize(), l2.push(p2.x, p2.y, p2.z), c2.push(o3 / n2), c2.push(e3 / r2);
        }
      }
      for (let e3 = 1; e3 <= n2; e3++)
        for (let t3 = 1; t3 <= r2; t3++) {
          const n3 = (r2 + 1) * (e3 - 1) + (t3 - 1), i3 = (r2 + 1) * e3 + (t3 - 1), s3 = (r2 + 1) * e3 + t3, a3 = (r2 + 1) * (e3 - 1) + t3;
          o2.push(n3, i3, a3), o2.push(i3, s3, a3);
        }
      function g2(e3, t3, n3, r3, i3) {
        const s3 = Math.cos(e3), o3 = Math.sin(e3), a3 = n3 / t3 * e3, l3 = Math.cos(a3);
        i3.x = r3 * (2 + l3) * 0.5 * s3, i3.y = r3 * (2 + l3) * o3 * 0.5, i3.z = r3 * Math.sin(a3) * 0.5;
      }
      this.setIndex(o2), this.setAttribute("position", new ls(a2, 3)), this.setAttribute("normal", new ls(l2, 3)), this.setAttribute("uv", new ls(c2, 2));
    }
    copy(e2) {
      return super.copy(e2), this.parameters = Object.assign({}, e2.parameters), this;
    }
    static fromJSON(e2) {
      return new Ap(e2.radius, e2.tube, e2.tubularSegments, e2.radialSegments, e2.p, e2.q);
    }
  }
  class xp extends gs {
    constructor(e2 = new Au(new Ar(-1, -1, 0), new Ar(-1, 1, 0), new Ar(1, 1, 0)), t2 = 64, n2 = 1, r2 = 8, i2 = false) {
      super(), this.type = "TubeGeometry", this.parameters = { path: e2, tubularSegments: t2, radius: n2, radialSegments: r2, closed: i2 };
      const s2 = e2.computeFrenetFrames(t2, i2);
      this.tangents = s2.tangents, this.normals = s2.normals, this.binormals = s2.binormals;
      const o2 = new Ar(), a2 = new Ar(), l2 = new Qn();
      let c2 = new Ar();
      const u2 = [], p2 = [], d2 = [], h2 = [];
      function f2(i3) {
        c2 = e2.getPointAt(i3 / t2, c2);
        const l3 = s2.normals[i3], d3 = s2.binormals[i3];
        for (let e3 = 0; e3 <= r2; e3++) {
          const t3 = e3 / r2 * Math.PI * 2, i4 = Math.sin(t3), s3 = -Math.cos(t3);
          a2.x = s3 * l3.x + i4 * d3.x, a2.y = s3 * l3.y + i4 * d3.y, a2.z = s3 * l3.z + i4 * d3.z, a2.normalize(), p2.push(a2.x, a2.y, a2.z), o2.x = c2.x + n2 * a2.x, o2.y = c2.y + n2 * a2.y, o2.z = c2.z + n2 * a2.z, u2.push(o2.x, o2.y, o2.z);
        }
      }
      !function() {
        for (let e3 = 0; e3 < t2; e3++)
          f2(e3);
        f2(false === i2 ? t2 : 0), function() {
          for (let e3 = 0; e3 <= t2; e3++)
            for (let n3 = 0; n3 <= r2; n3++)
              l2.x = e3 / t2, l2.y = n3 / r2, d2.push(l2.x, l2.y);
        }(), function() {
          for (let e3 = 1; e3 <= t2; e3++)
            for (let t3 = 1; t3 <= r2; t3++) {
              const n3 = (r2 + 1) * (e3 - 1) + (t3 - 1), i3 = (r2 + 1) * e3 + (t3 - 1), s3 = (r2 + 1) * e3 + t3, o3 = (r2 + 1) * (e3 - 1) + t3;
              h2.push(n3, i3, o3), h2.push(i3, s3, o3);
            }
        }();
      }(), this.setIndex(h2), this.setAttribute("position", new ls(u2, 3)), this.setAttribute("normal", new ls(p2, 3)), this.setAttribute("uv", new ls(d2, 2));
    }
    copy(e2) {
      return super.copy(e2), this.parameters = Object.assign({}, e2.parameters), this;
    }
    toJSON() {
      const e2 = super.toJSON();
      return e2.path = this.parameters.path.toJSON(), e2;
    }
    static fromJSON(e2) {
      return new xp(new Eu[e2.path.type]().fromJSON(e2.path), e2.tubularSegments, e2.radius, e2.radialSegments, e2.closed);
    }
  }
  class Ep extends gs {
    constructor(e2 = null) {
      if (super(), this.type = "WireframeGeometry", this.parameters = { geometry: e2 }, null !== e2) {
        const t2 = [], n2 = /* @__PURE__ */ new Set(), r2 = new Ar(), i2 = new Ar();
        if (null !== e2.index) {
          const s2 = e2.attributes.position, o2 = e2.index;
          let a2 = e2.groups;
          0 === a2.length && (a2 = [{ start: 0, count: o2.count, materialIndex: 0 }]);
          for (let e3 = 0, l2 = a2.length; e3 < l2; ++e3) {
            const l3 = a2[e3], c2 = l3.start;
            for (let e4 = c2, a3 = c2 + l3.count; e4 < a3; e4 += 3)
              for (let a4 = 0; a4 < 3; a4++) {
                const l4 = o2.getX(e4 + a4), c3 = o2.getX(e4 + (a4 + 1) % 3);
                r2.fromBufferAttribute(s2, l4), i2.fromBufferAttribute(s2, c3), true === Cp(r2, i2, n2) && (t2.push(r2.x, r2.y, r2.z), t2.push(i2.x, i2.y, i2.z));
              }
          }
        } else {
          const s2 = e2.attributes.position;
          for (let e3 = 0, o2 = s2.count / 3; e3 < o2; e3++)
            for (let o3 = 0; o3 < 3; o3++) {
              const a2 = 3 * e3 + o3, l2 = 3 * e3 + (o3 + 1) % 3;
              r2.fromBufferAttribute(s2, a2), i2.fromBufferAttribute(s2, l2), true === Cp(r2, i2, n2) && (t2.push(r2.x, r2.y, r2.z), t2.push(i2.x, i2.y, i2.z));
            }
        }
        this.setAttribute("position", new ls(t2, 3));
      }
    }
    copy(e2) {
      return super.copy(e2), this.parameters = Object.assign({}, e2.parameters), this;
    }
  }
  function Cp(e2, t2, n2) {
    const r2 = `${e2.x},${e2.y},${e2.z}-${t2.x},${t2.y},${t2.z}`, i2 = `${t2.x},${t2.y},${t2.z}-${e2.x},${e2.y},${e2.z}`;
    return true !== n2.has(r2) && true !== n2.has(i2) && (n2.add(r2), n2.add(i2), true);
  }
  var Sp = Object.freeze({ __proto__: null, BoxGeometry: Us, CapsuleGeometry: Tu, CircleGeometry: Pu, ConeGeometry: Ru, CylinderGeometry: Iu, DodecahedronGeometry: Du, EdgesGeometry: Fu, ExtrudeGeometry: hp, IcosahedronGeometry: mp, LatheGeometry: Mu, OctahedronGeometry: _p, PlaneGeometry: io, PolyhedronGeometry: ku, RingGeometry: gp, ShapeGeometry: vp, SphereGeometry: yp, TetrahedronGeometry: bp, TorusGeometry: wp, TorusKnotGeometry: Ap, TubeGeometry: xp, WireframeGeometry: Ep });
  class Mp extends Ui {
    constructor(e2) {
      super(), this.isShadowMaterial = true, this.type = "ShadowMaterial", this.color = new Vi(0), this.transparent = true, this.fog = true, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.color.copy(e2.color), this.fog = e2.fog, this;
    }
  }
  class Tp extends Gs {
    constructor(e2) {
      super(e2), this.isRawShaderMaterial = true, this.type = "RawShaderMaterial";
    }
  }
  class Pp extends Ui {
    constructor(e2) {
      super(), this.isMeshStandardMaterial = true, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Vi(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Vi(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ft, this.normalScale = new Qn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.defines = { STANDARD: "" }, this.color.copy(e2.color), this.roughness = e2.roughness, this.metalness = e2.metalness, this.map = e2.map, this.lightMap = e2.lightMap, this.lightMapIntensity = e2.lightMapIntensity, this.aoMap = e2.aoMap, this.aoMapIntensity = e2.aoMapIntensity, this.emissive.copy(e2.emissive), this.emissiveMap = e2.emissiveMap, this.emissiveIntensity = e2.emissiveIntensity, this.bumpMap = e2.bumpMap, this.bumpScale = e2.bumpScale, this.normalMap = e2.normalMap, this.normalMapType = e2.normalMapType, this.normalScale.copy(e2.normalScale), this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this.roughnessMap = e2.roughnessMap, this.metalnessMap = e2.metalnessMap, this.alphaMap = e2.alphaMap, this.envMap = e2.envMap, this.envMapIntensity = e2.envMapIntensity, this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this.wireframeLinecap = e2.wireframeLinecap, this.wireframeLinejoin = e2.wireframeLinejoin, this.flatShading = e2.flatShading, this.fog = e2.fog, this;
    }
  }
  class Ip extends Pp {
    constructor(e2) {
      super(), this.isMeshPhysicalMaterial = true, this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Qn(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function() {
        return Ln(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      }, set: function(e3) {
        this.ior = (1 + 0.4 * e3) / (1 - 0.4 * e3);
      } }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Vi(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Vi(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Vi(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e2);
    }
    get anisotropy() {
      return this._anisotropy;
    }
    set anisotropy(e2) {
      this._anisotropy > 0 != e2 > 0 && this.version++, this._anisotropy = e2;
    }
    get clearcoat() {
      return this._clearcoat;
    }
    set clearcoat(e2) {
      this._clearcoat > 0 != e2 > 0 && this.version++, this._clearcoat = e2;
    }
    get iridescence() {
      return this._iridescence;
    }
    set iridescence(e2) {
      this._iridescence > 0 != e2 > 0 && this.version++, this._iridescence = e2;
    }
    get sheen() {
      return this._sheen;
    }
    set sheen(e2) {
      this._sheen > 0 != e2 > 0 && this.version++, this._sheen = e2;
    }
    get transmission() {
      return this._transmission;
    }
    set transmission(e2) {
      this._transmission > 0 != e2 > 0 && this.version++, this._transmission = e2;
    }
    copy(e2) {
      return super.copy(e2), this.defines = { STANDARD: "", PHYSICAL: "" }, this.anisotropy = e2.anisotropy, this.anisotropyRotation = e2.anisotropyRotation, this.anisotropyMap = e2.anisotropyMap, this.clearcoat = e2.clearcoat, this.clearcoatMap = e2.clearcoatMap, this.clearcoatRoughness = e2.clearcoatRoughness, this.clearcoatRoughnessMap = e2.clearcoatRoughnessMap, this.clearcoatNormalMap = e2.clearcoatNormalMap, this.clearcoatNormalScale.copy(e2.clearcoatNormalScale), this.ior = e2.ior, this.iridescence = e2.iridescence, this.iridescenceMap = e2.iridescenceMap, this.iridescenceIOR = e2.iridescenceIOR, this.iridescenceThicknessRange = [...e2.iridescenceThicknessRange], this.iridescenceThicknessMap = e2.iridescenceThicknessMap, this.sheen = e2.sheen, this.sheenColor.copy(e2.sheenColor), this.sheenColorMap = e2.sheenColorMap, this.sheenRoughness = e2.sheenRoughness, this.sheenRoughnessMap = e2.sheenRoughnessMap, this.transmission = e2.transmission, this.transmissionMap = e2.transmissionMap, this.thickness = e2.thickness, this.thicknessMap = e2.thicknessMap, this.attenuationDistance = e2.attenuationDistance, this.attenuationColor.copy(e2.attenuationColor), this.specularIntensity = e2.specularIntensity, this.specularIntensityMap = e2.specularIntensityMap, this.specularColor.copy(e2.specularColor), this.specularColorMap = e2.specularColorMap, this;
    }
  }
  class Rp extends Ui {
    constructor(e2) {
      super(), this.isMeshPhongMaterial = true, this.type = "MeshPhongMaterial", this.color = new Vi(16777215), this.specular = new Vi(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Vi(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ft, this.normalScale = new Qn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = X, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.color.copy(e2.color), this.specular.copy(e2.specular), this.shininess = e2.shininess, this.map = e2.map, this.lightMap = e2.lightMap, this.lightMapIntensity = e2.lightMapIntensity, this.aoMap = e2.aoMap, this.aoMapIntensity = e2.aoMapIntensity, this.emissive.copy(e2.emissive), this.emissiveMap = e2.emissiveMap, this.emissiveIntensity = e2.emissiveIntensity, this.bumpMap = e2.bumpMap, this.bumpScale = e2.bumpScale, this.normalMap = e2.normalMap, this.normalMapType = e2.normalMapType, this.normalScale.copy(e2.normalScale), this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this.specularMap = e2.specularMap, this.alphaMap = e2.alphaMap, this.envMap = e2.envMap, this.combine = e2.combine, this.reflectivity = e2.reflectivity, this.refractionRatio = e2.refractionRatio, this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this.wireframeLinecap = e2.wireframeLinecap, this.wireframeLinejoin = e2.wireframeLinejoin, this.flatShading = e2.flatShading, this.fog = e2.fog, this;
    }
  }
  class kp extends Ui {
    constructor(e2) {
      super(), this.isMeshToonMaterial = true, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Vi(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Vi(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ft, this.normalScale = new Qn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = true, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.color.copy(e2.color), this.map = e2.map, this.gradientMap = e2.gradientMap, this.lightMap = e2.lightMap, this.lightMapIntensity = e2.lightMapIntensity, this.aoMap = e2.aoMap, this.aoMapIntensity = e2.aoMapIntensity, this.emissive.copy(e2.emissive), this.emissiveMap = e2.emissiveMap, this.emissiveIntensity = e2.emissiveIntensity, this.bumpMap = e2.bumpMap, this.bumpScale = e2.bumpScale, this.normalMap = e2.normalMap, this.normalMapType = e2.normalMapType, this.normalScale.copy(e2.normalScale), this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this.alphaMap = e2.alphaMap, this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this.wireframeLinecap = e2.wireframeLinecap, this.wireframeLinejoin = e2.wireframeLinejoin, this.fog = e2.fog, this;
    }
  }
  class Dp extends Ui {
    constructor(e2) {
      super(), this.isMeshNormalMaterial = true, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ft, this.normalScale = new Qn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.flatShading = false, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.bumpMap = e2.bumpMap, this.bumpScale = e2.bumpScale, this.normalMap = e2.normalMap, this.normalMapType = e2.normalMapType, this.normalScale.copy(e2.normalScale), this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this.flatShading = e2.flatShading, this;
    }
  }
  class Bp extends Ui {
    constructor(e2) {
      super(), this.isMeshLambertMaterial = true, this.type = "MeshLambertMaterial", this.color = new Vi(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Vi(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ft, this.normalScale = new Qn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = X, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.color.copy(e2.color), this.map = e2.map, this.lightMap = e2.lightMap, this.lightMapIntensity = e2.lightMapIntensity, this.aoMap = e2.aoMap, this.aoMapIntensity = e2.aoMapIntensity, this.emissive.copy(e2.emissive), this.emissiveMap = e2.emissiveMap, this.emissiveIntensity = e2.emissiveIntensity, this.bumpMap = e2.bumpMap, this.bumpScale = e2.bumpScale, this.normalMap = e2.normalMap, this.normalMapType = e2.normalMapType, this.normalScale.copy(e2.normalScale), this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this.specularMap = e2.specularMap, this.alphaMap = e2.alphaMap, this.envMap = e2.envMap, this.combine = e2.combine, this.reflectivity = e2.reflectivity, this.refractionRatio = e2.refractionRatio, this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this.wireframeLinecap = e2.wireframeLinecap, this.wireframeLinejoin = e2.wireframeLinejoin, this.flatShading = e2.flatShading, this.fog = e2.fog, this;
    }
  }
  class Op extends Ui {
    constructor(e2) {
      super(), this.isMeshMatcapMaterial = true, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Vi(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ft, this.normalScale = new Qn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = false, this.fog = true, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.defines = { MATCAP: "" }, this.color.copy(e2.color), this.matcap = e2.matcap, this.map = e2.map, this.bumpMap = e2.bumpMap, this.bumpScale = e2.bumpScale, this.normalMap = e2.normalMap, this.normalMapType = e2.normalMapType, this.normalScale.copy(e2.normalScale), this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this.alphaMap = e2.alphaMap, this.flatShading = e2.flatShading, this.fog = e2.fog, this;
    }
  }
  class Lp extends Lc {
    constructor(e2) {
      super(), this.isLineDashedMaterial = true, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.scale = e2.scale, this.dashSize = e2.dashSize, this.gapSize = e2.gapSize, this;
    }
  }
  function Up(e2, t2, n2) {
    return Np(e2) ? new e2.constructor(e2.subarray(t2, void 0 !== n2 ? n2 : e2.length)) : e2.slice(t2, n2);
  }
  function Fp(e2, t2, n2) {
    return !e2 || !n2 && e2.constructor === t2 ? e2 : "number" == typeof t2.BYTES_PER_ELEMENT ? new t2(e2) : Array.prototype.slice.call(e2);
  }
  function Np(e2) {
    return ArrayBuffer.isView(e2) && !(e2 instanceof DataView);
  }
  function jp(e2) {
    const t2 = e2.length, n2 = new Array(t2);
    for (let e3 = 0; e3 !== t2; ++e3)
      n2[e3] = e3;
    return n2.sort(function(t3, n3) {
      return e2[t3] - e2[n3];
    }), n2;
  }
  function zp(e2, t2, n2) {
    const r2 = e2.length, i2 = new e2.constructor(r2);
    for (let s2 = 0, o2 = 0; o2 !== r2; ++s2) {
      const r3 = n2[s2] * t2;
      for (let n3 = 0; n3 !== t2; ++n3)
        i2[o2++] = e2[r3 + n3];
    }
    return i2;
  }
  function Gp(e2, t2, n2, r2) {
    let i2 = 1, s2 = e2[0];
    for (; void 0 !== s2 && void 0 === s2[r2]; )
      s2 = e2[i2++];
    if (void 0 === s2)
      return;
    let o2 = s2[r2];
    if (void 0 !== o2)
      if (Array.isArray(o2))
        do {
          o2 = s2[r2], void 0 !== o2 && (t2.push(s2.time), n2.push.apply(n2, o2)), s2 = e2[i2++];
        } while (void 0 !== s2);
      else if (void 0 !== o2.toArray)
        do {
          o2 = s2[r2], void 0 !== o2 && (t2.push(s2.time), o2.toArray(n2, n2.length)), s2 = e2[i2++];
        } while (void 0 !== s2);
      else
        do {
          o2 = s2[r2], void 0 !== o2 && (t2.push(s2.time), n2.push(o2)), s2 = e2[i2++];
        } while (void 0 !== s2);
  }
  const Vp = { arraySlice: Up, convertArray: Fp, isTypedArray: Np, getKeyframeOrder: jp, sortedArray: zp, flattenJSON: Gp, subclip: function(e2, t2, n2, r2, i2 = 30) {
    const s2 = e2.clone();
    s2.name = t2;
    const o2 = [];
    for (let e3 = 0; e3 < s2.tracks.length; ++e3) {
      const t3 = s2.tracks[e3], a3 = t3.getValueSize(), l2 = [], c2 = [];
      for (let e4 = 0; e4 < t3.times.length; ++e4) {
        const s3 = t3.times[e4] * i2;
        if (!(s3 < n2 || s3 >= r2)) {
          l2.push(t3.times[e4]);
          for (let n3 = 0; n3 < a3; ++n3)
            c2.push(t3.values[e4 * a3 + n3]);
        }
      }
      0 !== l2.length && (t3.times = Fp(l2, t3.times.constructor), t3.values = Fp(c2, t3.values.constructor), o2.push(t3));
    }
    s2.tracks = o2;
    let a2 = 1 / 0;
    for (let e3 = 0; e3 < s2.tracks.length; ++e3)
      a2 > s2.tracks[e3].times[0] && (a2 = s2.tracks[e3].times[0]);
    for (let e3 = 0; e3 < s2.tracks.length; ++e3)
      s2.tracks[e3].shift(-1 * a2);
    return s2.resetDuration(), s2;
  }, makeClipAdditive: function(e2, t2 = 0, n2 = e2, r2 = 30) {
    r2 <= 0 && (r2 = 30);
    const i2 = n2.tracks.length, s2 = t2 / r2;
    for (let t3 = 0; t3 < i2; ++t3) {
      const r3 = n2.tracks[t3], i3 = r3.ValueTypeName;
      if ("bool" === i3 || "string" === i3)
        continue;
      const o2 = e2.tracks.find(function(e3) {
        return e3.name === r3.name && e3.ValueTypeName === i3;
      });
      if (void 0 === o2)
        continue;
      let a2 = 0;
      const l2 = r3.getValueSize();
      r3.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a2 = l2 / 3);
      let c2 = 0;
      const u2 = o2.getValueSize();
      o2.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c2 = u2 / 3);
      const p2 = r3.times.length - 1;
      let d2;
      if (s2 <= r3.times[0]) {
        const e3 = a2, t4 = l2 - a2;
        d2 = Up(r3.values, e3, t4);
      } else if (s2 >= r3.times[p2]) {
        const e3 = p2 * l2 + a2, t4 = e3 + l2 - a2;
        d2 = Up(r3.values, e3, t4);
      } else {
        const e3 = r3.createInterpolant(), t4 = a2, n3 = l2 - a2;
        e3.evaluate(s2), d2 = Up(e3.resultBuffer, t4, n3);
      }
      "quaternion" === i3 && new wr().fromArray(d2).normalize().conjugate().toArray(d2);
      const h2 = o2.times.length;
      for (let e3 = 0; e3 < h2; ++e3) {
        const t4 = e3 * u2 + c2;
        if ("quaternion" === i3)
          wr.multiplyQuaternionsFlat(o2.values, t4, d2, 0, o2.values, t4);
        else {
          const e4 = u2 - 2 * c2;
          for (let n3 = 0; n3 < e4; ++n3)
            o2.values[t4 + n3] -= d2[n3];
        }
      }
    }
    return e2.blendMode = It, e2;
  } };
  class Hp {
    constructor(e2, t2, n2, r2) {
      this.parameterPositions = e2, this._cachedIndex = 0, this.resultBuffer = void 0 !== r2 ? r2 : new t2.constructor(n2), this.sampleValues = t2, this.valueSize = n2, this.settings = null, this.DefaultSettings_ = {};
    }
    evaluate(e2) {
      const t2 = this.parameterPositions;
      let n2 = this._cachedIndex, r2 = t2[n2], i2 = t2[n2 - 1];
      e: {
        t: {
          let s2;
          n: {
            r:
              if (!(e2 < r2)) {
                for (let s3 = n2 + 2; ; ) {
                  if (void 0 === r2) {
                    if (e2 < i2)
                      break r;
                    return n2 = t2.length, this._cachedIndex = n2, this.copySampleValue_(n2 - 1);
                  }
                  if (n2 === s3)
                    break;
                  if (i2 = r2, r2 = t2[++n2], e2 < r2)
                    break t;
                }
                s2 = t2.length;
                break n;
              }
            if (e2 >= i2)
              break e;
            {
              const o2 = t2[1];
              e2 < o2 && (n2 = 2, i2 = o2);
              for (let s3 = n2 - 2; ; ) {
                if (void 0 === i2)
                  return this._cachedIndex = 0, this.copySampleValue_(0);
                if (n2 === s3)
                  break;
                if (r2 = i2, i2 = t2[--n2 - 1], e2 >= i2)
                  break t;
              }
              s2 = n2, n2 = 0;
            }
          }
          for (; n2 < s2; ) {
            const r3 = n2 + s2 >>> 1;
            e2 < t2[r3] ? s2 = r3 : n2 = r3 + 1;
          }
          if (r2 = t2[n2], i2 = t2[n2 - 1], void 0 === i2)
            return this._cachedIndex = 0, this.copySampleValue_(0);
          if (void 0 === r2)
            return n2 = t2.length, this._cachedIndex = n2, this.copySampleValue_(n2 - 1);
        }
        this._cachedIndex = n2, this.intervalChanged_(n2, i2, r2);
      }
      return this.interpolate_(n2, i2, e2, r2);
    }
    getSettings_() {
      return this.settings || this.DefaultSettings_;
    }
    copySampleValue_(e2) {
      const t2 = this.resultBuffer, n2 = this.sampleValues, r2 = this.valueSize, i2 = e2 * r2;
      for (let e3 = 0; e3 !== r2; ++e3)
        t2[e3] = n2[i2 + e3];
      return t2;
    }
    interpolate_() {
      throw new Error("call to abstract method");
    }
    intervalChanged_() {
    }
  }
  class Qp extends Hp {
    constructor(e2, t2, n2, r2) {
      super(e2, t2, n2, r2), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: St, endingEnd: St };
    }
    intervalChanged_(e2, t2, n2) {
      const r2 = this.parameterPositions;
      let i2 = e2 - 2, s2 = e2 + 1, o2 = r2[i2], a2 = r2[s2];
      if (void 0 === o2)
        switch (this.getSettings_().endingStart) {
          case Mt:
            i2 = e2, o2 = 2 * t2 - n2;
            break;
          case Tt:
            i2 = r2.length - 2, o2 = t2 + r2[i2] - r2[i2 + 1];
            break;
          default:
            i2 = e2, o2 = n2;
        }
      if (void 0 === a2)
        switch (this.getSettings_().endingEnd) {
          case Mt:
            s2 = e2, a2 = 2 * n2 - t2;
            break;
          case Tt:
            s2 = 1, a2 = n2 + r2[1] - r2[0];
            break;
          default:
            s2 = e2 - 1, a2 = t2;
        }
      const l2 = 0.5 * (n2 - t2), c2 = this.valueSize;
      this._weightPrev = l2 / (t2 - o2), this._weightNext = l2 / (a2 - n2), this._offsetPrev = i2 * c2, this._offsetNext = s2 * c2;
    }
    interpolate_(e2, t2, n2, r2) {
      const i2 = this.resultBuffer, s2 = this.sampleValues, o2 = this.valueSize, a2 = e2 * o2, l2 = a2 - o2, c2 = this._offsetPrev, u2 = this._offsetNext, p2 = this._weightPrev, d2 = this._weightNext, h2 = (n2 - t2) / (r2 - t2), f2 = h2 * h2, m2 = f2 * h2, _2 = -p2 * m2 + 2 * p2 * f2 - p2 * h2, g2 = (1 + p2) * m2 + (-1.5 - 2 * p2) * f2 + (-0.5 + p2) * h2 + 1, v2 = (-1 - d2) * m2 + (1.5 + d2) * f2 + 0.5 * h2, y2 = d2 * m2 - d2 * f2;
      for (let e3 = 0; e3 !== o2; ++e3)
        i2[e3] = _2 * s2[c2 + e3] + g2 * s2[l2 + e3] + v2 * s2[a2 + e3] + y2 * s2[u2 + e3];
      return i2;
    }
  }
  class Wp extends Hp {
    constructor(e2, t2, n2, r2) {
      super(e2, t2, n2, r2);
    }
    interpolate_(e2, t2, n2, r2) {
      const i2 = this.resultBuffer, s2 = this.sampleValues, o2 = this.valueSize, a2 = e2 * o2, l2 = a2 - o2, c2 = (n2 - t2) / (r2 - t2), u2 = 1 - c2;
      for (let e3 = 0; e3 !== o2; ++e3)
        i2[e3] = s2[l2 + e3] * u2 + s2[a2 + e3] * c2;
      return i2;
    }
  }
  class qp extends Hp {
    constructor(e2, t2, n2, r2) {
      super(e2, t2, n2, r2);
    }
    interpolate_(e2) {
      return this.copySampleValue_(e2 - 1);
    }
  }
  class Xp {
    constructor(e2, t2, n2, r2) {
      if (void 0 === e2)
        throw new Error("THREE.KeyframeTrack: track name is undefined");
      if (void 0 === t2 || 0 === t2.length)
        throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e2);
      this.name = e2, this.times = Fp(t2, this.TimeBufferType), this.values = Fp(n2, this.ValueBufferType), this.setInterpolation(r2 || this.DefaultInterpolation);
    }
    static toJSON(e2) {
      const t2 = e2.constructor;
      let n2;
      if (t2.toJSON !== this.toJSON)
        n2 = t2.toJSON(e2);
      else {
        n2 = { name: e2.name, times: Fp(e2.times, Array), values: Fp(e2.values, Array) };
        const t3 = e2.getInterpolation();
        t3 !== e2.DefaultInterpolation && (n2.interpolation = t3);
      }
      return n2.type = e2.ValueTypeName, n2;
    }
    InterpolantFactoryMethodDiscrete(e2) {
      return new qp(this.times, this.values, this.getValueSize(), e2);
    }
    InterpolantFactoryMethodLinear(e2) {
      return new Wp(this.times, this.values, this.getValueSize(), e2);
    }
    InterpolantFactoryMethodSmooth(e2) {
      return new Qp(this.times, this.values, this.getValueSize(), e2);
    }
    setInterpolation(e2) {
      let t2;
      switch (e2) {
        case xt:
          t2 = this.InterpolantFactoryMethodDiscrete;
          break;
        case Et:
          t2 = this.InterpolantFactoryMethodLinear;
          break;
        case Ct:
          t2 = this.InterpolantFactoryMethodSmooth;
      }
      if (void 0 === t2) {
        const t3 = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
        if (void 0 === this.createInterpolant) {
          if (e2 === this.DefaultInterpolation)
            throw new Error(t3);
          this.setInterpolation(this.DefaultInterpolation);
        }
        return console.warn("THREE.KeyframeTrack:", t3), this;
      }
      return this.createInterpolant = t2, this;
    }
    getInterpolation() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return xt;
        case this.InterpolantFactoryMethodLinear:
          return Et;
        case this.InterpolantFactoryMethodSmooth:
          return Ct;
      }
    }
    getValueSize() {
      return this.values.length / this.times.length;
    }
    shift(e2) {
      if (0 !== e2) {
        const t2 = this.times;
        for (let n2 = 0, r2 = t2.length; n2 !== r2; ++n2)
          t2[n2] += e2;
      }
      return this;
    }
    scale(e2) {
      if (1 !== e2) {
        const t2 = this.times;
        for (let n2 = 0, r2 = t2.length; n2 !== r2; ++n2)
          t2[n2] *= e2;
      }
      return this;
    }
    trim(e2, t2) {
      const n2 = this.times, r2 = n2.length;
      let i2 = 0, s2 = r2 - 1;
      for (; i2 !== r2 && n2[i2] < e2; )
        ++i2;
      for (; -1 !== s2 && n2[s2] > t2; )
        --s2;
      if (++s2, 0 !== i2 || s2 !== r2) {
        i2 >= s2 && (s2 = Math.max(s2, 1), i2 = s2 - 1);
        const e3 = this.getValueSize();
        this.times = Up(n2, i2, s2), this.values = Up(this.values, i2 * e3, s2 * e3);
      }
      return this;
    }
    validate() {
      let e2 = true;
      const t2 = this.getValueSize();
      t2 - Math.floor(t2) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e2 = false);
      const n2 = this.times, r2 = this.values, i2 = n2.length;
      0 === i2 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e2 = false);
      let s2 = null;
      for (let t3 = 0; t3 !== i2; t3++) {
        const r3 = n2[t3];
        if ("number" == typeof r3 && isNaN(r3)) {
          console.error("THREE.KeyframeTrack: Time is not a valid number.", this, t3, r3), e2 = false;
          break;
        }
        if (null !== s2 && s2 > r3) {
          console.error("THREE.KeyframeTrack: Out of order keys.", this, t3, r3, s2), e2 = false;
          break;
        }
        s2 = r3;
      }
      if (void 0 !== r2 && Np(r2))
        for (let t3 = 0, n3 = r2.length; t3 !== n3; ++t3) {
          const n4 = r2[t3];
          if (isNaN(n4)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, t3, n4), e2 = false;
            break;
          }
        }
      return e2;
    }
    optimize() {
      const e2 = Up(this.times), t2 = Up(this.values), n2 = this.getValueSize(), r2 = this.getInterpolation() === Ct, i2 = e2.length - 1;
      let s2 = 1;
      for (let o2 = 1; o2 < i2; ++o2) {
        let i3 = false;
        const a2 = e2[o2];
        if (a2 !== e2[o2 + 1] && (1 !== o2 || a2 !== e2[0]))
          if (r2)
            i3 = true;
          else {
            const e3 = o2 * n2, r3 = e3 - n2, s3 = e3 + n2;
            for (let o3 = 0; o3 !== n2; ++o3) {
              const n3 = t2[e3 + o3];
              if (n3 !== t2[r3 + o3] || n3 !== t2[s3 + o3]) {
                i3 = true;
                break;
              }
            }
          }
        if (i3) {
          if (o2 !== s2) {
            e2[s2] = e2[o2];
            const r3 = o2 * n2, i4 = s2 * n2;
            for (let e3 = 0; e3 !== n2; ++e3)
              t2[i4 + e3] = t2[r3 + e3];
          }
          ++s2;
        }
      }
      if (i2 > 0) {
        e2[s2] = e2[i2];
        for (let e3 = i2 * n2, r3 = s2 * n2, o2 = 0; o2 !== n2; ++o2)
          t2[r3 + o2] = t2[e3 + o2];
        ++s2;
      }
      return s2 !== e2.length ? (this.times = Up(e2, 0, s2), this.values = Up(t2, 0, s2 * n2)) : (this.times = e2, this.values = t2), this;
    }
    clone() {
      const e2 = Up(this.times, 0), t2 = Up(this.values, 0), n2 = new (0, this.constructor)(this.name, e2, t2);
      return n2.createInterpolant = this.createInterpolant, n2;
    }
  }
  Xp.prototype.TimeBufferType = Float32Array, Xp.prototype.ValueBufferType = Float32Array, Xp.prototype.DefaultInterpolation = Et;
  class Yp extends Xp {
  }
  Yp.prototype.ValueTypeName = "bool", Yp.prototype.ValueBufferType = Array, Yp.prototype.DefaultInterpolation = xt, Yp.prototype.InterpolantFactoryMethodLinear = void 0, Yp.prototype.InterpolantFactoryMethodSmooth = void 0;
  class Kp extends Xp {
  }
  Kp.prototype.ValueTypeName = "color";
  class Jp extends Xp {
  }
  Jp.prototype.ValueTypeName = "number";
  class Zp extends Hp {
    constructor(e2, t2, n2, r2) {
      super(e2, t2, n2, r2);
    }
    interpolate_(e2, t2, n2, r2) {
      const i2 = this.resultBuffer, s2 = this.sampleValues, o2 = this.valueSize, a2 = (n2 - t2) / (r2 - t2);
      let l2 = e2 * o2;
      for (let e3 = l2 + o2; l2 !== e3; l2 += 4)
        wr.slerpFlat(i2, 0, s2, l2 - o2, s2, l2, a2);
      return i2;
    }
  }
  class $p extends Xp {
    InterpolantFactoryMethodLinear(e2) {
      return new Zp(this.times, this.values, this.getValueSize(), e2);
    }
  }
  $p.prototype.ValueTypeName = "quaternion", $p.prototype.DefaultInterpolation = Et, $p.prototype.InterpolantFactoryMethodSmooth = void 0;
  class ed extends Xp {
  }
  ed.prototype.ValueTypeName = "string", ed.prototype.ValueBufferType = Array, ed.prototype.DefaultInterpolation = xt, ed.prototype.InterpolantFactoryMethodLinear = void 0, ed.prototype.InterpolantFactoryMethodSmooth = void 0;
  class td extends Xp {
  }
  td.prototype.ValueTypeName = "vector";
  class nd {
    constructor(e2, t2 = -1, n2, r2 = Pt) {
      this.name = e2, this.tracks = n2, this.duration = t2, this.blendMode = r2, this.uuid = On(), this.duration < 0 && this.resetDuration();
    }
    static parse(e2) {
      const t2 = [], n2 = e2.tracks, r2 = 1 / (e2.fps || 1);
      for (let e3 = 0, i3 = n2.length; e3 !== i3; ++e3)
        t2.push(rd(n2[e3]).scale(r2));
      const i2 = new this(e2.name, e2.duration, t2, e2.blendMode);
      return i2.uuid = e2.uuid, i2;
    }
    static toJSON(e2) {
      const t2 = [], n2 = e2.tracks, r2 = { name: e2.name, duration: e2.duration, tracks: t2, uuid: e2.uuid, blendMode: e2.blendMode };
      for (let e3 = 0, r3 = n2.length; e3 !== r3; ++e3)
        t2.push(Xp.toJSON(n2[e3]));
      return r2;
    }
    static CreateFromMorphTargetSequence(e2, t2, n2, r2) {
      const i2 = t2.length, s2 = [];
      for (let e3 = 0; e3 < i2; e3++) {
        let o2 = [], a2 = [];
        o2.push((e3 + i2 - 1) % i2, e3, (e3 + 1) % i2), a2.push(0, 1, 0);
        const l2 = jp(o2);
        o2 = zp(o2, 1, l2), a2 = zp(a2, 1, l2), r2 || 0 !== o2[0] || (o2.push(i2), a2.push(a2[0])), s2.push(new Jp(".morphTargetInfluences[" + t2[e3].name + "]", o2, a2).scale(1 / n2));
      }
      return new this(e2, -1, s2);
    }
    static findByName(e2, t2) {
      let n2 = e2;
      if (!Array.isArray(e2)) {
        const t3 = e2;
        n2 = t3.geometry && t3.geometry.animations || t3.animations;
      }
      for (let e3 = 0; e3 < n2.length; e3++)
        if (n2[e3].name === t2)
          return n2[e3];
      return null;
    }
    static CreateClipsFromMorphTargetSequences(e2, t2, n2) {
      const r2 = {}, i2 = /^([\w-]*?)([\d]+)$/;
      for (let t3 = 0, n3 = e2.length; t3 < n3; t3++) {
        const n4 = e2[t3], s3 = n4.name.match(i2);
        if (s3 && s3.length > 1) {
          const e3 = s3[1];
          let t4 = r2[e3];
          t4 || (r2[e3] = t4 = []), t4.push(n4);
        }
      }
      const s2 = [];
      for (const e3 in r2)
        s2.push(this.CreateFromMorphTargetSequence(e3, r2[e3], t2, n2));
      return s2;
    }
    static parseAnimation(e2, t2) {
      if (!e2)
        return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
      const n2 = function(e3, t3, n3, r3, i3) {
        if (0 !== n3.length) {
          const s3 = [], o3 = [];
          Gp(n3, s3, o3, r3), 0 !== s3.length && i3.push(new e3(t3, s3, o3));
        }
      }, r2 = [], i2 = e2.name || "default", s2 = e2.fps || 30, o2 = e2.blendMode;
      let a2 = e2.length || -1;
      const l2 = e2.hierarchy || [];
      for (let e3 = 0; e3 < l2.length; e3++) {
        const i3 = l2[e3].keys;
        if (i3 && 0 !== i3.length)
          if (i3[0].morphTargets) {
            const e4 = {};
            let t3;
            for (t3 = 0; t3 < i3.length; t3++)
              if (i3[t3].morphTargets)
                for (let n3 = 0; n3 < i3[t3].morphTargets.length; n3++)
                  e4[i3[t3].morphTargets[n3]] = -1;
            for (const n3 in e4) {
              const e5 = [], s3 = [];
              for (let r3 = 0; r3 !== i3[t3].morphTargets.length; ++r3) {
                const r4 = i3[t3];
                e5.push(r4.time), s3.push(r4.morphTarget === n3 ? 1 : 0);
              }
              r2.push(new Jp(".morphTargetInfluence[" + n3 + "]", e5, s3));
            }
            a2 = e4.length * s2;
          } else {
            const s3 = ".bones[" + t2[e3].name + "]";
            n2(td, s3 + ".position", i3, "pos", r2), n2($p, s3 + ".quaternion", i3, "rot", r2), n2(td, s3 + ".scale", i3, "scl", r2);
          }
      }
      return 0 === r2.length ? null : new this(i2, a2, r2, o2);
    }
    resetDuration() {
      let e2 = 0;
      for (let t2 = 0, n2 = this.tracks.length; t2 !== n2; ++t2) {
        const n3 = this.tracks[t2];
        e2 = Math.max(e2, n3.times[n3.times.length - 1]);
      }
      return this.duration = e2, this;
    }
    trim() {
      for (let e2 = 0; e2 < this.tracks.length; e2++)
        this.tracks[e2].trim(0, this.duration);
      return this;
    }
    validate() {
      let e2 = true;
      for (let t2 = 0; t2 < this.tracks.length; t2++)
        e2 = e2 && this.tracks[t2].validate();
      return e2;
    }
    optimize() {
      for (let e2 = 0; e2 < this.tracks.length; e2++)
        this.tracks[e2].optimize();
      return this;
    }
    clone() {
      const e2 = [];
      for (let t2 = 0; t2 < this.tracks.length; t2++)
        e2.push(this.tracks[t2].clone());
      return new this.constructor(this.name, this.duration, e2, this.blendMode);
    }
    toJSON() {
      return this.constructor.toJSON(this);
    }
  }
  function rd(e2) {
    if (void 0 === e2.type)
      throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const t2 = function(e3) {
      switch (e3.toLowerCase()) {
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
          return Jp;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
          return td;
        case "color":
          return Kp;
        case "quaternion":
          return $p;
        case "bool":
        case "boolean":
          return Yp;
        case "string":
          return ed;
      }
      throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e3);
    }(e2.type);
    if (void 0 === e2.times) {
      const t3 = [], n2 = [];
      Gp(e2.keys, t3, n2, "value"), e2.times = t3, e2.values = n2;
    }
    return void 0 !== t2.parse ? t2.parse(e2) : new t2(e2.name, e2.times, e2.values, e2.interpolation);
  }
  const id = { enabled: false, files: {}, add: function(e2, t2) {
    false !== this.enabled && (this.files[e2] = t2);
  }, get: function(e2, t2) {
    return false === this.enabled ? t2 ? Promise.resolve() : void 0 : t2 ? Promise.resolve(this.files[e2]) : this.files[e2];
  }, remove: function(e2) {
    delete this.files[e2];
  }, clear: function() {
    this.files = {};
  } };
  class sd {
    constructor(e2, t2, n2) {
      const r2 = this;
      let i2, s2 = false, o2 = 0, a2 = 0;
      const l2 = [];
      this.onStart = void 0, this.onLoad = e2, this.onProgress = t2, this.onError = n2, this.itemStart = function(e3) {
        a2++, false === s2 && void 0 !== r2.onStart && r2.onStart(e3, o2, a2), s2 = true;
      }, this.itemEnd = function(e3) {
        o2++, void 0 !== r2.onProgress && r2.onProgress(e3, o2, a2), o2 === a2 && (s2 = false, void 0 !== r2.onLoad && r2.onLoad());
      }, this.itemError = function(e3) {
        void 0 !== r2.onError && r2.onError(e3);
      }, this.resolveURL = function(e3) {
        return i2 ? i2(e3) : e3;
      }, this.setURLModifier = function(e3) {
        return i2 = e3, this;
      }, this.addHandler = function(e3, t3) {
        return l2.push(e3, t3), this;
      }, this.removeHandler = function(e3) {
        const t3 = l2.indexOf(e3);
        return -1 !== t3 && l2.splice(t3, 2), this;
      }, this.getHandler = function(e3) {
        for (let t3 = 0, n3 = l2.length; t3 < n3; t3 += 2) {
          const n4 = l2[t3], r3 = l2[t3 + 1];
          if (n4.global && (n4.lastIndex = 0), n4.test(e3))
            return r3;
        }
        return null;
      };
    }
  }
  const od = new sd();
  class ad {
    constructor(e2) {
      this.manager = void 0 !== e2 ? e2 : od, this.crossOrigin = "anonymous", this.withCredentials = false, this.path = "", this.resourcePath = "", this.requestHeader = {};
    }
    load() {
    }
    loadAsync(e2, t2) {
      const n2 = this;
      return new Promise(function(r2, i2) {
        n2.load(e2, r2, t2, i2);
      });
    }
    parse() {
    }
    setCrossOrigin(e2) {
      return this.crossOrigin = e2, this;
    }
    setWithCredentials(e2) {
      return this.withCredentials = e2, this;
    }
    setPath(e2) {
      return this.path = e2, this;
    }
    setResourcePath(e2) {
      return this.resourcePath = e2, this;
    }
    setRequestHeader(e2) {
      return this.requestHeader = e2, this;
    }
  }
  const ld = {};
  class cd extends Error {
    constructor(e2, t2) {
      super(e2), this.response = t2;
    }
  }
  class ud extends ad {
    constructor(e2) {
      super(e2), this.responseType = "text", this.useCache = true;
    }
    load(e2, t2, n2, r2) {
      void 0 === e2 && (e2 = ""), void 0 !== this.path && (e2 = this.path + e2), e2 = this.manager.resolveURL(e2), (this.useCache ? id.get(e2, this.responseType, this.mimeType) : Promise.resolve(void 0)).then((i2) => {
        if (void 0 !== i2)
          return this.manager.itemStart(e2), setTimeout(() => {
            t2 && t2(i2), this.manager.itemEnd(e2);
          }, 0), i2;
        if (void 0 !== ld[e2])
          return void ld[e2].push({ onLoad: t2, onProgress: n2, onError: r2 });
        ld[e2] = [], ld[e2].push({ onLoad: t2, onProgress: n2, onError: r2 });
        const s2 = new Request(e2, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" }), o2 = this.mimeType, a2 = this.responseType;
        fetch(s2).then((t3) => {
          if (200 === t3.status || 0 === t3.status) {
            if (0 === t3.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === t3.body || void 0 === t3.body.getReader)
              return t3;
            const n3 = ld[e2], r3 = t3.body.getReader(), i3 = t3.headers.get("Content-Length") || t3.headers.get("X-File-Size"), s3 = i3 ? parseInt(i3) : 0, o3 = 0 !== s3;
            let a3 = 0;
            const l2 = new ReadableStream({ start(e3) {
              !function t4() {
                r3.read().then(({ done: r4, value: i4 }) => {
                  if (r4)
                    e3.close();
                  else {
                    a3 += i4.byteLength;
                    const r5 = new ProgressEvent("progress", { lengthComputable: o3, loaded: a3, total: s3 });
                    for (let e4 = 0, t5 = n3.length; e4 < t5; e4++) {
                      const t6 = n3[e4];
                      t6.onProgress && t6.onProgress(r5);
                    }
                    e3.enqueue(i4), t4();
                  }
                });
              }();
            } });
            return new Response(l2);
          }
          throw new cd(`fetch for "${t3.url}" responded with ${t3.status}: ${t3.statusText}`, t3);
        }).then((e3) => {
          switch (a2) {
            case "arraybuffer":
              return e3.arrayBuffer();
            case "blob":
              return e3.blob();
            case "document":
              return e3.text().then((e4) => new DOMParser().parseFromString(e4, o2));
            case "json":
              return e3.json();
            default:
              if (void 0 === o2)
                return e3.text();
              {
                const t3 = /charset="?([^;"\s]*)"?/i.exec(o2), n3 = t3 && t3[1] ? t3[1].toLowerCase() : void 0, r3 = new TextDecoder(n3);
                return e3.arrayBuffer().then((e4) => r3.decode(e4));
              }
          }
        }).then((t3) => {
          this.useCache && id.add(e2, t3, this.responseType);
          const n3 = ld[e2];
          delete ld[e2];
          for (let e3 = 0, r3 = n3.length; e3 < r3; e3++) {
            const r4 = n3[e3];
            r4.onLoad && r4.onLoad(t3);
          }
        }).catch((t3) => {
          const n3 = ld[e2];
          if (void 0 === n3)
            throw this.manager.itemError(e2), t3;
          delete ld[e2];
          for (let e3 = 0, r3 = n3.length; e3 < r3; e3++) {
            const r4 = n3[e3];
            r4.onError && r4.onError(t3);
          }
          this.manager.itemError(e2);
        }).finally(() => {
          this.useCache && this.manager.itemEnd(e2);
        }), this.useCache && this.manager.itemStart(e2);
      });
    }
    setResponseType(e2) {
      return this.responseType = e2, this;
    }
    setMimeType(e2) {
      return this.mimeType = e2, this;
    }
  }
  class pd extends ad {
    constructor(e2) {
      super(e2);
    }
    load(e2, t2, n2, r2) {
      const i2 = this, s2 = new ud(this.manager);
      s2.setPath(this.path), s2.setRequestHeader(this.requestHeader), s2.setWithCredentials(this.withCredentials), s2.load(e2, function(n3) {
        try {
          t2(i2.parse(JSON.parse(n3)));
        } catch (t3) {
          r2 ? r2(t3) : console.error(t3), i2.manager.itemError(e2);
        }
      }, n2, r2);
    }
    parse(e2) {
      const t2 = [];
      for (let n2 = 0; n2 < e2.length; n2++) {
        const r2 = nd.parse(e2[n2]);
        t2.push(r2);
      }
      return t2;
    }
  }
  class dd extends ad {
    constructor(e2) {
      super(e2);
    }
    load(e2, t2, n2, r2) {
      const i2 = this, s2 = [], o2 = new nu(), a2 = new ud(this.manager);
      a2.setPath(this.path), a2.setResponseType("arraybuffer"), a2.setRequestHeader(this.requestHeader), a2.setWithCredentials(i2.withCredentials);
      let l2 = 0;
      function c2(c3) {
        a2.load(e2[c3], function(e3) {
          const n3 = i2.parse(e3, true);
          s2[c3] = { width: n3.width, height: n3.height, format: n3.format, mipmaps: n3.mipmaps }, l2 += 1, 6 === l2 && (1 === n3.mipmapCount && (o2.minFilter = ge), o2.image = s2, o2.format = n3.format, o2.needsUpdate = true, t2 && t2(o2));
        }, n2, r2);
      }
      if (Array.isArray(e2))
        for (let t3 = 0, n3 = e2.length; t3 < n3; ++t3)
          c2(t3);
      else
        a2.load(e2, function(e3) {
          const n3 = i2.parse(e3, true);
          if (n3.isCubemap) {
            const e4 = n3.mipmaps.length / n3.mipmapCount;
            for (let t3 = 0; t3 < e4; t3++) {
              s2[t3] = { mipmaps: [] };
              for (let e5 = 0; e5 < n3.mipmapCount; e5++)
                s2[t3].mipmaps.push(n3.mipmaps[t3 * n3.mipmapCount + e5]), s2[t3].format = n3.format, s2[t3].width = n3.width, s2[t3].height = n3.height;
            }
            o2.image = s2;
          } else
            o2.image.width = n3.width, o2.image.height = n3.height, o2.mipmaps = n3.mipmaps;
          1 === n3.mipmapCount && (o2.minFilter = ge), o2.format = n3.format, o2.needsUpdate = true, t2 && t2(o2);
        }, n2, r2);
      return o2;
    }
  }
  class hd extends ad {
    constructor(e2) {
      super(e2);
    }
    load(e2, t2, n2, r2) {
      const i2 = e2;
      void 0 !== this.path && (e2 = this.path + e2), e2 = this.manager.resolveURL(e2);
      const s2 = this, o2 = id.get(e2);
      if (void 0 !== o2)
        return s2.manager.itemStart(e2), setTimeout(function() {
          t2 && t2(o2), s2.manager.itemEnd(e2);
        }, 0), o2;
      const a2 = Jn("img");
      function l2() {
        u2(), id.add(e2, this), t2 && t2(this), s2.manager.itemEnd(e2);
      }
      function c2(t3) {
        u2(), r2 && r2(t3), s2.manager.itemError(e2), s2.manager.itemEnd(e2);
      }
      function u2() {
        a2.removeEventListener("load", l2, false), a2.removeEventListener("error", c2, false);
      }
      return a2.addEventListener("load", l2, false), a2.addEventListener("error", c2, false), "data:" !== e2.slice(0, 5) && void 0 !== this.crossOrigin && (a2.crossOrigin = this.crossOrigin), s2.manager.itemStart(e2), id.get(e2, "blob").then((t3) => {
        if (void 0 !== t3 && !t3.type.startsWith("text/plain"))
          return t3.type || (e2.endsWith(".svg") || e2.startsWith("data:image/svg")) && (t3 = new Blob([t3], { type: "image/svg+xml" })), void (a2.src = URL.createObjectURL(t3));
        const s3 = new ud(this.manager);
        s3.useCache = false, s3.setPath(this.path), s3.setCrossOrigin(this.crossOrigin), s3.setResponseType("blob"), s3.load(i2, function(t4) {
          t4.type || (e2.endsWith(".svg") || e2.startsWith("data:image/svg")) && (t4 = new Blob([t4], { type: "image/svg+xml" })), id.add(e2, t4, "blob"), a2.src = URL.createObjectURL(t4);
        }, n2, (e3) => {
          u2(), r2 && r2(e3);
        });
      }), a2;
    }
  }
  class fd extends ad {
    constructor(e2) {
      super(e2);
    }
    load(e2, t2, n2, r2) {
      const i2 = new qs();
      i2.colorSpace = zt;
      const s2 = new hd(this.manager);
      s2.setCrossOrigin(this.crossOrigin), s2.setPath(this.path);
      let o2 = 0;
      function a2(n3) {
        s2.load(e2[n3], function(e3) {
          i2.images[n3] = e3, o2++, 6 === o2 && (i2.needsUpdate = true, t2 && t2(i2));
        }, void 0, r2);
      }
      for (let t3 = 0; t3 < e2.length; ++t3)
        a2(t3);
      return i2;
    }
  }
  class md extends ad {
    constructor(e2) {
      super(e2);
    }
    load(e2, t2, n2, r2) {
      const i2 = this, s2 = new xc(), o2 = new ud(this.manager);
      return o2.setResponseType("arraybuffer"), o2.setRequestHeader(this.requestHeader), o2.setPath(this.path), o2.setWithCredentials(i2.withCredentials), o2.load(e2, function(e3) {
        const n3 = i2.parse(e3);
        n3 && (void 0 !== n3.image ? s2.image = n3.image : void 0 !== n3.data && (s2.image.width = n3.width, s2.image.height = n3.height, s2.image.data = n3.data, s2.image.complete = true), s2.wrapS = void 0 !== n3.wrapS ? n3.wrapS : ue, s2.wrapT = void 0 !== n3.wrapT ? n3.wrapT : ue, s2.magFilter = void 0 !== n3.magFilter ? n3.magFilter : ge, s2.minFilter = void 0 !== n3.minFilter ? n3.minFilter : ge, s2.anisotropy = void 0 !== n3.anisotropy ? n3.anisotropy : 1, void 0 !== n3.colorSpace ? s2.colorSpace = n3.colorSpace : void 0 !== n3.encoding && (s2.encoding = n3.encoding), void 0 !== n3.flipY && (s2.flipY = n3.flipY), void 0 !== n3.format && (s2.format = n3.format), void 0 !== n3.type && (s2.type = n3.type), void 0 !== n3.mipmaps && (s2.mipmaps = n3.mipmaps, s2.minFilter = be), 1 === n3.mipmapCount && (s2.minFilter = ge), void 0 !== n3.generateMipmaps && (s2.generateMipmaps = n3.generateMipmaps), s2.needsUpdate = true, t2 && t2(s2, n3));
      }, n2, r2), s2;
    }
  }
  class _d extends ad {
    constructor(e2) {
      super(e2);
    }
    load(e2, t2, n2, r2) {
      const i2 = new hr(), s2 = new hd(this.manager);
      return s2.setCrossOrigin(this.crossOrigin), s2.setPath(this.path), s2.load(e2, function(e3) {
        i2.image = e3, i2.needsUpdate = true, void 0 !== t2 && t2(i2);
      }, n2, r2), i2;
    }
  }
  class gd extends xi {
    constructor(e2, t2 = 1) {
      super(), this.isLight = true, this.type = "Light", this.color = new Vi(e2), this.intensity = t2;
    }
    dispose() {
    }
    copy(e2, t2) {
      return super.copy(e2, t2), this.color.copy(e2.color), this.intensity = e2.intensity, this;
    }
    toJSON(e2) {
      const t2 = super.toJSON(e2);
      return t2.object.color = this.color.getHex(), t2.object.intensity = this.intensity, void 0 !== this.groundColor && (t2.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t2.object.distance = this.distance), void 0 !== this.angle && (t2.object.angle = this.angle), void 0 !== this.decay && (t2.object.decay = this.decay), void 0 !== this.penumbra && (t2.object.penumbra = this.penumbra), void 0 !== this.shadow && (t2.object.shadow = this.shadow.toJSON()), t2;
    }
  }
  class vd extends gd {
    constructor(e2, t2, n2) {
      super(e2, n2), this.isHemisphereLight = true, this.type = "HemisphereLight", this.position.copy(xi.DEFAULT_UP), this.updateMatrix(), this.groundColor = new Vi(t2);
    }
    copy(e2, t2) {
      return super.copy(e2, t2), this.groundColor.copy(e2.groundColor), this;
    }
  }
  const yd = new Zr(), bd = new Ar(), wd = new Ar();
  class Ad {
    constructor(e2) {
      this.camera = e2, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Qn(512, 512), this.map = null, this.mapPass = null, this.matrix = new Zr(), this.autoUpdate = true, this.needsUpdate = false, this._frustum = new to(), this._frameExtents = new Qn(1, 1), this._viewportCount = 1, this._viewports = [new fr(0, 0, 1, 1)];
    }
    getViewportCount() {
      return this._viewportCount;
    }
    getFrustum() {
      return this._frustum;
    }
    updateMatrices(e2) {
      const t2 = this.camera, n2 = this.matrix;
      bd.setFromMatrixPosition(e2.matrixWorld), t2.position.copy(bd), wd.setFromMatrixPosition(e2.target.matrixWorld), t2.lookAt(wd), t2.updateMatrixWorld(), yd.multiplyMatrices(t2.projectionMatrix, t2.matrixWorldInverse), this._frustum.setFromProjectionMatrix(yd), n2.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), n2.multiply(yd);
    }
    getViewport(e2) {
      return this._viewports[e2];
    }
    getFrameExtents() {
      return this._frameExtents;
    }
    dispose() {
      this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
    }
    copy(e2) {
      return this.camera = e2.camera.clone(), this.bias = e2.bias, this.normalBias = e2.normalBias, this.radius = e2.radius, this.mapSize.copy(e2.mapSize), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    toJSON() {
      const e2 = {};
      return 0 !== this.bias && (e2.bias = this.bias), 0 !== this.normalBias && (e2.normalBias = this.normalBias), 1 !== this.radius && (e2.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e2.mapSize = this.mapSize.toArray()), e2.camera = this.camera.toJSON(false).object, delete e2.camera.matrix, e2;
    }
  }
  class xd extends Ad {
    constructor() {
      super(new Hs(50, 1, 0.5, 500)), this.isSpotLightShadow = true, this.focus = 1;
    }
    updateMatrices(e2) {
      const t2 = this.camera, n2 = 2 * Bn * e2.angle * this.focus, r2 = this.mapSize.width / this.mapSize.height, i2 = e2.distance || t2.far;
      n2 === t2.fov && r2 === t2.aspect && i2 === t2.far || (t2.fov = n2, t2.aspect = r2, t2.far = i2, t2.updateProjectionMatrix()), super.updateMatrices(e2);
    }
    copy(e2) {
      return super.copy(e2), this.focus = e2.focus, this;
    }
  }
  class Ed extends gd {
    constructor(e2, t2, n2 = 0, r2 = Math.PI / 3, i2 = 0, s2 = 2) {
      super(e2, t2), this.isSpotLight = true, this.type = "SpotLight", this.position.copy(xi.DEFAULT_UP), this.updateMatrix(), this.target = new xi(), this.distance = n2, this.angle = r2, this.penumbra = i2, this.decay = s2, this.map = null, this.shadow = new xd();
    }
    get power() {
      return this.intensity * Math.PI;
    }
    set power(e2) {
      this.intensity = e2 / Math.PI;
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(e2, t2) {
      return super.copy(e2, t2), this.distance = e2.distance, this.angle = e2.angle, this.penumbra = e2.penumbra, this.decay = e2.decay, this.target = e2.target.clone(), this.shadow = e2.shadow.clone(), this;
    }
  }
  const Cd = new Zr(), Sd = new Ar(), Md = new Ar();
  class Td extends Ad {
    constructor() {
      super(new Hs(90, 1, 0.5, 500)), this.isPointLightShadow = true, this._frameExtents = new Qn(4, 2), this._viewportCount = 6, this._viewports = [new fr(2, 1, 1, 1), new fr(0, 1, 1, 1), new fr(3, 1, 1, 1), new fr(1, 1, 1, 1), new fr(3, 0, 1, 1), new fr(1, 0, 1, 1)], this._cubeDirections = [new Ar(1, 0, 0), new Ar(-1, 0, 0), new Ar(0, 0, 1), new Ar(0, 0, -1), new Ar(0, 1, 0), new Ar(0, -1, 0)], this._cubeUps = [new Ar(0, 1, 0), new Ar(0, 1, 0), new Ar(0, 1, 0), new Ar(0, 1, 0), new Ar(0, 0, 1), new Ar(0, 0, -1)];
    }
    updateMatrices(e2, t2 = 0) {
      const n2 = this.camera, r2 = this.matrix, i2 = e2.distance || n2.far;
      i2 !== n2.far && (n2.far = i2, n2.updateProjectionMatrix()), Sd.setFromMatrixPosition(e2.matrixWorld), n2.position.copy(Sd), Md.copy(n2.position), Md.add(this._cubeDirections[t2]), n2.up.copy(this._cubeUps[t2]), n2.lookAt(Md), n2.updateMatrixWorld(), r2.makeTranslation(-Sd.x, -Sd.y, -Sd.z), Cd.multiplyMatrices(n2.projectionMatrix, n2.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Cd);
    }
  }
  class Pd extends gd {
    constructor(e2, t2, n2 = 0, r2 = 2) {
      super(e2, t2), this.isPointLight = true, this.type = "PointLight", this.distance = n2, this.decay = r2, this.shadow = new Td();
    }
    get power() {
      return 4 * this.intensity * Math.PI;
    }
    set power(e2) {
      this.intensity = e2 / (4 * Math.PI);
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(e2, t2) {
      return super.copy(e2, t2), this.distance = e2.distance, this.decay = e2.decay, this.shadow = e2.shadow.clone(), this;
    }
  }
  class Id extends Ad {
    constructor() {
      super(new _o(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = true;
    }
  }
  class Rd extends gd {
    constructor(e2, t2) {
      super(e2, t2), this.isDirectionalLight = true, this.type = "DirectionalLight", this.position.copy(xi.DEFAULT_UP), this.updateMatrix(), this.target = new xi(), this.shadow = new Id();
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(e2) {
      return super.copy(e2), this.target = e2.target.clone(), this.shadow = e2.shadow.clone(), this;
    }
  }
  class kd extends gd {
    constructor(e2, t2) {
      super(e2, t2), this.isAmbientLight = true, this.type = "AmbientLight";
    }
  }
  class Dd extends gd {
    constructor(e2, t2, n2 = 10, r2 = 10) {
      super(e2, t2), this.isRectAreaLight = true, this.type = "RectAreaLight", this.width = n2, this.height = r2;
    }
    get power() {
      return this.intensity * this.width * this.height * Math.PI;
    }
    set power(e2) {
      this.intensity = e2 / (this.width * this.height * Math.PI);
    }
    copy(e2) {
      return super.copy(e2), this.width = e2.width, this.height = e2.height, this;
    }
    toJSON(e2) {
      const t2 = super.toJSON(e2);
      return t2.object.width = this.width, t2.object.height = this.height, t2;
    }
  }
  class Bd {
    constructor() {
      this.isSphericalHarmonics3 = true, this.coefficients = [];
      for (let e2 = 0; e2 < 9; e2++)
        this.coefficients.push(new Ar());
    }
    set(e2) {
      for (let t2 = 0; t2 < 9; t2++)
        this.coefficients[t2].copy(e2[t2]);
      return this;
    }
    zero() {
      for (let e2 = 0; e2 < 9; e2++)
        this.coefficients[e2].set(0, 0, 0);
      return this;
    }
    getAt(e2, t2) {
      const n2 = e2.x, r2 = e2.y, i2 = e2.z, s2 = this.coefficients;
      return t2.copy(s2[0]).multiplyScalar(0.282095), t2.addScaledVector(s2[1], 0.488603 * r2), t2.addScaledVector(s2[2], 0.488603 * i2), t2.addScaledVector(s2[3], 0.488603 * n2), t2.addScaledVector(s2[4], n2 * r2 * 1.092548), t2.addScaledVector(s2[5], r2 * i2 * 1.092548), t2.addScaledVector(s2[6], 0.315392 * (3 * i2 * i2 - 1)), t2.addScaledVector(s2[7], n2 * i2 * 1.092548), t2.addScaledVector(s2[8], 0.546274 * (n2 * n2 - r2 * r2)), t2;
    }
    getIrradianceAt(e2, t2) {
      const n2 = e2.x, r2 = e2.y, i2 = e2.z, s2 = this.coefficients;
      return t2.copy(s2[0]).multiplyScalar(0.886227), t2.addScaledVector(s2[1], 1.023328 * r2), t2.addScaledVector(s2[2], 1.023328 * i2), t2.addScaledVector(s2[3], 1.023328 * n2), t2.addScaledVector(s2[4], 0.858086 * n2 * r2), t2.addScaledVector(s2[5], 0.858086 * r2 * i2), t2.addScaledVector(s2[6], 0.743125 * i2 * i2 - 0.247708), t2.addScaledVector(s2[7], 0.858086 * n2 * i2), t2.addScaledVector(s2[8], 0.429043 * (n2 * n2 - r2 * r2)), t2;
    }
    add(e2) {
      for (let t2 = 0; t2 < 9; t2++)
        this.coefficients[t2].add(e2.coefficients[t2]);
      return this;
    }
    addScaledSH(e2, t2) {
      for (let n2 = 0; n2 < 9; n2++)
        this.coefficients[n2].addScaledVector(e2.coefficients[n2], t2);
      return this;
    }
    scale(e2) {
      for (let t2 = 0; t2 < 9; t2++)
        this.coefficients[t2].multiplyScalar(e2);
      return this;
    }
    lerp(e2, t2) {
      for (let n2 = 0; n2 < 9; n2++)
        this.coefficients[n2].lerp(e2.coefficients[n2], t2);
      return this;
    }
    equals(e2) {
      for (let t2 = 0; t2 < 9; t2++)
        if (!this.coefficients[t2].equals(e2.coefficients[t2]))
          return false;
      return true;
    }
    copy(e2) {
      return this.set(e2.coefficients);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(e2, t2 = 0) {
      const n2 = this.coefficients;
      for (let r2 = 0; r2 < 9; r2++)
        n2[r2].fromArray(e2, t2 + 3 * r2);
      return this;
    }
    toArray(e2 = [], t2 = 0) {
      const n2 = this.coefficients;
      for (let r2 = 0; r2 < 9; r2++)
        n2[r2].toArray(e2, t2 + 3 * r2);
      return e2;
    }
    static getBasisAt(e2, t2) {
      const n2 = e2.x, r2 = e2.y, i2 = e2.z;
      t2[0] = 0.282095, t2[1] = 0.488603 * r2, t2[2] = 0.488603 * i2, t2[3] = 0.488603 * n2, t2[4] = 1.092548 * n2 * r2, t2[5] = 1.092548 * r2 * i2, t2[6] = 0.315392 * (3 * i2 * i2 - 1), t2[7] = 1.092548 * n2 * i2, t2[8] = 0.546274 * (n2 * n2 - r2 * r2);
    }
  }
  class Od extends gd {
    constructor(e2 = new Bd(), t2 = 1) {
      super(void 0, t2), this.isLightProbe = true, this.sh = e2;
    }
    copy(e2) {
      return super.copy(e2), this.sh.copy(e2.sh), this;
    }
    fromJSON(e2) {
      return this.intensity = e2.intensity, this.sh.fromArray(e2.sh), this;
    }
    toJSON(e2) {
      const t2 = super.toJSON(e2);
      return t2.object.sh = this.sh.toArray(), t2;
    }
  }
  class Ld extends ad {
    constructor(e2) {
      super(e2), this.textures = {};
    }
    load(e2, t2, n2, r2) {
      const i2 = this, s2 = new ud(i2.manager);
      s2.setPath(i2.path), s2.setRequestHeader(i2.requestHeader), s2.setWithCredentials(i2.withCredentials), s2.load(e2, function(n3) {
        try {
          t2(i2.parse(JSON.parse(n3)));
        } catch (t3) {
          r2 ? r2(t3) : console.error(t3), i2.manager.itemError(e2);
        }
      }, n2, r2);
    }
    parse(e2) {
      const t2 = this.textures;
      function n2(e3) {
        return void 0 === t2[e3] && console.warn("THREE.MaterialLoader: Undefined texture", e3), t2[e3];
      }
      const r2 = e2.metadata && e2.metadata.version <= 4.5 ? Gt : void 0, i2 = Ld.createMaterialFromType(e2.type);
      if (void 0 !== e2.uuid && (i2.uuid = e2.uuid), void 0 !== e2.name && (i2.name = e2.name), void 0 !== e2.color && void 0 !== i2.color && i2.color.setHex(e2.color, r2), void 0 !== e2.roughness && (i2.roughness = e2.roughness), void 0 !== e2.metalness && (i2.metalness = e2.metalness), void 0 !== e2.sheen && (i2.sheen = e2.sheen), void 0 !== e2.sheenColor && (i2.sheenColor = new Vi().setHex(e2.sheenColor, r2)), void 0 !== e2.sheenRoughness && (i2.sheenRoughness = e2.sheenRoughness), void 0 !== e2.emissive && void 0 !== i2.emissive && i2.emissive.setHex(e2.emissive, r2), void 0 !== e2.specular && void 0 !== i2.specular && i2.specular.setHex(e2.specular, r2), void 0 !== e2.specularIntensity && (i2.specularIntensity = e2.specularIntensity), void 0 !== e2.specularColor && void 0 !== i2.specularColor && i2.specularColor.setHex(e2.specularColor, r2), void 0 !== e2.shininess && (i2.shininess = e2.shininess), void 0 !== e2.clearcoat && (i2.clearcoat = e2.clearcoat), void 0 !== e2.clearcoatRoughness && (i2.clearcoatRoughness = e2.clearcoatRoughness), void 0 !== e2.iridescence && (i2.iridescence = e2.iridescence), void 0 !== e2.iridescenceIOR && (i2.iridescenceIOR = e2.iridescenceIOR), void 0 !== e2.iridescenceThicknessRange && (i2.iridescenceThicknessRange = e2.iridescenceThicknessRange), void 0 !== e2.transmission && (i2.transmission = e2.transmission), void 0 !== e2.thickness && (i2.thickness = e2.thickness), void 0 !== e2.attenuationDistance && (i2.attenuationDistance = e2.attenuationDistance), void 0 !== e2.attenuationColor && void 0 !== i2.attenuationColor && i2.attenuationColor.setHex(e2.attenuationColor, r2), void 0 !== e2.anisotropy && (i2.anisotropy = e2.anisotropy), void 0 !== e2.anisotropyRotation && (i2.anisotropyRotation = e2.anisotropyRotation), void 0 !== e2.fog && (i2.fog = e2.fog), void 0 !== e2.flatShading && (i2.flatShading = e2.flatShading), void 0 !== e2.blending && (i2.blending = e2.blending), void 0 !== e2.combine && (i2.combine = e2.combine), void 0 !== e2.side && (i2.side = e2.side), void 0 !== e2.shadowSide && (i2.shadowSide = e2.shadowSide), void 0 !== e2.opacity && (i2.opacity = e2.opacity), void 0 !== e2.transparent && (i2.transparent = e2.transparent), void 0 !== e2.alphaTest && (i2.alphaTest = e2.alphaTest), void 0 !== e2.depthTest && (i2.depthTest = e2.depthTest), void 0 !== e2.depthWrite && (i2.depthWrite = e2.depthWrite), void 0 !== e2.colorWrite && (i2.colorWrite = e2.colorWrite), void 0 !== e2.stencilWrite && (i2.stencilWrite = e2.stencilWrite), void 0 !== e2.stencilWriteMask && (i2.stencilWriteMask = e2.stencilWriteMask), void 0 !== e2.stencilFunc && (i2.stencilFunc = e2.stencilFunc), void 0 !== e2.stencilRef && (i2.stencilRef = e2.stencilRef), void 0 !== e2.stencilFuncMask && (i2.stencilFuncMask = e2.stencilFuncMask), void 0 !== e2.stencilFail && (i2.stencilFail = e2.stencilFail), void 0 !== e2.stencilZFail && (i2.stencilZFail = e2.stencilZFail), void 0 !== e2.stencilZPass && (i2.stencilZPass = e2.stencilZPass), void 0 !== e2.wireframe && (i2.wireframe = e2.wireframe), void 0 !== e2.wireframeLinewidth && (i2.wireframeLinewidth = e2.wireframeLinewidth), void 0 !== e2.wireframeLinecap && (i2.wireframeLinecap = e2.wireframeLinecap), void 0 !== e2.wireframeLinejoin && (i2.wireframeLinejoin = e2.wireframeLinejoin), void 0 !== e2.rotation && (i2.rotation = e2.rotation), 1 !== e2.linewidth && (i2.linewidth = e2.linewidth), void 0 !== e2.dashSize && (i2.dashSize = e2.dashSize), void 0 !== e2.gapSize && (i2.gapSize = e2.gapSize), void 0 !== e2.scale && (i2.scale = e2.scale), void 0 !== e2.polygonOffset && (i2.polygonOffset = e2.polygonOffset), void 0 !== e2.polygonOffsetFactor && (i2.polygonOffsetFactor = e2.polygonOffsetFactor), void 0 !== e2.polygonOffsetUnits && (i2.polygonOffsetUnits = e2.polygonOffsetUnits), void 0 !== e2.dithering && (i2.dithering = e2.dithering), void 0 !== e2.alphaToCoverage && (i2.alphaToCoverage = e2.alphaToCoverage), void 0 !== e2.premultipliedAlpha && (i2.premultipliedAlpha = e2.premultipliedAlpha), void 0 !== e2.forceSinglePass && (i2.forceSinglePass = e2.forceSinglePass), void 0 !== e2.visible && (i2.visible = e2.visible), void 0 !== e2.toneMapped && (i2.toneMapped = e2.toneMapped), void 0 !== e2.userData && (i2.userData = e2.userData), void 0 !== e2.vertexColors && ("number" == typeof e2.vertexColors ? i2.vertexColors = e2.vertexColors > 0 : i2.vertexColors = e2.vertexColors), void 0 !== e2.uniforms)
        for (const t3 in e2.uniforms) {
          const s2 = e2.uniforms[t3];
          switch (i2.uniforms[t3] = {}, s2.type) {
            case "t":
              i2.uniforms[t3].value = n2(s2.value);
              break;
            case "c":
              i2.uniforms[t3].value = new Vi().setHex(s2.value, r2);
              break;
            case "v2":
              i2.uniforms[t3].value = new Qn().fromArray(s2.value);
              break;
            case "v3":
              i2.uniforms[t3].value = new Ar().fromArray(s2.value);
              break;
            case "v4":
              i2.uniforms[t3].value = new fr().fromArray(s2.value);
              break;
            case "m3":
              i2.uniforms[t3].value = new Wn().fromArray(s2.value);
              break;
            case "m4":
              i2.uniforms[t3].value = new Zr().fromArray(s2.value);
              break;
            default:
              i2.uniforms[t3].value = s2.value;
          }
        }
      if (void 0 !== e2.defines && (i2.defines = e2.defines), void 0 !== e2.vertexShader && (i2.vertexShader = e2.vertexShader), void 0 !== e2.fragmentShader && (i2.fragmentShader = e2.fragmentShader), void 0 !== e2.glslVersion && (i2.glslVersion = e2.glslVersion), void 0 !== e2.extensions)
        for (const t3 in e2.extensions)
          i2.extensions[t3] = e2.extensions[t3];
      if (void 0 !== e2.lights && (i2.lights = e2.lights), void 0 !== e2.clipping && (i2.clipping = e2.clipping), void 0 !== e2.size && (i2.size = e2.size), void 0 !== e2.sizeAttenuation && (i2.sizeAttenuation = e2.sizeAttenuation), void 0 !== e2.map && (i2.map = n2(e2.map)), void 0 !== e2.matcap && (i2.matcap = n2(e2.matcap)), void 0 !== e2.alphaMap && (i2.alphaMap = n2(e2.alphaMap)), void 0 !== e2.bumpMap && (i2.bumpMap = n2(e2.bumpMap)), void 0 !== e2.bumpScale && (i2.bumpScale = e2.bumpScale), void 0 !== e2.normalMap && (i2.normalMap = n2(e2.normalMap)), void 0 !== e2.normalMapType && (i2.normalMapType = e2.normalMapType), void 0 !== e2.normalScale) {
        let t3 = e2.normalScale;
        false === Array.isArray(t3) && (t3 = [t3, t3]), i2.normalScale = new Qn().fromArray(t3);
      }
      return void 0 !== e2.displacementMap && (i2.displacementMap = n2(e2.displacementMap)), void 0 !== e2.displacementScale && (i2.displacementScale = e2.displacementScale), void 0 !== e2.displacementBias && (i2.displacementBias = e2.displacementBias), void 0 !== e2.roughnessMap && (i2.roughnessMap = n2(e2.roughnessMap)), void 0 !== e2.metalnessMap && (i2.metalnessMap = n2(e2.metalnessMap)), void 0 !== e2.emissiveMap && (i2.emissiveMap = n2(e2.emissiveMap)), void 0 !== e2.emissiveIntensity && (i2.emissiveIntensity = e2.emissiveIntensity), void 0 !== e2.specularMap && (i2.specularMap = n2(e2.specularMap)), void 0 !== e2.specularIntensityMap && (i2.specularIntensityMap = n2(e2.specularIntensityMap)), void 0 !== e2.specularColorMap && (i2.specularColorMap = n2(e2.specularColorMap)), void 0 !== e2.envMap && (i2.envMap = n2(e2.envMap)), void 0 !== e2.envMapIntensity && (i2.envMapIntensity = e2.envMapIntensity), void 0 !== e2.reflectivity && (i2.reflectivity = e2.reflectivity), void 0 !== e2.refractionRatio && (i2.refractionRatio = e2.refractionRatio), void 0 !== e2.lightMap && (i2.lightMap = n2(e2.lightMap)), void 0 !== e2.lightMapIntensity && (i2.lightMapIntensity = e2.lightMapIntensity), void 0 !== e2.aoMap && (i2.aoMap = n2(e2.aoMap)), void 0 !== e2.aoMapIntensity && (i2.aoMapIntensity = e2.aoMapIntensity), void 0 !== e2.gradientMap && (i2.gradientMap = n2(e2.gradientMap)), void 0 !== e2.clearcoatMap && (i2.clearcoatMap = n2(e2.clearcoatMap)), void 0 !== e2.clearcoatRoughnessMap && (i2.clearcoatRoughnessMap = n2(e2.clearcoatRoughnessMap)), void 0 !== e2.clearcoatNormalMap && (i2.clearcoatNormalMap = n2(e2.clearcoatNormalMap)), void 0 !== e2.clearcoatNormalScale && (i2.clearcoatNormalScale = new Qn().fromArray(e2.clearcoatNormalScale)), void 0 !== e2.iridescenceMap && (i2.iridescenceMap = n2(e2.iridescenceMap)), void 0 !== e2.iridescenceThicknessMap && (i2.iridescenceThicknessMap = n2(e2.iridescenceThicknessMap)), void 0 !== e2.transmissionMap && (i2.transmissionMap = n2(e2.transmissionMap)), void 0 !== e2.thicknessMap && (i2.thicknessMap = n2(e2.thicknessMap)), void 0 !== e2.anisotropyMap && (i2.anisotropyMap = n2(e2.anisotropyMap)), void 0 !== e2.sheenColorMap && (i2.sheenColorMap = n2(e2.sheenColorMap)), void 0 !== e2.sheenRoughnessMap && (i2.sheenRoughnessMap = n2(e2.sheenRoughnessMap)), i2;
    }
    setTextures(e2) {
      return this.textures = e2, this;
    }
    static createMaterialFromType(e2) {
      return new { ShadowMaterial: Mp, SpriteMaterial: ql, RawShaderMaterial: Tp, ShaderMaterial: Gs, PointsMaterial: qc, MeshPhysicalMaterial: Ip, MeshStandardMaterial: Pp, MeshPhongMaterial: Rp, MeshToonMaterial: kp, MeshNormalMaterial: Dp, MeshLambertMaterial: Bp, MeshDepthMaterial: Al, MeshDistanceMaterial: xl, MeshBasicMaterial: Qi, MeshMatcapMaterial: Op, LineDashedMaterial: Lp, LineBasicMaterial: Lc, Material: Ui }[e2]();
    }
  }
  class Ud {
    static decodeText(e2) {
      if ("undefined" != typeof TextDecoder)
        return new TextDecoder().decode(e2);
      let t2 = "";
      for (let n2 = 0, r2 = e2.length; n2 < r2; n2++)
        t2 += String.fromCharCode(e2[n2]);
      try {
        return decodeURIComponent(escape(t2));
      } catch (e3) {
        return t2;
      }
    }
    static extractUrlBase(e2) {
      const t2 = e2.lastIndexOf("/");
      return -1 === t2 ? "./" : e2.slice(0, t2 + 1);
    }
    static resolveURL(e2, t2) {
      return "string" != typeof e2 || "" === e2 ? "" : (/^https?:\/\//i.test(t2) && /^\//.test(e2) && (t2 = t2.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e2) || /^data:.*,.*$/i.test(e2) || /^blob:.*$/i.test(e2) ? e2 : t2 + e2);
    }
  }
  class Fd extends gs {
    constructor() {
      super(), this.isInstancedBufferGeometry = true, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
    }
    copy(e2) {
      return super.copy(e2), this.instanceCount = e2.instanceCount, this;
    }
    toJSON() {
      const e2 = super.toJSON();
      return e2.instanceCount = this.instanceCount, e2.isInstancedBufferGeometry = true, e2;
    }
  }
  class Nd extends ad {
    constructor(e2) {
      super(e2);
    }
    load(e2, t2, n2, r2) {
      const i2 = this, s2 = new ud(i2.manager);
      s2.setPath(i2.path), s2.setRequestHeader(i2.requestHeader), s2.setWithCredentials(i2.withCredentials), s2.load(e2, function(n3) {
        try {
          t2(i2.parse(JSON.parse(n3)));
        } catch (t3) {
          r2 ? r2(t3) : console.error(t3), i2.manager.itemError(e2);
        }
      }, n2, r2);
    }
    parse(e2) {
      const t2 = {}, n2 = {};
      function r2(e3, r3) {
        if (void 0 !== t2[r3])
          return t2[r3];
        const i3 = e3.interleavedBuffers[r3], s3 = function(e4, t3) {
          if (void 0 !== n2[t3])
            return n2[t3];
          const r4 = e4.arrayBuffers[t3], i4 = new Uint32Array(r4).buffer;
          return n2[t3] = i4, i4;
        }(e3, i3.buffer), o3 = Kn(i3.type, s3), a3 = new Hl(o3, i3.stride);
        return a3.uuid = i3.uuid, t2[r3] = a3, a3;
      }
      const i2 = e2.isInstancedBufferGeometry ? new Fd() : new gs(), s2 = e2.data.index;
      if (void 0 !== s2) {
        const e3 = Kn(s2.type, s2.array);
        i2.setIndex(new $i(e3, 1));
      }
      const o2 = e2.data.attributes;
      for (const t3 in o2) {
        const n3 = o2[t3];
        let s3;
        if (n3.isInterleavedBufferAttribute) {
          const t4 = r2(e2.data, n3.data);
          s3 = new Wl(t4, n3.itemSize, n3.offset, n3.normalized);
        } else {
          const e3 = Kn(n3.type, n3.array);
          s3 = new (n3.isInstancedBufferAttribute ? Mc : $i)(e3, n3.itemSize, n3.normalized);
        }
        void 0 !== n3.name && (s3.name = n3.name), void 0 !== n3.usage && s3.setUsage(n3.usage), void 0 !== n3.updateRange && (s3.updateRange.offset = n3.updateRange.offset, s3.updateRange.count = n3.updateRange.count), i2.setAttribute(t3, s3);
      }
      const a2 = e2.data.morphAttributes;
      if (a2)
        for (const t3 in a2) {
          const n3 = a2[t3], s3 = [];
          for (let t4 = 0, i3 = n3.length; t4 < i3; t4++) {
            const i4 = n3[t4];
            let o3;
            if (i4.isInterleavedBufferAttribute) {
              const t5 = r2(e2.data, i4.data);
              o3 = new Wl(t5, i4.itemSize, i4.offset, i4.normalized);
            } else {
              const e3 = Kn(i4.type, i4.array);
              o3 = new $i(e3, i4.itemSize, i4.normalized);
            }
            void 0 !== i4.name && (o3.name = i4.name), s3.push(o3);
          }
          i2.morphAttributes[t3] = s3;
        }
      e2.data.morphTargetsRelative && (i2.morphTargetsRelative = true);
      const l2 = e2.data.groups || e2.data.drawcalls || e2.data.offsets;
      if (void 0 !== l2)
        for (let e3 = 0, t3 = l2.length; e3 !== t3; ++e3) {
          const t4 = l2[e3];
          i2.addGroup(t4.start, t4.count, t4.materialIndex);
        }
      const c2 = e2.data.boundingSphere;
      if (void 0 !== c2) {
        const e3 = new Ar();
        void 0 !== c2.center && e3.fromArray(c2.center), i2.boundingSphere = new Vr(e3, c2.radius);
      }
      return e2.name && (i2.name = e2.name), e2.userData && (i2.userData = e2.userData), i2;
    }
  }
  class jd extends ad {
    constructor(e2) {
      super(e2);
    }
    load(e2, t2, n2, r2) {
      const i2 = this, s2 = "" === this.path ? Ud.extractUrlBase(e2) : this.path;
      this.resourcePath = this.resourcePath || s2;
      const o2 = new ud(this.manager);
      o2.setPath(this.path), o2.setRequestHeader(this.requestHeader), o2.setWithCredentials(this.withCredentials), o2.load(e2, function(n3) {
        let s3 = null;
        try {
          s3 = JSON.parse(n3);
        } catch (t3) {
          return void 0 !== r2 && r2(t3), void console.error("THREE:ObjectLoader: Can't parse " + e2 + ".", t3.message);
        }
        const o3 = s3.metadata;
        if (void 0 === o3 || void 0 === o3.type || "geometry" === o3.type.toLowerCase())
          return void 0 !== r2 && r2(new Error("THREE.ObjectLoader: Can't load " + e2)), void console.error("THREE.ObjectLoader: Can't load " + e2);
        i2.parse(s3, t2);
      }, n2, r2);
    }
    async loadAsync(e2, t2) {
      const n2 = "" === this.path ? Ud.extractUrlBase(e2) : this.path;
      this.resourcePath = this.resourcePath || n2;
      const r2 = new ud(this.manager);
      r2.setPath(this.path), r2.setRequestHeader(this.requestHeader), r2.setWithCredentials(this.withCredentials);
      const i2 = await r2.loadAsync(e2, t2), s2 = JSON.parse(i2), o2 = s2.metadata;
      if (void 0 === o2 || void 0 === o2.type || "geometry" === o2.type.toLowerCase())
        throw new Error("THREE.ObjectLoader: Can't load " + e2);
      return await this.parseAsync(s2);
    }
    parse(e2, t2) {
      const n2 = this.parseAnimations(e2.animations), r2 = this.parseShapes(e2.shapes), i2 = this.parseGeometries(e2.geometries, r2), s2 = this.parseImages(e2.images, function() {
        void 0 !== t2 && t2(l2);
      }), o2 = this.parseTextures(e2.textures, s2), a2 = this.parseMaterials(e2.materials, o2), l2 = this.parseObject(e2.object, i2, a2, o2, n2), c2 = this.parseSkeletons(e2.skeletons, l2);
      if (this.bindSkeletons(l2, c2), void 0 !== t2) {
        let e3 = false;
        for (const t3 in s2)
          if (s2[t3].data instanceof HTMLImageElement) {
            e3 = true;
            break;
          }
        false === e3 && t2(l2);
      }
      return l2;
    }
    async parseAsync(e2) {
      const t2 = this.parseAnimations(e2.animations), n2 = this.parseShapes(e2.shapes), r2 = this.parseGeometries(e2.geometries, n2), i2 = await this.parseImagesAsync(e2.images), s2 = this.parseTextures(e2.textures, i2), o2 = this.parseMaterials(e2.materials, s2), a2 = this.parseObject(e2.object, r2, o2, s2, t2), l2 = this.parseSkeletons(e2.skeletons, a2);
      return this.bindSkeletons(a2, l2), a2;
    }
    parseShapes(e2) {
      const t2 = {};
      if (void 0 !== e2)
        for (let n2 = 0, r2 = e2.length; n2 < r2; n2++) {
          const r3 = new Nu().fromJSON(e2[n2]);
          t2[r3.uuid] = r3;
        }
      return t2;
    }
    parseSkeletons(e2, t2) {
      const n2 = {}, r2 = {};
      if (t2.traverse(function(e3) {
        e3.isBone && (r2[e3.uuid] = e3);
      }), void 0 !== e2)
        for (let t3 = 0, i2 = e2.length; t3 < i2; t3++) {
          const i3 = new Sc().fromJSON(e2[t3], r2);
          n2[i3.uuid] = i3;
        }
      return n2;
    }
    parseGeometries(e2, t2) {
      const n2 = {};
      if (void 0 !== e2) {
        const r2 = new Nd();
        for (let i2 = 0, s2 = e2.length; i2 < s2; i2++) {
          let s3;
          const o2 = e2[i2];
          switch (o2.type) {
            case "BufferGeometry":
            case "InstancedBufferGeometry":
              s3 = r2.parse(o2);
              break;
            default:
              o2.type in Sp ? s3 = Sp[o2.type].fromJSON(o2, t2) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${o2.type}"`);
          }
          s3.uuid = o2.uuid, void 0 !== o2.name && (s3.name = o2.name), void 0 !== o2.userData && (s3.userData = o2.userData), n2[o2.uuid] = s3;
        }
      }
      return n2;
    }
    parseMaterials(e2, t2) {
      const n2 = {}, r2 = {};
      if (void 0 !== e2) {
        const i2 = new Ld();
        i2.setTextures(t2);
        for (let t3 = 0, s2 = e2.length; t3 < s2; t3++) {
          const s3 = e2[t3];
          void 0 === n2[s3.uuid] && (n2[s3.uuid] = i2.parse(s3)), r2[s3.uuid] = n2[s3.uuid];
        }
      }
      return r2;
    }
    parseAnimations(e2) {
      const t2 = {};
      if (void 0 !== e2)
        for (let n2 = 0; n2 < e2.length; n2++) {
          const r2 = e2[n2], i2 = nd.parse(r2);
          t2[i2.uuid] = i2;
        }
      return t2;
    }
    parseImages(e2, t2) {
      const n2 = this, r2 = {};
      let i2;
      function s2(e3) {
        if ("string" == typeof e3) {
          const t3 = e3;
          return function(e4) {
            return n2.manager.itemStart(e4), i2.load(e4, function() {
              n2.manager.itemEnd(e4);
            }, void 0, function() {
              n2.manager.itemError(e4), n2.manager.itemEnd(e4);
            });
          }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(t3) ? t3 : n2.resourcePath + t3);
        }
        return e3.data ? { data: Kn(e3.type, e3.data), width: e3.width, height: e3.height, complete: true } : null;
      }
      if (void 0 !== e2 && e2.length > 0) {
        const n3 = new sd(t2);
        i2 = new hd(n3), i2.setCrossOrigin(this.crossOrigin);
        for (let t3 = 0, n4 = e2.length; t3 < n4; t3++) {
          const n5 = e2[t3], i3 = n5.url;
          if (Array.isArray(i3)) {
            const e3 = [];
            for (let t4 = 0, n6 = i3.length; t4 < n6; t4++) {
              const n7 = s2(i3[t4]);
              null !== n7 && (n7 instanceof HTMLImageElement ? e3.push(n7) : e3.push(new xc(n7.data, n7.width, n7.height)));
            }
            r2[n5.uuid] = new ur(e3);
          } else {
            const e3 = s2(n5.url);
            r2[n5.uuid] = new ur(e3);
          }
        }
      }
      return r2;
    }
    async parseImagesAsync(e2) {
      const t2 = this, n2 = {};
      let r2;
      async function i2(e3) {
        if ("string" == typeof e3) {
          const n3 = e3, i3 = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(n3) ? n3 : t2.resourcePath + n3;
          return await r2.loadAsync(i3);
        }
        return e3.data ? { data: Kn(e3.type, e3.data), width: e3.width, height: e3.height, complete: true } : null;
      }
      if (void 0 !== e2 && e2.length > 0) {
        r2 = new hd(this.manager), r2.setCrossOrigin(this.crossOrigin);
        for (let t3 = 0, r3 = e2.length; t3 < r3; t3++) {
          const r4 = e2[t3], s2 = r4.url;
          if (Array.isArray(s2)) {
            const e3 = [];
            for (let t4 = 0, n3 = s2.length; t4 < n3; t4++) {
              const n4 = s2[t4], r5 = await i2(n4);
              null !== r5 && (r5 instanceof HTMLImageElement ? e3.push(r5) : e3.push(new xc(r5.data, r5.width, r5.height)));
            }
            n2[r4.uuid] = new ur(e3);
          } else {
            const e3 = await i2(r4.url);
            n2[r4.uuid] = new ur(e3);
          }
        }
      }
      return n2;
    }
    parseTextures(e2, t2) {
      function n2(e3, t3) {
        return "number" == typeof e3 ? e3 : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e3), t3[e3]);
      }
      const r2 = {};
      if (void 0 !== e2)
        for (let i2 = 0, s2 = e2.length; i2 < s2; i2++) {
          const s3 = e2[i2];
          void 0 === s3.image && console.warn('THREE.ObjectLoader: No "image" specified for', s3.uuid), void 0 === t2[s3.image] && console.warn("THREE.ObjectLoader: Undefined image", s3.image);
          const o2 = t2[s3.image], a2 = o2 ? o2.data : void 0;
          let l2;
          Array.isArray(a2) ? (l2 = new qs(), 6 === a2.length && (l2.needsUpdate = true)) : (l2 = a2 && a2.data ? new xc() : new hr(), a2 && a2.complete && (l2.needsUpdate = true)), l2.source = o2, l2.uuid = s3.uuid, void 0 !== s3.name && (l2.name = s3.name), void 0 !== s3.mapping && (l2.mapping = n2(s3.mapping, zd)), void 0 !== s3.channel && (l2.channel = s3.channel), void 0 !== s3.offset && l2.offset.fromArray(s3.offset), void 0 !== s3.repeat && l2.repeat.fromArray(s3.repeat), void 0 !== s3.center && l2.center.fromArray(s3.center), void 0 !== s3.rotation && (l2.rotation = s3.rotation), void 0 !== s3.wrap && (l2.wrapS = n2(s3.wrap[0], Gd), l2.wrapT = n2(s3.wrap[1], Gd)), void 0 !== s3.format && (l2.format = s3.format), void 0 !== s3.internalFormat && (l2.internalFormat = s3.internalFormat), void 0 !== s3.type && (l2.type = s3.type), void 0 !== s3.colorSpace ? l2.colorSpace = s3.colorSpace : void 0 !== s3.encoding && (l2.encoding = s3.encoding), void 0 !== s3.minFilter && (l2.minFilter = n2(s3.minFilter, Vd)), void 0 !== s3.magFilter && (l2.magFilter = n2(s3.magFilter, Vd)), void 0 !== s3.anisotropy && (l2.anisotropy = s3.anisotropy), void 0 !== s3.flipY && (l2.flipY = s3.flipY), void 0 !== s3.generateMipmaps && (l2.generateMipmaps = s3.generateMipmaps), void 0 !== s3.premultiplyAlpha && (l2.premultiplyAlpha = s3.premultiplyAlpha), void 0 !== s3.unpackAlignment && (l2.unpackAlignment = s3.unpackAlignment), void 0 !== s3.compareFunction && (l2.compareFunction = s3.compareFunction), void 0 !== s3.userData && (l2.userData = s3.userData), r2[s3.uuid] = l2;
        }
      return r2;
    }
    parseObject(e2, t2, n2, r2, i2) {
      let s2;
      const o2 = e2.metadata && e2.metadata.version <= 4.5 ? Gt : void 0;
      function a2(e3) {
        return void 0 === t2[e3] && console.warn("THREE.ObjectLoader: Undefined geometry", e3), t2[e3];
      }
      function l2(e3) {
        if (void 0 !== e3) {
          if (Array.isArray(e3)) {
            const t3 = [];
            for (let r3 = 0, i3 = e3.length; r3 < i3; r3++) {
              const i4 = e3[r3];
              void 0 === n2[i4] && console.warn("THREE.ObjectLoader: Undefined material", i4), t3.push(n2[i4]);
            }
            return t3;
          }
          return void 0 === n2[e3] && console.warn("THREE.ObjectLoader: Undefined material", e3), n2[e3];
        }
      }
      function c2(e3) {
        return void 0 === r2[e3] && console.warn("THREE.ObjectLoader: Undefined texture", e3), r2[e3];
      }
      let u2, p2;
      switch (e2.type) {
        case "Scene":
          s2 = new Vl(), void 0 !== e2.background && (Number.isInteger(e2.background) ? s2.background = new Vi().setHex(e2.background, o2) : s2.background = c2(e2.background)), void 0 !== e2.environment && (s2.environment = c2(e2.environment)), void 0 !== e2.fog && ("Fog" === e2.fog.type ? s2.fog = new Gl(e2.fog.color, e2.fog.near, e2.fog.far) : "FogExp2" === e2.fog.type && (s2.fog = new zl(e2.fog.color, e2.fog.density))), void 0 !== e2.backgroundBlurriness && (s2.backgroundBlurriness = e2.backgroundBlurriness), void 0 !== e2.backgroundIntensity && (s2.backgroundIntensity = e2.backgroundIntensity);
          break;
        case "PerspectiveCamera":
          s2 = new Hs(e2.fov, e2.aspect, e2.near, e2.far), void 0 !== e2.focus && (s2.focus = e2.focus), void 0 !== e2.zoom && (s2.zoom = e2.zoom), void 0 !== e2.filmGauge && (s2.filmGauge = e2.filmGauge), void 0 !== e2.filmOffset && (s2.filmOffset = e2.filmOffset), void 0 !== e2.view && (s2.view = Object.assign({}, e2.view));
          break;
        case "OrthographicCamera":
          s2 = new _o(e2.left, e2.right, e2.top, e2.bottom, e2.near, e2.far), void 0 !== e2.zoom && (s2.zoom = e2.zoom), void 0 !== e2.view && (s2.view = Object.assign({}, e2.view));
          break;
        case "AmbientLight":
          s2 = new kd(e2.color, e2.intensity);
          break;
        case "DirectionalLight":
          s2 = new Rd(e2.color, e2.intensity);
          break;
        case "PointLight":
          s2 = new Pd(e2.color, e2.intensity, e2.distance, e2.decay);
          break;
        case "RectAreaLight":
          s2 = new Dd(e2.color, e2.intensity, e2.width, e2.height);
          break;
        case "SpotLight":
          s2 = new Ed(e2.color, e2.intensity, e2.distance, e2.angle, e2.penumbra, e2.decay);
          break;
        case "HemisphereLight":
          s2 = new vd(e2.color, e2.groundColor, e2.intensity);
          break;
        case "LightProbe":
          s2 = new Od().fromJSON(e2);
          break;
        case "SkinnedMesh":
          u2 = a2(e2.geometry), p2 = l2(e2.material), s2 = new wc(u2, p2), void 0 !== e2.bindMode && (s2.bindMode = e2.bindMode), void 0 !== e2.bindMatrix && s2.bindMatrix.fromArray(e2.bindMatrix), void 0 !== e2.skeleton && (s2.skeleton = e2.skeleton);
          break;
        case "Mesh":
          u2 = a2(e2.geometry), p2 = l2(e2.material), s2 = new Os(u2, p2);
          break;
        case "InstancedMesh":
          u2 = a2(e2.geometry), p2 = l2(e2.material);
          const t3 = e2.count, n3 = e2.instanceMatrix, r3 = e2.instanceColor;
          s2 = new Oc(u2, p2, t3), s2.instanceMatrix = new Mc(new Float32Array(n3.array), 16), void 0 !== r3 && (s2.instanceColor = new Mc(new Float32Array(r3.array), r3.itemSize));
          break;
        case "LOD":
          s2 = new pc();
          break;
        case "Line":
          s2 = new Gc(a2(e2.geometry), l2(e2.material));
          break;
        case "LineLoop":
          s2 = new Wc(a2(e2.geometry), l2(e2.material));
          break;
        case "LineSegments":
          s2 = new Qc(a2(e2.geometry), l2(e2.material));
          break;
        case "PointCloud":
        case "Points":
          s2 = new Zc(a2(e2.geometry), l2(e2.material));
          break;
        case "Sprite":
          s2 = new ac(l2(e2.material));
          break;
        case "Group":
          s2 = new Rl();
          break;
        case "Bone":
          s2 = new Ac();
          break;
        default:
          s2 = new xi();
      }
      if (s2.uuid = e2.uuid, void 0 !== e2.name && (s2.name = e2.name), void 0 !== e2.matrix ? (s2.matrix.fromArray(e2.matrix), void 0 !== e2.matrixAutoUpdate && (s2.matrixAutoUpdate = e2.matrixAutoUpdate), s2.matrixAutoUpdate && s2.matrix.decompose(s2.position, s2.quaternion, s2.scale)) : (void 0 !== e2.position && s2.position.fromArray(e2.position), void 0 !== e2.rotation && s2.rotation.fromArray(e2.rotation), void 0 !== e2.quaternion && s2.quaternion.fromArray(e2.quaternion), void 0 !== e2.scale && s2.scale.fromArray(e2.scale)), void 0 !== e2.up && s2.up.fromArray(e2.up), void 0 !== e2.castShadow && (s2.castShadow = e2.castShadow), void 0 !== e2.receiveShadow && (s2.receiveShadow = e2.receiveShadow), e2.shadow && (void 0 !== e2.shadow.bias && (s2.shadow.bias = e2.shadow.bias), void 0 !== e2.shadow.normalBias && (s2.shadow.normalBias = e2.shadow.normalBias), void 0 !== e2.shadow.radius && (s2.shadow.radius = e2.shadow.radius), void 0 !== e2.shadow.mapSize && s2.shadow.mapSize.fromArray(e2.shadow.mapSize), void 0 !== e2.shadow.camera && (s2.shadow.camera = this.parseObject(e2.shadow.camera))), void 0 !== e2.visible && (s2.visible = e2.visible), void 0 !== e2.frustumCulled && (s2.frustumCulled = e2.frustumCulled), void 0 !== e2.renderOrder && (s2.renderOrder = e2.renderOrder), void 0 !== e2.userData && (s2.userData = e2.userData), void 0 !== e2.layers && (s2.layers.mask = e2.layers), void 0 !== e2.children) {
        const o3 = e2.children;
        for (let e3 = 0; e3 < o3.length; e3++)
          s2.add(this.parseObject(o3[e3], t2, n2, r2, i2));
      }
      if (void 0 !== e2.animations) {
        const t3 = e2.animations;
        for (let e3 = 0; e3 < t3.length; e3++) {
          const n3 = t3[e3];
          s2.animations.push(i2[n3]);
        }
      }
      if ("LOD" === e2.type) {
        void 0 !== e2.autoUpdate && (s2.autoUpdate = e2.autoUpdate);
        const t3 = e2.levels;
        for (let e3 = 0; e3 < t3.length; e3++) {
          const n3 = t3[e3], r3 = s2.getObjectByProperty("uuid", n3.object);
          void 0 !== r3 && s2.addLevel(r3, n3.distance, n3.hysteresis);
        }
      }
      return s2;
    }
    bindSkeletons(e2, t2) {
      0 !== Object.keys(t2).length && e2.traverse(function(e3) {
        if (true === e3.isSkinnedMesh && void 0 !== e3.skeleton) {
          const n2 = t2[e3.skeleton];
          void 0 === n2 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", e3.skeleton) : e3.bind(n2, e3.bindMatrix);
        }
      });
    }
  }
  const zd = { UVMapping: re, CubeReflectionMapping: ie, CubeRefractionMapping: se, EquirectangularReflectionMapping: oe, EquirectangularRefractionMapping: ae, CubeUVReflectionMapping: le }, Gd = { RepeatWrapping: ce, ClampToEdgeWrapping: ue, MirroredRepeatWrapping: pe }, Vd = { NearestFilter: de, NearestMipmapNearestFilter: he, NearestMipmapLinearFilter: me, LinearFilter: ge, LinearMipmapNearestFilter: ve, LinearMipmapLinearFilter: be };
  class Hd extends ad {
    constructor(e2) {
      super(e2), this.isImageBitmapLoader = true, "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
    }
    setOptions(e2) {
      return this.options = e2, this;
    }
    load(e2, t2, n2, r2) {
      void 0 === e2 && (e2 = ""), void 0 !== this.path && (e2 = this.path + e2), e2 = this.manager.resolveURL(e2);
      const i2 = this;
      id.get(e2, "blob").then((n3) => {
        if (void 0 !== n3)
          return i2.manager.itemStart(e2), void createImageBitmap(n3, Object.assign(i2.options, { colorSpaceConversion: "none" })).then(function(n4) {
            t2 && t2(n4), i2.manager.itemEnd(e2);
          }).catch(function(t3) {
            r2 && r2(t3), i2.manager.itemError(e2), i2.manager.itemEnd(e2);
          });
        const s2 = {};
        s2.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", s2.headers = this.requestHeader, fetch(e2, s2).then(function(e3) {
          return e3.blob();
        }).then(function(t3) {
          return id.add(e2, t3, "blob"), createImageBitmap(t3, Object.assign(i2.options, { colorSpaceConversion: "none" }));
        }).then(function(n4) {
          t2 && t2(n4), i2.manager.itemEnd(e2);
        }).catch(function(t3) {
          r2 && r2(t3), i2.manager.itemError(e2), i2.manager.itemEnd(e2);
        }), i2.manager.itemStart(e2);
      });
    }
  }
  let Qd;
  class Wd {
    static getContext() {
      return void 0 === Qd && (Qd = new (window.AudioContext || window.webkitAudioContext)()), Qd;
    }
    static setContext(e2) {
      Qd = e2;
    }
  }
  class qd extends ad {
    constructor(e2) {
      super(e2);
    }
    load(e2, t2, n2, r2) {
      const i2 = this, s2 = new ud(this.manager);
      function o2(t3) {
        r2 ? r2(t3) : console.error(t3), i2.manager.itemError(e2);
      }
      s2.setResponseType("arraybuffer"), s2.setPath(this.path), s2.setRequestHeader(this.requestHeader), s2.setWithCredentials(this.withCredentials), s2.load(e2, function(e3) {
        try {
          const n3 = e3.slice(0);
          Wd.getContext().decodeAudioData(n3, function(e4) {
            t2(e4);
          }, o2);
        } catch (e4) {
          o2(e4);
        }
      }, n2, r2);
    }
  }
  class Xd extends Od {
    constructor(e2, t2, n2 = 1) {
      super(void 0, n2), this.isHemisphereLightProbe = true;
      const r2 = new Vi().set(e2), i2 = new Vi().set(t2), s2 = new Ar(r2.r, r2.g, r2.b), o2 = new Ar(i2.r, i2.g, i2.b), a2 = Math.sqrt(Math.PI), l2 = a2 * Math.sqrt(0.75);
      this.sh.coefficients[0].copy(s2).add(o2).multiplyScalar(a2), this.sh.coefficients[1].copy(s2).sub(o2).multiplyScalar(l2);
    }
  }
  class Yd extends Od {
    constructor(e2, t2 = 1) {
      super(void 0, t2), this.isAmbientLightProbe = true;
      const n2 = new Vi().set(e2);
      this.sh.coefficients[0].set(n2.r, n2.g, n2.b).multiplyScalar(2 * Math.sqrt(Math.PI));
    }
  }
  const Kd = new Zr(), Jd = new Zr(), Zd = new Zr();
  class $d {
    constructor() {
      this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new Hs(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = false, this.cameraR = new Hs(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = false, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null };
    }
    update(e2) {
      const t2 = this._cache;
      if (t2.focus !== e2.focus || t2.fov !== e2.fov || t2.aspect !== e2.aspect * this.aspect || t2.near !== e2.near || t2.far !== e2.far || t2.zoom !== e2.zoom || t2.eyeSep !== this.eyeSep) {
        t2.focus = e2.focus, t2.fov = e2.fov, t2.aspect = e2.aspect * this.aspect, t2.near = e2.near, t2.far = e2.far, t2.zoom = e2.zoom, t2.eyeSep = this.eyeSep, Zd.copy(e2.projectionMatrix);
        const n2 = t2.eyeSep / 2, r2 = n2 * t2.near / t2.focus, i2 = t2.near * Math.tan(Dn * t2.fov * 0.5) / t2.zoom;
        let s2, o2;
        Jd.elements[12] = -n2, Kd.elements[12] = n2, s2 = -i2 * t2.aspect + r2, o2 = i2 * t2.aspect + r2, Zd.elements[0] = 2 * t2.near / (o2 - s2), Zd.elements[8] = (o2 + s2) / (o2 - s2), this.cameraL.projectionMatrix.copy(Zd), s2 = -i2 * t2.aspect - r2, o2 = i2 * t2.aspect - r2, Zd.elements[0] = 2 * t2.near / (o2 - s2), Zd.elements[8] = (o2 + s2) / (o2 - s2), this.cameraR.projectionMatrix.copy(Zd);
      }
      this.cameraL.matrixWorld.copy(e2.matrixWorld).multiply(Jd), this.cameraR.matrixWorld.copy(e2.matrixWorld).multiply(Kd);
    }
  }
  class eh {
    constructor(e2 = true) {
      this.autoStart = e2, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = false;
    }
    start() {
      this.startTime = th(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = true;
    }
    stop() {
      this.getElapsedTime(), this.running = false, this.autoStart = false;
    }
    getElapsedTime() {
      return this.getDelta(), this.elapsedTime;
    }
    getDelta() {
      let e2 = 0;
      if (this.autoStart && !this.running)
        return this.start(), 0;
      if (this.running) {
        const t2 = th();
        e2 = (t2 - this.oldTime) / 1e3, this.oldTime = t2, this.elapsedTime += e2;
      }
      return e2;
    }
  }
  function th() {
    return ("undefined" == typeof performance ? Date : performance).now();
  }
  const nh = new Ar(), rh = new wr(), ih = new Ar(), sh = new Ar();
  class oh extends xi {
    constructor() {
      super(), this.type = "AudioListener", this.context = Wd.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new eh();
    }
    getInput() {
      return this.gain;
    }
    removeFilter() {
      return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
    }
    getFilter() {
      return this.filter;
    }
    setFilter(e2) {
      return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e2, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
    }
    getMasterVolume() {
      return this.gain.gain.value;
    }
    setMasterVolume(e2) {
      return this.gain.gain.setTargetAtTime(e2, this.context.currentTime, 0.01), this;
    }
    updateMatrixWorld(e2) {
      super.updateMatrixWorld(e2);
      const t2 = this.context.listener, n2 = this.up;
      if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(nh, rh, ih), sh.set(0, 0, -1).applyQuaternion(rh), t2.positionX) {
        const e3 = this.context.currentTime + this.timeDelta;
        t2.positionX.linearRampToValueAtTime(nh.x, e3), t2.positionY.linearRampToValueAtTime(nh.y, e3), t2.positionZ.linearRampToValueAtTime(nh.z, e3), t2.forwardX.linearRampToValueAtTime(sh.x, e3), t2.forwardY.linearRampToValueAtTime(sh.y, e3), t2.forwardZ.linearRampToValueAtTime(sh.z, e3), t2.upX.linearRampToValueAtTime(n2.x, e3), t2.upY.linearRampToValueAtTime(n2.y, e3), t2.upZ.linearRampToValueAtTime(n2.z, e3);
      } else
        t2.setPosition(nh.x, nh.y, nh.z), t2.setOrientation(sh.x, sh.y, sh.z, n2.x, n2.y, n2.z);
    }
  }
  class ah extends xi {
    constructor(e2) {
      super(), this.type = "Audio", this.listener = e2, this.context = e2.context, this.gain = this.context.createGain(), this.gain.connect(e2.getInput()), this.autoplay = false, this.buffer = null, this.detune = 0, this.loop = false, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = false, this.hasPlaybackControl = true, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = false, this.filters = [];
    }
    getOutput() {
      return this.gain;
    }
    setNodeSource(e2) {
      return this.hasPlaybackControl = false, this.sourceType = "audioNode", this.source = e2, this.connect(), this;
    }
    setMediaElementSource(e2) {
      return this.hasPlaybackControl = false, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e2), this.connect(), this;
    }
    setMediaStreamSource(e2) {
      return this.hasPlaybackControl = false, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e2), this.connect(), this;
    }
    setBuffer(e2) {
      return this.buffer = e2, this.sourceType = "buffer", this.autoplay && this.play(), this;
    }
    play(e2 = 0) {
      if (true === this.isPlaying)
        return void console.warn("THREE.Audio: Audio is already playing.");
      if (false === this.hasPlaybackControl)
        return void console.warn("THREE.Audio: this Audio has no playback control.");
      this._startedAt = this.context.currentTime + e2;
      const t2 = this.context.createBufferSource();
      return t2.buffer = this.buffer, t2.loop = this.loop, t2.loopStart = this.loopStart, t2.loopEnd = this.loopEnd, t2.onended = this.onEnded.bind(this), t2.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = true, this.source = t2, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
    }
    pause() {
      if (false !== this.hasPlaybackControl)
        return true === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, true === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = false), this;
      console.warn("THREE.Audio: this Audio has no playback control.");
    }
    stop() {
      if (false !== this.hasPlaybackControl)
        return this._progress = 0, null !== this.source && (this.source.stop(), this.source.onended = null), this.isPlaying = false, this;
      console.warn("THREE.Audio: this Audio has no playback control.");
    }
    connect() {
      if (this.filters.length > 0) {
        this.source.connect(this.filters[0]);
        for (let e2 = 1, t2 = this.filters.length; e2 < t2; e2++)
          this.filters[e2 - 1].connect(this.filters[e2]);
        this.filters[this.filters.length - 1].connect(this.getOutput());
      } else
        this.source.connect(this.getOutput());
      return this._connected = true, this;
    }
    disconnect() {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e2 = 1, t2 = this.filters.length; e2 < t2; e2++)
          this.filters[e2 - 1].disconnect(this.filters[e2]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else
        this.source.disconnect(this.getOutput());
      return this._connected = false, this;
    }
    getFilters() {
      return this.filters;
    }
    setFilters(e2) {
      return e2 || (e2 = []), true === this._connected ? (this.disconnect(), this.filters = e2.slice(), this.connect()) : this.filters = e2.slice(), this;
    }
    setDetune(e2) {
      if (this.detune = e2, void 0 !== this.source.detune)
        return true === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
    }
    getDetune() {
      return this.detune;
    }
    getFilter() {
      return this.getFilters()[0];
    }
    setFilter(e2) {
      return this.setFilters(e2 ? [e2] : []);
    }
    setPlaybackRate(e2) {
      if (false !== this.hasPlaybackControl)
        return this.playbackRate = e2, true === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
      console.warn("THREE.Audio: this Audio has no playback control.");
    }
    getPlaybackRate() {
      return this.playbackRate;
    }
    onEnded() {
      this.isPlaying = false;
    }
    getLoop() {
      return false === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), false) : this.loop;
    }
    setLoop(e2) {
      if (false !== this.hasPlaybackControl)
        return this.loop = e2, true === this.isPlaying && (this.source.loop = this.loop), this;
      console.warn("THREE.Audio: this Audio has no playback control.");
    }
    setLoopStart(e2) {
      return this.loopStart = e2, this;
    }
    setLoopEnd(e2) {
      return this.loopEnd = e2, this;
    }
    getVolume() {
      return this.gain.gain.value;
    }
    setVolume(e2) {
      return this.gain.gain.setTargetAtTime(e2, this.context.currentTime, 0.01), this;
    }
  }
  const lh = new Ar(), ch = new wr(), uh = new Ar(), ph = new Ar();
  class dh extends ah {
    constructor(e2) {
      super(e2), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
    }
    connect() {
      super.connect(), this.panner.connect(this.gain);
    }
    disconnect() {
      super.disconnect(), this.panner.disconnect(this.gain);
    }
    getOutput() {
      return this.panner;
    }
    getRefDistance() {
      return this.panner.refDistance;
    }
    setRefDistance(e2) {
      return this.panner.refDistance = e2, this;
    }
    getRolloffFactor() {
      return this.panner.rolloffFactor;
    }
    setRolloffFactor(e2) {
      return this.panner.rolloffFactor = e2, this;
    }
    getDistanceModel() {
      return this.panner.distanceModel;
    }
    setDistanceModel(e2) {
      return this.panner.distanceModel = e2, this;
    }
    getMaxDistance() {
      return this.panner.maxDistance;
    }
    setMaxDistance(e2) {
      return this.panner.maxDistance = e2, this;
    }
    setDirectionalCone(e2, t2, n2) {
      return this.panner.coneInnerAngle = e2, this.panner.coneOuterAngle = t2, this.panner.coneOuterGain = n2, this;
    }
    updateMatrixWorld(e2) {
      if (super.updateMatrixWorld(e2), true === this.hasPlaybackControl && false === this.isPlaying)
        return;
      this.matrixWorld.decompose(lh, ch, uh), ph.set(0, 0, 1).applyQuaternion(ch);
      const t2 = this.panner;
      if (t2.positionX) {
        const e3 = this.context.currentTime + this.listener.timeDelta;
        t2.positionX.linearRampToValueAtTime(lh.x, e3), t2.positionY.linearRampToValueAtTime(lh.y, e3), t2.positionZ.linearRampToValueAtTime(lh.z, e3), t2.orientationX.linearRampToValueAtTime(ph.x, e3), t2.orientationY.linearRampToValueAtTime(ph.y, e3), t2.orientationZ.linearRampToValueAtTime(ph.z, e3);
      } else
        t2.setPosition(lh.x, lh.y, lh.z), t2.setOrientation(ph.x, ph.y, ph.z);
    }
  }
  class hh {
    constructor(e2, t2 = 2048) {
      this.analyser = e2.context.createAnalyser(), this.analyser.fftSize = t2, this.data = new Uint8Array(this.analyser.frequencyBinCount), e2.getOutput().connect(this.analyser);
    }
    getFrequencyData() {
      return this.analyser.getByteFrequencyData(this.data), this.data;
    }
    getAverageFrequency() {
      let e2 = 0;
      const t2 = this.getFrequencyData();
      for (let n2 = 0; n2 < t2.length; n2++)
        e2 += t2[n2];
      return e2 / t2.length;
    }
  }
  class fh {
    constructor(e2, t2, n2) {
      let r2, i2, s2;
      switch (this.binding = e2, this.valueSize = n2, t2) {
        case "quaternion":
          r2 = this._slerp, i2 = this._slerpAdditive, s2 = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n2), this._workIndex = 5;
          break;
        case "string":
        case "bool":
          r2 = this._select, i2 = this._select, s2 = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n2);
          break;
        default:
          r2 = this._lerp, i2 = this._lerpAdditive, s2 = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n2);
      }
      this._mixBufferRegion = r2, this._mixBufferRegionAdditive = i2, this._setIdentity = s2, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
    }
    accumulate(e2, t2) {
      const n2 = this.buffer, r2 = this.valueSize, i2 = e2 * r2 + r2;
      let s2 = this.cumulativeWeight;
      if (0 === s2) {
        for (let e3 = 0; e3 !== r2; ++e3)
          n2[i2 + e3] = n2[e3];
        s2 = t2;
      } else {
        s2 += t2;
        const e3 = t2 / s2;
        this._mixBufferRegion(n2, i2, 0, e3, r2);
      }
      this.cumulativeWeight = s2;
    }
    accumulateAdditive(e2) {
      const t2 = this.buffer, n2 = this.valueSize, r2 = n2 * this._addIndex;
      0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(t2, r2, 0, e2, n2), this.cumulativeWeightAdditive += e2;
    }
    apply(e2) {
      const t2 = this.valueSize, n2 = this.buffer, r2 = e2 * t2 + t2, i2 = this.cumulativeWeight, s2 = this.cumulativeWeightAdditive, o2 = this.binding;
      if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, i2 < 1) {
        const e3 = t2 * this._origIndex;
        this._mixBufferRegion(n2, r2, e3, 1 - i2, t2);
      }
      s2 > 0 && this._mixBufferRegionAdditive(n2, r2, this._addIndex * t2, 1, t2);
      for (let e3 = t2, i3 = t2 + t2; e3 !== i3; ++e3)
        if (n2[e3] !== n2[e3 + t2]) {
          o2.setValue(n2, r2);
          break;
        }
    }
    saveOriginalState() {
      const e2 = this.binding, t2 = this.buffer, n2 = this.valueSize, r2 = n2 * this._origIndex;
      e2.getValue(t2, r2);
      for (let e3 = n2, i2 = r2; e3 !== i2; ++e3)
        t2[e3] = t2[r2 + e3 % n2];
      this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
    }
    restoreOriginalState() {
      const e2 = 3 * this.valueSize;
      this.binding.setValue(this.buffer, e2);
    }
    _setAdditiveIdentityNumeric() {
      const e2 = this._addIndex * this.valueSize, t2 = e2 + this.valueSize;
      for (let n2 = e2; n2 < t2; n2++)
        this.buffer[n2] = 0;
    }
    _setAdditiveIdentityQuaternion() {
      this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
    }
    _setAdditiveIdentityOther() {
      const e2 = this._origIndex * this.valueSize, t2 = this._addIndex * this.valueSize;
      for (let n2 = 0; n2 < this.valueSize; n2++)
        this.buffer[t2 + n2] = this.buffer[e2 + n2];
    }
    _select(e2, t2, n2, r2, i2) {
      if (r2 >= 0.5)
        for (let r3 = 0; r3 !== i2; ++r3)
          e2[t2 + r3] = e2[n2 + r3];
    }
    _slerp(e2, t2, n2, r2) {
      wr.slerpFlat(e2, t2, e2, t2, e2, n2, r2);
    }
    _slerpAdditive(e2, t2, n2, r2, i2) {
      const s2 = this._workIndex * i2;
      wr.multiplyQuaternionsFlat(e2, s2, e2, t2, e2, n2), wr.slerpFlat(e2, t2, e2, t2, e2, s2, r2);
    }
    _lerp(e2, t2, n2, r2, i2) {
      const s2 = 1 - r2;
      for (let o2 = 0; o2 !== i2; ++o2) {
        const i3 = t2 + o2;
        e2[i3] = e2[i3] * s2 + e2[n2 + o2] * r2;
      }
    }
    _lerpAdditive(e2, t2, n2, r2, i2) {
      for (let s2 = 0; s2 !== i2; ++s2) {
        const i3 = t2 + s2;
        e2[i3] = e2[i3] + e2[n2 + s2] * r2;
      }
    }
  }
  const mh = "\\[\\]\\.:\\/", _h = new RegExp("[" + mh + "]", "g"), gh = "[^" + mh + "]", vh = "[^" + mh.replace("\\.", "") + "]", yh = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", gh) + /(WCOD+)?/.source.replace("WCOD", vh) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", gh) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", gh) + "$"), bh = ["material", "materials", "bones", "map"];
  class wh {
    constructor(e2, t2, n2) {
      this.path = t2, this.parsedPath = n2 || wh.parseTrackName(t2), this.node = wh.findNode(e2, this.parsedPath.nodeName), this.rootNode = e2, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
    }
    static create(e2, t2, n2) {
      return e2 && e2.isAnimationObjectGroup ? new wh.Composite(e2, t2, n2) : new wh(e2, t2, n2);
    }
    static sanitizeNodeName(e2) {
      return e2.replace(/\s/g, "_").replace(_h, "");
    }
    static parseTrackName(e2) {
      const t2 = yh.exec(e2);
      if (null === t2)
        throw new Error("PropertyBinding: Cannot parse trackName: " + e2);
      const n2 = { nodeName: t2[2], objectName: t2[3], objectIndex: t2[4], propertyName: t2[5], propertyIndex: t2[6] }, r2 = n2.nodeName && n2.nodeName.lastIndexOf(".");
      if (void 0 !== r2 && -1 !== r2) {
        const e3 = n2.nodeName.substring(r2 + 1);
        -1 !== bh.indexOf(e3) && (n2.nodeName = n2.nodeName.substring(0, r2), n2.objectName = e3);
      }
      if (null === n2.propertyName || 0 === n2.propertyName.length)
        throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e2);
      return n2;
    }
    static findNode(e2, t2) {
      if (void 0 === t2 || "" === t2 || "." === t2 || -1 === t2 || t2 === e2.name || t2 === e2.uuid)
        return e2;
      if (e2.skeleton) {
        const n2 = e2.skeleton.getBoneByName(t2);
        if (void 0 !== n2)
          return n2;
      }
      if (e2.children) {
        const n2 = function(e3) {
          for (let r3 = 0; r3 < e3.length; r3++) {
            const i2 = e3[r3];
            if (i2.name === t2 || i2.uuid === t2)
              return i2;
            const s2 = n2(i2.children);
            if (s2)
              return s2;
          }
          return null;
        }, r2 = n2(e2.children);
        if (r2)
          return r2;
      }
      return null;
    }
    _getValue_unavailable() {
    }
    _setValue_unavailable() {
    }
    _getValue_direct(e2, t2) {
      e2[t2] = this.targetObject[this.propertyName];
    }
    _getValue_array(e2, t2) {
      const n2 = this.resolvedProperty;
      for (let r2 = 0, i2 = n2.length; r2 !== i2; ++r2)
        e2[t2++] = n2[r2];
    }
    _getValue_arrayElement(e2, t2) {
      e2[t2] = this.resolvedProperty[this.propertyIndex];
    }
    _getValue_toArray(e2, t2) {
      this.resolvedProperty.toArray(e2, t2);
    }
    _setValue_direct(e2, t2) {
      this.targetObject[this.propertyName] = e2[t2];
    }
    _setValue_direct_setNeedsUpdate(e2, t2) {
      this.targetObject[this.propertyName] = e2[t2], this.targetObject.needsUpdate = true;
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e2, t2) {
      this.targetObject[this.propertyName] = e2[t2], this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_array(e2, t2) {
      const n2 = this.resolvedProperty;
      for (let r2 = 0, i2 = n2.length; r2 !== i2; ++r2)
        n2[r2] = e2[t2++];
    }
    _setValue_array_setNeedsUpdate(e2, t2) {
      const n2 = this.resolvedProperty;
      for (let r2 = 0, i2 = n2.length; r2 !== i2; ++r2)
        n2[r2] = e2[t2++];
      this.targetObject.needsUpdate = true;
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e2, t2) {
      const n2 = this.resolvedProperty;
      for (let r2 = 0, i2 = n2.length; r2 !== i2; ++r2)
        n2[r2] = e2[t2++];
      this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_arrayElement(e2, t2) {
      this.resolvedProperty[this.propertyIndex] = e2[t2];
    }
    _setValue_arrayElement_setNeedsUpdate(e2, t2) {
      this.resolvedProperty[this.propertyIndex] = e2[t2], this.targetObject.needsUpdate = true;
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e2, t2) {
      this.resolvedProperty[this.propertyIndex] = e2[t2], this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_fromArray(e2, t2) {
      this.resolvedProperty.fromArray(e2, t2);
    }
    _setValue_fromArray_setNeedsUpdate(e2, t2) {
      this.resolvedProperty.fromArray(e2, t2), this.targetObject.needsUpdate = true;
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e2, t2) {
      this.resolvedProperty.fromArray(e2, t2), this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _getValue_unbound(e2, t2) {
      this.bind(), this.getValue(e2, t2);
    }
    _setValue_unbound(e2, t2) {
      this.bind(), this.setValue(e2, t2);
    }
    bind() {
      let e2 = this.node;
      const t2 = this.parsedPath, n2 = t2.objectName, r2 = t2.propertyName;
      let i2 = t2.propertyIndex;
      if (e2 || (e2 = wh.findNode(this.rootNode, t2.nodeName), this.node = e2), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e2)
        return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      if (n2) {
        let r3 = t2.objectIndex;
        switch (n2) {
          case "materials":
            if (!e2.material)
              return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            if (!e2.material.materials)
              return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            e2 = e2.material.materials;
            break;
          case "bones":
            if (!e2.skeleton)
              return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            e2 = e2.skeleton.bones;
            for (let t3 = 0; t3 < e2.length; t3++)
              if (e2[t3].name === r3) {
                r3 = t3;
                break;
              }
            break;
          case "map":
            if ("map" in e2) {
              e2 = e2.map;
              break;
            }
            if (!e2.material)
              return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            if (!e2.material.map)
              return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            e2 = e2.material.map;
            break;
          default:
            if (void 0 === e2[n2])
              return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            e2 = e2[n2];
        }
        if (void 0 !== r3) {
          if (void 0 === e2[r3])
            return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e2);
          e2 = e2[r3];
        }
      }
      const s2 = e2[r2];
      if (void 0 === s2) {
        const n3 = t2.nodeName;
        return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n3 + "." + r2 + " but it wasn't found.", e2);
      }
      let o2 = this.Versioning.None;
      this.targetObject = e2, void 0 !== e2.needsUpdate ? o2 = this.Versioning.NeedsUpdate : void 0 !== e2.matrixWorldNeedsUpdate && (o2 = this.Versioning.MatrixWorldNeedsUpdate);
      let a2 = this.BindingType.Direct;
      if (void 0 !== i2) {
        if ("morphTargetInfluences" === r2) {
          if (!e2.geometry)
            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          if (!e2.geometry.morphAttributes)
            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          void 0 !== e2.morphTargetDictionary[i2] && (i2 = e2.morphTargetDictionary[i2]);
        }
        a2 = this.BindingType.ArrayElement, this.resolvedProperty = s2, this.propertyIndex = i2;
      } else
        void 0 !== s2.fromArray && void 0 !== s2.toArray ? (a2 = this.BindingType.HasFromToArray, this.resolvedProperty = s2) : Array.isArray(s2) ? (a2 = this.BindingType.EntireArray, this.resolvedProperty = s2) : this.propertyName = r2;
      this.getValue = this.GetterByBindingType[a2], this.setValue = this.SetterByBindingTypeAndVersioning[a2][o2];
    }
    unbind() {
      this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
    }
  }
  wh.Composite = class {
    constructor(e2, t2, n2) {
      const r2 = n2 || wh.parseTrackName(t2);
      this._targetGroup = e2, this._bindings = e2.subscribe_(t2, r2);
    }
    getValue(e2, t2) {
      this.bind();
      const n2 = this._targetGroup.nCachedObjects_, r2 = this._bindings[n2];
      void 0 !== r2 && r2.getValue(e2, t2);
    }
    setValue(e2, t2) {
      const n2 = this._bindings;
      for (let r2 = this._targetGroup.nCachedObjects_, i2 = n2.length; r2 !== i2; ++r2)
        n2[r2].setValue(e2, t2);
    }
    bind() {
      const e2 = this._bindings;
      for (let t2 = this._targetGroup.nCachedObjects_, n2 = e2.length; t2 !== n2; ++t2)
        e2[t2].bind();
    }
    unbind() {
      const e2 = this._bindings;
      for (let t2 = this._targetGroup.nCachedObjects_, n2 = e2.length; t2 !== n2; ++t2)
        e2[t2].unbind();
    }
  }, wh.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, wh.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, wh.prototype.GetterByBindingType = [wh.prototype._getValue_direct, wh.prototype._getValue_array, wh.prototype._getValue_arrayElement, wh.prototype._getValue_toArray], wh.prototype.SetterByBindingTypeAndVersioning = [[wh.prototype._setValue_direct, wh.prototype._setValue_direct_setNeedsUpdate, wh.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [wh.prototype._setValue_array, wh.prototype._setValue_array_setNeedsUpdate, wh.prototype._setValue_array_setMatrixWorldNeedsUpdate], [wh.prototype._setValue_arrayElement, wh.prototype._setValue_arrayElement_setNeedsUpdate, wh.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [wh.prototype._setValue_fromArray, wh.prototype._setValue_fromArray_setNeedsUpdate, wh.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
  class Ah {
    constructor() {
      this.isAnimationObjectGroup = true, this.uuid = On(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
      const e2 = {};
      this._indicesByUUID = e2;
      for (let t3 = 0, n2 = arguments.length; t3 !== n2; ++t3)
        e2[arguments[t3].uuid] = t3;
      this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
      const t2 = this;
      this.stats = { objects: { get total() {
        return t2._objects.length;
      }, get inUse() {
        return this.total - t2.nCachedObjects_;
      } }, get bindingsPerObject() {
        return t2._bindings.length;
      } };
    }
    add() {
      const e2 = this._objects, t2 = this._indicesByUUID, n2 = this._paths, r2 = this._parsedPaths, i2 = this._bindings, s2 = i2.length;
      let o2, a2 = e2.length, l2 = this.nCachedObjects_;
      for (let c2 = 0, u2 = arguments.length; c2 !== u2; ++c2) {
        const u3 = arguments[c2], p2 = u3.uuid;
        let d2 = t2[p2];
        if (void 0 === d2) {
          d2 = a2++, t2[p2] = d2, e2.push(u3);
          for (let e3 = 0, t3 = s2; e3 !== t3; ++e3)
            i2[e3].push(new wh(u3, n2[e3], r2[e3]));
        } else if (d2 < l2) {
          o2 = e2[d2];
          const a3 = --l2, c3 = e2[a3];
          t2[c3.uuid] = d2, e2[d2] = c3, t2[p2] = a3, e2[a3] = u3;
          for (let e3 = 0, t3 = s2; e3 !== t3; ++e3) {
            const t4 = i2[e3], s3 = t4[a3];
            let o3 = t4[d2];
            t4[d2] = s3, void 0 === o3 && (o3 = new wh(u3, n2[e3], r2[e3])), t4[a3] = o3;
          }
        } else
          e2[d2] !== o2 && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
      }
      this.nCachedObjects_ = l2;
    }
    remove() {
      const e2 = this._objects, t2 = this._indicesByUUID, n2 = this._bindings, r2 = n2.length;
      let i2 = this.nCachedObjects_;
      for (let s2 = 0, o2 = arguments.length; s2 !== o2; ++s2) {
        const o3 = arguments[s2], a2 = o3.uuid, l2 = t2[a2];
        if (void 0 !== l2 && l2 >= i2) {
          const s3 = i2++, c2 = e2[s3];
          t2[c2.uuid] = l2, e2[l2] = c2, t2[a2] = s3, e2[s3] = o3;
          for (let e3 = 0, t3 = r2; e3 !== t3; ++e3) {
            const t4 = n2[e3], r3 = t4[s3], i3 = t4[l2];
            t4[l2] = r3, t4[s3] = i3;
          }
        }
      }
      this.nCachedObjects_ = i2;
    }
    uncache() {
      const e2 = this._objects, t2 = this._indicesByUUID, n2 = this._bindings, r2 = n2.length;
      let i2 = this.nCachedObjects_, s2 = e2.length;
      for (let o2 = 0, a2 = arguments.length; o2 !== a2; ++o2) {
        const a3 = arguments[o2].uuid, l2 = t2[a3];
        if (void 0 !== l2)
          if (delete t2[a3], l2 < i2) {
            const o3 = --i2, a4 = e2[o3], c2 = --s2, u2 = e2[c2];
            t2[a4.uuid] = l2, e2[l2] = a4, t2[u2.uuid] = o3, e2[o3] = u2, e2.pop();
            for (let e3 = 0, t3 = r2; e3 !== t3; ++e3) {
              const t4 = n2[e3], r3 = t4[o3], i3 = t4[c2];
              t4[l2] = r3, t4[o3] = i3, t4.pop();
            }
          } else {
            const i3 = --s2, o3 = e2[i3];
            i3 > 0 && (t2[o3.uuid] = l2), e2[l2] = o3, e2.pop();
            for (let e3 = 0, t3 = r2; e3 !== t3; ++e3) {
              const t4 = n2[e3];
              t4[l2] = t4[i3], t4.pop();
            }
          }
      }
      this.nCachedObjects_ = i2;
    }
    subscribe_(e2, t2) {
      const n2 = this._bindingsIndicesByPath;
      let r2 = n2[e2];
      const i2 = this._bindings;
      if (void 0 !== r2)
        return i2[r2];
      const s2 = this._paths, o2 = this._parsedPaths, a2 = this._objects, l2 = a2.length, c2 = this.nCachedObjects_, u2 = new Array(l2);
      r2 = i2.length, n2[e2] = r2, s2.push(e2), o2.push(t2), i2.push(u2);
      for (let n3 = c2, r3 = a2.length; n3 !== r3; ++n3) {
        const r4 = a2[n3];
        u2[n3] = new wh(r4, e2, t2);
      }
      return u2;
    }
    unsubscribe_(e2) {
      const t2 = this._bindingsIndicesByPath, n2 = t2[e2];
      if (void 0 !== n2) {
        const r2 = this._paths, i2 = this._parsedPaths, s2 = this._bindings, o2 = s2.length - 1, a2 = s2[o2];
        t2[e2[o2]] = n2, s2[n2] = a2, s2.pop(), i2[n2] = i2[o2], i2.pop(), r2[n2] = r2[o2], r2.pop();
      }
    }
  }
  class xh {
    constructor(e2, t2, n2 = null, r2 = t2.blendMode) {
      this._mixer = e2, this._clip = t2, this._localRoot = n2, this.blendMode = r2;
      const i2 = t2.tracks, s2 = i2.length, o2 = new Array(s2), a2 = { endingStart: St, endingEnd: St };
      for (let e3 = 0; e3 !== s2; ++e3) {
        const t3 = i2[e3].createInterpolant(null);
        o2[e3] = t3, t3.settings = a2;
      }
      this._interpolantSettings = a2, this._interpolants = o2, this._propertyBindings = new Array(s2), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = wt, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = false, this.enabled = true, this.clampWhenFinished = false, this.zeroSlopeAtStart = true, this.zeroSlopeAtEnd = true;
    }
    play() {
      return this._mixer._activateAction(this), this;
    }
    stop() {
      return this._mixer._deactivateAction(this), this.reset();
    }
    reset() {
      return this.paused = false, this.enabled = true, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
    }
    isRunning() {
      return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
    }
    isScheduled() {
      return this._mixer._isActiveAction(this);
    }
    startAt(e2) {
      return this._startTime = e2, this;
    }
    setLoop(e2, t2) {
      return this.loop = e2, this.repetitions = t2, this;
    }
    setEffectiveWeight(e2) {
      return this.weight = e2, this._effectiveWeight = this.enabled ? e2 : 0, this.stopFading();
    }
    getEffectiveWeight() {
      return this._effectiveWeight;
    }
    fadeIn(e2) {
      return this._scheduleFading(e2, 0, 1);
    }
    fadeOut(e2) {
      return this._scheduleFading(e2, 1, 0);
    }
    crossFadeFrom(e2, t2, n2) {
      if (e2.fadeOut(t2), this.fadeIn(t2), n2) {
        const n3 = this._clip.duration, r2 = e2._clip.duration, i2 = r2 / n3, s2 = n3 / r2;
        e2.warp(1, i2, t2), this.warp(s2, 1, t2);
      }
      return this;
    }
    crossFadeTo(e2, t2, n2) {
      return e2.crossFadeFrom(this, t2, n2);
    }
    stopFading() {
      const e2 = this._weightInterpolant;
      return null !== e2 && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e2)), this;
    }
    setEffectiveTimeScale(e2) {
      return this.timeScale = e2, this._effectiveTimeScale = this.paused ? 0 : e2, this.stopWarping();
    }
    getEffectiveTimeScale() {
      return this._effectiveTimeScale;
    }
    setDuration(e2) {
      return this.timeScale = this._clip.duration / e2, this.stopWarping();
    }
    syncWith(e2) {
      return this.time = e2.time, this.timeScale = e2.timeScale, this.stopWarping();
    }
    halt(e2) {
      return this.warp(this._effectiveTimeScale, 0, e2);
    }
    warp(e2, t2, n2) {
      const r2 = this._mixer, i2 = r2.time, s2 = this.timeScale;
      let o2 = this._timeScaleInterpolant;
      null === o2 && (o2 = r2._lendControlInterpolant(), this._timeScaleInterpolant = o2);
      const a2 = o2.parameterPositions, l2 = o2.sampleValues;
      return a2[0] = i2, a2[1] = i2 + n2, l2[0] = e2 / s2, l2[1] = t2 / s2, this;
    }
    stopWarping() {
      const e2 = this._timeScaleInterpolant;
      return null !== e2 && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e2)), this;
    }
    getMixer() {
      return this._mixer;
    }
    getClip() {
      return this._clip;
    }
    getRoot() {
      return this._localRoot || this._mixer._root;
    }
    _update(e2, t2, n2, r2) {
      if (!this.enabled)
        return void this._updateWeight(e2);
      const i2 = this._startTime;
      if (null !== i2) {
        const r3 = (e2 - i2) * n2;
        r3 < 0 || 0 === n2 ? t2 = 0 : (this._startTime = null, t2 = n2 * r3);
      }
      t2 *= this._updateTimeScale(e2);
      const s2 = this._updateTime(t2), o2 = this._updateWeight(e2);
      if (o2 > 0) {
        const e3 = this._interpolants, t3 = this._propertyBindings;
        if (this.blendMode === It)
          for (let n3 = 0, r3 = e3.length; n3 !== r3; ++n3)
            e3[n3].evaluate(s2), t3[n3].accumulateAdditive(o2);
        else
          for (let n3 = 0, i3 = e3.length; n3 !== i3; ++n3)
            e3[n3].evaluate(s2), t3[n3].accumulate(r2, o2);
      }
    }
    _updateWeight(e2) {
      let t2 = 0;
      if (this.enabled) {
        t2 = this.weight;
        const n2 = this._weightInterpolant;
        if (null !== n2) {
          const r2 = n2.evaluate(e2)[0];
          t2 *= r2, e2 > n2.parameterPositions[1] && (this.stopFading(), 0 === r2 && (this.enabled = false));
        }
      }
      return this._effectiveWeight = t2, t2;
    }
    _updateTimeScale(e2) {
      let t2 = 0;
      if (!this.paused) {
        t2 = this.timeScale;
        const n2 = this._timeScaleInterpolant;
        null !== n2 && (t2 *= n2.evaluate(e2)[0], e2 > n2.parameterPositions[1] && (this.stopWarping(), 0 === t2 ? this.paused = true : this.timeScale = t2));
      }
      return this._effectiveTimeScale = t2, t2;
    }
    _updateTime(e2) {
      const t2 = this._clip.duration, n2 = this.loop;
      let r2 = this.time + e2, i2 = this._loopCount;
      const s2 = n2 === At;
      if (0 === e2)
        return -1 === i2 ? r2 : s2 && 1 == (1 & i2) ? t2 - r2 : r2;
      if (n2 === bt) {
        -1 === i2 && (this._loopCount = 0, this._setEndings(true, true, false));
        e: {
          if (r2 >= t2)
            r2 = t2;
          else {
            if (!(r2 < 0)) {
              this.time = r2;
              break e;
            }
            r2 = 0;
          }
          this.clampWhenFinished ? this.paused = true : this.enabled = false, this.time = r2, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e2 < 0 ? -1 : 1 });
        }
      } else {
        if (-1 === i2 && (e2 >= 0 ? (i2 = 0, this._setEndings(true, 0 === this.repetitions, s2)) : this._setEndings(0 === this.repetitions, true, s2)), r2 >= t2 || r2 < 0) {
          const n3 = Math.floor(r2 / t2);
          r2 -= t2 * n3, i2 += Math.abs(n3);
          const o2 = this.repetitions - i2;
          if (o2 <= 0)
            this.clampWhenFinished ? this.paused = true : this.enabled = false, r2 = e2 > 0 ? t2 : 0, this.time = r2, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e2 > 0 ? 1 : -1 });
          else {
            if (1 === o2) {
              const t3 = e2 < 0;
              this._setEndings(t3, !t3, s2);
            } else
              this._setEndings(false, false, s2);
            this._loopCount = i2, this.time = r2, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: n3 });
          }
        } else
          this.time = r2;
        if (s2 && 1 == (1 & i2))
          return t2 - r2;
      }
      return r2;
    }
    _setEndings(e2, t2, n2) {
      const r2 = this._interpolantSettings;
      n2 ? (r2.endingStart = Mt, r2.endingEnd = Mt) : (r2.endingStart = e2 ? this.zeroSlopeAtStart ? Mt : St : Tt, r2.endingEnd = t2 ? this.zeroSlopeAtEnd ? Mt : St : Tt);
    }
    _scheduleFading(e2, t2, n2) {
      const r2 = this._mixer, i2 = r2.time;
      let s2 = this._weightInterpolant;
      null === s2 && (s2 = r2._lendControlInterpolant(), this._weightInterpolant = s2);
      const o2 = s2.parameterPositions, a2 = s2.sampleValues;
      return o2[0] = i2, a2[0] = t2, o2[1] = i2 + e2, a2[1] = n2, this;
    }
  }
  const Eh = new Float32Array(1);
  class Ch extends In {
    constructor(e2) {
      super(), this._root = e2, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
    }
    _bindAction(e2, t2) {
      const n2 = e2._localRoot || this._root, r2 = e2._clip.tracks, i2 = r2.length, s2 = e2._propertyBindings, o2 = e2._interpolants, a2 = n2.uuid, l2 = this._bindingsByRootAndName;
      let c2 = l2[a2];
      void 0 === c2 && (c2 = {}, l2[a2] = c2);
      for (let e3 = 0; e3 !== i2; ++e3) {
        const i3 = r2[e3], l3 = i3.name;
        let u2 = c2[l3];
        if (void 0 !== u2)
          ++u2.referenceCount, s2[e3] = u2;
        else {
          if (u2 = s2[e3], void 0 !== u2) {
            null === u2._cacheIndex && (++u2.referenceCount, this._addInactiveBinding(u2, a2, l3));
            continue;
          }
          const r3 = t2 && t2._propertyBindings[e3].binding.parsedPath;
          u2 = new fh(wh.create(n2, l3, r3), i3.ValueTypeName, i3.getValueSize()), ++u2.referenceCount, this._addInactiveBinding(u2, a2, l3), s2[e3] = u2;
        }
        o2[e3].resultBuffer = u2.buffer;
      }
    }
    _activateAction(e2) {
      if (!this._isActiveAction(e2)) {
        if (null === e2._cacheIndex) {
          const t3 = (e2._localRoot || this._root).uuid, n2 = e2._clip.uuid, r2 = this._actionsByClip[n2];
          this._bindAction(e2, r2 && r2.knownActions[0]), this._addInactiveAction(e2, n2, t3);
        }
        const t2 = e2._propertyBindings;
        for (let e3 = 0, n2 = t2.length; e3 !== n2; ++e3) {
          const n3 = t2[e3];
          0 == n3.useCount++ && (this._lendBinding(n3), n3.saveOriginalState());
        }
        this._lendAction(e2);
      }
    }
    _deactivateAction(e2) {
      if (this._isActiveAction(e2)) {
        const t2 = e2._propertyBindings;
        for (let e3 = 0, n2 = t2.length; e3 !== n2; ++e3) {
          const n3 = t2[e3];
          0 == --n3.useCount && (n3.restoreOriginalState(), this._takeBackBinding(n3));
        }
        this._takeBackAction(e2);
      }
    }
    _initMemoryManager() {
      this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
      const e2 = this;
      this.stats = { actions: { get total() {
        return e2._actions.length;
      }, get inUse() {
        return e2._nActiveActions;
      } }, bindings: { get total() {
        return e2._bindings.length;
      }, get inUse() {
        return e2._nActiveBindings;
      } }, controlInterpolants: { get total() {
        return e2._controlInterpolants.length;
      }, get inUse() {
        return e2._nActiveControlInterpolants;
      } } };
    }
    _isActiveAction(e2) {
      const t2 = e2._cacheIndex;
      return null !== t2 && t2 < this._nActiveActions;
    }
    _addInactiveAction(e2, t2, n2) {
      const r2 = this._actions, i2 = this._actionsByClip;
      let s2 = i2[t2];
      if (void 0 === s2)
        s2 = { knownActions: [e2], actionByRoot: {} }, e2._byClipCacheIndex = 0, i2[t2] = s2;
      else {
        const t3 = s2.knownActions;
        e2._byClipCacheIndex = t3.length, t3.push(e2);
      }
      e2._cacheIndex = r2.length, r2.push(e2), s2.actionByRoot[n2] = e2;
    }
    _removeInactiveAction(e2) {
      const t2 = this._actions, n2 = t2[t2.length - 1], r2 = e2._cacheIndex;
      n2._cacheIndex = r2, t2[r2] = n2, t2.pop(), e2._cacheIndex = null;
      const i2 = e2._clip.uuid, s2 = this._actionsByClip, o2 = s2[i2], a2 = o2.knownActions, l2 = a2[a2.length - 1], c2 = e2._byClipCacheIndex;
      l2._byClipCacheIndex = c2, a2[c2] = l2, a2.pop(), e2._byClipCacheIndex = null, delete o2.actionByRoot[(e2._localRoot || this._root).uuid], 0 === a2.length && delete s2[i2], this._removeInactiveBindingsForAction(e2);
    }
    _removeInactiveBindingsForAction(e2) {
      const t2 = e2._propertyBindings;
      for (let e3 = 0, n2 = t2.length; e3 !== n2; ++e3) {
        const n3 = t2[e3];
        0 == --n3.referenceCount && this._removeInactiveBinding(n3);
      }
    }
    _lendAction(e2) {
      const t2 = this._actions, n2 = e2._cacheIndex, r2 = this._nActiveActions++, i2 = t2[r2];
      e2._cacheIndex = r2, t2[r2] = e2, i2._cacheIndex = n2, t2[n2] = i2;
    }
    _takeBackAction(e2) {
      const t2 = this._actions, n2 = e2._cacheIndex, r2 = --this._nActiveActions, i2 = t2[r2];
      e2._cacheIndex = r2, t2[r2] = e2, i2._cacheIndex = n2, t2[n2] = i2;
    }
    _addInactiveBinding(e2, t2, n2) {
      const r2 = this._bindingsByRootAndName, i2 = this._bindings;
      let s2 = r2[t2];
      void 0 === s2 && (s2 = {}, r2[t2] = s2), s2[n2] = e2, e2._cacheIndex = i2.length, i2.push(e2);
    }
    _removeInactiveBinding(e2) {
      const t2 = this._bindings, n2 = e2.binding, r2 = n2.rootNode.uuid, i2 = n2.path, s2 = this._bindingsByRootAndName, o2 = s2[r2], a2 = t2[t2.length - 1], l2 = e2._cacheIndex;
      a2._cacheIndex = l2, t2[l2] = a2, t2.pop(), delete o2[i2], 0 === Object.keys(o2).length && delete s2[r2];
    }
    _lendBinding(e2) {
      const t2 = this._bindings, n2 = e2._cacheIndex, r2 = this._nActiveBindings++, i2 = t2[r2];
      e2._cacheIndex = r2, t2[r2] = e2, i2._cacheIndex = n2, t2[n2] = i2;
    }
    _takeBackBinding(e2) {
      const t2 = this._bindings, n2 = e2._cacheIndex, r2 = --this._nActiveBindings, i2 = t2[r2];
      e2._cacheIndex = r2, t2[r2] = e2, i2._cacheIndex = n2, t2[n2] = i2;
    }
    _lendControlInterpolant() {
      const e2 = this._controlInterpolants, t2 = this._nActiveControlInterpolants++;
      let n2 = e2[t2];
      return void 0 === n2 && (n2 = new Wp(new Float32Array(2), new Float32Array(2), 1, Eh), n2.__cacheIndex = t2, e2[t2] = n2), n2;
    }
    _takeBackControlInterpolant(e2) {
      const t2 = this._controlInterpolants, n2 = e2.__cacheIndex, r2 = --this._nActiveControlInterpolants, i2 = t2[r2];
      e2.__cacheIndex = r2, t2[r2] = e2, i2.__cacheIndex = n2, t2[n2] = i2;
    }
    clipAction(e2, t2, n2) {
      const r2 = t2 || this._root, i2 = r2.uuid;
      let s2 = "string" == typeof e2 ? nd.findByName(r2, e2) : e2;
      const o2 = null !== s2 ? s2.uuid : e2, a2 = this._actionsByClip[o2];
      let l2 = null;
      if (void 0 === n2 && (n2 = null !== s2 ? s2.blendMode : Pt), void 0 !== a2) {
        const e3 = a2.actionByRoot[i2];
        if (void 0 !== e3 && e3.blendMode === n2)
          return e3;
        l2 = a2.knownActions[0], null === s2 && (s2 = l2._clip);
      }
      if (null === s2)
        return null;
      const c2 = new xh(this, s2, t2, n2);
      return this._bindAction(c2, l2), this._addInactiveAction(c2, o2, i2), c2;
    }
    existingAction(e2, t2) {
      const n2 = t2 || this._root, r2 = n2.uuid, i2 = "string" == typeof e2 ? nd.findByName(n2, e2) : e2, s2 = i2 ? i2.uuid : e2, o2 = this._actionsByClip[s2];
      return void 0 !== o2 && o2.actionByRoot[r2] || null;
    }
    stopAllAction() {
      const e2 = this._actions;
      for (let t2 = this._nActiveActions - 1; t2 >= 0; --t2)
        e2[t2].stop();
      return this;
    }
    update(e2) {
      e2 *= this.timeScale;
      const t2 = this._actions, n2 = this._nActiveActions, r2 = this.time += e2, i2 = Math.sign(e2), s2 = this._accuIndex ^= 1;
      for (let o3 = 0; o3 !== n2; ++o3)
        t2[o3]._update(r2, e2, i2, s2);
      const o2 = this._bindings, a2 = this._nActiveBindings;
      for (let e3 = 0; e3 !== a2; ++e3)
        o2[e3].apply(s2);
      return this;
    }
    setTime(e2) {
      this.time = 0;
      for (let e3 = 0; e3 < this._actions.length; e3++)
        this._actions[e3].time = 0;
      return this.update(e2);
    }
    getRoot() {
      return this._root;
    }
    uncacheClip(e2) {
      const t2 = this._actions, n2 = e2.uuid, r2 = this._actionsByClip, i2 = r2[n2];
      if (void 0 !== i2) {
        const e3 = i2.knownActions;
        for (let n3 = 0, r3 = e3.length; n3 !== r3; ++n3) {
          const r4 = e3[n3];
          this._deactivateAction(r4);
          const i3 = r4._cacheIndex, s2 = t2[t2.length - 1];
          r4._cacheIndex = null, r4._byClipCacheIndex = null, s2._cacheIndex = i3, t2[i3] = s2, t2.pop(), this._removeInactiveBindingsForAction(r4);
        }
        delete r2[n2];
      }
    }
    uncacheRoot(e2) {
      const t2 = e2.uuid, n2 = this._actionsByClip;
      for (const e3 in n2) {
        const r3 = n2[e3].actionByRoot[t2];
        void 0 !== r3 && (this._deactivateAction(r3), this._removeInactiveAction(r3));
      }
      const r2 = this._bindingsByRootAndName[t2];
      if (void 0 !== r2)
        for (const e3 in r2) {
          const t3 = r2[e3];
          t3.restoreOriginalState(), this._removeInactiveBinding(t3);
        }
    }
    uncacheAction(e2, t2) {
      const n2 = this.existingAction(e2, t2);
      null !== n2 && (this._deactivateAction(n2), this._removeInactiveAction(n2));
    }
  }
  class Sh {
    constructor(e2) {
      this.value = e2;
    }
    clone() {
      return new Sh(void 0 === this.value.clone ? this.value : this.value.clone());
    }
  }
  let Mh = 0;
  class Th extends In {
    constructor() {
      super(), this.isUniformsGroup = true, Object.defineProperty(this, "id", { value: Mh++ }), this.name = "", this.usage = _n, this.uniforms = [];
    }
    add(e2) {
      return this.uniforms.push(e2), this;
    }
    remove(e2) {
      const t2 = this.uniforms.indexOf(e2);
      return -1 !== t2 && this.uniforms.splice(t2, 1), this;
    }
    setName(e2) {
      return this.name = e2, this;
    }
    setUsage(e2) {
      return this.usage = e2, this;
    }
    dispose() {
      return this.dispatchEvent({ type: "dispose" }), this;
    }
    copy(e2) {
      this.name = e2.name, this.usage = e2.usage;
      const t2 = e2.uniforms;
      this.uniforms.length = 0;
      for (let e3 = 0, n2 = t2.length; e3 < n2; e3++)
        this.uniforms.push(t2[e3].clone());
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class Ph extends Hl {
    constructor(e2, t2, n2 = 1) {
      super(e2, t2), this.isInstancedInterleavedBuffer = true, this.meshPerAttribute = n2;
    }
    copy(e2) {
      return super.copy(e2), this.meshPerAttribute = e2.meshPerAttribute, this;
    }
    clone(e2) {
      const t2 = super.clone(e2);
      return t2.meshPerAttribute = this.meshPerAttribute, t2;
    }
    toJSON(e2) {
      const t2 = super.toJSON(e2);
      return t2.isInstancedInterleavedBuffer = true, t2.meshPerAttribute = this.meshPerAttribute, t2;
    }
  }
  class Ih {
    constructor(e2, t2, n2, r2, i2) {
      this.isGLBufferAttribute = true, this.name = "", this.buffer = e2, this.type = t2, this.itemSize = n2, this.elementSize = r2, this.count = i2, this.version = 0;
    }
    set needsUpdate(e2) {
      true === e2 && this.version++;
    }
    setBuffer(e2) {
      return this.buffer = e2, this;
    }
    setType(e2, t2) {
      return this.type = e2, this.elementSize = t2, this;
    }
    setItemSize(e2) {
      return this.itemSize = e2, this;
    }
    setCount(e2) {
      return this.count = e2, this;
    }
  }
  class Rh {
    constructor(e2, t2, n2 = 0, r2 = 1 / 0) {
      this.ray = new Jr(e2, t2), this.near = n2, this.far = r2, this.camera = null, this.layers = new ci(), this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} };
    }
    set(e2, t2) {
      this.ray.set(e2, t2);
    }
    setFromCamera(e2, t2) {
      t2.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t2.matrixWorld), this.ray.direction.set(e2.x, e2.y, 0.5).unproject(t2).sub(this.ray.origin).normalize(), this.camera = t2) : t2.isOrthographicCamera ? (this.ray.origin.set(e2.x, e2.y, (t2.near + t2.far) / (t2.near - t2.far)).unproject(t2), this.ray.direction.set(0, 0, -1).transformDirection(t2.matrixWorld), this.camera = t2) : console.error("THREE.Raycaster: Unsupported camera type: " + t2.type);
    }
    intersectObject(e2, t2 = true, n2 = []) {
      return Dh(e2, this, n2, t2), n2.sort(kh), n2;
    }
    intersectObjects(e2, t2 = true, n2 = []) {
      for (let r2 = 0, i2 = e2.length; r2 < i2; r2++)
        Dh(e2[r2], this, n2, t2);
      return n2.sort(kh), n2;
    }
  }
  function kh(e2, t2) {
    return e2.distance - t2.distance;
  }
  function Dh(e2, t2, n2, r2) {
    if (e2.layers.test(t2.layers) && e2.raycast(t2, n2), true === r2) {
      const r3 = e2.children;
      for (let e3 = 0, i2 = r3.length; e3 < i2; e3++)
        Dh(r3[e3], t2, n2, true);
    }
  }
  class Bh {
    constructor(e2 = 1, t2 = 0, n2 = 0) {
      return this.radius = e2, this.phi = t2, this.theta = n2, this;
    }
    set(e2, t2, n2) {
      return this.radius = e2, this.phi = t2, this.theta = n2, this;
    }
    copy(e2) {
      return this.radius = e2.radius, this.phi = e2.phi, this.theta = e2.theta, this;
    }
    makeSafe() {
      const e2 = 1e-6;
      return this.phi = Math.max(e2, Math.min(Math.PI - e2, this.phi)), this;
    }
    setFromVector3(e2) {
      return this.setFromCartesianCoords(e2.x, e2.y, e2.z);
    }
    setFromCartesianCoords(e2, t2, n2) {
      return this.radius = Math.sqrt(e2 * e2 + t2 * t2 + n2 * n2), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e2, n2), this.phi = Math.acos(Ln(t2 / this.radius, -1, 1))), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class Oh {
    constructor(e2 = 1, t2 = 0, n2 = 0) {
      return this.radius = e2, this.theta = t2, this.y = n2, this;
    }
    set(e2, t2, n2) {
      return this.radius = e2, this.theta = t2, this.y = n2, this;
    }
    copy(e2) {
      return this.radius = e2.radius, this.theta = e2.theta, this.y = e2.y, this;
    }
    setFromVector3(e2) {
      return this.setFromCartesianCoords(e2.x, e2.y, e2.z);
    }
    setFromCartesianCoords(e2, t2, n2) {
      return this.radius = Math.sqrt(e2 * e2 + n2 * n2), this.theta = Math.atan2(e2, n2), this.y = t2, this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const Lh = new Qn();
  class Uh {
    constructor(e2 = new Qn(1 / 0, 1 / 0), t2 = new Qn(-1 / 0, -1 / 0)) {
      this.isBox2 = true, this.min = e2, this.max = t2;
    }
    set(e2, t2) {
      return this.min.copy(e2), this.max.copy(t2), this;
    }
    setFromPoints(e2) {
      this.makeEmpty();
      for (let t2 = 0, n2 = e2.length; t2 < n2; t2++)
        this.expandByPoint(e2[t2]);
      return this;
    }
    setFromCenterAndSize(e2, t2) {
      const n2 = Lh.copy(t2).multiplyScalar(0.5);
      return this.min.copy(e2).sub(n2), this.max.copy(e2).add(n2), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e2) {
      return this.min.copy(e2.min), this.max.copy(e2.max), this;
    }
    makeEmpty() {
      return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y;
    }
    getCenter(e2) {
      return this.isEmpty() ? e2.set(0, 0) : e2.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(e2) {
      return this.isEmpty() ? e2.set(0, 0) : e2.subVectors(this.max, this.min);
    }
    expandByPoint(e2) {
      return this.min.min(e2), this.max.max(e2), this;
    }
    expandByVector(e2) {
      return this.min.sub(e2), this.max.add(e2), this;
    }
    expandByScalar(e2) {
      return this.min.addScalar(-e2), this.max.addScalar(e2), this;
    }
    containsPoint(e2) {
      return !(e2.x < this.min.x || e2.x > this.max.x || e2.y < this.min.y || e2.y > this.max.y);
    }
    containsBox(e2) {
      return this.min.x <= e2.min.x && e2.max.x <= this.max.x && this.min.y <= e2.min.y && e2.max.y <= this.max.y;
    }
    getParameter(e2, t2) {
      return t2.set((e2.x - this.min.x) / (this.max.x - this.min.x), (e2.y - this.min.y) / (this.max.y - this.min.y));
    }
    intersectsBox(e2) {
      return !(e2.max.x < this.min.x || e2.min.x > this.max.x || e2.max.y < this.min.y || e2.min.y > this.max.y);
    }
    clampPoint(e2, t2) {
      return t2.copy(e2).clamp(this.min, this.max);
    }
    distanceToPoint(e2) {
      return this.clampPoint(e2, Lh).distanceTo(e2);
    }
    intersect(e2) {
      return this.min.max(e2.min), this.max.min(e2.max), this.isEmpty() && this.makeEmpty(), this;
    }
    union(e2) {
      return this.min.min(e2.min), this.max.max(e2.max), this;
    }
    translate(e2) {
      return this.min.add(e2), this.max.add(e2), this;
    }
    equals(e2) {
      return e2.min.equals(this.min) && e2.max.equals(this.max);
    }
  }
  const Fh = new Ar(), Nh = new Ar();
  class jh {
    constructor(e2 = new Ar(), t2 = new Ar()) {
      this.start = e2, this.end = t2;
    }
    set(e2, t2) {
      return this.start.copy(e2), this.end.copy(t2), this;
    }
    copy(e2) {
      return this.start.copy(e2.start), this.end.copy(e2.end), this;
    }
    getCenter(e2) {
      return e2.addVectors(this.start, this.end).multiplyScalar(0.5);
    }
    delta(e2) {
      return e2.subVectors(this.end, this.start);
    }
    distanceSq() {
      return this.start.distanceToSquared(this.end);
    }
    distance() {
      return this.start.distanceTo(this.end);
    }
    at(e2, t2) {
      return this.delta(t2).multiplyScalar(e2).add(this.start);
    }
    closestPointToPointParameter(e2, t2) {
      Fh.subVectors(e2, this.start), Nh.subVectors(this.end, this.start);
      const n2 = Nh.dot(Nh);
      let r2 = Nh.dot(Fh) / n2;
      return t2 && (r2 = Ln(r2, 0, 1)), r2;
    }
    closestPointToPoint(e2, t2, n2) {
      const r2 = this.closestPointToPointParameter(e2, t2);
      return this.delta(n2).multiplyScalar(r2).add(this.start);
    }
    applyMatrix4(e2) {
      return this.start.applyMatrix4(e2), this.end.applyMatrix4(e2), this;
    }
    equals(e2) {
      return e2.start.equals(this.start) && e2.end.equals(this.end);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const zh = new Ar();
  class Gh extends xi {
    constructor(e2, t2) {
      super(), this.light = e2, this.matrix = e2.matrixWorld, this.matrixAutoUpdate = false, this.color = t2, this.type = "SpotLightHelper";
      const n2 = new gs(), r2 = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
      for (let e3 = 0, t3 = 1, n3 = 32; e3 < n3; e3++, t3++) {
        const i3 = e3 / n3 * Math.PI * 2, s2 = t3 / n3 * Math.PI * 2;
        r2.push(Math.cos(i3), Math.sin(i3), 1, Math.cos(s2), Math.sin(s2), 1);
      }
      n2.setAttribute("position", new ls(r2, 3));
      const i2 = new Lc({ fog: false, toneMapped: false });
      this.cone = new Qc(n2, i2), this.add(this.cone), this.update();
    }
    dispose() {
      this.cone.geometry.dispose(), this.cone.material.dispose();
    }
    update() {
      this.light.updateWorldMatrix(true, false), this.light.target.updateWorldMatrix(true, false);
      const e2 = this.light.distance ? this.light.distance : 1e3, t2 = e2 * Math.tan(this.light.angle);
      this.cone.scale.set(t2, t2, e2), zh.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(zh), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
    }
  }
  const Vh = new Ar(), Hh = new Zr(), Qh = new Zr();
  class Wh extends Qc {
    constructor(e2) {
      const t2 = qh(e2), n2 = new gs(), r2 = [], i2 = [], s2 = new Vi(0, 0, 1), o2 = new Vi(0, 1, 0);
      for (let e3 = 0; e3 < t2.length; e3++) {
        const n3 = t2[e3];
        n3.parent && n3.parent.isBone && (r2.push(0, 0, 0), r2.push(0, 0, 0), i2.push(s2.r, s2.g, s2.b), i2.push(o2.r, o2.g, o2.b));
      }
      n2.setAttribute("position", new ls(r2, 3)), n2.setAttribute("color", new ls(i2, 3)), super(n2, new Lc({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true })), this.isSkeletonHelper = true, this.type = "SkeletonHelper", this.root = e2, this.bones = t2, this.matrix = e2.matrixWorld, this.matrixAutoUpdate = false;
    }
    updateMatrixWorld(e2) {
      const t2 = this.bones, n2 = this.geometry, r2 = n2.getAttribute("position");
      Qh.copy(this.root.matrixWorld).invert();
      for (let e3 = 0, n3 = 0; e3 < t2.length; e3++) {
        const i2 = t2[e3];
        i2.parent && i2.parent.isBone && (Hh.multiplyMatrices(Qh, i2.matrixWorld), Vh.setFromMatrixPosition(Hh), r2.setXYZ(n3, Vh.x, Vh.y, Vh.z), Hh.multiplyMatrices(Qh, i2.parent.matrixWorld), Vh.setFromMatrixPosition(Hh), r2.setXYZ(n3 + 1, Vh.x, Vh.y, Vh.z), n3 += 2);
      }
      n2.getAttribute("position").needsUpdate = true, super.updateMatrixWorld(e2);
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }
  function qh(e2) {
    const t2 = [];
    true === e2.isBone && t2.push(e2);
    for (let n2 = 0; n2 < e2.children.length; n2++)
      t2.push.apply(t2, qh(e2.children[n2]));
    return t2;
  }
  class Xh extends Os {
    constructor(e2, t2, n2) {
      super(new yp(t2, 4, 2), new Qi({ wireframe: true, fog: false, toneMapped: false })), this.light = e2, this.color = n2, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = false, this.update();
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
    update() {
      this.light.updateWorldMatrix(true, false), void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
    }
  }
  const Yh = new Ar(), Kh = new Vi(), Jh = new Vi();
  class Zh extends xi {
    constructor(e2, t2, n2) {
      super(), this.light = e2, this.matrix = e2.matrixWorld, this.matrixAutoUpdate = false, this.color = n2, this.type = "HemisphereLightHelper";
      const r2 = new _p(t2);
      r2.rotateY(0.5 * Math.PI), this.material = new Qi({ wireframe: true, fog: false, toneMapped: false }), void 0 === this.color && (this.material.vertexColors = true);
      const i2 = r2.getAttribute("position"), s2 = new Float32Array(3 * i2.count);
      r2.setAttribute("color", new $i(s2, 3)), this.add(new Os(r2, this.material)), this.update();
    }
    dispose() {
      this.children[0].geometry.dispose(), this.children[0].material.dispose();
    }
    update() {
      const e2 = this.children[0];
      if (void 0 !== this.color)
        this.material.color.set(this.color);
      else {
        const t2 = e2.geometry.getAttribute("color");
        Kh.copy(this.light.color), Jh.copy(this.light.groundColor);
        for (let e3 = 0, n2 = t2.count; e3 < n2; e3++) {
          const r2 = e3 < n2 / 2 ? Kh : Jh;
          t2.setXYZ(e3, r2.r, r2.g, r2.b);
        }
        t2.needsUpdate = true;
      }
      this.light.updateWorldMatrix(true, false), e2.lookAt(Yh.setFromMatrixPosition(this.light.matrixWorld).negate());
    }
  }
  class $h extends Qc {
    constructor(e2 = 10, t2 = 10, n2 = 4473924, r2 = 8947848) {
      n2 = new Vi(n2), r2 = new Vi(r2);
      const i2 = t2 / 2, s2 = e2 / t2, o2 = e2 / 2, a2 = [], l2 = [];
      for (let e3 = 0, c3 = 0, u2 = -o2; e3 <= t2; e3++, u2 += s2) {
        a2.push(-o2, 0, u2, o2, 0, u2), a2.push(u2, 0, -o2, u2, 0, o2);
        const t3 = e3 === i2 ? n2 : r2;
        t3.toArray(l2, c3), c3 += 3, t3.toArray(l2, c3), c3 += 3, t3.toArray(l2, c3), c3 += 3, t3.toArray(l2, c3), c3 += 3;
      }
      const c2 = new gs();
      c2.setAttribute("position", new ls(a2, 3)), c2.setAttribute("color", new ls(l2, 3)), super(c2, new Lc({ vertexColors: true, toneMapped: false })), this.type = "GridHelper";
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }
  class ef extends Qc {
    constructor(e2 = 10, t2 = 16, n2 = 8, r2 = 64, i2 = 4473924, s2 = 8947848) {
      i2 = new Vi(i2), s2 = new Vi(s2);
      const o2 = [], a2 = [];
      if (t2 > 1)
        for (let n3 = 0; n3 < t2; n3++) {
          const r3 = n3 / t2 * (2 * Math.PI), l3 = Math.sin(r3) * e2, c2 = Math.cos(r3) * e2;
          o2.push(0, 0, 0), o2.push(l3, 0, c2);
          const u2 = 1 & n3 ? i2 : s2;
          a2.push(u2.r, u2.g, u2.b), a2.push(u2.r, u2.g, u2.b);
        }
      for (let t3 = 0; t3 < n2; t3++) {
        const l3 = 1 & t3 ? i2 : s2, c2 = e2 - e2 / n2 * t3;
        for (let e3 = 0; e3 < r2; e3++) {
          let t4 = e3 / r2 * (2 * Math.PI), n3 = Math.sin(t4) * c2, i3 = Math.cos(t4) * c2;
          o2.push(n3, 0, i3), a2.push(l3.r, l3.g, l3.b), t4 = (e3 + 1) / r2 * (2 * Math.PI), n3 = Math.sin(t4) * c2, i3 = Math.cos(t4) * c2, o2.push(n3, 0, i3), a2.push(l3.r, l3.g, l3.b);
        }
      }
      const l2 = new gs();
      l2.setAttribute("position", new ls(o2, 3)), l2.setAttribute("color", new ls(a2, 3)), super(l2, new Lc({ vertexColors: true, toneMapped: false })), this.type = "PolarGridHelper";
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }
  const tf = new Ar(), nf = new Ar(), rf = new Ar();
  class sf extends xi {
    constructor(e2, t2, n2) {
      super(), this.light = e2, this.matrix = e2.matrixWorld, this.matrixAutoUpdate = false, this.color = n2, this.type = "DirectionalLightHelper", void 0 === t2 && (t2 = 1);
      let r2 = new gs();
      r2.setAttribute("position", new ls([-t2, t2, 0, t2, t2, 0, t2, -t2, 0, -t2, -t2, 0, -t2, t2, 0], 3));
      const i2 = new Lc({ fog: false, toneMapped: false });
      this.lightPlane = new Gc(r2, i2), this.add(this.lightPlane), r2 = new gs(), r2.setAttribute("position", new ls([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Gc(r2, i2), this.add(this.targetLine), this.update();
    }
    dispose() {
      this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
    }
    update() {
      this.light.updateWorldMatrix(true, false), this.light.target.updateWorldMatrix(true, false), tf.setFromMatrixPosition(this.light.matrixWorld), nf.setFromMatrixPosition(this.light.target.matrixWorld), rf.subVectors(nf, tf), this.lightPlane.lookAt(nf), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(nf), this.targetLine.scale.z = rf.length();
    }
  }
  const of = new Ar(), af = new Vs();
  class lf extends Qc {
    constructor(e2) {
      const t2 = new gs(), n2 = new Lc({ color: 16777215, vertexColors: true, toneMapped: false }), r2 = [], i2 = [], s2 = {};
      function o2(e3, t3) {
        a2(e3), a2(t3);
      }
      function a2(e3) {
        r2.push(0, 0, 0), i2.push(0, 0, 0), void 0 === s2[e3] && (s2[e3] = []), s2[e3].push(r2.length / 3 - 1);
      }
      o2("n1", "n2"), o2("n2", "n4"), o2("n4", "n3"), o2("n3", "n1"), o2("f1", "f2"), o2("f2", "f4"), o2("f4", "f3"), o2("f3", "f1"), o2("n1", "f1"), o2("n2", "f2"), o2("n3", "f3"), o2("n4", "f4"), o2("p", "n1"), o2("p", "n2"), o2("p", "n3"), o2("p", "n4"), o2("u1", "u2"), o2("u2", "u3"), o2("u3", "u1"), o2("c", "t"), o2("p", "c"), o2("cn1", "cn2"), o2("cn3", "cn4"), o2("cf1", "cf2"), o2("cf3", "cf4"), t2.setAttribute("position", new ls(r2, 3)), t2.setAttribute("color", new ls(i2, 3)), super(t2, n2), this.type = "CameraHelper", this.camera = e2, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e2.matrixWorld, this.matrixAutoUpdate = false, this.pointMap = s2, this.update();
      const l2 = new Vi(16755200), c2 = new Vi(16711680), u2 = new Vi(43775), p2 = new Vi(16777215), d2 = new Vi(3355443);
      this.setColors(l2, c2, u2, p2, d2);
    }
    setColors(e2, t2, n2, r2, i2) {
      const s2 = this.geometry.getAttribute("color");
      s2.setXYZ(0, e2.r, e2.g, e2.b), s2.setXYZ(1, e2.r, e2.g, e2.b), s2.setXYZ(2, e2.r, e2.g, e2.b), s2.setXYZ(3, e2.r, e2.g, e2.b), s2.setXYZ(4, e2.r, e2.g, e2.b), s2.setXYZ(5, e2.r, e2.g, e2.b), s2.setXYZ(6, e2.r, e2.g, e2.b), s2.setXYZ(7, e2.r, e2.g, e2.b), s2.setXYZ(8, e2.r, e2.g, e2.b), s2.setXYZ(9, e2.r, e2.g, e2.b), s2.setXYZ(10, e2.r, e2.g, e2.b), s2.setXYZ(11, e2.r, e2.g, e2.b), s2.setXYZ(12, e2.r, e2.g, e2.b), s2.setXYZ(13, e2.r, e2.g, e2.b), s2.setXYZ(14, e2.r, e2.g, e2.b), s2.setXYZ(15, e2.r, e2.g, e2.b), s2.setXYZ(16, e2.r, e2.g, e2.b), s2.setXYZ(17, e2.r, e2.g, e2.b), s2.setXYZ(18, e2.r, e2.g, e2.b), s2.setXYZ(19, e2.r, e2.g, e2.b), s2.setXYZ(20, e2.r, e2.g, e2.b), s2.setXYZ(21, e2.r, e2.g, e2.b), s2.setXYZ(22, e2.r, e2.g, e2.b), s2.setXYZ(23, e2.r, e2.g, e2.b), s2.setXYZ(24, t2.r, t2.g, t2.b), s2.setXYZ(25, t2.r, t2.g, t2.b), s2.setXYZ(26, t2.r, t2.g, t2.b), s2.setXYZ(27, t2.r, t2.g, t2.b), s2.setXYZ(28, t2.r, t2.g, t2.b), s2.setXYZ(29, t2.r, t2.g, t2.b), s2.setXYZ(30, t2.r, t2.g, t2.b), s2.setXYZ(31, t2.r, t2.g, t2.b), s2.setXYZ(32, n2.r, n2.g, n2.b), s2.setXYZ(33, n2.r, n2.g, n2.b), s2.setXYZ(34, n2.r, n2.g, n2.b), s2.setXYZ(35, n2.r, n2.g, n2.b), s2.setXYZ(36, n2.r, n2.g, n2.b), s2.setXYZ(37, n2.r, n2.g, n2.b), s2.setXYZ(38, r2.r, r2.g, r2.b), s2.setXYZ(39, r2.r, r2.g, r2.b), s2.setXYZ(40, i2.r, i2.g, i2.b), s2.setXYZ(41, i2.r, i2.g, i2.b), s2.setXYZ(42, i2.r, i2.g, i2.b), s2.setXYZ(43, i2.r, i2.g, i2.b), s2.setXYZ(44, i2.r, i2.g, i2.b), s2.setXYZ(45, i2.r, i2.g, i2.b), s2.setXYZ(46, i2.r, i2.g, i2.b), s2.setXYZ(47, i2.r, i2.g, i2.b), s2.setXYZ(48, i2.r, i2.g, i2.b), s2.setXYZ(49, i2.r, i2.g, i2.b), s2.needsUpdate = true;
    }
    update() {
      const e2 = this.geometry, t2 = this.pointMap;
      af.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), cf("c", t2, e2, af, 0, 0, -1), cf("t", t2, e2, af, 0, 0, 1), cf("n1", t2, e2, af, -1, -1, -1), cf("n2", t2, e2, af, 1, -1, -1), cf("n3", t2, e2, af, -1, 1, -1), cf("n4", t2, e2, af, 1, 1, -1), cf("f1", t2, e2, af, -1, -1, 1), cf("f2", t2, e2, af, 1, -1, 1), cf("f3", t2, e2, af, -1, 1, 1), cf("f4", t2, e2, af, 1, 1, 1), cf("u1", t2, e2, af, 0.7, 1.1, -1), cf("u2", t2, e2, af, -0.7, 1.1, -1), cf("u3", t2, e2, af, 0, 2, -1), cf("cf1", t2, e2, af, -1, 0, 1), cf("cf2", t2, e2, af, 1, 0, 1), cf("cf3", t2, e2, af, 0, -1, 1), cf("cf4", t2, e2, af, 0, 1, 1), cf("cn1", t2, e2, af, -1, 0, -1), cf("cn2", t2, e2, af, 1, 0, -1), cf("cn3", t2, e2, af, 0, -1, -1), cf("cn4", t2, e2, af, 0, 1, -1), e2.getAttribute("position").needsUpdate = true;
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }
  function cf(e2, t2, n2, r2, i2, s2, o2) {
    of.set(i2, s2, o2).unproject(r2);
    const a2 = t2[e2];
    if (void 0 !== a2) {
      const e3 = n2.getAttribute("position");
      for (let t3 = 0, n3 = a2.length; t3 < n3; t3++)
        e3.setXYZ(a2[t3], of.x, of.y, of.z);
    }
  }
  const uf = new Cr();
  class pf extends Qc {
    constructor(e2, t2 = 16776960) {
      const n2 = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r2 = new Float32Array(24), i2 = new gs();
      i2.setIndex(new $i(n2, 1)), i2.setAttribute("position", new $i(r2, 3)), super(i2, new Lc({ color: t2, toneMapped: false })), this.object = e2, this.type = "BoxHelper", this.matrixAutoUpdate = false, this.update();
    }
    update(e2) {
      if (void 0 !== e2 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && uf.setFromObject(this.object), uf.isEmpty())
        return;
      const t2 = uf.min, n2 = uf.max, r2 = this.geometry.attributes.position, i2 = r2.array;
      i2[0] = n2.x, i2[1] = n2.y, i2[2] = n2.z, i2[3] = t2.x, i2[4] = n2.y, i2[5] = n2.z, i2[6] = t2.x, i2[7] = t2.y, i2[8] = n2.z, i2[9] = n2.x, i2[10] = t2.y, i2[11] = n2.z, i2[12] = n2.x, i2[13] = n2.y, i2[14] = t2.z, i2[15] = t2.x, i2[16] = n2.y, i2[17] = t2.z, i2[18] = t2.x, i2[19] = t2.y, i2[20] = t2.z, i2[21] = n2.x, i2[22] = t2.y, i2[23] = t2.z, r2.needsUpdate = true, this.geometry.computeBoundingSphere();
    }
    setFromObject(e2) {
      return this.object = e2, this.update(), this;
    }
    copy(e2, t2) {
      return super.copy(e2, t2), this.object = e2.object, this;
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }
  class df extends Qc {
    constructor(e2, t2 = 16776960) {
      const n2 = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r2 = new gs();
      r2.setIndex(new $i(n2, 1)), r2.setAttribute("position", new ls([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(r2, new Lc({ color: t2, toneMapped: false })), this.box = e2, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
    }
    updateMatrixWorld(e2) {
      const t2 = this.box;
      t2.isEmpty() || (t2.getCenter(this.position), t2.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e2));
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }
  class hf extends Gc {
    constructor(e2, t2 = 1, n2 = 16776960) {
      const r2 = n2, i2 = new gs();
      i2.setAttribute("position", new ls([1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), i2.computeBoundingSphere(), super(i2, new Lc({ color: r2, toneMapped: false })), this.type = "PlaneHelper", this.plane = e2, this.size = t2;
      const s2 = new gs();
      s2.setAttribute("position", new ls([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), s2.computeBoundingSphere(), this.add(new Os(s2, new Qi({ color: r2, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false })));
    }
    updateMatrixWorld(e2) {
      this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e2);
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
    }
  }
  const ff = new Ar();
  let mf, _f;
  class gf extends xi {
    constructor(e2 = new Ar(0, 0, 1), t2 = new Ar(0, 0, 0), n2 = 1, r2 = 16776960, i2 = 0.2 * n2, s2 = 0.2 * i2) {
      super(), this.type = "ArrowHelper", void 0 === mf && (mf = new gs(), mf.setAttribute("position", new ls([0, 0, 0, 0, 1, 0], 3)), _f = new Iu(0, 0.5, 1, 5, 1), _f.translate(0, -0.5, 0)), this.position.copy(t2), this.line = new Gc(mf, new Lc({ color: r2, toneMapped: false })), this.line.matrixAutoUpdate = false, this.add(this.line), this.cone = new Os(_f, new Qi({ color: r2, toneMapped: false })), this.cone.matrixAutoUpdate = false, this.add(this.cone), this.setDirection(e2), this.setLength(n2, i2, s2);
    }
    setDirection(e2) {
      if (e2.y > 0.99999)
        this.quaternion.set(0, 0, 0, 1);
      else if (e2.y < -0.99999)
        this.quaternion.set(1, 0, 0, 0);
      else {
        ff.set(e2.z, 0, -e2.x).normalize();
        const t2 = Math.acos(e2.y);
        this.quaternion.setFromAxisAngle(ff, t2);
      }
    }
    setLength(e2, t2 = 0.2 * e2, n2 = 0.2 * t2) {
      this.line.scale.set(1, Math.max(1e-4, e2 - t2), 1), this.line.updateMatrix(), this.cone.scale.set(n2, t2, n2), this.cone.position.y = e2, this.cone.updateMatrix();
    }
    setColor(e2) {
      this.line.material.color.set(e2), this.cone.material.color.set(e2);
    }
    copy(e2) {
      return super.copy(e2, false), this.line.copy(e2.line), this.cone.copy(e2.cone), this;
    }
    dispose() {
      this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
    }
  }
  class vf extends Qc {
    constructor(e2 = 1) {
      const t2 = [0, 0, 0, e2, 0, 0, 0, 0, 0, 0, e2, 0, 0, 0, 0, 0, 0, e2], n2 = new gs();
      n2.setAttribute("position", new ls(t2, 3)), n2.setAttribute("color", new ls([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], 3)), super(n2, new Lc({ vertexColors: true, toneMapped: false })), this.type = "AxesHelper";
    }
    setColors(e2, t2, n2) {
      const r2 = new Vi(), i2 = this.geometry.attributes.color.array;
      return r2.set(e2), r2.toArray(i2, 0), r2.toArray(i2, 3), r2.set(t2), r2.toArray(i2, 6), r2.toArray(i2, 9), r2.set(n2), r2.toArray(i2, 12), r2.toArray(i2, 15), this.geometry.attributes.color.needsUpdate = true, this;
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }
  class yf {
    constructor() {
      this.type = "ShapePath", this.color = new Vi(), this.subPaths = [], this.currentPath = null;
    }
    moveTo(e2, t2) {
      return this.currentPath = new Su(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e2, t2), this;
    }
    lineTo(e2, t2) {
      return this.currentPath.lineTo(e2, t2), this;
    }
    quadraticCurveTo(e2, t2, n2, r2) {
      return this.currentPath.quadraticCurveTo(e2, t2, n2, r2), this;
    }
    bezierCurveTo(e2, t2, n2, r2, i2, s2) {
      return this.currentPath.bezierCurveTo(e2, t2, n2, r2, i2, s2), this;
    }
    splineThru(e2) {
      return this.currentPath.splineThru(e2), this;
    }
    toShapes(e2) {
      function t2(e3, t3) {
        const n3 = t3.length;
        let r3 = false;
        for (let i3 = n3 - 1, s3 = 0; s3 < n3; i3 = s3++) {
          let n4 = t3[i3], o3 = t3[s3], a3 = o3.x - n4.x, l3 = o3.y - n4.y;
          if (Math.abs(l3) > Number.EPSILON) {
            if (l3 < 0 && (n4 = t3[s3], a3 = -a3, o3 = t3[i3], l3 = -l3), e3.y < n4.y || e3.y > o3.y)
              continue;
            if (e3.y === n4.y) {
              if (e3.x === n4.x)
                return true;
            } else {
              const t4 = l3 * (e3.x - n4.x) - a3 * (e3.y - n4.y);
              if (0 === t4)
                return true;
              if (t4 < 0)
                continue;
              r3 = !r3;
            }
          } else {
            if (e3.y !== n4.y)
              continue;
            if (o3.x <= e3.x && e3.x <= n4.x || n4.x <= e3.x && e3.x <= o3.x)
              return true;
          }
        }
        return r3;
      }
      const n2 = up.isClockWise, r2 = this.subPaths;
      if (0 === r2.length)
        return [];
      let i2, s2, o2;
      const a2 = [];
      if (1 === r2.length)
        return s2 = r2[0], o2 = new Nu(), o2.curves = s2.curves, a2.push(o2), a2;
      let l2 = !n2(r2[0].getPoints());
      l2 = e2 ? !l2 : l2;
      const c2 = [], u2 = [];
      let p2, d2, h2 = [], f2 = 0;
      u2[f2] = void 0, h2[f2] = [];
      for (let t3 = 0, o3 = r2.length; t3 < o3; t3++)
        s2 = r2[t3], p2 = s2.getPoints(), i2 = n2(p2), i2 = e2 ? !i2 : i2, i2 ? (!l2 && u2[f2] && f2++, u2[f2] = { s: new Nu(), p: p2 }, u2[f2].s.curves = s2.curves, l2 && f2++, h2[f2] = []) : h2[f2].push({ h: s2, p: p2[0] });
      if (!u2[0])
        return function(e3) {
          const t3 = [];
          for (let n3 = 0, r3 = e3.length; n3 < r3; n3++) {
            const r4 = e3[n3], i3 = new Nu();
            i3.curves = r4.curves, t3.push(i3);
          }
          return t3;
        }(r2);
      if (u2.length > 1) {
        let e3 = false, n3 = 0;
        for (let e4 = 0, t3 = u2.length; e4 < t3; e4++)
          c2[e4] = [];
        for (let r3 = 0, i3 = u2.length; r3 < i3; r3++) {
          const i4 = h2[r3];
          for (let s3 = 0; s3 < i4.length; s3++) {
            const o3 = i4[s3];
            let a3 = true;
            for (let i5 = 0; i5 < u2.length; i5++)
              t2(o3.p, u2[i5].p) && (r3 !== i5 && n3++, a3 ? (a3 = false, c2[i5].push(o3)) : e3 = true);
            a3 && c2[r3].push(o3);
          }
        }
        n3 > 0 && false === e3 && (h2 = c2);
      }
      for (let e3 = 0, t3 = u2.length; e3 < t3; e3++) {
        o2 = u2[e3].s, a2.push(o2), d2 = h2[e3];
        for (let e4 = 0, t4 = d2.length; e4 < t4; e4++)
          o2.holes.push(d2[e4].h);
      }
      return a2;
    }
  }
  class bf extends Us {
    constructor(e2, t2, n2, r2, i2, s2) {
      console.warn("THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry."), super(e2, t2, n2, r2, i2, s2);
    }
  }
  class wf extends Tu {
    constructor(e2, t2, n2, r2) {
      console.warn("THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry."), super(e2, t2, n2, r2);
    }
  }
  class Af extends Pu {
    constructor(e2, t2, n2, r2) {
      console.warn("THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry."), super(e2, t2, n2, r2);
    }
  }
  class xf extends Ru {
    constructor(e2, t2, n2, r2, i2, s2, o2) {
      console.warn("THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry."), super(e2, t2, n2, r2, i2, s2, o2);
    }
  }
  class Ef extends Iu {
    constructor(e2, t2, n2, r2, i2, s2, o2, a2) {
      console.warn("THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry."), super(e2, t2, n2, r2, i2, s2, o2, a2);
    }
  }
  class Cf extends Du {
    constructor(e2, t2) {
      console.warn("THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry."), super(e2, t2);
    }
  }
  class Sf extends hp {
    constructor(e2, t2) {
      console.warn("THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry."), super(e2, t2);
    }
  }
  class Mf extends mp {
    constructor(e2, t2) {
      console.warn("THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry."), super(e2, t2);
    }
  }
  class Tf extends Mu {
    constructor(e2, t2, n2, r2) {
      console.warn("THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry."), super(e2, t2, n2, r2);
    }
  }
  class Pf extends _p {
    constructor(e2, t2) {
      console.warn("THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry."), super(e2, t2);
    }
  }
  class If extends io {
    constructor(e2, t2, n2, r2) {
      console.warn("THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry."), super(e2, t2, n2, r2);
    }
  }
  class Rf extends ku {
    constructor(e2, t2, n2, r2) {
      console.warn("THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry."), super(e2, t2, n2, r2);
    }
  }
  class kf extends gp {
    constructor(e2, t2, n2, r2, i2, s2) {
      console.warn("THREE.RingBufferGeometry has been renamed to THREE.RingGeometry."), super(e2, t2, n2, r2, i2, s2);
    }
  }
  class Df extends vp {
    constructor(e2, t2) {
      console.warn("THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry."), super(e2, t2);
    }
  }
  class Bf extends yp {
    constructor(e2, t2, n2, r2, i2, s2, o2) {
      console.warn("THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry."), super(e2, t2, n2, r2, i2, s2, o2);
    }
  }
  class Of extends bp {
    constructor(e2, t2) {
      console.warn("THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry."), super(e2, t2);
    }
  }
  class Lf extends wp {
    constructor(e2, t2, n2, r2, i2) {
      console.warn("THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry."), super(e2, t2, n2, r2, i2);
    }
  }
  class Uf extends Ap {
    constructor(e2, t2, n2, r2, i2, s2) {
      console.warn("THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry."), super(e2, t2, n2, r2, i2, s2);
    }
  }
  class Ff extends xp {
    constructor(e2, t2, n2, r2, i2) {
      console.warn("THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry."), super(e2, t2, n2, r2, i2);
    }
  }
  "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: r } })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = r);
}, 553: function(e, t, n) {
  n.d(t, { _: function() {
    return s;
  } });
  var r = n(988);
  const i = /* @__PURE__ */ new WeakMap();
  class s extends r.aNw {
    constructor(e2) {
      super(e2), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = { position: "POSITION", normal: "NORMAL", color: "COLOR", uv: "TEX_COORD" }, this.defaultAttributeTypes = { position: "Float32Array", normal: "Float32Array", color: "Float32Array", uv: "Float32Array" };
    }
    setDecoderPath(e2) {
      return this.decoderPath = e2, this;
    }
    setDecoderConfig(e2) {
      return this.decoderConfig = e2, this;
    }
    setWorkerLimit(e2) {
      return this.workerLimit = e2, this;
    }
    load(e2, t2, n2, i2) {
      const s2 = new r.hH6(this.manager);
      s2.setPath(this.path), s2.setResponseType("arraybuffer"), s2.setRequestHeader(this.requestHeader), s2.setWithCredentials(this.withCredentials), s2.load(e2, (e3) => {
        this.parse(e3, t2, i2);
      }, n2, i2);
    }
    parse(e2, t2, n2) {
      this.decodeDracoFile(e2, t2, null, null, r.KI_).catch(n2);
    }
    decodeDracoFile(e2, t2, n2, i2, s2 = r.GUF) {
      const o2 = { attributeIDs: n2 || this.defaultAttributeIDs, attributeTypes: i2 || this.defaultAttributeTypes, useUniqueIDs: !!n2, vertexColorSpace: s2 };
      return this.decodeGeometry(e2, o2).then(t2);
    }
    decodeGeometry(e2, t2) {
      const n2 = JSON.stringify(t2);
      if (i.has(e2)) {
        const t3 = i.get(e2);
        if (t3.key === n2)
          return t3.promise;
        if (0 === e2.byteLength)
          throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.");
      }
      let r2;
      const s2 = this.workerNextTaskID++, o2 = e2.byteLength, a = this._getWorker(s2, o2).then((n3) => (r2 = n3, new Promise((n4, i2) => {
        r2._callbacks[s2] = { resolve: n4, reject: i2 }, r2.postMessage({ type: "decode", id: s2, taskConfig: t2, buffer: e2 }, [e2]);
      }))).then((e3) => this._createGeometry(e3.geometry));
      return a.catch(() => true).then(() => {
        r2 && s2 && this._releaseTask(r2, s2);
      }), i.set(e2, { key: n2, promise: a }), a;
    }
    _createGeometry(e2) {
      const t2 = new r.u9r();
      e2.index && t2.setIndex(new r.TlE(e2.index.array, 1));
      for (let n2 = 0; n2 < e2.attributes.length; n2++) {
        const i2 = e2.attributes[n2], s2 = i2.name, o2 = i2.array, a = i2.itemSize, l = new r.TlE(o2, a);
        "color" === s2 && (this._assignVertexColorSpace(l, i2.vertexColorSpace), l.normalized = o2 instanceof Float32Array == 0), t2.setAttribute(s2, l);
      }
      return t2;
    }
    _assignVertexColorSpace(e2, t2) {
      if (t2 !== r.KI_)
        return;
      const n2 = new r.Ilk();
      for (let t3 = 0, r2 = e2.count; t3 < r2; t3++)
        n2.fromBufferAttribute(e2, t3).convertSRGBToLinear(), e2.setXYZ(t3, n2.r, n2.g, n2.b);
    }
    _loadLibrary(e2, t2) {
      const n2 = new r.hH6(this.manager);
      return n2.setPath(this.decoderPath), n2.setResponseType(t2), n2.setWithCredentials(this.withCredentials), new Promise((t3, r2) => {
        n2.load(e2, t3, void 0, r2);
      });
    }
    preload() {
      return this._initDecoder(), this;
    }
    _initDecoder() {
      if (this.decoderPending)
        return this.decoderPending;
      const e2 = "object" != typeof WebAssembly || "js" === this.decoderConfig.type, t2 = [];
      return e2 ? t2.push(this._loadLibrary("draco_decoder.js", "text")) : (t2.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t2.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t2).then((t3) => {
        const n2 = t3[0];
        e2 || (this.decoderConfig.wasmBinary = t3[1]);
        const r2 = o, i2 = ["/* draco decoder */", n2, "", "/* worker */", r2.substring(r2.indexOf("{") + 1, r2.lastIndexOf("}"))].join("\n");
        this.workerSourceURL = URL.createObjectURL(new Blob([i2]));
      }), this.decoderPending;
    }
    _getWorker(e2, t2) {
      return this._initDecoder().then(() => {
        if (this.workerPool.length < this.workerLimit) {
          const e3 = new Worker(this.workerSourceURL);
          e3._callbacks = {}, e3._taskCosts = {}, e3._taskLoad = 0, e3.postMessage({ type: "init", decoderConfig: this.decoderConfig }), e3.onmessage = function(t3) {
            const n3 = t3.data;
            switch (n3.type) {
              case "decode":
                e3._callbacks[n3.id].resolve(n3);
                break;
              case "error":
                e3._callbacks[n3.id].reject(n3);
                break;
              default:
                console.error('THREE.DRACOLoader: Unexpected message, "' + n3.type + '"');
            }
          }, this.workerPool.push(e3);
        } else
          this.workerPool.sort(function(e3, t3) {
            return e3._taskLoad > t3._taskLoad ? -1 : 1;
          });
        const n2 = this.workerPool[this.workerPool.length - 1];
        return n2._taskCosts[e2] = t2, n2._taskLoad += t2, n2;
      });
    }
    _releaseTask(e2, t2) {
      e2._taskLoad -= e2._taskCosts[t2], delete e2._callbacks[t2], delete e2._taskCosts[t2];
    }
    debug() {
      console.log("Task load: ", this.workerPool.map((e2) => e2._taskLoad));
    }
    dispose() {
      for (let e2 = 0; e2 < this.workerPool.length; ++e2)
        this.workerPool[e2].terminate();
      return this.workerPool.length = 0, "" !== this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), this;
    }
  }
  const o = "\nfunction DRACOWorker() {\n\n	let decoderConfig;\n	let decoderPending;\n\n	onmessage = function ( e ) {\n\n		const message = e.data;\n\n		switch ( message.type ) {\n\n			case 'init':\n				decoderConfig = message.decoderConfig;\n				decoderPending = new Promise( function ( resolve/*, reject*/ ) {\n\n					decoderConfig.onModuleLoaded = function ( draco ) {\n\n						// Module is Promise-like. Wrap before resolving to avoid loop.\n						resolve( { draco: draco } );\n\n					};\n\n					DracoDecoderModule( decoderConfig ); // eslint-disable-line no-undef\n\n				} );\n				break;\n\n			case 'decode':\n				const buffer = message.buffer;\n				const taskConfig = message.taskConfig;\n				decoderPending.then( ( module ) => {\n\n					const draco = module.draco;\n					const decoder = new draco.Decoder();\n\n					try {\n\n						const geometry = decodeGeometry( draco, decoder, new Int8Array( buffer ), taskConfig );\n\n						const buffers = geometry.attributes.map( ( attr ) => attr.array.buffer );\n\n						if ( geometry.index ) buffers.push( geometry.index.array.buffer );\n\n						self.postMessage( { type: 'decode', id: message.id, geometry }, buffers );\n\n					} catch ( error ) {\n\n						console.error( error );\n\n						self.postMessage( { type: 'error', id: message.id, error: error.message } );\n\n					} finally {\n\n						draco.destroy( decoder );\n\n					}\n\n				} );\n				break;\n\n		}\n\n	};\n\n	function decodeGeometry( draco, decoder, array, taskConfig ) {\n\n		const attributeIDs = taskConfig.attributeIDs;\n		const attributeTypes = taskConfig.attributeTypes;\n\n		let dracoGeometry;\n		let decodingStatus;\n\n		const geometryType = decoder.GetEncodedGeometryType( array );\n\n		if ( geometryType === draco.TRIANGULAR_MESH ) {\n\n			dracoGeometry = new draco.Mesh();\n			decodingStatus = decoder.DecodeArrayToMesh( array, array.byteLength, dracoGeometry );\n\n		} else if ( geometryType === draco.POINT_CLOUD ) {\n\n			dracoGeometry = new draco.PointCloud();\n			decodingStatus = decoder.DecodeArrayToPointCloud( array, array.byteLength, dracoGeometry );\n\n		} else {\n\n			throw new Error( 'THREE.DRACOLoader: Unexpected geometry type.' );\n\n		}\n\n		if ( ! decodingStatus.ok() || dracoGeometry.ptr === 0 ) {\n\n			throw new Error( 'THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg() );\n\n		}\n\n		const geometry = { index: null, attributes: [] };\n\n		// Gather all vertex attributes.\n		for ( const attributeName in attributeIDs ) {\n\n			const attributeType = self[ attributeTypes[ attributeName ] ];\n\n			let attribute;\n			let attributeID;\n\n			// A Draco file may be created with default vertex attributes, whose attribute IDs\n			// are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n			// a Draco file may contain a custom set of attributes, identified by known unique\n			// IDs. glTF files always do the latter, and .drc files typically do the former.\n			if ( taskConfig.useUniqueIDs ) {\n\n				attributeID = attributeIDs[ attributeName ];\n				attribute = decoder.GetAttributeByUniqueId( dracoGeometry, attributeID );\n\n			} else {\n\n				attributeID = decoder.GetAttributeId( dracoGeometry, draco[ attributeIDs[ attributeName ] ] );\n\n				if ( attributeID === - 1 ) continue;\n\n				attribute = decoder.GetAttribute( dracoGeometry, attributeID );\n\n			}\n\n			const attributeResult = decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute );\n\n			if ( attributeName === 'color' ) {\n\n				attributeResult.vertexColorSpace = taskConfig.vertexColorSpace;\n\n			}\n\n			geometry.attributes.push( attributeResult );\n\n		}\n\n		// Add index.\n		if ( geometryType === draco.TRIANGULAR_MESH ) {\n\n			geometry.index = decodeIndex( draco, decoder, dracoGeometry );\n\n		}\n\n		draco.destroy( dracoGeometry );\n\n		return geometry;\n\n	}\n\n	function decodeIndex( draco, decoder, dracoGeometry ) {\n\n		const numFaces = dracoGeometry.num_faces();\n		const numIndices = numFaces * 3;\n		const byteLength = numIndices * 4;\n\n		const ptr = draco._malloc( byteLength );\n		decoder.GetTrianglesUInt32Array( dracoGeometry, byteLength, ptr );\n		const index = new Uint32Array( draco.HEAPF32.buffer, ptr, numIndices ).slice();\n		draco._free( ptr );\n\n		return { array: index, itemSize: 1 };\n\n	}\n\n	function decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) {\n\n		const numComponents = attribute.num_components();\n		const numPoints = dracoGeometry.num_points();\n		const numValues = numPoints * numComponents;\n		const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n		const dataType = getDracoDataType( draco, attributeType );\n\n		const ptr = draco._malloc( byteLength );\n		decoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, dataType, byteLength, ptr );\n		const array = new attributeType( draco.HEAPF32.buffer, ptr, numValues ).slice();\n		draco._free( ptr );\n\n		return {\n			name: attributeName,\n			array: array,\n			itemSize: numComponents\n		};\n\n	}\n\n	function getDracoDataType( draco, attributeType ) {\n\n		switch ( attributeType ) {\n\n			case Float32Array: return draco.DT_FLOAT32;\n			case Int8Array: return draco.DT_INT8;\n			case Int16Array: return draco.DT_INT16;\n			case Int32Array: return draco.DT_INT32;\n			case Uint8Array: return draco.DT_UINT8;\n			case Uint16Array: return draco.DT_UINT16;\n			case Uint32Array: return draco.DT_UINT32;\n\n		}\n\n	}\n\n}\n";
} };
var __webpackgi_module_cache__ = {};
var leafPrototypes;
var getProto;
var inProgress;
var dataWebpackPrefix;
function __webpackgi_require__2(e) {
  var t = __webpackgi_module_cache__[e];
  if (void 0 !== t)
    return t.exports;
  var n = __webpackgi_module_cache__[e] = { id: e, exports: {} };
  return __webpackgi_modules__[e].call(n.exports, n, n.exports, __webpackgi_require__2), n.exports;
}
__webpackgi_require__2.m = __webpackgi_modules__, __webpackgi_require__2.n = function(e) {
  var t = e && e.__esModule ? function() {
    return e.default;
  } : function() {
    return e;
  };
  return __webpackgi_require__2.d(t, { a: t }), t;
}, getProto = Object.getPrototypeOf ? function(e) {
  return Object.getPrototypeOf(e);
} : function(e) {
  return e.__proto__;
}, __webpackgi_require__2.t = function(e, t) {
  if (1 & t && (e = this(e)), 8 & t)
    return e;
  if ("object" == typeof e && e) {
    if (4 & t && e.__esModule)
      return e;
    if (16 & t && "function" == typeof e.then)
      return e;
  }
  var n = /* @__PURE__ */ Object.create(null);
  __webpackgi_require__2.r(n);
  var r = {};
  leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
  for (var i = 2 & t && e; "object" == typeof i && !~leafPrototypes.indexOf(i); i = getProto(i))
    Object.getOwnPropertyNames(i).forEach(function(t2) {
      r[t2] = function() {
        return e[t2];
      };
    });
  return r.default = function() {
    return e;
  }, __webpackgi_require__2.d(n, r), n;
}, __webpackgi_require__2.d = function(e, t) {
  for (var n in t)
    __webpackgi_require__2.o(t, n) && !__webpackgi_require__2.o(e, n) && Object.defineProperty(e, n, { enumerable: true, get: t[n] });
}, __webpackgi_require__2.f = {}, __webpackgi_require__2.e = function(e) {
  return Promise.all(Object.keys(__webpackgi_require__2.f).reduce(function(t, n) {
    return __webpackgi_require__2.f[n](e, t), t;
  }, []));
}, __webpackgi_require__2.u = function(e) {
  return e + ".mjs";
}, __webpackgi_require__2.o = function(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}, inProgress = {}, dataWebpackPrefix = "webgi:", __webpackgi_require__2.l = function(e, t, n, r) {
  if (inProgress[e])
    inProgress[e].push(t);
  else {
    var i, s;
    if (void 0 !== n)
      for (var o = document.getElementsByTagName("script"), a = 0; a < o.length; a++) {
        var l = o[a];
        if (l.getAttribute("src") == e || l.getAttribute("data-webpack") == dataWebpackPrefix + n) {
          i = l;
          break;
        }
      }
    i || (s = true, (i = document.createElement("script")).type = "module", i.charset = "utf-8", i.timeout = 120, __webpackgi_require__2.nc && i.setAttribute("nonce", __webpackgi_require__2.nc), i.setAttribute("data-webpack", dataWebpackPrefix + n), i.src = e), inProgress[e] = [t];
    var c = function(t2, n2) {
      i.onerror = i.onload = null, clearTimeout(u);
      var r2 = inProgress[e];
      if (delete inProgress[e], i.parentNode && i.parentNode.removeChild(i), r2 && r2.forEach(function(e2) {
        return e2(n2);
      }), t2)
        return t2(n2);
    }, u = setTimeout(c.bind(null, void 0, { type: "timeout", target: i }), 12e4);
    i.onerror = c.bind(null, i.onerror), i.onload = c.bind(null, i.onload), s && document.head.appendChild(i);
  }
}, __webpackgi_require__2.r = function(e) {
  "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: true });
}, function() {
  var e;
  if ("string" == typeof import.meta.url && (e = import.meta.url), !e)
    throw new Error("Automatic publicPath is not supported in this browser");
  e = e.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/"), __webpackgi_require__2.p = e + "../../";
}(), function() {
  var e = { 698: 0 };
  __webpackgi_require__2.f.j = function(t2, n2) {
    var r = __webpackgi_require__2.o(e, t2) ? e[t2] : void 0;
    if (0 !== r)
      if (r)
        n2.push(r[2]);
      else {
        var i = new Promise(function(n3, i2) {
          r = e[t2] = [n3, i2];
        });
        n2.push(r[2] = i);
        var s = __webpackgi_require__2.p + __webpackgi_require__2.u(t2), o = new Error();
        __webpackgi_require__2.l(s, function(n3) {
          if (__webpackgi_require__2.o(e, t2) && (0 !== (r = e[t2]) && (e[t2] = void 0), r)) {
            var i2 = n3 && ("load" === n3.type ? "missing" : n3.type), s2 = n3 && n3.target && n3.target.src;
            o.message = "Loading chunk " + t2 + " failed.\n(" + i2 + ": " + s2 + ")", o.name = "ChunkLoadError", o.type = i2, o.request = s2, r[1](o);
          }
        }, "chunk-" + t2, t2);
      }
  };
  var t = function(t2, n2) {
    var r, i, s = n2[0], o = n2[1], a = n2[2], l = 0;
    if (s.some(function(t3) {
      return 0 !== e[t3];
    })) {
      for (r in o)
        __webpackgi_require__2.o(o, r) && (__webpackgi_require__2.m[r] = o[r]);
      a && a(__webpackgi_require__2);
    }
    for (t2 && t2(n2); l < s.length; l++)
      i = s[l], __webpackgi_require__2.o(e, i) && e[i] && e[i][0](), e[i] = 0;
  }, n = self.webpackChunkwebgi = self.webpackChunkwebgi || [];
  n.forEach(t.bind(null, 0)), n.push = t.bind(null, n.push.bind(n));
}(), __webpackgi_require__2.nc = void 0;
var __webpackgi_exports__2 = {};
!function() {
  var e;
  __webpackgi_require__2.d(__webpackgi_exports__2, { MWW: function() {
    return xc;
  }, LY2: function() {
    return n.LY2;
  }, GYo: function() {
    return HT;
  }, GPz: function() {
    return gC;
  }, HRj: function() {
    return Lt;
  }, li4: function() {
    return iC;
  }, FO5: function() {
    return pC;
  }, Nlh: function() {
    return oC;
  }, Mp4: function() {
    return lt;
  }, QvI: function() {
    return gt;
  }, PrA: function() {
    return SU;
  }, JHp: function() {
    return Co;
  }, bGH: function() {
    return n.bGH;
  }, NDo: function() {
    return n.NDo;
  }, gSk: function() {
    return n.gSk;
  }, WMw: function() {
    return n.WMw;
  }, OTo: function() {
    return n.OTo;
  }, T6w: function() {
    return n.T6w;
  }, Se2: function() {
    return n.Se2;
  }, cum: function() {
    return n.cum;
  }, Mig: function() {
    return n.Mig;
  }, B$7: function() {
    return lr;
  }, i_9: function() {
    return n.i_9;
  }, bBp: function() {
    return n.bBp;
  }, m7l: function() {
    return n.m7l;
  }, sYA: function() {
    return n.sYA;
  }, Xcj: function() {
    return n.Xcj;
  }, mzJ: function() {
    return n.mzJ;
  }, ZZA: function() {
    return n.ZZA;
  }, $Ph: function() {
    return Sl;
  }, T__: function() {
    return n.T__;
  }, HkE: function() {
    return n.HkE;
  }, tGC: function() {
    return n.tGC;
  }, g1S: function() {
    return lb;
  }, I$C: function() {
    return ub;
  }, QIH: function() {
    return ks;
  }, _JE: function() {
    return bv;
  }, SwW: function() {
    return Tv;
  }, ksm: function() {
    return Ls;
  }, jl_: function() {
    return Fi;
  }, b7R: function() {
    return es;
  }, BDV: function() {
    return Ii;
  }, Ea_: function() {
    return Gi;
  }, qff: function() {
    return Fi;
  }, tmC: function() {
    return Bi;
  }, BON: function() {
    return Ms;
  }, P40: function() {
    return Ki;
  }, wLL: function() {
    return ws;
  }, iHO: function() {
    return Wi;
  }, BbS: function() {
    return n.BbS;
  }, kqm: function() {
    return n.kqm;
  }, Hmr: function() {
    return n.Hmr;
  }, SJI: function() {
    return n.SJI;
  }, mTL: function() {
    return n.mTL;
  }, y8_: function() {
    return n.y8_;
  }, _Li: function() {
    return n._Li;
  }, w7U: function() {
    return Fo;
  }, g56: function() {
    return jg;
  }, bj3: function() {
    return fe;
  }, z81: function() {
    return n.z81;
  }, _MY: function() {
    return n._MY;
  }, L7J: function() {
    return RI;
  }, yEv: function() {
    return ny;
  }, dFZ: function() {
    return yo;
  }, N$j: function() {
    return n.N$j;
  }, _YM: function() {
    return n._YM;
  }, TUj: function() {
    return n.TUj;
  }, ZzF: function() {
    return n.ZzF;
  }, qzb: function() {
    return h;
  }, GQ: function() {
    return n.GQ;
  }, nvb: function() {
    return n.nvb;
  }, DvJ: function() {
    return n.DvJ;
  }, fQA: function() {
    return n.fQA;
  }, cPz: function() {
    return oa;
  }, TlE: function() {
    return n.TlE;
  }, u9r: function() {
    return n.u9r;
  }, s4_: function() {
    return n.s4_;
  }, T95: function() {
    return n.T95;
  }, F5w: function() {
    return aS;
  }, NlP: function() {
    return VT;
  }, $8Z: function() {
    return sS;
  }, YYN: function() {
    return HE;
  }, CtF: function() {
    return n.CtF;
  }, V1s: function() {
    return n.V1s;
  }, jOv: function() {
    return nt;
  }, Rki: function() {
    return n.Rki;
  }, pzV: function() {
    return oL;
  }, itZ: function() {
    return jp;
  }, MMq: function() {
    return kP;
  }, qKx: function() {
    return zp;
  }, Hmi: function() {
    return IO;
  }, X4S: function() {
    return yC;
  }, vlJ: function() {
    return cU;
  }, nPO: function() {
    return AC;
  }, zcQ: function() {
    return Lc;
  }, GH1: function() {
    return Fc;
  }, ROQ: function() {
    return n.ROQ;
  }, YN5: function() {
    return n.YN5;
  }, BVQ: function() {
    return n.BVQ;
  }, YT8: function() {
    return n.YT8;
  }, _DE: function() {
    return io;
  }, YGz: function() {
    return n.YGz;
  }, trn: function() {
    return n.trn;
  }, zf8: function() {
    return n.zf8;
  }, uWy: function() {
    return n.uWy;
  }, wYQ: function() {
    return Wd;
  }, SUY: function() {
    return n.SUY;
  }, Ilk: function() {
    return n.Ilk;
  }, R2R: function() {
    return n.R2R;
  }, epp: function() {
    return n.epp;
  }, xmJ: function() {
    return Qs;
  }, GD$: function() {
    return Ui;
  }, Z_g: function() {
    return n.Z_g;
  }, EB7: function() {
    return n.EB7;
  }, DqL: function() {
    return n.DqL;
  }, _3: function() {
    return n._3;
  }, b_z: function() {
    return n.b_z;
  }, OCn: function() {
    return SC;
  }, N_j: function() {
    return bF;
  }, hNv: function() {
    return iv;
  }, _am: function() {
    return n._am;
  }, kB7: function() {
    return zl;
  }, fY$: function() {
    return n.fY$;
  }, vxC: function() {
    return n.vxC;
  }, BtG: function() {
    return n.BtG;
  }, cBK: function() {
    return n.cBK;
  }, g8_: function() {
    return n.g8_;
  }, AXT: function() {
    return n.AXT;
  }, yj7: function() {
    return n.yj7;
  }, dYG: function() {
    return n.dYG;
  }, tm_: function() {
    return n.tm_;
  }, S2y: function() {
    return n.S2y;
  }, B02: function() {
    return n.B02;
  }, PeU: function() {
    return n.PeU;
  }, Hyl: function() {
    return n.Hyl;
  }, Wqd: function() {
    return n.Wqd;
  }, c0Q: function() {
    return TP;
  }, re0: function() {
    return PP;
  }, Xaj: function() {
    return n.Xaj;
  }, DUb: function() {
    return Ha;
  }, dZ3: function() {
    return n.dZ3;
  }, m_w: function() {
    return n.m_w;
  }, fHI: function() {
    return n.fHI;
  }, LBq: function() {
    return n.LBq;
  }, Qww: function() {
    return rr.Q;
  }, CGV: function() {
    return t.Damper;
  }, JUT: function() {
    return n.JUT;
  }, p3g: function() {
    return n.p3g;
  }, IEO: function() {
    return n.IEO;
  }, yxD: function() {
    return n.yxD;
  }, CUS: function() {
    return ry;
  }, A5E: function() {
    return n.A5E;
  }, zqG: function() {
    return bh;
  }, PfX: function() {
    return ls;
  }, Q1o: function() {
    return $i;
  }, jfJ: function() {
    return n.jfJ;
  }, T_J: function() {
    return n.T_J;
  }, tEQ: function() {
    return n.tEQ;
  }, gb4: function() {
    return Pi;
  }, qkB: function() {
    return n.qkB;
  }, cvk: function() {
    return Eo;
  }, HWo: function() {
    return Ro;
  }, brP: function() {
    return n.brP;
  }, $YQ: function() {
    return n.$YQ;
  }, X8d: function() {
    return ZT;
  }, Zdt: function() {
    return $T;
  }, yNB: function() {
    return Kl;
  }, h7x: function() {
    return Bc;
  }, Ox3: function() {
    return n.Ox3;
  }, qtn: function() {
    return sr;
  }, cBI: function() {
    return n.cBI;
  }, cU9: function() {
    return n.cU9;
  }, ntt: function() {
    return n.ntt;
  }, DT1: function() {
    return n.DT1;
  }, Kgo: function() {
    return n.Kgo;
  }, ehD: function() {
    return n.ehD;
  }, fhJ: function() {
    return Us;
  }, y1s: function() {
    return Fs;
  }, fSK: function() {
    return n.fSK;
  }, Vdb: function() {
    return n.Vdb;
  }, l8J: function() {
    return n.l8J;
  }, dj0: function() {
    return n.dj0;
  }, QM0: function() {
    return n.QM0;
  }, n94: function() {
    return ab;
  }, OIS: function() {
    return Hg;
  }, q8b: function() {
    return Dp;
  }, TOt: function() {
    return n.TOt;
  }, xaN: function() {
    return d;
  }, Ny0: function() {
    return n.Ny0;
  }, NeD: function() {
    return NC;
  }, Zof: function() {
    return cs;
  }, N1Y: function() {
    return cb;
  }, itK: function() {
    return No;
  }, F1y: function() {
    return n.F1y;
  }, eD: function() {
    return n.eD;
  }, jwo: function() {
    return n.jwo;
  }, dSO: function() {
    return n.dSO;
  }, Bf4: function() {
    return n.Bf4;
  }, USm: function() {
    return n.USm;
  }, pBf: function() {
    return n.pBf;
  }, eBg: function() {
    return UL;
  }, $Vf: function() {
    return n.$Vf;
  }, O7d: function() {
    return n.O7d;
  }, ksq: function() {
    return nm;
  }, hFL: function() {
    return bC;
  }, gXf: function() {
    return Bg;
  }, hH6: function() {
    return n.hH6;
  }, izP: function() {
    return IP;
  }, kpi: function() {
    return Yo;
  }, DwZ: function() {
    return sP;
  }, kN3: function() {
    return oP;
  }, e62: function() {
    return n.e62;
  }, a$l: function() {
    return n.a$l;
  }, OM3: function() {
    return n.OM3;
  }, VzW: function() {
    return n.VzW;
  }, ybr: function() {
    return n.ybr;
  }, yo9: function() {
    return n.yo9;
  }, Dzq: function() {
    return Rl;
  }, zCA: function() {
    return kl;
  }, $Bt: function() {
    return Po;
  }, Wzm: function() {
    return n.Wzm;
  }, Wl3: function() {
    return n.Wl3;
  }, iWj: function() {
    return n.iWj;
  }, DNz: function() {
    return wd;
  }, m1M: function() {
    return wt;
  }, ylh: function() {
    return n.ylh;
  }, v9Y: function() {
    return n.v9Y;
  }, LSk: function() {
    return n.LSk;
  }, LHE: function() {
    return Ya;
  }, KE0: function() {
    return uE;
  }, KCF: function() {
    return cE;
  }, a4n: function() {
    return Uy;
  }, NKC: function() {
    return Md;
  }, jrv: function() {
    return Pd;
  }, zIH: function() {
    return Ln;
  }, Hfk: function() {
    return Jn;
  }, png: function() {
    return Yn;
  }, tAj: function() {
    return Kn;
  }, Eb_: function() {
    return Zn;
  }, SJj: function() {
    return Ed;
  }, cF0: function() {
    return ge;
  }, BT2: function() {
    return ev;
  }, _8p: function() {
    return By;
  }, V5Z: function() {
    return Od;
  }, s5b: function() {
    return Ld;
  }, BHZ: function() {
    return jo;
  }, hkn: function() {
    return ft;
  }, GFY: function() {
    return yt;
  }, hZr: function() {
    return SI;
  }, Zen: function() {
    return n.Zen;
  }, w$m: function() {
    return n.w$m;
  }, Jjb: function() {
    return n.Jjb;
  }, ksN: function() {
    return n.ksN;
  }, j4z: function() {
    return n.j4z;
  }, OAl: function() {
    return n.OAl;
  }, VLJ: function() {
    return n.VLJ;
  }, C73: function() {
    return Gg;
  }, ZAu: function() {
    return n.ZAu;
  }, ibP: function() {
    return zi;
  }, lth: function() {
    return ld;
  }, _fI: function() {
    return Ui;
  }, hUN: function() {
    return Ul;
  }, cLu: function() {
    return n.cLu;
  }, vmT: function() {
    return n.vmT;
  }, Qpg: function() {
    return n.Qpg;
  }, So8: function() {
    return n.So8;
  }, eOv: function() {
    return eL;
  }, Wjw: function() {
    return n.Wjw;
  }, cJO: function() {
    return n.cJO;
  }, QRU: function() {
    return n.QRU;
  }, S3k: function() {
    return n.S3k;
  }, OPJ: function() {
    return vC;
  }, PpQ: function() {
    return n.PpQ;
  }, q_9: function() {
    return Ft;
  }, ZRs: function() {
    return n.ZRs;
  }, oqc: function() {
    return n.oqc;
  }, T_x: function() {
    return Di;
  }, lb7: function() {
    return n.lb7;
  }, L5s: function() {
    return n.L5s;
  }, $TI: function() {
    return n.$TI;
  }, SPe: function() {
    return n.SPe;
  }, aVm: function() {
    return n.aVm;
  }, j87: function() {
    return n.j87;
  }, RNb: function() {
    return n.RNb;
  }, Kz5: function() {
    return n.Kz5;
  }, LYt: function() {
    return rv;
  }, vpT: function() {
    return n.vpT;
  }, kB5: function() {
    return n.kB5;
  }, _C8: function() {
    return n._C8;
  }, Syv: function() {
    return n.Syv;
  }, NMF: function() {
    return n.NMF;
  }, pIN: function() {
    return n.pIN;
  }, eMJ: function() {
    return n.eMJ;
  }, rN7: function() {
    return gh;
  }, iUp: function() {
    return vh;
  }, GFd: function() {
    return ty;
  }, x5V: function() {
    return n.x5V;
  }, tUh: function() {
    return n.tUh;
  }, z8B: function() {
    return n.z8B;
  }, vcl: function() {
    return ad;
  }, GZb: function() {
    return n.GZb;
  }, p7y: function() {
    return n.p7y;
  }, e6l: function() {
    return Gd;
  }, S9g: function() {
    return n.S9g;
  }, D67: function() {
    return n.D67;
  }, Zr5: function() {
    return n.Zr5;
  }, M$G: function() {
    return n.M$G;
  }, vCF: function() {
    return n.vCF;
  }, yt0: function() {
    return n.yt0;
  }, uXU: function() {
    return n.uXU;
  }, _kC: function() {
    return n._kC;
  }, lk7: function() {
    return n.lk7;
  }, USc: function() {
    return tL;
  }, x12: function() {
    return n.x12;
  }, w_R: function() {
    return Zv;
  }, Zzh: function() {
    return n.Zzh;
  }, nls: function() {
    return n.nls;
  }, g_z: function() {
    return n.g_z;
  }, U7: function() {
    return n.U7;
  }, FT0: function() {
    return n.FT0;
  }, L1_: function() {
    return Jv;
  }, blk: function() {
    return n.blk;
  }, YRm: function() {
    return ta;
  }, ejS: function() {
    return n.ejS;
  }, wUb: function() {
    return Kv;
  }, zOz: function() {
    return $o;
  }, rnI: function() {
    return n.rnI;
  }, wem: function() {
    return n.wem;
  }, lfu: function() {
    return n.lfu;
  }, FDw: function() {
    return n.FDw;
  }, lRj: function() {
    return n.lRj;
  }, D1R: function() {
    return n.D1R;
  }, qyh: function() {
    return n.qyh;
  }, GUF: function() {
    return n.GUF;
  }, EoG: function() {
    return n.EoG;
  }, aNw: function() {
    return n.aNw;
  }, Zp0: function() {
    return n.Zp0;
  }, lLk: function() {
    return n.lLk;
  }, NHT: function() {
    return Sc;
  }, jAl: function() {
    return n.jAl;
  }, uEv: function() {
    return n.uEv;
  }, YKA: function() {
    return n.YKA;
  }, cRx: function() {
    return n.cRx;
  }, Y8D: function() {
    return n.Y8D;
  }, RsA: function() {
    return n.RsA;
  }, Y0m: function() {
    return wh;
  }, F5T: function() {
    return n.F5T;
  }, EDU: function() {
    return om;
  }, z$Q: function() {
    return Pg;
  }, KA8: function() {
    return at;
  }, ZqF: function() {
    return Go;
  }, XUj: function() {
    return kg;
  }, Me$: function() {
    return Dg;
  }, u7G: function() {
    return n.u7G;
  }, PEk: function() {
    return Ut;
  }, BG4: function() {
    return sm;
  }, M8C: function() {
    return n.M8C;
  }, Vkp: function() {
    return n.Vkp;
  }, yGw: function() {
    return n.yGw;
  }, Sm8: function() {
    return n.Sm8;
  }, Kj0: function() {
    return n.Kj0;
  }, vBJ: function() {
    return n.vBJ;
  }, QfV: function() {
    return kt;
  }, lRF: function() {
    return n.lRF;
  }, Lun: function() {
    return n.Lun;
  }, YBo: function() {
    return n.YBo;
  }, kaV: function() {
    return n.kaV;
  }, RSm: function() {
    return n.RSm;
  }, NDk: function() {
    return MP;
  }, xoR: function() {
    return n.xoR;
  }, EJi: function() {
    return n.EJi;
  }, Wid: function() {
    return n.Wid;
  }, iuj: function() {
    return It;
  }, IKL: function() {
    return n.IKL;
  }, r_: function() {
    return n.r_;
  }, OoA: function() {
    return n.OoA;
  }, qhX: function() {
    return n.qhX;
  }, CRe: function() {
    return cd;
  }, qPT: function() {
    return so;
  }, M5h: function() {
    return n.M5h;
  }, Ns1: function() {
    return n.Ns1;
  }, TyD: function() {
    return n.TyD;
  }, vZf: function() {
    return n.vZf;
  }, HTd: function() {
    return n.HTd;
  }, aH4: function() {
    return n.aH4;
  }, YLQ: function() {
    return n.YLQ;
  }, xoQ: function() {
    return n.xoQ;
  }, BVF: function() {
    return n.BVF;
  }, MyG: function() {
    return n.MyG;
  }, jFi: function() {
    return n.jFi;
  }, aCh: function() {
    return n.aCh;
  }, uL9: function() {
    return n.uL9;
  }, TNj: function() {
    return fd;
  }, IFH: function() {
    return n.IFH;
  }, bdR: function() {
    return n.bdR;
  }, RPs: function() {
    return al;
  }, kM_: function() {
    return Gl;
  }, O78: function() {
    return n.O78;
  }, M6v: function() {
    return n.M6v;
  }, RvT: function() {
    return n.RvT;
  }, dUE: function() {
    return n.dUE;
  }, oe_: function() {
    return Oh;
  }, BuN: function() {
    return Lh;
  }, Tme: function() {
    return n.Tme;
  }, N9P: function() {
    return Nt;
  }, tfP: function() {
    return YL;
  }, Gql: function() {
    return n.Gql;
  }, $XY: function() {
    return Nn;
  }, O9d: function() {
    return Ko;
  }, zEO: function() {
    return zt;
  }, qfx: function() {
    return RC;
  }, PA7: function() {
    return n.PA7;
  }, REq: function() {
    return n.REq;
  }, pQR: function() {
    return n.pQR;
  }, ghN: function() {
    return n.ghN;
  }, Hy8: function() {
    return n.Hy8;
  }, Wpd: function() {
    return n.Wpd;
  }, LgZ: function() {
    return n.LgZ;
  }, iWC: function() {
    return n.iWC;
  }, mqn: function() {
    return lU;
  }, SKe: function() {
    return et;
  }, iKG: function() {
    return n.iKG;
  }, rCq: function() {
    return $E;
  }, _iA: function() {
    return n._iA;
  }, ntZ: function() {
    return n.ntZ;
  }, anP: function() {
    return n.anP;
  }, X2e: function() {
    return BE;
  }, oxT: function() {
    return dd;
  }, FCo: function() {
    return BC;
  }, y$t: function() {
    return n.y$t;
  }, cPb: function() {
    return n.cPb;
  }, lmx: function() {
    return za;
  }, JOQ: function() {
    return n.JOQ;
  }, BKK: function() {
    return n.BKK;
  }, _12: function() {
    return n._12;
  }, tJx: function() {
    return n.tJx;
  }, mjX: function() {
    return zo;
  }, cek: function() {
    return n.cek;
  }, qD0: function() {
    return ar;
  }, xG9: function() {
    return n.xG9;
  }, eqi: function() {
    return t.PointerDragHelper;
  }, wI8: function() {
    return fP;
  }, Sgv: function() {
    return mP;
  }, woe: function() {
    return n.woe;
  }, UY4: function() {
    return n.UY4;
  }, aq0: function() {
    return n.aq0;
  }, ujx: function() {
    return n.ujx;
  }, Uol: function() {
    return n.Uol;
  }, JiH: function() {
    return jC;
  }, VYz: function() {
    return n.VYz;
  }, B2H: function() {
    return Uo;
  }, _Pm: function() {
    return Ho;
  }, EsW: function() {
    return To;
  }, iUV: function() {
    return n.iUV;
  }, tf: function() {
    return n.tf;
  }, ZQ6: function() {
    return n.ZQ6;
  }, mXe: function() {
    return n.mXe;
  }, _fP: function() {
    return n._fP;
  }, iLg: function() {
    return n.iLg;
  }, zbs: function() {
    return n.zbs;
  }, ZTh: function() {
    return n.ZTh;
  }, HdW: function() {
    return n.HdW;
  }, UZH: function() {
    return n.UZH;
  }, mSO: function() {
    return n.mSO;
  }, wk1: function() {
    return n.wk1;
  }, E2K: function() {
    return n.E2K;
  }, FUD: function() {
    return n.FUD;
  }, pKu: function() {
    return n.pKu;
  }, GG6: function() {
    return n.GG6;
  }, Gih: function() {
    return n.Gih;
  }, iiP: function() {
    return n.iiP;
  }, SvJ: function() {
    return n.SvJ;
  }, ptH: function() {
    return n.ptH;
  }, jZA: function() {
    return n.jZA;
  }, y2t: function() {
    return n.y2t;
  }, gi4: function() {
    return n.gi4;
  }, Djp: function() {
    return n.Djp;
  }, BG$: function() {
    return n.BG$;
  }, NYV: function() {
    return n.NYV;
  }, xJs: function() {
    return n.xJs;
  }, bsb: function() {
    return n.bsb;
  }, ekQ: function() {
    return n.ekQ;
  }, CaW: function() {
    return n.CaW;
  }, eaV: function() {
    return n.eaV;
  }, BFQ: function() {
    return n.BFQ;
  }, v3W: function() {
    return n.v3W;
  }, ILR: function() {
    return n.ILR;
  }, G_r: function() {
    return n.G_r;
  }, N3F: function() {
    return k;
  }, fto: function() {
    return n.fto;
  }, l0P: function() {
    return n.l0P;
  }, vCx: function() {
    return n.vCx;
  }, _AM: function() {
    return n._AM;
  }, wuA: function() {
    return n.wuA;
  }, av9: function() {
    return n.av9;
  }, CtA: function() {
    return n.CtA;
  }, fpq: function() {
    return II;
  }, BvQ: function() {
    return gl;
  }, FZJ: function() {
    return bl;
  }, FIo: function() {
    return n.FIo;
  }, zHn: function() {
    return n.zHn;
  }, iMs: function() {
    return n.iMs;
  }, T_f: function() {
    return n.T_f;
  }, hEm: function() {
    return n.hEm;
  }, D9w: function() {
    return n.D9w;
  }, sHH: function() {
    return Fg;
  }, CdI: function() {
    return n.CdI;
  }, rkc: function() {
    return sL;
  }, rpg: function() {
    return n.rpg;
  }, ce8: function() {
    return n.ce8;
  }, rOj: function() {
    return n.rOj;
  }, P6m: function() {
    return Jg;
  }, JA6: function() {
    return Kg;
  }, V4E: function() {
    return n.V4E;
  }, o8S: function() {
    return n.o8S;
  }, flB: function() {
    return it;
  }, lGU: function() {
    return n.lGU;
  }, vuL: function() {
    return n.vuL;
  }, KI_: function() {
    return n.KI_;
  }, iLN: function() {
    return fo;
  }, X6w: function() {
    return Rd;
  }, rz_: function() {
    return kd;
  }, jsw: function() {
    return jl;
  }, srG: function() {
    return il;
  }, i6Z: function() {
    return El;
  }, vfv: function() {
    return $g;
  }, xsS: function() {
    return n.xsS;
  }, or: function() {
    return nL;
  }, EQj: function() {
    return Zp;
  }, Rnn: function() {
    return DP;
  }, TyN: function() {
    return LP;
  }, ov0: function() {
    return sa;
  }, WdD: function() {
    return n.WdD;
  }, Vj0: function() {
    return n.Vj0;
  }, jyz: function() {
    return n.jyz;
  }, mTM: function() {
    return ct;
  }, Mn1: function() {
    return ut;
  }, Hlq: function() {
    return dt;
  }, Fi7: function() {
    return Lg;
  }, Tn7: function() {
    return n.Tn7;
  }, bnF: function() {
    return n.bnF;
  }, HW6: function() {
    return n.HW6;
  }, oa8: function() {
    return n.oa8;
  }, T_1: function() {
    return n.T_1;
  }, zHJ: function() {
    return FC;
  }, iDF: function() {
    return n.iDF;
  }, iAb: function() {
    return n.iAb;
  }, d4E: function() {
    return Pv;
  }, lBg: function() {
    return KO;
  }, JeJ: function() {
    return Iv;
  }, FKY: function() {
    return t.SimpleEventDispatcher;
  }, zlZ: function() {
    return iy;
  }, vkg: function() {
    return Gt;
  }, brh: function() {
    return sy;
  }, kZK: function() {
    return XC;
  }, puG: function() {
    return JO;
  }, VJK: function() {
    return EP;
  }, OdW: function() {
    return n.OdW;
  }, _YX: function() {
    return n._YX;
  }, TUv: function() {
    return n.TUv;
  }, Hw6: function() {
    return n.Hw6;
  }, aLr: function() {
    return n.aLr;
  }, Aip: function() {
    return n.Aip;
  }, xo$: function() {
    return n.xo$;
  }, bIn: function() {
    return uU;
  }, $V: function() {
    return n.$V;
  }, lDi: function() {
    return n.lDi;
  }, gti: function() {
    return n.gti;
  }, PMe: function() {
    return n.PMe;
  }, iwP: function() {
    return or;
  }, FvO: function() {
    return n.FvO;
  }, jyi: function() {
    return n.jyi;
  }, xeV: function() {
    return n.xeV;
  }, k74: function() {
    return n.k74;
  }, RlZ: function() {
    return n.RlZ;
  }, KhW: function() {
    return n.KhW;
  }, HgB: function() {
    return n.HgB;
  }, W2J: function() {
    return n.W2J;
  }, JWc: function() {
    return n.JWc;
  }, u37: function() {
    return n.u37;
  }, Z6B: function() {
    return n.Z6B;
  }, QZ1: function() {
    return n.QZ1;
  }, Ir4: function() {
    return n.Ir4;
  }, NwF: function() {
    return n.NwF;
  }, Wbm: function() {
    return n.Wbm;
  }, N4l: function() {
    return n.N4l;
  }, Jxm: function() {
    return Ig;
  }, ej9: function() {
    return Rg;
  }, QmN: function() {
    return n.QmN;
  }, Y4W: function() {
    return t.TYPED_ARRAYS;
  }, IOt: function() {
    return n.IOt;
  }, NOD: function() {
    return yd;
  }, L5g: function() {
    return n.L5g;
  }, H$k: function() {
    return n.H$k;
  }, cuP: function() {
    return QC;
  }, xEZ: function() {
    return n.xEZ;
  }, dpR: function() {
    return n.dpR;
  }, wOD: function() {
    return Do;
  }, KNb: function() {
    return Os;
  }, IiN: function() {
    return eo;
  }, Cne: function() {
    return n.Cne;
  }, XvJ: function() {
    return n.XvJ;
  }, XZw: function() {
    return n.XZw;
  }, FE5: function() {
    return n.FE5;
  }, lUF: function() {
    return AP;
  }, Mck: function() {
    return fI;
  }, lVp: function() {
    return Na;
  }, Lpo: function() {
    return TI;
  }, CJI: function() {
    return n.CJI;
  }, z$h: function() {
    return n.z$h;
  }, UlW: function() {
    return n.UlW;
  }, WwZ: function() {
    return n.WwZ;
  }, zG7: function() {
    return Fd;
  }, Lcc: function() {
    return n.Lcc;
  }, WXh: function() {
    return n.WXh;
  }, Vjr: function() {
    return OC;
  }, LuM: function() {
    return YO;
  }, LP5: function() {
    return zO;
  }, ub3: function() {
    return n.ub3;
  }, OV: function() {
    return lI;
  }, G_n: function() {
    return cI;
  }, xfE: function() {
    return n.xfE;
  }, qlB: function() {
    return n.qlB;
  }, lCJ: function() {
    return n.lCJ;
  }, WTc: function() {
    return n.WTc;
  }, rAo: function() {
    return n.rAo;
  }, LZj: function() {
    return Zs;
  }, xWb: function() {
    return n.xWb;
  }, gH0: function() {
    return n.gH0;
  }, rBU: function() {
    return n.rBU;
  }, rDY: function() {
    return n.rDY;
  }, ywz: function() {
    return n.ywz;
  }, wJv: function() {
    return n.wJv;
  }, JQ4: function() {
    return n.JQ4;
  }, k0A: function() {
    return n.k0A;
  }, irR: function() {
    return n.irR;
  }, LsT: function() {
    return n.LsT;
  }, q5h: function() {
    return Ts;
  }, TKh: function() {
    return Ss;
  }, tyg: function() {
    return Cs;
  }, Ro5: function() {
    return Yi;
  }, Saj: function() {
    return Vo;
  }, CHp: function() {
    return mC;
  }, dwk: function() {
    return n.dwk;
  }, t0w: function() {
    return hI;
  }, M7$: function() {
    return dI;
  }, ML4: function() {
    return pI;
  }, FM8: function() {
    return n.FM8;
  }, Pa4: function() {
    return n.Pa4;
  }, Ltg: function() {
    return n.Ltg;
  }, yC1: function() {
    return n.yC1;
  }, lHq: function() {
    return nd;
  }, fO1: function() {
    return n.fO1;
  }, oMA: function() {
    return zs;
  }, JzW: function() {
    return e;
  }, QEt: function() {
    return Kp;
  }, IFZ: function() {
    return _I;
  }, b5g: function() {
    return n.b5g;
  }, Ywn: function() {
    return n.Ywn;
  }, GVz: function() {
    return n.GVz;
  }, _RZ: function() {
    return n._RZ;
  }, oAp: function() {
    return n.oAp;
  }, kFz: function() {
    return n.kFz;
  }, dd2: function() {
    return n.dd2;
  }, CP7: function() {
    return n.CP7;
  }, fQK: function() {
    return n.fQK;
  }, JCZ: function() {
    return n.JCZ;
  }, Wd$: function() {
    return hv;
  }, t1_: function() {
    return TL;
  }, v27: function() {
    return ia;
  }, Uk6: function() {
    return n.Uk6;
  }, H7Z: function() {
    return ea;
  }, _sL: function() {
    return n._sL;
  }, czO: function() {
    return uI;
  }, Pnf: function() {
    return n.Pnf;
  }, c8b: function() {
    return n.c8b;
  }, _lf: function() {
    return n._lf;
  }, ad5: function() {
    return n.ad5;
  }, sZV: function() {
    return As;
  }, TfA: function() {
    return bs;
  }, sKX: function() {
    return Rs;
  }, UdM: function() {
    return ys;
  }, P0y: function() {
    return Qi;
  }, L_r: function() {
    return n.L_r;
  }, zC5: function() {
    return t.absMax;
  }, Bve: function() {
    return sv;
  }, b5G: function() {
    return vo;
  }, UeO: function() {
    return ir;
  }, qCx: function() {
    return wF;
  }, $nx: function() {
    return jy;
  }, Bk6: function() {
    return zn;
  }, EER: function() {
    return od;
  }, y4l: function() {
    return Ht;
  }, P39: function() {
    return Id;
  }, HI1: function() {
    return t.aesGcmDecrypt;
  }, ZYi: function() {
    return t.aesGcmEncrypt;
  }, wXW: function() {
    return Jm;
  }, r5x: function() {
    return Xm;
  }, MSI: function() {
    return e_;
  }, EUu: function() {
    return DU;
  }, jtH: function() {
    return kp;
  }, T0T: function() {
    return Up;
  }, gAb: function() {
    return dU;
  }, je_: function() {
    return fU;
  }, wBP: function() {
    return Lp;
  }, LU2: function() {
    return eu;
  }, wQL: function() {
    return BU;
  }, Zs7: function() {
    return g_;
  }, sMc: function() {
    return t.arrayBufferToBase64;
  }, x7s: function() {
    return k_;
  }, Mnd: function() {
    return UU;
  }, A0_: function() {
    return FU;
  }, d73: function() {
    return Lm;
  }, HCD: function() {
    return Q;
  }, YQ8: function() {
    return _e;
  }, RG9: function() {
    return W;
  }, G2P: function() {
    return Jc;
  }, XLf: function() {
    return $c;
  }, CGN: function() {
    return Zc;
  }, RGi: function() {
    return t.base64ToArrayBuffer;
  }, mvg: function() {
    return Um;
  }, Hiy: function() {
    return Rt;
  }, XMc: function() {
    return Ym;
  }, N7M: function() {
    return Wm;
  }, iv: function() {
    return Zm;
  }, n55: function() {
    return t.blobToDataURL;
  }, IaC: function() {
    return Dm;
  }, h9t: function() {
    return nu;
  }, yDW: function() {
    return ru;
  }, gJv: function() {
    return tu;
  }, l$g: function() {
    return oS;
  }, vQi: function() {
    return GT;
  }, $MY: function() {
    return St;
  }, wJl: function() {
    return Et;
  }, Z7Y: function() {
    return Xc;
  }, X7D: function() {
    return Kc;
  }, BnX: function() {
    return Yc;
  }, uZ5: function() {
    return lu;
  }, zVI: function() {
    return jm;
  }, Wz1: function() {
    return t.colorToDataUrl;
  }, DpF: function() {
    return Ao;
  }, nNb: function() {
    return Ni;
  }, cqZ: function() {
    return ji;
  }, pKN: function() {
    return WE;
  }, CN8: function() {
    return ql;
  }, DdI: function() {
    return qE;
  }, rrX: function() {
    return XE;
  }, uqj: function() {
    return _;
  }, Z9P: function() {
    return S;
  }, KlC: function() {
    return Hl;
  }, KVn: function() {
    return R;
  }, oau: function() {
    return __;
  }, aw9: function() {
    return K;
  }, Aap: function() {
    return Ee;
  }, Dxg: function() {
    return t.copyProps;
  }, MjT: function() {
    return Z;
  }, F7Q: function() {
    return Vc;
  }, IFq: function() {
    return LU;
  }, IJl: function() {
    return Gc;
  }, O5A: function() {
    return t.createCanvasElement;
  }, wCn: function() {
    return t.createDiv;
  }, gGT: function() {
    return zc;
  }, hqj: function() {
    return _E;
  }, pEc: function() {
    return QE;
  }, Bi6: function() {
    return t.createImage;
  }, fi_: function() {
    return L_;
  }, TT: function() {
    return o_;
  }, q2Z: function() {
    return KL;
  }, NyK: function() {
    return me;
  }, bgu: function() {
    return t.createScriptFromURL;
  }, kcS: function() {
    return t.createStyles;
  }, rRN: function() {
    return iS;
  }, ivY: function() {
    return t.css;
  }, _s1: function() {
    return lF;
  }, _HO: function() {
    return G;
  }, tpL: function() {
    return V;
  }, DMK: function() {
    return dp;
  }, LjN: function() {
    return ts;
  }, iFs: function() {
    return ns;
  }, qTg: function() {
    return t.deepAccessObject;
  }, J4G: function() {
    return y;
  }, Zj8: function() {
    return PU;
  }, Wtl: function() {
    return Ri;
  }, DmK: function() {
    return ki;
  }, Htt: function() {
    return NU;
  }, Nv0: function() {
    return w;
  }, tCp: function() {
    return A;
  }, Hx7: function() {
    return ce;
  }, imt: function() {
    return ae;
  }, US6: function() {
    return T_;
  }, vZs: function() {
    return Xl;
  }, TE$: function() {
    return VU;
  }, lmu: function() {
    return t.downloadBlob;
  }, SvO: function() {
    return t.downloadFile;
  }, YQY: function() {
    return Qc;
  }, mZN: function() {
    return qc;
  }, VvG: function() {
    return Wc;
  }, omp: function() {
    return t.embedUrlRefs;
  }, utz: function() {
    return Nm;
  }, TFV: function() {
    return Gs;
  }, hrz: function() {
    return t.escapeRegExp;
  }, H$s: function() {
    return x;
  }, JKM: function() {
    return l_;
  }, jZf: function() {
    return pU;
  }, RjL: function() {
    return GO;
  }, RRI: function() {
    return P_;
  }, RUq: function() {
    return WC;
  }, _t4: function() {
    return He;
  }, YHh: function() {
    return Qe;
  }, R8g: function() {
    return D;
  }, f1L: function() {
    return t.getFileHandle;
  }, Bbl: function() {
    return t.getFilenameFromPath;
  }, V9r: function() {
    return t.getKeyByValue;
  }, a95: function() {
    return t.getNewFileHandle;
  }, PZ2: function() {
    return t.getOrCall;
  }, w7A: function() {
    return t.getPropertyDescriptor;
  }, N6S: function() {
    return L;
  }, Uxp: function() {
    return U;
  }, tAz: function() {
    return O;
  }, R$F: function() {
    return N;
  }, N33: function() {
    return F;
  }, JFD: function() {
    return B;
  }, gw2: function() {
    return Ds;
  }, rfc: function() {
    return t.getTypedArray;
  }, wo6: function() {
    return t.getUrlQueryParam;
  }, V4T: function() {
    return Un;
  }, H4P: function() {
    return t.glsl;
  }, NLp: function() {
    return Td;
  }, swA: function() {
    return Vi;
  }, _Z3: function() {
    return Hi;
  }, ivc: function() {
    return Ni;
  }, rZ1: function() {
    return ji;
  }, CpZ: function() {
    return O_;
  }, dyc: function() {
    return t.html;
  }, MxZ: function() {
    return t.htmlToCanvas;
  }, btp: function() {
    return t.htmlToPng;
  }, mXy: function() {
    return t.htmlToSvg;
  }, Ej0: function() {
    return Ae;
  }, ep4: function() {
    return Y;
  }, DQP: function() {
    return xe;
  }, VNr: function() {
    return J;
  }, V7q: function() {
    return t.imageBitmapToBase64;
  }, hiB: function() {
    return t.imageDataToCanvas;
  }, zEk: function() {
    return t.imageToCanvas;
  }, qfq: function() {
    return t.imageUrlToImageData;
  }, piB: function() {
    return t.includesAll;
  }, IIc: function() {
    return RU;
  }, rrF: function() {
    return Oi;
  }, naq: function() {
    return Li;
  }, zlD: function() {
    return b;
  }, sXR: function() {
    return cp;
  }, p5I: function() {
    return Op;
  }, wps: function() {
    return jU;
  }, wuo: function() {
    return zU;
  }, GpE: function() {
    return t.isPropertyWritable;
  }, F4b: function() {
    return pp;
  }, NN$: function() {
    return xd;
  }, t$v: function() {
    return Om;
  }, tdn: function() {
    return Vp;
  }, Y9t: function() {
    return Hp;
  }, GEo: function() {
    return Hc;
  }, GGm: function() {
    return t.longestCommonPrefix;
  }, DH3: function() {
    return Km;
  }, uxM: function() {
    return t.makeColorSvg;
  }, zH3: function() {
    return t.makeColorSvgCircle;
  }, MLs: function() {
    return vt;
  }, xXG: function() {
    return X;
  }, YM4: function() {
    return Bp;
  }, iAx: function() {
    return t.makeTextSvg;
  }, lDn: function() {
    return z;
  }, P1O: function() {
    return v;
  }, iib: function() {
    return I;
  }, qf5: function() {
    return P;
  }, n4s: function() {
    return g;
  }, fr: function() {
    return M;
  }, Z9s: function() {
    return E;
  }, oaQ: function() {
    return jc;
  }, CD7: function() {
    return Au;
  }, Rc0: function() {
    return Hu;
  }, iPG: function() {
    return ap;
  }, TIc: function() {
    return t.mobileAndTabletCheck;
  }, xsC: function() {
    return t_;
  }, zOc: function() {
    return t.now;
  }, i8W: function() {
    return t.objectHasOwn;
  }, r46: function() {
    return v_;
  }, z2C: function() {
    return t.onChange;
  }, N4A: function() {
    return t.onChange2;
  }, hjq: function() {
    return t.onChange3;
  }, _X$: function() {
    return t.parseFileExtension;
  }, _yn: function() {
    return pt;
  }, Dyg: function() {
    return t.pathJoin;
  }, cUc: function() {
    return Pt;
  }, zGw: function() {
    return np;
  }, Ctq: function() {
    return Qm;
  }, $ch: function() {
    return HU;
  }, k5b: function() {
    return Gm;
  }, kZl: function() {
    return s_;
  }, OCg: function() {
    return h_;
  }, Kd3: function() {
    return t.prettyScrollbar;
  }, YjH: function() {
    return R_;
  }, Ui8: function() {
    return Fy;
  }, YD2: function() {
    return wu;
  }, vi9: function() {
    return kU;
  }, ij3: function() {
    return qm;
  }, pJq: function() {
    return t.readFile;
  }, YPW: function() {
    return Vm;
  }, _tY: function() {
    return t.remoteWorkerURL;
  }, Bg1: function() {
    return $L;
  }, kon: function() {
    return t.replaceAll;
  }, M3g: function() {
    return Nc;
  }, F2z: function() {
    return Bm;
  }, pJF: function() {
    return TC;
  }, knz: function() {
    return n.knz;
  }, Ejo: function() {
    return t.safeSetProperty;
  }, BgY: function() {
    return pe;
  }, qCG: function() {
    return ie;
  }, HD9: function() {
    return le;
  }, Rgz: function() {
    return de;
  }, fEB: function() {
    return se;
  }, Udc: function() {
    return we;
  }, ZQg: function() {
    return be;
  }, ofC: function() {
    return H;
  }, yRy: function() {
    return t.setUrlQueryParam;
  }, _NL: function() {
    return xF;
  }, LCA: function() {
    return ye;
  }, Sy1: function() {
    return OL;
  }, Vs_: function() {
    return LL;
  }, j1w: function() {
    return jt;
  }, i8J: function() {
    return AF;
  }, p7C: function() {
    return ot;
  }, Y8s: function() {
    return MU;
  }, ZAS: function() {
    return Wp;
  }, ipH: function() {
    return qU;
  }, $TF: function() {
    return WU;
  }, uZI: function() {
    return XU;
  }, VWG: function() {
    return im;
  }, pQ7: function() {
    return Gp;
  }, STw: function() {
    return yu;
  }, jc8: function() {
    return Tt;
  }, BL_: function() {
    return Fm;
  }, S6: function() {
    return cF;
  }, T8U: function() {
    return ps;
  }, TD6: function() {
    return us;
  }, BTW: function() {
    return TU;
  }, akS: function() {
    return t.svgToCanvas;
  }, QKE: function() {
    return t.svgToPng;
  }, dKx: function() {
    return t.svgUrl;
  }, doP: function() {
    return te;
  }, $jA: function() {
    return $;
  }, T99: function() {
    return ee;
  }, LJS: function() {
    return ne;
  }, VsW: function() {
    return t.timeout;
  }, LZE: function() {
    return T;
  }, YMc: function() {
    return QU;
  }, aPg: function() {
    return q;
  }, LFn: function() {
    return t.toTitleCase;
  }, VsX: function() {
    return C;
  }, wey: function() {
    return km;
  }, MaE: function() {
    return je;
  }, s4x: function() {
    return Ge;
  }, FJA: function() {
    return Be;
  }, vIA: function() {
    return Ne;
  }, Spv: function() {
    return We;
  }, w8l: function() {
    return Ve;
  }, riG: function() {
    return ze;
  }, Kbh: function() {
    return Le;
  }, BFq: function() {
    return qe;
  }, t8K: function() {
    return Ue;
  }, Q7n: function() {
    return Oe;
  }, KGF: function() {
    return Fe;
  }, e5: function() {
    return j;
  }, Rik: function() {
    return Ps;
  }, GZo: function() {
    return Is;
  }, Bds: function() {
    return Ji;
  }, HTu: function() {
    return Zi;
  }, cTq: function() {
    return t.uploadFile;
  }, X_Y: function() {
    return Ct;
  }, dA8: function() {
    return xt;
  }, NSm: function() {
    return Xe;
  }, bwS: function() {
    return Hm;
  }, Lks: function() {
    return YU;
  }, Rvq: function() {
    return IU;
  }, P4F: function() {
    return t.verifyPermission;
  }, Pd0: function() {
    return jn;
  }, Pjo: function() {
    return zm;
  }, Tum: function() {
    return Gn;
  }, dRH: function() {
    return Hn;
  }, RX0: function() {
    return Vn;
  }, reQ: function() {
    return KU;
  }, cWm: function() {
    return $m;
  }, NC9: function() {
    return t.writeFile;
  }, $Re: function() {
    return xs;
  }, Xo9: function() {
    return Es;
  }, LNO: function() {
    return qi;
  }, iZP: function() {
    return Xi;
  } }), function(e2) {
    e2[e2.Error = -2] = "Error", e2[e2.Destroyed = -1] = "Destroyed", e2[e2.None = 0] = "None", e2[e2.Running = 1] = "Running", e2[e2.Paused = 2] = "Paused";
  }(e || (e = {}));
  var t = __webpackgi_require__2(8), n = __webpackgi_require__2(988);
  const r = { name: "CopyShader", uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } }, vertexShader: "\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vUv = uv;\n			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n		}", fragmentShader: "\n\n		uniform float opacity;\n\n		uniform sampler2D tDiffuse;\n\n		varying vec2 vUv;\n\n		void main() {\n\n			gl_FragColor = texture2D( tDiffuse, vUv );\n			gl_FragColor.a *= opacity;\n\n\n		}" };
  class i {
    constructor() {
      this.isPass = true, this.enabled = true, this.needsSwap = true, this.clear = false, this.renderToScreen = false;
    }
    setSize() {
    }
    render() {
      console.error("THREE.Pass: .render() must be implemented in derived pass.");
    }
    dispose() {
    }
  }
  const s = new n.iKG(-1, 1, 1, -1, 0, 1), o = new n.u9r();
  o.setAttribute("position", new n.a$l([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), o.setAttribute("uv", new n.a$l([0, 2, 0, 0, 2, 0], 2));
  class a {
    constructor(e2) {
      this._mesh = new n.Kj0(o, e2);
    }
    dispose() {
      this._mesh.geometry.dispose();
    }
    render(e2) {
      e2.render(this._mesh, s);
    }
    get material() {
      return this._mesh.material;
    }
    set material(e2) {
      this._mesh.material = e2;
    }
  }
  class l extends i {
    constructor(e2, t2) {
      super(), this.textureID = void 0 !== t2 ? t2 : "tDiffuse", e2 instanceof n.jyz ? (this.uniforms = e2.uniforms, this.material = e2) : e2 && (this.uniforms = n.rDY.clone(e2.uniforms), this.material = new n.jyz({ name: void 0 !== e2.name ? e2.name : "unspecified", defines: Object.assign({}, e2.defines), uniforms: this.uniforms, vertexShader: e2.vertexShader, fragmentShader: e2.fragmentShader })), this.fsQuad = new a(this.material), this.useExistingRenderTarget = false;
    }
    render(e2, t2, n2) {
      this.uniforms[this.textureID] && n2 && (this.uniforms[this.textureID].value = n2.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e2.setRenderTarget(null), this.fsQuad.render(e2)) : (this.useExistingRenderTarget || e2.setRenderTarget(t2 || null), this.clear && e2.clear(e2.autoClearColor, e2.autoClearDepth, e2.autoClearStencil), this.fsQuad.render(e2));
    }
    dispose() {
      this.material.dispose(), this.fsQuad.dispose();
    }
  }
  class c extends i {
    constructor(e2, t2) {
      super(), this.scene = e2, this.camera = t2, this.clear = true, this.needsSwap = false, this.inverse = false;
    }
    render(e2, t2, n2) {
      const r2 = e2.getContext(), i2 = e2.state;
      let s2, o2;
      i2.buffers.color.setMask(false), i2.buffers.depth.setMask(false), i2.buffers.color.setLocked(true), i2.buffers.depth.setLocked(true), this.inverse ? (s2 = 0, o2 = 1) : (s2 = 1, o2 = 0), i2.buffers.stencil.setTest(true), i2.buffers.stencil.setOp(r2.REPLACE, r2.REPLACE, r2.REPLACE), i2.buffers.stencil.setFunc(r2.ALWAYS, s2, 4294967295), i2.buffers.stencil.setClear(o2), i2.buffers.stencil.setLocked(true), e2.setRenderTarget(n2), this.clear && e2.clear(), e2.render(this.scene, this.camera), e2.setRenderTarget(t2), this.clear && e2.clear(), e2.render(this.scene, this.camera), i2.buffers.color.setLocked(false), i2.buffers.depth.setLocked(false), i2.buffers.stencil.setLocked(false), i2.buffers.stencil.setFunc(r2.EQUAL, 1, 4294967295), i2.buffers.stencil.setOp(r2.KEEP, r2.KEEP, r2.KEEP), i2.buffers.stencil.setLocked(true);
    }
  }
  class u extends i {
    constructor() {
      super(), this.needsSwap = false;
    }
    render(e2) {
      e2.state.buffers.stencil.setLocked(false), e2.state.buffers.stencil.setTest(false);
    }
  }
  class p {
    constructor(e2, t2) {
      if (this.renderer = e2, this._pixelRatio = e2.getPixelRatio(), void 0 === t2) {
        const r2 = e2.getSize(new n.FM8());
        this._width = r2.width, this._height = r2.height, (t2 = new n.dd2(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: n.cLu })).texture.name = "EffectComposer.rt1";
      } else
        this._width = t2.width, this._height = t2.height;
      this.renderTarget1 = t2, this.renderTarget2 = t2.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = true, this.passes = [], this.copyPass = new l(r), this.clock = new n.SUY();
    }
    swapBuffers() {
      const e2 = this.readBuffer;
      this.readBuffer = this.writeBuffer, this.writeBuffer = e2;
    }
    addPass(e2) {
      this.passes.push(e2), e2.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    insertPass(e2, t2) {
      this.passes.splice(t2, 0, e2), e2.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    removePass(e2) {
      const t2 = this.passes.indexOf(e2);
      -1 !== t2 && this.passes.splice(t2, 1);
    }
    isLastEnabledPass(e2) {
      for (let t2 = e2 + 1; t2 < this.passes.length; t2++)
        if (this.passes[t2].enabled)
          return false;
      return true;
    }
    render(e2) {
      void 0 === e2 && (e2 = this.clock.getDelta());
      const t2 = this.renderer.getRenderTarget();
      let n2 = false;
      for (let t3 = 0, r2 = this.passes.length; t3 < r2; t3++) {
        const r3 = this.passes[t3];
        if (false !== r3.enabled) {
          if (r3.renderToScreen = this.renderToScreen && this.isLastEnabledPass(t3), r3.render(this.renderer, this.writeBuffer, this.readBuffer, e2, n2), r3.needsSwap) {
            if (n2) {
              const t4 = this.renderer.getContext(), n3 = this.renderer.state.buffers.stencil;
              n3.setFunc(t4.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e2), n3.setFunc(t4.EQUAL, 1, 4294967295);
            }
            this.swapBuffers();
          }
          void 0 !== c && (r3 instanceof c ? n2 = true : r3 instanceof u && (n2 = false));
        }
      }
      this.renderer.setRenderTarget(t2);
    }
    reset(e2) {
      if (void 0 === e2) {
        const t2 = this.renderer.getSize(new n.FM8());
        this._pixelRatio = this.renderer.getPixelRatio(), this._width = t2.width, this._height = t2.height, (e2 = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
      }
      this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e2, this.renderTarget2 = e2.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
    }
    setSize(e2, t2) {
      this._width = e2, this._height = t2;
      const n2 = this._width * this._pixelRatio, r2 = this._height * this._pixelRatio;
      this.renderTarget1.setSize(n2, r2), this.renderTarget2.setSize(n2, r2);
      for (let e3 = 0; e3 < this.passes.length; e3++)
        this.passes[e3].setSize(n2, r2);
    }
    setPixelRatio(e2) {
      this._pixelRatio = e2, this.setSize(this._width, this._height);
    }
    dispose() {
      this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose();
    }
  }
  class d extends p {
    constructor(e2, t2) {
      super(e2, t2);
    }
    setPixelRatio(e2, t2 = true) {
      const n2 = this.setSize;
      t2 || (this.setSize = () => {
      }), super.setPixelRatio(e2), t2 || (this.setSize = n2);
    }
  }
  class h extends n.ZzF {
    expandByObject(e2, t2 = false, n2 = false, r2) {
      var i2;
      if (false === (null === (i2 = e2.userData) || void 0 === i2 ? void 0 : i2.bboxVisible))
        return this;
      if (!e2.visible && n2)
        return this;
      if (r2 && r2(e2))
        return this;
      if (e2.updateWorldMatrix(false, false), void 0 !== e2.boundingBox)
        null === e2.boundingBox && e2.computeBoundingBox(), f.copy(e2.boundingBox), f.applyMatrix4(e2.matrixWorld), this.union(f);
      else {
        const n3 = e2.geometry;
        if (void 0 !== n3)
          if (t2 && null != n3.attributes && void 0 !== n3.attributes.position) {
            const t3 = n3.attributes.position;
            for (let n4 = 0, r3 = t3.count; n4 < r3; n4++)
              m.fromBufferAttribute(t3, n4).applyMatrix4(e2.matrixWorld), this.expandByPoint(m);
          } else
            null === n3.boundingBox && n3.computeBoundingBox(), f.copy(n3.boundingBox), f.applyMatrix4(e2.matrixWorld), this.union(f);
      }
      const s2 = e2.children;
      for (let e3 = 0, i3 = s2.length; e3 < i3; e3++)
        this.expandByObject(s2[e3], t2, n2, r2);
      return this;
    }
    expandByObjects(e2, t2 = false, n2 = false, r2) {
      for (let i2 = 0, s2 = e2.length; i2 < s2; i2++)
        this.expandByObject(e2[i2], t2, n2, r2);
      return this;
    }
    getPoints() {
      return [new n.Pa4(this.min.x, this.min.y, this.min.z), new n.Pa4(this.min.x, this.min.y, this.max.z), new n.Pa4(this.min.x, this.max.y, this.min.z), new n.Pa4(this.min.x, this.max.y, this.max.z), new n.Pa4(this.max.x, this.min.y, this.min.z), new n.Pa4(this.max.x, this.min.y, this.max.z), new n.Pa4(this.max.x, this.max.y, this.min.z), new n.Pa4(this.max.x, this.max.y, this.max.z)];
    }
    getScreenSpaceBounds(e2) {
      const t2 = this.getPoints(), r2 = new n.TUj();
      for (const n2 of t2) {
        const t3 = n2.project(e2);
        r2.min.min(t3), r2.max.max(t3);
      }
      return r2;
    }
  }
  const f = new h(), m = new n.Pa4();
  function _(e2, t2, r2 = true) {
    if (!t2 || !t2.isReady)
      throw new Error("BufferGeometryUtils: Initialized MikkTSpace library required.");
    if (!e2.hasAttribute("position") || !e2.hasAttribute("normal") || !e2.hasAttribute("uv"))
      throw new Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');
    function i2(e3) {
      if (e3.normalized || e3.isInterleavedBufferAttribute) {
        const t3 = new Float32Array(e3.count * e3.itemSize);
        for (let n2 = 0, r3 = 0; n2 < e3.count; n2++)
          t3[r3++] = e3.getX(n2), t3[r3++] = e3.getY(n2), e3.itemSize > 2 && (t3[r3++] = e3.getZ(n2));
        return t3;
      }
      return e3.array instanceof Float32Array ? e3.array : new Float32Array(e3.array);
    }
    const s2 = e2.index ? e2.toNonIndexed() : e2, o2 = t2.generateTangents(i2(s2.attributes.position), i2(s2.attributes.normal), i2(s2.attributes.uv));
    if (r2)
      for (let e3 = 3; e3 < o2.length; e3 += 4)
        o2[e3] *= -1;
    return s2.setAttribute("tangent", new n.TlE(o2, 4)), e2 !== s2 && e2.copy(s2), e2;
  }
  function g(e2, t2 = false) {
    const r2 = null !== e2[0].index, i2 = new Set(Object.keys(e2[0].attributes)), s2 = new Set(Object.keys(e2[0].morphAttributes)), o2 = {}, a2 = {}, l2 = e2[0].morphTargetsRelative, c2 = new n.u9r();
    let u2 = 0;
    for (let n2 = 0; n2 < e2.length; ++n2) {
      const p2 = e2[n2];
      let d2 = 0;
      if (r2 !== (null !== p2.index))
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + n2 + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null;
      for (const e3 in p2.attributes) {
        if (!i2.has(e3))
          return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + n2 + '. All geometries must have compatible attributes; make sure "' + e3 + '" attribute exists among all geometries, or in none of them.'), null;
        void 0 === o2[e3] && (o2[e3] = []), o2[e3].push(p2.attributes[e3]), d2++;
      }
      if (d2 !== i2.size)
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + n2 + ". Make sure all geometries have the same number of attributes."), null;
      if (l2 !== p2.morphTargetsRelative)
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + n2 + ". .morphTargetsRelative must be consistent throughout all geometries."), null;
      for (const e3 in p2.morphAttributes) {
        if (!s2.has(e3))
          return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + n2 + ".  .morphAttributes must be consistent throughout all geometries."), null;
        void 0 === a2[e3] && (a2[e3] = []), a2[e3].push(p2.morphAttributes[e3]);
      }
      if (t2) {
        let e3;
        if (r2)
          e3 = p2.index.count;
        else {
          if (void 0 === p2.attributes.position)
            return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + n2 + ". The geometry must have either an index or a position attribute"), null;
          e3 = p2.attributes.position.count;
        }
        c2.addGroup(u2, e3, n2), u2 += e3;
      }
    }
    if (r2) {
      let t3 = 0;
      const n2 = [];
      for (let r3 = 0; r3 < e2.length; ++r3) {
        const i3 = e2[r3].index;
        for (let e3 = 0; e3 < i3.count; ++e3)
          n2.push(i3.getX(e3) + t3);
        t3 += e2[r3].attributes.position.count;
      }
      c2.setIndex(n2);
    }
    for (const e3 in o2) {
      const t3 = v(o2[e3]);
      if (!t3)
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + e3 + " attribute."), null;
      c2.setAttribute(e3, t3);
    }
    for (const e3 in a2) {
      const t3 = a2[e3][0].length;
      if (0 === t3)
        break;
      c2.morphAttributes = c2.morphAttributes || {}, c2.morphAttributes[e3] = [];
      for (let n2 = 0; n2 < t3; ++n2) {
        const t4 = [];
        for (let r4 = 0; r4 < a2[e3].length; ++r4)
          t4.push(a2[e3][r4][n2]);
        const r3 = v(t4);
        if (!r3)
          return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + e3 + " morphAttribute."), null;
        c2.morphAttributes[e3].push(r3);
      }
    }
    return c2;
  }
  function v(e2) {
    let t2, r2, i2, s2 = -1, o2 = 0;
    for (let n2 = 0; n2 < e2.length; ++n2) {
      const a3 = e2[n2];
      if (a3.isInterleavedBufferAttribute)
        return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported."), null;
      if (void 0 === t2 && (t2 = a3.array.constructor), t2 !== a3.array.constructor)
        return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null;
      if (void 0 === r2 && (r2 = a3.itemSize), r2 !== a3.itemSize)
        return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null;
      if (void 0 === i2 && (i2 = a3.normalized), i2 !== a3.normalized)
        return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null;
      if (-1 === s2 && (s2 = a3.gpuType), s2 !== a3.gpuType)
        return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."), null;
      o2 += a3.array.length;
    }
    const a2 = new t2(o2);
    let l2 = 0;
    for (let t3 = 0; t3 < e2.length; ++t3)
      a2.set(e2[t3].array, l2), l2 += e2[t3].array.length;
    const c2 = new n.TlE(a2, r2, i2);
    return void 0 !== s2 && (c2.gpuType = s2), c2;
  }
  function y(e2) {
    return e2.isInstancedInterleavedBufferAttribute || e2.isInterleavedBufferAttribute ? w(e2) : e2.isInstancedBufferAttribute ? new n.lb7().copy(e2) : new n.TlE().copy(e2);
  }
  function b(e2) {
    let t2, r2 = 0, i2 = 0;
    for (let n2 = 0, s3 = e2.length; n2 < s3; ++n2) {
      const s4 = e2[n2];
      if (void 0 === t2 && (t2 = s4.array.constructor), t2 !== s4.array.constructor)
        return console.error("AttributeBuffers of different types cannot be interleaved"), null;
      r2 += s4.array.length, i2 += s4.itemSize;
    }
    const s2 = new n.vpT(new t2(r2), i2);
    let o2 = 0;
    const a2 = [], l2 = ["getX", "getY", "getZ", "getW"], c2 = ["setX", "setY", "setZ", "setW"];
    for (let t3 = 0, r3 = e2.length; t3 < r3; t3++) {
      const r4 = e2[t3], i3 = r4.itemSize, u2 = r4.count, p2 = new n.kB5(s2, i3, o2, r4.normalized);
      a2.push(p2), o2 += i3;
      for (let e3 = 0; e3 < u2; e3++)
        for (let t4 = 0; t4 < i3; t4++)
          p2[c2[t4]](e3, r4[l2[t4]](e3));
    }
    return a2;
  }
  function w(e2) {
    const t2 = e2.data.array.constructor, r2 = e2.count, i2 = e2.itemSize, s2 = e2.normalized, o2 = new t2(r2 * i2);
    let a2;
    a2 = e2.isInstancedInterleavedBufferAttribute ? new n.lb7(o2, i2, s2, e2.meshPerAttribute) : new n.TlE(o2, i2, s2);
    for (let t3 = 0; t3 < r2; t3++)
      a2.setX(t3, e2.getX(t3)), i2 >= 2 && a2.setY(t3, e2.getY(t3)), i2 >= 3 && a2.setZ(t3, e2.getZ(t3)), i2 >= 4 && a2.setW(t3, e2.getW(t3));
    return a2;
  }
  function A(e2) {
    const t2 = e2.attributes, n2 = e2.morphTargets, r2 = /* @__PURE__ */ new Map();
    for (const e3 in t2) {
      const n3 = t2[e3];
      n3.isInterleavedBufferAttribute && (r2.has(n3) || r2.set(n3, w(n3)), t2[e3] = r2.get(n3));
    }
    for (const e3 in n2) {
      const t3 = n2[e3];
      t3.isInterleavedBufferAttribute && (r2.has(t3) || r2.set(t3, w(t3)), n2[e3] = r2.get(t3));
    }
  }
  function x(e2) {
    let t2 = 0;
    for (const n3 in e2.attributes) {
      const r2 = e2.getAttribute(n3);
      t2 += r2.count * r2.itemSize * r2.array.BYTES_PER_ELEMENT;
    }
    const n2 = e2.getIndex();
    return t2 += n2 ? n2.count * n2.itemSize * n2.array.BYTES_PER_ELEMENT : 0, t2;
  }
  function E(e2, t2 = 1e-4) {
    const r2 = t2 > 0;
    t2 = Math.max(t2, Number.EPSILON);
    const i2 = {}, s2 = e2.getIndex(), o2 = e2.getAttribute("position"), a2 = s2 ? s2.count : o2.count;
    let l2 = 0;
    const c2 = Object.keys(e2.attributes), u2 = {}, p2 = {}, d2 = [], h2 = ["getX", "getY", "getZ", "getW"], f2 = ["setX", "setY", "setZ", "setW"];
    for (let t3 = 0, r3 = c2.length; t3 < r3; t3++) {
      const r4 = c2[t3], i3 = e2.attributes[r4];
      u2[r4] = new n.TlE(new i3.array.constructor(i3.count * i3.itemSize), i3.itemSize, i3.normalized);
      const s3 = e2.morphAttributes[r4];
      s3 && (p2[r4] = new n.TlE(new s3.array.constructor(s3.count * s3.itemSize), s3.itemSize, s3.normalized));
    }
    const m2 = Math.log10(1 / t2), _2 = Math.pow(10, m2);
    for (let t3 = 0; t3 < a2; t3++) {
      const n2 = s2 ? s2.getX(t3) : t3;
      let o3 = "";
      for (let t4 = 0, i3 = c2.length; t4 < i3 && r2; t4++) {
        const r3 = c2[t4], i4 = e2.getAttribute(r3), s3 = i4.itemSize;
        for (let e3 = 0; e3 < s3; e3++)
          o3 += ~~(i4[h2[e3]](n2) * _2) + ",";
      }
      if (r2 && o3 in i2)
        d2.push(i2[o3]);
      else {
        for (let t4 = 0, r3 = c2.length; t4 < r3; t4++) {
          const r4 = c2[t4], i3 = e2.getAttribute(r4), s3 = e2.morphAttributes[r4], o4 = i3.itemSize, a3 = u2[r4], d3 = p2[r4];
          for (let e3 = 0; e3 < o4; e3++) {
            const t5 = h2[e3], r5 = f2[e3];
            if (a3[r5](l2, i3[t5](n2)), s3)
              for (let e4 = 0, i4 = s3.length; e4 < i4; e4++)
                d3[e4][r5](l2, s3[e4][t5](n2));
          }
        }
        r2 && (i2[o3] = l2), d2.push(l2), l2++;
      }
    }
    const g2 = e2.clone();
    for (const t3 in e2.attributes) {
      const e3 = u2[t3];
      if (g2.setAttribute(t3, new n.TlE(e3.array.slice(0, l2 * e3.itemSize), e3.itemSize, e3.normalized)), t3 in p2)
        for (let e4 = 0; e4 < p2[t3].length; e4++) {
          const r3 = p2[t3][e4];
          g2.morphAttributes[t3][e4] = new n.TlE(r3.array.slice(0, l2 * r3.itemSize), r3.itemSize, r3.normalized);
        }
    }
    return g2.setIndex(d2), g2;
  }
  function C(e2, t2) {
    if (t2 === n.WwZ)
      return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), e2;
    if (t2 === n.z$h || t2 === n.UlW) {
      let r2 = e2.getIndex();
      if (null === r2) {
        const t3 = [], n2 = e2.getAttribute("position");
        if (void 0 === n2)
          return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e2;
        for (let e3 = 0; e3 < n2.count; e3++)
          t3.push(e3);
        e2.setIndex(t3), r2 = e2.getIndex();
      }
      const i2 = r2.count - 2, s2 = [];
      if (t2 === n.z$h)
        for (let e3 = 1; e3 <= i2; e3++)
          s2.push(r2.getX(0)), s2.push(r2.getX(e3)), s2.push(r2.getX(e3 + 1));
      else
        for (let e3 = 0; e3 < i2; e3++)
          e3 % 2 == 0 ? (s2.push(r2.getX(e3)), s2.push(r2.getX(e3 + 1)), s2.push(r2.getX(e3 + 2))) : (s2.push(r2.getX(e3 + 2)), s2.push(r2.getX(e3 + 1)), s2.push(r2.getX(e3)));
      s2.length / 3 !== i2 && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
      const o2 = e2.clone();
      return o2.setIndex(s2), o2.clearGroups(), o2;
    }
    return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", t2), e2;
  }
  function S(e2) {
    const t2 = new n.Pa4(), r2 = new n.Pa4(), i2 = new n.Pa4(), s2 = new n.Pa4(), o2 = new n.Pa4(), a2 = new n.Pa4(), l2 = new n.Pa4(), c2 = new n.Pa4(), u2 = new n.Pa4();
    function p2(e3, n2, p3, d3, h3, f3, m3, _3) {
      t2.fromBufferAttribute(n2, h3), r2.fromBufferAttribute(n2, f3), i2.fromBufferAttribute(n2, m3);
      const g3 = e3.morphTargetInfluences;
      if (p3 && g3) {
        l2.set(0, 0, 0), c2.set(0, 0, 0), u2.set(0, 0, 0);
        for (let e4 = 0, n3 = p3.length; e4 < n3; e4++) {
          const n4 = g3[e4], _4 = p3[e4];
          0 !== n4 && (s2.fromBufferAttribute(_4, h3), o2.fromBufferAttribute(_4, f3), a2.fromBufferAttribute(_4, m3), d3 ? (l2.addScaledVector(s2, n4), c2.addScaledVector(o2, n4), u2.addScaledVector(a2, n4)) : (l2.addScaledVector(s2.sub(t2), n4), c2.addScaledVector(o2.sub(r2), n4), u2.addScaledVector(a2.sub(i2), n4)));
        }
        t2.add(l2), r2.add(c2), i2.add(u2);
      }
      e3.isSkinnedMesh && (e3.applyBoneTransform(h3, t2), e3.applyBoneTransform(f3, r2), e3.applyBoneTransform(m3, i2)), _3[3 * h3 + 0] = t2.x, _3[3 * h3 + 1] = t2.y, _3[3 * h3 + 2] = t2.z, _3[3 * f3 + 0] = r2.x, _3[3 * f3 + 1] = r2.y, _3[3 * f3 + 2] = r2.z, _3[3 * m3 + 0] = i2.x, _3[3 * m3 + 1] = i2.y, _3[3 * m3 + 2] = i2.z;
    }
    const d2 = e2.geometry, h2 = e2.material;
    let f2, m2, _2;
    const g2 = d2.index, v2 = d2.attributes.position, y2 = d2.morphAttributes.position, b2 = d2.morphTargetsRelative, w2 = d2.attributes.normal, A2 = d2.morphAttributes.position, x2 = d2.groups, E2 = d2.drawRange;
    let C2, S2, M2, T2, P2, I2, R2;
    const k2 = new Float32Array(v2.count * v2.itemSize), D2 = new Float32Array(w2.count * w2.itemSize);
    if (null !== g2)
      if (Array.isArray(h2))
        for (C2 = 0, M2 = x2.length; C2 < M2; C2++)
          for (P2 = x2[C2], I2 = Math.max(P2.start, E2.start), R2 = Math.min(P2.start + P2.count, E2.start + E2.count), S2 = I2, T2 = R2; S2 < T2; S2 += 3)
            f2 = g2.getX(S2), m2 = g2.getX(S2 + 1), _2 = g2.getX(S2 + 2), p2(e2, v2, y2, b2, f2, m2, _2, k2), p2(e2, w2, A2, b2, f2, m2, _2, D2);
      else
        for (I2 = Math.max(0, E2.start), R2 = Math.min(g2.count, E2.start + E2.count), C2 = I2, M2 = R2; C2 < M2; C2 += 3)
          f2 = g2.getX(C2), m2 = g2.getX(C2 + 1), _2 = g2.getX(C2 + 2), p2(e2, v2, y2, b2, f2, m2, _2, k2), p2(e2, w2, A2, b2, f2, m2, _2, D2);
    else if (Array.isArray(h2))
      for (C2 = 0, M2 = x2.length; C2 < M2; C2++)
        for (P2 = x2[C2], I2 = Math.max(P2.start, E2.start), R2 = Math.min(P2.start + P2.count, E2.start + E2.count), S2 = I2, T2 = R2; S2 < T2; S2 += 3)
          f2 = S2, m2 = S2 + 1, _2 = S2 + 2, p2(e2, v2, y2, b2, f2, m2, _2, k2), p2(e2, w2, A2, b2, f2, m2, _2, D2);
    else
      for (I2 = Math.max(0, E2.start), R2 = Math.min(v2.count, E2.start + E2.count), C2 = I2, M2 = R2; C2 < M2; C2 += 3)
        f2 = C2, m2 = C2 + 1, _2 = C2 + 2, p2(e2, v2, y2, b2, f2, m2, _2, k2), p2(e2, w2, A2, b2, f2, m2, _2, D2);
    return { positionAttribute: v2, normalAttribute: w2, morphedPositionAttribute: new n.a$l(k2, 3), morphedNormalAttribute: new n.a$l(D2, 3) };
  }
  function M(e2) {
    if (0 === e2.groups.length)
      return console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge."), e2;
    let t2 = e2.groups;
    if (t2 = t2.sort((e3, t3) => e3.materialIndex !== t3.materialIndex ? e3.materialIndex - t3.materialIndex : e3.start - t3.start), null === e2.getIndex()) {
      const t3 = e2.getAttribute("position"), n3 = [];
      for (let e3 = 0; e3 < t3.count; e3 += 3)
        n3.push(e3, e3 + 1, e3 + 2);
      e2.setIndex(n3);
    }
    const n2 = e2.getIndex(), r2 = [];
    for (let e3 = 0; e3 < t2.length; e3++) {
      const i3 = t2[e3], s3 = i3.start, o2 = s3 + i3.count;
      for (let e4 = s3; e4 < o2; e4++)
        r2.push(n2.getX(e4));
    }
    e2.dispose(), e2.setIndex(r2);
    let i2 = 0;
    for (let e3 = 0; e3 < t2.length; e3++) {
      const n3 = t2[e3];
      n3.start = i2, i2 += n3.count;
    }
    let s2 = t2[0];
    e2.groups = [s2];
    for (let n3 = 1; n3 < t2.length; n3++) {
      const r3 = t2[n3];
      s2.materialIndex === r3.materialIndex ? s2.count += r3.count : (s2 = r3, e2.groups.push(s2));
    }
    return e2;
  }
  function T(e2, t2 = Math.PI / 3) {
    const r2 = Math.cos(t2), i2 = 100 * (1 + 1e-10), s2 = [new n.Pa4(), new n.Pa4(), new n.Pa4()], o2 = new n.Pa4(), a2 = new n.Pa4(), l2 = new n.Pa4(), c2 = new n.Pa4();
    function u2(e3) {
      return `${~~(e3.x * i2)},${~~(e3.y * i2)},${~~(e3.z * i2)}`;
    }
    const p2 = e2.toNonIndexed(), d2 = p2.attributes.position, h2 = {};
    for (let e3 = 0, t3 = d2.count / 3; e3 < t3; e3++) {
      const t4 = 3 * e3, r3 = s2[0].fromBufferAttribute(d2, t4 + 0), i3 = s2[1].fromBufferAttribute(d2, t4 + 1), l3 = s2[2].fromBufferAttribute(d2, t4 + 2);
      o2.subVectors(l3, i3), a2.subVectors(r3, i3);
      const c3 = new n.Pa4().crossVectors(o2, a2).normalize();
      for (let e4 = 0; e4 < 3; e4++) {
        const t5 = u2(s2[e4]);
        t5 in h2 || (h2[t5] = []), h2[t5].push(c3);
      }
    }
    const f2 = new Float32Array(3 * d2.count), m2 = new n.TlE(f2, 3, false);
    for (let e3 = 0, t3 = d2.count / 3; e3 < t3; e3++) {
      const t4 = 3 * e3, n2 = s2[0].fromBufferAttribute(d2, t4 + 0), i3 = s2[1].fromBufferAttribute(d2, t4 + 1), p3 = s2[2].fromBufferAttribute(d2, t4 + 2);
      o2.subVectors(p3, i3), a2.subVectors(n2, i3), l2.crossVectors(o2, a2).normalize();
      for (let e4 = 0; e4 < 3; e4++) {
        const n3 = h2[u2(s2[e4])];
        c2.set(0, 0, 0);
        for (let e5 = 0, t5 = n3.length; e5 < t5; e5++) {
          const t6 = n3[e5];
          l2.dot(t6) > r2 && c2.add(t6);
        }
        c2.normalize(), m2.setXYZ(t4 + e4, c2.x, c2.y, c2.z);
      }
    }
    return p2.setAttribute("normal", m2), p2;
  }
  function P(e2, t2 = false) {
    return console.warn("THREE.BufferGeometryUtils: mergeBufferGeometries() has been renamed to mergeGeometries()."), g(e2, t2);
  }
  function I(e2) {
    return console.warn("THREE.BufferGeometryUtils: mergeBufferAttributes() has been renamed to mergeAttributes()."), v(e2);
  }
  function R(e2, t2) {
    let r2, i2;
    if (Array.isArray(e2))
      for (const n2 of e2) {
        const e3 = R(n2, t2);
        void 0 === r2 || void 0 === i2 ? (r2 = e3.min.clone(), i2 = e3.max.clone()) : (r2.min(e3.min), i2.max(e3.max));
      }
    const s2 = e2;
    if (void 0 !== s2.geometry) {
      const o2 = s2.geometry.vertices;
      if (void 0 === o2 && void 0 !== s2.geometry.attributes && "position" in s2.geometry.attributes) {
        const o3 = new n.Pa4(), a2 = s2.geometry.attributes.position;
        for (let s3 = 0; s3 < a2.count * a2.itemSize; s3 += a2.itemSize) {
          o3.set(a2.array[s3], a2.array[s3 + 1], a2.array[3]);
          const l2 = o3.applyMatrix4(e2.matrixWorld).project(t2), c2 = new n.FM8(l2.x, l2.y);
          void 0 === r2 || void 0 === i2 ? (r2 = c2.clone(), i2 = c2.clone()) : (r2.min(c2), i2.max(c2));
        }
      } else
        for (const s3 of o2) {
          const o3 = s3.clone().applyMatrix4(e2.matrixWorld).project(t2), a2 = new n.FM8(o3.x, o3.y);
          void 0 === r2 || void 0 === i2 ? (r2 = a2.clone(), i2 = a2.clone()) : (r2.min(a2), i2.max(a2));
        }
    }
    if (void 0 !== e2.children)
      for (const n2 of e2.children) {
        const e3 = R(n2, t2);
        void 0 === r2 || void 0 === i2 ? (r2 = e3.min.clone(), i2 = e3.max.clone()) : (r2.min(e3.min), i2.max(e3.max));
      }
    return new n.TUj(r2, i2);
  }
  const k = "rgbm-16";
  function D(e2) {
    switch (e2) {
      case n.aCh:
      case n.GUF:
        return ["Linear", "( value )"];
      case n.KI_:
        return ["sRGB", "( value )"];
      case k:
        return ["RGBM", "( value, 16.0 )"];
      default:
        return console.warn("utils: Unsupported colorSpace:", e2), ["Linear", "( value )"];
    }
  }
  function B(e2, t2) {
    let r2;
    return e2 && e2.isTexture ? r2 = e2.colorSpace : e2 && e2.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), r2 = e2.texture.colorSpace) : r2 = n.GUF, t2 && e2 && e2.isTexture && e2.format === n.wk1 && e2.type === n.ywz && e2.colorSpace === n.KI_ && (r2 = n.GUF), r2;
  }
  function O(e2, t2) {
    const n2 = D(t2);
    return "vec4 " + e2 + "( vec4 value ) { return " + n2[0] + "ToLinear" + n2[1] + "; }";
  }
  function L(e2, t2, n2) {
    return O(e2 + "TexelToLinear", B(t2, n2)) + "\n";
  }
  function U(e2, t2) {
    return O(e2 + "TexelToLinear", t2) + "\n";
  }
  function F(e2, t2) {
    const n2 = D(t2);
    return "vec4 " + e2 + "( vec4 value ) { return LinearTo" + n2[0] + n2[1] + "; }";
  }
  function N(e2, t2, n2) {
    return F(e2, B(t2, n2));
  }
  function j({ uniforms: e2, propKey: n2, thisTarget: r2 = false } = {}) {
    const i2 = !!e2, s2 = !!n2, o2 = r2;
    return (r3, a2) => {
      const l2 = (t2) => {
        const r4 = o2 ? t2 : i2 ? e2 : t2.uniforms || t2._uniforms;
        let l3 = s2 ? n2 : a2;
        o2 && (l3 = "_" + l3);
        let c2 = r4[l3];
        return c2 || (c2 = { value: null }, r4[l3] = c2), c2;
      };
      Object.defineProperty(r3, a2, { get() {
        return l2(this).value;
      }, set(e3) {
        l2(this).value = e3, (0, t.safeSetProperty)(this, "uniformsNeedUpdate", true, true);
      } });
    };
  }
  function z(e2, n2, r2 = false, i2) {
    const s2 = !!n2, o2 = !!e2;
    return (a2, l2) => {
      const c2 = (t2) => ({ t: s2 ? n2 : t2.defines || t2._defines, p: o2 ? e2 : l2 });
      Object.defineProperty(a2, l2, { get() {
        const { t: e3, p: t2 } = c2(r2 ? this : this.material);
        return e3[t2];
      }, set(e3) {
        const { t: n3, p: s3 } = c2(r2 ? this : this.material);
        if ((0, t.safeSetProperty)(n3, s3, e3, true), "function" == typeof i2) {
          const t2 = [s3, e3];
          if (i2.name) {
            const e4 = this[i2.name];
            e4 === i2 ? i2.call(this, ...t2) : e4.name === `bound ${i2.name}` ? e4(...t2) : i2(...t2);
          } else
            i2(...t2);
        } else
          (0, t.safeSetProperty)(r2 ? this : this.material, "needsUpdate", true, true);
      } });
    };
  }
  function G(e2) {
    const t2 = new n.IEO(new Uint8Array([Math.floor(255 * e2.r), Math.floor(255 * e2.g), Math.floor(255 * e2.b), 255]), 1, 1, n.wk1, n.ywz);
    return t2.needsUpdate = true, t2.colorSpace = n.aCh, t2;
  }
  function V(e2) {
    const t2 = new n.IEO(new Uint8Array([Math.floor(255 * e2.x), Math.floor(255 * e2.y), Math.floor(255 * e2.z), Math.floor(255 * e2.w)]), 1, 1, n.wk1, n.ywz);
    return t2.needsUpdate = true, t2;
  }
  function H(e2, t2, n2) {
    const r2 = e2.userData, { backgroundRender: i2, transparentRender: s2, shadowMapRender: o2, mainRenderPass: a2, opaqueRender: l2, transmissionRender: c2, sceneRender: u2, screenSpaceRendering: p2 } = r2;
    void 0 !== t2.backgroundRender && (r2.backgroundRender = t2.backgroundRender), void 0 !== t2.transparentRender && (r2.transparentRender = t2.transparentRender), void 0 !== t2.shadowMapRender && (r2.shadowMapRender = t2.shadowMapRender), void 0 !== t2.mainRenderPass && (r2.mainRenderPass = t2.mainRenderPass), void 0 !== t2.opaqueRender && (r2.opaqueRender = t2.opaqueRender), void 0 !== t2.sceneRender && (r2.sceneRender = t2.sceneRender), void 0 !== t2.transmissionRender && (r2.transmissionRender = t2.transmissionRender), void 0 !== t2.screenSpaceRendering && (r2.screenSpaceRendering = t2.screenSpaceRendering), n2(), r2.backgroundRender = i2, r2.transparentRender = s2, r2.shadowMapRender = o2, r2.mainRenderPass = a2, r2.opaqueRender = l2, r2.sceneRender = u2, r2.transmissionRender = c2, r2.screenSpaceRendering = p2;
  }
  function Q(e2) {
    const t2 = new h().expandByObject(e2, true, true).getCenter(new n.Pa4());
    e2.position.sub(t2), e2.updateMatrix(), e2.userData.autoCentered = true, e2.userData.isCentered = true;
  }
  function W(e2, t2, r2) {
    const i2 = 0.5 * new h().expandByObject(e2, true, true).getSize(new n.Pa4()).length();
    void 0 === t2 && (t2 = e2.userData.autoScaleRadius || 1);
    const s2 = t2 / i2;
    return isFinite(s2) && (e2.userData.pseudoCentered ? e2.children.forEach((e3) => {
      e3.scale.multiplyScalar(s2);
    }) : e2.scale.multiplyScalar(s2), (r2 || e2.userData.isCentered) && e2.position.multiplyScalar(s2), e2.traverse((e3) => {
      var t3, n2;
      e3.isLight && (null === (n2 = null === (t3 = e3.shadow) || void 0 === t3 ? void 0 : t3.camera) || void 0 === n2 ? void 0 : n2.right) && (e3.shadow.camera.right *= s2, e3.shadow.camera.left *= s2, e3.shadow.camera.top *= s2, e3.shadow.camera.bottom *= s2), e3.isCamera && e3.right && (e3.right *= s2, e3.left *= s2, e3.top *= s2, e3.bottom *= s2);
    }), e2.userData.autoScaled = true, e2.userData.autoScaleRadius = t2, e2.dispatchEvent({ type: "objectUpdate" })), e2;
  }
  function q(e2, t2 = -1) {
    return E(e2, t2);
  }
  function X(e2, t2) {
    return { type: "folder", label: t2 + " Sampler", hidden: () => !e2[t2], children: [() => ({ type: "vec2", label: "Repeat", bounds: [-100, 100], stepSize: 1e-3, property: [e2[t2], "repeat"], onChange: null == e2 ? void 0 : e2.setDirty }), () => ({ type: "vec2", label: "Offset", bounds: [-2, 2], stepSize: 1e-3, property: [e2[t2], "offset"], onChange: null == e2 ? void 0 : e2.setDirty }), () => ({ type: "vec2", label: "Center", bounds: [-2, 2], stepSize: 1e-3, property: [e2[t2], "center"], onChange: null == e2 ? void 0 : e2.setDirty }), () => ({ type: "input", label: "Rotation", stepSize: 1e-3, bounds: [-Math.PI, Math.PI], property: [e2[t2], "rotation"], onChange: null == e2 ? void 0 : e2.setDirty }), () => ({ type: "dropdown", label: "Color Space", property: [e2[t2], "colorSpace"], children: [["Linear", n.GUF], ["sRGB", n.KI_]].map((e3) => ({ label: e3[0], value: e3[1] })), onChange: [() => {
      const n2 = e2[t2];
      n2 && (n2.needsUpdate = true);
    }, null == e2 ? void 0 : e2.setDirty] }), () => ({ type: "checkbox", label: "Flip Y", getValue: () => {
      var n2, r2;
      return null !== (r2 = null === (n2 = e2[t2]) || void 0 === n2 ? void 0 : n2.flipY) && void 0 !== r2 && r2;
    }, setValue: (n2) => {
      var r2;
      const i2 = e2[t2];
      if (i2 && i2.flipY !== n2)
        if (i2.image && ImageBitmap && i2.image instanceof ImageBitmap) {
          const t3 = i2, r3 = i2.source.data;
          createImageBitmap(r3, { imageOrientation: "flipY" }).then((i3) => {
            var s2;
            r3.close && r3.close(), t3.flipY = n2, t3.source.data = i3, t3.source.needsUpdate = true, t3.needsUpdate = true, null === (s2 = null == e2 ? void 0 : e2.setDirty) || void 0 === s2 || s2.call(e2);
          });
        } else
          i2.flipY = n2, i2.needsUpdate = true, null === (r2 = null == e2 ? void 0 : e2.setDirty) || void 0 === r2 || r2.call(e2);
    } }), () => ({ type: "dropdown", label: "Wrap S", property: [e2[t2], "wrapS"], children: [["ClampToEdge", n.uWy], ["MirroredRepeat", n.OoA], ["Repeat", n.rpg]].map((e3) => ({ label: e3[0], value: e3[1] })), onChange: [() => {
      e2[t2] && (e2[t2].needsUpdate = true);
    }, null == e2 ? void 0 : e2.setDirty] }), () => ({ type: "dropdown", label: "Wrap T", property: [e2[t2], "wrapT"], children: [["ClampToEdge", n.uWy], ["MirroredRepeat", n.OoA], ["Repeat", n.rpg]].map((e3) => ({ label: e3[0], value: e3[1] })), onChange: [() => {
      e2[t2] && (e2[t2].needsUpdate = true);
    }, null == e2 ? void 0 : e2.setDirty] }), () => ({ type: "input", label: "Anisotropy", bounds: [1, 6], stepSize: 1, property: [e2[t2], "anisotropy"], onChange: [() => {
      e2[t2] && (e2[t2].needsUpdate = true), e2.needsUpdate = true;
    }, null == e2 ? void 0 : e2.setDirty] }), () => ({ type: "dropdown", label: "Min Filter", property: [e2[t2], "minFilter"], children: [["Linear", n.wem], ["Nearest", n.TyD], ["NearestMipmapNearest", n.YLQ], ["NearestMipmapLinear", n.vZf], ["LinearMipmapNearest", n.qyh], ["LinearMipmapLinear", n.D1R]].map((e3) => ({ label: e3[0], value: e3[1] })), onChange: [() => {
      e2[t2] && (e2[t2].needsUpdate = true);
    }, null == e2 ? void 0 : e2.setDirty] }), () => ({ type: "dropdown", label: "Mag Filter", property: [e2[t2], "magFilter"], children: [["Linear", n.wem], ["Nearest", n.TyD]].map((e3) => ({ label: e3[0], value: e3[1] })), onChange: [() => {
      e2[t2] && (e2[t2].needsUpdate = true);
    }, null == e2 ? void 0 : e2.setDirty] })] };
  }
  const Y = ["appliedMeshes", "imageLoadAwaiter", "inverseModelMatrix", "uvTransform", "uuid", "iMaterial"];
  function K(e2, t2, n2 = true) {
    if (!t2)
      return e2;
    for (const r2 of Object.keys(t2)) {
      if (n2 && Y.includes(r2))
        continue;
      if (r2.startsWith("__"))
        continue;
      const i2 = t2[r2];
      if ("function" == typeof e2[r2] || "function" == typeof i2)
        continue;
      const s2 = !i2 || i2.isTexture || i2.isObject3D || i2.isMaterial;
      s2 || "function" != typeof i2.clone ? s2 || "object" != typeof i2 && !Array.isArray(i2) ? e2[r2] = i2 : e2[r2] = K(Array.isArray(i2) ? [] : {}, i2, false) : e2[r2] = i2.clone();
    }
    return e2;
  }
  const J = ["appliedMaterials", "uuid"];
  function Z(e2, t2) {
    if (t2)
      for (const n2 of Object.keys(t2))
        J.includes(n2) || n2.startsWith("__") || "function" != typeof e2[n2] && "function" != typeof t2[n2] && (e2[n2] = t2[n2]);
    return e2;
  }
  function $(e2, r2, i2) {
    var s2;
    const o2 = null !== (s2 = null == i2 ? void 0 : i2.data) && void 0 !== s2 ? s2 : new Uint8ClampedArray(e2.height * e2.width * 4), a2 = e2.data instanceof Float32Array, l2 = e2.data instanceof Uint16Array;
    for (let i3 = 0; i3 < o2.length; i3++)
      o2[i3] = a2 ? 255 * e2.data[i3] : l2 ? 255 * n.A5E.fromHalfFloat(e2.data[i3]) : e2.data[i3], r2 === n.GUF && (o2[i3] = 255 * (0, t.LinearToSRGB)(o2[i3] / 255));
    return null != i2 ? i2 : new ImageData(o2, e2.width, e2.height);
  }
  function ee(e2, t2, n2 = false) {
    let r2;
    return r2 = e2.isDataTexture ? $(e2.image, e2.colorSpace) : e2.image, te(r2, t2, n2);
  }
  function te(e2, n2, r2 = false) {
    const i2 = document.createElement("canvas");
    i2.width = Math.min(n2, e2.width), i2.height = Math.floor(1 + i2.width * e2.height / e2.width);
    const s2 = i2.getContext("2d");
    if (!s2)
      return console.error("textureToDataUrl: could not get canvas context"), i2;
    true === r2 && (s2.translate(0, i2.height), s2.scale(1, -1));
    let o2 = false;
    if (void 0 !== e2.data) {
      const t2 = e2;
      if (e2.width !== i2.width || e2.height !== i2.height) {
        const n3 = document.createElement("canvas");
        n3.width = e2.width, n3.height = e2.height;
        const r3 = n3.getContext("2d");
        r3 ? (r3.putImageData(t2, 0, 0), s2.drawImage(n3, 0, 0, i2.width, i2.height)) : (console.error("textureToDataUrl: could not get temp canvas context"), s2.putImageData(t2, 0, 0));
      } else
        s2.putImageData(t2, 0, 0), r2 && (o2 = true);
    } else
      s2.drawImage(e2, 0, 0, i2.width, i2.height);
    return o2 ? (0, t.canvasFlipY)(i2) : i2;
  }
  function ne(e2, t2, n2, r2, i2) {
    return ee(e2, t2, n2).toDataURL(r2, i2);
  }
  String.prototype.replaceAll || (String.prototype.replaceAll = function(e2, t2) {
    return "[object regexp]" === Object.prototype.toString.call(e2).toLowerCase() ? this.replace(e2, t2) : this.replace(new RegExp(e2, "g"), t2);
  });
  const re = /* @__PURE__ */ new Map();
  function ie(e2) {
    return (t2, n2) => {
      const r2 = t2.constructor;
      if (r2 === Object)
        throw new Error("All properties in an object are serialized by default");
      re.has(r2) || re.set(r2, []), re.get(r2).push([e2 || n2, n2]);
    };
  }
  const se = { obj: (e2, t2) => Object.fromEntries(Object.entries(e2).map(([e3, n2]) => [e3, le(n2, false, t2)])), vec4: (e2) => ({ x: e2.x, y: e2.y, z: e2.z, w: e2.w, isVector4: true }), vec3: (e2) => ({ x: e2.x, y: e2.y, z: e2.z, isVector3: true }), vec2: (e2) => ({ x: e2.x, y: e2.y, isVector2: true }), color: (e2) => ({ r: e2.r, g: e2.g, b: e2.b, isColor: true }), quat: (e2) => ({ x: e2.x, y: e2.y, z: e2.z, w: e2.w, isQuaternion: true }), texture: (e2, t2) => {
    var n2;
    if (!(null == e2 ? void 0 : e2.isTexture))
      throw new Error("Expected a texture");
    if (null == t2 ? void 0 : t2.textures[e2.uuid])
      return { uuid: e2.uuid, resource: "textures" };
    if (e2.isRenderTargetTexture && !(null === (n2 = e2.userData) || void 0 === n2 ? void 0 : n2.serializableRenderTarget))
      return;
    const r2 = e2.source.data, i2 = !e2.isRenderTargetTexture && e2.userData.rootPath;
    i2 && e2.source.data && (e2.userData.__embedUrlImagePreviews ? e2.source.data = ee(e2, 16, e2.flipY) : e2.source.data = null);
    const s2 = e2.userData;
    e2.userData = {};
    const o2 = { images: {} };
    let a2 = {};
    try {
      a2 = e2.toJSON(t2 || o2), !t2 && a2.image && (a2.image = i2 && !e2.userData.__embedUrlImagePreviews ? void 0 : o2.images[a2.image]), a2.userData = le(Z({}, s2), false, t2);
    } catch (e3) {
      console.error(e3);
    }
    return e2.userData = s2, i2 && (t2 && !e2.userData.__embedUrlImagePreviews && delete t2.images[e2.source.uuid], e2.source.data = r2), (null == t2 ? void 0 : t2.textures) && !a2.resource && (t2.textures[a2.uuid] || (t2.textures[a2.uuid] = a2), a2 = { uuid: a2.uuid, resource: "textures" }), a2;
  }, material: (e2, t2) => {
    if (!(null == e2 ? void 0 : e2.isMaterial))
      throw new Error("Expected a material");
    if (null == t2 ? void 0 : t2.materials[e2.uuid])
      return { uuid: e2.uuid, resource: "materials" };
    e2.userData.rootPath && console.error("TODO: handle material with root path with material inheritance/hierarchy");
    const n2 = null != t2 ? t2 : { textures: {}, images: {} }, r2 = {}, i2 = {};
    for (const [t3, s3] of Object.entries(e2))
      if ((null == s3 ? void 0 : s3.isTexture) && !t3.startsWith("__")) {
        const o2 = se.texture(s3, n2);
        r2[t3] = o2, i2[t3] = s3, e2[t3] = o2 ? { isTexture: true, toJSON: () => o2 } : null;
      }
    let s2 = e2.toJSON(t2);
    for (const [t3, n3] of Object.entries(i2))
      e2[t3] = n3, delete i2[t3];
    if (t2) {
      for (const [e3, t3] of Object.entries(r2))
        t3 && (s2[e3] = t3);
      (null == t2 ? void 0 : t2.materials) && (t2.materials[s2.uuid] || (t2.materials[s2.uuid] = s2), s2 = { uuid: s2.uuid, resource: "materials" });
    } else {
      for (const [e3, t3] of Object.entries(r2))
        t3 && (s2[e3] = t3.uuid);
      s2.textures = Object.values(n2.textures), s2.images = Object.values(n2.images);
    }
    return s2;
  } }, oe = (e2) => (t2, n2) => {
    var r2, i2;
    return null !== (i2 = null === (r2 = null == n2 ? void 0 : n2.copy) || void 0 === r2 ? void 0 : r2.call(n2, t2)) && void 0 !== i2 ? i2 : new e2().copy(t2);
  }, ae = { obj: (e2, t2, n2) => Object.assign(t2, Object.fromEntries(Object.entries(e2).map(([e3, r2]) => [e3, ce(r2, null == t2 ? void 0 : t2[e3], false, n2)]))), vec4: oe(n.Ltg), vec3: oe(n.Pa4), vec2: oe(n.FM8), color: oe(n.Ilk), quat: oe(n._fP) };
  function le(e2, t2, n2) {
    var r2, i2;
    if ("function" == typeof e2)
      return;
    if (Array.isArray(e2))
      return e2.map((e3) => le(e3, false, n2));
    if ("object" != typeof e2) {
      if ("number" == typeof e2) {
        if (e2 === 1 / 0)
          return "Infinity";
        if (e2 === -1 / 0)
          return "-Infinity";
        if (isNaN(e2))
          return "NaN";
      }
      return e2;
    }
    if (!e2)
      return e2;
    let s2 = null !== (r2 = e2.constructor) && void 0 !== r2 ? r2 : Object;
    if (s2 === Object)
      return se.obj(e2, n2);
    if (e2.isVector2)
      return se.vec2(e2);
    if (e2.isVector3)
      return se.vec3(e2);
    if (e2.isVector4)
      return se.vec4(e2);
    if (e2.isColor)
      return se.color(e2);
    if (e2.isQuaternion)
      return se.quat(e2);
    if (e2.isTexture)
      return se.texture(e2, n2);
    if (e2.isMaterial)
      return se.material(e2, n2);
    if (!t2 && "function" == typeof e2.toJSON) {
      const t3 = e2.toJSON(n2);
      return e2.serializableClassId && t3 && (t3.serializableClassId = e2.serializableClassId), t3;
    }
    const o2 = {};
    for (; s2 && s2 !== Object; )
      null === (i2 = re.get(s2)) || void 0 === i2 || i2.forEach(([t3, r3]) => {
        const i3 = e2[r3];
        o2[t3] = le(i3, false, n2);
      }), s2 = Object.getPrototypeOf(s2);
    return e2.serializableClassId && (o2.serializableClassId = e2.serializableClassId), o2;
  }
  function ce(e2, n2, r2, i2) {
    var s2, o2, a2;
    let l2 = n2;
    if (void 0 === e2)
      return l2;
    if ("number" == typeof n2) {
      if ("Infinity" === e2)
        return 1 / 0;
      if ("-Infinity" === e2)
        return -1 / 0;
      if ("NaN" === e2)
        return NaN;
      if ("number" == typeof e2 || !e2)
        return e2;
    }
    if (Array.isArray(e2)) {
      const t2 = e2.length;
      Array.isArray(l2) || (l2 = []);
      for (let n3 = 0; n3 < t2; n3++) {
        const t3 = e2[n3], r3 = l2.length > n3 ? ce(t3, l2[n3], false, i2) : ce(t3, void 0, false, i2);
        l2.length <= n3 ? l2.push(r3) : l2[n3] = r3;
      }
      return l2;
    }
    let c2 = false;
    if (e2 && e2.resource && "string" == typeof e2.resource && (e2 = null === (s2 = i2[e2.resource]) || void 0 === s2 ? void 0 : s2[e2.uuid], c2 = true), !l2 && e2 && !c2)
      if (e2.serializableClassId) {
        const t2 = ue.get(e2.serializableClassId);
        t2 && (l2 = t2.DataInConstructor ? new t2(e2) : new t2());
      } else
        "object" != typeof e2 || e2.constructor && e2.constructor !== Object || (l2 = {});
    if ("function" == typeof l2)
      return console.error("cannot deserialize over function", l2, e2), l2;
    if (e2 && "object" == typeof e2 && !c2) {
      if (e2.isVector2)
        return ae.vec2(e2, l2);
      if (e2.isVector3)
        return ae.vec3(e2, l2);
      if (e2.isVector4)
        return ae.vec4(e2, l2);
      if (e2.isColor)
        return ae.color(e2, l2);
      if (e2.isQuaternion)
        return ae.quat(e2, l2);
    }
    if (null == e2 || null == l2 || "object" != typeof l2 || l2.isTexture)
      return c2 && (e2 ? e2.__useCount = e2.__useCount ? e2.__useCount + 1 : 1 : console.warn("probable error deserialize: resource not found.")), e2;
    let u2 = null !== (o2 = l2.constructor) && void 0 !== o2 ? o2 : Object;
    if (u2 === Object)
      return ae.obj(e2, l2, i2);
    if (!r2 && "function" == typeof l2.fromJSON)
      return l2.isMaterial && (Object.entries(e2).forEach(([t2, n3]) => {
        var r3;
        if (!n3 || !n3.resource || "string" != typeof n3.resource)
          return;
        const s3 = null === (r3 = i2[n3.resource]) || void 0 === r3 ? void 0 : r3[n3.uuid];
        e2[t2] = s3 || null;
      }), e2.userData && (e2.userData = ce(e2.userData, void 0, false, i2))), l2.fromJSON(e2, i2), l2;
    for (; u2 && u2 !== Object; )
      null === (a2 = re.get(u2)) || void 0 === a2 || a2.forEach(([n3, r3]) => {
        const s3 = l2[r3], o3 = ce(e2[n3], s3, false, i2);
        o3 !== s3 && (0, t.safeSetProperty)(l2, r3, o3, true);
      }), u2 = Object.getPrototypeOf(u2);
    return l2;
  }
  const ue = /* @__PURE__ */ new Map();
  function pe(e2) {
    return (t2) => (t2 = class extends t2 {
      constructor() {
        super(...arguments), this.serializableClassId = e2;
      }
    }, ue.set(e2, t2), t2);
  }
  function de(e2, t2, n2, r2) {
    var i2, s2, o2;
    if (null == t2 ? void 0 : t2.extras[e2.uuid])
      return { uuid: e2.uuid, resource: "extras" };
    let a2 = "";
    if ((null === (i2 = e2.source) || void 0 === i2 ? void 0 : i2._sourceImgBuffer) || e2.userData.__sourceBuffer) {
      const t3 = new Uint8Array((null === (s2 = e2.source) || void 0 === s2 ? void 0 : s2._sourceImgBuffer) || e2.userData.__sourceBuffer), n3 = r2 || e2.userData.mimeType || "";
      a2 = { data: Array.from(t3), type: t3.constructor.name, path: (null === (o2 = e2.userData.__sourceBlob) || void 0 === o2 ? void 0 : o2.name) || e2.userData.rootPath || "file." + n3.split("/")[1] }, n3 && (a2.mimeType = n3);
    } else
      e2.userData.rootPath ? a2 = e2.userData.rootPath : console.error("Unable to serialize LUT texture, not loaded through asset manager.");
    const l2 = { uuid: e2.uuid, url: a2, userData: Z({}, e2.userData), type: e2.type, name: n2 || e2.name };
    return (null == t2 ? void 0 : t2.extras) ? (t2.extras[e2.uuid] = l2, { uuid: e2.uuid, resource: "extras" }) : l2;
  }
  var he = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let fe = class extends t.SimpleEventDispatcher {
    get composer() {
      return this._composer;
    }
    get passes() {
      return this._passes;
    }
    get isWebGL2() {
      return this._isWebGL2;
    }
    get composerTarget() {
      return this._composerTarget;
    }
    get renderSize() {
      return this._renderSize;
    }
    get displayCanvasScaling() {
      return this._displayCanvasScaling;
    }
    set displayCanvasScaling(e2) {
      e2 !== this._displayCanvasScaling && (this._displayCanvasScaling = e2, this.setSize(void 0, void 0, true));
    }
    get frameCount() {
      return this._frameCount;
    }
    get totalFrameCount() {
      return this._totalFrameCount;
    }
    set pipeline(e2) {
      this._pipeline = e2, this._passesNeedsUpdate = true;
    }
    get pipeline() {
      return this._pipeline;
    }
    refreshPipeline() {
      var e2, n2, r2;
      const i2 = this._passes, s2 = [], o2 = {};
      for (const t2 of i2) {
        if (false === t2.enabled)
          continue;
        const i3 = { after: null !== (e2 = t2.after) && void 0 !== e2 ? e2 : [], before: null !== (n2 = t2.before) && void 0 !== n2 ? n2 : [], dependencies: new Set(null !== (r2 = t2.required) && void 0 !== r2 ? r2 : []) };
        o2[t2.passId] = i3;
      }
      for (const [e3, t2] of Object.entries(o2)) {
        const n3 = /* @__PURE__ */ new Set([...t2.after, ...t2.before]);
        t2.dependencies.forEach((e4) => n3.has(e4) && n3.delete(e4)), n3.forEach((n4) => {
          const r3 = o2[n4];
          if (r3) {
            if (r3.dependencies.has(e3))
              throw console.error("cyclic", e3, n4), "Cyclic dependency";
            t2.dependencies.add(n4);
          }
        });
      }
      for (; ; ) {
        let e3 = false;
        const n3 = [...Object.entries(o2)];
        for (const [r3, a2] of n3)
          if (!s2.includes(r3) && (0, t.includesAll)(s2, a2.dependencies.values())) {
            const t2 = Math.max(-1, ...a2.after.map((e4) => s2.indexOf(e4))), n4 = Math.min(s2.length, ...a2.before.map((e4) => {
              const t3 = s2.indexOf(e4);
              return t3 < 0 ? s2.length : t3;
            }));
            if (t2 >= n4)
              throw console.error(a2, i2, s2, t2, n4), "Not possible";
            s2.splice(a2.after.length > 0 ? t2 + 1 : n4, 0, r3), e3 = true, delete o2[r3];
          }
        if (Object.keys(o2).length < 1)
          break;
        if (!e3)
          throw console.error(n3, o2, s2), "Not possible 2";
      }
      return this.pipeline = s2, this.pipeline;
    }
    get context() {
      return this._context;
    }
    get rendererObject() {
      return this._renderer;
    }
    _animationLoop(e2, t2) {
      const n2 = e2 - this._lastTime;
      this._lastTime = e2, this.frameWaitTime -= n2, this.frameWaitTime > 0 || (this.frameWaitTime = 0, this.dispatchEvent({ type: "animationLoop", deltaTime: n2, time: e2, renderer: this, xrFrame: t2 }));
    }
    get clock() {
      return this._composer.clock;
    }
    registerPass(e2, t2 = true) {
      var n2;
      if (t2)
        for (const t3 of [...this._passes])
          e2.passId === t3.passId && this.unregisterPass(t3);
      this._passes.push(e2), null === (n2 = e2.onRegister) || void 0 === n2 || n2.call(e2, this), this._passesNeedsUpdate = true, this._updated();
    }
    unregisterPass(e2) {
      var t2;
      const n2 = this._passes.indexOf(e2);
      n2 >= 0 && (null === (t2 = e2.onUnregister) || void 0 === t2 || t2.call(e2, this), this._passes.splice(n2, 1), this._passesNeedsUpdate = true, this._updated());
    }
    constructor({ animationLoop: e2, canvas: t2, alpha: r2 = true, targetOptions: i2 }) {
      super(), this._isWebGL2 = false, this._trackedTargets = [], this.dirty = true, this._lastTime = 0, this.frameWaitTime = 0, this._passes = [], this._pipeline = [], this._passesNeedsUpdate = true, this._displayCanvasScaling = 1, this._renderSize = new n.FM8(512, 512), this._frameCount = 0, this.defaultRenderToScreen = true, this._tempTargets = {}, this.maxTempPerKey = 5, this._totalFrameCount = 0, this.stableNoise = false, this._animationLoop = this._animationLoop.bind(this), this._processNewTarget = this._processNewTarget.bind(this), this._processNewTempTarget = this._processNewTempTarget.bind(this), this.trackTarget = this.trackTarget.bind(this), this.disposeTarget = this.disposeTarget.bind(this), this.createTarget = this.createTarget.bind(this), this.createTargetCustom = this.createTargetCustom.bind(this), this._renderer = new n.CP7({ canvas: t2, antialias: false, alpha: r2, premultipliedAlpha: true, preserveDrawingBuffer: true, powerPreference: "high-performance" }), this._renderer.useLegacyLights = false, this._renderer.baseRenderer = this, this._renderer.setAnimationLoop(this._animationLoop), this._context = this._renderer.getContext(), this._isWebGL2 = this._renderer.capabilities.isWebGL2, this._renderer.onContextLost = (e3) => {
        this.dispatchEvent({ type: "contextLost", event: e3 });
      }, this._renderer.onContextRestore = () => {
        this.dispatchEvent({ type: "contextRestored" });
      }, this._renderSize = new n.FM8(t2.clientWidth, t2.clientHeight), this._renderer.setSize(this._renderSize.width, this._renderSize.height, false), this._renderer.setPixelRatio(this._displayCanvasScaling), this._renderer.toneMapping = n.uL9, this._renderer.toneMappingExposure = 1, this._renderer.outputColorSpace = n.aCh, this._renderer.shadowMap.enabled = true, this._renderer.shadowMap.type = n._iA, this._renderer.shadowMap.autoUpdate = false, this.resetShadows(), this._composerTarget = this.createTarget(i2, false), this._composerTarget.texture.name = "EffectComposer.rt1", this._composer = new d(this._renderer, this._composerTarget), e2 && this.addEventListener("animationLoop", e2);
    }
    setSize(e2, t2, n2 = false) {
      !n2 && (e2 ? Math.abs(e2 - this._renderSize.width) : 0) + (t2 ? Math.abs(t2 - this._renderSize.height) : 0) < 0.1 || (e2 && (this._renderSize.width = e2), t2 && (this._renderSize.height = t2), this.rendererObject.xr.enabled && this.rendererObject.xr.isPresenting || (this._renderer.setSize(this._renderSize.width, this._renderSize.height, false), this._renderer.setPixelRatio(this._displayCanvasScaling)), this._composer.setPixelRatio(this._displayCanvasScaling, false), this._composer.setSize(this._renderSize.width, this._renderSize.height), this._trackedTargets.forEach((e3) => {
        const t3 = e3, n3 = t3.sizeMultiplier;
        if (n3) {
          const e4 = this._renderSize.clone().multiplyScalar(this._displayCanvasScaling * n3);
          t3.setSize(Math.floor(e4.width), Math.floor(e4.height));
        }
      }), this.dispatchEvent({ type: "resize" }), this._updated(), this.reset());
    }
    blit(e2, t2, { viewport: r2, material: i2, shader: s2, pass: o2, clear: a2 = true } = {}) {
      const l2 = this._composer.copyPass, { renderToScreen: c2, material: u2, uniforms: p2, clear: d2 } = l2;
      i2 && (l2.material = i2);
      const h2 = this._renderer.getViewport(new n.Ltg()), f2 = this._renderer.autoClear, m2 = this._renderer.getRenderTarget();
      r2 && this._renderer.setViewport(new n.Ltg().fromArray(r2)), this._renderer.autoClear = false, l2.uniforms = l2.material.uniforms, l2.renderToScreen = false, l2.clear = a2, H(this._renderer, { sceneRender: true, opaqueRender: true, shadowMapRender: false, backgroundRender: false, transparentRender: true, transmissionRender: false }, () => {
        l2.render(this._renderer, null != t2 ? t2 : null, { texture: e2 }, 0, false);
      }), l2.renderToScreen = c2, l2.clear = d2, l2.material = u2, l2.uniforms = p2, this._renderer.autoClear = f2, r2 && this._renderer.setViewport(h2), this._renderer.setRenderTarget(m2);
    }
    clearColor({ r: e2, g: t2, b: r2, a: i2, target: s2, depth: o2 = true, stencil: a2 = true }) {
      var l2;
      const c2 = this._renderer.getClearColor(new n.Ilk()), u2 = this._renderer.getClearAlpha();
      this._renderer.setClearColor(new n.Ilk(null != e2 ? e2 : c2.r, null != t2 ? t2 : c2.g, null != r2 ? r2 : c2.b), null != i2 ? i2 : u2);
      const p2 = this._renderer.getRenderTarget(), d2 = this._renderer.getActiveCubeFace(), h2 = this._renderer.getActiveMipmapLevel();
      s2 && "function" == typeof s2.clear ? s2.clear(this._renderer, true, o2, a2) : (this._renderer.setRenderTarget(null !== (l2 = s2) && void 0 !== l2 ? l2 : null), this._renderer.clear(true, o2, a2)), this._renderer.setRenderTarget(p2, d2, h2), this._renderer.setClearColor(c2, u2);
    }
    renderModel(e2, t2) {
      this._renderer.render(e2.modelObject, t2.cameraObject);
    }
    renderScene(e2) {
      const t2 = e2.activeCamera;
      t2 && this.renderModel(e2, t2);
    }
    _updated() {
      this.dispatchEvent({ type: "update" });
    }
    render(e2) {
      var t2;
      this._passesNeedsUpdate && this.refreshPasses();
      for (const e3 of this._passes)
        e3.passObject.enabled && (null === (t2 = e3.update) || void 0 === t2 || t2.call(e3));
      e2 = null != e2 ? e2 : this.defaultRenderToScreen, this._composer.renderToScreen = e2, this._composer.render(), this._composer.renderToScreen = true, e2 && (this._frameCount += 1, this._totalFrameCount += 1), this.dirty = false;
    }
    updateDirty() {
      this.dirty = this.dirty || this._passes.findIndex((e2) => e2.dirty) >= 0;
    }
    reset() {
      this._frameCount = 0, this.dirty = true;
    }
    resetShadows() {
      this._renderer.shadowMap.needsUpdate = true;
    }
    refreshPasses() {
      if (!this._passesNeedsUpdate)
        return;
      this._passesNeedsUpdate = false;
      const e2 = [];
      for (const t2 of this._pipeline) {
        const n2 = this._passes.find((e3) => e3.passId === t2);
        n2 ? e2.push(n2.passObject) : console.warn("WebGi BaseRenderer: Unable to find pass: ", t2);
      }
      [...this._composer.passes].forEach((e3) => this._composer.removePass(e3)), e2.forEach((e3) => this._composer.addPass(e3)), this._updated();
    }
    dispose() {
      this._trackedTargets.forEach((e2) => e2.dispose()), this._trackedTargets = [], this._renderer.dispose();
    }
    trackTarget(e2) {
      this._trackedTargets.push(e2);
    }
    removeTrackedTarget(e2) {
      const t2 = this._trackedTargets.indexOf(e2);
      t2 >= 0 && this._trackedTargets.splice(t2, 1);
    }
    createTarget({ sizeMultiplier: e2, samples: t2 = 0, colorSpace: r2 = n.aCh, type: i2 = n.ywz, format: s2 = n.wk1, depthBuffer: o2 = true, depthTexture: a2 = false, depthTextureType: l2 = n.JQ4, depthTextureFormat: c2 = n.qkB, size: u2, textureCount: p2 = 1, ...d2 } = {}, h2 = true) {
      this.isWebGL2 || (t2 = 0), void 0 !== e2 && void 0 !== u2 && console.error("Both sizeMultiplier and size are defined. sizeMultiplier will be ignored."), (u2 = u2 || this._renderSize.clone().multiplyScalar(this._displayCanvasScaling * (e2 = e2 || 1))).width = Math.floor(u2.width), u2.height = Math.floor(u2.height);
      const f2 = a2 ? new n.$YQ(u2.width, u2.height, l2) : void 0;
      f2 && (f2.format = c2);
      const m2 = this.createTargetCustom(p2 > 1 ? { width: u2.width, height: u2.height, count: p2 } : u2, { samples: t2, colorSpace: r2, type: i2, format: s2, depthBuffer: o2, depthTexture: f2 }, p2 > 1 ? n.kFz : n.dd2);
      return this._processNewTarget(m2, e2, h2), this._setTargetOptions(m2, d2), m2;
    }
    _processNewTarget(e2, t2, n2) {
      return void 0 !== t2 && (e2.sizeMultiplier = t2), n2 && this.trackTarget(e2), e2;
    }
    disposeTarget(e2) {
      if (e2) {
        if (e2.isTemporary)
          return this.releaseTempTarget(e2);
        this.removeTrackedTarget(e2), e2.dispose();
      }
    }
    createTargetCustom({ width: e2, height: t2, count: r2 }, i2 = {}, s2) {
      var o2;
      const a2 = this._processNewTarget, l2 = this.renderTargetToDataUrl.bind(this);
      this.renderTargetToBuffer.bind(this);
      let c2 = [e2, t2];
      if (r2 && r2 > 1 && c2.push(r2), (null == s2 ? void 0 : s2.prototype) === n.oAp.prototype) {
        if (e2 !== t2)
          throw "Width and height of cube render target must be equal";
        c2 = [e2];
      }
      i2 = { format: n.wk1, minFilter: n.wem, magFilter: n.wem, generateMipmaps: false, type: n.ywz, colorSpace: n.aCh, ...i2 };
      const u2 = [this, ...c2, i2];
      return new class extends (null !== (o2 = s2) && void 0 !== o2 ? o2 : n.dd2) {
        constructor(e3, ...t3) {
          super(...t3), this.renderer = e3, this.assetType = "renderTarget", this.name = "RenderTarget", Array.isArray(this.texture) ? this.texture.forEach((e4) => {
            e4.__target = this, e4.userData || (e4.userData = {}), e4.colorSpace = i2.colorSpace, e4.toJSON = () => (console.warn("WebGi RenderTarget: Multiple render target texture.toJSON not supported yet."), {});
          }) : (this.texture.userData || (this.texture.userData = {}), this.texture.__toJSON = this.texture.toJSON, this.texture.__target = this, this.texture.toJSON = function(e4) {
            console.warn("WebGi RenderTarget: Render target texture.toJSON might be buggy."), this.source.data.url = l2(this.__target, "image/png", 90);
            const t4 = this.__toJSON.call(this, e4);
            return delete this.source.data.url, t4.isRenderTargetTexture = true, t4;
          });
        }
        setSize(e3, t3, n2) {
          super.setSize(Math.floor(e3), Math.floor(t3), n2);
        }
        clone(e3 = true) {
          if (this.isTemporary)
            throw "Cloning temporary render targets not supported";
          if (Array.isArray(this.texture))
            throw "Cloning multiple render targets not supported";
          const t3 = super.clone();
          return t3.texture.isRenderTargetTexture = true, a2(t3, this.sizeMultiplier || 1, e3);
        }
      }(...u2);
    }
    getTempTarget(e2 = {}) {
      var t2;
      const n2 = me(e2);
      let r2;
      return (null === (t2 = this._tempTargets[n2]) || void 0 === t2 ? void 0 : t2.length) && (r2 = this._tempTargets[n2].pop()), r2 ? this._setTargetOptions(r2, e2) : (r2 = this.createTarget(e2), this._processNewTempTarget(r2, n2)), r2;
    }
    _processNewTempTarget(e2, t2) {
      return e2.isTemporary = true, e2.targetKey = t2, void 0 === this._tempTargets[t2] && (this._tempTargets[t2] = []), e2;
    }
    releaseTempTarget(e2) {
      const t2 = e2.targetKey;
      if (!t2 || !e2.isTemporary)
        throw "Not a temp target";
      this._tempTargets[t2].length > this.maxTempPerKey ? (this.removeTrackedTarget(e2), e2.dispose()) : this._tempTargets[t2].push(e2);
    }
    updateShaderProperties(e2) {
      return this.stableNoise ? e2.uniforms.frameCount ? e2.uniforms.frameCount.value = this._totalFrameCount : console.warn("WebGi BaseRenderer: no uniform: frameCount") : e2.uniforms.frameCount ? e2.uniforms.frameCount.value = this.frameCount : console.warn("WebGi BaseRenderer:  no uniform: frameCount"), e2.uniforms.frameCount2 && (e2.uniforms.frameCount2.value = this.frameCount), this;
    }
    _setTargetOptions(e2, t2) {
      var r2, i2, s2;
      e2.texture.minFilter = null !== (r2 = t2.minFilter) && void 0 !== r2 ? r2 : n.wem, e2.texture.magFilter = null !== (i2 = t2.magFilter) && void 0 !== i2 ? i2 : n.wem, e2.texture.generateMipmaps = null !== (s2 = t2.generateMipmaps) && void 0 !== s2 && s2, e2.texture.generateMipmaps && e2.texture.minFilter === n.wem && (e2.texture.minFilter = n.FDw), e2.texture.generateMipmaps || e2.texture.minFilter !== n.FDw || (e2.texture.minFilter = n.wem);
    }
    renderTargetToDataUrl(e2, t2 = "image/png", r2 = 90, i2 = 0) {
      const s2 = document.createElement("canvas");
      s2.width = e2.width, s2.height = e2.height;
      const o2 = s2.getContext("2d");
      if (!o2)
        throw new Error("Unable to get 2d context");
      const a2 = Array.isArray(e2.texture) ? e2.texture[i2] : e2.texture, l2 = o2.createImageData(e2.width, e2.height, { colorSpace: ["display-p3", "srgb"].includes(a2.colorSpace) ? a2.colorSpace : void 0 });
      if (a2.type === n.cLu) {
        const t3 = new Uint16Array(e2.width * e2.height * 4);
        this._renderer.readRenderTargetPixels(e2, 0, 0, e2.width, e2.height, t3, void 0, i2), $({ data: t3, width: e2.width, height: e2.height }, a2.colorSpace, l2);
      } else if (a2.type === n.VzW) {
        const t3 = new Float32Array(e2.width * e2.height * 4);
        this._renderer.readRenderTargetPixels(e2, 0, 0, e2.width, e2.height, t3, void 0, i2), $({ data: t3, width: e2.width, height: e2.height }, a2.colorSpace, l2);
      } else
        this._renderer.readRenderTargetPixels(e2, 0, 0, e2.width, e2.height, l2.data, void 0, i2);
      o2.putImageData(l2, 0, 0);
      const c2 = s2.toDataURL(t2, r2);
      return s2.remove(), c2;
    }
    renderTargetToBuffer(e2, t2 = 0) {
      const r2 = (Array.isArray(e2.texture) ? e2.texture[t2] : e2.texture).type === n.cLu ? new Uint16Array(e2.width * e2.height * 4) : new Uint8Array(e2.width * e2.height * 4);
      return this._renderer.readRenderTargetPixels(e2, 0, 0, e2.width, e2.height, r2, void 0, t2), r2;
    }
    get useLegacyLights() {
      return this.rendererObject.useLegacyLights;
    }
    set useLegacyLights(e2) {
      this.rendererObject.useLegacyLights = e2, this._updated(), this.resetShadows();
    }
    get useTotalFrameCount() {
      return console.warn("WebGi BaseRenderer: useTotalFrameCount is deprecated, use stableNoise instead"), this.stableNoise;
    }
    set useTotalFrameCount(e2) {
      console.warn("WebGi BaseRenderer: useTotalFrameCount is deprecated, use stableNoise instead"), this.stableNoise = e2;
    }
    get renderScale() {
      return this.displayCanvasScaling;
    }
    set renderScale(e2) {
      this.displayCanvasScaling = e2;
    }
  };
  function me(e2 = {}) {
    var t2, n2;
    return [e2.sizeMultiplier, e2.samples, e2.colorSpace, e2.type, e2.format, e2.depthBuffer, e2.depthTexture, null === (t2 = e2.size) || void 0 === t2 ? void 0 : t2.width, null === (n2 = e2.size) || void 0 === n2 ? void 0 : n2.height].join(";");
  }
  function _e(e2) {
    var t2, r2, i2, s2, o2, a2, l2, c2;
    if (!e2.isMaterial && !e2.isBufferGeometry)
      return;
    const u2 = Array.from(e2.userData.__appliedMeshes).filter((e3) => !e3.isInstancedMesh && !!e3.parent && 0 === e3.children.length && !Array.isArray(e3.material));
    if (u2.length < 2)
      return;
    const p2 = (e3) => {
      var t3;
      return e3.parent.uuid + "_" + e3.geometry.uuid + "_" + (null === (t3 = e3.material) || void 0 === t3 ? void 0 : t3.uuid);
    }, d2 = /* @__PURE__ */ new Map();
    for (const e3 of u2) {
      const t3 = p2(e3);
      d2.has(t3) || d2.set(t3, []), d2.get(t3).push(e3), e3.updateMatrix();
    }
    const h2 = d2.keys();
    for (const e3 of h2) {
      const u3 = d2.get(e3), p3 = u3[0];
      if (!p3)
        continue;
      if (u3.length < 2)
        continue;
      const h3 = new n.SPe(p3.geometry, p3.material, u3.length), f2 = p3.userData;
      p3.userData = {}, h3.copy(p3), Ee(h3.userData, f2);
      const m2 = p3.parent;
      h3.position.set(0, 0, 0), h3.rotation.set(0, 0, 0), h3.scale.set(1, 1, 1), h3.updateMatrix();
      const _2 = new Float32Array(3 * h3.count), g2 = new Float32Array(4 * h3.count), v2 = new Float32Array(3 * h3.count);
      for (let e4 = 0; e4 < u3.length; e4++) {
        const n2 = u3[e4], l3 = n2.matrix;
        l3.determinant() < 0 && (l3.elements[0] *= -1, l3.elements[1] *= -1, l3.elements[2] *= -1), h3.setMatrixAt(e4, l3), n2.position.toArray(_2, 3 * e4), n2.quaternion.toArray(g2, 4 * e4), n2.scale.toArray(v2, 3 * e4), n2.removeFromParent(), null === (i2 = null === (r2 = null === (t2 = n2.material) || void 0 === t2 ? void 0 : t2.userData) || void 0 === r2 ? void 0 : r2.__appliedMeshes) || void 0 === i2 || i2.delete(n2), null === (a2 = null === (o2 = null === (s2 = n2.geometry) || void 0 === s2 ? void 0 : s2.userData) || void 0 === o2 ? void 0 : o2.__appliedMeshes) || void 0 === a2 || a2.delete(n2);
      }
      null === (c2 = null === (l2 = h3.material.userData) || void 0 === l2 ? void 0 : l2.__appliedMeshes) || void 0 === c2 || c2.add(h3), h3.geometry.userData.__appliedMeshes.add(h3), h3.sourceTrs = { TRANSLATION: new n.TlE(_2, 3), ROTATION: new n.TlE(g2, 4), SCALE: new n.TlE(v2, 3) }, h3.instanceMatrix.needsUpdate = true, m2.add(h3), m2.setDirty();
    }
  }
  he([ie()], fe.prototype, "stableNoise", void 0), he([ie()], fe.prototype, "useLegacyLights", null), fe = he([pe("RenderManager")], fe);
  class ge {
    constructor(e2) {
      this.writer = e2, this.name = "EXT_mesh_gpu_instancing";
    }
    writeNode(e2, t2) {
      if (!e2.isInstancedMesh)
        return;
      const r2 = this.writer, i2 = e2;
      let s2 = i2.sourceTrs;
      if (!s2) {
        const e3 = new Float32Array(3 * i2.count), t3 = new Float32Array(4 * i2.count), r3 = new Float32Array(3 * i2.count), o2 = new n.yGw(), a2 = new n.Pa4(), l2 = new n._fP(), c2 = new n.Pa4();
        for (let n2 = 0; n2 < i2.count; n2++)
          i2.getMatrixAt(n2, o2), o2.decompose(a2, l2, c2), a2.toArray(e3, 3 * n2), l2.toArray(t3, 4 * n2), c2.toArray(r3, 3 * n2);
        s2 = { TRANSLATION: new n.TlE(e3, 3), ROTATION: new n.TlE(t3, 4), SCALE: new n.TlE(r3, 3) };
      }
      s2 = { TRANSLATION: r2.processAccessor(s2.TRANSLATION), ROTATION: r2.processAccessor(s2.ROTATION), SCALE: r2.processAccessor(s2.SCALE) }, i2.instanceColor && (s2.COLOR = r2.processAccessor(new n.TlE(i2.instanceColor.array, 3))), r2.extensionsUsed[this.name] = true, r2.extensionsRequired[this.name] = true, t2.extensions = t2.extensions || {}, t2.extensions[this.name] = { attributes: s2 };
    }
  }
  function ve(e2, t2) {
    if (e2.uiConfig)
      return e2.uiConfig;
    const r2 = { type: "folder", label: () => e2.name || "unnamed", expanded: true, limitedUi: true, children: [{ type: "checkbox", label: "Visible", property: [e2, "visible"], limitedUi: true }, { type: "button", label: "Pick/Focus", value: () => {
      e2.dispatchEvent({ type: "select", ui: true, value: e2, focusCamera: true });
    } }, { type: "button", label: "Pick Parent", hidden: () => !e2.parent, value: () => {
      const t3 = e2.parent;
      t3 && t3.dispatchEvent({ type: "select", ui: true, value: t3 });
    } }, { type: "input", label: "Name", property: [e2, "name"], onChange: (t3) => {
      var n2;
      t3.last && (null === (n2 = e2.setDirty) || void 0 === n2 || n2.call(e2, { sceneUpdate: true, refreshUi: true }));
    } }, { type: "checkbox", label: "Casts Shadow", hidden: () => !e2.isMesh, property: [e2, "castShadow"] }, { type: "checkbox", label: "Receive Shadow", hidden: () => !e2.isMesh, property: [e2, "receiveShadow"] }, { type: "checkbox", label: "Frustum culled", property: [e2, "frustumCulled"] }, { type: "vec3", label: "Position", property: [e2, "position"], limitedUi: true }, { type: "vec3", label: "Rotation", property: [e2, "rotation"], limitedUi: true }, { type: "vec3", label: "Scale", property: [e2, "scale"] }, { type: "input", label: "Render Order", property: [e2, "renderOrder"] }, { type: "button", label: "Auto Scale", prompt: ["Auto Scale Radius: Object will be scaled to the given radius", e2.userData.autoScaleRadius || "2", true], value: (t3) => {
      if (!t3)
        return;
      const n2 = parseFloat(t3);
      Math.abs(n2) > 0 && W(e2, n2);
    } }, { type: "button", label: "Auto Center", value: () => {
      confirm("Auto Center: Object will be centered, are you sure you want to proceed?") && Q(e2);
    } }, { type: "folder", label: "Rotate model", children: ["X +", "X -", "Y +", "Y -", "Z +", "Z -"].map((t3) => ({ type: "button", label: "Rotate " + t3 + "90", value: () => {
      var r3;
      e2.rotateOnAxis(new n.Pa4(t3.includes("X") ? 1 : 0, t3.includes("Y") ? 1 : 0, t3.includes("Z") ? 1 : 0), Math.PI / 2 * (t3.includes("-") ? -1 : 1)), null === (r3 = e2.setDirty) || void 0 === r3 || r3.call(e2, { sceneUpdate: true, refreshUi: false });
    } })) }, void 0 !== e2.userData.license ? { type: "input", label: "License/Credits", property: [e2.userData, "license"], limitedUi: true } : {}] }, i2 = e2;
    if ((null == i2 ? void 0 : i2.isMesh) && false !== t2) {
      const t3 = [() => {
        const t4 = Object.entries(i2.morphTargetDictionary || {});
        return t4.length ? { label: "Morph Targets", type: "folder", children: t4.map(([t5, n2]) => ({ type: "slider", label: t5, bounds: [0, 1], stepSize: 1e-4, property: [i2.morphTargetInfluences, n2], onChange: (t6) => {
          var n3;
          null === (n3 = e2.setDirty) || void 0 === n3 || n3.call(e2, { sceneUpdate: t6.last, frameFade: false, refreshUi: false });
        } })) } : void 0;
      }, () => {
        var e3;
        return null === (e3 = i2.geometry) || void 0 === e3 ? void 0 : e3.uiConfig;
      }, () => {
        var e3;
        return Array.isArray(i2.material) ? i2.material.length < 1 ? void 0 : { label: "Materials", type: "folder", children: i2.material.map((e4) => null == e4 ? void 0 : e4.uiConfig).filter((e4) => e4) } : null === (e3 = i2.material) || void 0 === e3 ? void 0 : e3.uiConfig;
      }];
      r2.children.push(...t3);
    }
    if (null == e2 ? void 0 : e2.isCamera) {
      const t3 = [{ type: "button", label: "Set View", value: () => {
        var t4;
        e2.dispatchEvent({ type: "setView", ui: true, camera: e2 }), null === (t4 = r2.uiRefresh) || void 0 === t4 || t4.call(r2, "postFrame", true);
      } }, { type: "button", label: "Activate main", hidden: () => {
        var t4;
        return null === (t4 = e2.userData.iCamera) || void 0 === t4 ? void 0 : t4.isActiveCamera;
      }, value: () => {
        var t4;
        e2.dispatchEvent({ type: "activateMain", ui: true, camera: e2 }), null === (t4 = r2.uiRefresh) || void 0 === t4 || t4.call(r2, "postFrame", true);
      } }, { type: "button", label: "Deactivate main", hidden: () => {
        var t4;
        return !(null === (t4 = e2.userData.iCamera) || void 0 === t4 ? void 0 : t4.isActiveCamera);
      }, value: () => {
        var t4;
        e2.dispatchEvent({ type: "activateMain", ui: true, camera: void 0 }), null === (t4 = r2.uiRefresh) || void 0 === t4 || t4.call(r2, "postFrame", true);
      } }, { type: "checkbox", label: "Auto LookAt Target", getValue: () => {
        var t4;
        return null !== (t4 = e2.userData.autoLookAtTarget) && void 0 !== t4 && t4;
      }, setValue: (t4) => {
        var n2;
        e2.userData.autoLookAtTarget = t4, null === (n2 = r2.uiRefresh) || void 0 === n2 || n2.call(r2, "postFrame", true);
      } }];
      r2.children.push(...t3);
    }
    return e2.uiConfig = r2, r2;
  }
  function ye(e2, t2, n2) {
    var r2;
    if (!e2)
      return void console.warn("WebGi: setupIModel: object is undefined");
    if (e2.__disposed && (console.warn("WebGi: re-init/re-add disposed object, things might not work as intended", e2), delete e2.__disposed), e2.userData || (e2.userData = {}), e2.userData.__iModelSetup && e2.modelObject)
      return e2;
    e2.userData.__iModelSetup = true;
    let i2 = [];
    i2.push(() => {
      [...e2.children].forEach((t3) => {
        var n3;
        null === (n3 = null == t3 ? void 0 : t3.dispose) || void 0 === n3 || n3.call(t3), e2.add(t3);
      }), e2.parent && e2.removeFromParent();
    }), e2.isLight && !e2.assetType ? (e2.assetType = "light", e2.lightObject = e2) : e2.isCamera ? (e2.assetType = "camera", e2.cameraObject = e2) : e2.assetType || (e2.assetType = "model"), e2.modelObject || (e2.modelObject = e2), e2.setDirty || (e2.setDirty = (t3 = {}) => {
      e2.dispatchEvent({ ...t3, type: "objectUpdate", object: e2 });
    }, e2.userData.setDirty && console.warn("WebGi: userData.setDirty already defined", e2.userData.setDirty, e2), e2.userData.setDirty = (t3) => {
      var n3;
      console.warn("WebGi: userData.setDirty is deprecated, use setDirty directly"), null === (n3 = e2.setDirty) || void 0 === n3 || n3.call(e2, t3);
    }), e2.addEventListener("added", (t3) => {
      var n3, r3, i3;
      const s3 = null !== (r3 = null === (n3 = e2.parent) || void 0 === n3 ? void 0 : n3.userData.parentRoot) && void 0 !== r3 ? r3 : e2.parent;
      s3 !== e2.userData.parentRoot && e2.traverse((e3) => {
        e3.userData.parentRoot = s3;
      }), null === (i3 = e2.setDirty) || void 0 === i3 || i3.call(e2, { change: "addedToParent" });
    }), e2.addEventListener("removed", () => {
      var t3;
      null === (t3 = e2.setDirty) || void 0 === t3 || t3.call(e2, { change: "removedFromParent" }), void 0 !== e2.userData.parentRoot && e2.traverse((e3) => {
        e3.userData.parentRoot = void 0;
      });
    }), i2.push(() => {
    });
    const s2 = e2.dispose;
    e2.dispose = () => {
      e2.dispatchEvent({ type: "dispose" }), null == s2 || s2.call(e2);
    }, e2.userData.dispose && console.warn("WebGi: userData.dispose already defined"), e2.userData.dispose = () => {
      var t3;
      console.warn("WebGi: userData.dispose is deprecated, use dispose directly"), null === (t3 = e2.dispose) || void 0 === t3 || t3.call(e2);
    };
    const o2 = e2;
    !o2.isMesh && !o2.isLine || o2.userData.__meshSetup || (o2.userData.__meshSetup = true, o2.setMaterial || (o2.setMaterial = (e3) => be(o2, e3)), o2.setGeometry || (o2.setGeometry = (e3, t3 = false) => we(o2, e3, t3), o2.setGeometry(o2.geometry, true)), e2.userData.setMaterial && console.warn("WebGi: userData.setMaterial already defined"), e2.userData.setMaterial = (t3) => {
      var n3;
      console.warn("WebGi: userData.setMaterial is deprecated, use setMaterial directly"), null === (n3 = e2.setMaterial) || void 0 === n3 || n3.call(e2, t3);
    }, e2.userData.setGeometry && console.warn("WebGi: userData.setGeometry already defined"), e2.userData.setGeometry = (t3, ...n3) => {
      var r3;
      console.warn("WebGi: userData.setGeometry is deprecated, use setGeometry directly"), null === (r3 = e2.setGeometry) || void 0 === r3 || r3.call(e2, t3, ...n3);
    }, e2.userData.__keepShadowDef || (e2.castShadow = true, e2.receiveShadow = true, e2.userData.__keepShadowDef = true), i2.push(() => {
      var e3, t3, n3, r3;
      const i3 = (null === (e3 = o2.setMaterial) || void 0 === e3 ? void 0 : e3.call(o2, void 0)) || [], s3 = null === (t3 = o2.setGeometry) || void 0 === t3 ? void 0 : t3.call(o2, void 0);
      for (const e4 of i3)
        e4 && e4.userData && false !== e4.userData.disposeOnIdle && e4.dispose();
      s3 && s3.userData && false !== s3.userData.disposeOnIdle && s3.dispose(), null === (n3 = o2.setMaterial) || void 0 === n3 || n3.call(o2, i3), null === (r3 = o2.setGeometry) || void 0 === r3 || r3.call(o2, s3);
    })), e2.uiConfig || "model" !== e2.assetType && "camera" !== e2.assetType || (ve(e2), i2.push(() => {
    })), e2.addEventListener("objectUpdate", ({ refreshUi: t3 }) => {
      var n3, r3;
      return false !== t3 && (null === (r3 = null === (n3 = e2.uiConfig) || void 0 === n3 ? void 0 : n3.uiRefresh) || void 0 === r3 ? void 0 : r3.call(n3, "postFrame", true, 1));
    }), e2.userData.__autoParentDispatchEvents ? console.warn("WebGi: object.userData.__autoParentDispatchEvents already set") : (e2.userData.__autoParentDispatchEvents = e2.userData.__autoParentDispatchEvents || ["objectUpdate", "materialUpdate", "select", "materialChanged", "textureUpdate"], e2.isCamera && e2.userData.__autoParentDispatchEvents.push("activateMain", "setView")), t2 && (e2.userData.parentRoot = t2);
    const a2 = e2.dispatchEvent;
    e2.dispatchEvent = (t3) => {
      var n3;
      (null === (n3 = e2.userData.__autoParentDispatchEvents) || void 0 === n3 ? void 0 : n3.includes(t3.type)) && (t3.parentDispatch = true), t3.parentDispatch && ((t4) => {
        var n4;
        const r3 = null !== (n4 = e2.userData.parentRoot) && void 0 !== n4 ? n4 : e2.parent;
        (null == r3 ? void 0 : r3.modelObject) && r3.dispatchEvent(t4);
      })(t3), a2.call(e2, t3);
    };
    const l2 = e2.clone;
    e2.clone = (...t3) => {
      const r3 = e2.userData;
      e2.userData = {};
      let i3 = l2.call(e2, ...t3);
      e2.userData = r3, Ee(i3.userData, r3);
      const s3 = e2.userData.parentRoot;
      return s3 && "model" !== s3.assetType && console.warn("WebGi: Cloning an object with a parent that is not an IModel is not supported"), i3 = ye(i3, s3, n2), i3.userData.cloneParent = e2.uuid, i3;
    };
    const c2 = e2.copy;
    e2.copy = (t3, ...n3) => {
      const r3 = t3.userData;
      t3.userData = {};
      const i3 = c2.call(e2, t3, ...n3);
      return t3.userData = r3, Ee(e2.userData, t3), i3;
    };
    const u2 = e2.add;
    return e2.add = (...t3) => (t3.forEach((t4) => ye(t4, e2.userData.parentRoot || e2, n2)), u2.call(e2, ...t3)), (e2 = null !== (r2 = null == n2 ? void 0 : n2(e2)) && void 0 !== r2 ? r2 : e2).addEventListener("dispose", () => {
      i2.forEach((e3) => e3()), i2 = [];
    }), [...e2.children].forEach((t3) => ye(t3, e2, n2)), e2;
  }
  function be(e2, t2) {
    var n2, r2, i2, s2, o2;
    const a2 = (Array.isArray(t2) ? t2 : [t2]).map((e3) => null == e3 ? void 0 : e3.materialObject).filter((e3) => e3);
    if (e2.material == a2 || 1 === a2.length && e2.material === a2[0])
      return [];
    e2.userData.__materialUpdater || (e2.userData.__materialUpdater = () => {
      e2.dispatchEvent({ type: "materialUpdate" });
    }), e2.userData.__textureUpdater || (e2.userData.__textureUpdater = () => {
      e2.dispatchEvent({ type: "textureUpdate" });
    });
    const l2 = Array.isArray(e2.material) ? [...e2.material] : [e2.material];
    for (const t3 of l2)
      t3 && (t3.removeEventListener("materialUpdate", e2.userData.__materialUpdater), t3.removeEventListener("textureUpdate", e2.userData.__textureUpdater), null === (r2 = null === (n2 = t3.userData) || void 0 === n2 ? void 0 : n2.__appliedMeshes) || void 0 === r2 || r2.delete(e2));
    const c2 = [];
    for (const t3 of a2)
      t3.userData.__appliedMeshes || (t3.userData.__appliedMeshes = /* @__PURE__ */ new Set()), c2.push(t3), t3 && (t3.addEventListener("materialUpdate", e2.userData.__materialUpdater), t3.addEventListener("textureUpdate", e2.userData.__textureUpdater), t3.userData.__appliedMeshes.add(e2));
    return e2.material = 1 !== c2.length ? c2 : null !== (i2 = c2[0]) && void 0 !== i2 ? i2 : void 0, e2.dispatchEvent({ type: "materialChanged", material: t2, mesh: e2 }), null === (o2 = null === (s2 = e2.uiConfig) || void 0 === s2 ? void 0 : s2.uiRefresh) || void 0 === o2 || o2.call(s2, "postFrame", true), l2;
  }
  function we(e2, t2, r2 = false) {
    var i2, s2, o2, a2, l2, c2, u2;
    e2.userData.__objectUpdater || (e2.userData.__objectUpdater = (t3) => {
      e2.dispatchEvent({ ...t3, type: "objectUpdate" });
    });
    let p2 = e2.geometry;
    const d2 = p2;
    return (p2 !== t2 || r2) && (p2 && (p2.removeEventListener("geometryUpdate", e2.userData.__objectUpdater), null === (s2 = null === (i2 = p2.userData) || void 0 === i2 ? void 0 : i2.__appliedMeshes) || void 0 === s2 || s2.delete(e2)), p2 = t2, p2 && !p2.userData.__appliedMeshes && (p2.userData.__appliedMeshes = /* @__PURE__ */ new Set()), e2.geometry = null !== (o2 = p2) && void 0 !== o2 ? o2 : void 0, p2 && (e2.updateMorphTargets(), p2.addEventListener("geometryUpdate", e2.userData.__objectUpdater), null === (l2 = null === (a2 = p2.userData) || void 0 === a2 ? void 0 : a2.__appliedMeshes) || void 0 === l2 || l2.add(e2))), t2 && !t2.uiConfig && (t2.uiConfig = function(e3) {
      return { label: "Geometry", type: "folder", children: [{ type: "input", property: [e3, "uuid"], disabled: true }, { type: "input", property: [e3, "name"] }, { type: "button", label: "Center Geometry", value: () => {
        e3.center();
      } }, { type: "button", label: "Center Geometry (keep position)", value: () => {
        const t3 = new n.Pa4();
        e3.center(t3), t3.negate();
        const r3 = e3.userData.__appliedMeshes;
        for (const e4 of r3)
          e4.updateMatrix(), e4.position.copy(t3).applyMatrix4(e4.matrix), e4.setDirty && e4.setDirty();
      } }, { type: "button", label: "Compute vertex normals", value: () => {
        e3.computeVertexNormals();
      } }, { type: "button", label: "Compute vertex tangents", value: () => {
        e3.computeTangents();
      } }, { type: "button", label: "Normalize normals", value: () => {
        e3.normalizeNormals();
      } }, { type: "button", label: "Convert to indexed", hidden: () => !!e3.index, value: () => {
        var t3;
        if (e3.attributes.index)
          return;
        const n2 = parseFloat(null !== (t3 = prompt("Tolerance", "-1")) && void 0 !== t3 ? t3 : "-1");
        q(e3, n2);
      } }, { type: "button", label: "Convert to non-indexed", hidden: () => !e3.index, value: () => {
        e3.attributes.index && e3.toNonIndexed();
      } }, { type: "button", label: "Create uv1 from uv", value: () => {
        e3.hasAttribute("uv1") && !confirm("uv1 already exists, replace with uv data?") || e3.setAttribute("uv1", e3.getAttribute("uv"));
      } }, { type: "button", label: "Remove vertex color attribute", hidden: () => !e3.hasAttribute("color"), value: () => {
        e3.hasAttribute("color") ? confirm("Remove color attribute?") && e3.deleteAttribute("color") : prompt("No color attribute found");
      } }, { type: "button", label: "Auto GPU Instances", hidden: () => !e3.userData.__appliedMeshes || e3.userData.__appliedMeshes.size < 2, value: () => {
        _e(e3);
      } }, { type: "input", label: "Mesh count", get value() {
        var t3, n2, r3;
        return null !== (r3 = null === (n2 = null === (t3 = e3.userData) || void 0 === t3 ? void 0 : t3.__appliedMeshes) || void 0 === n2 ? void 0 : n2.size) && void 0 !== r3 ? r3 : 0;
      }, set value(e4) {
      }, disabled: true }] };
    }(e2.geometry)), e2.dispatchEvent({ type: "geometryChanged", geometry: t2 }), null === (u2 = null === (c2 = e2.uiConfig) || void 0 === c2 ? void 0 : c2.uiRefresh) || void 0 === u2 || u2.call(c2, "postFrame", true), d2 === p2 ? void 0 : d2 || void 0;
  }
  const Ae = ["appliedMeshes"], xe = ["parentRoot", "iCamera", "iModel"];
  function Ee(e2, t2) {
    if (t2)
      for (const n2 of Object.keys(t2))
        xe.includes(n2) || n2.startsWith("__") || "function" != typeof e2[n2] && "function" != typeof t2[n2] && (e2[n2] = t2[n2]);
    return e2;
  }
  var Ce, Se = new Uint8Array(16);
  function Me() {
    if (!Ce && !(Ce = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto)))
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    return Ce(Se);
  }
  for (var Te = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i, Pe = [], Ie = 0; Ie < 256; ++Ie)
    Pe.push((Ie + 256).toString(16).substr(1));
  var Re = function(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n2 = (Pe[e2[t2 + 0]] + Pe[e2[t2 + 1]] + Pe[e2[t2 + 2]] + Pe[e2[t2 + 3]] + "-" + Pe[e2[t2 + 4]] + Pe[e2[t2 + 5]] + "-" + Pe[e2[t2 + 6]] + Pe[e2[t2 + 7]] + "-" + Pe[e2[t2 + 8]] + Pe[e2[t2 + 9]] + "-" + Pe[e2[t2 + 10]] + Pe[e2[t2 + 11]] + Pe[e2[t2 + 12]] + Pe[e2[t2 + 13]] + Pe[e2[t2 + 14]] + Pe[e2[t2 + 15]]).toLowerCase();
    if (!function(e3) {
      return "string" == typeof e3 && Te.test(e3);
    }(n2))
      throw TypeError("Stringified UUID is invalid");
    return n2;
  }, ke = function(e2, t2, n2) {
    var r2 = (e2 = e2 || {}).random || (e2.rng || Me)();
    if (r2[6] = 15 & r2[6] | 64, r2[8] = 63 & r2[8] | 128, t2) {
      n2 = n2 || 0;
      for (var i2 = 0; i2 < 16; ++i2)
        t2[n2 + i2] = r2[i2];
      return t2;
    }
    return Re(r2);
  };
  const De = /* @__PURE__ */ new Map();
  function Be(e2, t2) {
    return (n2, r2) => {
      const i2 = n2.constructor;
      if (i2 === Object)
        throw new Error("All properties in an object are serialized by default");
      De.has(i2) || De.set(i2, []);
      const s2 = De.get(i2);
      if (!(s2.findIndex((e3) => e3.propKey === r2) < 0))
        throw new Error(`Property ${r2} already has a uiConfig decorator`);
      s2.push({ params: t2 || {}, propKey: r2, uiType: e2 });
    };
  }
  function Oe(e2, t2) {
    return Be("checkbox", { label: e2, params: t2 });
  }
  function Le(e2, t2) {
    return Be("monitor", { label: e2, params: t2 });
  }
  function Ue(e2, t2, n2, r2) {
    return Be("slider", { label: e2, bounds: t2, stepSize: n2, params: r2 });
  }
  function Fe(e2, t2, n2, r2) {
    return Be("vec", { label: e2, bounds: t2, stepSize: n2, params: r2 });
  }
  function Ne(e2, t2, n2) {
    return Be("dropdown", { label: e2, children: t2, params: n2 });
  }
  function je(e2, t2) {
    return Be("button", { label: e2, params: t2 });
  }
  function ze(e2, t2) {
    return Be("input", { label: e2, params: t2 });
  }
  function Ge(e2, t2) {
    return Be("color", { label: e2, params: t2 });
  }
  function Ve(e2, t2) {
    return Be("image", { label: e2, params: t2 });
  }
  function He(e2) {
    let t2 = null == e2 ? void 0 : e2.constructor;
    if (!e2 || !t2)
      return [];
    const n2 = [], r2 = [];
    for (; t2 && t2 !== Object; )
      r2.push(t2), t2 = Object.getPrototypeOf(t2);
    if (!r2.length || Array.isArray(e2)) {
      const t3 = "object" == typeof e2 ? Object.keys(e2) : Array.isArray(e2) ? e2.map((e3, t4) => t4) : [];
      for (const r3 of t3) {
        const t4 = e2[r3];
        if (null == t4)
          continue;
        const i2 = null == t4 ? void 0 : t4.uiConfig;
        if (i2)
          n2.push(i2);
        else {
          const i3 = Xe(t4);
          "folder" === i3 ? n2.push(Qe(r3 + "", t4, void 0, "folder", true)) : i3 && n2.push({ type: i3, label: r3 + "", property: [e2, r3] });
        }
      }
    }
    return r2.reverse().forEach((t3) => {
      var r3;
      null === (r3 = De.get(t3)) || void 0 === r3 || r3.forEach(({ params: t4, propKey: r4, uiType: i2 }) => {
        let s2;
        if (!i2) {
          const t5 = e2[r4];
          s2 = null == t5 ? void 0 : t5.uiConfig, s2 ? n2.push(s2) : null != t5 && ("folder" === (i2 = Xe(t5)) ? s2 = Qe(r4 + "", t5, void 0, "folder", true) : i2 && (s2 = { type: i2, label: r4 + "", property: [e2, r4] }));
        }
        if (s2 || (s2 = { property: [e2, r4], type: i2 || "input" }), t4) {
          const n3 = "function" == typeof t4.params ? t4.params(e2) : t4.params || {};
          delete t4.params, Object.assign(s2, { ...t4, ...n3 });
        }
        n2.push(s2);
      });
    }), n2;
  }
  function Qe(e2, t2, n2 = {}, r2 = "folder", i2 = false) {
    return { type: r2, label: e2, children: i2 ? [() => He(t2)] : He(t2), uuid: ke(), ...n2 };
  }
  function We(e2, t2, n2 = "folder") {
    return (r2) => class extends r2 {
      constructor() {
        super(...arguments), this.uiConfig = Qe(e2, this, t2 || {}, n2);
      }
    };
  }
  function qe(e2, t2) {
    return We(e2, t2, "panel");
  }
  function Xe(e2) {
    return null == e2 ? null : Array.isArray(e2) ? "folder" : "boolean" == typeof e2 ? "checkbox" : "number" == typeof e2 ? "number" : "string" == typeof e2 ? "input" : "function" == typeof e2 ? "button" : "number" == typeof e2.x ? "vec" : "number" == typeof e2.r ? "color" : e2.isTexture ? "image" : "object" == typeof e2 ? "folder" : null;
  }
  const Ye = { type: "change" }, Ke = { type: "start" }, Je = { type: "end" };
  class Ze extends n.pBf {
    constructor(e2, t2) {
      super(), this.object = e2, this.domElement = t2, this.domElement.style.touchAction = "none", this.enabled = true, this.target = new n.Pa4(), this.minDistance = 1e-5, this.maxDistance = 1 / 0, this.autoPushTarget = true, this.autoPullTarget = true, this.clampMax = new n.Pa4(1 / 0, 1 / 0, 1 / 0), this.clampMin = new n.Pa4(-1 / 0, -1 / 0, -1 / 0), this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = false, this.dampingFactor = 0.05, this.enableZoom = true, this.zoomSpeed = 1, this.maxZoomSpeed = 1, this.dollyZoom = false, this.enableRotate = true, this.rotateSpeed = 1, this.enablePan = true, this.panSpeed = 1, this.screenSpacePanning = true, this.keyPanSpeed = 7, this.autoRotate = false, this.autoRotateSpeed = 2, this.throttleUpdate = 0, this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }, this.mouseButtons = { LEFT: n.RsA.ROTATE, MIDDLE: n.RsA.DOLLY, RIGHT: n.RsA.PAN }, this.touches = { ONE: n.QmN.ROTATE, TWO: n.QmN.DOLLY_PAN }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function() {
        return a2.phi;
      }, this.getAzimuthalAngle = function() {
        return a2.theta;
      }, this.getDistance = function() {
        return this.object.position.distanceTo(this.target);
      }, this.listenToKeyEvents = function(e3) {
        e3.addEventListener("keydown", V2), this._domElementKeyEvents = e3;
      }, this.stopListenToKeyEvents = function() {
        this._domElementKeyEvents.removeEventListener("keydown", V2), this._domElementKeyEvents = null;
      }, this.saveState = function() {
        r2.target0.copy(r2.target), r2.position0.copy(r2.object.position), r2.zoom0 = r2.object.zoom;
      }, this.reset = function() {
        r2.target.copy(r2.target0), r2.object.position.copy(r2.position0), r2.object.zoom = r2.zoom0, r2.object.updateProjectionMatrix(), r2.dispatchEvent(Ye), r2.update(), s2 = i2.NONE;
      }, this.update = function() {
        const t3 = new n.Pa4(), d3 = new n._fP().setFromUnitVectors(e2.up, new n.Pa4(0, 1, 0)), h3 = d3.clone().invert(), f3 = new n.Pa4(), m3 = new n._fP(), _3 = new n.Pa4(), g3 = 2 * Math.PI;
        return function() {
          if (this.throttleUpdate && this.throttleUpdate >= 1 && Date.now() - 0 < 1e3 / this.throttleUpdate)
            return;
          const e3 = r2.object.position;
          t3.copy(e3).sub(r2.target), t3.applyQuaternion(d3), a2.setFromVector3(t3), r2.autoRotate && s2 === i2.NONE && E2(2 * Math.PI / 60 / 60 * r2.autoRotateSpeed), r2.enableDamping ? (a2.theta += l2.theta * r2.dampingFactor, a2.phi += l2.phi * r2.dampingFactor) : (a2.theta += l2.theta, a2.phi += l2.phi);
          let n2 = r2.minAzimuthAngle, v3 = r2.maxAzimuthAngle;
          isFinite(n2) && isFinite(v3) && (n2 < -Math.PI ? n2 += g3 : n2 > Math.PI && (n2 -= g3), v3 < -Math.PI ? v3 += g3 : v3 > Math.PI && (v3 -= g3), a2.theta = n2 <= v3 ? Math.max(n2, Math.min(v3, a2.theta)) : a2.theta > (n2 + v3) / 2 ? Math.max(n2, a2.theta) : Math.min(v3, a2.theta)), a2.phi = Math.max(r2.minPolarAngle, Math.min(r2.maxPolarAngle, a2.phi)), a2.makeSafe(), Math.abs(l2.radius) > 0 && (r2.dollyZoom && (r2.object.zoom = Math.max(Math.max(r2.minZoom, 0.1), Math.min(Math.min(r2.maxZoom, 20), r2.object.zoom * (1 + l2.radius * (r2.enableDamping ? r2.dampingFactor : 1)))), r2.object.updateProjectionMatrix(), (r2.object.zoom >= Math.min(r2.maxZoom, 20) || r2.object.zoom <= Math.max(r2.minZoom, 0.1)) && (l2.radius = 0)), a2.radius *= 1 + l2.radius * (r2.enableDamping ? r2.dampingFactor : 1)), Math.abs(c2 - 1) > 1e-5 && (r2.dollyZoom && (r2.object.zoom = Math.max(Math.max(r2.minZoom, 0.1), Math.min(Math.min(r2.maxZoom, 20), r2.object.zoom * c2)), r2.object.updateProjectionMatrix(), (r2.object.zoom >= Math.min(r2.maxZoom, 20) || r2.object.zoom <= Math.max(r2.minZoom, 0.1)) && (c2 = 1)), a2.radius *= c2);
          let y3 = 0;
          r2.autoPushTarget && a2.radius < r2.minDistance && (y3 = r2.minDistance - a2.radius), r2.autoPullTarget && a2.radius > r2.maxDistance && (y3 = r2.maxDistance - a2.radius), a2.radius = Math.max(r2.minDistance, Math.min(r2.maxDistance, a2.radius)), true === r2.enableDamping ? r2.target.addScaledVector(u2, r2.dampingFactor) : r2.target.add(u2), t3.setFromSpherical(a2), t3.applyQuaternion(h3), e3.copy(r2.target).add(t3), r2.target.add(t3.normalize().multiplyScalar(-y3)), e3.clamp(r2.clampMin, r2.clampMax), r2.target.clamp(r2.clampMin, r2.clampMax), r2.object.lookAt(r2.target);
          let b3 = false;
          return true === r2.enableDamping && Math.abs(l2.theta) + Math.abs(l2.phi) + Math.abs(l2.radius) + u2.length() > 1e-3 ? (l2.theta *= 1 - r2.dampingFactor, l2.phi *= 1 - r2.dampingFactor, l2.radius *= 1 - r2.dampingFactor, u2.multiplyScalar(1 - r2.dampingFactor), b3 = true) : (l2.set(0, 0, 0), u2.set(0, 0, 0)), c2 = 1, !!(p2 || b3 || f3.distanceToSquared(r2.object.position) > o2 || 8 * (1 - m3.dot(r2.object.quaternion)) > o2 || _3.distanceToSquared(r2.target) > 0) && (r2.dispatchEvent(Ye), f3.copy(r2.object.position), m3.copy(r2.object.quaternion), _3.copy(r2.target), p2 = false, true);
        };
      }(), this.stopDamping = function() {
        l2.set(0, 0, 0), u2.set(0, 0, 0);
      }, this.dispose = function() {
        r2.domElement.removeEventListener("contextmenu", H2), r2.domElement.removeEventListener("pointerdown", N2), r2.domElement.removeEventListener("pointercancel", z2), r2.domElement.removeEventListener("wheel", G2), r2.domElement.removeEventListener("pointermove", j2), r2.domElement.removeEventListener("pointerup", z2), null !== r2._domElementKeyEvents && (r2._domElementKeyEvents.removeEventListener("keydown", V2), r2._domElementKeyEvents = null);
      };
      const r2 = this, i2 = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 };
      let s2 = i2.NONE;
      const o2 = 1e-6, a2 = new n.$V(), l2 = new n.$V(0, 0, 0);
      let c2 = 1;
      const u2 = new n.Pa4();
      let p2 = false;
      const d2 = new n.FM8(), h2 = new n.FM8(), f2 = new n.FM8(), m2 = new n.FM8(), _2 = new n.FM8(), g2 = new n.FM8(), v2 = new n.FM8(), y2 = new n.FM8(), b2 = new n.FM8(), w2 = [], A2 = {};
      function x2() {
        return r2.enableDamping ? 1 : Math.pow(0.95, r2.zoomSpeed);
      }
      function E2(e3) {
        l2.theta -= e3;
      }
      function C2(e3) {
        l2.phi -= e3;
      }
      this.rotateUp = C2, this.rotateLeft = E2;
      const S2 = function() {
        const e3 = new n.Pa4();
        return function(t3, n2) {
          e3.setFromMatrixColumn(n2, 0), e3.multiplyScalar(-t3), u2.add(e3);
        };
      }(), M2 = function() {
        const e3 = new n.Pa4();
        return function(t3, n2) {
          true === r2.screenSpacePanning ? e3.setFromMatrixColumn(n2, 1) : (e3.setFromMatrixColumn(n2, 0), e3.crossVectors(r2.object.up, e3)), e3.multiplyScalar(t3), u2.add(e3);
        };
      }(), T2 = function() {
        const e3 = new n.Pa4();
        return function(t3, n2) {
          const i3 = r2.domElement;
          if (r2.object.isPerspectiveCamera) {
            const s3 = r2.object.position;
            e3.copy(s3).sub(r2.target);
            let o3 = e3.length();
            o3 *= Math.tan(r2.object.fov / 2 * Math.PI / 180), S2(2 * t3 * o3 / i3.clientHeight, r2.object.matrix), M2(2 * n2 * o3 / i3.clientHeight, r2.object.matrix);
          } else
            r2.object.isOrthographicCamera ? (S2(t3 * (r2.object.right - r2.object.left) / r2.object.zoom / i3.clientWidth, r2.object.matrix), M2(n2 * (r2.object.top - r2.object.bottom) / r2.object.zoom / i3.clientHeight, r2.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), r2.enablePan = false);
        };
      }();
      function P2(e3, t3 = 0) {
        r2.object.isPerspectiveCamera ? (c2 /= e3, l2.radius = Math.max(-r2.maxZoomSpeed, Math.min(r2.maxZoomSpeed, l2.radius - t3))) : r2.object.isOrthographicCamera ? (r2.object.zoom = Math.max(r2.minZoom, Math.min(r2.maxZoom, r2.object.zoom * e3)), r2.object.updateProjectionMatrix(), p2 = true) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), r2.enableZoom = false);
      }
      function I2(e3, t3 = 0) {
        r2.object.isPerspectiveCamera ? (c2 *= e3, l2.radius = Math.max(-r2.maxZoomSpeed, Math.min(r2.maxZoomSpeed, l2.radius + t3))) : r2.object.isOrthographicCamera ? (r2.object.zoom = Math.max(r2.minZoom, Math.min(r2.maxZoom, r2.object.zoom / e3)), r2.object.updateProjectionMatrix(), p2 = true) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), r2.enableZoom = false);
      }
      function R2(e3) {
        d2.set(e3.clientX, e3.clientY);
      }
      function k2(e3) {
        m2.set(e3.clientX, e3.clientY);
      }
      function D2() {
        if (1 === w2.length)
          d2.set(w2[0].pageX, w2[0].pageY);
        else {
          const e3 = 0.5 * (w2[0].pageX + w2[1].pageX), t3 = 0.5 * (w2[0].pageY + w2[1].pageY);
          d2.set(e3, t3);
        }
      }
      function B2() {
        if (1 === w2.length)
          m2.set(w2[0].pageX, w2[0].pageY);
        else {
          const e3 = 0.5 * (w2[0].pageX + w2[1].pageX), t3 = 0.5 * (w2[0].pageY + w2[1].pageY);
          m2.set(e3, t3);
        }
      }
      function O2() {
        const e3 = w2[0].pageX - w2[1].pageX, t3 = w2[0].pageY - w2[1].pageY, n2 = Math.sqrt(e3 * e3 + t3 * t3);
        v2.set(0, n2);
      }
      function L2(e3) {
        if (1 == w2.length)
          h2.set(e3.pageX, e3.pageY);
        else {
          const t4 = W2(e3), n2 = 0.5 * (e3.pageX + t4.x), r3 = 0.5 * (e3.pageY + t4.y);
          h2.set(n2, r3);
        }
        f2.subVectors(h2, d2).multiplyScalar(r2.rotateSpeed);
        const t3 = r2.domElement;
        E2(2 * Math.PI * f2.x / t3.clientHeight), C2(2 * Math.PI * f2.y / t3.clientHeight), d2.copy(h2);
      }
      function U2(e3) {
        if (1 === w2.length)
          _2.set(e3.pageX, e3.pageY);
        else {
          const t3 = W2(e3), n2 = 0.5 * (e3.pageX + t3.x), r3 = 0.5 * (e3.pageY + t3.y);
          _2.set(n2, r3);
        }
        g2.subVectors(_2, m2).multiplyScalar(r2.panSpeed), T2(g2.x, g2.y), m2.copy(_2);
      }
      function F2(e3) {
        const t3 = W2(e3), n2 = e3.pageX - t3.x, i3 = e3.pageY - t3.y, s3 = Math.sqrt(n2 * n2 + i3 * i3);
        y2.set(0, s3), b2.set(0, Math.pow(y2.y / v2.y, 6 * r2.zoomSpeed)), P2(b2.y), v2.copy(y2);
      }
      function N2(e3) {
        false !== r2.enabled && (0 === w2.length && (r2.domElement.setPointerCapture(e3.pointerId), r2.domElement.addEventListener("pointermove", j2), r2.domElement.addEventListener("pointerup", z2)), function(e4) {
          w2.push(e4);
        }(e3), "touch" === e3.pointerType ? function(e4) {
          switch (Q2(e4), w2.length) {
            case 1:
              switch (r2.touches.ONE) {
                case n.QmN.ROTATE:
                  if (false === r2.enableRotate)
                    return;
                  D2(), s2 = i2.TOUCH_ROTATE;
                  break;
                case n.QmN.PAN:
                  if (false === r2.enablePan)
                    return;
                  B2(), s2 = i2.TOUCH_PAN;
                  break;
                default:
                  s2 = i2.NONE;
              }
              break;
            case 2:
              switch (r2.touches.TWO) {
                case n.QmN.DOLLY_PAN:
                  if (false === r2.enableZoom && false === r2.enablePan)
                    return;
                  r2.enableZoom && O2(), r2.enablePan && B2(), s2 = i2.TOUCH_DOLLY_PAN;
                  break;
                case n.QmN.DOLLY_ROTATE:
                  if (false === r2.enableZoom && false === r2.enableRotate)
                    return;
                  r2.enableZoom && O2(), r2.enableRotate && D2(), s2 = i2.TOUCH_DOLLY_ROTATE;
                  break;
                default:
                  s2 = i2.NONE;
              }
              break;
            default:
              s2 = i2.NONE;
          }
          s2 !== i2.NONE && r2.dispatchEvent(Ke);
        }(e3) : function(e4) {
          let t3;
          switch (e4.button) {
            case 0:
              t3 = r2.mouseButtons.LEFT;
              break;
            case 1:
              t3 = r2.mouseButtons.MIDDLE;
              break;
            case 2:
              t3 = r2.mouseButtons.RIGHT;
              break;
            default:
              t3 = -1;
          }
          switch (t3) {
            case n.RsA.DOLLY:
              if (false === r2.enableZoom)
                return;
              !function(e5) {
                v2.set(e5.clientX, e5.clientY);
              }(e4), s2 = i2.DOLLY;
              break;
            case n.RsA.ROTATE:
              if (e4.ctrlKey || e4.metaKey || e4.shiftKey) {
                if (false === r2.enablePan)
                  return;
                k2(e4), s2 = i2.PAN;
              } else {
                if (false === r2.enableRotate)
                  return;
                R2(e4), s2 = i2.ROTATE;
              }
              break;
            case n.RsA.PAN:
              if (e4.ctrlKey || e4.metaKey || e4.shiftKey) {
                if (false === r2.enableRotate)
                  return;
                R2(e4), s2 = i2.ROTATE;
              } else {
                if (false === r2.enablePan)
                  return;
                k2(e4), s2 = i2.PAN;
              }
              break;
            default:
              s2 = i2.NONE;
          }
          s2 !== i2.NONE && r2.dispatchEvent(Ke);
        }(e3));
      }
      function j2(e3) {
        false !== r2.enabled && ("touch" === e3.pointerType ? function(e4) {
          switch (Q2(e4), s2) {
            case i2.TOUCH_ROTATE:
              if (false === r2.enableRotate)
                return;
              L2(e4), r2.update();
              break;
            case i2.TOUCH_PAN:
              if (false === r2.enablePan)
                return;
              U2(e4), r2.update();
              break;
            case i2.TOUCH_DOLLY_PAN:
              if (false === r2.enableZoom && false === r2.enablePan)
                return;
              !function(e5) {
                r2.enableZoom && F2(e5), r2.enablePan && U2(e5);
              }(e4), r2.update();
              break;
            case i2.TOUCH_DOLLY_ROTATE:
              if (false === r2.enableZoom && false === r2.enableRotate)
                return;
              !function(e5) {
                r2.enableZoom && F2(e5), r2.enableRotate && L2(e5);
              }(e4), r2.update();
              break;
            default:
              s2 = i2.NONE;
          }
        }(e3) : e3.buttons ? function(e4) {
          switch (s2) {
            case i2.ROTATE:
              if (false === r2.enableRotate)
                return;
              !function(e5) {
                h2.set(e5.clientX, e5.clientY), f2.subVectors(h2, d2).multiplyScalar(r2.rotateSpeed);
                const t3 = r2.domElement;
                E2(2 * Math.PI * f2.x / t3.clientHeight), C2(2 * Math.PI * f2.y / t3.clientHeight), d2.copy(h2), r2.update();
              }(e4);
              break;
            case i2.DOLLY:
              if (false === r2.enableZoom)
                return;
              !function(e5) {
                y2.set(e5.clientX, e5.clientY), b2.subVectors(y2, v2), b2.y > 0 ? P2(x2()) : b2.y < 0 && I2(x2()), v2.copy(y2), r2.update();
              }(e4);
              break;
            case i2.PAN:
              if (false === r2.enablePan)
                return;
              !function(e5) {
                _2.set(e5.clientX, e5.clientY), g2.subVectors(_2, m2).multiplyScalar(r2.panSpeed), T2(g2.x, g2.y), m2.copy(_2), r2.update();
              }(e4);
          }
        }(e3) : z2(e3));
      }
      function z2(e3) {
        !function(e4) {
          delete A2[e4.pointerId];
          for (let t3 = 0; t3 < w2.length; t3++)
            if (w2[t3].pointerId == e4.pointerId)
              return void w2.splice(t3, 1);
        }(e3), 0 === w2.length && (r2.domElement.releasePointerCapture(e3.pointerId), r2.domElement.removeEventListener("pointermove", j2), r2.domElement.removeEventListener("pointerup", z2)), r2.dispatchEvent(Je), s2 = i2.NONE;
      }
      function G2(e3) {
        false !== r2.enabled && false !== r2.enableZoom && s2 === i2.NONE && (e3.preventDefault(), r2.dispatchEvent(Ke), function(e4) {
          let t3 = 0;
          switch (e4.deltaMode) {
            case 2:
              t3 += 1 * e4.deltaY;
              break;
            case 1:
              t3 += 0.4 * e4.deltaY;
              break;
            default:
              t3 += 0.01 * e4.deltaY;
          }
          e4.deltaY < 0 ? I2(1, t3 * r2.zoomSpeed) : e4.deltaY > 0 && P2(1, -t3 * r2.zoomSpeed), r2.update();
        }(e3), r2.dispatchEvent(Je));
      }
      function V2(e3) {
        false !== r2.enabled && false !== r2.enablePan && function(e4) {
          let t3 = false;
          switch (e4.code) {
            case r2.keys.UP:
              e4.ctrlKey || e4.metaKey || e4.shiftKey ? C2(2 * Math.PI * r2.rotateSpeed / r2.domElement.clientHeight) : T2(0, r2.keyPanSpeed), t3 = true;
              break;
            case r2.keys.BOTTOM:
              e4.ctrlKey || e4.metaKey || e4.shiftKey ? C2(-2 * Math.PI * r2.rotateSpeed / r2.domElement.clientHeight) : T2(0, -r2.keyPanSpeed), t3 = true;
              break;
            case r2.keys.LEFT:
              e4.ctrlKey || e4.metaKey || e4.shiftKey ? E2(2 * Math.PI * r2.rotateSpeed / r2.domElement.clientHeight) : T2(r2.keyPanSpeed, 0), t3 = true;
              break;
            case r2.keys.RIGHT:
              e4.ctrlKey || e4.metaKey || e4.shiftKey ? E2(-2 * Math.PI * r2.rotateSpeed / r2.domElement.clientHeight) : T2(-r2.keyPanSpeed, 0), t3 = true;
          }
          t3 && (e4.preventDefault(), r2.update());
        }(e3);
      }
      function H2(e3) {
        false !== r2.enabled && e3.preventDefault();
      }
      function Q2(e3) {
        let t3 = A2[e3.pointerId];
        void 0 === t3 && (t3 = new n.FM8(), A2[e3.pointerId] = t3), t3.set(e3.pageX, e3.pageY);
      }
      function W2(e3) {
        const t3 = e3.pointerId === w2[0].pointerId ? w2[1] : w2[0];
        return A2[t3.pointerId];
      }
      this.zoomIn = function(e3) {
        P2(1, e3 * r2.zoomSpeed);
      }, this.zoomOut = function(e3) {
        I2(1, e3 * r2.zoomSpeed);
      }, r2.domElement.addEventListener("contextmenu", H2), r2.domElement.addEventListener("pointerdown", N2), r2.domElement.addEventListener("pointercancel", z2), r2.domElement.addEventListener("wheel", G2, { passive: false }), this.update();
    }
  }
  var $e = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let et = class extends Ze {
    constructor() {
      super(...arguments), this.type = "OrbitControls", this.enabled = true, this.dollyZoom = false, this.enableDamping = true, this.dampingFactor = 0.08, this.autoRotate = false, this.autoRotateSpeed = 2, this.enableZoom = true, this.zoomSpeed = 0.15, this.maxZoomSpeed = 0.2, this.enableRotate = true, this.rotateSpeed = 2, this.enablePan = true, this.panSpeed = 1, this.autoPushTarget = false, this.autoPullTarget = false, this.minDistance = 0.35, this.maxDistance = 1e3, this.minZoom = 0.01, this.maxZoom = 1e3, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1e4, this.maxAzimuthAngle = 1e4, this.clampMin = new n.Pa4(-1e4, -1e4, -1e4), this.clampMax = new n.Pa4(1e4, 1e4, 1e4), this.screenSpacePanning = true, this.keyPanSpeed = 7, this.throttleUpdate = 60;
    }
    zoomIn(e2) {
      super.zoomIn(e2);
    }
    zoomOut(e2) {
      super.zoomOut(e2);
    }
    dispatchEvent(e2) {
      super.dispatchEvent(e2);
    }
  };
  $e([ie()], et.prototype, "type", void 0), $e([Oe()], et.prototype, "enabled", void 0), $e([Oe(), ie()], et.prototype, "dollyZoom", void 0), $e([Oe(), ie()], et.prototype, "enableDamping", void 0), $e([ze(), ie()], et.prototype, "dampingFactor", void 0), $e([Oe(), ie()], et.prototype, "autoRotate", void 0), $e([ze(), ie()], et.prototype, "autoRotateSpeed", void 0), $e([Oe(), ie()], et.prototype, "enableZoom", void 0), $e([ze(), ie()], et.prototype, "zoomSpeed", void 0), $e([ze(), ie()], et.prototype, "maxZoomSpeed", void 0), $e([Oe(), ie()], et.prototype, "enableRotate", void 0), $e([ze(), ie()], et.prototype, "rotateSpeed", void 0), $e([Oe(), ie()], et.prototype, "enablePan", void 0), $e([ze(), ie()], et.prototype, "panSpeed", void 0), $e([ze(), ie()], et.prototype, "autoPushTarget", void 0), $e([ze(), ie()], et.prototype, "autoPullTarget", void 0), $e([ze(), ie()], et.prototype, "minDistance", void 0), $e([ze(), ie()], et.prototype, "maxDistance", void 0), $e([ze(), ie()], et.prototype, "minZoom", void 0), $e([ze(), ie()], et.prototype, "maxZoom", void 0), $e([ze(), ie()], et.prototype, "minPolarAngle", void 0), $e([ze(), ie()], et.prototype, "maxPolarAngle", void 0), $e([ze(), ie()], et.prototype, "minAzimuthAngle", void 0), $e([ze(), ie()], et.prototype, "maxAzimuthAngle", void 0), $e([Fe(), ie()], et.prototype, "clampMin", void 0), $e([Fe(), ie()], et.prototype, "clampMax", void 0), $e([ie()], et.prototype, "screenSpacePanning", void 0), $e([ie()], et.prototype, "keyPanSpeed", void 0), et = $e([qe("Orbit Controls")], et);
  var tt = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  class nt extends t.SimpleEventDispatcher {
    get controls() {
      return this._controls;
    }
    getControls() {
      return this._controls;
    }
    get userData() {
      return this._camera.modelObject.userData;
    }
    set userData(e2) {
      this._camera.modelObject.userData = e2;
    }
    get isActiveCamera() {
      return this._isActiveCamera;
    }
    get target() {
      return this._target;
    }
    set target(e2) {
      const t2 = this._target.sub(e2).length() > 0;
      this._target.copy(e2), t2 && this.targetUpdated();
    }
    get position() {
      return this._position;
    }
    set position(e2) {
      const t2 = this._position.sub(e2).length() > 0;
      this._position.copy(e2), t2 && this.positionUpdated();
    }
    get name() {
      return this._camera.name;
    }
    set name(e2) {
      this._camera.name = e2;
    }
    getCameraOptions() {
      return { ...this._options, position: this._position.toArray(), target: this._target.toArray() };
    }
    setCameraOptions(e2, t2 = true) {
      var n2, r2;
      const i2 = { ...e2 };
      (null === (n2 = i2.position) || void 0 === n2 ? void 0 : n2.isVector3) && (i2.position = [i2.position.x, i2.position.y, i2.position.z]), (null === (r2 = i2.target) || void 0 === r2 ? void 0 : r2.isVector3) && (i2.target = [i2.target.x, i2.target.y, i2.target.z]), Object.keys(i2).forEach((e3) => "frustumSize" !== e3 && void 0 === i2[e3] && delete i2[e3]), Object.assign(this._options, i2), this._refreshCameraOptions(false), this.refreshCameraControls(false), t2 && this.setDirty({ optionsUpdate: true });
    }
    _refreshCameraOptions(e2 = true) {
      let t2 = this._camera.modelObject;
      if (this._options.type !== t2.type) {
        const e3 = "PerspectiveCamera" === this._options.type ? new n.cPb() : new n.iKG();
        e3.name = this._camera.name, e3.near = this._camera.modelObject.near, e3.far = this._camera.modelObject.far, e3.zoom = this._camera.modelObject.zoom, e3.scale.copy(this._camera.modelObject.scale);
        const r3 = this._isActiveCamera;
        r3 && this.deactivateMain(), this._camera = this._setCameraObject(e3), t2 = this._camera.modelObject, r3 && this.activateMain(), this._camera.modelObject.updateProjectionMatrix();
      }
      let r2 = this._options.aspect;
      if ("auto" === r2 && (r2 = this._container.clientWidth / this._container.clientHeight), this._options.position && (this.position.set(...this._options.position), delete this._options.position), this._options.target && (this.target.set(...this._options.target), delete this._options.target), this.positionUpdated(false), "PerspectiveCamera" === this._options.type && (t2.fov = this._options.fov, t2.focus = this._options.focus, t2.aspect = r2), "OrthographicCamera" === this._options.type) {
        const e3 = this._options.frustumSize;
        void 0 !== e3 ? (t2.top = e3 / 2, t2.bottom = -e3 / 2, t2.left = r2 * e3 / 2, t2.right = -r2 * e3 / 2) : (t2.top = this._options.top, t2.bottom = this._options.bottom, t2.left = this._options.left, t2.right = this._options.right);
      }
      t2.zoom = this._options.zoom, this._nearFarChanged(), e2 && this.setDirty();
    }
    _setCameraObject(e2) {
      return this._camera && this._camera.removeEventListener("objectUpdate", this._cameraObjectUpdate), this._camera = ye(e2), this._camera.addEventListener("objectUpdate", this._cameraObjectUpdate), this._camera;
    }
    get interactionsEnabled() {
      return 0 === this._interactionsDisabledBy.size && this._isActiveCamera && this._options.controlsEnabled && "" !== this._options.controlsMode;
    }
    set interactionsEnabled(e2) {
      this.setInteractions(e2, "_default");
    }
    setInteractions(e2, t2) {
      const n2 = this._interactionsDisabledBy.size;
      e2 ? this._interactionsDisabledBy.delete(t2) : this._interactionsDisabledBy.add(t2), n2 !== this._interactionsDisabledBy.size && this.refreshCameraControls(true);
    }
    _nearFarChanged() {
      this._camera && (this._camera.modelObject.near = this.near, this._camera.modelObject.far = this.far, this._camera.modelObject.updateProjectionMatrix());
    }
    constructor(e2, t2, r2) {
      var i2;
      super(), this._controlsMode = "", this._isActiveCamera = false, this._cameraObjectUpdate = (e3) => {
        this.setDirty(e3);
      }, this._interactionsDisabledBy = /* @__PURE__ */ new Set(), this.autoLookAtTarget = false, this.near = 0.01, this.far = 50, this._options = { type: "PerspectiveCamera", aspect: "auto", focus: 10, fov: 25, zoom: 1, frustumSize: 1, top: 1, bottom: -1, left: -1, right: 1, controlsMode: "orbit", controlsEnabled: true }, this._position = new n.Pa4(0, 0, 10), this._target = new n.Pa4(0, 0, 0), this._controlsCtors = /* @__PURE__ */ new Map([["orbit", (e3, t3) => {
        const n2 = new et(e3, t3.ownerDocument ? t3 : t3.documentElement);
        return n2.screenSpacePanning = true, n2;
      }]]), this._positionWorld = new n.Pa4(), this._camUi = [{ type: "vec3", label: "Position", property: [this, "position"], onChange: () => this.positionUpdated(true) }, { type: "vec3", label: "Target", property: [this, "target"], onChange: () => this.targetUpdated(true) }, { type: "slider", bounds: [1, 180], label: "Field Of View", hidden: () => !this._camera.modelObject.isPerspectiveCamera, property: [this._options, "fov"], onChange: () => this.refreshCameraOptions(), limitedUi: true }, { type: "checkbox", label: "Auto Near far", getValue: () => {
        var e3;
        return null === (e3 = this._camera.userData.autoNearFar) || void 0 === e3 || e3;
      }, setValue: (e3) => this._camera.userData.autoNearFar = e3, onChange: () => this.setDirty() }, { type: "checkbox", label: "Auto Camera Position", getValue: () => {
        var e3;
        return null !== (e3 = this._camera.userData.autoCameraPosition) && void 0 !== e3 && e3;
      }, setValue: (e3) => this._camera.userData.autoCameraPosition = e3, onChange: () => this.setDirty() }, { type: "input", label: () => {
        var e3;
        return null === (e3 = this._camera.userData.autoNearFar) || void 0 === e3 || e3 ? "Min Near" : "Near";
      }, getValue: () => {
        var e3;
        return null !== (e3 = this._camera.userData.minNearPlane) && void 0 !== e3 ? e3 : 0.5;
      }, setValue: (e3) => this._camera.userData.minNearPlane = e3, onChange: () => this.setDirty() }, { type: "input", label: () => {
        var e3;
        return null === (e3 = this._camera.userData.autoNearFar) || void 0 === e3 || e3 ? "Max Far" : "Far";
      }, getValue: () => {
        var e3;
        return null !== (e3 = this._camera.userData.maxFarPlane) && void 0 !== e3 ? e3 : 1e3;
      }, setValue: (e3) => this._camera.userData.maxFarPlane = e3, onChange: () => this.setDirty() }, () => ({ type: "dropdown", label: "Controls Mode", property: [this._options, "controlsMode"], children: ["", "orbit", ...this._controlsCtors.keys()].map((e3) => ({ label: "" === e3 ? "none" : e3, value: e3 })), onChange: () => {
        this.refreshCameraOptions();
      } })], this.uiConfig = { type: "folder", label: "Camera", limitedUi: true, children: [...this._camUi, () => {
        var e3;
        return (null === (e3 = this._controls) || void 0 === e3 ? void 0 : e3.zoomIn) ? { type: "button", label: "Zoom in", value: () => {
          var e4;
          null === (e4 = this._controls) || void 0 === e4 || e4.zoomIn(1);
        } } : {};
      }, () => {
        var e3;
        return (null === (e3 = this._controls) || void 0 === e3 ? void 0 : e3.zoomOut) ? { type: "button", label: "Zoom out", value: () => {
          var e4;
          null === (e4 = this._controls) || void 0 === e4 || e4.zoomOut(1);
        } } : {};
      }, () => {
        var e3;
        return null === (e3 = this._controls) || void 0 === e3 ? void 0 : e3.uiConfig;
      }] }, this.assetType = "model", this.uuid = n.M8C.generateUUID(), this.setDirty = this.setDirty.bind(this), this.targetUpdated = this.targetUpdated.bind(this), this._refreshCameraOptions = this._refreshCameraOptions.bind(this), this._container = null != r2 ? r2 : document.body;
      const s2 = null !== (i2 = { ...t2 }) && void 0 !== i2 ? i2 : this._options;
      this._camera = this._setCameraObject(null != e2 ? e2 : "OrthographicCamera" === s2.type ? new n.iKG(-1, 1, 1, -1) : new n.cPb()), this._camera.modelObject.userData.iCamera = this;
      const o2 = e2;
      e2 && (o2.isPerspectiveCamera ? (s2.fov = o2.fov, s2.focus = o2.focus, s2.aspect = o2.aspect <= 0 || o2.userData.autoAspect ? "auto" : o2.aspect, s2.zoom = o2.zoom) : o2.isOrthographicCamera && (s2.left = o2.left, s2.right = o2.right, s2.top = o2.top, s2.bottom = o2.bottom, s2.zoom = o2.zoom), this.near = o2.near, this.far = o2.far, this._position.copy(e2.position), this.refreshTarget()), this.positionUpdated(false), this.setCameraOptions(s2);
    }
    refreshAspect(e2 = true) {
      "auto" === this._options.aspect && this._refreshCameraOptions(e2);
    }
    refreshTarget(e2 = 4) {
      var t2;
      (null === (t2 = this._controls) || void 0 === t2 ? void 0 : t2.enabled) && this._controls.target ? this._target.copy(this._controls.target) : this.cameraObject.getWorldDirection(this._target).multiplyScalar(e2).add(this.cameraObject.getWorldPosition(new n.Pa4()));
    }
    setControlsCtor(e2, t2, n2 = false) {
      n2 || !this._controlsCtors.has(e2) ? this._controlsCtors.set(e2, t2) : console.error(e2 + " already exists.");
    }
    removeControlsCtor(e2) {
      this._controlsCtors.delete(e2);
    }
    _initCameraControls() {
      var e2, t2, n2;
      const r2 = this._options.controlsMode;
      this._controls = null !== (t2 = null === (e2 = this._controlsCtors.get(r2)) || void 0 === e2 ? void 0 : e2(this._camera.modelObject, this._container)) && void 0 !== t2 ? t2 : void 0, this._controls || "" === r2 || console.error("Unable to create controls with mode " + r2 + ". Are you missing a plugin?"), null === (n2 = this._controls) || void 0 === n2 || n2.addEventListener("change", this.setDirty), this._controlsMode = this._controls ? r2 : "";
    }
    _disposeCameraControls() {
      var e2, t2;
      this._controlsMode, null === (e2 = this._controls) || void 0 === e2 || e2.removeEventListener("change", this.setDirty), null === (t2 = this._controls) || void 0 === t2 || t2.dispose(), this._controlsMode = "", this._controls = void 0;
    }
    refreshCameraControls(e2 = true) {
      var t2, r2;
      if (this._options.controlsEnabled) {
        const e3 = this._options.controlsMode;
        this._controls ? this._controlsMode === e3 && this._camera.modelObject === this._controls.object || (this._disposeCameraControls(), this._initCameraControls()) : this._initCameraControls(), this._controlsMode = e3;
      }
      if (this._controls) {
        const e3 = this.interactionsEnabled;
        this._controls.enabled = e3, e3 && this._camera.modelObject.up.copy(n.Tme.DEFAULT_UP);
      }
      e2 && this.setDirty(), null === (r2 = (t2 = this.uiConfig).uiRefresh) || void 0 === r2 || r2.call(t2, "postFrame", true);
    }
    setDirty(e2) {
      var t2, n2;
      this._position.copy(this._camera.modelObject.position), this._controls && this._controls.enabled && this._controls.target && this._target.copy(this._controls.target), void 0 !== this._camera.modelObject.fov && (this._options.fov = this._camera.modelObject.fov), void 0 !== this._camera.modelObject.focus && (this._options.focus = this._camera.modelObject.focus), void 0 !== this._camera.modelObject.zoom && (this._options.zoom = this._camera.modelObject.zoom), null === (n2 = (t2 = this.cameraObject).updateProjectionMatrix) || void 0 === n2 || n2.call(t2), this.cameraObject.getWorldPosition(this._positionWorld), this.dispatchEvent({ ...e2, type: "update" }), this._camUi.forEach((e3) => {
        var t3;
        return null === (t3 = null == e3 ? void 0 : e3.uiRefresh) || void 0 === t3 ? void 0 : t3.call(e3, "postFrame", false, 1);
      });
    }
    activateMain(e2 = true) {
      var t2, r2;
      this._isActiveCamera || (this._isActiveCamera = true, this._camera.modelObject.userData.__lastScale = this._camera.modelObject.scale.clone(), this._camera.modelObject.scale.divide(this._camera.modelObject.getWorldScale(new n.Pa4())), e2 && (this.refreshCameraControls(false), this._refreshCameraOptions(true)), null === (r2 = (t2 = this._camera).setDirty) || void 0 === r2 || r2.call(t2, { change: "activateMain" }));
    }
    deactivateMain(e2 = true) {
      this._isActiveCamera && (this._isActiveCamera = false, this._camera.modelObject.userData.__lastScale && (this._camera.modelObject.scale.copy(this._camera.modelObject.userData.__lastScale), delete this._camera.modelObject.userData.__lastScale), e2 && this.refreshCameraControls(true));
    }
    get cameraObject() {
      return this._camera.modelObject;
    }
    get modelObject() {
      return this._camera.modelObject;
    }
    dispose() {
      this._disposeCameraControls();
    }
    targetUpdated(e2 = true) {
      var t2, n2;
      const r2 = this.target;
      null === (n2 = null === (t2 = this._controls) || void 0 === t2 ? void 0 : t2.target) || void 0 === n2 || n2.set(r2.x, r2.y, r2.z), this._controls && this._controls.enabled && this._controls.target ? e2 && this.setDirty() : this._camera && (void 0 !== this._camera.userData.autoLookAtTarget && (this.autoLookAtTarget = this._camera.userData.autoLookAtTarget), this.autoLookAtTarget && this._camera.modelObject.lookAt(r2), e2 && this.setDirty());
    }
    positionUpdated(e2 = true) {
      const t2 = this.position;
      this._camera.modelObject.position.set(t2.x, t2.y, t2.z), this.targetUpdated(e2);
    }
    positionTargetUpdated(e2 = true) {
      this.positionUpdated(e2);
    }
    copyFromCamera(e2, t2 = 4) {
      e2.getWorldPosition(this._position), e2.getWorldDirection(this._target).multiplyScalar(t2).add(this._position), this.positionUpdated(false), this.setCameraOptions({ fov: e2.fov, focus: e2.focus, zoom: e2.zoom, type: e2.type }, true);
    }
    updateShaderProperties(e2) {
      var t2, n2, r2, i2;
      return null === (n2 = null === (t2 = e2.uniforms.cameraPositionWorld) || void 0 === t2 ? void 0 : t2.value) || void 0 === n2 || n2.copy(this._positionWorld), null === (i2 = null === (r2 = e2.uniforms.cameraNearFar) || void 0 === r2 ? void 0 : r2.value) || void 0 === i2 || i2.set(this._camera.modelObject.near, this._camera.modelObject.far), e2.uniforms.projection && (e2.uniforms.projection.value = this._camera.modelObject.projectionMatrix), e2.defines.PERSPECTIVE_CAMERA = "PerspectiveCamera" === this._camera.modelObject.type ? "1" : "0", e2.defines.ORTHOGRAPHIC_CAMERA = "OrthographicCamera" === this._camera.modelObject.type ? "1" : "0", this;
    }
    toJSON(e2) {
      const t2 = {};
      return Ee(t2, this.userData), Object.assign({ userData: t2 }, le(this, true, e2));
    }
    fromJSON(e2, t2) {
      return e2.userData && (Ee(this.userData, e2.userData), delete (e2 = { ...e2 }).userData), e2.camOptions && (this.setCameraOptions(e2.camOptions, false), this.refreshCameraOptions(false)), ce(e2, this, true, t2), this.positionUpdated(false), this.refreshCameraOptions(false), this.setDirty({ change: "deserialize" }), this;
    }
    refreshCameraOptions(e2 = true) {
      this.setCameraOptions(this._options, e2);
    }
    get visible() {
      return true;
    }
    set visible(e2) {
      console.error("Cannot set visible on camera", e2);
    }
  }
  tt([ie("camControls")], nt.prototype, "_controls", void 0), tt([(0, t.onChange)(nt.prototype._nearFarChanged)], nt.prototype, "near", void 0), tt([(0, t.onChange)(nt.prototype._nearFarChanged)], nt.prototype, "far", void 0), tt([ie("camOptions")], nt.prototype, "_options", void 0), tt([ie("position")], nt.prototype, "_position", void 0), tt([ie("target")], nt.prototype, "_target", void 0);
  var rt = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  class it extends n.xsS {
    get activeCamera() {
      return this._activeCamera >= 0 ? this._cameras[this._activeCamera] : this._dummyCam;
    }
    set activeCamera(e2) {
      const t2 = this.activeCamera;
      if (e2 || (e2 = this.defaultCamera), t2 !== e2) {
        if (t2 && (t2.deactivateMain(), t2.removeEventListener("update", this._activeCameraUpdate)), e2) {
          e2.activateMain(), e2.addEventListener("update", this._activeCameraUpdate);
          let t3 = this._cameras.indexOf(e2);
          t3 < 0 && (this._cameras.push(e2), t3 = this._cameras.length - 1), this._activeCamera = t3;
        } else
          this._activeCamera = -1;
        this.dispatchEvent({ type: "activeCameraChange", lastCamera: t2, camera: e2 }), this.setDirty();
      }
    }
    get renderCamera() {
      var e2;
      return null !== (e2 = this._renderCamera) && void 0 !== e2 ? e2 : this.activeCamera;
    }
    set renderCamera(e2) {
      const t2 = this._renderCamera;
      this._renderCamera = e2, this.dispatchEvent({ type: "renderCameraChange", lastCamera: t2, camera: e2 });
    }
    get modelObject() {
      return this;
    }
    constructor(e2) {
      super(), this.isRootScene = true, this.assetType = "model", this._sceneBounds = new h(), this._modelBounds = new h(), this._sceneBoundingRadius = 0, this._cameras = [], this._activeCamera = -1, this.envMapIntensity = 1, this.fixedEnvMapDirection = false, this.backgroundIntensity = 1, this._dummyCam = new nt(new n.cPb(), { controlsMode: "", controlsEnabled: false }), this.environment = null, this.textureSlots = {}, this.background = null, this.backgroundColor = null, this.setDirty = this.setDirty.bind(this), this.updateScene = this.updateScene.bind(this), this.refreshActiveCameraNearFar = this.refreshActiveCameraNearFar.bind(this), this._activeCameraUpdate = this._activeCameraUpdate.bind(this), this._optionsUpdate = this._optionsUpdate.bind(this), this._onSceneMaterialUpdate = this._onSceneMaterialUpdate.bind(this), this._onSceneUpdate = this._onSceneUpdate.bind(this), this.addEventListener("materialUpdate", this._onSceneMaterialUpdate), this.addEventListener("materialChanged", this._onSceneMaterialUpdate), this.addEventListener("objectUpdate", this._onSceneUpdate), this.defaultCamera = e2, this.modelRoot = ye(new n.ZAu(), void 0), this.modelRoot.userData.rootSceneModelRoot = true, this.modelRoot.name = "Scene", this.modelRoot.addEventListener("update", this.setDirty), this.addSceneObject(this.modelRoot, { addToRoot: true, autoScale: false }), this.addSceneObject(this.defaultCamera, { addToRoot: true }), this.activeCamera = this.defaultCamera, this.boxHelper = new n.GQ(this.getBounds());
    }
    addModel(e2, t2 = {}) {
      return "model" !== e2.assetType && console.error("Invalid asset type for ", e2, ", adding anyway"), this.addSceneObject(e2, t2);
    }
    addWidget(e2, t2 = {}) {
      "widget" !== e2.assetType && console.warn("Invalid asset type for ", e2, ", adding anyway"), this.add(e2.modelObject);
    }
    _addModel(e2, t2 = {}) {
      return this._addObject3D(null == e2 ? void 0 : e2.modelObject, t2);
    }
    addSceneObject(e2, t2) {
      if (!e2)
        return e2;
      const n2 = e2.assetType;
      let r2 = false;
      switch (n2) {
        case "model":
          r2 = e2.modelObject.isCamera, r2 && (t2 = { ...t2, autoScale: false }), this._addModel(e2, t2);
          break;
        case "material":
          break;
        case "texture":
          this.dispatchEvent({ type: "textureAdded", texture: e2 });
          break;
        case "light":
          this._addLight(e2, t2);
          break;
        default:
          console.warn("WebGi RootScene: Unknown asset imported", e2, n2);
      }
      return this.dispatchEvent({ type: "addSceneObject", object: e2, options: t2 }), e2;
    }
    _addObject3D(e2, { autoScale: t2 = true, autoScaleRadius: n2 = 2, addToRoot: r2 = false } = {}) {
      const i2 = e2;
      i2 ? (t2 && !i2.userData.autoScaled && W(i2, i2.userData.autoScaleRadius || n2), i2.traverse((e3) => {
        e3.isMesh && !e3.userData.__keepShadowDef && (e3.castShadow = true, e3.receiveShadow = true, e3.userData.__keepShadowDef = true);
      }), r2 ? this.modelObject.add(i2) : this.modelRoot.add(i2), this.setDirty()) : console.error("Invalid Model, cannot add.");
    }
    removeSceneModels() {
      this.modelRoot.clear(), this.modelRoot.children = [], this.setDirty({ sceneUpdate: true });
    }
    disposeSceneModels() {
      [...this.modelRoot.children].forEach((e2) => {
        var t2, n2;
        (null !== (t2 = e2.dispose) && void 0 !== t2 ? t2 : null === (n2 = e2.modelObject) || void 0 === n2 ? void 0 : n2.removeFromParent)();
      }), this.setDirty({ sceneUpdate: true });
    }
    _onEnvironmentChange() {
      var e2;
      (null === (e2 = this.environment) || void 0 === e2 ? void 0 : e2.mapping) === n.xfE && (this.environment.mapping = n.dSO, this.environment.needsUpdate = true), this.dispatchEvent({ type: "environmentChanged", environment: this.environment }), this._onSceneUpdate({ geometryChanged: false });
    }
    _onBackgroundChange() {
      this.dispatchEvent({ type: "backgroundChanged", background: this.background, backgroundColor: this.backgroundColor }), this._onSceneUpdate({ geometryChanged: false });
    }
    add(...e2) {
      return super.add(...e2.map((e3) => ye(e3))), this._onSceneUpdate(), this;
    }
    setEnvironment(e2) {
      if (!e2)
        return void (this.environment = null);
      if (!e2.isTexture)
        return void console.error("Unknown Environment type", e2);
      "texture" !== e2.assetType && console.warn("Environment asset not processed", e2);
      const t2 = e2.textureObject || e2;
      this.environment = t2;
    }
    getEnvironment() {
      return this.environment;
    }
    setBackground(e2) {
      let t2;
      if (!e2 || "texture" === e2.assetType || e2.isTexture || e2.isColor || "environment" === e2)
        t2 = ("texture" === (null == e2 ? void 0 : e2.assetType) || e2.isTexture) && e2.textureObject || e2;
      else {
        if ("string" != typeof e2 && "number" != typeof e2)
          return void console.error("Unknown Background type", e2);
        t2 = new n.Ilk(e2);
      }
      this.background = t2;
    }
    setBackgroundColor(e2) {
      this.backgroundColor = e2 ? new n.Ilk(e2) : null;
    }
    getBackground() {
      return this.background;
    }
    setDirty(e2) {
      return (null == e2 ? void 0 : e2.sceneUpdate) || (null == e2 ? void 0 : e2.refreshScene) ? this._onSceneUpdate(e2) : this.dispatchEvent({ type: "update" }), this;
    }
    updateScene(e2) {
      return this._onSceneUpdate(e2);
    }
    _activeCameraUpdate(e2) {
      e2.optionsUpdate && this._optionsUpdate(e2), this.setDirty(), this.refreshActiveCameraNearFar(), this.dispatchEvent({ ...e2, type: "activeCameraUpdate" });
    }
    _optionsUpdate(e2) {
      if (!this.activeCamera.userData.autoCameraPosition)
        return;
      const t2 = new h().expandByObject(this.modelRoot.modelObject, false, true), r2 = (t2.getCenter(new n.Pa4()), t2.getSize(new n.Pa4()));
      let i2 = this.activeCamera.cameraObject, s2 = 1;
      if (i2.isPerspectiveCamera) {
        const e3 = Math.max(1, i2.fov) * (Math.PI / 180), t3 = 2 * Math.atan(Math.tan(e3 / 2) * i2.aspect), n2 = r2.z / 2 + Math.abs(r2.x / 2 / Math.tan(t3 / 2)), o3 = r2.z / 2 + Math.abs(r2.y / 2 / Math.tan(e3 / 2));
        s2 = 1.5 * Math.max(n2, o3);
      }
      const o2 = this.activeCamera.target, a2 = new n.Pa4().subVectors(o2, i2.position).normalize();
      this.activeCamera.position = a2.multiplyScalar(-s2).add(o2);
    }
    _onSceneUpdate(e2 = {}) {
      var t2, r2, i2, s2;
      return false === e2.sceneUpdate && false === e2.refreshScene || (null === (t2 = e2.object) || void 0 === t2 ? void 0 : t2.isCamera) ? this.setDirty(e2) : (this.refreshActiveCameraNearFar(), this._sceneBounds = this.getBounds(false, true), null === (s2 = null === (i2 = null === (r2 = this.boxHelper) || void 0 === r2 ? void 0 : r2.box) || void 0 === i2 ? void 0 : i2.copy) || void 0 === s2 || s2.call(i2, this._sceneBounds), this._modelBounds = this.getModelBounds(false, true), this._sceneBoundingRadius = this._modelBounds.getSize(new n.Pa4()).length() / 2, this.dispatchEvent({ ...e2, type: "sceneUpdate", hierarchyChanged: ["addedToParent", "removedFromParent"].includes(e2.change || "") }), this);
    }
    _onSceneMaterialUpdate() {
      this.dispatchEvent({ type: "sceneMaterialUpdate" });
    }
    dispose() {
      var e2;
      this.disposeSceneModels(), this.clear(), null === (e2 = this.environment) || void 0 === e2 || e2.dispose();
    }
    findObjectsByName(e2, t2) {
      const n2 = [];
      return (null != t2 ? t2 : this.modelObject).traverse((t3) => {
        t3.name === e2 && n2.push(t3);
      }), n2;
    }
    addLight(e2, t2 = {}) {
      this.addSceneObject(e2, t2);
    }
    _addLight(e2, { addToRoot: t2 = false } = {}) {
      var n2;
      const r2 = e2.lightObject;
      r2 && (null === (n2 = r2.children) || void 0 === n2 || n2.length, t2 ? this.add(r2) : this.modelRoot.add(r2));
    }
    getBounds(e2 = false, t2 = true, n2 = true, r2) {
      return new h().expandByObject(this.modelObject, e2, t2, (e3) => {
        var t3;
        return !(!n2 || "widget" !== e3.assetType) || null !== (t3 = null == r2 ? void 0 : r2(e3)) && void 0 !== t3 && t3;
      });
    }
    getModelBounds(e2 = false, t2 = true, n2 = true, r2) {
      return null == this.modelRoot ? new h() : new h().expandByObject(this.modelRoot, e2, t2, (e3) => {
        var t3;
        return !(!n2 || "widget" !== e3.assetType) || null !== (t3 = null == r2 ? void 0 : r2(e3)) && void 0 !== t3 && t3;
      });
    }
    refreshActiveCameraNearFar() {
      var e2, t2, r2, i2;
      const s2 = this.activeCamera;
      if (!s2)
        return;
      if (false === s2.cameraObject.userData.autoNearFar)
        return s2.near = null !== (e2 = s2.cameraObject.userData.minNearPlane) && void 0 !== e2 ? e2 : 0.5, void (s2.far = null !== (t2 = s2.cameraObject.userData.maxFarPlane) && void 0 !== t2 ? t2 : 1e3);
      const o2 = this.getBounds(false), a2 = s2.cameraObject.getWorldPosition(new n.Pa4()).sub(o2.getCenter(new n.Pa4())), l2 = 1.5 * o2.getSize(new n.Pa4()).length() / 2, c2 = Math.max(0.1, -a2.clone().normalize().dot(s2.cameraObject.getWorldDirection(new n.Pa4()))), u2 = a2.length(), p2 = Math.max(Math.max(null !== (r2 = s2.cameraObject.userData.minNearPlane) && void 0 !== r2 ? r2 : 0.5, 1e-3), c2 * (u2 - l2)), d2 = Math.min(Math.max(p2 + l2, c2 * (u2 + l2)), null !== (i2 = s2.cameraObject.userData.maxFarPlane) && void 0 !== i2 ? i2 : 1e3);
      s2.near = p2, s2.far = d2;
    }
    updateShaderProperties(e2) {
      return e2.uniforms.sceneBoundingRadius ? e2.uniforms.sceneBoundingRadius.value = this._sceneBoundingRadius : console.warn("BaseRenderer: no uniform: frameCount"), this;
    }
    toJSON(e2) {
      return le(this, true, e2);
    }
    fromJSON(e2, t2) {
      const n2 = e2.environment;
      return void 0 !== n2 && (this.setEnvironment(ce(n2, this.getEnvironment(), false, t2)), delete e2.environment), ce(e2, this, true, t2), e2.environment = n2, this;
    }
    addEventListener(e2, t2) {
      super.addEventListener(e2, t2);
    }
    removeEventListener(e2, t2) {
      super.removeEventListener(e2, t2);
    }
    get minNearDistance() {
      var e2;
      return console.error("minNearDistance is deprecated. Use camera.userData.minNearPlane instead"), null !== (e2 = this.activeCamera.userData.minNearPlane) && void 0 !== e2 ? e2 : 0.5;
    }
    set minNearDistance(e2) {
      console.error("minNearDistance is deprecated. Use camera.userData.minNearPlane instead"), this.activeCamera && (this.activeCamera.userData.minNearPlane = e2);
    }
  }
  rt([ie()], it.prototype, "defaultCamera", void 0), rt([(0, t.onChange2)(it.prototype.setDirty), ie()], it.prototype, "envMapIntensity", void 0), rt([(0, t.onChange2)(it.prototype.setDirty), ie()], it.prototype, "fixedEnvMapDirection", void 0), rt([(0, t.onChange2)(it.prototype.setDirty), ie()], it.prototype, "backgroundIntensity", void 0), rt([ie(), (0, t.onChange)(it.prototype._onEnvironmentChange.name)], it.prototype, "environment", void 0), rt([ie()], it.prototype, "textureSlots", void 0), rt([ie(), (0, t.onChange)(it.prototype._onBackgroundChange)], it.prototype, "background", void 0), rt([ie(), (0, t.onChange)(it.prototype._onBackgroundChange)], it.prototype, "backgroundColor", void 0);
  const st = true;
  function ot(e2, t2, n2, { replaceAll: r2 = false, prepend: i2 = false, append: s2 = false } = {}) {
    if (st && !e2.includes(t2))
      return console.error(`${t2} not found in shader`), e2;
    let o2 = n2;
    return i2 ? o2 = n2 + t2 : s2 && (o2 = t2 + n2), r2 ? e2.replaceAll(t2, o2) : e2.replace(t2, o2);
  }
  class at {
    static ApplyMaterialExtensions(e2, t2, n2, r2) {
      for (const i2 of n2)
        this.ApplyMaterialExtension(e2, t2, i2, r2);
    }
    static ApplyMaterialExtension(e2, n2, r2, i2) {
      var s2, o2;
      let a2 = null !== (s2 = (0, t.getOrCall)(r2.parsFragmentSnippet, i2, e2)) && void 0 !== s2 ? s2 : "";
      a2.length && (n2.fragmentShader = ot(n2.fragmentShader, this.VoidMain, "\n" + a2 + "\n", { prepend: true })), a2 = null !== (o2 = (0, t.getOrCall)(r2.parsVertexSnippet, i2, e2)) && void 0 !== o2 ? o2 : "", a2.length && (n2.vertexShader = ot(n2.vertexShader, this.VoidMain, "\n" + a2 + "\n", { prepend: true })), r2.extraUniforms && (n2.uniforms = Object.assign(n2.uniforms, r2.extraUniforms)), r2.extraDefines && function(e3, t2) {
        let n3 = false;
        t2.materialObject && void 0 === t2.materialObject.defines && (t2.materialObject.defines = {});
        const r3 = Object.entries(e3);
        for (const [e4, i3] of r3)
          void 0 === i3 ? void 0 !== t2.materialObject.defines[e4] && (delete t2.materialObject.defines[e4], n3 = true) : t2.materialObject.defines[e4] !== i3 && (t2.materialObject.defines[e4] = i3, n3 = true);
        n3 && (t2.materialObject.needsUpdate = true);
      }(r2.extraDefines, e2), r2.shaderExtender && r2.shaderExtender(n2, e2, i2), e2.lastShader = n2;
    }
    static CacheKeyForExtensions(e2, t2) {
      let n2 = "";
      for (const r2 of t2)
        n2 += this.CacheKeyForExtension(e2, r2);
      return n2;
    }
    static CacheKeyForExtension(e2, t2) {
      let n2 = "";
      return t2.customCacheKey && (n2 += t2.customCacheKey), t2.computeCacheKey && (n2 += t2.computeCacheKey(e2)), t2.extraDefines && Object.values(t2.extraDefines).forEach((e3) => n2 += e3), n2;
    }
    static RegisterExtensions(e2, n2) {
      const r2 = [];
      if (n2)
        for (const t2 of n2)
          t2.isCompatible && t2.isCompatible(e2) && (r2.push(t2), t2.uuid || (t2.uuid = ke()), t2.__setDirty || (t2.__setDirty = () => {
            t2.updateVersion || (t2.updateVersion = 0), t2.updateVersion++;
          }), t2.setDirty || (t2.setDirty = t2.__setDirty));
      return e2.materialExtensions = r2, e2.__ext_beforeRenderListen || (e2.__ext_beforeRenderListen = true, e2.addEventListener("beforeRender", (n3) => function(e3, { object: n4, renderer: r3 }) {
        var i2;
        if (e3.materialExtensions)
          for (const s2 of e3.materialExtensions) {
            if (null === (i2 = s2.onObjectRender) || void 0 === i2 || i2.call(s2, n4, e3, r3), e3.lastShader) {
              const n5 = (0, t.getOrCall)(s2.updaters) || [];
              for (const t2 of n5)
                t2 && t2.updateShaderProperties(e3.lastShader);
            }
            s2.updateVersion !== e3.materialObject.userData["_" + s2.uuid + "_version"] && (e3.materialObject.userData["_" + s2.uuid + "_version"] = s2.updateVersion, e3.materialObject.needsUpdate = true);
          }
      }(e2, n3))), e2.__ext_afterRenderListen || (e2.__ext_afterRenderListen = true, e2.addEventListener("afterRender", (t2) => function(e3, { object: t3, renderer: n3 }) {
        var r3;
        if (e3.materialExtensions)
          for (const i2 of e3.materialExtensions)
            null === (r3 = i2.onAfterRender) || void 0 === r3 || r3.call(i2, t3, e3, n3);
      }(e2, t2))), r2;
    }
  }
  at.VoidMain = "void main()";
  class lt extends n.jyz {
    constructor(e2, t2 = false) {
      var n2;
      super(e2), this.typeSlug = "shaderMat", this.assetType = "material", this.materialObject = this, this.materialExtensions = [], this.isRawShaderMaterial = false, this.extraUniformsToUpload = {}, t2 && (this.isRawShaderMaterial = true, this.type = "RawShaderMaterial"), this.materialExtensions = at.RegisterExtensions(this, null !== (n2 = null == e2 ? void 0 : e2.customMaterialExtensions) && void 0 !== n2 ? n2 : []);
    }
    registerMaterialExtensions(e2) {
      this.materialExtensions = [...this.materialExtensions, ...at.RegisterExtensions(this, e2)];
    }
    unregisterMaterialExtensions(e2) {
    }
    onBeforeCompile(e2, t2) {
      at.ApplyMaterialExtensions(this, e2, this.materialExtensions, t2), this.dispatchEvent({ type: "beforeCompile", shader: e2, renderer: t2 }), e2.fragmentShader = e2.fragmentShader.replaceAll("#glMarker", "// "), super.onBeforeCompile(e2, t2);
    }
    customProgramCacheKey() {
      return super.customProgramCacheKey() + at.CacheKeyForExtensions(this, this.materialExtensions);
    }
    onBeforeRender(e2, t2, n2, r2, i2) {
      super.onBeforeRender(e2, t2, n2, r2, i2), this.dispatchEvent({ type: "beforeRender", renderer: e2, scene: t2, camera: n2, geometry: r2, object: i2 });
    }
    onAfterRender(e2, t2, n2, r2, i2) {
      super.onAfterRender(e2, t2, n2, r2, i2), this.dispatchEvent({ type: "afterRender", renderer: e2, scene: t2, camera: n2, geometry: r2, object: i2 });
    }
    setDirty(e2) {
      this.needsUpdate = true, this.dispatchEvent({ ...e2, type: "materialUpdate" });
    }
  }
  class ct extends lt {
    constructor() {
      super(...arguments), this.typeSlug = "shaderMat";
    }
    toJSON(e2) {
      throw new Error("Method not supported for this material.");
    }
    fromJSON(e2, t2) {
      throw new Error("Method not supported for this material.");
    }
    copyProps(e2) {
      throw new Error("Method not supported for this material.");
    }
  }
  class ut extends ct {
    constructor(e2, t2) {
      super(e2), this.typeSlug = "shaderMat", this.textures = [], this.setTextureIds(t2);
    }
    setTextureIds(e2) {
      this.textures.map((e3) => e3.id).join(";") !== e2.join(";") && (this.textures = e2.map((e3) => ({ id: e3, colorSpace: n.aCh })), this.setDirty());
    }
    _setUniformTexSize(e2, t2) {
      var n2, r2, i2, s2;
      if (!t2 || !e2)
        return;
      const o2 = null !== (r2 = null === (n2 = t2.image) || void 0 === n2 ? void 0 : n2.width) && void 0 !== r2 ? r2 : 512, a2 = null !== (s2 = null === (i2 = t2.image) || void 0 === i2 ? void 0 : i2.height) && void 0 !== s2 ? s2 : 512, l2 = e2.value;
      l2.isVector2 || console.warn("uniform is not a Vector2"), l2 && Math.abs(l2.x - o2) + Math.abs(l2.y - a2) > 0.1 && (l2.x = o2, l2.y = a2, this.uniformsNeedUpdate = true);
    }
    onBeforeRender(e2, t2, n2, r2, i2) {
      var s2, o2;
      this._setUniformTexSize(this.uniforms.screenSize, null === (s2 = e2.getRenderTarget()) || void 0 === s2 ? void 0 : s2.texture);
      for (const e3 of this.textures) {
        const t3 = e3.id, n3 = null === (o2 = this.uniforms[t3]) || void 0 === o2 ? void 0 : o2.value;
        n3 && (this._setUniformTexSize(this.uniforms[t3 + "Size"], n3), n3.colorSpace !== e3.colorSpace && (e3.colorSpace = n3.colorSpace, this.needsUpdate = true));
      }
      super.onBeforeRender(e2, t2, n2, r2, i2);
    }
    onBeforeCompile(e2, t2) {
      e2.fragmentShader = this.textures.map((e3) => {
        var t3, r2;
        return `uniform sampler2D ${e3.id}; 
` + U(null !== (t3 = e3.id) && void 0 !== t3 ? t3 : "input", null !== (r2 = e3.colorSpace) && void 0 !== r2 ? r2 : n.aCh);
      }).join("\n") + e2.fragmentShader, super.onBeforeCompile(e2, t2);
    }
    customProgramCacheKey() {
      return super.customProgramCacheKey() + this.textures.map((e2) => e2.id + e2.colorSpace).join(";");
    }
  }
  function pt(e2, ...t2) {
    const n2 = e2.fragmentShader;
    return new ut({ defines: Object.assign({}, e2.defines), uniforms: e2.uniforms, vertexShader: e2.vertexShader, fragmentShader: n2 }, t2);
  }
  class dt extends l {
    constructor(e2, ...t2) {
      super(e2.isMaterial ? e2 : pt(e2, ...t2), t2.length < 1 ? dt.DEFAULT_TEX_ID : t2[0]), this.onDirty = [], this.isShaderPass2 = true, this.enabled = true, this.setDirty = this.setDirty.bind(this);
    }
    dispose() {
      var e2, t2, n2, r2;
      null === (t2 = null === (e2 = this.material) || void 0 === e2 ? void 0 : e2.dispose) || void 0 === t2 || t2.call(e2), null === (r2 = null === (n2 = this.fsQuad) || void 0 === n2 ? void 0 : n2.dispose) || void 0 === r2 || r2.call(n2), this.onDirty = [];
    }
    setDirty() {
      this.onDirty.forEach((e2) => e2());
    }
    updateShaderProperties(e2) {
      e2 && (Array.isArray(e2) || (e2 = [e2]), e2.forEach((e3) => null == e3 ? void 0 : e3.updateShaderProperties(this.material)));
    }
    render(e2, t2, n2, r2, i2) {
      this.enabled && super.render(e2, t2 || null, n2, r2, i2);
    }
  }
  dt.DEFAULT_TEX_ID = "tDiffuse", function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    s2 > 3 && o2 && Object.defineProperty(t2, n2, o2);
  }([Oe("Enabled"), ie()], dt.prototype, "enabled", void 0);
  class ht extends i {
    constructor(e2, t2, r2, i2, s2) {
      super(), this.scene = e2, this.camera = t2, this.overrideMaterial = r2, this.clearColor = i2, this.clearAlpha = void 0 !== s2 ? s2 : 0, this.clear = true, this.clearDepth = false, this.needsSwap = false, this._oldClearColor = new n.Ilk();
    }
    render(e2, t2, n2, r2, i2, s2) {
      if (!this.scene || !this.camera)
        return;
      const o2 = e2.autoClear;
      let a2, l2;
      if (e2.autoClear = false, void 0 !== this.overrideMaterial && (l2 = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor && (e2.getClearColor(this._oldClearColor), a2 = e2.getClearAlpha(), e2.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && e2.clearDepth(), e2.setRenderTarget(this.renderToScreen ? null : n2), s2) {
        const t3 = e2.getContext();
        t3.framebufferRenderbuffer(t3.FRAMEBUFFER, t3.DEPTH_ATTACHMENT, t3.RENDERBUFFER, s2);
      }
      if (this.clear && e2.clear(e2.autoClearColor, e2.autoClearDepth, e2.autoClearStencil), e2.render(this.scene, this.camera), s2) {
        const t3 = e2.getContext();
        t3.framebufferRenderbuffer(t3.FRAMEBUFFER, t3.DEPTH_ATTACHMENT, t3.RENDERBUFFER, null);
      }
      this.clearColor && e2.setClearColor(this._oldClearColor, a2), void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = l2), e2.autoClear = o2;
    }
  }
  class ft extends dt {
    constructor(e2, n2 = "c = a + b;", i2 = "", s2) {
      super({ vertexShader: r.vertexShader, fragmentShader: t.glsl`
                varying vec2 vUv;
                
                ${i2}
                
                void blend(in vec4 a, in vec4 b, inout vec4 c){
                
                ${n2}
                
                }
                void main() {
                    vec4 texel = vec4(0);
                    blend(tDiffuseTexelToLinear ( texture2D( tDiffuse, vUv ) ), tDiffuse2TexelToLinear ( texture2D( tDiffuse2, vUv ) ), texel);
                    texel = clamp(texel, vec4(0), vec4(8));
                    gl_FragColor = texel;
                    #include <encodings_fragment>
                }
            `, uniforms: { tDiffuse: { value: null }, tDiffuse2: { value: s2 }, ...e2 } }, "tDiffuse", "tDiffuse2"), this.clear = false, this.needsSwap = true;
    }
  }
  class mt extends ct {
    constructor(e2 = true) {
      super({ vertexShader: "#define DEPTH_NORMAL \n#if IS_GLSL3 > 0\nout vec3 vViewPosition;\n#else\nvarying vec3 vViewPosition;\n#endif\n#ifdef USE_ALPHAMAP\n#define USE_UV \n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main(){\n#include <uv_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <normal_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition=-mvPosition.xyz;}", fragmentShader: "#define DEPTH_NORMAL \n#if IS_GLSL3 > 0\nin vec3 vViewPosition;\n#else\nvarying vec3 vViewPosition;\n#endif\n#ifdef USE_ALPHAMAP\n#define USE_UV \n#include <packing>\n#endif\n#if IS_GLSL3 > 0\n#ifndef gl_FragColor \nlayout(location=0)out vec4 A;layout(location=1)out vec4 B;\n#endif\n#endif\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nuniform vec2 cameraNearFar;uniform vec4 flags;vec2 pack16(float value){float f=clamp(value,0.,1.)*255.;float digitLow=fract(f);float digitHigh=floor(f)/255.;return vec2(digitHigh,digitLow);}vec2 packNormal(vec3 n){float p=sqrt(n.z*8.+8.);return vec2(n.xy/p+0.5);}float linstep(float edge0,float edge1,float value){return clamp((value-edge0)/(edge1-edge0),0.,1.);}float getSSCurvature(in vec3 normal){vec3 n=normalize(normal);vec3 dx=dFdx(n);vec3 dy=dFdy(n);vec3 xneg=n-dx;vec3 xpos=n+dx;vec3 yneg=n-dy;vec3 ypos=n+dy;float curvature=(cross(xneg,xpos).y-cross(yneg,ypos).x);return curvature;}void main(){\n#glMarker mainStart\n#include <clipping_planes_fragment>\nvec4 diffuseColor=vec4(1.);\n#include <map_fragment>\n#ifdef USE_ALPHAMAP\nfloat alphaMapValue=\n#ifdef ALPHA_I_RGBA_PACKING\n1.-unpackRGBAToDepth(texture2D(alphaMap,vAlphaMapUv));\n#else\ntexture2D(alphaMap,vAlphaMapUv).g;\n#endif\n#if defined(INVERSE_ALPHAMAP) && INVERSE_ALPHAMAP >= 1\ndiffuseColor.a*=1.-alphaMapValue;\n#else\ndiffuseColor.a*=alphaMapValue;\n#endif\n#endif\n#include <alphatest_fragment>\n#include <logdepthbuf_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#ifdef FORCED_LINEAR_DEPTH\nfloat linearZ=float(FORCED_LINEAR_DEPTH);\n#else\nfloat linearZ=linstep(-cameraNearFar.x,-cameraNearFar.y,-vViewPosition.z);\n#endif\nvec2 packedZ=pack16(pow(linearZ,0.5));vec2 packedNormal=packNormal(normal);\n#if IS_GLSL3 > 0\n#ifndef gl_FragColor \nA=vec4(packedZ.x,packedZ.y,packedNormal.x,packedNormal.y);B=flags;B.x=getSSCurvature(normal)*0.5+0.5;\n#else\ngl_FragColor=vec4(packedZ.x,packedZ.y,packedNormal.x,packedNormal.y);\n#endif\n#else\ngl_FragColor=vec4(packedZ.x,packedZ.y,packedNormal.x,packedNormal.y);\n#endif\n}", uniforms: n.rDY.merge([n.rBU.common, n.rBU.bumpmap, n.rBU.normalmap, n.rBU.displacementmap, { cameraNearFar: { value: new n.FM8(0.1, 1e3) }, flags: { value: new n.Ltg(255, 255, 255, 255) } }]), defines: { IS_GLSL3: e2 ? "1" : "0" }, glslVersion: e2 ? n.LSk : n.v9Y }), this.normalMapType = n.IOt, this.flatShading = false, this._updaters = [];
    }
    onBeforeRender(e2, t2, r2, i2, s2) {
      var o2, a2, l2, c2, u2, p2, d2, h2, f2, m2, _2, g2, v2;
      super.onBeforeRender(e2, t2, r2, i2, s2);
      let y2 = s2.material;
      Array.isArray(y2) && (y2 = y2[0]), this.uniforms.map.value = null !== (o2 = null == y2 ? void 0 : y2.map) && void 0 !== o2 ? o2 : null, this.uniforms.map.value && e2.materials.refreshTransformUniform(this.uniforms.map.value, this.uniforms.mapTransform), this.uniforms.alphaMap.value = null !== (a2 = null == y2 ? void 0 : y2.alphaMap) && void 0 !== a2 ? a2 : null, this.uniforms.alphaMap.value && e2.materials.refreshTransformUniform(this.uniforms.alphaMap.value, this.uniforms.alphaMapTransform), this.alphaTest = !y2 || !y2.alphaTest || y2.alphaTest < 1e-7 ? 1e-3 : y2.alphaTest, this.uniforms.alphaTest.value = this.alphaTest, this.uniforms.displacementMap.value = null !== (l2 = null == y2 ? void 0 : y2.displacementMap) && void 0 !== l2 ? l2 : null, this.uniforms.displacementMap.value && e2.materials.refreshTransformUniform(this.uniforms.displacementMap.value, this.uniforms.displacementMapTransform), this.uniforms.displacementScale.value = null !== (c2 = null == y2 ? void 0 : y2.displacementScale) && void 0 !== c2 ? c2 : 1, this.uniforms.displacementBias.value = null !== (u2 = null == y2 ? void 0 : y2.displacementBias) && void 0 !== u2 ? u2 : 0, this.uniforms.bumpMap.value = null !== (p2 = null == y2 ? void 0 : y2.bumpMap) && void 0 !== p2 ? p2 : null, this.uniforms.bumpMap.value && e2.materials.refreshTransformUniform(this.uniforms.bumpMap.value, this.uniforms.bumpMapTransform), this.uniforms.bumpScale.value = null !== (d2 = null == y2 ? void 0 : y2.bumpScale) && void 0 !== d2 ? d2 : 1, this.uniforms.normalMap.value = null !== (h2 = null == y2 ? void 0 : y2.normalMap) && void 0 !== h2 ? h2 : null, this.uniforms.normalMap.value && e2.materials.refreshTransformUniform(this.uniforms.normalMap.value, this.uniforms.normalMapTransform), this.uniforms.normalScale.value && this.uniforms.normalScale.value.copy(null !== (f2 = null == y2 ? void 0 : y2.normalScale) && void 0 !== f2 ? f2 : new n.FM8(1, 1)), this.normalMapType = null !== (m2 = null == y2 ? void 0 : y2.normalMapType) && void 0 !== m2 ? m2 : n.IOt, this.flatShading = null !== (_2 = null == y2 ? void 0 : y2.flatShading) && void 0 !== _2 && _2, this.uniforms.flags.value.set(255, 255, 255, 255), this.uniforms.flags.value.z = ((null == y2 ? void 0 : y2.userData.matId) ? null == y2 ? void 0 : y2.userData.matId : 0) / 255, this._updaters.forEach((e3) => {
        e3(s2, this.uniforms.flags.value);
      }), this.uniforms.flags.value.y /= 255, this.uniforms.flags.value.w /= 255, this.uniformsNeedUpdate = true;
      let b2 = this.uniforms.alphaMap.value ? 1 : void 0;
      b2 !== this.defines.USE_ALPHAMAP && (void 0 === b2 ? (delete this.defines.USE_ALPHAMAP, delete this.defines.ALPHAMAP_UV) : (this.defines.USE_ALPHAMAP = b2, this.defines.ALPHAMAP_UV = "uv"), this.needsUpdate = true), b2 = this.uniforms.map.value ? 1 : void 0, b2 !== this.defines.USE_MAP && (void 0 === b2 ? (delete this.defines.USE_MAP, delete this.defines.MAP_UV) : (this.defines.USE_MAP = b2, this.defines.MAP_UV = "uv"), this.needsUpdate = true), b2 = this.uniforms.bumpMap.value ? 1 : void 0, b2 !== this.defines.USE_BUMPMAP && (void 0 === b2 ? (delete this.defines.USE_BUMPMAP, delete this.defines.BUMPMAP_UV) : (this.defines.USE_BUMPMAP = b2, this.defines.BUMPMAP_UV = "uv"), this.needsUpdate = true), b2 = this.uniforms.normalMap.value ? 1 : void 0, b2 !== this.defines.USE_NORMALMAP && (void 0 === b2 ? (delete this.defines.USE_NORMALMAP, delete this.defines.NORMALMAP_UV) : (this.defines.USE_NORMALMAP = b2, this.defines.NORMALMAP_UV = "uv"), this.needsUpdate = true), b2 = this.uniforms.displacementMap.value ? 1 : void 0, b2 !== this.defines.USE_DISPLACEMENTMAP && (void 0 === b2 ? (delete this.defines.USE_DISPLACEMENTMAP, delete this.defines.DISPLACEMENTMAP_UV) : (this.defines.USE_DISPLACEMENTMAP = b2, this.defines.DISPLACEMENTMAP_UV = "uv"), this.needsUpdate = true), b2 = y2.userData.ALPHA_I_RGBA_PACKING ? 1 : void 0, b2 !== this.defines.ALPHA_I_RGBA_PACKING && (void 0 === b2 ? delete this.defines.ALPHA_I_RGBA_PACKING : this.defines.ALPHA_I_RGBA_PACKING = b2, this.needsUpdate = true), b2 = null !== (g2 = y2.userData.forcedLinearDepth) && void 0 !== g2 ? g2 : void 0, b2 !== this.defines.FORCED_LINEAR_DEPTH && (void 0 === b2 ? delete this.defines.FORCED_LINEAR_DEPTH : this.defines.FORCED_LINEAR_DEPTH = b2, this.needsUpdate = true), this.side = null !== (v2 = y2.side) && void 0 !== v2 ? v2 : n.ehD;
    }
    addGBufferUpdater(e2) {
      this._updaters.push(e2);
    }
    removeGBufferUpdater(e2) {
      const t2 = this._updaters.indexOf(e2);
      -1 !== t2 && this._updaters.splice(t2, 1);
    }
  }
  var _t = "#ifndef UNPACK_GBUFFER_SNIPPET\n#define UNPACK_GBUFFER_SNIPPET \nuniform sampler2D tNormalDepth;float unpack16(vec2 value){return value.x+value.y/255.;}vec3 unpackNormal(vec2 enc){vec2 fenc=enc*4.-2.;float f=dot(fenc,fenc);float g=sqrt(1.-f/4.);return vec3(fenc*g,1.-f/2.);}float unpackDepth(vec2 uncodedDepth){float x=unpack16(uncodedDepth.xy);return x*x;}float getDepth(vec2 uv){vec4 uncodedDepth=texture2D(tNormalDepth,uv);return unpackDepth(uncodedDepth.xy);}void getDepthNormal(const in vec2 uv,out float depth,out vec3 normal){vec4 uncodedDepth=texture2D(tNormalDepth,uv);depth=unpackDepth(uncodedDepth.xy);normal=unpackNormal(uncodedDepth.zw);}vec3 getViewNormal(const in vec2 uv){return unpackNormal(texture2D(tNormalDepth,uv).zw);}\n#if defined(GBUFFER_HAS_FLAGS) && GBUFFER_HAS_FLAGS == 1\nuniform sampler2D tGBufferFlags;\n#endif\nivec4 getGBufferFlags(const in vec2 uv){\n#if defined(GBUFFER_HAS_FLAGS) && GBUFFER_HAS_FLAGS == 1\nreturn ivec4(texture2D(tGBufferFlags,uv)*255.);\n#else\nreturn ivec4(1);\n#endif\n}\n#endif\n";
  class gt extends t.SimpleEventDispatcher {
    constructor() {
      super(...arguments), this._dirty = false;
    }
    get dirty() {
      return this.enabled && this._dirty;
    }
    set dirty(e2) {
      this._dirty = e2;
    }
    get viewer() {
      return this._viewer;
    }
    async onAdded(e2) {
      this._viewer = e2;
    }
    async onDispose(e2) {
    }
    async onRemove(e2) {
      this._viewer !== e2 && console.error("Wrong viewer"), this._viewer = void 0;
    }
    toJSON(e2) {
      const t2 = le(this, true, e2);
      return t2.type = this.constructor.PluginType, this.dispatchEvent({ type: "serialize", data: t2 }), t2;
    }
    fromJSON(e2, t2) {
      return e2.type !== this.constructor.PluginType ? null : (ce(e2, this, true, t2), this.dispatchEvent({ type: "deserialize", data: e2, meta: t2 }), this);
    }
    _storeKey(e2) {
      return (null != e2 ? e2 : "webgi") + "_" + (this.constructor.PluginType || this.constructor.name);
    }
    exportState() {
      var e2, t2, n2, r2;
      return null !== (n2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPluginByType("AssetManager")) || void 0 === t2 ? void 0 : t2.exportPluginPreset(this)) && void 0 !== n2 ? n2 : null === (r2 = this.toJSON) || void 0 === r2 ? void 0 : r2.call(this);
    }
    async importState(e2) {
      var t2, n2;
      const r2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPluginByType("AssetManager");
      r2 ? await r2.importPluginPreset(e2, this) : null === (n2 = this.fromJSON) || void 0 === n2 || n2.call(this, e2);
    }
    storeState(e2, t2, n2) {
      (t2 = t2 || (window ? window.localStorage : void 0)) ? (void 0 === n2 && (n2 = this.exportState()), n2 && t2.setItem(this._storeKey(e2), JSON.stringify(n2))) : console.warn("Unable to store state");
    }
    async loadState(e2, t2) {
      if (!(t2 = t2 || (window ? window.localStorage : void 0)))
        return void console.warn("Unable to load state");
      const n2 = t2.getItem(this._storeKey(e2));
      n2 && await this.importState(JSON.parse(n2));
    }
  }
  function vt(e2, n2, r2) {
    return { ...n2, get dirty() {
      return n2.dirty || false;
    }, set dirty(e3) {
      (0, t.safeSetProperty)(n2, "dirty", e3, true);
    }, update() {
      var e3, i2, s2;
      this.passObject.enabled && (null === (i2 = (e3 = this.passObject).updateShaderProperties) || void 0 === i2 || i2.call(e3, (0, t.getOrCall)(r2)), null === (s2 = n2.update) || void 0 === s2 || s2.call(this));
    }, onRegister(t2) {
      var r3, i2, s2;
      this.passObject.materialExtension && (null === (i2 = null === (r3 = e2.getPluginByType("AssetManager")) || void 0 === r3 ? void 0 : r3.materials) || void 0 === i2 || i2.registerMaterialExtension(this.passObject.materialExtension)), null === (s2 = n2.onRegister) || void 0 === s2 || s2.call(this, t2);
    }, onUnregister(t2) {
      var r3, i2, s2;
      this.passObject.materialExtension && (null === (i2 = null === (r3 = e2.getPluginByType("AssetManager")) || void 0 === r3 ? void 0 : r3.materials) || void 0 === i2 || i2.unregisterMaterialExtension(this.passObject.materialExtension)), null === (s2 = n2.onUnregister) || void 0 === s2 || s2.call(this, t2);
    }, dispose() {
      var e3, t2, r3;
      null === (t2 = (e3 = this.passObject).dispose) || void 0 === t2 || t2.call(e3), null === (r3 = n2.dispose) || void 0 === r3 || r3.call(this);
    } };
  }
  class yt extends gt {
    _update(e2) {
      var t2;
      return (null === (t2 = this._pass) || void 0 === t2 ? void 0 : t2.enabled) && this.enabled || false;
    }
    get enabled() {
      var e2, t2, n2;
      return null !== (n2 = null === (t2 = null === (e2 = this._pass) || void 0 === e2 ? void 0 : e2.passObject) || void 0 === t2 ? void 0 : t2.enabled) && void 0 !== n2 ? n2 : this._enabledTemp;
    }
    set enabled(e2) {
      var t2;
      (null === (t2 = this._pass) || void 0 === t2 ? void 0 : t2.passObject) && (this._pass.passObject.enabled = e2), this._enabledTemp = e2;
    }
    constructor() {
      super(), this._enabledTemp = true;
    }
    async onAdded(e2) {
      await super.onAdded(e2);
      const t2 = { enabled: true, passId: this.passId, passObject: this.passCtor(e2), after: this._afterFilters, before: this._beforeFilters, required: this._requiredFilters, set dirty(t3) {
        t3 && e2.setDirty();
      }, get dirty() {
        return false;
      }, update: () => this._update(e2) };
      this._pass = vt(e2, t2), void 0 !== t2.passObject.onDirty && t2.passObject.onDirty.push(() => t2.dirty = true), e2.renderer.registerPass(this._pass), this.enabled = this._enabledTemp;
    }
    async onRemove(e2) {
      var t2, n2;
      this._pass && e2.renderer.unregisterPass(this._pass), null === (n2 = null === (t2 = this._pass) || void 0 === t2 ? void 0 : t2.dispose) || void 0 === n2 || n2.call(t2), this._pass = void 0, await super.onRemove(e2);
    }
    get pass() {
      return this._pass;
    }
    toJSON(e2) {
      var t2;
      const n2 = super.toJSON(e2);
      if (!n2.type)
        return n2;
      const r2 = this.pass;
      return r2 && (n2.pass = le(null !== (t2 = null == r2 ? void 0 : r2.passObject) && void 0 !== t2 ? t2 : r2, false, e2)), n2;
    }
    fromJSON(e2, t2) {
      var n2;
      if (!super.fromJSON(e2, t2))
        return null;
      if (e2.pass) {
        const r2 = this.pass;
        r2 && ce(e2.pass, null !== (n2 = null == r2 ? void 0 : r2.passObject) && void 0 !== n2 ? n2 : r2, false, t2);
      }
      return this;
    }
  }
  !function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    s2 > 3 && o2 && Object.defineProperty(t2, n2, o2);
  }([ie()], yt.prototype, "enabled", null);
  class bt extends ht {
    constructor(e2, t2, r2 = new n.Ilk(1, 1, 1), i2 = 1) {
      super(void 0, void 0, t2, r2, i2), this.target = e2, this._transparentMats = /* @__PURE__ */ new Set(), this._transmissiveMats = /* @__PURE__ */ new Set();
    }
    render(e2, t2, n2, r2, i2) {
      var s2;
      const o2 = e2.getRenderTarget(), a2 = e2.getActiveCubeFace(), l2 = e2.getActiveMipmapLevel();
      null === (s2 = this.scene) || void 0 === s2 || s2.traverse(({ material: e3 }) => {
        e3 && ((e3.transparent && e3.userData.renderToDepth || !e3.transparent && 0 === e3.transmission && false === e3.userData.renderToDepth) && (this._transparentMats.add(e3), e3.transparent = !e3.transparent), Math.abs(e3.transmission || 0) > 0 && e3.userData.renderToDepth && (this._transmissiveMats.add([e3, e3.transmission]), e3.transmission = 0));
      }), H(e2, { shadowMapRender: false, backgroundRender: false, opaqueRender: true, transparentRender: false, transmissionRender: false, mainRenderPass: false }, () => super.render(e2, t2, this.target, r2, i2)), this._transparentMats.forEach((e3) => e3.transparent = !e3.transparent), this._transparentMats.clear(), this._transmissiveMats.forEach(([e3, t3]) => e3.transmission = t3), this._transmissiveMats.clear(), e2.setRenderTarget(o2, a2, l2);
    }
  }
  class wt extends yt {
    get material() {
      return this._material;
    }
    passCtor(e2) {
      var t2, r2, i2;
      const s2 = (null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.renderer.isWebGL2) && this.renderFlagsBuffer, o2 = e2.renderer.createTarget({ depthBuffer: true, samples: (null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.useGBufferDepth) && (null === (i2 = this._viewer) || void 0 === i2 ? void 0 : i2.renderer.composerTarget.samples) || 0, type: n.ywz, textureCount: s2 ? 2 : 1, depthTexture: this.renderDepthTexture, depthTextureType: this.depthTextureType });
      return Array.isArray(o2.texture) ? (o2.texture[0].name = "gbufferDepthNormal", o2.texture[1].name = "gbufferFlags", this._gbufferTextures = o2.texture) : (o2.texture.name = "gbufferDepthNormal", this._gbufferTextures.push(o2.texture)), this._gbufferTarget = o2, this._material = new mt(s2), this._material.userData.isGBufferMaterial = true, new bt(o2, this._material);
    }
    _update(e2) {
      if (!super._update(e2))
        return false;
      const t2 = this.pass.passObject;
      return t2.scene = e2.scene.modelObject, e2.scene.renderCamera.updateShaderProperties(t2.overrideMaterial), t2.camera = e2.scene.renderCamera.cameraObject, true;
    }
    constructor(e2 = true, t2 = false, r2 = n.JQ4) {
      super(), this.renderFlagsBuffer = e2, this.renderDepthTexture = t2, this.depthTextureType = r2, this.passId = "gbuffer", this._beforeFilters = ["render"], this._afterFilters = [], this._requiredFilters = ["render"], this._gbufferTextures = [];
    }
    getDepthNormal() {
      return this._gbufferTextures.length > 0 ? this._gbufferTextures[0] : void 0;
    }
    getFlagsTexture() {
      return this._gbufferTextures.length > 1 ? this._gbufferTextures[1] : void 0;
    }
    async onDispose(e2) {
    }
    async onRemove(e2) {
      return this._gbufferTarget && (e2.renderer.disposeTarget(this._gbufferTarget), this._gbufferTarget = void 0), super.onRemove(e2);
    }
    getTarget() {
      return this._gbufferTarget;
    }
    getDepthTexture() {
      var e2;
      return null === (e2 = this._gbufferTarget) || void 0 === e2 ? void 0 : e2.depthTexture;
    }
    getUnpackSnippet() {
      return _t;
    }
    updateShaderProperties(e2) {
      var t2, n2, r2;
      if (e2.uniforms.tNormalDepth ? e2.uniforms.tNormalDepth.value = null !== (t2 = this.getDepthNormal()) && void 0 !== t2 ? t2 : void 0 : null === (n2 = this._viewer) || void 0 === n2 || n2.console.warn("BaseRenderer: no uniform: tNormalDepth"), e2.uniforms.tGBufferFlags) {
        e2.uniforms.tGBufferFlags.value = null !== (r2 = this.getFlagsTexture()) && void 0 !== r2 ? r2 : void 0;
        const t3 = e2.uniforms.tGBufferFlags.value ? 1 : 0;
        t3 !== e2.defines.GBUFFER_HAS_FLAGS && (e2.defines.GBUFFER_HAS_FLAGS = t3, e2.needsUpdate = true);
      }
      return this;
    }
    registerGBufferUpdater(e2) {
      this._material && this._material.addGBufferUpdater(e2);
    }
  }
  wt.PluginType = "GBuffer";
  class At extends ht {
    get transparentTarget() {
      return this._transparentTarget || (this._transparentTarget = this._viewer.renderer.getTempTarget({ sizeMultiplier: 1, samples: this._viewer.renderer.composerTarget.samples || 0, colorSpace: n.aCh, type: this._viewer.renderer.rendererObject.extensions.has("EXT_color_buffer_half_float") ? n.cLu : n.ywz, format: n.wk1, minFilter: n.wem, magFilter: n.wem, depthBuffer: false })), this._transparentTarget;
    }
    _releaseTransparentTarget() {
      this._transparentTarget && this._viewer.renderer.releaseTempTarget(this._transparentTarget), this._transparentTarget = void 0;
    }
    constructor(e2, t2 = true) {
      super(), this.blurTransmissionTarget = true, this.preserveTransparentTarget = false, this._viewer = e2, this._doTransmissionFix = t2, this.clear = true, this.clearColor = new n.Ilk(0, 0, 0), this.clearAlpha = 0, this.clearDepth = false, this._blendPass = new ft({}, "c = vec4(a.rgb * (1. - b.a) + b.rgb * b.a, 1.);");
    }
    render(e2, t2, n2, r2, i2) {
      var s2;
      let o2 = false;
      if (e2.userData.mainRenderPass = true, !this._doTransmissionFix)
        return super.render(e2, t2, n2, r2, i2), this.needsSwap = o2, void (e2.userData.mainRenderPass = void 0);
      const a2 = e2.userData;
      a2 || console.error("threejs is not patched?");
      const l2 = this._viewer.useGBufferDepth;
      let c2;
      if (l2) {
        const t3 = null === (s2 = this._viewer.getPlugin(wt)) || void 0 === s2 ? void 0 : s2.getTarget();
        if (t3) {
          const n3 = e2.properties.get(t3);
          c2 = n3.__webglDepthRenderbuffer || n3.__webglDepthbuffer;
        } else
          console.warn("No Gbuffer present for depth prepass.");
      }
      let u2 = (t3 = false) => {
        super.render(e2, void 0, n2, r2, i2, c2);
      };
      if (this._viewer.useRgbm) {
        if (this._viewer.useRgbm) {
          if (o2 = false, e2.info && !e2.info.autoReset)
            throw "renderer.info.autoReset must be true";
          {
            const t3 = e2.autoClearDepth;
            e2.autoClearDepth = !l2, H(e2, { shadowMapRender: true, backgroundRender: true, opaqueRender: true, transparentRender: false, transmissionRender: false }, u2), e2.autoClearDepth = t3;
          }
          if (!l2) {
            const t3 = e2.properties.get(n2);
            c2 = t3.__webglDepthRenderbuffer || t3.__webglDepthbuffer;
          }
          u2 = () => {
            super.render(e2, void 0, this.transparentTarget, r2, i2, c2);
          };
          {
            const t3 = this.clear, n3 = e2.autoClearDepth;
            e2.autoClearDepth = false, this.clear = true, H(e2, { shadowMapRender: false, backgroundRender: false, opaqueRender: false, transparentRender: true, transmissionRender: false }, u2), this.clear = t3, e2.autoClearDepth = n3;
          }
          (!e2.info || e2.info.render.calls > 0) && (this._blendPass.uniforms.tDiffuse2.value = this.transparentTarget.texture, this._blendPass.render(e2, t2, n2, r2, i2), o2 = true);
          {
            const r3 = this.clear;
            this.clear = false, a2.transmissionRenderTarget = o2 ? t2 : n2, a2.blurTransmissionTarget = this.blurTransmissionTarget && 0 === a2.transmissionRenderTarget.samples, H(e2, { shadowMapRender: false, backgroundRender: false, opaqueRender: false, transparentRender: false, transmissionRender: true }, u2), a2.blurTransmissionTarget = void 0, a2.transmissionRenderTarget = void 0, this.clear = r3;
          }
          (!e2.info || e2.info.render.calls > 0) && (this._blendPass.uniforms.tDiffuse2.value = this.transparentTarget.texture, this._blendPass.render(e2, t2, n2, r2, i2), o2 = true);
        }
      } else {
        {
          const t3 = this.clear, n3 = e2.autoClearDepth;
          e2.autoClearDepth = !l2, this.clear = true, H(e2, { shadowMapRender: true, backgroundRender: true, opaqueRender: true, transparentRender: true, transmissionRender: false }, u2), this.clear = t3, e2.autoClearDepth = n3;
        }
        {
          this._viewer.renderer.blit(n2.texture, t2, { clear: true });
          const r3 = this.clear;
          this.clear = false, a2.transmissionRenderTarget = t2, a2.blurTransmissionTarget = this.blurTransmissionTarget, H(e2, { shadowMapRender: false, backgroundRender: false, opaqueRender: false, transparentRender: false, transmissionRender: true }, u2), a2.blurTransmissionTarget = void 0, a2.transmissionRenderTarget = void 0, this.clear = r3;
        }
        o2 = false;
      }
      this.preserveTransparentTarget || this._releaseTransparentTarget(), this.needsSwap = o2, e2.userData.mainRenderPass = void 0;
    }
    dispose() {
      this._releaseTransparentTarget(), super.dispose();
    }
  }
  function xt(e2, t2) {
    return e2.multiplyScalar(e2.w * t2), e2.w = 1, e2;
  }
  function Et(e2, t2) {
    return xt(e2, t2), new n.Ilk(e2.x, e2.y, e2.z);
  }
  function Ct(e2, t2) {
    const n2 = Math.max(e2.x, Math.max(e2.y, e2.z));
    let r2 = Math.max(Math.min(n2 / t2, 1), 0);
    return r2 = Math.ceil(255 * r2) / 255, e2.divideScalar(r2 * t2), e2.w = r2, e2;
  }
  function St(e2, t2) {
    return Ct(new n.Ltg(e2.r, e2.g, e2.b, 1), t2);
  }
  const Mt = { name: "", blending: n.bdR, side: n.Wl3, vertexColors: false, opacity: 1, transparent: false, blendSrc: n.k74, blendDst: n.LgZ, blendEquation: n.bGH, blendSrcAlpha: null, blendDstAlpha: null, blendEquationAlpha: null, depthFunc: n.vCF, depthTest: true, depthWrite: true, stencilWriteMask: 255, stencilFunc: n.cum, stencilRef: 0, stencilFuncMask: 255, stencilFail: n.x5V, stencilZFail: n.x5V, stencilZPass: n.x5V, stencilWrite: false, clippingPlanes: null, clipIntersection: false, clipShadows: false, shadowSide: null, colorWrite: true, precision: null, polygonOffset: false, polygonOffsetFactor: 0, polygonOffsetUnits: 0, dithering: false, alphaToCoverage: false, premultipliedAlpha: false, forceSinglePass: false, visible: true, toneMapped: true, userData: {}, alphaTest: 0 }, Tt = { ...Mt, color: "#ffffff", roughness: 1, metalness: 0, map: null, lightMap: null, lightMapIntensity: 1, aoMap: null, aoMapIntensity: 1, emissive: "#000000", emissiveIntensity: 1, emissiveMap: null, bumpMap: null, bumpScale: 1, normalMap: null, normalMapType: n.IOt, normalScale: new n.FM8(1, 1), displacementMap: null, displacementScale: 1, displacementBias: 0, roughnessMap: null, metalnessMap: null, alphaMap: null, envMap: null, envMapIntensity: 1, wireframe: false, wireframeLinewidth: 1, wireframeLinecap: "round", wireframeLinejoin: "round", flatShading: false, fog: true }, Pt = { ...Tt, clearcoat: 0, clearcoatMap: null, clearcoatRoughness: 0, clearcoatRoughnessMap: null, clearcoatNormalScale: new n.FM8(1, 1), clearcoatNormalMap: null, reflectivity: 0.5, iridescence: 0, iridescenceMap: null, iridescenceIOR: 1.3, iridescenceThicknessRange: [100, 400], iridescenceThicknessMap: null, sheen: 0, sheenColor: new n.Ilk(0), sheenColorMap: null, sheenRoughness: 1, sheenRoughnessMap: null, transmission: 0, transmissionMap: null, thickness: 0, thicknessMap: null, attenuationDistance: 1 / 0, attenuationColor: new n.Ilk(1, 1, 1), specularIntensity: 1, specularIntensityMap: null, specularColor: new n.Ilk(1, 1, 1), specularColorMap: null };
  class It extends n.EJi {
    constructor(e2) {
      var t2;
      super(e2), this.typeSlug = It.TypeSlug, this.assetType = "material", this.materialObject = this, this.isMeshStandardMaterial2 = true, this.extraUniformsToUpload = {}, this.setDirty = this.setDirty.bind(this), this.userData.setDirty = (e3) => {
        console.warn("userData.setDirty is deprecated. Use setDirty instead."), this.setDirty(e3);
      }, this.fog = false, this.attenuationDistance = 0, this.materialExtensions = at.RegisterExtensions(this, null !== (t2 = null == e2 ? void 0 : e2.customMaterialExtensions) && void 0 !== t2 ? t2 : []);
    }
    setDirty(e2) {
      var t2, n2;
      this.needsUpdate = true, this.dispatchEvent({ ...e2, type: "materialUpdate" }), null === (n2 = null === (t2 = this._uiConfig) || void 0 === t2 ? void 0 : t2.uiRefresh) || void 0 === n2 || n2.call(t2, "postFrame", true, 1);
    }
    registerMaterialExtensions(e2) {
      this.materialExtensions = [...this.materialExtensions, ...at.RegisterExtensions(this, e2)];
    }
    unregisterMaterialExtensions(e2) {
    }
    get uiConfig() {
      return this._uiConfigChildren || (this._uiConfigChildren = [{ type: "input", property: [this, "name"] }, { type: "checkbox", property: [this, "wireframe"] }, { type: "checkbox", property: [this, "vertexColors"] }, { type: "color", property: [this, "color"], limitedUi: true }, { type: "image", property: [this, "map"] }, X(this, "map"), { type: "folder", label: "Rough/Metal", limitedUi: true, children: [{ type: "slider", bounds: [0, 1], property: [this, "roughness"], limitedUi: true }, { type: "slider", bounds: [0, 1], property: [this, "metalness"], limitedUi: true }, { type: "image", property: [this, "roughnessMap"] }, X(this, "roughnessMap"), { type: "image", property: [this, "metalnessMap"] }, X(this, "metalnessMap")] }, { type: "folder", label: "Bump/Normal", limitedUi: true, children: [{ type: "slider", bounds: [-0.1, 0.2], stepSize: 1e-3, property: [this, "bumpScale"], hidden: () => !this.bumpMap }, { type: "image", property: [this, "bumpMap"] }, X(this, "bumpMap"), { type: "image", property: [this, "normalMap"] }, { type: "vec2", property: [this, "normalScale"], hidden: () => !this.normalMap }, { type: "dropdown", hidden: () => !this.normalMap, property: [this, "normalMapType"], children: [["TangentSpace", n.IOt], ["ObjectSpace", n.PA7]].map((e2) => ({ label: e2[0], value: e2[1] })) }, X(this, "normalMap"), { type: "input", property: [this, "displacementScale"], hidden: () => !this.displacementMap }, { type: "image", property: [this, "displacementMap"] }, X(this, "displacementMap")] }, { type: "folder", label: "Sheen", children: [{ type: "slider", bounds: [0, 1], property: [this, "sheen"] }, { type: "color", hidden: () => this.sheen < 1e-3, property: [this, "sheenColor"] }, { type: "image", property: [this, "sheenColorMap"] }, X(this, "sheenColorMap"), { type: "slider", bounds: [0, 1], property: [this, "sheenRoughness"] }, { type: "image", property: [this, "sheenRoughnessMap"] }, X(this, "sheenRoughnessMap")] }, { type: "folder", label: "Clearcoat", children: [{ type: "slider", bounds: [0, 1], property: [this, "clearcoat"] }, { type: "slider", bounds: [0, 1], hidden: () => this.clearcoat < 1e-3, property: [this, "clearcoatRoughness"] }, { type: "image", property: [this, "clearcoatMap"] }, X(this, "clearcoatMap"), { type: "slider", bounds: [0, 1], property: [this, "clearcoatRoughness"] }, { type: "image", property: [this, "clearcoatRoughnessMap"] }, X(this, "clearcoatRoughnessMap"), { type: "image", property: [this, "clearcoatNormalMap"] }, { type: "vec2", property: [this, "clearcoatNormalScale"], hidden: () => !this.clearcoatNormalMap }, X(this, "clearcoatNormalMap")] }, { type: "folder", label: "Emission", children: [{ type: "color", property: [this, "emissive"] }, { type: "slider", bounds: [0, 10], property: [this, "emissiveIntensity"] }, { type: "image", property: [this, "emissiveMap"] }, X(this, "emissiveMap")] }, { type: "folder", label: "Refraction", children: [{ type: "slider", bounds: [0, 4], property: [this, "ior"] }, { type: "slider", bounds: [0, 1], property: [this, "transmission"], limitedUi: true }, { type: "slider", bounds: [0, 1], stepSize: 1e-3, property: [this, "thickness"] }, { type: "image", property: [this, "transmissionMap"] }, X(this, "transmissionMap"), { type: "image", property: [this, "thicknessMap"] }, X(this, "thicknessMap"), { type: "input", property: [this, "attenuationDistance"] }, { type: "color", property: [this, "attenuationColor"] }] }, { type: "folder", label: "Blending", children: [{ type: "slider", bounds: [0, 1], property: [this, "opacity"] }, { type: "checkbox", property: [this, "transparent"], onChange: this.setDirty }, { type: "dropdown", property: [this, "depthFunc"], children: [["Never", n.BVF], ["Always", n.Se2], ["Less", n.Zr5], ["LessEqual", n.vCF], ["Equal", n.eD], ["GreaterEqual", n.ksN], ["Greater", n.w$m], ["NotEqual", n.M6v]].map((e2) => ({ label: e2[0], value: e2[1] })) }, { type: "checkbox", property: [this, "depthTest"], onChange: this.setDirty }, { type: "checkbox", property: [this, "depthWrite"], onChange: this.setDirty }, { type: "checkbox", property: [this, "colorWrite"], onChange: this.setDirty }, { type: "slider", bounds: [0, 1], stepSize: 1e-3, property: [this, "alphaTest"] }, { type: "checkbox", property: [this, "dithering"] }, { type: "dropdown", label: "Blending", property: [this, "blending"], children: [["None", n.jFi], ["Normal", n.bdR], ["Additive", n.WMw], ["Subtractive", n.N4l], ["Multiply", n.M5h]].map((e2) => ({ label: e2[0], value: e2[1] })) }, { type: "image", property: [this, "alphaMap"] }, X(this, "alphaMap"), { type: "checkbox", label: "Render to Depth", getValue: () => true === this.userData.renderToDepth, setValue: (e2) => {
        this.userData.renderToDepth = e2 || void 0, this.setDirty();
      } }, { type: "checkbox", label: "Inverse AlphaMap", hidden: () => !this.transparent, getValue: () => true === this.userData.inverseAlphaMap, setValue: (e2) => {
        this.userData.inverseAlphaMap = e2 || void 0, this.setDirty();
      } }, { type: "checkbox", label: "Polygon Offset", property: [this, "polygonOffset"] }, { type: "slider", label: "Polygon Offset Factor", bounds: [-10, 10], property: [this, "polygonOffsetFactor"] }, { type: "slider", label: "Polygon Offset Units", bounds: [-10, 10], property: [this, "polygonOffsetUnits"] }] }, { type: "folder", label: "AO/Lightmap", children: [{ type: "slider", bounds: [0, 2], property: [this, "aoMapIntensity"] }, { type: "image", property: [this, "aoMap"] }, X(this, "aoMap"), { type: "slider", bounds: [0, 2], property: [this, "lightMapIntensity"] }, { type: "image", property: [this, "lightMap"] }, X(this, "lightMap")] }, { type: "folder", label: "Iridescence", children: [{ type: "slider", bounds: [0, 3], label: "Intensity", property: [this, "iridescence"] }, { type: "slider", bounds: [0, 3], label: "IOR", property: [this, "iridescenceIOR"] }, { type: "slider", bounds: [0, 500], label: "Thickness0", property: [this.iridescenceThicknessRange, "0"], onChange: this.setDirty }, { type: "slider", bounds: [0, 500], label: "Thickness1", property: [this.iridescenceThicknessRange, "1"], onChange: this.setDirty }, { type: "image", property: [this, "iridescenceMap"] }, X(this, "iridescenceMap"), { type: "image", property: [this, "iridescenceThicknessMap"] }, X(this, "iridescenceThicknessMap")] }, { type: "folder", label: "Environment", children: [{ type: "checkbox", label: "Override Environment", getValue: () => true === this.userData.separateEnvMapIntensity, setValue: (e2) => {
        this.userData.separateEnvMapIntensity = e2, e2 || delete this.userData.separateEnvMapIntensity;
      }, onChange: this.setDirty }, { type: "slider", bounds: [0, 10], hidden: () => !this.userData.separateEnvMapIntensity, label: "Environment Intensity", property: [this, "envMapIntensity"] }, { type: "dropdown", hidden: () => !this.userData.separateEnvMapIntensity && !this.userData.envMapSlotKey, label: "Environment Map", children: ["", "environment1", "environment2"].map((e2) => ({ label: e2 || "default", value: e2 })), getValue: () => this.userData.envMapSlotKey || "", setValue: (e2) => {
        this.userData.envMapSlotKey = e2, e2 || delete this.userData.envMapSlotKey, this.setDirty();
      } }] }, { type: "dropdown", label: "Side", property: [this, "side"], children: [["Front", n.Wl3], ["Back", n._Li], ["Double", n.ehD]].map((e2) => ({ label: e2[0], value: e2[1] })) }, { type: "checkbox", property: [this, "flatShading"] }, { type: "input", label: "Mesh count", getValue: () => {
        var e2, t2, n2;
        return null !== (n2 = null === (t2 = null === (e2 = this.userData) || void 0 === e2 ? void 0 : e2.__appliedMeshes) || void 0 === t2 ? void 0 : t2.size) && void 0 !== n2 ? n2 : 0;
      }, setValue: (e2) => {
      }, disabled: true }, { type: "button", label: `Download ${this.typeSlug}`, value: () => {
        const e2 = new Blob([JSON.stringify(le(this, false), null, 2)], { type: "application/json" });
        (0, t.downloadBlob)(e2, `physical-material.${this.typeSlug}`);
      } }]), this._uiConfig || (this._uiConfig = { type: "folder", label: "Physical Material", expanded: true, children: this._uiConfigChildren, uuid: "MSM2_" + this.uuid, limitedUi: true }), this._uiConfig.children = [...this._uiConfigChildren, ...this.materialExtensions.map((e2) => {
        var t2;
        return null === (t2 = e2.getUiConfig) || void 0 === t2 ? void 0 : t2.call(e2, this);
      })].filter((e2) => e2), this._uiConfig;
    }
    onBeforeCompile(e2, t2) {
      const n2 = [["vec3 totalDiffuse = ", "afterModulation"], ["#include <aomap_fragment>", "beforeModulation"], ["#include <lights_physical_fragment>", "beforeAccumulation"], ["#include <clipping_planes_fragment>", "mainStart"]], r2 = [["#include <uv_vertex>", "mainStart"]];
      for (const t3 of r2)
        e2.vertexShader = ot(e2.vertexShader, t3[0], "#glMarker " + t3[1] + "\n" + t3[0]);
      for (const t3 of n2)
        e2.fragmentShader = ot(e2.fragmentShader, t3[0], "#glMarker " + t3[1] + "\n" + t3[0]);
      at.ApplyMaterialExtensions(this, e2, this.materialExtensions, t2), e2.fragmentShader = e2.fragmentShader.replaceAll("#glMarker", "// "), e2.vertexShader = e2.vertexShader.replaceAll("#glMarker", "// "), e2.defines.INVERSE_ALPHAMAP = this.userData.inverseAlphaMap ? 1 : 0, super.onBeforeCompile(e2, t2);
    }
    customProgramCacheKey() {
      return super.customProgramCacheKey() + at.CacheKeyForExtensions(this, this.materialExtensions) + this.userData.inverseAlphaMap;
    }
    onBeforeRender(e2, t2, n2, r2, i2) {
      super.onBeforeRender(e2, t2, n2, r2, i2), void 0 === this.envMapIntensity || this.userData.separateEnvMapIntensity || void 0 === t2.envMapIntensity || (this.userData.__envIntensity = this.envMapIntensity, this.envMapIntensity = t2.envMapIntensity), void 0 !== this.envMap && void 0 !== t2.fixedEnvMapDirection && (t2.fixedEnvMapDirection ? this.defines.FIX_ENV_DIRECTION || (this.defines.FIX_ENV_DIRECTION = "1", this.needsUpdate = true) : void 0 !== this.defines.FIX_ENV_DIRECTION && (delete this.defines.FIX_ENV_DIRECTION, this.needsUpdate = true)), this.dispatchEvent({ type: "beforeRender", renderer: e2, scene: t2, camera: n2, geometry: r2, object: i2 });
      const s2 = this.userData.inverseAlphaMap ? 1 : 0;
      s2 !== this.defines.INVERSE_ALPHAMAP && (this.defines.INVERSE_ALPHAMAP = s2, this.needsUpdate = true);
    }
    onAfterRender(e2, t2, n2, r2, i2) {
      super.onAfterRender(e2, t2, n2, r2, i2), void 0 !== this.userData.__envIntensity && (this.envMapIntensity = this.userData.__envIntensity, delete this.userData.__envIntensity), this.dispatchEvent({ type: "afterRender", renderer: e2, scene: t2, camera: n2, geometry: r2, object: i2 });
    }
    copyProps(e2, n2 = false, r2 = true) {
      if (!n2 && !["MeshStandardMaterial", It.TYPE, "MeshPhysicalMaterial"].includes(e2.type))
        return console.error("Material type is not supported:", e2.type), this;
      const i2 = {}, s2 = Array.from(Object.keys(Pt));
      (0, t.copyProps)(e2, i2, s2);
      const o2 = i2.userData;
      delete i2.userData;
      for (const e3 of Object.keys(i2))
        void 0 === i2[e3] && delete i2[e3];
      if (this.setValues(i2), r2) {
        const e3 = {};
        for (const t2 of Y)
          void 0 !== this.userData[t2] && (e3[t2] = this.userData[t2]);
      }
      return o2 && K(this.userData, o2), isFinite(this.attenuationDistance) || (this.attenuationDistance = 0), this.setDirty(), this;
    }
    toJSON(e2) {
      var t2, n2;
      const r2 = this.userData;
      this.userData = {};
      const i2 = super.toJSON(e2);
      this.userData = r2, i2.userData = {}, K(i2.userData, r2), i2.userData.uuid = this.userData.uuid;
      const s2 = e2 || { textures: Object.fromEntries((null === (t2 = i2.textures) || void 0 === t2 ? void 0 : t2.map((e3) => [e3.uuid, e3])) || []), images: Object.fromEntries((null === (n2 = i2.images) || void 0 === n2 ? void 0 : n2.map((e3) => [e3.uuid, e3])) || []) };
      i2.userData = le(i2.userData, false, s2), e2 || (Object.keys(s2.textures).length > 0 && (i2.textures = Object.values(s2.textures)), Object.keys(s2.images).length > 0 && (i2.images = Object.values(s2.images))), i2.type = It.TYPE;
      for (const e3 of Object.keys(i2))
        void 0 === i2[e3] && delete i2[e3];
      return i2;
    }
    fromJSON(e2, t2, n2 = false) {
      return this.copyProps(e2, n2);
    }
    clone() {
      return super.clone();
    }
  }
  It.TypeSlug = "pmat", It.TYPE = "MeshStandardMaterial2";
  const Rt = { ...Mt, color: "#ffffff", map: null, lightMap: null, lightMapIntensity: 1, aoMap: null, aoMapIntensity: 1, specularMap: null, alphaMap: null, envMap: null, combine: n.Ns1, reflectivity: 1, refractionRatio: 0.98, wireframe: false, wireframeLinewidth: 1, wireframeLinecap: "round", wireframeLinejoin: "round", skinning: false, fog: true };
  class kt extends n.vBJ {
    constructor(e2) {
      var t2;
      super(e2), this.typeSlug = kt.TypeSlug, this.assetType = "material", this.materialObject = this, this.isMeshBasicMaterial2 = true, this.extraUniformsToUpload = {}, !this.defines && (this.defines = {}), this.fog = false, this.setDirty = this.setDirty.bind(this), this.userData.setDirty = (e3) => {
        console.warn("WebGi: userData.setDirty is deprecated. Use setDirty instead."), this.setDirty(e3);
      }, this.materialExtensions = at.RegisterExtensions(this, null !== (t2 = null == e2 ? void 0 : e2.customMaterialExtensions) && void 0 !== t2 ? t2 : []);
    }
    setDirty(e2) {
      var t2, n2;
      this.needsUpdate = true, this.dispatchEvent({ ...e2, type: "materialUpdate" }), null === (n2 = null === (t2 = this._uiConfig) || void 0 === t2 ? void 0 : t2.uiRefresh) || void 0 === n2 || n2.call(t2, "postFrame", true, 1);
    }
    registerMaterialExtensions(e2) {
      this.materialExtensions = [...this.materialExtensions, ...at.RegisterExtensions(this, e2)];
    }
    unregisterMaterialExtensions(e2) {
    }
    get uiConfig() {
      return this._uiConfigChildren || (this._uiConfigChildren = [{ type: "input", property: [this, "name"] }, { type: "checkbox", property: [this, "wireframe"] }, { type: "color", property: [this, "color"], limitedUi: true }, { type: "image", property: [this, "map"] }, X(this, "map"), { type: "folder", label: "Blending", children: [{ type: "slider", bounds: [0, 1], property: [this, "opacity"] }, { type: "checkbox", property: [this, "transparent"], onChange: this.setDirty }, { type: "checkbox", property: [this, "depthWrite"], onChange: this.setDirty }, { type: "checkbox", property: [this, "colorWrite"], onChange: this.setDirty }, { type: "slider", bounds: [0, 1], property: [this, "alphaTest"] }, { type: "checkbox", property: [this, "dithering"] }, { type: "dropdown", label: "Blending", property: [this, "blending"], children: [["None", n.jFi], ["Normal", n.bdR], ["Additive", n.WMw], ["Subtractive", n.N4l], ["Multiply", n.M5h]].map((e2) => ({ label: e2[0], value: e2[1] })) }, { type: "image", property: [this, "alphaMap"] }, X(this, "alphaMap"), { type: "checkbox", label: "Render to Depth", getValue: () => true === this.userData.renderToDepth, setValue: (e2) => {
        this.userData.renderToDepth = e2 || void 0, this.setDirty();
      } }] }, { type: "folder", label: "AO/Lightmap", children: [{ type: "slider", bounds: [0, 2], property: [this, "aoMapIntensity"] }, { type: "image", property: [this, "aoMap"] }, X(this, "aoMap"), { type: "slider", bounds: [0, 2], property: [this, "lightMapIntensity"] }, { type: "image", property: [this, "lightMap"] }, X(this, "lightMap")] }, { type: "dropdown", label: "Side", property: [this, "side"], children: [["Front", n.Wl3], ["Back", n._Li], ["Double", n.ehD]].map((e2) => ({ label: e2[0], value: e2[1] })) }, { type: "input", label: "Mesh count", getValue: () => {
        var e2, t2, n2;
        return null !== (n2 = null === (t2 = null === (e2 = this.userData) || void 0 === e2 ? void 0 : e2.__appliedMeshes) || void 0 === t2 ? void 0 : t2.size) && void 0 !== n2 ? n2 : 0;
      }, setValue: (e2) => {
      }, disabled: true }, { type: "button", label: `Download ${this.typeSlug}`, value: () => {
        const e2 = new Blob([JSON.stringify(le(this, false), null, 2)], { type: "application/json" });
        (0, t.downloadBlob)(e2, `unlit-material.${this.typeSlug}`);
      } }]), this._uiConfig || (this._uiConfig = { type: "folder", label: "Unlit Material", expanded: true, children: this._uiConfigChildren, uuid: "MBM2_" + this.uuid, limitedUi: true }), this._uiConfig.children = [...this._uiConfigChildren, ...this.materialExtensions.map((e2) => {
        var t2;
        return null === (t2 = e2.getUiConfig) || void 0 === t2 ? void 0 : t2.call(e2, this);
      })].filter((e2) => e2), this._uiConfig;
    }
    onBeforeCompile(e2, t2) {
      const n2 = [["vec3 outgoingLight = ", "afterModulation"], ["#include <aomap_fragment>", "beforeModulation"], ["ReflectedLight reflectedLight = ", "beforeAccumulation"], ["#include <clipping_planes_fragment>", "mainStart"]], r2 = [["#include <uv_vertex>", "mainStart"]];
      for (const t3 of r2)
        e2.vertexShader = ot(e2.vertexShader, t3[0], "#glMarker " + t3[1] + "\n" + t3[0]);
      for (const t3 of n2)
        e2.fragmentShader = ot(e2.fragmentShader, t3[0], "#glMarker " + t3[1] + "\n" + t3[0]);
      at.ApplyMaterialExtensions(this, e2, this.materialExtensions, t2), this.dispatchEvent({ type: "beforeCompile", shader: e2, renderer: t2 }), e2.fragmentShader = e2.fragmentShader.replaceAll("#glMarker", "// "), e2.vertexShader = e2.vertexShader.replaceAll("#glMarker", "// "), super.onBeforeCompile(e2, t2);
    }
    customProgramCacheKey() {
      return super.customProgramCacheKey() + at.CacheKeyForExtensions(this, this.materialExtensions) + this.userData.inverseAlphaMap;
    }
    onBeforeRender(e2, t2, n2, r2, i2) {
      super.onBeforeRender(e2, t2, n2, r2, i2), this.dispatchEvent({ type: "beforeRender", renderer: e2, scene: t2, camera: n2, geometry: r2, object: i2 });
    }
    onAfterRender(e2, t2, n2, r2, i2) {
      super.onAfterRender(e2, t2, n2, r2, i2), this.dispatchEvent({ type: "afterRender", renderer: e2, scene: t2, camera: n2, geometry: r2, object: i2 });
    }
    copyProps(e2, n2 = false) {
      if (!n2 && !["MeshBasicMaterial", kt.TYPE].includes(e2.type))
        return console.error("Material type is not supported:", e2.type), this;
      const r2 = {}, i2 = Array.from(Object.keys(Rt));
      (0, t.copyProps)(e2, r2, i2);
      const s2 = r2.userData;
      delete r2.userData;
      for (const e3 of Object.keys(r2))
        void 0 === r2[e3] && delete r2[e3];
      return this.setValues(r2), s2 && K(this.userData, s2), this.setDirty(), this;
    }
    toJSON(e2) {
      var t2, n2;
      const r2 = this.userData;
      this.userData = {};
      const i2 = super.toJSON(e2);
      this.userData = r2, i2.userData = {}, K(i2.userData, r2), i2.userData.uuid = this.userData.uuid;
      const s2 = e2 || { textures: Object.fromEntries((null === (t2 = i2.textures) || void 0 === t2 ? void 0 : t2.map((e3) => [e3.uuid, e3])) || []), images: Object.fromEntries((null === (n2 = i2.images) || void 0 === n2 ? void 0 : n2.map((e3) => [e3.uuid, e3])) || []) };
      i2.userData = le(i2.userData, false, s2), e2 || (Object.keys(s2.textures).length > 0 && (i2.textures = Object.values(s2.textures)), Object.keys(s2.images).length > 0 && (i2.images = Object.values(s2.images))), i2.type = kt.TYPE;
      for (const e3 of Object.keys(i2))
        void 0 === i2[e3] && delete i2[e3];
      return i2;
    }
    fromJSON(e2, t2, n2 = false) {
      return this.copyProps(e2, n2);
    }
    clone() {
      return super.clone();
    }
  }
  kt.TypeSlug = "bmat", kt.TYPE = "MeshBasicMaterial2";
  const Dt = { materialType: It.TYPE, name: "standard", color: "#ffffff" }, Bt = { materialType: kt.TYPE, name: "basic", color: "#ffffff" }, Ot = { [It.TYPE]: Dt.name, MeshStandardMaterial: Dt.name, MeshPhysicalMaterial: Dt.name, [kt.TYPE]: Bt.name, MeshBasicMaterial: Bt.name };
  class Lt extends t.SimpleEventDispatcher {
    constructor() {
      super(), this._templates = [Dt, Bt], this._materials = [], this._disposeMaterial = (e2) => {
        const t2 = e2.target;
        if (!t2 || "material" !== t2.assetType)
          return;
        this._refreshTextureRefs();
        const n2 = this._getMapsForMaterial(t2), r2 = [];
        n2.forEach((e3) => {
          const n3 = e3.userData.__appliedMaterials;
          null == n3 || n3.delete(t2), n3 && false !== e3.userData.disposeOnIdle && 0 === n3.size && r2.push(e3);
        }), r2.forEach((e3) => {
          e3.dispose();
        });
      }, this._materialExtensions = [], this.processModel = this.processModel.bind(this), this.processMaterial = this.processMaterial.bind(this);
    }
    findOrCreate(e2, t2) {
      let n2 = this.findMaterial(e2);
      return n2 || (n2 = this.generateFromTemplate(e2, t2)), n2;
    }
    generateFromTemplate(e2, t2) {
      const n2 = this.findTemplate(e2);
      if (n2)
        return this._generateFromTemplate(n2, null != t2 ? t2 : {});
    }
    generateFromTemplateType(e2, t2) {
      const n2 = this._templates.find((t3) => t3.materialType === e2);
      if (n2)
        return this._generateFromTemplate(n2, null != t2 ? t2 : {});
    }
    findTemplate(e2) {
      return this._templates.find((t2) => t2.name === e2);
    }
    _refreshTextureRefs(e2) {
      (e2 || this.getAllMaterials()).forEach((e3) => {
        this._getMapsForMaterial(e3).forEach((t2) => {
          let n2 = t2.userData.__appliedMaterials;
          n2 || (t2.userData.__appliedMaterials = n2 = /* @__PURE__ */ new Set()), t2.addEventListener("update", () => e3.dispatchEvent({ type: "textureUpdate", texture: t2 })), n2.add(e3);
        });
      });
    }
    _getMapsForMaterial(e2) {
      var t2;
      const n2 = /* @__PURE__ */ new Set();
      for (const t3 of Object.values(e2))
        t3 && t3.isTexture && n2.add(t3);
      for (const r2 of Object.values(null !== (t2 = e2.userData) && void 0 !== t2 ? t2 : {}))
        r2 && r2.isTexture && n2.add(r2);
      return n2;
    }
    registerMaterial(e2) {
      if (this._materials.includes(e2))
        return;
      const t2 = this.findMaterial(e2.uuid);
      t2 ? console.warn("WebGi MaterialManager: Material UUID already exists", e2, t2) : (e2.addEventListener("dispose", this._disposeMaterial), this._materials.push(e2), this._refreshTextureRefs([e2]));
    }
    registerMaterialObject(e2) {
      const t2 = e2.materialObject ? e2 : Object.assign(e2, { assetType: "material", materialObject: e2 });
      return this.registerMaterial(t2), t2;
    }
    unregisterMaterial(e2) {
      this._materials = this._materials.filter((t2) => t2.uuid !== e2.uuid), e2.removeEventListener("dispose", this._disposeMaterial);
    }
    registerMaterialTemplate(e2) {
      e2.templateUUID || (e2.templateUUID = ke());
      const t2 = this._templates.find((t3) => t3.templateUUID === e2.templateUUID);
      t2 ? console.warn("WebGi Material Manager: MaterialTemplate already exists", e2, t2) : this._templates.push(e2);
    }
    unregisterMaterialTemplate(e2) {
      this._templates = this._templates.filter((t2) => t2.templateUUID !== e2.templateUUID);
    }
    dispose(e2 = true) {
      const t2 = this._materials;
      this._materials = [];
      for (const n2 of t2)
        e2 || !n2.userData.runtimeMaterial ? n2.dispose() : this._materials.push(n2);
    }
    findMaterial(e2) {
      return e2 ? this._materials.find((t2) => t2.uuid === e2) : void 0;
    }
    findMaterialsByName(e2, t2 = false) {
      return this._materials.filter((n2) => "string" != typeof e2 || t2 ? null !== n2.name.match("string" == typeof e2 ? "^" + e2 + "$" : e2) : n2.name === e2);
    }
    getMaterialsOfType(e2) {
      return e2 ? this._materials.filter((t2) => t2.typeSlug === e2) : [];
    }
    getAllMaterials() {
      return [...this._materials];
    }
    processModel(e2, n2) {
      const r2 = this._processModel(e2, n2);
      return (0, t.safeSetProperty)(e2, "modelObject", r2), e2;
    }
    _processMaterial(e2, t2) {
      var n2, r2;
      if (!e2)
        return;
      if (null === (n2 = e2.materialObject) || void 0 === n2 ? void 0 : n2.isMaterial)
        return e2;
      let i2 = e2.mmMaterial;
      if (!i2) {
        const n3 = (null === (r2 = e2.userData) || void 0 === r2 ? void 0 : r2.uuid) || e2.uuid;
        if (i2 = this.findMaterial(n3), i2)
          i2.copyProps(e2);
        else {
          const n4 = false === t2.useSourceMaterial || !e2.isMaterial, r3 = t2.materialTemplate || (n4 ? "standard" : Ot[e2.type] || "standard");
          i2 = this.generateFromTemplate(r3, n4 ? {} : e2);
        }
        e2.mmMaterial = i2;
      }
      return i2;
    }
    processMaterial(e2, t2) {
      return e2.materialObject || (e2 = this._processMaterial(e2, { ...t2, register: false })), false !== t2.register && this.registerMaterial(e2), e2;
    }
    registerMaterialExtension(e2) {
      this._materialExtensions.includes(e2) || this._materialExtensions.push(e2);
    }
    unregisterMaterialExtension(e2) {
      const t2 = this._materialExtensions.indexOf(e2);
      t2 >= 0 && this._materialExtensions.splice(t2, 1);
    }
    exportMaterial(e2, n2, r2 = true, i2 = false) {
      const s2 = le(e2, false), o2 = JSON.stringify(s2, null, r2 ? 0 : 2), a2 = (n2 || e2.name || "physical_material") + "." + e2.typeSlug, l2 = new File([o2], a2, { type: "application/json" });
      return i2 && (0, t.downloadFile)(l2), l2;
    }
    applyMaterial(e2, t2, n2 = true) {
      var r2;
      const i2 = Object.getPrototypeOf(e2).constructor.TYPE;
      let s2 = this.findMaterialsByName(t2, n2);
      (!s2 || s2.length < 1) && (s2 = [this.findMaterial(t2)]);
      let o2 = false;
      for (const t3 of s2)
        if (t3 && !t3.userData.__isVariation && t3 !== e2)
          if (Object.getPrototypeOf(t3).constructor.TYPE === i2) {
            const n3 = t3.name;
            t3.copyProps(e2), t3.name = n3, o2 = true;
          } else {
            const n3 = t3["__" + i2] || this.generateFromTemplateType(i2);
            if (!n3)
              continue;
            const s3 = t3.name;
            n3.copyProps(e2), n3.name = s3;
            const a2 = t3.userData.__appliedMeshes;
            for (const e3 of [...null != a2 ? a2 : []])
              null === (r2 = null == e3 ? void 0 : e3.setMaterial) || void 0 === r2 || r2.call(e3, n3), e3 && (o2 = true);
            t3["__" + i2] = n3;
          }
      return o2;
    }
  }
  class Ut extends Lt {
    _generateFromTemplate(e2, r2) {
      var i2, s2, o2, a2, l2, c2;
      let u2;
      const p2 = { ...e2 };
      p2.customMaterialExtensions = [...null !== (i2 = p2.customMaterialExtensions) && void 0 !== i2 ? i2 : [], ...this._materialExtensions];
      const d2 = (null == r2 ? void 0 : r2.metadata) && (null == r2 ? void 0 : r2.metadata.version) <= 4.5;
      d2 && (n.epp.enabled = false);
      let h2 = {};
      switch (e2.materialType) {
        case "MeshStandardMaterial2":
        case "standard":
          r2 && (0, t.copyProps)(r2, p2, Array.from(Object.keys(Pt))), "MeshBasicMaterial" === (null == r2 ? void 0 : r2.type) && (p2.roughness = 0.9, p2.metalness = 0, (null === (s2 = p2.userData) || void 0 === s2 ? void 0 : s2.uuid) && delete p2.userData.uuid), h2 = null === (o2 = p2.userData) || void 0 === o2 ? void 0 : o2.uuid, h2 && delete p2.userData.uuid, u2 = new It({ customMaterialExtensions: p2.customMaterialExtensions }).fromJSON(p2, void 0, true), h2 && (u2.uuid = h2), u2.userData.uuid = u2.uuid, u2.setDirty(), (null == r2 ? void 0 : r2.isMaterial) && void 0 !== r2.userData && (r2.userData.iMaterial = u2);
          break;
        case "MeshBasicMaterial2":
        case "basic":
        case "unlit":
          r2 && (0, t.copyProps)(r2, p2, Array.from(Object.keys(Rt))), h2 = null === (a2 = p2.userData) || void 0 === a2 ? void 0 : a2.uuid, h2 && delete p2.userData.uuid, u2 = new kt({ customMaterialExtensions: p2.customMaterialExtensions }).fromJSON(p2, void 0, true), h2 && (u2.uuid = h2, p2.userData.uuid = h2), u2.userData.uuid = u2.uuid, u2.setDirty();
          break;
        case "shadow":
          throw "TODO: Not implemented shadow material";
        default:
          h2 = null, r2 && r2.userData && (h2 = r2.userData, delete r2.userData), u2 = (null === (l2 = e2.generator) || void 0 === l2 ? void 0 : l2.call(e2, p2, r2)) || void 0, r2 && h2 && (r2.userData = h2), h2 && u2 && (K(u2.userData, h2), (null == h2 ? void 0 : h2.uuid) && (u2.uuid = h2.uuid), h2 = null), u2 && (u2.userData.uuid = u2.uuid);
      }
      if (u2) {
        r2.runtimeMaterial && (u2.userData.runtimeMaterial = true);
        const t2 = u2;
        if (u2.clone = () => {
          t2.userData.cloneId || (t2.userData.cloneId = "0"), t2.userData.cloneCount || (t2.userData.cloneCount = 0), t2.userData.cloneCount += 1;
          const n2 = this.generateFromTemplate(e2.name);
          return n2 && (n2.copyProps(t2), n2.userData.cloneId = n2.userData.cloneId + "_" + t2.userData.cloneCount, n2.userData.cloneCount = 0, n2.name = n2.name + "_" + n2.userData.cloneId, n2.userData.uuid = n2.uuid), null == n2 ? void 0 : n2.materialObject;
        }, r2) {
          let e3 = this.findMaterial(null == r2 ? void 0 : r2.uuid);
          e3 && this.unregisterMaterial(e3), e3 = this.findMaterial(null === (c2 = null == r2 ? void 0 : r2.materialObject) || void 0 === c2 ? void 0 : c2.uuid), e3 && this.unregisterMaterial(e3);
        }
      }
      return d2 && (n.epp.enabled = true), u2 ? this.registerMaterialObject(u2) : void 0;
    }
    _processModel(e2, t2) {
      if (!e2.modelObject)
        return console.error("MaterialManager: No modelObject found for ", e2), e2;
      let n2 = e2.material;
      if (!n2 && e2.geometry && (this._defaultMaterial || (this._defaultMaterial = this.generateFromTemplate("standard")), n2 = this._defaultMaterial, e2.material = n2), n2) {
        let r2 = true;
        Array.isArray(n2) || (n2 = [n2], r2 = false);
        const i2 = [];
        for (const e3 of n2) {
          const n3 = this._processMaterial(e3, t2);
          i2.push(null == n3 ? void 0 : n3.materialObject);
        }
        e2.setMaterial && (e2.modelObject.material = null, e2.setMaterial(r2 ? i2 : i2[0]));
      }
      if (false !== t2.recursive)
        for (let n3 = 0; n3 < e2.modelObject.children.length; n3++)
          e2.modelObject.children[n3] = this._processModel(e2.modelObject.children[n3], t2);
      return e2;
    }
  }
  class Ft {
    ctor(e2) {
      const t2 = this.cls && new this.cls(e2.loadingManager);
      return "function" == typeof this.onCtor ? this.onCtor(t2, e2) : t2;
    }
    constructor(e2, t2, n2, r2) {
      this.cls = e2, this.ext = t2, this.root = n2, this.onCtor = r2;
    }
  }
  class Nt {
    get visible() {
      return this._modelObject.visible;
    }
    set visible(e2) {
      this._modelObject.visible = e2;
    }
    get uuid() {
      return this._modelObject.uuid;
    }
    get modelObject() {
      return this._modelObject;
    }
    get name() {
      return this._modelObject.name;
    }
    set name(e2) {
      this._modelObject.name = e2;
    }
    constructor(e2, { pseudoCenter: t2 = false, autoCenter: r2 = false, autoScale: i2 = false, autoScaleRadius: s2 = 2, license: o2 = "" } = {}) {
      if (this.assetType = "model", this._modelObject = ye(new n.Tme()), this.setDirty = this.setDirty.bind(this), this.updateBounds = this.updateBounds.bind(this), e2 || (e2 = this._modelObject), !t2 || e2.userData.pseudoCentered || e2.userData.isCentered)
        !r2 || e2.userData.autoCentered || e2.userData.isCentered || e2.userData.pseudoCentered ? t2 || r2 || (e2.userData.isCentered = true) : Q(e2), this._modelObject = e2;
      else {
        r2 && console.error("cannot use pseudoCenter and autoCenter at the same time");
        const t3 = new h().expandByObject(e2, true, true).getCenter(new n.Pa4());
        this._modelObject.position.copy(t3).negate(), this._modelObject.updateMatrix(), this._modelObject.add(e2), this._modelObject.name = e2.name + "-centered", this._modelObject.userData.pseudoCentered = true, this._modelObject.userData.isCentered = true, e2.userData.iModel = this;
      }
      i2 && !this._modelObject.userData.autoScaled ? W(this._modelObject, e2.userData.autoScaleRadius || s2) : this._modelObject.userData.autoScaled = true, this._modelObject.addEventListener("dispose", () => {
        this.__disposed = true;
      }), this._modelObject.userData.iModel = this, this.license = o2;
    }
    get license() {
      return this._modelObject.userData.license;
    }
    set license(e2) {
      this._modelObject.userData.license = e2;
    }
    addEventListener(e2, t2) {
      this._modelObject.addEventListener(e2, t2);
    }
    dispatchEvent(e2) {
      this._modelObject.dispatchEvent(e2);
    }
    hasEventListener(e2, t2) {
      return this._modelObject.hasEventListener(e2, t2);
    }
    removeEventListener(e2, t2) {
      this._modelObject.removeEventListener(e2, t2);
    }
    traverse(e2) {
      this._modelObject.traverse(e2);
    }
    dispose() {
      const e2 = this._modelObject.dispose;
      e2 && "function" == typeof e2 ? e2() : (console.warn("WebGi Object3DModel: no dispose in modelObject"), this._modelObject.removeFromParent());
    }
    setDirty(e2) {
      var t2, n2, r2, i2;
      null === (n2 = null === (t2 = this._modelObject) || void 0 === t2 ? void 0 : t2.setDirty) || void 0 === n2 || n2.call(t2, e2), null === (i2 = null === (r2 = this._uiConfig) || void 0 === r2 ? void 0 : r2.uiRefresh) || void 0 === i2 || i2.call(r2, "postFrame", true);
    }
    setMaterial(e2) {
      var t2, n2;
      return this._modelObject.isMesh ? (null === (n2 = (t2 = this._modelObject).setMaterial) || void 0 === n2 ? void 0 : n2.call(t2, e2)) || [] : (console.error("setMaterial only works on meshes"), []);
    }
    get material() {
      return this._modelObject.material;
    }
    get geometry() {
      return this._modelObject.geometry;
    }
    setGeometry(e2, t2 = false) {
      var n2, r2;
      if (this._modelObject.isMesh)
        return null === (r2 = (n2 = this._modelObject).setGeometry) || void 0 === r2 ? void 0 : r2.call(n2, e2, t2);
      console.error("setGeometry only works on meshes");
    }
    get userData() {
      return this._modelObject.userData;
    }
    set userData(e2) {
      this._modelObject.userData = e2;
    }
    updateBounds() {
      console.warn("WebGi Object3DModel: updateBounds: NOT IMPLEMENTED, don't use"), this.setDirty();
    }
    get uiConfig() {
      return this._uiConfig || (this._uiConfig = ve(this._modelObject, false)), this._uiConfig;
    }
    clone() {
      return new Nt(this._modelObject.clone(), { pseudoCenter: false, autoScale: false, autoCenter: false, license: this.license });
    }
  }
  function jt(e2, t2) {
    return [e2.modelObject, ...e2.modelObject.children].forEach((n2) => {
      ye(n2, n2 !== e2.modelObject ? e2 : void 0, t2);
    }), e2;
  }
  class zt {
    constructor() {
      this._processors = /* @__PURE__ */ new Map();
    }
    add(e2, t2) {
      var n2;
      this._processors.has(e2) || this._processors.set(e2, []), null === (n2 = this._processors.get(e2)) || void 0 === n2 || n2.push(t2);
    }
    remove(e2, t2) {
      const n2 = this._processors.get(e2), r2 = (null == n2 ? void 0 : n2.indexOf(t2)) || (null == n2 ? void 0 : n2.findIndex((e3) => e3.process && e3.process === t2.process || e3.processAsync && e3.processAsync === t2.processAsync));
      !n2 || !r2 || r2 < 0 || n2.splice(r2, 1);
    }
    get(e2) {
      var t2;
      return null !== (t2 = this._processors.get(e2)) && void 0 !== t2 ? t2 : [];
    }
    async process(e2, t2, n2) {
      var r2, i2, s2, o2;
      const a2 = this.get(e2), l2 = t2.assetType;
      for (const e3 of a2)
        e3.forAssetType === l2 && (t2 = null !== (i2 = null === (r2 = e3.process) || void 0 === r2 ? void 0 : r2.call(e3, t2, n2)) && void 0 !== i2 ? i2 : t2, t2 = null !== (o2 = await (null === (s2 = e3.processAsync) || void 0 === s2 ? void 0 : s2.call(e3, t2, n2))) && void 0 !== o2 ? o2 : t2);
      return t2;
    }
    dispose() {
      this._processors.clear();
    }
  }
  class Gt extends n.hH6 {
    load(e2, t2, n2, r2) {
      return super.load(e2, (e3) => {
        try {
          if ("string" != typeof e3)
            throw new Error("Invalid JSON");
          null == t2 || t2(JSON.parse(e3));
        } catch (e4) {
          null == r2 || r2(e4);
        }
      }, n2, r2);
    }
  }
  class Vt extends n.yxD {
    constructor(e2) {
      super(e2), this.type = n.cLu;
    }
    parse(e2) {
      const t2 = function(e3, t3) {
        switch (e3) {
          case 1:
            console.error("THREE.RGBELoader Read Error: " + (t3 || ""));
            break;
          case 2:
            console.error("THREE.RGBELoader Write Error: " + (t3 || ""));
            break;
          case 3:
            console.error("THREE.RGBELoader Bad File Format: " + (t3 || ""));
            break;
          default:
            console.error("THREE.RGBELoader: Error: " + (t3 || ""));
        }
        return -1;
      }, r2 = function(e3, t3, n2) {
        t3 = t3 || 1024;
        let r3 = e3.pos, i3 = -1, s3 = 0, o3 = "", a3 = String.fromCharCode.apply(null, new Uint16Array(e3.subarray(r3, r3 + 128)));
        for (; 0 > (i3 = a3.indexOf("\n")) && s3 < t3 && r3 < e3.byteLength; )
          o3 += a3, s3 += a3.length, r3 += 128, a3 += String.fromCharCode.apply(null, new Uint16Array(e3.subarray(r3, r3 + 128)));
        return -1 < i3 && (false !== n2 && (e3.pos += s3 + i3 + 1), o3 + a3.slice(0, i3));
      }, i2 = function(e3, t3, n2, r3) {
        const i3 = e3[t3 + 3], s3 = Math.pow(2, i3 - 128) / 255;
        n2[r3 + 0] = e3[t3 + 0] * s3, n2[r3 + 1] = e3[t3 + 1] * s3, n2[r3 + 2] = e3[t3 + 2] * s3, n2[r3 + 3] = 1;
      }, s2 = function(e3, t3, r3, i3) {
        const s3 = e3[t3 + 3], o3 = Math.pow(2, s3 - 128) / 255;
        r3[i3 + 0] = n.A5E.toHalfFloat(Math.min(e3[t3 + 0] * o3, 65504)), r3[i3 + 1] = n.A5E.toHalfFloat(Math.min(e3[t3 + 1] * o3, 65504)), r3[i3 + 2] = n.A5E.toHalfFloat(Math.min(e3[t3 + 2] * o3, 65504)), r3[i3 + 3] = n.A5E.toHalfFloat(1);
      }, o2 = new Uint8Array(e2);
      o2.pos = 0;
      const a2 = function(e3) {
        const n2 = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, i3 = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, s3 = /^\s*FORMAT=(\S+)\s*$/, o3 = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, a3 = { valid: 0, string: "", comments: "", programtype: "RGBE", format: "", gamma: 1, exposure: 1, width: 0, height: 0 };
        let l2, c2;
        if (e3.pos >= e3.byteLength || !(l2 = r2(e3)))
          return t2(1, "no header found");
        if (!(c2 = l2.match(/^#\?(\S+)/)))
          return t2(3, "bad initial token");
        for (a3.valid |= 1, a3.programtype = c2[1], a3.string += l2 + "\n"; l2 = r2(e3), false !== l2; )
          if (a3.string += l2 + "\n", "#" !== l2.charAt(0)) {
            if ((c2 = l2.match(n2)) && (a3.gamma = parseFloat(c2[1])), (c2 = l2.match(i3)) && (a3.exposure = parseFloat(c2[1])), (c2 = l2.match(s3)) && (a3.valid |= 2, a3.format = c2[1]), (c2 = l2.match(o3)) && (a3.valid |= 4, a3.height = parseInt(c2[1], 10), a3.width = parseInt(c2[2], 10)), 2 & a3.valid && 4 & a3.valid)
              break;
          } else
            a3.comments += l2 + "\n";
        return 2 & a3.valid ? 4 & a3.valid ? a3 : t2(3, "missing image size specifier") : t2(3, "missing format specifier");
      }(o2);
      if (-1 !== a2) {
        const e3 = a2.width, r3 = a2.height, l2 = function(e4, n2, r4) {
          const i3 = n2;
          if (i3 < 8 || i3 > 32767 || 2 !== e4[0] || 2 !== e4[1] || 128 & e4[2])
            return new Uint8Array(e4);
          if (i3 !== (e4[2] << 8 | e4[3]))
            return t2(3, "wrong scanline width");
          const s3 = new Uint8Array(4 * n2 * r4);
          if (!s3.length)
            return t2(4, "unable to allocate buffer space");
          let o3 = 0, a3 = 0;
          const l3 = 4 * i3, c2 = new Uint8Array(4), u2 = new Uint8Array(l3);
          let p2 = r4;
          for (; p2 > 0 && a3 < e4.byteLength; ) {
            if (a3 + 4 > e4.byteLength)
              return t2(1);
            if (c2[0] = e4[a3++], c2[1] = e4[a3++], c2[2] = e4[a3++], c2[3] = e4[a3++], 2 != c2[0] || 2 != c2[1] || (c2[2] << 8 | c2[3]) != i3)
              return t2(3, "bad rgbe scanline format");
            let n3, r5 = 0;
            for (; r5 < l3 && a3 < e4.byteLength; ) {
              n3 = e4[a3++];
              const i4 = n3 > 128;
              if (i4 && (n3 -= 128), 0 === n3 || r5 + n3 > l3)
                return t2(3, "bad scanline data");
              if (i4) {
                const t3 = e4[a3++];
                for (let e5 = 0; e5 < n3; e5++)
                  u2[r5++] = t3;
              } else
                u2.set(e4.subarray(a3, a3 + n3), r5), r5 += n3, a3 += n3;
            }
            const d2 = i3;
            for (let e5 = 0; e5 < d2; e5++) {
              let t3 = 0;
              s3[o3] = u2[e5 + t3], t3 += i3, s3[o3 + 1] = u2[e5 + t3], t3 += i3, s3[o3 + 2] = u2[e5 + t3], t3 += i3, s3[o3 + 3] = u2[e5 + t3], o3 += 4;
            }
            p2--;
          }
          return s3;
        }(o2.subarray(o2.pos), e3, r3);
        if (-1 !== l2) {
          let t3, o3, c2;
          switch (this.type) {
            case n.VzW:
              c2 = l2.length / 4;
              const e4 = new Float32Array(4 * c2);
              for (let t4 = 0; t4 < c2; t4++)
                i2(l2, 4 * t4, e4, 4 * t4);
              t3 = e4, o3 = n.VzW;
              break;
            case n.cLu:
              c2 = l2.length / 4;
              const r4 = new Uint16Array(4 * c2);
              for (let e5 = 0; e5 < c2; e5++)
                s2(l2, 4 * e5, r4, 4 * e5);
              t3 = r4, o3 = n.cLu;
              break;
            default:
              console.error("THREE.RGBELoader: unsupported type: ", this.type);
          }
          return { width: e3, height: r3, data: t3, header: a2.string, gamma: a2.gamma, exposure: a2.exposure, type: o3 };
        }
      }
      return null;
    }
    setDataType(e2) {
      return this.type = e2, this;
    }
    load(e2, t2, r2, i2) {
      return super.load(e2, function(e3, r3) {
        switch (e3.type) {
          case n.VzW:
          case n.cLu:
            e3.colorSpace = n.GUF, e3.minFilter = n.wem, e3.magFilter = n.wem, e3.generateMipmaps = false, e3.flipY = true;
        }
        t2 && t2(e3, r3);
      }, r2, i2);
    }
  }
  function Ht(e2) {
    return new Ft(class extends Vt {
      constructor(t2) {
        super(t2), this.setDataType(Ds(e2.renderer.rendererObject));
      }
    }, ["hdr"], false);
  }
  class Qt extends n.aNw {
    constructor(e2) {
      super(e2), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(e3) {
        return new Jt(e3);
      }), this.register(function(e3) {
        return new on(e3);
      }), this.register(function(e3) {
        return new an(e3);
      }), this.register(function(e3) {
        return new ln(e3);
      }), this.register(function(e3) {
        return new $t(e3);
      }), this.register(function(e3) {
        return new en(e3);
      }), this.register(function(e3) {
        return new tn(e3);
      }), this.register(function(e3) {
        return new nn(e3);
      }), this.register(function(e3) {
        return new Kt(e3);
      }), this.register(function(e3) {
        return new rn(e3);
      }), this.register(function(e3) {
        return new Zt(e3);
      }), this.register(function(e3) {
        return new sn(e3);
      }), this.register(function(e3) {
        return new Xt(e3);
      }), this.register(function(e3) {
        return new cn(e3);
      }), this.register(function(e3) {
        return new un(e3);
      });
    }
    load(e2, t2, r2, i2) {
      const s2 = this;
      let o2;
      o2 = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : n.Zp0.extractUrlBase(e2), this.manager.itemStart(e2);
      const a2 = function(t3) {
        i2 ? i2(t3) : console.error(t3), s2.manager.itemError(e2), s2.manager.itemEnd(e2);
      }, l2 = new n.hH6(this.manager);
      l2.setPath(this.path), l2.setResponseType("arraybuffer"), l2.setRequestHeader(this.requestHeader), l2.setWithCredentials(this.withCredentials), l2.load(e2, function(n2) {
        try {
          s2.parse(n2, o2, function(n3) {
            t2(n3), s2.manager.itemEnd(e2);
          }, a2, e2);
        } catch (e3) {
          a2(e3);
        }
      }, r2, a2);
    }
    setDRACOLoader(e2) {
      return this.dracoLoader = e2, this;
    }
    setDDSLoader() {
      throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
    }
    setKTX2Loader(e2) {
      return this.ktx2Loader = e2, this;
    }
    setMeshoptDecoder(e2) {
      return this.meshoptDecoder = e2, this;
    }
    register(e2) {
      return -1 === this.pluginCallbacks.indexOf(e2) && this.pluginCallbacks.push(e2), this;
    }
    unregister(e2) {
      return -1 !== this.pluginCallbacks.indexOf(e2) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e2), 1), this;
    }
    parse(e2, t2, n2, r2, i2) {
      let s2;
      const o2 = {}, a2 = {}, l2 = new TextDecoder();
      if ("string" == typeof e2)
        s2 = JSON.parse(e2);
      else if (e2 instanceof ArrayBuffer)
        if (l2.decode(new Uint8Array(e2, 0, 4)) === pn) {
          try {
            o2[qt.KHR_BINARY_GLTF] = new dn(e2);
          } catch (e3) {
            return void (r2 && r2(e3));
          }
          s2 = JSON.parse(o2[qt.KHR_BINARY_GLTF].content);
        } else
          s2 = JSON.parse(l2.decode(e2));
      else
        s2 = e2;
      if (void 0 === s2.asset || s2.asset.version[0] < 2)
        return void (r2 && r2(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
      const c2 = new Bn(s2, { path: t2 || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder });
      c2.fileLoader.setRequestHeader(this.requestHeader);
      for (let e3 = 0; e3 < this.pluginCallbacks.length; e3++) {
        const t3 = this.pluginCallbacks[e3](c2);
        a2[t3.name] = t3, o2[t3.name] = true;
      }
      if (s2.extensionsUsed)
        for (let e3 = 0; e3 < s2.extensionsUsed.length; ++e3) {
          const t3 = s2.extensionsUsed[e3], n3 = s2.extensionsRequired || [];
          switch (t3) {
            case qt.KHR_MATERIALS_UNLIT:
              o2[t3] = new Yt();
              break;
            case qt.KHR_DRACO_MESH_COMPRESSION:
              o2[t3] = new hn(s2, this.dracoLoader);
              break;
            case qt.KHR_TEXTURE_TRANSFORM:
              o2[t3] = new fn();
              break;
            case qt.KHR_MESH_QUANTIZATION:
              o2[t3] = new mn();
              break;
            default:
              n3.indexOf(t3) >= 0 && void 0 === a2[t3] && console.warn('THREE.GLTFLoader: Unknown extension "' + t3 + '".');
          }
        }
      c2.setExtensions(o2), c2.setPlugins(a2), c2.parse(n2, r2);
    }
    parseAsync(e2, t2) {
      const n2 = this;
      return new Promise(function(r2, i2) {
        n2.parse(e2, t2, r2, i2);
      });
    }
  }
  function Wt() {
    let e2 = {};
    return { get: function(t2) {
      return e2[t2];
    }, add: function(t2, n2) {
      e2[t2] = n2;
    }, remove: function(t2) {
      delete e2[t2];
    }, removeAll: function() {
      e2 = {};
    } };
  }
  Qt.ObjectConstructors = { DirectionalLight: n.Ox3, PointLight: n.cek, SpotLight: n.PMe, MeshStandardMaterial: n.Wid, MeshBasicMaterial: n.vBJ, MeshPhysicalMaterial: n.EJi, LineBasicMaterial: n.nls, PointsMaterial: n.UY4, PerspectiveCamera: n.cPb, OrthographicCamera: n.iKG };
  const qt = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_IOR: "KHR_materials_ior", KHR_MATERIALS_SHEEN: "KHR_materials_sheen", KHR_MATERIALS_SPECULAR: "KHR_materials_specular", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence", KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_MATERIALS_VOLUME: "KHR_materials_volume", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_TEXTURE_AVIF: "EXT_texture_avif", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression", EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing" };
  class Xt {
    constructor(e2) {
      this.parser = e2, this.name = qt.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
    }
    _markDefs() {
      const e2 = this.parser, t2 = this.parser.json.nodes || [];
      for (let n2 = 0, r2 = t2.length; n2 < r2; n2++) {
        const r3 = t2[n2];
        r3.extensions && r3.extensions[this.name] && void 0 !== r3.extensions[this.name].light && e2._addNodeRef(this.cache, r3.extensions[this.name].light);
      }
    }
    _loadLight(e2) {
      const t2 = this.parser, r2 = "light:" + e2;
      let i2 = t2.cache.get(r2);
      if (i2)
        return i2;
      const s2 = t2.json, o2 = ((s2.extensions && s2.extensions[this.name] || {}).lights || [])[e2];
      let a2;
      const l2 = new n.Ilk(16777215);
      void 0 !== o2.color && l2.fromArray(o2.color);
      const c2 = void 0 !== o2.range ? o2.range : 0;
      switch (o2.type) {
        case "directional":
          a2 = new Qt.ObjectConstructors.DirectionalLight(l2), a2.target.position.set(0, 0, -1), a2.add(a2.target);
          break;
        case "point":
          a2 = new Qt.ObjectConstructors.PointLight(l2), a2.distance = c2;
          break;
        case "spot":
          a2 = new Qt.ObjectConstructors.SpotLight(l2), a2.distance = c2, o2.spot = o2.spot || {}, o2.spot.innerConeAngle = void 0 !== o2.spot.innerConeAngle ? o2.spot.innerConeAngle : 0, o2.spot.outerConeAngle = void 0 !== o2.spot.outerConeAngle ? o2.spot.outerConeAngle : Math.PI / 4, a2.angle = o2.spot.outerConeAngle, a2.penumbra = 1 - o2.spot.innerConeAngle / o2.spot.outerConeAngle, a2.target.position.set(0, 0, -1), a2.add(a2.target);
          break;
        default:
          throw new Error("THREE.GLTFLoader: Unexpected light type: " + o2.type);
      }
      return a2.position.set(0, 0, 0), a2.decay = 2, Tn(a2, o2), void 0 !== o2.intensity && (a2.intensity = o2.intensity), a2.name = t2.createUniqueName(o2.name || "light_" + e2), i2 = Promise.resolve(a2), t2.cache.add(r2, i2), i2;
    }
    getDependency(e2, t2) {
      if ("light" === e2)
        return this._loadLight(t2);
    }
    createNodeAttachment(e2) {
      const t2 = this, n2 = this.parser, r2 = n2.json.nodes[e2], i2 = (r2.extensions && r2.extensions[this.name] || {}).light;
      return void 0 === i2 ? null : this._loadLight(i2).then(function(e3) {
        return n2._getNodeRef(t2.cache, i2, e3);
      });
    }
  }
  class Yt {
    constructor() {
      this.name = qt.KHR_MATERIALS_UNLIT;
    }
    getMaterialType() {
      return Qt.ObjectConstructors.MeshBasicMaterial;
    }
    extendParams(e2, t2, r2) {
      const i2 = [];
      e2.color = new n.Ilk(1, 1, 1), e2.opacity = 1;
      const s2 = t2.pbrMetallicRoughness;
      if (s2) {
        if (Array.isArray(s2.baseColorFactor)) {
          const t3 = s2.baseColorFactor;
          e2.color.fromArray(t3), e2.opacity = t3[3];
        }
        void 0 !== s2.baseColorTexture && i2.push(r2.assignTexture(e2, "map", s2.baseColorTexture, n.KI_));
      }
      return Promise.all(i2);
    }
  }
  class Kt {
    constructor(e2) {
      this.parser = e2, this.name = qt.KHR_MATERIALS_EMISSIVE_STRENGTH;
    }
    extendMaterialParams(e2, t2) {
      const n2 = this.parser.json.materials[e2];
      if (!n2.extensions || !n2.extensions[this.name])
        return Promise.resolve();
      const r2 = n2.extensions[this.name].emissiveStrength;
      return void 0 !== r2 && (t2.emissiveIntensity = r2), Promise.resolve();
    }
  }
  class Jt {
    constructor(e2) {
      this.parser = e2, this.name = qt.KHR_MATERIALS_CLEARCOAT;
    }
    getMaterialType(e2) {
      const t2 = this.parser.json.materials[e2];
      return t2.extensions && t2.extensions[this.name] ? Qt.ObjectConstructors.MeshPhysicalMaterial : null;
    }
    extendMaterialParams(e2, t2) {
      const r2 = this.parser, i2 = r2.json.materials[e2];
      if (!i2.extensions || !i2.extensions[this.name])
        return Promise.resolve();
      const s2 = [], o2 = i2.extensions[this.name];
      if (void 0 !== o2.clearcoatFactor && (t2.clearcoat = o2.clearcoatFactor), void 0 !== o2.clearcoatTexture && s2.push(r2.assignTexture(t2, "clearcoatMap", o2.clearcoatTexture)), void 0 !== o2.clearcoatRoughnessFactor && (t2.clearcoatRoughness = o2.clearcoatRoughnessFactor), void 0 !== o2.clearcoatRoughnessTexture && s2.push(r2.assignTexture(t2, "clearcoatRoughnessMap", o2.clearcoatRoughnessTexture)), void 0 !== o2.clearcoatNormalTexture && (s2.push(r2.assignTexture(t2, "clearcoatNormalMap", o2.clearcoatNormalTexture)), void 0 !== o2.clearcoatNormalTexture.scale)) {
        const e3 = o2.clearcoatNormalTexture.scale;
        t2.clearcoatNormalScale = new n.FM8(e3, e3);
      }
      return Promise.all(s2);
    }
  }
  class Zt {
    constructor(e2) {
      this.parser = e2, this.name = qt.KHR_MATERIALS_IRIDESCENCE;
    }
    getMaterialType(e2) {
      const t2 = this.parser.json.materials[e2];
      return t2.extensions && t2.extensions[this.name] ? Qt.ObjectConstructors.MeshPhysicalMaterial : null;
    }
    extendMaterialParams(e2, t2) {
      const n2 = this.parser, r2 = n2.json.materials[e2];
      if (!r2.extensions || !r2.extensions[this.name])
        return Promise.resolve();
      const i2 = [], s2 = r2.extensions[this.name];
      return void 0 !== s2.iridescenceFactor && (t2.iridescence = s2.iridescenceFactor), void 0 !== s2.iridescenceTexture && i2.push(n2.assignTexture(t2, "iridescenceMap", s2.iridescenceTexture)), void 0 !== s2.iridescenceIor && (t2.iridescenceIOR = s2.iridescenceIor), void 0 === t2.iridescenceThicknessRange && (t2.iridescenceThicknessRange = [100, 400]), void 0 !== s2.iridescenceThicknessMinimum && (t2.iridescenceThicknessRange[0] = s2.iridescenceThicknessMinimum), void 0 !== s2.iridescenceThicknessMaximum && (t2.iridescenceThicknessRange[1] = s2.iridescenceThicknessMaximum), void 0 !== s2.iridescenceThicknessTexture && i2.push(n2.assignTexture(t2, "iridescenceThicknessMap", s2.iridescenceThicknessTexture)), Promise.all(i2);
    }
  }
  class $t {
    constructor(e2) {
      this.parser = e2, this.name = qt.KHR_MATERIALS_SHEEN;
    }
    getMaterialType(e2) {
      const t2 = this.parser.json.materials[e2];
      return t2.extensions && t2.extensions[this.name] ? Qt.ObjectConstructors.MeshPhysicalMaterial : null;
    }
    extendMaterialParams(e2, t2) {
      const r2 = this.parser, i2 = r2.json.materials[e2];
      if (!i2.extensions || !i2.extensions[this.name])
        return Promise.resolve();
      const s2 = [];
      t2.sheenColor = new n.Ilk(0, 0, 0), t2.sheenRoughness = 0, t2.sheen = 1;
      const o2 = i2.extensions[this.name];
      return void 0 !== o2.sheenColorFactor && t2.sheenColor.fromArray(o2.sheenColorFactor), void 0 !== o2.sheenRoughnessFactor && (t2.sheenRoughness = o2.sheenRoughnessFactor), void 0 !== o2.sheenColorTexture && s2.push(r2.assignTexture(t2, "sheenColorMap", o2.sheenColorTexture, n.KI_)), void 0 !== o2.sheenRoughnessTexture && s2.push(r2.assignTexture(t2, "sheenRoughnessMap", o2.sheenRoughnessTexture)), i2.extras && void 0 !== i2.extras.sheenFactor && (t2.sheen = i2.extras.sheenFactor, delete i2.extras.sheenFactor), Promise.all(s2);
    }
  }
  class en {
    constructor(e2) {
      this.parser = e2, this.name = qt.KHR_MATERIALS_TRANSMISSION;
    }
    getMaterialType(e2) {
      const t2 = this.parser.json.materials[e2];
      return t2.extensions && t2.extensions[this.name] ? Qt.ObjectConstructors.MeshPhysicalMaterial : null;
    }
    extendMaterialParams(e2, t2) {
      const n2 = this.parser, r2 = n2.json.materials[e2];
      if (!r2.extensions || !r2.extensions[this.name])
        return Promise.resolve();
      const i2 = [], s2 = r2.extensions[this.name];
      return void 0 !== s2.transmissionFactor && (t2.transmission = s2.transmissionFactor), void 0 !== s2.transmissionTexture && i2.push(n2.assignTexture(t2, "transmissionMap", s2.transmissionTexture)), Promise.all(i2);
    }
  }
  class tn {
    constructor(e2) {
      this.parser = e2, this.name = qt.KHR_MATERIALS_VOLUME;
    }
    getMaterialType(e2) {
      const t2 = this.parser.json.materials[e2];
      return t2.extensions && t2.extensions[this.name] ? Qt.ObjectConstructors.MeshPhysicalMaterial : null;
    }
    extendMaterialParams(e2, t2) {
      const r2 = this.parser, i2 = r2.json.materials[e2];
      if (!i2.extensions || !i2.extensions[this.name])
        return Promise.resolve();
      const s2 = [], o2 = i2.extensions[this.name];
      t2.thickness = void 0 !== o2.thicknessFactor ? o2.thicknessFactor : 0, void 0 !== o2.thicknessTexture && s2.push(r2.assignTexture(t2, "thicknessMap", o2.thicknessTexture)), t2.attenuationDistance = o2.attenuationDistance || 1 / 0;
      const a2 = o2.attenuationColor || [1, 1, 1];
      return t2.attenuationColor = new n.Ilk(a2[0], a2[1], a2[2]), Promise.all(s2);
    }
  }
  class nn {
    constructor(e2) {
      this.parser = e2, this.name = qt.KHR_MATERIALS_IOR;
    }
    getMaterialType(e2) {
      const t2 = this.parser.json.materials[e2];
      return t2.extensions && t2.extensions[this.name] ? Qt.ObjectConstructors.MeshPhysicalMaterial : null;
    }
    extendMaterialParams(e2, t2) {
      const n2 = this.parser.json.materials[e2];
      if (!n2.extensions || !n2.extensions[this.name])
        return Promise.resolve();
      const r2 = n2.extensions[this.name];
      return t2.ior = void 0 !== r2.ior ? r2.ior : 1.5, Promise.resolve();
    }
  }
  class rn {
    constructor(e2) {
      this.parser = e2, this.name = qt.KHR_MATERIALS_SPECULAR;
    }
    getMaterialType(e2) {
      const t2 = this.parser.json.materials[e2];
      return t2.extensions && t2.extensions[this.name] ? Qt.ObjectConstructors.MeshPhysicalMaterial : null;
    }
    extendMaterialParams(e2, t2) {
      const r2 = this.parser, i2 = r2.json.materials[e2];
      if (!i2.extensions || !i2.extensions[this.name])
        return Promise.resolve();
      const s2 = [], o2 = i2.extensions[this.name];
      t2.specularIntensity = void 0 !== o2.specularFactor ? o2.specularFactor : 1, void 0 !== o2.specularTexture && s2.push(r2.assignTexture(t2, "specularIntensityMap", o2.specularTexture));
      const a2 = o2.specularColorFactor || [1, 1, 1];
      return t2.specularColor = new n.Ilk(a2[0], a2[1], a2[2]), void 0 !== o2.specularColorTexture && s2.push(r2.assignTexture(t2, "specularColorMap", o2.specularColorTexture, n.KI_)), Promise.all(s2);
    }
  }
  class sn {
    constructor(e2) {
      this.parser = e2, this.name = qt.KHR_MATERIALS_ANISOTROPY;
    }
    getMaterialType(e2) {
      const t2 = this.parser.json.materials[e2];
      return t2.extensions && t2.extensions[this.name] ? n.EJi : null;
    }
    extendMaterialParams(e2, t2) {
      const n2 = this.parser, r2 = n2.json.materials[e2];
      if (!r2.extensions || !r2.extensions[this.name])
        return Promise.resolve();
      const i2 = [], s2 = r2.extensions[this.name];
      return void 0 !== s2.anisotropyStrength && (t2.anisotropy = s2.anisotropyStrength), void 0 !== s2.anisotropyRotation && (t2.anisotropyRotation = s2.anisotropyRotation), void 0 !== s2.anisotropyTexture && i2.push(n2.assignTexture(t2, "anisotropyMap", s2.anisotropyTexture)), Promise.all(i2);
    }
  }
  class on {
    constructor(e2) {
      this.parser = e2, this.name = qt.KHR_TEXTURE_BASISU;
    }
    loadTexture(e2) {
      const t2 = this.parser, n2 = t2.json, r2 = n2.textures[e2];
      if (!r2.extensions || !r2.extensions[this.name])
        return null;
      const i2 = r2.extensions[this.name], s2 = t2.options.ktx2Loader;
      if (!s2) {
        if (n2.extensionsRequired && n2.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
        return null;
      }
      return t2.loadTextureImage(e2, i2.source, s2);
    }
  }
  class an {
    constructor(e2) {
      this.parser = e2, this.name = qt.EXT_TEXTURE_WEBP, this.isSupported = null;
    }
    loadTexture(e2) {
      const t2 = this.name, n2 = this.parser, r2 = n2.json, i2 = r2.textures[e2];
      if (!i2.extensions || !i2.extensions[t2])
        return null;
      const s2 = i2.extensions[t2], o2 = r2.images[s2.source];
      let a2 = n2.textureLoader;
      if (o2.uri) {
        const e3 = n2.options.manager.getHandler(o2.uri);
        null !== e3 && (a2 = e3);
      }
      return this.detectSupport().then(function(i3) {
        if (i3)
          return n2.loadTextureImage(e2, s2.source, a2);
        if (r2.extensionsRequired && r2.extensionsRequired.indexOf(t2) >= 0)
          throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
        return n2.loadTexture(e2);
      });
    }
    detectSupport() {
      return this.isSupported || (this.isSupported = new Promise(function(e2) {
        const t2 = new Image();
        t2.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t2.onload = t2.onerror = function() {
          e2(1 === t2.height);
        };
      })), this.isSupported;
    }
  }
  class ln {
    constructor(e2) {
      this.parser = e2, this.name = qt.EXT_TEXTURE_AVIF, this.isSupported = null;
    }
    loadTexture(e2) {
      const t2 = this.name, n2 = this.parser, r2 = n2.json, i2 = r2.textures[e2];
      if (!i2.extensions || !i2.extensions[t2])
        return null;
      const s2 = i2.extensions[t2], o2 = r2.images[s2.source];
      let a2 = n2.textureLoader;
      if (o2.uri) {
        const e3 = n2.options.manager.getHandler(o2.uri);
        null !== e3 && (a2 = e3);
      }
      return this.detectSupport().then(function(i3) {
        if (i3)
          return n2.loadTextureImage(e2, s2.source, a2);
        if (r2.extensionsRequired && r2.extensionsRequired.indexOf(t2) >= 0)
          throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
        return n2.loadTexture(e2);
      });
    }
    detectSupport() {
      return this.isSupported || (this.isSupported = new Promise(function(e2) {
        const t2 = new Image();
        t2.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t2.onload = t2.onerror = function() {
          e2(1 === t2.height);
        };
      })), this.isSupported;
    }
  }
  class cn {
    constructor(e2) {
      this.name = qt.EXT_MESHOPT_COMPRESSION, this.parser = e2;
    }
    loadBufferView(e2) {
      const t2 = this.parser.json, n2 = t2.bufferViews[e2];
      if (n2.extensions && n2.extensions[this.name]) {
        const e3 = n2.extensions[this.name], r2 = this.parser.getDependency("buffer", e3.buffer), i2 = this.parser.options.meshoptDecoder;
        if (!i2 || !i2.supported) {
          if (t2.extensionsRequired && t2.extensionsRequired.indexOf(this.name) >= 0)
            throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
          return null;
        }
        return r2.then(function(t3) {
          const n3 = e3.byteOffset || 0, r3 = e3.byteLength || 0, s2 = e3.count, o2 = e3.byteStride, a2 = new Uint8Array(t3, n3, r3);
          return i2.decodeGltfBufferAsync ? i2.decodeGltfBufferAsync(s2, o2, a2, e3.mode, e3.filter).then(function(e4) {
            return e4.buffer;
          }) : i2.ready.then(function() {
            const t4 = new ArrayBuffer(s2 * o2);
            return i2.decodeGltfBuffer(new Uint8Array(t4), s2, o2, a2, e3.mode, e3.filter), t4;
          });
        });
      }
      return null;
    }
  }
  class un {
    constructor(e2) {
      this.name = qt.EXT_MESH_GPU_INSTANCING, this.parser = e2;
    }
    createNodeMesh(e2) {
      const t2 = this.parser.json, r2 = t2.nodes[e2];
      if (!r2.extensions || !r2.extensions[this.name] || void 0 === r2.mesh)
        return null;
      const i2 = t2.meshes[r2.mesh];
      for (const e3 of i2.primitives)
        if (e3.mode !== yn.TRIANGLES && e3.mode !== yn.TRIANGLE_STRIP && e3.mode !== yn.TRIANGLE_FAN && void 0 !== e3.mode)
          return null;
      const s2 = r2.extensions[this.name].attributes, o2 = [], a2 = {};
      for (const e3 in s2)
        o2.push(this.parser.getDependency("accessor", s2[e3]).then((t3) => (a2[e3] = t3, a2[e3])));
      return o2.length < 1 ? null : (o2.push(this.parser.createNodeMesh(e2)), Promise.all(o2).then((e3) => {
        const t3 = e3.pop(), r3 = t3.isGroup ? t3.children : [t3], i3 = e3[0].count, s3 = [];
        for (const e4 of r3) {
          const t4 = new n.yGw(), r4 = new n.Pa4(), o3 = new n._fP(), l2 = new n.Pa4(1, 1, 1), c2 = new n.SPe(e4.geometry, e4.material, i3);
          for (let e5 = 0; e5 < i3; e5++)
            a2.TRANSLATION && r4.fromBufferAttribute(a2.TRANSLATION, e5), a2.ROTATION && o3.fromBufferAttribute(a2.ROTATION, e5), a2.SCALE && l2.fromBufferAttribute(a2.SCALE, e5), c2.setMatrixAt(e5, t4.compose(r4, o3, l2));
          c2.sourceTrs = a2;
          for (const t5 in a2)
            "TRANSLATION" !== t5 && "ROTATION" !== t5 && "SCALE" !== t5 && e4.geometry.setAttribute(t5, a2[t5]);
          n.Tme.prototype.copy.call(c2, e4), this.parser.assignFinalMaterial(c2), s3.push(c2);
        }
        return t3.isGroup ? (t3.clear(), t3.add(...s3), t3) : s3[0];
      }));
    }
  }
  const pn = "glTF";
  class dn {
    constructor(e2) {
      this.name = qt.KHR_BINARY_GLTF, this.content = null, this.body = null;
      const t2 = new DataView(e2, 0, 12), n2 = new TextDecoder();
      if (this.header = { magic: n2.decode(new Uint8Array(e2.slice(0, 4))), version: t2.getUint32(4, true), length: t2.getUint32(8, true) }, this.header.magic !== pn)
        throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
      if (this.header.version < 2)
        throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
      const r2 = this.header.length - 12, i2 = new DataView(e2, 12);
      let s2 = 0;
      for (; s2 < r2; ) {
        const t3 = i2.getUint32(s2, true);
        s2 += 4;
        const r3 = i2.getUint32(s2, true);
        if (s2 += 4, 1313821514 === r3) {
          const r4 = new Uint8Array(e2, 12 + s2, t3);
          this.content = n2.decode(r4);
        } else if (5130562 === r3) {
          const n3 = 12 + s2;
          this.body = e2.slice(n3, n3 + t3);
        }
        s2 += t3;
      }
      if (null === this.content)
        throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
  }
  class hn {
    constructor(e2, t2) {
      if (!t2)
        throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
      this.name = qt.KHR_DRACO_MESH_COMPRESSION, this.json = e2, this.dracoLoader = t2, this.dracoLoader.preload();
    }
    decodePrimitive(e2, t2) {
      const n2 = this.json, r2 = this.dracoLoader, i2 = e2.extensions[this.name].bufferView, s2 = e2.extensions[this.name].attributes, o2 = {}, a2 = {}, l2 = {};
      for (const e3 in s2) {
        const t3 = En[e3] || e3.toLowerCase();
        o2[t3] = s2[e3];
      }
      for (const t3 in e2.attributes) {
        const r3 = En[t3] || t3.toLowerCase();
        if (void 0 !== s2[t3]) {
          const i3 = n2.accessors[e2.attributes[t3]], s3 = bn[i3.componentType];
          l2[r3] = s3.name, a2[r3] = true === i3.normalized;
        }
      }
      return t2.getDependency("bufferView", i2).then(function(e3) {
        return new Promise(function(t3) {
          r2.decodeDracoFile(e3, function(e4) {
            for (const t4 in e4.attributes) {
              const n3 = e4.attributes[t4], r3 = a2[t4];
              void 0 !== r3 && (n3.normalized = r3);
            }
            t3(e4);
          }, o2, l2);
        });
      });
    }
  }
  class fn {
    constructor() {
      this.name = qt.KHR_TEXTURE_TRANSFORM;
    }
    extendTexture(e2, t2) {
      return void 0 !== t2.texCoord && t2.texCoord !== e2.channel || void 0 !== t2.offset || void 0 !== t2.rotation || void 0 !== t2.scale ? (e2.__hasGLTFUuid || (e2 = e2.clone()), void 0 !== t2.texCoord && (e2.channel = t2.texCoord), void 0 !== t2.offset && e2.offset.fromArray(t2.offset), void 0 !== t2.rotation && (e2.rotation = t2.rotation), void 0 !== t2.scale && e2.repeat.fromArray(t2.scale), e2.needsUpdate = true, e2) : e2;
    }
  }
  class mn {
    constructor() {
      this.name = qt.KHR_MESH_QUANTIZATION;
    }
  }
  class _n extends n._C8 {
    constructor(e2, t2, n2, r2) {
      super(e2, t2, n2, r2);
    }
    copySampleValue_(e2) {
      const t2 = this.resultBuffer, n2 = this.sampleValues, r2 = this.valueSize, i2 = e2 * r2 * 3 + r2;
      for (let e3 = 0; e3 !== r2; e3++)
        t2[e3] = n2[i2 + e3];
      return t2;
    }
    interpolate_(e2, t2, n2, r2) {
      const i2 = this.resultBuffer, s2 = this.sampleValues, o2 = this.valueSize, a2 = 2 * o2, l2 = 3 * o2, c2 = r2 - t2, u2 = (n2 - t2) / c2, p2 = u2 * u2, d2 = p2 * u2, h2 = e2 * l2, f2 = h2 - l2, m2 = -2 * d2 + 3 * p2, _2 = d2 - p2, g2 = 1 - m2, v2 = _2 - p2 + u2;
      for (let e3 = 0; e3 !== o2; e3++) {
        const t3 = s2[f2 + e3 + o2], n3 = s2[f2 + e3 + a2] * c2, r3 = s2[h2 + e3 + o2], l3 = s2[h2 + e3] * c2;
        i2[e3] = g2 * t3 + v2 * n3 + m2 * r3 + _2 * l3;
      }
      return i2;
    }
  }
  const gn = new n._fP();
  class vn extends _n {
    interpolate_(e2, t2, n2, r2) {
      const i2 = super.interpolate_(e2, t2, n2, r2);
      return gn.fromArray(i2).normalize().toArray(i2), i2;
    }
  }
  const yn = { FLOAT: 5126, FLOAT_MAT3: 35675, FLOAT_MAT4: 35676, FLOAT_VEC2: 35664, FLOAT_VEC3: 35665, FLOAT_VEC4: 35666, LINEAR: 9729, REPEAT: 10497, SAMPLER_2D: 35678, POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6, UNSIGNED_BYTE: 5121, UNSIGNED_SHORT: 5123 }, bn = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, wn = { 9728: n.TyD, 9729: n.wem, 9984: n.YLQ, 9985: n.qyh, 9986: n.aH4, 9987: n.D1R }, An = { 33071: n.uWy, 33648: n.OoA, 10497: n.rpg }, xn = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, En = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv1", TEXCOORD_2: "uv2", TEXCOORD_3: "uv3", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, Cn = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, Sn = { CUBICSPLINE: void 0, LINEAR: n.NMF, STEP: n.Syv };
  function Mn(e2, t2, n2) {
    for (const r2 in n2.extensions)
      void 0 === e2[r2] && (t2.userData.gltfExtensions = t2.userData.gltfExtensions || {}, t2.userData.gltfExtensions[r2] = n2.extensions[r2]);
  }
  function Tn(e2, t2) {
    void 0 !== t2.extras && ("object" == typeof t2.extras ? Object.assign(e2.userData, t2.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t2.extras));
  }
  function Pn(e2, t2) {
    if (e2.updateMorphTargets(), void 0 !== t2.weights)
      for (let n2 = 0, r2 = t2.weights.length; n2 < r2; n2++)
        e2.morphTargetInfluences[n2] = t2.weights[n2];
    if (t2.extras && Array.isArray(t2.extras.targetNames)) {
      const n2 = t2.extras.targetNames;
      if (e2.morphTargetInfluences.length === n2.length) {
        e2.morphTargetDictionary = {};
        for (let t3 = 0, r2 = n2.length; t3 < r2; t3++)
          e2.morphTargetDictionary[n2[t3]] = t3;
      } else
        console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
    }
  }
  function In(e2) {
    let t2;
    const n2 = e2.extensions && e2.extensions[qt.KHR_DRACO_MESH_COMPRESSION];
    if (t2 = n2 ? "draco:" + n2.bufferView + ":" + n2.indices + ":" + Rn(n2.attributes) : e2.indices + ":" + Rn(e2.attributes) + ":" + e2.mode, void 0 !== e2.targets)
      for (let n3 = 0, r2 = e2.targets.length; n3 < r2; n3++)
        t2 += ":" + Rn(e2.targets[n3]);
    return t2;
  }
  function Rn(e2) {
    let t2 = "";
    const n2 = Object.keys(e2).sort();
    for (let r2 = 0, i2 = n2.length; r2 < i2; r2++)
      t2 += n2[r2] + ":" + e2[n2[r2]] + ";";
    return t2;
  }
  function kn(e2) {
    switch (e2) {
      case Int8Array:
        return 1 / 127;
      case Uint8Array:
        return 1 / 255;
      case Int16Array:
        return 1 / 32767;
      case Uint16Array:
        return 1 / 65535;
      default:
        throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
    }
  }
  const Dn = new n.yGw();
  class Bn {
    constructor(e2 = {}, t2 = {}) {
      this.json = e2, this.extensions = {}, this.plugins = {}, this.options = t2, this.cache = new Wt(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
      let r2 = false, i2 = false, s2 = -1;
      "undefined" != typeof navigator && (r2 = true === /^((?!chrome|android).)*safari/i.test(navigator.userAgent), i2 = navigator.userAgent.indexOf("Firefox") > -1, s2 = i2 ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), "undefined" == typeof createImageBitmap || r2 || i2 && s2 < 98 ? this.textureLoader = new n.dpR(this.options.manager) : this.textureLoader = new n.QRU(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new n.hH6(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(true);
    }
    setExtensions(e2) {
      this.extensions = e2;
    }
    setPlugins(e2) {
      this.plugins = e2;
    }
    parse(e2, t2) {
      const n2 = this, r2 = this.json, i2 = this.extensions;
      this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(e3) {
        return e3._markDefs && e3._markDefs();
      }), Promise.all(this._invokeAll(function(e3) {
        return e3.beforeRoot && e3.beforeRoot();
      })).then(function() {
        return Promise.all([n2.getDependencies("scene"), n2.getDependencies("animation"), n2.getDependencies("camera")]);
      }).then(function(t3) {
        const s2 = { scene: t3[0][r2.scene || 0], scenes: t3[0], animations: t3[1], cameras: t3[2], asset: r2.asset, parser: n2, userData: {} };
        Mn(i2, s2, r2), Tn(s2, r2), Promise.all(n2._invokeAll(function(e3) {
          return e3.afterRoot && e3.afterRoot(s2);
        })).then(function() {
          e2(s2);
        });
      }).catch(t2);
    }
    _markDefs() {
      const e2 = this.json.nodes || [], t2 = this.json.skins || [], n2 = this.json.meshes || [];
      for (let n3 = 0, r2 = t2.length; n3 < r2; n3++) {
        const r3 = t2[n3].joints;
        for (let t3 = 0, n4 = r3.length; t3 < n4; t3++)
          e2[r3[t3]].isBone = true;
      }
      for (let t3 = 0, r2 = e2.length; t3 < r2; t3++) {
        const r3 = e2[t3];
        void 0 !== r3.mesh && (this._addNodeRef(this.meshCache, r3.mesh), void 0 !== r3.skin && (n2[r3.mesh].isSkinnedMesh = true)), void 0 !== r3.camera && this._addNodeRef(this.cameraCache, r3.camera);
      }
    }
    _addNodeRef(e2, t2) {
      void 0 !== t2 && (void 0 === e2.refs[t2] && (e2.refs[t2] = e2.uses[t2] = 0), e2.refs[t2]++);
    }
    _getNodeRef(e2, t2, n2) {
      if (e2.refs[t2] <= 1)
        return n2;
      const r2 = n2.clone(), i2 = (e3, t3) => {
        const n3 = this.associations.get(e3);
        null != n3 && this.associations.set(t3, n3);
        for (const [n4, r3] of e3.children.entries())
          i2(r3, t3.children[n4]);
      };
      return i2(n2, r2), r2.name += "_instance_" + e2.uses[t2]++, r2;
    }
    _invokeOne(e2) {
      const t2 = Object.values(this.plugins);
      t2.push(this);
      for (let n2 = 0; n2 < t2.length; n2++) {
        const r2 = e2(t2[n2]);
        if (r2)
          return r2;
      }
      return null;
    }
    _invokeAll(e2) {
      const t2 = Object.values(this.plugins);
      t2.unshift(this);
      const n2 = [];
      for (let r2 = 0; r2 < t2.length; r2++) {
        const i2 = e2(t2[r2]);
        i2 && n2.push(i2);
      }
      return n2;
    }
    getDependency(e2, t2) {
      const n2 = e2 + ":" + t2;
      let r2 = this.cache.get(n2);
      if (!r2) {
        switch (e2) {
          case "scene":
            r2 = this.loadScene(t2);
            break;
          case "node":
            r2 = this._invokeOne(function(e3) {
              return e3.loadNode && e3.loadNode(t2);
            });
            break;
          case "mesh":
            r2 = this._invokeOne(function(e3) {
              return e3.loadMesh && e3.loadMesh(t2);
            });
            break;
          case "accessor":
            r2 = this.loadAccessor(t2);
            break;
          case "bufferView":
            r2 = this._invokeOne(function(e3) {
              return e3.loadBufferView && e3.loadBufferView(t2);
            });
            break;
          case "buffer":
            r2 = this.loadBuffer(t2);
            break;
          case "material":
            r2 = this._invokeOne(function(e3) {
              return e3.loadMaterial && e3.loadMaterial(t2);
            });
            break;
          case "texture":
            r2 = this._invokeOne(function(e3) {
              return e3.loadTexture && e3.loadTexture(t2);
            });
            break;
          case "skin":
            r2 = this.loadSkin(t2);
            break;
          case "animation":
            r2 = this._invokeOne(function(e3) {
              return e3.loadAnimation && e3.loadAnimation(t2);
            });
            break;
          case "camera":
            r2 = this.loadCamera(t2);
            break;
          default:
            if (r2 = this._invokeOne(function(n3) {
              return n3 != this && n3.getDependency && n3.getDependency(e2, t2);
            }), !r2)
              throw new Error("Unknown type: " + e2);
        }
        this.cache.add(n2, r2);
      }
      return r2;
    }
    getDependencies(e2) {
      let t2 = this.cache.get(e2);
      if (!t2) {
        const n2 = this, r2 = this.json[e2 + ("mesh" === e2 ? "es" : "s")] || [];
        t2 = Promise.all(r2.map(function(t3, r3) {
          return n2.getDependency(e2, r3);
        })), this.cache.add(e2, t2);
      }
      return t2;
    }
    loadBuffer(e2) {
      const t2 = this.json.buffers[e2], r2 = this.fileLoader;
      if (t2.type && "arraybuffer" !== t2.type)
        throw new Error("THREE.GLTFLoader: " + t2.type + " buffer type is not supported.");
      if (void 0 === t2.uri && 0 === e2)
        return Promise.resolve(this.extensions[qt.KHR_BINARY_GLTF].body);
      const i2 = this.options;
      return new Promise(function(e3, s2) {
        r2.load(n.Zp0.resolveURL(t2.uri, i2.path), e3, void 0, function() {
          s2(new Error('THREE.GLTFLoader: Failed to load buffer "' + t2.uri + '".'));
        });
      });
    }
    loadBufferView(e2) {
      const t2 = this.json.bufferViews[e2];
      return this.getDependency("buffer", t2.buffer).then(function(e3) {
        const n2 = t2.byteLength || 0, r2 = t2.byteOffset || 0;
        return e3.slice(r2, r2 + n2);
      });
    }
    loadAccessor(e2) {
      const t2 = this, r2 = this.json, i2 = this.json.accessors[e2];
      if (void 0 === i2.bufferView && void 0 === i2.sparse) {
        const e3 = xn[i2.type], t3 = bn[i2.componentType], r3 = true === i2.normalized, s3 = new t3(i2.count * e3);
        return Promise.resolve(new n.TlE(s3, e3, r3));
      }
      const s2 = [];
      return void 0 !== i2.bufferView ? s2.push(this.getDependency("bufferView", i2.bufferView)) : s2.push(null), void 0 !== i2.sparse && (s2.push(this.getDependency("bufferView", i2.sparse.indices.bufferView)), s2.push(this.getDependency("bufferView", i2.sparse.values.bufferView))), Promise.all(s2).then(function(e3) {
        const s3 = e3[0], o2 = xn[i2.type], a2 = bn[i2.componentType], l2 = a2.BYTES_PER_ELEMENT, c2 = l2 * o2, u2 = i2.byteOffset || 0, p2 = void 0 !== i2.bufferView ? r2.bufferViews[i2.bufferView].byteStride : void 0, d2 = true === i2.normalized;
        let h2, f2;
        if (p2 && p2 !== c2) {
          const e4 = Math.floor(u2 / p2), r3 = "InterleavedBuffer:" + i2.bufferView + ":" + i2.componentType + ":" + e4 + ":" + i2.count;
          let c3 = t2.cache.get(r3);
          c3 || (h2 = new a2(s3, e4 * p2, i2.count * p2 / l2), c3 = new n.vpT(h2, p2 / l2), t2.cache.add(r3, c3)), f2 = new n.kB5(c3, o2, u2 % p2 / l2, d2);
        } else
          h2 = null === s3 ? new a2(i2.count * o2) : new a2(s3, u2, i2.count * o2), f2 = new n.TlE(h2, o2, d2);
        if (void 0 !== i2.sparse) {
          const t3 = xn.SCALAR, r3 = bn[i2.sparse.indices.componentType], l3 = i2.sparse.indices.byteOffset || 0, c3 = i2.sparse.values.byteOffset || 0, u3 = new r3(e3[1], l3, i2.sparse.count * t3), p3 = new a2(e3[2], c3, i2.sparse.count * o2);
          null !== s3 && (f2 = new n.TlE(f2.array.slice(), f2.itemSize, f2.normalized));
          for (let e4 = 0, t4 = u3.length; e4 < t4; e4++) {
            const t5 = u3[e4];
            if (f2.setX(t5, p3[e4 * o2]), o2 >= 2 && f2.setY(t5, p3[e4 * o2 + 1]), o2 >= 3 && f2.setZ(t5, p3[e4 * o2 + 2]), o2 >= 4 && f2.setW(t5, p3[e4 * o2 + 3]), o2 >= 5)
              throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
          }
        }
        return f2;
      });
    }
    loadTexture(e2) {
      const t2 = this.json, n2 = this.options, r2 = t2.textures[e2].source, i2 = t2.images[r2];
      let s2 = this.textureLoader;
      if (i2.uri) {
        const e3 = n2.manager.getHandler(i2.uri);
        null !== e3 && (s2 = e3);
      }
      return this.loadTextureImage(e2, r2, s2);
    }
    loadTextureImage(e2, t2, r2) {
      const i2 = this, s2 = this.json, o2 = s2.textures[e2], a2 = s2.images[t2], l2 = (a2.uri || a2.bufferView) + ":" + o2.sampler;
      if (this.textureCache[l2])
        return this.textureCache[l2];
      const c2 = this.loadImageSource(t2, r2).then(function(t3) {
        t3.name = o2.name || a2.name || "", "" === t3.name && "string" == typeof a2.uri && false === a2.uri.startsWith("data:image/") && (t3.name = a2.uri);
        const r3 = (s2.samplers || {})[o2.sampler] || {};
        return t3.magFilter = wn[r3.magFilter] || n.wem, t3.minFilter = wn[r3.minFilter] || n.D1R, t3.wrapS = An[r3.wrapS] || n.rpg, t3.wrapT = An[r3.wrapT] || n.rpg, r3.extras && void 0 !== r3.extras.uuid && (t3.uuid = r3.extras.uuid, t3.__hasGLTFUuid = true), i2.associations.set(t3, { textures: e2 }), t3;
      }).catch(function() {
        return null;
      });
      return this.textureCache[l2] = c2, c2;
    }
    loadImageSource(e2, t2, r2 = false, i2 = false) {
      const s2 = this, o2 = this.json, a2 = this.options;
      if (!i2 && void 0 !== this.sourceCache[e2])
        return this.sourceCache[e2].then((e3) => e3.clone());
      const l2 = o2.images[e2], c2 = self.URL || self.webkitURL;
      void 0 === l2.uri && l2.extras && l2.extras.uri && (l2.uri = l2.extras.uri);
      let u2 = l2.uri || "", p2 = false, d2 = null;
      if (void 0 === l2.bufferView || r2 && u2) {
        if (void 0 === l2.uri)
          throw new Error("THREE.GLTFLoader: Image " + e2 + " is missing URI and bufferView");
      } else
        u2 = s2.getDependency("bufferView", l2.bufferView).then(function(e3) {
          p2 = true;
          const t3 = new Blob([e3], { type: l2.mimeType });
          return u2 = c2.createObjectURL(t3), d2 = t3, u2;
        });
      const h2 = Promise.resolve(u2).then(function(e3) {
        return new Promise(function(r3, i3) {
          let o3 = r3;
          true === t2.isImageBitmapLoader && (o3 = function(e4) {
            const t3 = new n.xEZ(e4);
            t3.needsUpdate = true, r3(t3);
          }), t2.load(n.Zp0.resolveURL(e3, a2.path), o3, void 0, function(l3) {
            true === t2.isImageBitmapLoader ? (t2 = new n.dpR(s2.options.manager), o3 = r3, t2.setCrossOrigin(s2.options.crossOrigin), t2.setRequestHeader(s2.options.requestHeader), t2.load(n.Zp0.resolveURL(e3, a2.path), o3, void 0, i3)) : i3(l3);
          });
        });
      }).then(function(i3) {
        var o3;
        if (true === p2 && c2.revokeObjectURL(u2), i3.userData.mimeType = l2.mimeType || ((o3 = l2.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === o3.search(/^data\:image\/jpeg/) ? "image/jpeg" : o3.search(/\.webp($|\?)/i) > 0 || 0 === o3.search(/^data\:image\/webp/) ? "image/webp" : "image/png"), i3.flipY = false, l2.extras) {
          if (void 0 !== l2.extras.flipY) {
            if (true === t2.isImageBitmapLoader && void 0 !== typeof createImageBitmap) {
              let e3 = i3;
              const t3 = l2.extras.flipY && !e3.flipY;
              createImageBitmap(e3.source.data, { imageOrientation: t3 ? "flipY" : "none" }).then(function(t4) {
                e3._newTex && (e3 = e3._newTex), e3.source.data.close && e3.source.data.close(), e3.source.data = t4, e3.source.needsUpdate = true, e3.needsUpdate = true;
              });
            }
            i3.flipY = l2.extras.flipY, i3.needsUpdate = true, delete l2.extras.flipY;
          }
          void 0 !== l2.extras.uuid && (i3.source.uuid = l2.extras.uuid), void 0 !== l2.extras.t_uuid && (i3.uuid = l2.extras.t_uuid, i3.__hasGLTFUuid = true);
        }
        return l2.uri && "string" == typeof l2.uri && false === p2 && !l2.uri.startsWith("/") && (i3.userData.rootPath = n.Zp0.resolveURL(l2.uri, a2.path)), d2 && (i3.userData.__sourceBlob = d2), !r2 && l2.uri && l2.uri !== u2 && s2.loadImageSource(e2, t2, true, true).then(function(e3) {
          i3.source.data && i3.source.data.close && i3.source.data.close(), i3.dispose(), i3.source = e3.source, i3.source.needsUpdate = true, i3.needsUpdate = true, i3.uuid = e3.uuid, e3.__hasGLTFUuid && (i3.__hasGLTFUuid = true), i3.flipY = e3.flipY, i3.userData = e3.userData, i3.setDirty && i3.setDirty(), e3._newTex = i3;
        }), i3;
      }).catch(function(e3) {
        throw console.error("THREE.GLTFLoader: Couldn't load texture", u2), e3;
      });
      return this.sourceCache[e2] = h2, h2;
    }
    assignTexture(e2, t2, n2, r2) {
      const i2 = this;
      return this.getDependency("texture", n2.index).then(function(s2) {
        if (!s2)
          return null;
        if (void 0 !== n2.texCoord && n2.texCoord > 0 && ((s2 = s2.clone()).channel = n2.texCoord), i2.extensions[qt.KHR_TEXTURE_TRANSFORM]) {
          const e3 = void 0 !== n2.extensions ? n2.extensions[qt.KHR_TEXTURE_TRANSFORM] : void 0;
          if (e3) {
            const t3 = i2.associations.get(s2);
            s2 = i2.extensions[qt.KHR_TEXTURE_TRANSFORM].extendTexture(s2, e3), i2.associations.set(s2, t3);
          }
        }
        return void 0 !== r2 && (s2.colorSpace = r2), e2[t2] = s2, s2;
      });
    }
    assignFinalMaterial(e2) {
      const t2 = e2.geometry;
      let r2 = e2.material;
      const i2 = void 0 === t2.attributes.tangent, s2 = void 0 !== t2.attributes.color, o2 = void 0 === t2.attributes.normal;
      if (e2.isPoints) {
        const e3 = "PointsMaterial:" + r2.uuid;
        let t3 = this.cache.get(e3);
        t3 || (t3 = new Qt.ObjectConstructors.PointsMaterial(), n.F5T.prototype.copy.call(t3, r2), t3.color.copy(r2.color), t3.map = r2.map, t3.sizeAttenuation = false, this.cache.add(e3, t3)), r2 = t3;
      } else if (e2.isLine) {
        const e3 = "LineBasicMaterial:" + r2.uuid;
        let t3 = this.cache.get(e3);
        t3 || (t3 = new Qt.ObjectConstructors.LineBasicMaterial(), n.F5T.prototype.copy.call(t3, r2), t3.color.copy(r2.color), t3.map = r2.map, this.cache.add(e3, t3)), r2 = t3;
      }
      const a2 = !(!r2.userData || !r2.userData.gltfExtensions || !r2.userData.gltfExtensions.WEBGI_material_extras);
      if ((i2 || s2 || o2) && !a2) {
        let e3 = "ClonedMaterial:" + r2.uuid + ":";
        i2 && (e3 += "derivative-tangents:"), s2 && (e3 += "vertex-colors:"), o2 && (e3 += "flat-shading:");
        let t3 = this.cache.get(e3);
        t3 || (t3 = r2.clone(), s2 && (t3.vertexColors = true), o2 && (t3.flatShading = true), i2 && (t3.normalScale && (t3.normalScale.y *= -1), t3.clearcoatNormalScale && (t3.clearcoatNormalScale.y *= -1)), this.cache.add(e3, t3), this.associations.set(t3, this.associations.get(r2))), r2 = t3;
      }
      e2.material = r2;
    }
    getMaterialType() {
      return Qt.ObjectConstructors.MeshStandardMaterial;
    }
    loadMaterial(e2) {
      const t2 = this, r2 = this.json, i2 = this.extensions, s2 = r2.materials[e2];
      let o2;
      const a2 = {}, l2 = [];
      if ((s2.extensions || {})[qt.KHR_MATERIALS_UNLIT]) {
        const e3 = i2[qt.KHR_MATERIALS_UNLIT];
        o2 = e3.getMaterialType(), l2.push(e3.extendParams(a2, s2, t2));
      } else {
        const r3 = s2.pbrMetallicRoughness || {};
        if (a2.color = new n.Ilk(1, 1, 1), a2.opacity = 1, Array.isArray(r3.baseColorFactor)) {
          const e3 = r3.baseColorFactor;
          a2.color.fromArray(e3), a2.opacity = e3[3];
        }
        void 0 !== r3.baseColorTexture && l2.push(t2.assignTexture(a2, "map", r3.baseColorTexture, n.KI_)), a2.metalness = void 0 !== r3.metallicFactor ? r3.metallicFactor : 1, a2.roughness = void 0 !== r3.roughnessFactor ? r3.roughnessFactor : 1, void 0 !== r3.metallicRoughnessTexture && (l2.push(t2.assignTexture(a2, "metalnessMap", r3.metallicRoughnessTexture)), l2.push(t2.assignTexture(a2, "roughnessMap", r3.metallicRoughnessTexture))), o2 = this._invokeOne(function(t3) {
          return t3.getMaterialType && t3.getMaterialType(e2);
        }), l2.push(Promise.all(this._invokeAll(function(t3) {
          return t3.extendMaterialParams && t3.extendMaterialParams(e2, a2);
        })));
      }
      true === s2.doubleSided && (a2.side = n.ehD);
      const c2 = s2.alphaMode || "OPAQUE";
      if ("BLEND" === c2 ? (a2.transparent = true, a2.depthWrite = false) : (a2.transparent = false, "MASK" === c2 && (a2.alphaTest = void 0 !== s2.alphaCutoff ? s2.alphaCutoff : 0.5)), void 0 !== s2.normalTexture && o2 !== Qt.ObjectConstructors.MeshBasicMaterial && (l2.push(t2.assignTexture(a2, "normalMap", s2.normalTexture)), a2.normalScale = new n.FM8(1, 1), void 0 !== s2.normalTexture.scale)) {
        const e3 = s2.normalTexture.scale;
        a2.normalScale.set(e3, e3);
      }
      return void 0 !== s2.occlusionTexture && o2 !== Qt.ObjectConstructors.MeshBasicMaterial && (l2.push(t2.assignTexture(a2, "aoMap", s2.occlusionTexture)), void 0 !== s2.occlusionTexture.strength && (a2.aoMapIntensity = s2.occlusionTexture.strength)), void 0 !== s2.emissiveFactor && o2 !== Qt.ObjectConstructors.MeshBasicMaterial && (a2.emissive = new n.Ilk().fromArray(s2.emissiveFactor)), void 0 !== s2.emissiveTexture && o2 !== Qt.ObjectConstructors.MeshBasicMaterial && l2.push(t2.assignTexture(a2, "emissiveMap", s2.emissiveTexture, n.KI_)), Promise.all(l2).then(function() {
        const n2 = new o2(a2);
        return s2.extras && s2.extras.uuid && (n2.uuid = s2.extras.uuid), s2.name && (n2.name = s2.name), Tn(n2, s2), t2.associations.set(n2, { materials: e2 }), s2.extensions && Mn(i2, n2, s2), n2;
      });
    }
    createUniqueName(e2) {
      const t2 = n.iUV.sanitizeNodeName(e2 || "");
      return t2 in this.nodeNamesUsed ? t2 + "_" + ++this.nodeNamesUsed[t2] : (this.nodeNamesUsed[t2] = 0, t2);
    }
    loadGeometries(e2) {
      const t2 = this, r2 = this.extensions, i2 = this.primitiveCache;
      function s2(e3) {
        return r2[qt.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e3, t2).then(function(n2) {
          return On(n2, e3, t2);
        });
      }
      const o2 = [];
      for (let r3 = 0, a2 = e2.length; r3 < a2; r3++) {
        const a3 = e2[r3], l2 = In(a3), c2 = i2[l2];
        if (c2)
          o2.push(c2.promise);
        else {
          let e3;
          e3 = a3.extensions && a3.extensions[qt.KHR_DRACO_MESH_COMPRESSION] ? s2(a3) : On(new n.u9r(), a3, t2), i2[l2] = { primitive: a3, promise: e3 }, o2.push(e3);
        }
      }
      return Promise.all(o2);
    }
    loadMesh(e2) {
      const t2 = this, r2 = this.json, i2 = this.extensions, s2 = r2.meshes[e2], o2 = s2.primitives, a2 = [];
      for (let e3 = 0, t3 = o2.length; e3 < t3; e3++) {
        const t4 = void 0 === o2[e3].material ? (void 0 === (l2 = this.cache).DefaultMaterial && (l2.DefaultMaterial = new Qt.ObjectConstructors.MeshStandardMaterial({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: false, depthTest: true, side: n.Wl3 })), l2.DefaultMaterial) : this.getDependency("material", o2[e3].material);
        a2.push(t4);
      }
      var l2;
      return a2.push(t2.loadGeometries(o2)), Promise.all(a2).then(function(r3) {
        const a3 = r3.slice(0, r3.length - 1), l3 = r3[r3.length - 1], c2 = [];
        for (let r4 = 0, u3 = l3.length; r4 < u3; r4++) {
          const u4 = l3[r4], p2 = o2[r4];
          let d2;
          const h2 = a3[r4];
          if (p2.mode === yn.TRIANGLES || p2.mode === yn.TRIANGLE_STRIP || p2.mode === yn.TRIANGLE_FAN || void 0 === p2.mode)
            d2 = true === s2.isSkinnedMesh ? new n.TUv(u4, h2) : new n.Kj0(u4, h2), true === d2.isSkinnedMesh && d2.normalizeSkinWeights(), p2.mode === yn.TRIANGLE_STRIP ? d2.geometry = C(d2.geometry, n.UlW) : p2.mode === yn.TRIANGLE_FAN && (d2.geometry = C(d2.geometry, n.z$h));
          else if (p2.mode === yn.LINES)
            d2 = new n.ejS(u4, h2);
          else if (p2.mode === yn.LINE_STRIP)
            d2 = new n.x12(u4, h2);
          else if (p2.mode === yn.LINE_LOOP)
            d2 = new n.blk(u4, h2);
          else {
            if (p2.mode !== yn.POINTS)
              throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + p2.mode);
            d2 = new n.woe(u4, h2);
          }
          Object.keys(d2.geometry.morphAttributes).length > 0 && Pn(d2, s2), d2.name = t2.createUniqueName(s2.name || "mesh_" + e2), d2.geometry && s2.extras && s2.extras.isGeometryUserData ? (Tn(d2.geometry, s2), p2.extensions && Mn(i2, d2.geometry, p2)) : (Tn(d2, s2), p2.extensions && Mn(i2, d2, p2)), t2.assignFinalMaterial(d2), c2.push(d2);
        }
        s2.extensions && c2.forEach((e3) => Mn(i2, e3, s2));
        for (let n2 = 0, r4 = c2.length; n2 < r4; n2++)
          t2.associations.set(c2[n2], { meshes: e2, primitives: n2 });
        if (1 === c2.length)
          return s2.extensions && Mn(i2, c2[0], s2), c2[0];
        const u2 = new n.ZAu();
        s2.extensions && Mn(i2, u2, s2), t2.associations.set(u2, { meshes: e2 });
        for (let e3 = 0, t3 = c2.length; e3 < t3; e3++)
          u2.add(c2[e3]);
        return u2;
      });
    }
    loadCamera(e2) {
      let t2;
      const r2 = this.json.cameras[e2], i2 = r2[r2.type];
      if (i2)
        return "perspective" === r2.type ? t2 = new Qt.ObjectConstructors.PerspectiveCamera(n.M8C.radToDeg(i2.yfov), i2.aspectRatio || 1, i2.znear || 1, i2.zfar || 2e6) : "orthographic" === r2.type && (t2 = new Qt.ObjectConstructors.OrthographicCamera(-i2.xmag, i2.xmag, i2.ymag, -i2.ymag, i2.znear, i2.zfar)), r2.name && (t2.name = this.createUniqueName(r2.name)), Tn(t2, r2), Promise.resolve(t2);
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
    }
    loadSkin(e2) {
      const t2 = this.json.skins[e2], r2 = [];
      for (let e3 = 0, n2 = t2.joints.length; e3 < n2; e3++)
        r2.push(this._loadNodeShallow(t2.joints[e3]));
      return void 0 !== t2.inverseBindMatrices ? r2.push(this.getDependency("accessor", t2.inverseBindMatrices)) : r2.push(null), Promise.all(r2).then(function(e3) {
        const r3 = e3.pop(), i2 = e3, s2 = [], o2 = [];
        for (let e4 = 0, a2 = i2.length; e4 < a2; e4++) {
          const a3 = i2[e4];
          if (a3) {
            s2.push(a3);
            const t3 = new n.yGw();
            null !== r3 && t3.fromArray(r3.array, 16 * e4), o2.push(t3);
          } else
            console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t2.joints[e4]);
        }
        return new n.OdW(s2, o2);
      });
    }
    loadAnimation(e2) {
      const t2 = this.json.animations[e2], r2 = t2.name ? t2.name : "animation_" + e2, i2 = [], s2 = [], o2 = [], a2 = [], l2 = [];
      for (let e3 = 0, n2 = t2.channels.length; e3 < n2; e3++) {
        const n3 = t2.channels[e3], r3 = t2.samplers[n3.sampler], c2 = n3.target, u2 = c2.node, p2 = void 0 !== t2.parameters ? t2.parameters[r3.input] : r3.input, d2 = void 0 !== t2.parameters ? t2.parameters[r3.output] : r3.output;
        void 0 !== c2.node && (i2.push(this.getDependency("node", u2)), s2.push(this.getDependency("accessor", p2)), o2.push(this.getDependency("accessor", d2)), a2.push(r3), l2.push(c2));
      }
      return Promise.all([Promise.all(i2), Promise.all(s2), Promise.all(o2), Promise.all(a2), Promise.all(l2)]).then(function(e3) {
        const t3 = e3[0], i3 = e3[1], s3 = e3[2], o3 = e3[3], a3 = e3[4], l3 = [];
        for (let e4 = 0, r3 = t3.length; e4 < r3; e4++) {
          const r4 = t3[e4], c2 = i3[e4], u2 = s3[e4], p2 = o3[e4], d2 = a3[e4];
          if (void 0 === r4)
            continue;
          let h2;
          switch (r4.updateMatrix(), Cn[d2.path]) {
            case Cn.weights:
              h2 = n.dUE;
              break;
            case Cn.rotation:
              h2 = n.iLg;
              break;
            default:
              h2 = n.yC1;
          }
          const f2 = r4.name ? r4.name : r4.uuid, m2 = void 0 !== p2.interpolation ? Sn[p2.interpolation] : n.NMF, _2 = [];
          Cn[d2.path] === Cn.weights ? r4.traverse(function(e5) {
            e5.morphTargetInfluences && _2.push(e5.name ? e5.name : e5.uuid);
          }) : _2.push(f2);
          let g2 = u2.array;
          if (u2.normalized) {
            const e5 = kn(g2.constructor), t4 = new Float32Array(g2.length);
            for (let n2 = 0, r5 = g2.length; n2 < r5; n2++)
              t4[n2] = g2[n2] * e5;
            g2 = t4;
          }
          for (let e5 = 0, t4 = _2.length; e5 < t4; e5++) {
            const t5 = new h2(_2[e5] + "." + Cn[d2.path], c2.array, g2, m2);
            "CUBICSPLINE" === p2.interpolation && (t5.createInterpolant = function(e6) {
              return new (this instanceof n.iLg ? vn : _n)(this.times, this.values, this.getValueSize() / 3, e6);
            }, t5.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true), l3.push(t5);
          }
        }
        return new n.m7l(r2, void 0, l3);
      });
    }
    createNodeMesh(e2) {
      const t2 = this.json, n2 = this, r2 = t2.nodes[e2];
      return void 0 === r2.mesh ? null : n2.getDependency("mesh", r2.mesh).then(function(e3) {
        const t3 = n2._getNodeRef(n2.meshCache, r2.mesh, e3);
        return void 0 !== r2.weights && t3.traverse(function(e4) {
          if (e4.isMesh)
            for (let t4 = 0, n3 = r2.weights.length; t4 < n3; t4++)
              e4.morphTargetInfluences[t4] = r2.weights[t4];
        }), t3;
      });
    }
    loadNode(e2) {
      const t2 = this, n2 = this.json.nodes[e2], r2 = t2._loadNodeShallow(e2), i2 = [], s2 = n2.children || [];
      for (let e3 = 0, n3 = s2.length; e3 < n3; e3++)
        i2.push(t2.getDependency("node", s2[e3]));
      const o2 = void 0 === n2.skin ? Promise.resolve(null) : t2.getDependency("skin", n2.skin);
      return Promise.all([r2, Promise.all(i2), o2]).then(function(e3) {
        const t3 = e3[0], n3 = e3[1], r3 = e3[2];
        null !== r3 && t3.traverse(function(e4) {
          e4.isSkinnedMesh && e4.bind(r3, Dn);
        });
        for (let e4 = 0, r4 = n3.length; e4 < r4; e4++)
          t3.add(n3[e4]);
        return t3;
      });
    }
    _loadNodeShallow(e2) {
      const t2 = this.json, r2 = this.extensions, i2 = this;
      if (void 0 !== this.nodeCache[e2])
        return this.nodeCache[e2];
      const s2 = t2.nodes[e2], o2 = s2.name ? i2.createUniqueName(s2.name) : "", a2 = [], l2 = i2._invokeOne(function(t3) {
        return t3.createNodeMesh && t3.createNodeMesh(e2);
      });
      return l2 && a2.push(l2), void 0 !== s2.camera && a2.push(i2.getDependency("camera", s2.camera).then(function(e3) {
        return i2._getNodeRef(i2.cameraCache, s2.camera, e3);
      })), i2._invokeAll(function(t3) {
        return t3.createNodeAttachment && t3.createNodeAttachment(e2);
      }).forEach(function(e3) {
        a2.push(e3);
      }), this.nodeCache[e2] = Promise.all(a2).then(function(t3) {
        let a3;
        if (a3 = true === s2.isBone ? new n.N$j() : t3.length > 1 ? new n.ZAu() : 1 === t3.length ? t3[0] : new n.Tme(), a3 !== t3[0])
          for (let e3 = 0, n2 = t3.length; e3 < n2; e3++)
            a3.add(t3[e3]);
        if (s2.name && (a3.userData.name = s2.name, a3.name = o2), Tn(a3, s2), s2.extensions && Mn(r2, a3, s2), void 0 !== s2.matrix) {
          const e3 = new n.yGw();
          e3.fromArray(s2.matrix), a3.applyMatrix4(e3);
        } else
          void 0 !== s2.translation && a3.position.fromArray(s2.translation), void 0 !== s2.rotation && a3.quaternion.fromArray(s2.rotation), void 0 !== s2.scale && a3.scale.fromArray(s2.scale);
        return i2.associations.has(a3) || i2.associations.set(a3, {}), i2.associations.get(a3).nodes = e2, a3;
      }), this.nodeCache[e2];
    }
    loadScene(e2) {
      const t2 = this.extensions, r2 = this.json.scenes[e2], i2 = this, s2 = new n.ZAu();
      r2.name && (s2.name = i2.createUniqueName(r2.name)), Tn(s2, r2), r2.extensions && Mn(t2, s2, r2);
      const o2 = r2.nodes || [], a2 = [];
      for (let e3 = 0, t3 = o2.length; e3 < t3; e3++)
        a2.push(i2.getDependency("node", o2[e3]));
      return Promise.all(a2).then(function(e3) {
        for (let t3 = 0, n2 = e3.length; t3 < n2; t3++)
          s2.add(e3[t3]);
        return i2.associations = ((e4) => {
          const t3 = /* @__PURE__ */ new Map();
          for (const [e5, r3] of i2.associations)
            (e5 instanceof n.F5T || e5 instanceof n.xEZ) && t3.set(e5, r3);
          return e4.traverse((e5) => {
            const n2 = i2.associations.get(e5);
            null != n2 && t3.set(e5, n2);
          }), t3;
        })(s2), s2;
      });
    }
  }
  function On(e2, t2, r2) {
    const i2 = t2.attributes, s2 = [];
    function o2(t3, n2) {
      return r2.getDependency("accessor", t3).then(function(t4) {
        e2.setAttribute(n2, t4);
      });
    }
    for (const t3 in i2) {
      const n2 = En[t3] || t3.toLowerCase();
      n2 in e2.attributes || s2.push(o2(i2[t3], n2));
    }
    if (void 0 !== t2.indices && !e2.index) {
      const n2 = r2.getDependency("accessor", t2.indices).then(function(t3) {
        e2.setIndex(t3);
      });
      s2.push(n2);
    }
    return Tn(e2, t2), function(e3, t3, r3) {
      const i3 = t3.attributes, s3 = new n.ZzF();
      if (void 0 === i3.POSITION)
        return;
      {
        const e4 = r3.json.accessors[i3.POSITION], t4 = e4.min, o4 = e4.max;
        if (void 0 === t4 || void 0 === o4)
          return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        if (s3.set(new n.Pa4(t4[0], t4[1], t4[2]), new n.Pa4(o4[0], o4[1], o4[2])), e4.normalized) {
          const t5 = kn(bn[e4.componentType]);
          s3.min.multiplyScalar(t5), s3.max.multiplyScalar(t5);
        }
      }
      const o3 = t3.targets;
      if (void 0 !== o3) {
        const e4 = new n.Pa4(), t4 = new n.Pa4();
        for (let n2 = 0, i4 = o3.length; n2 < i4; n2++) {
          const i5 = o3[n2];
          if (void 0 !== i5.POSITION) {
            const n3 = r3.json.accessors[i5.POSITION], s4 = n3.min, o4 = n3.max;
            if (void 0 !== s4 && void 0 !== o4) {
              if (t4.setX(Math.max(Math.abs(s4[0]), Math.abs(o4[0]))), t4.setY(Math.max(Math.abs(s4[1]), Math.abs(o4[1]))), t4.setZ(Math.max(Math.abs(s4[2]), Math.abs(o4[2]))), n3.normalized) {
                const e5 = kn(bn[n3.componentType]);
                t4.multiplyScalar(e5);
              }
              e4.max(t4);
            } else
              console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
          }
        }
        s3.expandByVector(e4);
      }
      e3.boundingBox = s3;
      const a2 = new n.aLr();
      s3.getCenter(a2.center), a2.radius = s3.min.distanceTo(s3.max) / 2, e3.boundingSphere = a2;
    }(e2, t2, r2), Promise.all(s2).then(function() {
      return void 0 !== t2.targets ? function(e3, t3, n2) {
        let r3 = false, i3 = false, s3 = false;
        for (let e4 = 0, n3 = t3.length; e4 < n3; e4++) {
          const n4 = t3[e4];
          if (void 0 !== n4.POSITION && (r3 = true), void 0 !== n4.NORMAL && (i3 = true), void 0 !== n4.COLOR_0 && (s3 = true), r3 && i3 && s3)
            break;
        }
        if (!r3 && !i3 && !s3)
          return Promise.resolve(e3);
        const o3 = [], a2 = [], l2 = [];
        for (let c2 = 0, u2 = t3.length; c2 < u2; c2++) {
          const u3 = t3[c2];
          if (r3) {
            const t4 = void 0 !== u3.POSITION ? n2.getDependency("accessor", u3.POSITION) : e3.attributes.position;
            o3.push(t4);
          }
          if (i3) {
            const t4 = void 0 !== u3.NORMAL ? n2.getDependency("accessor", u3.NORMAL) : e3.attributes.normal;
            a2.push(t4);
          }
          if (s3) {
            const t4 = void 0 !== u3.COLOR_0 ? n2.getDependency("accessor", u3.COLOR_0) : e3.attributes.color;
            l2.push(t4);
          }
        }
        return Promise.all([Promise.all(o3), Promise.all(a2), Promise.all(l2)]).then(function(t4) {
          const n3 = t4[0], o4 = t4[1], a3 = t4[2];
          return r3 && (e3.morphAttributes.position = n3), i3 && (e3.morphAttributes.normal = o4), s3 && (e3.morphAttributes.color = a3), e3.morphTargetsRelative = true, e3;
        });
      }(e2, t2.targets, r2) : e2;
    });
  }
  class Ln extends Qt {
    constructor(e2) {
      super(e2), this.isGLTFLoader2 = true, this.preparsers = [], this.preparsers.push(Un);
    }
    async preparse(e2, t2) {
      for (const n2 of this.preparsers)
        e2 = await n2.process(e2, t2);
      return e2;
    }
    parse(e2, t2, n2, r2, i2) {
      this.preparse.call(this, e2, i2 || t2).then((e3) => e3 ? super.parse(e3, t2, n2, r2) : r2 && r2(new ErrorEvent("no data"))).catch((e3) => {
        console.error(e3), r2 && r2(null != e3 ? e3 : new ErrorEvent("unknown error"));
      });
    }
    transform(e2, t2) {
      const n2 = e2 ? e2.scene || (e2.scenes && e2.scenes.length > 0 ? e2.scenes[0] : void 0) : void 0;
      return n2 && e2.animations.length > 0 && (n2.animations = e2.animations), null == n2 || n2.traverse((e3) => {
        e3.userData.gltfUUID && (e3.uuid = e3.userData.gltfUUID, delete e3.userData.gltfUUID);
      }), n2;
    }
    register(e2) {
      return super.register(e2);
    }
  }
  const Un = { key: (e2, t2, n2) => e2.key || window && window.prompt && window.prompt("GLTFEncryption: Please enter the password/key for the model: " + n2) || "", async process(e2, n2) {
    var r2;
    if ("string" == typeof e2)
      return e2;
    if (!new TextDecoder().decode(new Uint8Array(e2, 0, 100)).includes("WebGiGLBWrapper"))
      return e2;
    const i2 = new dn(e2), s2 = JSON.parse(i2.content || "{}");
    let o2 = i2.body || e2;
    const a2 = null === (r2 = s2.asset) || void 0 === r2 ? void 0 : r2.encryption;
    if (!a2)
      return o2;
    const l2 = a2.type, c2 = a2.version;
    if ("aesgcm" === l2 && 1 === c2) {
      const e3 = await (0, t.getOrCall)(this.key, a2, s2, n2) || "";
      try {
        o2 = (await (0, t.aesGcmDecrypt)(new Uint8Array(o2), e3)).buffer;
      } catch (e4) {
        throw new ErrorEvent("decryption error");
      }
    }
    return o2;
  } };
  class Fn extends n.hH6 {
    constructor(e2) {
      super(e2), this.type = n.cLu;
    }
    async loadAsync(e2, t2) {
      const r2 = await this.parseAsync(e2, t2, false), i2 = new n.IEO(r2.data, r2.width, r2.height, n.wk1, this.type);
      return i2.needsUpdate = true, i2.flipY = true, i2.colorSpace = n.KI_, i2.minFilter = n.wem, i2.magFilter = n.wem, i2.source.data.complete = true, i2;
    }
    async parseAsync(e2, r2, i2 = false) {
      let s2 = false;
      if (!e2.startsWith("data:") && !e2.startsWith("blob:")) {
        this.responseType = "blob";
        const t2 = await super.loadAsync(e2, r2);
        e2 = URL.createObjectURL(t2), s2 = true;
      }
      const o2 = await (0, t.imageUrlToImageData)(e2);
      s2 && URL.revokeObjectURL(e2);
      let a2 = Uint8Array;
      this.type === n.cLu ? a2 = Uint16Array : this.type === n.VzW && (a2 = Uint32Array);
      const l2 = function(e3, t2 = 3, r3 = Uint16Array, i3 = false) {
        let s3;
        const o3 = e3.byteLength >> 2, a3 = new r3(o3 * t2);
        for (let r4 = 0; r4 < o3; r4++)
          s3 = Math.pow(2, e3[4 * r4 + 3] - 136), i3 ? (a3[r4 * t2] = Math.min(e3[4 * r4] * s3, 65504), a3[r4 * t2 + 1] = Math.min(e3[4 * r4 + 1] * s3, 65504), a3[r4 * t2 + 2] = Math.min(e3[4 * r4 + 2] * s3, 65504)) : (a3[r4 * t2] = n.A5E.toHalfFloat(Math.min(e3[4 * r4] * s3, 65504)), a3[r4 * t2 + 1] = n.A5E.toHalfFloat(Math.min(e3[4 * r4 + 1] * s3, 65504)), a3[r4 * t2 + 2] = n.A5E.toHalfFloat(Math.min(e3[4 * r4 + 2] * s3, 65504))), 4 === t2 && (a3[r4 * t2 + 3] = n.A5E.toHalfFloat(1));
        return a3;
      }(o2.data, 4, a2, i2);
      return { data: l2, width: o2.width, height: o2.height };
    }
    setDataType(e2) {
      return this.type = e2, this;
    }
  }
  class Nn extends n.Gql {
    constructor(e2) {
      super(e2), this._imageLoader = new n.S3k(e2);
    }
    static async LoadRootPathTextures(e2, t2, r2, i2 = true) {
      var s2;
      const o2 = [];
      for (const a2 of Array.isArray(e2) ? e2 : Object.values(null != e2 ? e2 : {})) {
        const e3 = null === (s2 = null == a2 ? void 0 : a2.userData) || void 0 === s2 ? void 0 : s2.rootPath, l2 = i2 && a2.image && t2[a2.image];
        if (!e3)
          continue;
        const c2 = r2.importPath(e3, { processImported: false }).then((e4) => {
          const r3 = null == e4 ? void 0 : e4[0], i3 = null == r3 ? void 0 : r3.source;
          if (!r3 || !i3)
            return null;
          const s3 = new n.Hw6(i3.data);
          return a2.image && (s3.uuid = a2.image), a2.image = s3.uuid, l2 || (t2[s3.uuid] = s3), r3.dispose(), s3;
        }).catch((e4) => (console.error(e4), delete a2.userData.rootPath, null));
        l2 ? a2.rootPathPromise = c2 : o2.push(c2);
      }
      await Promise.allSettled(o2);
    }
    parseTextures2(e2, t2, r2) {
      var i2, s2;
      for (const s3 of e2) {
        const e3 = null === (i2 = null == s3 ? void 0 : s3.userData) || void 0 === i2 ? void 0 : i2.rootPath;
        if (e3 && (!s3.image || !t2[s3.image])) {
          const i3 = new n.Hw6(this._imageLoader.load(e3, r2));
          if (!i3)
            continue;
          s3.image && (i3.uuid = s3.image), t2[i3.uuid] = i3, s3.image = i3.uuid;
        }
        s3.userData = ce(s3.userData, void 0, false, { images: t2 });
      }
      const o2 = super.parseTextures(e2, t2), a2 = { ...o2 };
      for (const t3 of e2)
        null === (s2 = t3.rootPathPromise) || void 0 === s2 || s2.then((e3) => {
          if (!e3)
            return;
          const n2 = a2[t3.uuid];
          n2.dispose(), n2.source = e3, n2.source.needsUpdate = true, n2.needsUpdate = true;
        });
      return o2;
    }
    parseMaterials2(e2, t2, n2) {
      const r2 = {};
      return e2.forEach((e3) => {
        if (!e3)
          return;
        const i2 = { ...e3 }, s2 = Object.keys(i2);
        for (const e4 of s2)
          if ("map" === e4 || e4.endsWith("Map")) {
            const n3 = i2[e4];
            "string" == typeof n3 && (t2[n3] ? i2[e4] = t2[n3] : (console.warn(`Texture ${n3} not found`), delete i2[e4]));
          }
        i2.userData && (i2.userData = ce(i2.userData, void 0, false, { textures: t2 }), i2.userData.cloneId && i2.userData.uuid !== e3.uuid && (i2.userData.uuid = e3.uuid));
        const o2 = n2.generateFromTemplateType(i2.type, i2);
        o2 && (r2[e3.uuid] = o2);
      }), r2;
    }
  }
  const jn = "WEBGI_viewer";
  function zn(e2) {
    return new Ft(Ln, ["gltf", "glb", "data:model/gltf"], true, (t2, n2) => {
      if (!t2)
        return t2;
      const r2 = t2, i2 = new Nn(n2.loadingManager);
      return r2.register(Wn(i2, e2)), r2.register(Qn(i2)), r2.register(qn(i2)), r2.register((e3) => new $n(e3)), r2.register((e3) => new er(e3)), r2.register((e3) => new tr(e3)), r2.register((e3) => new nr(e3)), r2.register((t3) => {
        var s2, o2, a2, l2, c2, u2, p2, d2, h2;
        const f2 = t3.getDependency;
        t3.getDependency = async (e3, n3) => {
          const r3 = await f2.call(t3, e3, n3);
          if (r3 && r3.userData) {
            const e4 = r3.userData.gltfExtensions;
            delete r3.userData.gltfExtensions, r3.userData = ce(r3.userData, {}, false, {}), r3.userData.gltfExtensions = e4;
          }
          return r3;
        };
        const m2 = ke() + ".drc", _2 = ke() + ".ktx2", g2 = null === (a2 = null === (o2 = null === (s2 = t3.json) || void 0 === s2 ? void 0 : s2.extensionsRequired) || void 0 === o2 ? void 0 : o2.includes) || void 0 === a2 ? void 0 : a2.call(o2, "KHR_draco_mesh_compression");
        if (g2) {
          const e3 = n2.registerFile(m2);
          e3 && r2.setDRACOLoader(e3);
        }
        (null === (u2 = null === (c2 = null === (l2 = t3.json) || void 0 === l2 ? void 0 : l2.extensionsUsed) || void 0 === c2 ? void 0 : c2.includes) || void 0 === u2 ? void 0 : u2.call(c2, "EXT_meshopt_compression")) && (window.MeshoptDecoder ? (r2.setMeshoptDecoder(window.MeshoptDecoder), t3.options.meshoptDecoder = window.MeshoptDecoder) : console.error("Add GLTFMeshOptPlugin to viewer to enable EXT_meshopt_compression decode"));
        const v2 = null === (h2 = null === (d2 = null === (p2 = t3.json) || void 0 === p2 ? void 0 : p2.extensionsUsed) || void 0 === d2 ? void 0 : d2.includes) || void 0 === h2 ? void 0 : h2.call(d2, "KHR_texture_basisu");
        if (v2) {
          const e3 = n2.registerFile(_2);
          e3 && (r2.setKTX2Loader(e3), t3.options.ktx2Loader = e3);
        }
        return { name: "GLTF2_HELPER_PLUGIN", afterRoot: async (r3) => {
          g2 && n2.unregisterFile(m2), v2 && n2.unregisterFile(_2);
          const s3 = await Xn(t3, e2, i2);
          r3.scene && (r3.scene.__importedViewerConfig = s3);
        } };
      }), r2;
    });
  }
  const Gn = "WEBGI_light_extras", Vn = "WEBGI_object3d_extras", Hn = "WEBGI_material_extras", Qn = (e2) => (e3) => ({ name: "__" + Vn, afterRoot: async (e4) => {
    (e4.scenes || (e4.scene ? [e4.scene] : [])).forEach((e5) => {
      e5.traverse((e6) => {
        var t2, n2;
        if (!e6 || !e6.isObject3D)
          return;
        const r2 = null === (n2 = null === (t2 = e6.userData) || void 0 === t2 ? void 0 : t2.gltfExtensions) || void 0 === n2 ? void 0 : n2[Vn];
        if (!r2)
          return void (e6.isLight && !e6.isAmbientLight && (e6.castShadow = true));
        const i2 = void 0 !== r2.castShadow || void 0 !== r2.receiveShadow;
        void 0 !== r2.castShadow && (e6.castShadow = r2.castShadow), void 0 !== r2.receiveShadow && (e6.receiveShadow = r2.receiveShadow), void 0 !== r2.visible && (e6.visible = r2.visible), void 0 !== r2.frustumCulled && (e6.frustumCulled = r2.frustumCulled), void 0 !== r2.renderOrder && (e6.renderOrder = r2.renderOrder), void 0 !== r2.layers && (e6.layers.mask = r2.layers), i2 && (e6.userData.__keepShadowDef = true), delete e6.userData.gltfExtensions[Vn];
      });
    });
  } }), Wn = (e2, t2) => (e3) => ({ name: "__" + Hn, afterRoot: async (e4) => {
    var n2, r2, i2;
    const s2 = e4.scenes || (e4.scene ? [e4.scene] : []);
    for (const e5 of s2) {
      const s3 = null === (r2 = null === (n2 = e5.userData) || void 0 === n2 ? void 0 : n2.gltfExtensions) || void 0 === r2 ? void 0 : r2[Hn], o2 = s3 && await (null === (i2 = t2.getPlugin(Ls)) || void 0 === i2 ? void 0 : i2.importConfigResources(s3.resources || {})) || {};
      e5.traverse((e6) => {
        var n3, r3;
        const i3 = null == e6 ? void 0 : e6.material;
        if (!(null == i3 ? void 0 : i3.isMaterial))
          return;
        const s4 = null === (r3 = null === (n3 = i3.userData) || void 0 === n3 ? void 0 : n3.gltfExtensions) || void 0 === r3 ? void 0 : r3[Hn];
        s4 && (void 0 !== s4.emissiveIntensity && (i3.emissiveIntensity = s4.emissiveIntensity), void 0 !== s4.fog && (i3.fog = s4.fog), void 0 !== s4.flatShading && (i3.flatShading = s4.flatShading), void 0 !== s4.blending && (i3.blending = s4.blending), void 0 !== s4.side && (i3.side = s4.side), void 0 !== s4.shadowSide && (i3.shadowSide = s4.shadowSide), void 0 !== s4.depthFunc && (i3.depthFunc = s4.depthFunc), void 0 !== s4.depthTest && (i3.depthTest = s4.depthTest), void 0 !== s4.depthWrite && (i3.depthWrite = s4.depthWrite), void 0 !== s4.colorWrite && (i3.colorWrite = s4.colorWrite), void 0 !== s4.vertexColors && (i3.vertexColors = s4.vertexColors), void 0 !== s4.alphaTest && (i3.alphaTest = s4.alphaTest), void 0 !== s4.envMapIntensity && (i3.envMapIntensity = s4.envMapIntensity), void 0 !== s4.wireframe && (i3.wireframe = s4.wireframe), void 0 !== s4.wireframeLinewidth && (i3.wireframeLinewidth = s4.wireframeLinewidth), void 0 !== s4.wireframeLinecap && (i3.wireframeLinecap = s4.wireframeLinecap), void 0 !== s4.wireframeLinejoin && (i3.wireframeLinejoin = s4.wireframeLinejoin), void 0 !== s4.rotation && (i3.rotation = s4.rotation), void 0 !== s4.polygonOffset && (i3.polygonOffset = s4.polygonOffset), void 0 !== s4.polygonOffsetFactor && (i3.polygonOffsetFactor = s4.polygonOffsetFactor), void 0 !== s4.polygonOffsetUnits && (i3.polygonOffsetUnits = s4.polygonOffsetUnits), void 0 !== s4.dithering && (i3.dithering = s4.dithering), void 0 !== s4.alphaToCoverage && (i3.alphaToCoverage = s4.alphaToCoverage), void 0 !== s4.premultipliedAlpha && (i3.premultipliedAlpha = s4.premultipliedAlpha), void 0 !== s4.toneMapped && (i3.toneMapped = s4.toneMapped), void 0 !== s4.normalScale && void 0 !== i3.normalScale && (Array.isArray(s4.normalScale) ? i3.normalScale.fromArray(s4.normalScale) : "number" == typeof s4.normalScale ? i3.normalScale.set(s4.normalScale, s4.normalScale) : t2.console.warn("normalScale is not an array or number", s4.normalScale)), void 0 !== s4.reflectivity && (i3.reflectivity = s4.reflectivity), Object.entries(s4).forEach(([e7, t3]) => {
          e7.startsWith("_") || t3 && t3.resource && "string" == typeof t3.resource && (i3[e7] = ce(t3, i3[e7], false, o2));
        }), delete i3.userData.gltfExtensions[Hn]);
      }), s3 && delete e5.userData.gltfExtensions[Hn];
    }
  } }), qn = (e2) => (t2) => ({ name: "__" + Gn, afterRoot: async (t3) => {
    (t3.scenes || (t3.scene ? [t3.scene] : [])).forEach((t4) => {
      t4.traverse((t5) => {
        var n2, r2;
        if (!t5.isLight)
          return;
        const i2 = null === (r2 = null === (n2 = t5.userData) || void 0 === n2 ? void 0 : n2.gltfExtensions) || void 0 === r2 ? void 0 : r2[Gn];
        i2 && (!t5.shadow && i2.shadow && console.error("Light has no shadow, cannot import", t5, i2), i2.shadow && t5.shadow && (void 0 !== i2.shadow.bias && (t5.shadow.bias = i2.shadow.bias), void 0 !== i2.shadow.normalBias && (t5.shadow.normalBias = i2.shadow.normalBias), void 0 !== i2.shadow.radius && (t5.shadow.radius = i2.shadow.radius), void 0 !== i2.shadow.mapSize && t5.shadow.mapSize.fromArray(i2.shadow.mapSize), void 0 !== i2.shadow.camera && (t5.shadow.camera = e2.parseObject(i2.shadow.camera))), delete t5.userData.gltfExtensions[Gn]);
      });
    });
  } });
  async function Xn(e2, t2, n2, r2) {
    var i2, s2, o2;
    if (!r2) {
      const i3 = e2.json.scenes || [];
      if (1 !== i3.length) {
        for (const r3 of i3)
          await Xn(e2, t2, n2, r3);
        return;
      }
      r2 = i3[0];
    }
    const a2 = null === (i2 = r2.extensions) || void 0 === i2 ? void 0 : i2[jn];
    if (!a2)
      return;
    const l2 = [];
    Object.values(a2.resources).forEach((e3) => {
      Object.values(e3).forEach((e4) => {
        e4.url && ("Uint16Array" === e4.url.type && e4.url.data && l2.push(e4.url), "Uint8Array" === e4.url.type && e4.url.data && l2.push(e4.url));
      });
    });
    for (const t3 of l2) {
      const n3 = t3.data.image, r3 = e2.json.images[n3], i3 = await e2.getDependency("bufferView", r3.bufferView);
      if (r3.mimeType.startsWith("image/") && "Uint16Array" === t3.type && "rgbe" === t3.encoding) {
        const e3 = new Blob([i3]);
        let n4 = URL.createObjectURL(e3);
        (t3.encodingVersion || 1) < 2 && (n4 = "data:image/png;base64," + btoa(await e3.text())), t3.data = (await new Fn().parseAsync(n4, void 0, true)).data, URL.revokeObjectURL(n4), delete t3.encoding, delete t3.encodingVersion;
      } else
        t3.data = i3;
    }
    const c2 = { textures: {}, materials: {} }, u2 = a2.resources;
    if (u2.textures && e2.json.textures)
      for (const [t3, n3] of [...Object.entries(u2.textures)]) {
        if (n3.uuid || !t3)
          continue;
        delete u2.textures[t3];
        const r3 = e2.json.textures.findIndex((n4) => {
          var r4, i3, s3, o3, a3, l3, c3;
          return (null === (r4 = n4.extras) || void 0 === r4 ? void 0 : r4.uuid) === t3 || (null === (o3 = null === (s3 = null === (i3 = e2.json.samplers) || void 0 === i3 ? void 0 : i3[n4.sampler]) || void 0 === s3 ? void 0 : s3.extras) || void 0 === o3 ? void 0 : o3.uuid) === t3 || (null === (c3 = null === (l3 = null === (a3 = e2.json.images) || void 0 === a3 ? void 0 : a3[n4.source]) || void 0 === l3 ? void 0 : l3.extras) || void 0 === c3 ? void 0 : c3.t_uuid) === t3;
        });
        r3 >= 0 && (c2.textures[t3] = await e2.getDependency("texture", r3));
      }
    if (u2.materials && e2.json.materials)
      for (const [n3, r3] of [...Object.entries(u2.materials)]) {
        if (r3.uuid || !n3)
          continue;
        delete u2.materials[n3];
        const i3 = e2.json.materials.findIndex((e3) => {
          var t3;
          return (null === (t3 = e3.extras) || void 0 === t3 ? void 0 : t3.uuid) === n3;
        });
        i3 >= 0 && (c2.materials[n3] = await e2.getDependency("material", i3), c2.materials[n3] = null === (o2 = null === (s2 = t2.getPlugin(Ls)) || void 0 === s2 ? void 0 : s2.materials) || void 0 === o2 ? void 0 : o2.processMaterial(c2.materials[n3], {}));
      }
    return a2.resources = await t2.getPlugin(Ls).importConfigResources(u2 || {}, n2, c2), a2;
  }
  const Yn = "WEBGI_materials_bumpmap", Kn = "WEBGI_materials_displacementmap", Jn = "WEBGI_materials_alphamap", Zn = "WEBGI_materials_lightmap";
  class $n {
    constructor(e2) {
      this.parser = e2, this.name = Yn;
    }
    async extendMaterialParams(e2, t2) {
      const n2 = this.parser, r2 = n2.json.materials[e2];
      if (!r2.extensions || !r2.extensions[this.name])
        return Promise.resolve();
      const i2 = [], s2 = r2.extensions[this.name];
      return void 0 !== s2.bumpScale && (t2.bumpScale = s2.bumpScale), void 0 !== s2.bumpTexture && i2.push(n2.assignTexture(t2, "bumpMap", s2.bumpTexture)), Promise.all(i2);
    }
  }
  class er {
    constructor(e2) {
      this.parser = e2, this.name = Kn;
    }
    async extendMaterialParams(e2, t2) {
      const n2 = this.parser, r2 = n2.json.materials[e2];
      if (!r2.extensions || !r2.extensions[this.name])
        return Promise.resolve();
      const i2 = [], s2 = r2.extensions[this.name];
      return void 0 !== s2.displacementScale && (t2.displacementScale = s2.displacementScale), void 0 !== s2.displacementBias && (t2.displacementBias = s2.displacementBias), void 0 !== s2.displacementTexture && i2.push(n2.assignTexture(t2, "displacementMap", s2.displacementTexture)), Promise.all(i2);
    }
  }
  class tr {
    constructor(e2) {
      this.parser = e2, this.name = Zn;
    }
    async extendMaterialParams(e2, t2) {
      const n2 = this.parser, r2 = n2.json.materials[e2];
      if (!r2.extensions || !r2.extensions[this.name])
        return Promise.resolve();
      const i2 = [], s2 = r2.extensions[this.name];
      return void 0 !== s2.lightMapIntensity && (t2.lightMapIntensity = s2.lightMapIntensity), void 0 !== s2.lightMapTexture && i2.push(n2.assignTexture(t2, "lightMap", s2.lightMapTexture)), Promise.all(i2);
    }
  }
  class nr {
    constructor(e2) {
      this.parser = e2, this.name = Jn;
    }
    async extendMaterialParams(e2, t2) {
      const n2 = this.parser, r2 = n2.json.materials[e2];
      if (!r2.extensions || !r2.extensions[this.name])
        return Promise.resolve();
      const i2 = [], s2 = r2.extensions[this.name];
      return void 0 !== s2.alphaTexture && i2.push(n2.assignTexture(t2, "alphaMap", s2.alphaTexture)), Promise.all(i2);
    }
  }
  var rr = __webpackgi_require__2(23);
  function ir() {
    return new Ft(rr.Q, ["drc"], true);
  }
  class sr extends n.Ox3 {
    get lightObject() {
      return this;
    }
    get modelObject() {
      return this;
    }
    constructor(e2, t2) {
      super(), this.assetType = "light", this.isDirectionalLight2 = true, this.color = new n.Ilk(e2), this.intensity = t2 || 1, this.target.position.set(0, 0, -1), this.add(this.target);
    }
    copy(e2, t2) {
      const n2 = this.target, r2 = e2.userData;
      return e2.userData = {}, super.copy(e2, t2), Ee(this.userData, r2), n2.position.copy(this.target.position), n2.updateMatrixWorld(), this.target = n2, this;
    }
    get uiConfig() {
      return this._uiConfig ? this._uiConfig : this._uiConfig = { type: "folder", label: "Directional Light", children: [{ type: "checkbox", label: "Enabled", property: [this, "visible"] }, { type: "color", label: "Color", property: [this, "color"] }, { type: "slider", label: "Intensity", bounds: [0, 20], property: [this, "intensity"] }, { type: "vec3", label: "Rotation", property: [this, "rotation"] }, { type: "vec3", label: "Position", property: [this, "position"] }, { type: "checkbox", label: "Shadow Enabled", property: [this, "castShadow"] }, { type: "vec2", label: "Shadow Map Size", property: [null == this ? void 0 : this.shadow, "mapSize"], onChange: () => {
        var e2, t2;
        null === (e2 = this.shadow.map) || void 0 === e2 || e2.dispose(), null === (t2 = this.shadow.mapPass) || void 0 === t2 || t2.dispose(), this.shadow.map = null, this.shadow.mapPass = null;
      } }, { type: "slider", bounds: [-1e-3, 1e-3], stepSize: 2e-5, label: "Shadow Bias", property: [null == this ? void 0 : this.shadow, "bias"], onChange: this.setDirty }, { type: "slider", bounds: [-0.1, 0.1], stepSize: 5e-3, label: "Shadow Normal Bias", property: [null == this ? void 0 : this.shadow, "normalBias"], onChange: this.setDirty }, { type: "slider", bounds: [0, 5], label: "Shadow radius", property: [null == this ? void 0 : this.shadow, "radius"], onChange: this.setDirty }, { type: "slider", bounds: [0.1, 50], label: "Shadow frustum", getValue: () => 2 * this.shadow.camera.right, setValue: (e2) => {
        this.shadow.camera.left = -e2 / 2, this.shadow.camera.right = e2 / 2, this.shadow.camera.top = e2 / 2, this.shadow.camera.bottom = -e2 / 2;
      }, onChange: this.setDirty }] };
    }
    toJSON(e2) {
      const { userData: t2, children: n2 } = this;
      this.userData = {}, this.children = [];
      const r2 = super.toJSON(e2);
      return r2.userData = le(Ee({}, t2), false), this.userData = {}, this.children = n2, r2.type = "DirectionalLight2", r2.target = this.target.position.toArray(), Object.assign(r2, le(this, true, e2));
    }
    fromJSON(e2, t2) {
      if ("DirectionalLight2" !== e2.type)
        return null;
      const n2 = e2.target, r2 = e2.object;
      return e2.target && (this.target.position.fromArray(e2.target), this.target.updateMatrixWorld(), delete e2.target), e2.object && delete e2.object, ce(e2, this, true, t2), n2 && (e2.target = n2), r2 && (void 0 !== r2.color && this.color.set(r2.color), void 0 !== r2.intensity && (this.intensity = r2.intensity), e2.object = r2), this;
    }
  }
  class or extends n.PMe {
    get lightObject() {
      return this;
    }
    get modelObject() {
      return this;
    }
    constructor(e2, t2, n2, r2, i2, s2) {
      super(e2, t2, n2, r2, i2, s2), this.assetType = "light", this.target.position.set(0, 0, -1), this.add(this.target);
    }
    copy(e2, t2) {
      const n2 = this.target, r2 = e2.userData;
      return e2.userData = {}, super.copy(e2, t2), Ee(this.userData, r2), n2.position.copy(this.target.position), n2.updateMatrixWorld(), this.target = n2, this;
    }
    get uiConfig() {
      return this._uiConfig ? this._uiConfig : this._uiConfig = { type: "folder", label: "Spot Light", children: [{ type: "checkbox", label: "Enabled", property: [this, "visible"] }, { type: "color", label: "Color", property: [this, "color"] }, { type: "slider", label: "Intensity", bounds: [0, 30], property: [this, "intensity"] }, { type: "slider", bounds: [0, 2], property: [this, "angle"] }, { type: "slider", bounds: [0, 0.9999], property: [this, "penumbra"] }, { type: "vec3", label: "Rotation", property: [this, "rotation"] }, { type: "vec3", label: "Position", property: [this, "position"] }, { type: "checkbox", label: "Shadow Enabled", property: [this, "castShadow"] }, { type: "vec2", label: "Shadow Map Size", property: [null == this ? void 0 : this.shadow, "mapSize"], onChange: () => {
        var e2, t2;
        null === (e2 = this.shadow.map) || void 0 === e2 || e2.dispose(), null === (t2 = this.shadow.mapPass) || void 0 === t2 || t2.dispose(), this.shadow.map = null, this.shadow.mapPass = null;
      } }, { type: "slider", bounds: [-1e-3, 1e-3], stepSize: 2e-5, label: "Shadow Bias", property: [null == this ? void 0 : this.shadow, "bias"], onChange: this.setDirty }, { type: "slider", bounds: [0, 5], label: "Shadow radius", property: [null == this ? void 0 : this.shadow, "radius"], onChange: this.setDirty }] };
    }
    toJSON(e2) {
      const { userData: t2, children: n2 } = this;
      this.userData = {}, this.children = [];
      const r2 = super.toJSON(e2);
      return r2.userData = le(Ee({}, t2), false), this.userData = {}, this.children = n2, r2.type = "SpotLight2", r2.target = this.target.position.toArray(), Object.assign(r2, le(this, true, e2));
    }
    fromJSON(e2, t2) {
      return "SpotLight2" !== e2.type ? null : (e2.target && (this.target.position.fromArray(e2.target), this.target.updateMatrixWorld()), e2.object ? (void 0 !== e2.object.color && this.color.set(e2.object.color), void 0 !== e2.object.intensity && (this.intensity = e2.object.intensity), void 0 !== e2.object.distance && (this.distance = e2.object.distance), void 0 !== e2.object.angle && (this.angle = e2.object.angle), void 0 !== e2.object.decay && (this.decay = e2.object.decay), void 0 !== e2.object.penumbra && (this.penumbra = e2.object.penumbra), ce(e2, this, true, t2), this) : this);
    }
  }
  class ar extends n.cek {
    get lightObject() {
      return this;
    }
    get modelObject() {
      return this;
    }
    constructor(e2, t2, n2, r2) {
      super(e2, t2, n2, r2), this.assetType = "light";
    }
    copy(e2, t2) {
      const n2 = e2.userData;
      return e2.userData = {}, super.copy(e2, t2), Ee(this.userData, n2), this;
    }
    get uiConfig() {
      return this._uiConfig ? this._uiConfig : this._uiConfig = { type: "folder", label: "Point Light", children: [{ type: "checkbox", label: "Enabled", property: [this, "visible"] }, { type: "color", label: "Color", property: [this, "color"] }, { type: "slider", label: "Intensity", bounds: [0, 20], property: [this, "intensity"] }, { type: "input", label: "Distance", property: [this, "distance"] }, { type: "input", property: [this, "decay"] }, { type: "vec3", label: "Position", property: [this, "position"] }, { type: "checkbox", label: "Shadow Enabled", property: [this, "castShadow"] }, { type: "vec2", label: "Shadow Map Size", property: [null == this ? void 0 : this.shadow, "mapSize"], onChange: () => {
        var e2, t2;
        null === (e2 = this.shadow.map) || void 0 === e2 || e2.dispose(), null === (t2 = this.shadow.mapPass) || void 0 === t2 || t2.dispose(), this.shadow.map = null, this.shadow.mapPass = null;
      } }, { type: "slider", bounds: [-1e-3, 1e-3], stepSize: 2e-5, label: "Shadow Bias", property: [null == this ? void 0 : this.shadow, "bias"], onChange: this.setDirty }, { type: "slider", bounds: [0, 5], label: "Shadow radius", property: [null == this ? void 0 : this.shadow, "radius"], onChange: this.setDirty }] };
    }
    toJSON(e2) {
      const { userData: t2 } = this;
      this.userData = {};
      const n2 = super.toJSON(e2);
      return n2.userData = le(Ee({}, t2), false), this.userData = {}, n2.type = "PointLight2", Object.assign(n2, le(this, true, e2));
    }
    fromJSON(e2, t2) {
      return "PointLight2" !== e2.type ? null : e2.object ? (void 0 !== e2.object.color && this.color.set(e2.object.color), void 0 !== e2.object.intensity && (this.intensity = e2.object.intensity), void 0 !== e2.object.distance && (this.distance = e2.object.distance), void 0 !== e2.object.decay && (this.decay = e2.object.decay), ce(e2, this, true, t2), this) : this;
    }
  }
  class lr extends n.Mig {
    get lightObject() {
      return this;
    }
    get modelObject() {
      return this;
    }
    constructor(e2, t2) {
      super(e2, t2), this.assetType = "light";
    }
    copy(e2, t2) {
      const n2 = e2.userData;
      return e2.userData = {}, super.copy(e2, t2), Ee(this.userData, n2), this;
    }
    get uiConfig() {
      return this._uiConfig ? this._uiConfig : this._uiConfig = { type: "folder", label: "Ambient Light", children: [{ type: "checkbox", label: "Enabled", property: [this, "visible"] }, { type: "color", label: "Color", property: [this, "color"] }, { type: "slider", label: "Intensity", bounds: [0, 20], property: [this, "intensity"] }] };
    }
    toJSON(e2) {
      const { userData: t2 } = this;
      this.userData = {};
      const n2 = super.toJSON(e2);
      return n2.userData = le(Ee({}, t2), false), this.userData = {}, n2.type = "AmbientLight2", Object.assign(n2, le(this, true, e2));
    }
    fromJSON(e2, t2) {
      return "AmbientLight2" !== e2.type ? null : e2.object ? (void 0 !== e2.object.color && this.color.set(e2.object.color), void 0 !== e2.object.intensity && (this.intensity = e2.object.intensity), ce(e2, this, true, t2), this) : this;
    }
  }
  class cr extends n.aNw {
    load(e2, t2, r2, i2) {
      const s2 = new n.hH6(this.manager);
      s2.setPath(this.path), s2.setResponseType("text"), s2.load(e2, (n2) => {
        try {
          t2(this.parse(n2));
        } catch (t3) {
          i2 ? i2(t3) : console.error(t3), this.manager.itemError(e2);
        }
      }, r2, i2);
    }
    parse(e2) {
      e2 = e2.replace(/^#.*?(\n|\r)/gm, "").replace(/^\s*?(\n|\r)/gm, "").trim();
      let t2 = null, r2 = null;
      const i2 = new n.Pa4(0, 0, 0), s2 = new n.Pa4(1, 1, 1), o2 = e2.split(/[\n\r]+/g);
      let a2 = null, l2 = 0;
      for (let e3 = 0, n2 = o2.length; e3 < n2; e3++) {
        const n3 = o2[e3].trim(), c3 = n3.split(/\s/g);
        switch (c3[0]) {
          case "TITLE":
            t2 = n3.substring(7, n3.length - 1);
            break;
          case "LUT_3D_SIZE":
            const e4 = c3[1];
            r2 = parseFloat(e4), a2 = new Uint8Array(r2 * r2 * r2 * 4);
            break;
          case "DOMAIN_MIN":
            i2.x = parseFloat(c3[1]), i2.y = parseFloat(c3[2]), i2.z = parseFloat(c3[3]);
            break;
          case "DOMAIN_MAX":
            s2.x = parseFloat(c3[1]), s2.y = parseFloat(c3[2]), s2.z = parseFloat(c3[3]);
            break;
          default:
            const o3 = parseFloat(c3[0]), u3 = parseFloat(c3[1]), p2 = parseFloat(c3[2]);
            if (o3 > 1 || o3 < 0 || u3 > 1 || u3 < 0 || p2 > 1 || p2 < 0)
              throw new Error("LUTCubeLoader : Non normalized values not supported.");
            a2[l2 + 0] = 255 * o3, a2[l2 + 1] = 255 * u3, a2[l2 + 2] = 255 * p2, a2[l2 + 3] = 255, l2 += 4;
        }
      }
      const c2 = new n.IEO();
      c2.image.data = a2, c2.image.width = r2, c2.image.height = r2 * r2, c2.type = n.ywz, c2.magFilter = n.wem, c2.minFilter = n.wem, c2.wrapS = n.uWy, c2.wrapT = n.uWy, c2.generateMipmaps = false, c2.needsUpdate = true;
      const u2 = new n.JUT();
      return u2.image.data = a2, u2.image.width = r2, u2.image.height = r2, u2.image.depth = r2, u2.type = n.ywz, u2.magFilter = n.wem, u2.minFilter = n.wem, u2.wrapS = n.uWy, u2.wrapT = n.uWy, u2.wrapR = n.uWy, u2.generateMipmaps = false, u2.needsUpdate = true, { title: t2, size: r2, domainMin: i2, domainMax: s2, texture: c2, texture3D: u2 };
    }
  }
  let ur = class {
    constructor({ domainMax: e2, domainMin: t2, size: r2, texture: i2, texture3D: s2, title: o2 }) {
      this.userData = {}, this.type = "LUTCubeTextureWrapper", this.assetType = "lutTexture", this.domainMax = e2, this.domainMin = t2, this.size = r2, this.texture = i2, this.texture3D = s2, this.title = o2, this.uuid = n.M8C.generateUUID(), this.userData.__needsSourceBuffer = true;
    }
    fromJSON(e2, t2) {
      return e2.type !== this.type && console.warn("WebGi LUTCubeLoader2: type mismatch while import", e2, this), console.error("not supported"), this;
    }
    toJSON(e2) {
      return de(this, e2, this.texture.name);
    }
  };
  ur = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  }([pe("LUTCubeTextureWrapper")], ur);
  class pr extends cr {
    parse(e2) {
      const t2 = super.parse(e2);
      return new ur(t2);
    }
  }
  var dr = {}, hr = Uint8Array, fr = Uint16Array, mr = Uint32Array, _r = new hr([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), gr = new hr([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), vr = new hr([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), yr = function(e2, t2) {
    for (var n2 = new fr(31), r2 = 0; r2 < 31; ++r2)
      n2[r2] = t2 += 1 << e2[r2 - 1];
    var i2 = new mr(n2[30]);
    for (r2 = 1; r2 < 30; ++r2)
      for (var s2 = n2[r2]; s2 < n2[r2 + 1]; ++s2)
        i2[s2] = s2 - n2[r2] << 5 | r2;
    return [n2, i2];
  }, br = yr(_r, 2), wr = br[0], Ar = br[1];
  wr[28] = 258, Ar[258] = 28;
  for (var xr = yr(gr, 0), Er = xr[0], Cr = xr[1], Sr = new fr(32768), Mr = 0; Mr < 32768; ++Mr) {
    var Tr = (43690 & Mr) >>> 1 | (21845 & Mr) << 1;
    Tr = (61680 & (Tr = (52428 & Tr) >>> 2 | (13107 & Tr) << 2)) >>> 4 | (3855 & Tr) << 4, Sr[Mr] = ((65280 & Tr) >>> 8 | (255 & Tr) << 8) >>> 1;
  }
  var Pr = function(e2, t2, n2) {
    for (var r2 = e2.length, i2 = 0, s2 = new fr(t2); i2 < r2; ++i2)
      ++s2[e2[i2] - 1];
    var o2, a2 = new fr(t2);
    for (i2 = 0; i2 < t2; ++i2)
      a2[i2] = a2[i2 - 1] + s2[i2 - 1] << 1;
    if (n2) {
      o2 = new fr(1 << t2);
      var l2 = 15 - t2;
      for (i2 = 0; i2 < r2; ++i2)
        if (e2[i2])
          for (var c2 = i2 << 4 | e2[i2], u2 = t2 - e2[i2], p2 = a2[e2[i2] - 1]++ << u2, d2 = p2 | (1 << u2) - 1; p2 <= d2; ++p2)
            o2[Sr[p2] >>> l2] = c2;
    } else
      for (o2 = new fr(r2), i2 = 0; i2 < r2; ++i2)
        e2[i2] && (o2[i2] = Sr[a2[e2[i2] - 1]++] >>> 15 - e2[i2]);
    return o2;
  }, Ir = new hr(288);
  for (Mr = 0; Mr < 144; ++Mr)
    Ir[Mr] = 8;
  for (Mr = 144; Mr < 256; ++Mr)
    Ir[Mr] = 9;
  for (Mr = 256; Mr < 280; ++Mr)
    Ir[Mr] = 7;
  for (Mr = 280; Mr < 288; ++Mr)
    Ir[Mr] = 8;
  var Rr = new hr(32);
  for (Mr = 0; Mr < 32; ++Mr)
    Rr[Mr] = 5;
  var kr = Pr(Ir, 9, 0), Dr = Pr(Ir, 9, 1), Br = Pr(Rr, 5, 0), Or = Pr(Rr, 5, 1), Lr = function(e2) {
    for (var t2 = e2[0], n2 = 1; n2 < e2.length; ++n2)
      e2[n2] > t2 && (t2 = e2[n2]);
    return t2;
  }, Ur = function(e2, t2, n2) {
    var r2 = t2 / 8 | 0;
    return (e2[r2] | e2[r2 + 1] << 8) >> (7 & t2) & n2;
  }, Fr = function(e2, t2) {
    var n2 = t2 / 8 | 0;
    return (e2[n2] | e2[n2 + 1] << 8 | e2[n2 + 2] << 16) >> (7 & t2);
  }, Nr = function(e2) {
    return (e2 / 8 | 0) + (7 & e2 && 1);
  }, jr = function(e2, t2, n2) {
    (null == t2 || t2 < 0) && (t2 = 0), (null == n2 || n2 > e2.length) && (n2 = e2.length);
    var r2 = new (e2 instanceof fr ? fr : e2 instanceof mr ? mr : hr)(n2 - t2);
    return r2.set(e2.subarray(t2, n2)), r2;
  }, zr = function(e2, t2, n2) {
    var r2 = e2.length;
    if (!r2 || n2 && !n2.l && r2 < 5)
      return t2 || new hr(0);
    var i2 = !t2 || n2, s2 = !n2 || n2.i;
    n2 || (n2 = {}), t2 || (t2 = new hr(3 * r2));
    var o2 = function(e3) {
      var n3 = t2.length;
      if (e3 > n3) {
        var r3 = new hr(Math.max(2 * n3, e3));
        r3.set(t2), t2 = r3;
      }
    }, a2 = n2.f || 0, l2 = n2.p || 0, c2 = n2.b || 0, u2 = n2.l, p2 = n2.d, d2 = n2.m, h2 = n2.n, f2 = 8 * r2;
    do {
      if (!u2) {
        n2.f = a2 = Ur(e2, l2, 1);
        var m2 = Ur(e2, l2 + 1, 3);
        if (l2 += 3, !m2) {
          var _2 = e2[(M2 = Nr(l2) + 4) - 4] | e2[M2 - 3] << 8, g2 = M2 + _2;
          if (g2 > r2) {
            if (s2)
              throw "unexpected EOF";
            break;
          }
          i2 && o2(c2 + _2), t2.set(e2.subarray(M2, g2), c2), n2.b = c2 += _2, n2.p = l2 = 8 * g2;
          continue;
        }
        if (1 == m2)
          u2 = Dr, p2 = Or, d2 = 9, h2 = 5;
        else {
          if (2 != m2)
            throw "invalid block type";
          var v2 = Ur(e2, l2, 31) + 257, y2 = Ur(e2, l2 + 10, 15) + 4, b2 = v2 + Ur(e2, l2 + 5, 31) + 1;
          l2 += 14;
          for (var w2 = new hr(b2), A2 = new hr(19), x2 = 0; x2 < y2; ++x2)
            A2[vr[x2]] = Ur(e2, l2 + 3 * x2, 7);
          l2 += 3 * y2;
          var E2 = Lr(A2), C2 = (1 << E2) - 1, S2 = Pr(A2, E2, 1);
          for (x2 = 0; x2 < b2; ) {
            var M2, T2 = S2[Ur(e2, l2, C2)];
            if (l2 += 15 & T2, (M2 = T2 >>> 4) < 16)
              w2[x2++] = M2;
            else {
              var P2 = 0, I2 = 0;
              for (16 == M2 ? (I2 = 3 + Ur(e2, l2, 3), l2 += 2, P2 = w2[x2 - 1]) : 17 == M2 ? (I2 = 3 + Ur(e2, l2, 7), l2 += 3) : 18 == M2 && (I2 = 11 + Ur(e2, l2, 127), l2 += 7); I2--; )
                w2[x2++] = P2;
            }
          }
          var R2 = w2.subarray(0, v2), k2 = w2.subarray(v2);
          d2 = Lr(R2), h2 = Lr(k2), u2 = Pr(R2, d2, 1), p2 = Pr(k2, h2, 1);
        }
        if (l2 > f2) {
          if (s2)
            throw "unexpected EOF";
          break;
        }
      }
      i2 && o2(c2 + 131072);
      for (var D2 = (1 << d2) - 1, B2 = (1 << h2) - 1, O2 = l2; ; O2 = l2) {
        var L2 = (P2 = u2[Fr(e2, l2) & D2]) >>> 4;
        if ((l2 += 15 & P2) > f2) {
          if (s2)
            throw "unexpected EOF";
          break;
        }
        if (!P2)
          throw "invalid length/literal";
        if (L2 < 256)
          t2[c2++] = L2;
        else {
          if (256 == L2) {
            O2 = l2, u2 = null;
            break;
          }
          var U2 = L2 - 254;
          if (L2 > 264) {
            var F2 = _r[x2 = L2 - 257];
            U2 = Ur(e2, l2, (1 << F2) - 1) + wr[x2], l2 += F2;
          }
          var N2 = p2[Fr(e2, l2) & B2], j2 = N2 >>> 4;
          if (!N2)
            throw "invalid distance";
          if (l2 += 15 & N2, k2 = Er[j2], j2 > 3 && (F2 = gr[j2], k2 += Fr(e2, l2) & (1 << F2) - 1, l2 += F2), l2 > f2) {
            if (s2)
              throw "unexpected EOF";
            break;
          }
          i2 && o2(c2 + 131072);
          for (var z2 = c2 + U2; c2 < z2; c2 += 4)
            t2[c2] = t2[c2 - k2], t2[c2 + 1] = t2[c2 + 1 - k2], t2[c2 + 2] = t2[c2 + 2 - k2], t2[c2 + 3] = t2[c2 + 3 - k2];
          c2 = z2;
        }
      }
      n2.l = u2, n2.p = O2, n2.b = c2, u2 && (a2 = 1, n2.m = d2, n2.d = p2, n2.n = h2);
    } while (!a2);
    return c2 == t2.length ? t2 : jr(t2, 0, c2);
  }, Gr = function(e2, t2, n2) {
    n2 <<= 7 & t2;
    var r2 = t2 / 8 | 0;
    e2[r2] |= n2, e2[r2 + 1] |= n2 >>> 8;
  }, Vr = function(e2, t2, n2) {
    n2 <<= 7 & t2;
    var r2 = t2 / 8 | 0;
    e2[r2] |= n2, e2[r2 + 1] |= n2 >>> 8, e2[r2 + 2] |= n2 >>> 16;
  }, Hr = function(e2, t2) {
    for (var n2 = [], r2 = 0; r2 < e2.length; ++r2)
      e2[r2] && n2.push({ s: r2, f: e2[r2] });
    var i2 = n2.length, s2 = n2.slice();
    if (!i2)
      return [Jr, 0];
    if (1 == i2) {
      var o2 = new hr(n2[0].s + 1);
      return o2[n2[0].s] = 1, [o2, 1];
    }
    n2.sort(function(e3, t3) {
      return e3.f - t3.f;
    }), n2.push({ s: -1, f: 25001 });
    var a2 = n2[0], l2 = n2[1], c2 = 0, u2 = 1, p2 = 2;
    for (n2[0] = { s: -1, f: a2.f + l2.f, l: a2, r: l2 }; u2 != i2 - 1; )
      a2 = n2[n2[c2].f < n2[p2].f ? c2++ : p2++], l2 = n2[c2 != u2 && n2[c2].f < n2[p2].f ? c2++ : p2++], n2[u2++] = { s: -1, f: a2.f + l2.f, l: a2, r: l2 };
    var d2 = s2[0].s;
    for (r2 = 1; r2 < i2; ++r2)
      s2[r2].s > d2 && (d2 = s2[r2].s);
    var h2 = new fr(d2 + 1), f2 = Qr(n2[u2 - 1], h2, 0);
    if (f2 > t2) {
      r2 = 0;
      var m2 = 0, _2 = f2 - t2, g2 = 1 << _2;
      for (s2.sort(function(e3, t3) {
        return h2[t3.s] - h2[e3.s] || e3.f - t3.f;
      }); r2 < i2; ++r2) {
        var v2 = s2[r2].s;
        if (!(h2[v2] > t2))
          break;
        m2 += g2 - (1 << f2 - h2[v2]), h2[v2] = t2;
      }
      for (m2 >>>= _2; m2 > 0; ) {
        var y2 = s2[r2].s;
        h2[y2] < t2 ? m2 -= 1 << t2 - h2[y2]++ - 1 : ++r2;
      }
      for (; r2 >= 0 && m2; --r2) {
        var b2 = s2[r2].s;
        h2[b2] == t2 && (--h2[b2], ++m2);
      }
      f2 = t2;
    }
    return [new hr(h2), f2];
  }, Qr = function(e2, t2, n2) {
    return -1 == e2.s ? Math.max(Qr(e2.l, t2, n2 + 1), Qr(e2.r, t2, n2 + 1)) : t2[e2.s] = n2;
  }, Wr = function(e2) {
    for (var t2 = e2.length; t2 && !e2[--t2]; )
      ;
    for (var n2 = new fr(++t2), r2 = 0, i2 = e2[0], s2 = 1, o2 = function(e3) {
      n2[r2++] = e3;
    }, a2 = 1; a2 <= t2; ++a2)
      if (e2[a2] == i2 && a2 != t2)
        ++s2;
      else {
        if (!i2 && s2 > 2) {
          for (; s2 > 138; s2 -= 138)
            o2(32754);
          s2 > 2 && (o2(s2 > 10 ? s2 - 11 << 5 | 28690 : s2 - 3 << 5 | 12305), s2 = 0);
        } else if (s2 > 3) {
          for (o2(i2), --s2; s2 > 6; s2 -= 6)
            o2(8304);
          s2 > 2 && (o2(s2 - 3 << 5 | 8208), s2 = 0);
        }
        for (; s2--; )
          o2(i2);
        s2 = 1, i2 = e2[a2];
      }
    return [n2.subarray(0, r2), t2];
  }, qr = function(e2, t2) {
    for (var n2 = 0, r2 = 0; r2 < t2.length; ++r2)
      n2 += e2[r2] * t2[r2];
    return n2;
  }, Xr = function(e2, t2, n2) {
    var r2 = n2.length, i2 = Nr(t2 + 2);
    e2[i2] = 255 & r2, e2[i2 + 1] = r2 >>> 8, e2[i2 + 2] = 255 ^ e2[i2], e2[i2 + 3] = 255 ^ e2[i2 + 1];
    for (var s2 = 0; s2 < r2; ++s2)
      e2[i2 + s2 + 4] = n2[s2];
    return 8 * (i2 + 4 + r2);
  }, Yr = function(e2, t2, n2, r2, i2, s2, o2, a2, l2, c2, u2) {
    Gr(t2, u2++, n2), ++i2[256];
    for (var p2 = Hr(i2, 15), d2 = p2[0], h2 = p2[1], f2 = Hr(s2, 15), m2 = f2[0], _2 = f2[1], g2 = Wr(d2), v2 = g2[0], y2 = g2[1], b2 = Wr(m2), w2 = b2[0], A2 = b2[1], x2 = new fr(19), E2 = 0; E2 < v2.length; ++E2)
      x2[31 & v2[E2]]++;
    for (E2 = 0; E2 < w2.length; ++E2)
      x2[31 & w2[E2]]++;
    for (var C2 = Hr(x2, 7), S2 = C2[0], M2 = C2[1], T2 = 19; T2 > 4 && !S2[vr[T2 - 1]]; --T2)
      ;
    var P2, I2, R2, k2, D2 = c2 + 5 << 3, B2 = qr(i2, Ir) + qr(s2, Rr) + o2, O2 = qr(i2, d2) + qr(s2, m2) + o2 + 14 + 3 * T2 + qr(x2, S2) + (2 * x2[16] + 3 * x2[17] + 7 * x2[18]);
    if (D2 <= B2 && D2 <= O2)
      return Xr(t2, u2, e2.subarray(l2, l2 + c2));
    if (Gr(t2, u2, 1 + (O2 < B2)), u2 += 2, O2 < B2) {
      P2 = Pr(d2, h2, 0), I2 = d2, R2 = Pr(m2, _2, 0), k2 = m2;
      var L2 = Pr(S2, M2, 0);
      for (Gr(t2, u2, y2 - 257), Gr(t2, u2 + 5, A2 - 1), Gr(t2, u2 + 10, T2 - 4), u2 += 14, E2 = 0; E2 < T2; ++E2)
        Gr(t2, u2 + 3 * E2, S2[vr[E2]]);
      u2 += 3 * T2;
      for (var U2 = [v2, w2], F2 = 0; F2 < 2; ++F2) {
        var N2 = U2[F2];
        for (E2 = 0; E2 < N2.length; ++E2) {
          var j2 = 31 & N2[E2];
          Gr(t2, u2, L2[j2]), u2 += S2[j2], j2 > 15 && (Gr(t2, u2, N2[E2] >>> 5 & 127), u2 += N2[E2] >>> 12);
        }
      }
    } else
      P2 = kr, I2 = Ir, R2 = Br, k2 = Rr;
    for (E2 = 0; E2 < a2; ++E2)
      if (r2[E2] > 255) {
        j2 = r2[E2] >>> 18 & 31, Vr(t2, u2, P2[j2 + 257]), u2 += I2[j2 + 257], j2 > 7 && (Gr(t2, u2, r2[E2] >>> 23 & 31), u2 += _r[j2]);
        var z2 = 31 & r2[E2];
        Vr(t2, u2, R2[z2]), u2 += k2[z2], z2 > 3 && (Vr(t2, u2, r2[E2] >>> 5 & 8191), u2 += gr[z2]);
      } else
        Vr(t2, u2, P2[r2[E2]]), u2 += I2[r2[E2]];
    return Vr(t2, u2, P2[256]), u2 + I2[256];
  }, Kr = new mr([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), Jr = new hr(0), Zr = function(e2, t2, n2, r2, i2, s2) {
    var o2 = e2.length, a2 = new hr(r2 + o2 + 5 * (1 + Math.ceil(o2 / 7e3)) + i2), l2 = a2.subarray(r2, a2.length - i2), c2 = 0;
    if (!t2 || o2 < 8)
      for (var u2 = 0; u2 <= o2; u2 += 65535) {
        var p2 = u2 + 65535;
        p2 < o2 ? c2 = Xr(l2, c2, e2.subarray(u2, p2)) : (l2[u2] = s2, c2 = Xr(l2, c2, e2.subarray(u2, o2)));
      }
    else {
      for (var d2 = Kr[t2 - 1], h2 = d2 >>> 13, f2 = 8191 & d2, m2 = (1 << n2) - 1, _2 = new fr(32768), g2 = new fr(m2 + 1), v2 = Math.ceil(n2 / 3), y2 = 2 * v2, b2 = function(t3) {
        return (e2[t3] ^ e2[t3 + 1] << v2 ^ e2[t3 + 2] << y2) & m2;
      }, w2 = new mr(25e3), A2 = new fr(288), x2 = new fr(32), E2 = 0, C2 = 0, S2 = (u2 = 0, 0), M2 = 0, T2 = 0; u2 < o2; ++u2) {
        var P2 = b2(u2), I2 = 32767 & u2, R2 = g2[P2];
        if (_2[I2] = R2, g2[P2] = I2, M2 <= u2) {
          var k2 = o2 - u2;
          if ((E2 > 7e3 || S2 > 24576) && k2 > 423) {
            c2 = Yr(e2, l2, 0, w2, A2, x2, C2, S2, T2, u2 - T2, c2), S2 = E2 = C2 = 0, T2 = u2;
            for (var D2 = 0; D2 < 286; ++D2)
              A2[D2] = 0;
            for (D2 = 0; D2 < 30; ++D2)
              x2[D2] = 0;
          }
          var B2 = 2, O2 = 0, L2 = f2, U2 = I2 - R2 & 32767;
          if (k2 > 2 && P2 == b2(u2 - U2))
            for (var F2 = Math.min(h2, k2) - 1, N2 = Math.min(32767, u2), j2 = Math.min(258, k2); U2 <= N2 && --L2 && I2 != R2; ) {
              if (e2[u2 + B2] == e2[u2 + B2 - U2]) {
                for (var z2 = 0; z2 < j2 && e2[u2 + z2] == e2[u2 + z2 - U2]; ++z2)
                  ;
                if (z2 > B2) {
                  if (B2 = z2, O2 = U2, z2 > F2)
                    break;
                  var G2 = Math.min(U2, z2 - 2), V2 = 0;
                  for (D2 = 0; D2 < G2; ++D2) {
                    var H2 = u2 - U2 + D2 + 32768 & 32767, Q2 = H2 - _2[H2] + 32768 & 32767;
                    Q2 > V2 && (V2 = Q2, R2 = H2);
                  }
                }
              }
              U2 += (I2 = R2) - (R2 = _2[I2]) + 32768 & 32767;
            }
          if (O2) {
            w2[S2++] = 268435456 | Ar[B2] << 18 | Cr[O2];
            var W2 = 31 & Ar[B2], q2 = 31 & Cr[O2];
            C2 += _r[W2] + gr[q2], ++A2[257 + W2], ++x2[q2], M2 = u2 + B2, ++E2;
          } else
            w2[S2++] = e2[u2], ++A2[e2[u2]];
        }
      }
      c2 = Yr(e2, l2, s2, w2, A2, x2, C2, S2, T2, u2 - T2, c2), !s2 && 7 & c2 && (c2 = Xr(l2, c2 + 1, Jr));
    }
    return jr(a2, 0, r2 + Nr(c2) + i2);
  }, $r = function() {
    for (var e2 = new Int32Array(256), t2 = 0; t2 < 256; ++t2) {
      for (var n2 = t2, r2 = 9; --r2; )
        n2 = (1 & n2 && -306674912) ^ n2 >>> 1;
      e2[t2] = n2;
    }
    return e2;
  }(), ei = function() {
    var e2 = -1;
    return { p: function(t2) {
      for (var n2 = e2, r2 = 0; r2 < t2.length; ++r2)
        n2 = $r[255 & n2 ^ t2[r2]] ^ n2 >>> 8;
      e2 = n2;
    }, d: function() {
      return ~e2;
    } };
  }, ti = function() {
    var e2 = 1, t2 = 0;
    return { p: function(n2) {
      for (var r2 = e2, i2 = t2, s2 = n2.length, o2 = 0; o2 != s2; ) {
        for (var a2 = Math.min(o2 + 2655, s2); o2 < a2; ++o2)
          i2 += r2 += n2[o2];
        r2 = (65535 & r2) + 15 * (r2 >> 16), i2 = (65535 & i2) + 15 * (i2 >> 16);
      }
      e2 = r2, t2 = i2;
    }, d: function() {
      return (255 & (e2 %= 65521)) << 24 | e2 >>> 8 << 16 | (255 & (t2 %= 65521)) << 8 | t2 >>> 8;
    } };
  }, ni = function(e2, t2, n2, r2, i2) {
    return Zr(e2, null == t2.level ? 6 : t2.level, null == t2.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(e2.length)))) : 12 + t2.mem, n2, r2, !i2);
  }, ri = function(e2, t2) {
    var n2 = {};
    for (var r2 in e2)
      n2[r2] = e2[r2];
    for (var r2 in t2)
      n2[r2] = t2[r2];
    return n2;
  }, ii = function(e2, t2, n2) {
    for (var r2 = e2(), i2 = e2.toString(), s2 = i2.slice(i2.indexOf("[") + 1, i2.lastIndexOf("]")).replace(/ /g, "").split(","), o2 = 0; o2 < r2.length; ++o2) {
      var a2 = r2[o2], l2 = s2[o2];
      if ("function" == typeof a2) {
        t2 += ";" + l2 + "=";
        var c2 = a2.toString();
        if (a2.prototype)
          if (-1 != c2.indexOf("[native code]")) {
            var u2 = c2.indexOf(" ", 8) + 1;
            t2 += c2.slice(u2, c2.indexOf("(", u2));
          } else
            for (var p2 in t2 += c2, a2.prototype)
              t2 += ";" + l2 + ".prototype." + p2 + "=" + a2.prototype[p2].toString();
        else
          t2 += c2;
      } else
        n2[l2] = a2;
    }
    return [t2, n2];
  }, si = [], oi = function(e2, t2, n2, r2) {
    var i2;
    if (!si[n2]) {
      for (var s2 = "", o2 = {}, a2 = e2.length - 1, l2 = 0; l2 < a2; ++l2)
        s2 = (i2 = ii(e2[l2], s2, o2))[0], o2 = i2[1];
      si[n2] = ii(e2[a2], s2, o2);
    }
    var c2 = ri({}, si[n2][1]);
    return function(e3, t3, n3, r3, i3) {
      var s3 = new Worker(dr[t3] || (dr[t3] = URL.createObjectURL(new Blob([e3], { type: "text/javascript" }))));
      return s3.onerror = function(e4) {
        return i3(e4.error, null);
      }, s3.onmessage = function(e4) {
        return i3(null, e4.data);
      }, s3.postMessage(n3, r3), s3;
    }(si[n2][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + t2.toString() + "}", n2, c2, function(e3) {
      var t3 = [];
      for (var n3 in e3)
        (e3[n3] instanceof hr || e3[n3] instanceof fr || e3[n3] instanceof mr) && t3.push((e3[n3] = new e3[n3].constructor(e3[n3])).buffer);
      return t3;
    }(c2), r2);
  }, ai = function() {
    return [hr, fr, mr, _r, gr, vr, wr, Er, Dr, Or, Sr, Pr, Lr, Ur, Fr, Nr, jr, zr, Li, hi, fi];
  }, li = function() {
    return [hr, fr, mr, _r, gr, vr, Ar, Cr, kr, Ir, Br, Rr, Sr, Kr, Jr, Pr, Gr, Vr, Hr, Qr, Wr, qr, Xr, Yr, Nr, jr, Zr, ni, ki, hi];
  }, ci = function() {
    return [Ai, Ci, wi, ei, $r];
  }, ui = function() {
    return [xi, Ei];
  }, pi = function() {
    return [Si, wi, ti];
  }, di = function() {
    return [Mi];
  }, hi = function(e2) {
    return postMessage(e2, [e2.buffer]);
  }, fi = function(e2) {
    return e2 && e2.size && new hr(e2.size);
  }, mi = function(e2, t2, n2, r2, i2, s2) {
    var o2 = oi(n2, r2, i2, function(e3, t3) {
      o2.terminate(), s2(e3, t3);
    });
    return o2.postMessage([e2, t2], t2.consume ? [e2.buffer] : []), function() {
      o2.terminate();
    };
  }, _i = function(e2) {
    return e2.ondata = function(e3, t2) {
      return postMessage([e3, t2], [e3.buffer]);
    }, function(t2) {
      return e2.push(t2.data[0], t2.data[1]);
    };
  }, gi = function(e2, t2, n2, r2, i2) {
    var s2, o2 = oi(e2, r2, i2, function(e3, n3) {
      e3 ? (o2.terminate(), t2.ondata.call(t2, e3)) : (n3[1] && o2.terminate(), t2.ondata.call(t2, e3, n3[0], n3[1]));
    });
    o2.postMessage(n2), t2.push = function(e3, n3) {
      if (s2)
        throw "stream finished";
      if (!t2.ondata)
        throw "no stream handler";
      o2.postMessage([e3, s2 = n3], [e3.buffer]);
    }, t2.terminate = function() {
      o2.terminate();
    };
  }, vi = function(e2, t2) {
    return e2[t2] | e2[t2 + 1] << 8;
  }, yi = function(e2, t2) {
    return (e2[t2] | e2[t2 + 1] << 8 | e2[t2 + 2] << 16 | e2[t2 + 3] << 24) >>> 0;
  }, bi = function(e2, t2) {
    return yi(e2, t2) + 4294967296 * yi(e2, t2 + 4);
  }, wi = function(e2, t2, n2) {
    for (; n2; ++t2)
      e2[t2] = n2, n2 >>>= 8;
  }, Ai = function(e2, t2) {
    var n2 = t2.filename;
    if (e2[0] = 31, e2[1] = 139, e2[2] = 8, e2[8] = t2.level < 2 ? 4 : 9 == t2.level ? 2 : 0, e2[9] = 3, 0 != t2.mtime && wi(e2, 4, Math.floor(new Date(t2.mtime || Date.now()) / 1e3)), n2) {
      e2[3] = 8;
      for (var r2 = 0; r2 <= n2.length; ++r2)
        e2[r2 + 10] = n2.charCodeAt(r2);
    }
  }, xi = function(e2) {
    if (31 != e2[0] || 139 != e2[1] || 8 != e2[2])
      throw "invalid gzip data";
    var t2 = e2[3], n2 = 10;
    4 & t2 && (n2 += e2[10] | 2 + (e2[11] << 8));
    for (var r2 = (t2 >> 3 & 1) + (t2 >> 4 & 1); r2 > 0; r2 -= !e2[n2++])
      ;
    return n2 + (2 & t2);
  }, Ei = function(e2) {
    var t2 = e2.length;
    return (e2[t2 - 4] | e2[t2 - 3] << 8 | e2[t2 - 2] << 16 | e2[t2 - 1] << 24) >>> 0;
  }, Ci = function(e2) {
    return 10 + (e2.filename && e2.filename.length + 1 || 0);
  }, Si = function(e2, t2) {
    var n2 = t2.level, r2 = 0 == n2 ? 0 : n2 < 6 ? 1 : 9 == n2 ? 3 : 2;
    e2[0] = 120, e2[1] = r2 << 6 | (r2 ? 32 - 2 * r2 : 1);
  }, Mi = function(e2) {
    if (8 != (15 & e2[0]) || e2[0] >>> 4 > 7 || (e2[0] << 8 | e2[1]) % 31)
      throw "invalid zlib data";
    if (32 & e2[1])
      throw "invalid zlib data: preset dictionaries not supported";
  };
  function Ti(e2, t2) {
    return t2 || "function" != typeof e2 || (t2 = e2, e2 = {}), this.ondata = t2, e2;
  }
  var Pi = function() {
    function e2(e3, t2) {
      t2 || "function" != typeof e3 || (t2 = e3, e3 = {}), this.ondata = t2, this.o = e3 || {};
    }
    return e2.prototype.p = function(e3, t2) {
      this.ondata(ni(e3, this.o, 0, 0, !t2), t2);
    }, e2.prototype.push = function(e3, t2) {
      if (this.d)
        throw "stream finished";
      if (!this.ondata)
        throw "no stream handler";
      this.d = t2, this.p(e3, t2 || false);
    }, e2;
  }(), Ii = function() {
    return function(e2, t2) {
      gi([li, function() {
        return [_i, Pi];
      }], this, Ti.call(this, e2, t2), function(e3) {
        var t3 = new Pi(e3.data);
        onmessage = _i(t3);
      }, 6);
    };
  }();
  function Ri(e2, t2, n2) {
    if (n2 || (n2 = t2, t2 = {}), "function" != typeof n2)
      throw "no callback";
    return mi(e2, t2, [li], function(e3) {
      return hi(ki(e3.data[0], e3.data[1]));
    }, 0, n2);
  }
  function ki(e2, t2) {
    return ni(e2, t2 || {}, 0, 0);
  }
  var Di = function() {
    function e2(e3) {
      this.s = {}, this.p = new hr(0), this.ondata = e3;
    }
    return e2.prototype.e = function(e3) {
      if (this.d)
        throw "stream finished";
      if (!this.ondata)
        throw "no stream handler";
      var t2 = this.p.length, n2 = new hr(t2 + e3.length);
      n2.set(this.p), n2.set(e3, t2), this.p = n2;
    }, e2.prototype.c = function(e3) {
      this.d = this.s.i = e3 || false;
      var t2 = this.s.b, n2 = zr(this.p, this.o, this.s);
      this.ondata(jr(n2, t2, this.s.b), this.d), this.o = jr(n2, this.s.b - 32768), this.s.b = this.o.length, this.p = jr(this.p, this.s.p / 8 | 0), this.s.p &= 7;
    }, e2.prototype.push = function(e3, t2) {
      this.e(e3), this.c(t2);
    }, e2;
  }(), Bi = function() {
    return function(e2) {
      this.ondata = e2, gi([ai, function() {
        return [_i, Di];
      }], this, 0, function() {
        var e3 = new Di();
        onmessage = _i(e3);
      }, 7);
    };
  }();
  function Oi(e2, t2, n2) {
    if (n2 || (n2 = t2, t2 = {}), "function" != typeof n2)
      throw "no callback";
    return mi(e2, t2, [ai], function(e3) {
      return hi(Li(e3.data[0], fi(e3.data[1])));
    }, 1, n2);
  }
  function Li(e2, t2) {
    return zr(e2, t2);
  }
  var Ui = function() {
    function e2(e3, t2) {
      this.c = ei(), this.l = 0, this.v = 1, Pi.call(this, e3, t2);
    }
    return e2.prototype.push = function(e3, t2) {
      Pi.prototype.push.call(this, e3, t2);
    }, e2.prototype.p = function(e3, t2) {
      this.c.p(e3), this.l += e3.length;
      var n2 = ni(e3, this.o, this.v && Ci(this.o), t2 && 8, !t2);
      this.v && (Ai(n2, this.o), this.v = 0), t2 && (wi(n2, n2.length - 8, this.c.d()), wi(n2, n2.length - 4, this.l)), this.ondata(n2, t2);
    }, e2;
  }(), Fi = function() {
    return function(e2, t2) {
      gi([li, ci, function() {
        return [_i, Pi, Ui];
      }], this, Ti.call(this, e2, t2), function(e3) {
        var t3 = new Ui(e3.data);
        onmessage = _i(t3);
      }, 8);
    };
  }();
  function Ni(e2, t2, n2) {
    if (n2 || (n2 = t2, t2 = {}), "function" != typeof n2)
      throw "no callback";
    return mi(e2, t2, [li, ci, function() {
      return [ji];
    }], function(e3) {
      return hi(ji(e3.data[0], e3.data[1]));
    }, 2, n2);
  }
  function ji(e2, t2) {
    t2 || (t2 = {});
    var n2 = ei(), r2 = e2.length;
    n2.p(e2);
    var i2 = ni(e2, t2, Ci(t2), 8), s2 = i2.length;
    return Ai(i2, t2), wi(i2, s2 - 8, n2.d()), wi(i2, s2 - 4, r2), i2;
  }
  var zi = function() {
    function e2(e3) {
      this.v = 1, Di.call(this, e3);
    }
    return e2.prototype.push = function(e3, t2) {
      if (Di.prototype.e.call(this, e3), this.v) {
        var n2 = this.p.length > 3 ? xi(this.p) : 4;
        if (n2 >= this.p.length && !t2)
          return;
        this.p = this.p.subarray(n2), this.v = 0;
      }
      if (t2) {
        if (this.p.length < 8)
          throw "invalid gzip stream";
        this.p = this.p.subarray(0, -8);
      }
      Di.prototype.c.call(this, t2);
    }, e2;
  }(), Gi = function() {
    return function(e2) {
      this.ondata = e2, gi([ai, ui, function() {
        return [_i, Di, zi];
      }], this, 0, function() {
        var e3 = new zi();
        onmessage = _i(e3);
      }, 9);
    };
  }();
  function Vi(e2, t2, n2) {
    if (n2 || (n2 = t2, t2 = {}), "function" != typeof n2)
      throw "no callback";
    return mi(e2, t2, [ai, ui, function() {
      return [Hi];
    }], function(e3) {
      return hi(Hi(e3.data[0]));
    }, 3, n2);
  }
  function Hi(e2, t2) {
    return zr(e2.subarray(xi(e2), -8), t2 || new hr(Ei(e2)));
  }
  var Qi = function() {
    function e2(e3, t2) {
      this.c = ti(), this.v = 1, Pi.call(this, e3, t2);
    }
    return e2.prototype.push = function(e3, t2) {
      Pi.prototype.push.call(this, e3, t2);
    }, e2.prototype.p = function(e3, t2) {
      this.c.p(e3);
      var n2 = ni(e3, this.o, this.v && 2, t2 && 4, !t2);
      this.v && (Si(n2, this.o), this.v = 0), t2 && wi(n2, n2.length - 4, this.c.d()), this.ondata(n2, t2);
    }, e2;
  }(), Wi = function() {
    return function(e2, t2) {
      gi([li, pi, function() {
        return [_i, Pi, Qi];
      }], this, Ti.call(this, e2, t2), function(e3) {
        var t3 = new Qi(e3.data);
        onmessage = _i(t3);
      }, 10);
    };
  }();
  function qi(e2, t2, n2) {
    if (n2 || (n2 = t2, t2 = {}), "function" != typeof n2)
      throw "no callback";
    return mi(e2, t2, [li, pi, function() {
      return [Xi];
    }], function(e3) {
      return hi(Xi(e3.data[0], e3.data[1]));
    }, 4, n2);
  }
  function Xi(e2, t2) {
    t2 || (t2 = {});
    var n2 = ti();
    n2.p(e2);
    var r2 = ni(e2, t2, 2, 4);
    return Si(r2, t2), wi(r2, r2.length - 4, n2.d()), r2;
  }
  var Yi = function() {
    function e2(e3) {
      this.v = 1, Di.call(this, e3);
    }
    return e2.prototype.push = function(e3, t2) {
      if (Di.prototype.e.call(this, e3), this.v) {
        if (this.p.length < 2 && !t2)
          return;
        this.p = this.p.subarray(2), this.v = 0;
      }
      if (t2) {
        if (this.p.length < 4)
          throw "invalid zlib stream";
        this.p = this.p.subarray(0, -4);
      }
      Di.prototype.c.call(this, t2);
    }, e2;
  }(), Ki = function() {
    return function(e2) {
      this.ondata = e2, gi([ai, di, function() {
        return [_i, Di, Yi];
      }], this, 0, function() {
        var e3 = new Yi();
        onmessage = _i(e3);
      }, 11);
    };
  }();
  function Ji(e2, t2, n2) {
    if (n2 || (n2 = t2, t2 = {}), "function" != typeof n2)
      throw "no callback";
    return mi(e2, t2, [ai, di, function() {
      return [Zi];
    }], function(e3) {
      return hi(Zi(e3.data[0], fi(e3.data[1])));
    }, 5, n2);
  }
  function Zi(e2, t2) {
    return zr((Mi(e2), e2.subarray(2, -4)), t2);
  }
  var $i = function() {
    function e2(e3) {
      this.G = zi, this.I = Di, this.Z = Yi, this.ondata = e3;
    }
    return e2.prototype.push = function(e3, t2) {
      if (!this.ondata)
        throw "no stream handler";
      if (this.s)
        this.s.push(e3, t2);
      else {
        if (this.p && this.p.length) {
          var n2 = new hr(this.p.length + e3.length);
          n2.set(this.p), n2.set(e3, this.p.length);
        } else
          this.p = e3;
        if (this.p.length > 2) {
          var r2 = this, i2 = function() {
            r2.ondata.apply(r2, arguments);
          };
          this.s = 31 == this.p[0] && 139 == this.p[1] && 8 == this.p[2] ? new this.G(i2) : 8 != (15 & this.p[0]) || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(i2) : new this.Z(i2), this.s.push(this.p, t2), this.p = null;
        }
      }
    }, e2;
  }(), es = function() {
    function e2(e3) {
      this.G = Gi, this.I = Bi, this.Z = Ki, this.ondata = e3;
    }
    return e2.prototype.push = function(e3, t2) {
      $i.prototype.push.call(this, e3, t2);
    }, e2;
  }();
  function ts(e2, t2, n2) {
    if (n2 || (n2 = t2, t2 = {}), "function" != typeof n2)
      throw "no callback";
    return 31 == e2[0] && 139 == e2[1] && 8 == e2[2] ? Vi(e2, t2, n2) : 8 != (15 & e2[0]) || e2[0] >> 4 > 7 || (e2[0] << 8 | e2[1]) % 31 ? Oi(e2, t2, n2) : Ji(e2, t2, n2);
  }
  function ns(e2, t2) {
    return 31 == e2[0] && 139 == e2[1] && 8 == e2[2] ? Hi(e2, t2) : 8 != (15 & e2[0]) || e2[0] >> 4 > 7 || (e2[0] << 8 | e2[1]) % 31 ? Li(e2, t2) : Zi(e2, t2);
  }
  var rs = function(e2, t2, n2, r2) {
    for (var i2 in e2) {
      var s2 = e2[i2], o2 = t2 + i2;
      s2 instanceof hr ? n2[o2] = [s2, r2] : Array.isArray(s2) ? n2[o2] = [s2[0], ri(r2, s2[1])] : rs(s2, o2 + "/", n2, r2);
    }
  }, is = "undefined" != typeof TextEncoder && new TextEncoder(), ss = "undefined" != typeof TextDecoder && new TextDecoder(), os = 0;
  try {
    ss.decode(Jr, { stream: true }), os = 1;
  } catch (fl2) {
  }
  var as = function(e2) {
    for (var t2 = "", n2 = 0; ; ) {
      var r2 = e2[n2++], i2 = (r2 > 127) + (r2 > 223) + (r2 > 239);
      if (n2 + i2 > e2.length)
        return [t2, jr(e2, n2 - 1)];
      i2 ? 3 == i2 ? (r2 = ((15 & r2) << 18 | (63 & e2[n2++]) << 12 | (63 & e2[n2++]) << 6 | 63 & e2[n2++]) - 65536, t2 += String.fromCharCode(55296 | r2 >> 10, 56320 | 1023 & r2)) : t2 += 1 & i2 ? String.fromCharCode((31 & r2) << 6 | 63 & e2[n2++]) : String.fromCharCode((15 & r2) << 12 | (63 & e2[n2++]) << 6 | 63 & e2[n2++]) : t2 += String.fromCharCode(r2);
    }
  }, ls = function() {
    function e2(e3) {
      this.ondata = e3, os ? this.t = new TextDecoder() : this.p = Jr;
    }
    return e2.prototype.push = function(e3, t2) {
      if (!this.ondata)
        throw "no callback";
      if (t2 = !!t2, this.t) {
        if (this.ondata(this.t.decode(e3, { stream: true }), t2), t2) {
          if (this.t.decode().length)
            throw "invalid utf-8 data";
          this.t = null;
        }
      } else {
        if (!this.p)
          throw "stream finished";
        var n2 = new hr(this.p.length + e3.length);
        n2.set(this.p), n2.set(e3, this.p.length);
        var r2 = as(n2), i2 = r2[0], s2 = r2[1];
        if (t2) {
          if (s2.length)
            throw "invalid utf-8 data";
          this.p = null;
        } else
          this.p = s2;
        this.ondata(i2, t2);
      }
    }, e2;
  }(), cs = function() {
    function e2(e3) {
      this.ondata = e3;
    }
    return e2.prototype.push = function(e3, t2) {
      if (!this.ondata)
        throw "no callback";
      if (this.d)
        throw "stream finished";
      this.ondata(us(e3), this.d = t2 || false);
    }, e2;
  }();
  function us(e2, t2) {
    if (t2) {
      for (var n2 = new hr(e2.length), r2 = 0; r2 < e2.length; ++r2)
        n2[r2] = e2.charCodeAt(r2);
      return n2;
    }
    if (is)
      return is.encode(e2);
    var i2 = e2.length, s2 = new hr(e2.length + (e2.length >> 1)), o2 = 0, a2 = function(e3) {
      s2[o2++] = e3;
    };
    for (r2 = 0; r2 < i2; ++r2) {
      if (o2 + 5 > s2.length) {
        var l2 = new hr(o2 + 8 + (i2 - r2 << 1));
        l2.set(s2), s2 = l2;
      }
      var c2 = e2.charCodeAt(r2);
      c2 < 128 || t2 ? a2(c2) : c2 < 2048 ? (a2(192 | c2 >> 6), a2(128 | 63 & c2)) : c2 > 55295 && c2 < 57344 ? (a2(240 | (c2 = 65536 + (1047552 & c2) | 1023 & e2.charCodeAt(++r2)) >> 18), a2(128 | c2 >> 12 & 63), a2(128 | c2 >> 6 & 63), a2(128 | 63 & c2)) : (a2(224 | c2 >> 12), a2(128 | c2 >> 6 & 63), a2(128 | 63 & c2));
    }
    return jr(s2, 0, o2);
  }
  function ps(e2, t2) {
    if (t2) {
      for (var n2 = "", r2 = 0; r2 < e2.length; r2 += 16384)
        n2 += String.fromCharCode.apply(null, e2.subarray(r2, r2 + 16384));
      return n2;
    }
    if (ss)
      return ss.decode(e2);
    var i2 = as(e2), s2 = i2[0];
    if (i2[1].length)
      throw "invalid utf-8 data";
    return s2;
  }
  var ds = function(e2) {
    return 1 == e2 ? 3 : e2 < 6 ? 2 : 9 == e2 ? 1 : 0;
  }, hs = function(e2, t2) {
    return t2 + 30 + vi(e2, t2 + 26) + vi(e2, t2 + 28);
  }, fs = function(e2, t2, n2) {
    var r2 = vi(e2, t2 + 28), i2 = ps(e2.subarray(t2 + 46, t2 + 46 + r2), !(2048 & vi(e2, t2 + 8))), s2 = t2 + 46 + r2, o2 = yi(e2, t2 + 20), a2 = n2 && 4294967295 == o2 ? ms(e2, s2) : [o2, yi(e2, t2 + 24), yi(e2, t2 + 42)], l2 = a2[0], c2 = a2[1], u2 = a2[2];
    return [vi(e2, t2 + 10), l2, c2, i2, s2 + vi(e2, t2 + 30) + vi(e2, t2 + 32), u2];
  }, ms = function(e2, t2) {
    for (; 1 != vi(e2, t2); t2 += 4 + vi(e2, t2 + 2))
      ;
    return [bi(e2, t2 + 12), bi(e2, t2 + 4), bi(e2, t2 + 20)];
  }, _s = function(e2) {
    var t2 = 0;
    if (e2)
      for (var n2 in e2) {
        var r2 = e2[n2].length;
        if (r2 > 65535)
          throw "extra field too long";
        t2 += r2 + 4;
      }
    return t2;
  }, gs = function(e2, t2, n2, r2, i2, s2, o2, a2) {
    var l2 = r2.length, c2 = n2.extra, u2 = a2 && a2.length, p2 = _s(c2);
    wi(e2, t2, null != o2 ? 33639248 : 67324752), t2 += 4, null != o2 && (e2[t2++] = 20, e2[t2++] = n2.os), e2[t2] = 20, t2 += 2, e2[t2++] = n2.flag << 1 | (null == s2 && 8), e2[t2++] = i2 && 8, e2[t2++] = 255 & n2.compression, e2[t2++] = n2.compression >> 8;
    var d2 = new Date(null == n2.mtime ? Date.now() : n2.mtime), h2 = d2.getFullYear() - 1980;
    if (h2 < 0 || h2 > 119)
      throw "date not in range 1980-2099";
    if (wi(e2, t2, h2 << 25 | d2.getMonth() + 1 << 21 | d2.getDate() << 16 | d2.getHours() << 11 | d2.getMinutes() << 5 | d2.getSeconds() >>> 1), t2 += 4, null != s2 && (wi(e2, t2, n2.crc), wi(e2, t2 + 4, s2), wi(e2, t2 + 8, n2.size)), wi(e2, t2 + 12, l2), wi(e2, t2 + 14, p2), t2 += 16, null != o2 && (wi(e2, t2, u2), wi(e2, t2 + 6, n2.attrs), wi(e2, t2 + 10, o2), t2 += 14), e2.set(r2, t2), t2 += l2, p2)
      for (var f2 in c2) {
        var m2 = c2[f2], _2 = m2.length;
        wi(e2, t2, +f2), wi(e2, t2 + 2, _2), e2.set(m2, t2 + 4), t2 += 4 + _2;
      }
    return u2 && (e2.set(a2, t2), t2 += u2), t2;
  }, vs = function(e2, t2, n2, r2, i2) {
    wi(e2, t2, 101010256), wi(e2, t2 + 8, n2), wi(e2, t2 + 10, n2), wi(e2, t2 + 12, r2), wi(e2, t2 + 16, i2);
  }, ys = function() {
    function e2(e3) {
      this.filename = e3, this.c = ei(), this.size = 0, this.compression = 0;
    }
    return e2.prototype.process = function(e3, t2) {
      this.ondata(null, e3, t2);
    }, e2.prototype.push = function(e3, t2) {
      if (!this.ondata)
        throw "no callback - add to ZIP archive before pushing";
      this.c.p(e3), this.size += e3.length, t2 && (this.crc = this.c.d()), this.process(e3, t2 || false);
    }, e2;
  }(), bs = function() {
    function e2(e3, t2) {
      var n2 = this;
      t2 || (t2 = {}), ys.call(this, e3), this.d = new Pi(t2, function(e4, t3) {
        n2.ondata(null, e4, t3);
      }), this.compression = 8, this.flag = ds(t2.level);
    }
    return e2.prototype.process = function(e3, t2) {
      try {
        this.d.push(e3, t2);
      } catch (e4) {
        this.ondata(e4, null, t2);
      }
    }, e2.prototype.push = function(e3, t2) {
      ys.prototype.push.call(this, e3, t2);
    }, e2;
  }(), ws = function() {
    function e2(e3, t2) {
      var n2 = this;
      t2 || (t2 = {}), ys.call(this, e3), this.d = new Ii(t2, function(e4, t3, r2) {
        n2.ondata(e4, t3, r2);
      }), this.compression = 8, this.flag = ds(t2.level), this.terminate = this.d.terminate;
    }
    return e2.prototype.process = function(e3, t2) {
      this.d.push(e3, t2);
    }, e2.prototype.push = function(e3, t2) {
      ys.prototype.push.call(this, e3, t2);
    }, e2;
  }(), As = function() {
    function e2(e3) {
      this.ondata = e3, this.u = [], this.d = 1;
    }
    return e2.prototype.add = function(e3) {
      var t2 = this;
      if (2 & this.d)
        throw "stream finished";
      var n2 = us(e3.filename), r2 = n2.length, i2 = e3.comment, s2 = i2 && us(i2), o2 = r2 != e3.filename.length || s2 && i2.length != s2.length, a2 = r2 + _s(e3.extra) + 30;
      if (r2 > 65535)
        throw "filename too long";
      var l2 = new hr(a2);
      gs(l2, 0, e3, n2, o2);
      var c2 = [l2], u2 = function() {
        for (var e4 = 0, n3 = c2; e4 < n3.length; e4++) {
          var r3 = n3[e4];
          t2.ondata(null, r3, false);
        }
        c2 = [];
      }, p2 = this.d;
      this.d = 0;
      var d2 = this.u.length, h2 = ri(e3, { f: n2, u: o2, o: s2, t: function() {
        e3.terminate && e3.terminate();
      }, r: function() {
        if (u2(), p2) {
          var e4 = t2.u[d2 + 1];
          e4 ? e4.r() : t2.d = 1;
        }
        p2 = 1;
      } }), f2 = 0;
      e3.ondata = function(n3, r3, i3) {
        if (n3)
          t2.ondata(n3, r3, i3), t2.terminate();
        else if (f2 += r3.length, c2.push(r3), i3) {
          var s3 = new hr(16);
          wi(s3, 0, 134695760), wi(s3, 4, e3.crc), wi(s3, 8, f2), wi(s3, 12, e3.size), c2.push(s3), h2.c = f2, h2.b = a2 + f2 + 16, h2.crc = e3.crc, h2.size = e3.size, p2 && h2.r(), p2 = 1;
        } else
          p2 && u2();
      }, this.u.push(h2);
    }, e2.prototype.end = function() {
      var e3 = this;
      if (2 & this.d) {
        if (1 & this.d)
          throw "stream finishing";
        throw "stream finished";
      }
      this.d ? this.e() : this.u.push({ r: function() {
        1 & e3.d && (e3.u.splice(-1, 1), e3.e());
      }, t: function() {
      } }), this.d = 3;
    }, e2.prototype.e = function() {
      for (var e3 = 0, t2 = 0, n2 = 0, r2 = 0, i2 = this.u; r2 < i2.length; r2++)
        n2 += 46 + (l2 = i2[r2]).f.length + _s(l2.extra) + (l2.o ? l2.o.length : 0);
      for (var s2 = new hr(n2 + 22), o2 = 0, a2 = this.u; o2 < a2.length; o2++) {
        var l2 = a2[o2];
        gs(s2, e3, l2, l2.f, l2.u, l2.c, t2, l2.o), e3 += 46 + l2.f.length + _s(l2.extra) + (l2.o ? l2.o.length : 0), t2 += l2.b;
      }
      vs(s2, e3, this.u.length, n2, t2), this.ondata(null, s2, true), this.d = 2;
    }, e2.prototype.terminate = function() {
      for (var e3 = 0, t2 = this.u; e3 < t2.length; e3++)
        t2[e3].t();
      this.d = 2;
    }, e2;
  }();
  function xs(e2, t2, n2) {
    if (n2 || (n2 = t2, t2 = {}), "function" != typeof n2)
      throw "no callback";
    var r2 = {};
    rs(e2, "", r2, t2);
    var i2 = Object.keys(r2), s2 = i2.length, o2 = 0, a2 = 0, l2 = s2, c2 = new Array(s2), u2 = [], p2 = function() {
      for (var e3 = 0; e3 < u2.length; ++e3)
        u2[e3]();
    }, d2 = function() {
      var e3 = new hr(a2 + 22), t3 = o2, r3 = a2 - o2;
      a2 = 0;
      for (var i3 = 0; i3 < l2; ++i3) {
        var s3 = c2[i3];
        try {
          var u3 = s3.c.length;
          gs(e3, a2, s3, s3.f, s3.u, u3);
          var p3 = 30 + s3.f.length + _s(s3.extra), d3 = a2 + p3;
          e3.set(s3.c, d3), gs(e3, o2, s3, s3.f, s3.u, u3, a2, s3.m), o2 += 16 + p3 + (s3.m ? s3.m.length : 0), a2 = d3 + u3;
        } catch (e4) {
          return n2(e4, null);
        }
      }
      vs(e3, o2, c2.length, r3, t3), n2(null, e3);
    };
    s2 || d2();
    for (var h2 = function(e3) {
      var t3 = i2[e3], l3 = r2[t3], h3 = l3[0], f3 = l3[1], m2 = ei(), _2 = h3.length;
      m2.p(h3);
      var g2 = us(t3), v2 = g2.length, y2 = f3.comment, b2 = y2 && us(y2), w2 = b2 && b2.length, A2 = _s(f3.extra), x2 = 0 == f3.level ? 0 : 8, E2 = function(r3, i3) {
        if (r3)
          p2(), n2(r3, null);
        else {
          var l4 = i3.length;
          c2[e3] = ri(f3, { size: _2, crc: m2.d(), c: i3, f: g2, m: b2, u: v2 != t3.length || b2 && y2.length != w2, compression: x2 }), o2 += 30 + v2 + A2 + l4, a2 += 76 + 2 * (v2 + A2) + (w2 || 0) + l4, --s2 || d2();
        }
      };
      if (v2 > 65535 && E2("filename too long", null), x2)
        if (_2 < 16e4)
          try {
            E2(null, ki(h3, f3));
          } catch (e4) {
            E2(e4, null);
          }
        else
          u2.push(Ri(h3, f3, E2));
      else
        E2(null, h3);
    }, f2 = 0; f2 < l2; ++f2)
      h2(f2);
    return p2;
  }
  function Es(e2, t2) {
    t2 || (t2 = {});
    var n2 = {}, r2 = [];
    rs(e2, "", n2, t2);
    var i2 = 0, s2 = 0;
    for (var o2 in n2) {
      var a2 = n2[o2], l2 = a2[0], c2 = a2[1], u2 = 0 == c2.level ? 0 : 8, p2 = (x2 = us(o2)).length, d2 = c2.comment, h2 = d2 && us(d2), f2 = h2 && h2.length, m2 = _s(c2.extra);
      if (p2 > 65535)
        throw "filename too long";
      var _2 = u2 ? ki(l2, c2) : l2, g2 = _2.length, v2 = ei();
      v2.p(l2), r2.push(ri(c2, { size: l2.length, crc: v2.d(), c: _2, f: x2, m: h2, u: p2 != o2.length || h2 && d2.length != f2, o: i2, compression: u2 })), i2 += 30 + p2 + m2 + g2, s2 += 76 + 2 * (p2 + m2) + (f2 || 0) + g2;
    }
    for (var y2 = new hr(s2 + 22), b2 = i2, w2 = s2 - i2, A2 = 0; A2 < r2.length; ++A2) {
      var x2 = r2[A2];
      gs(y2, x2.o, x2, x2.f, x2.u, x2.c.length);
      var E2 = 30 + x2.f.length + _s(x2.extra);
      y2.set(x2.c, x2.o + E2), gs(y2, i2, x2, x2.f, x2.u, x2.c.length, x2.o, x2.m), i2 += 16 + E2 + (x2.m ? x2.m.length : 0);
    }
    return vs(y2, i2, r2.length, w2, b2), y2;
  }
  var Cs = function() {
    function e2() {
    }
    return e2.prototype.push = function(e3, t2) {
      this.ondata(null, e3, t2);
    }, e2.compression = 0, e2;
  }(), Ss = function() {
    function e2() {
      var e3 = this;
      this.i = new Di(function(t2, n2) {
        e3.ondata(null, t2, n2);
      });
    }
    return e2.prototype.push = function(e3, t2) {
      try {
        this.i.push(e3, t2);
      } catch (n2) {
        this.ondata(n2, e3, t2);
      }
    }, e2.compression = 8, e2;
  }(), Ms = function() {
    function e2(e3, t2) {
      var n2 = this;
      t2 < 32e4 ? this.i = new Di(function(e4, t3) {
        n2.ondata(null, e4, t3);
      }) : (this.i = new Bi(function(e4, t3, r2) {
        n2.ondata(e4, t3, r2);
      }), this.terminate = this.i.terminate);
    }
    return e2.prototype.push = function(e3, t2) {
      this.i.terminate && (e3 = jr(e3, 0)), this.i.push(e3, t2);
    }, e2.compression = 8, e2;
  }(), Ts = function() {
    function e2(e3) {
      this.onfile = e3, this.k = [], this.o = { 0: Cs }, this.p = Jr;
    }
    return e2.prototype.push = function(e3, t2) {
      var n2 = this;
      if (!this.onfile)
        throw "no callback";
      if (!this.p)
        throw "stream finished";
      if (this.c > 0) {
        var r2 = Math.min(this.c, e3.length), i2 = e3.subarray(0, r2);
        if (this.c -= r2, this.d ? this.d.push(i2, !this.c) : this.k[0].push(i2), (e3 = e3.subarray(r2)).length)
          return this.push(e3, t2);
      } else {
        var s2 = 0, o2 = 0, a2 = void 0, l2 = void 0;
        this.p.length ? e3.length ? ((l2 = new hr(this.p.length + e3.length)).set(this.p), l2.set(e3, this.p.length)) : l2 = this.p : l2 = e3;
        for (var c2 = l2.length, u2 = this.c, p2 = u2 && this.d, d2 = function() {
          var e4, t3 = yi(l2, o2);
          if (67324752 == t3) {
            s2 = 1, a2 = o2, h2.d = null, h2.c = 0;
            var r3 = vi(l2, o2 + 6), i3 = vi(l2, o2 + 8), p3 = 2048 & r3, d3 = 8 & r3, f3 = vi(l2, o2 + 26), m2 = vi(l2, o2 + 28);
            if (c2 > o2 + 30 + f3 + m2) {
              var _2 = [];
              h2.k.unshift(_2), s2 = 2;
              var g2, v2 = yi(l2, o2 + 18), y2 = yi(l2, o2 + 22), b2 = ps(l2.subarray(o2 + 30, o2 += 30 + f3), !p3);
              4294967295 == v2 ? (e4 = d3 ? [-2] : ms(l2, o2), v2 = e4[0], y2 = e4[1]) : d3 && (v2 = -1), o2 += m2, h2.c = v2;
              var w2 = { name: b2, compression: i3, start: function() {
                if (!w2.ondata)
                  throw "no callback";
                if (v2) {
                  var e5 = n2.o[i3];
                  if (!e5)
                    throw "unknown compression type " + i3;
                  (g2 = v2 < 0 ? new e5(b2) : new e5(b2, v2, y2)).ondata = function(e6, t5, n3) {
                    w2.ondata(e6, t5, n3);
                  };
                  for (var t4 = 0, r4 = _2; t4 < r4.length; t4++) {
                    var s3 = r4[t4];
                    g2.push(s3, false);
                  }
                  n2.k[0] == _2 && n2.c ? n2.d = g2 : g2.push(Jr, true);
                } else
                  w2.ondata(null, Jr, true);
              }, terminate: function() {
                g2 && g2.terminate && g2.terminate();
              } };
              v2 >= 0 && (w2.size = v2, w2.originalSize = y2), h2.onfile(w2);
            }
            return "break";
          }
          if (u2) {
            if (134695760 == t3)
              return a2 = o2 += 12 + (-2 == u2 && 8), s2 = 3, h2.c = 0, "break";
            if (33639248 == t3)
              return a2 = o2 -= 4, s2 = 3, h2.c = 0, "break";
          }
        }, h2 = this; o2 < c2 - 4 && "break" !== d2(); ++o2)
          ;
        if (this.p = Jr, u2 < 0) {
          var f2 = s2 ? l2.subarray(0, a2 - 12 - (-2 == u2 && 8) - (134695760 == yi(l2, a2 - 16) && 4)) : l2.subarray(0, o2);
          p2 ? p2.push(f2, !!s2) : this.k[+(2 == s2)].push(f2);
        }
        if (2 & s2)
          return this.push(l2.subarray(o2), t2);
        this.p = l2.subarray(o2);
      }
      if (t2) {
        if (this.c)
          throw "invalid zip file";
        this.p = null;
      }
    }, e2.prototype.register = function(e3) {
      this.o[e3.compression] = e3;
    }, e2;
  }();
  function Ps(e2, t2) {
    if ("function" != typeof t2)
      throw "no callback";
    for (var n2 = [], r2 = function() {
      for (var e3 = 0; e3 < n2.length; ++e3)
        n2[e3]();
    }, i2 = {}, s2 = e2.length - 22; 101010256 != yi(e2, s2); --s2)
      if (!s2 || e2.length - s2 > 65558)
        return void t2("invalid zip file", null);
    var o2 = vi(e2, s2 + 8);
    o2 || t2(null, {});
    var a2 = o2, l2 = yi(e2, s2 + 16), c2 = 4294967295 == l2;
    if (c2) {
      if (s2 = yi(e2, s2 - 12), 101075792 != yi(e2, s2))
        return void t2("invalid zip file", null);
      a2 = o2 = yi(e2, s2 + 32), l2 = yi(e2, s2 + 48);
    }
    for (var u2 = function(s3) {
      var a3 = fs(e2, l2, c2), u3 = a3[0], p3 = a3[1], d2 = a3[2], h2 = a3[3], f2 = a3[4], m2 = a3[5], _2 = hs(e2, m2);
      l2 = f2;
      var g2 = function(e3, n3) {
        e3 ? (r2(), t2(e3, null)) : (i2[h2] = n3, --o2 || t2(null, i2));
      };
      if (u3)
        if (8 == u3) {
          var v2 = e2.subarray(_2, _2 + p3);
          if (p3 < 32e4)
            try {
              g2(null, Li(v2, new hr(d2)));
            } catch (e3) {
              g2(e3, null);
            }
          else
            n2.push(Oi(v2, { size: d2 }, g2));
        } else
          g2("unknown compression type " + u3, null);
      else
        g2(null, jr(e2, _2, _2 + p3));
    }, p2 = 0; p2 < a2; ++p2)
      u2();
    return r2;
  }
  function Is(e2) {
    for (var t2 = {}, n2 = e2.length - 22; 101010256 != yi(e2, n2); --n2)
      if (!n2 || e2.length - n2 > 65558)
        throw "invalid zip file";
    var r2 = vi(e2, n2 + 8);
    if (!r2)
      return {};
    var i2 = yi(e2, n2 + 16), s2 = 4294967295 == i2;
    if (s2) {
      if (n2 = yi(e2, n2 - 12), 101075792 != yi(e2, n2))
        throw "invalid zip file";
      r2 = yi(e2, n2 + 32), i2 = yi(e2, n2 + 48);
    }
    for (var o2 = 0; o2 < r2; ++o2) {
      var a2 = fs(e2, i2, s2), l2 = a2[0], c2 = a2[1], u2 = a2[2], p2 = a2[3], d2 = a2[4], h2 = a2[5], f2 = hs(e2, h2);
      if (i2 = d2, l2) {
        if (8 != l2)
          throw "unknown compression type " + l2;
        t2[p2] = Li(e2.subarray(f2, f2 + c2), new hr(u2));
      } else
        t2[p2] = jr(e2, f2, f2 + c2);
    }
    return t2;
  }
  class Rs extends n.hH6 {
    load(e2, t2, n2, r2) {
      return this.setResponseType("arraybuffer"), super.load(e2, (e3) => {
        const n3 = Is(new Uint8Array(e3)), r3 = new Map(Object.entries(n3).map(([e4, t3]) => [e4, new File([t3], e4)]));
        null == t2 || t2(r3);
      }, n2, r2);
    }
  }
  class ks extends t.SimpleEventDispatcher {
    get cachedAssets() {
      return this._cachedAssets;
    }
    get processors() {
      return this._processors;
    }
    get loadingManager() {
      return this._loadingManager;
    }
    constructor(e2, t2 = false) {
      super(), this._processors = new zt(), this._logger = console.log, this.Importers = [new Ft(Gt, ["json"], false), new Ft(n.hH6, ["txt"], false), new Ft(Fn, ["rgbe.png", "hdr.png", "hdrpng"], false), new Ft(n.dpR, ["webp", "png", "jpeg", "jpg", "svg", "data:image"], false), new Ft(pr, ["cube"], false), new Ft(Rs, ["zip"], true)], this._loaderCache = [], this._fileDatabase = /* @__PURE__ */ new Map(), this._cachedAssets = [], t2 || (this._logger = () => {
      }), this._viewer = e2, this._onLoad = this._onLoad.bind(this), this._onProgress = this._onProgress.bind(this), this._onError = this._onError.bind(this), this._onStart = this._onStart.bind(this), this._urlModifier = this._urlModifier.bind(this), this._loadingManager = new n.lLk(this._onLoad, this._onProgress, this._onError), this._loadingManager.onStart = this._onStart, this._loadingManager.setURLModifier(this._urlModifier), this.Importers.push(Ht(e2)), this.Importers.push(zn(e2)), this.Importers.push(ir());
    }
    _onLoad() {
      this.dispatchEvent({ type: "onLoad" });
    }
    _onProgress(e2, t2, n2) {
      this.dispatchEvent({ type: "onProgress", url: e2, loaded: t2, total: n2 });
    }
    _onError(e2) {
      this.dispatchEvent({ type: "onError", url: e2 });
    }
    _onStart(e2, t2, n2) {
      this.dispatchEvent({ type: "onStart", url: e2, loaded: t2, total: n2 });
    }
    _urlModifier(e2) {
      var t2;
      let n2 = decodeURI(e2);
      const r2 = null === (t2 = this._rootContext) || void 0 === t2 ? void 0 : t2.rootUrl;
      n2.includes("://") || !r2 || n2.startsWith(r2) || (n2 = r2 + n2), n2 = n2.replace("./", ""), n2 = n2.replace(/^(\/\/)/, "/"), n2 = n2.replace(/\?.*$/, "");
      const i2 = this._fileDatabase.get(n2);
      return i2 ? i2.ext ? (i2.objectUrl || (i2.objectUrl = URL.createObjectURL(i2) + "#" + n2), i2.objectUrl) : (console.error("Unable to determine file extension", i2), e2) : e2;
    }
    _createLoader(e2) {
      const t2 = this._getImporter(e2), n2 = null == t2 ? void 0 : t2.ctor(this);
      return n2 && (null == t2 || t2.ext.forEach((e3) => {
        const t3 = new RegExp(e3.startsWith("data:") ? "^" + e3 + "\\/" : "\\." + e3 + "$", "i");
        this._loadingManager.addHandler(t3, n2);
      })), n2 && (this._loaderCache.push({ loader: n2, files: [] }), this.dispatchEvent({ type: "loaderCreate", loader: n2 })), n2;
    }
    addEventListener(e2, t2) {
      if (super.addEventListener(e2, t2), "loaderCreate" === e2)
        for (const e3 of this._loaderCache)
          this.dispatchEvent({ type: "loaderCreate", loader: e3.loader });
    }
    async importFiles(e2, t2 = {}) {
      const n2 = /* @__PURE__ */ new Map();
      let { allowedExtensions: r2 } = t2;
      if (r2 && r2.length < 1 && (r2 = void 0), 0 === e2.size)
        return n2;
      this.dispatchEvent({ type: "importFiles", files: Object.keys(e2), state: "start" });
      const i2 = [], s2 = [];
      if (e2.forEach((e3, t3) => {
        var n3;
        this.registerFile(t3, e3);
        const o2 = e3.ext;
        o2 && (null === (n3 = null == r2 ? void 0 : r2.includes(o2.toLowerCase())) || void 0 === n3 || n3) && (this._isRootFileExtension(o2) ? i2.push(t3) : s2.push(t3));
      }), i2.length > 0)
        for (const e3 of i2) {
          let r3 = await this._importFile(e3, void 0, t2);
          r3 && (r3 = await this.processImported(r3, t2)), n2.set(e3, r3);
        }
      else
        for (const e3 of s2) {
          let r3 = await this._importFile(e3, void 0, t2);
          r3 && (r3 = await this.processImported(r3, t2)), n2.set(e3, r3);
        }
      return this.dispatchEvent({ type: "importFiles", files: Object.keys(e2), state: "end" }), e2.forEach((e3, t3) => {
        this.unregisterFile(t3);
      }), n2;
    }
    registerFile(e2, n2) {
      var r2, i2, s2;
      e2 = e2.replace(/\?.*$/, "");
      const o2 = null !== (r2 = null == n2 ? void 0 : n2.ext) && void 0 !== r2 ? r2 : null === (s2 = (0, t.parseFileExtension)(null !== (i2 = null == n2 ? void 0 : n2.name) && void 0 !== i2 ? i2 : e2.trim())) || void 0 === s2 ? void 0 : s2.toLowerCase();
      n2 && (n2.ext || (n2.ext = o2), this._fileDatabase.set(e2, n2));
      let a2 = this._getLoader(e2);
      if (a2 || (a2 = this._createLoader(null != n2 ? n2 : { name: e2, ext: o2 })), a2) {
        for (const t2 of this._loaderCache)
          if (t2.loader === a2) {
            t2.files.push(e2);
            break;
          }
      }
      return a2;
    }
    unregisterFile(e2) {
      e2 = e2.replace(/\?.*$/, "");
      const t2 = this._fileDatabase.get(e2);
      (null == t2 ? void 0 : t2.objectUrl) && (URL.revokeObjectURL(t2.objectUrl), t2.objectUrl = void 0), t2 && this._fileDatabase.delete(e2);
    }
    _isRootFileExtension(e2) {
      return null != this.Importers.find((t2) => t2.root && t2.ext.includes(e2.toLowerCase()));
    }
    resolveURL(e2) {
      return this._loadingManager.resolveURL(e2);
    }
    async _importFile(e2, t2, r2 = {}, i2) {
      var s2, o2;
      if (null == t2 ? void 0 : t2.__imported)
        return t2.__imported;
      let a2;
      this.dispatchEvent({ type: "importFile", path: e2, state: "downloading", progress: 0 });
      try {
        this.registerFile(e2, t2);
        const o3 = this.resolveURL(e2), l2 = e2.replace(/\?.*$/, "").trim(), c2 = null !== (s2 = r2.fileHandler) && void 0 !== s2 ? s2 : await this._loadingManager.getHandler(l2) || (t2 ? await this._loadingManager.getHandler(t2.name || t2.ext || "") : void 0);
        if (!c2)
          throw new Error("AssetImporter: Unable to find loader for " + e2);
        this._rootContext = { path: e2, url: o3, rootUrl: n.Zp0.extractUrlBase(e2), baseUrl: n.Zp0.extractUrlBase(o3) }, a2 = await c2.loadAsync(e2 + (r2.queryString ? (e2.includes("?") ? "&" : "?") + r2.queryString : ""), (t3) => {
          i2 && i2(t3), this.dispatchEvent({ type: "importFile", path: e2, state: "downloading", loadedBytes: t3.loaded || void 0, totalBytes: t3.total || void 0, progress: t3.total > 0 ? t3.loaded / t3.total : 1 });
        }), c2.transform && (a2 = await c2.transform(a2, r2)), this._rootContext = void 0, this.dispatchEvent({ type: "importFile", path: e2, state: "downloading", progress: 1 }), this.dispatchEvent({ type: "importFile", path: e2, state: "adding" }), t2 ? this._logger("AssetImporter: loaded", e2) : this._logger("AssetImporter: downloaded", e2), t2 && this.unregisterFile(e2);
      } catch (n2) {
        return console.error("AssetImporter: Unable to import file", e2, t2), console.error(n2), console.error(null == n2 ? void 0 : n2.stack), this.dispatchEvent({ type: "importFile", path: e2, state: "error", error: n2 }), t2 && this.unregisterFile(e2), [];
      }
      if (this.dispatchEvent({ type: "importFile", path: e2, state: "done" }), t2 && a2) {
        t2.__imported = a2;
        let e3 = [];
        Array.isArray(a2) ? e3 = a2 : (null === (o2 = a2.userData) || void 0 === o2 ? void 0 : o2.rootSceneModelRoot) ? e3.push(...a2.children) : e3.push(a2), e3.forEach((e4) => {
          e4.addEventListener && e4.addEventListener("dispose", () => {
            t2.__imported = void 0;
          });
        });
      }
      if (a2 && "object" == typeof a2) {
        a2.__rootPath = e2;
        const n2 = t2 || this._fileDatabase.get(e2);
        n2 && (a2.__rootBlob = n2);
      }
      return a2;
    }
    _getImporter(e2, t2 = false) {
      return this.Importers.find((n2) => {
        if (t2 && !n2.root)
          return false;
        const r2 = n2.ext.find((t3) => {
          var n3, r3, i2;
          return e2.ext && t3 === e2.ext.toLowerCase() || (null === (r3 = null === (n3 = e2.name) || void 0 === n3 ? void 0 : n3.toLowerCase()) || void 0 === r3 ? void 0 : r3.endsWith("." + t3.toLowerCase())) || (null == t3 ? void 0 : t3.startsWith("data:")) && (null === (i2 = e2.name) || void 0 === i2 ? void 0 : i2.startsWith(t3));
        });
        return !!r2 && (e2.ext = r2, true);
      });
    }
    _getLoader(e2) {
      var t2;
      return null !== (t2 = this._loadingManager.getHandler(e2.trim())) && void 0 !== t2 ? t2 : void 0;
    }
    async importAsset(e2, t2 = {}, n2) {
      var r2, i2, s2;
      if (!e2)
        return [];
      if (!this._cachedAssets.includes(e2)) {
        if (1 === Object.entries(e2).length && e2.path) {
          const t4 = this._cachedAssets.find((t5) => t5.path === e2.path);
          t4 && Object.assign(e2, t4);
        }
        const t3 = this._cachedAssets.findIndex((t4) => t4.path === e2.path);
        t3 >= 0 && this._cachedAssets.splice(t3, 1), this._cachedAssets.push(e2);
      }
      let o2;
      if ((null == e2 ? void 0 : e2.preImported) && (o2 = await e2.preImported), !t2.forceImport && o2) {
        const e3 = await this.processImported(o2, t2);
        let n3 = false;
        for (const t3 of e3) {
          if ((null === (r2 = t3.userData) || void 0 === r2 ? void 0 : r2.rootSceneModelRoot) && [...t3.children, ...t3.__processedChildren || []].find((e4) => e4.__disposed)) {
            n3 = true;
            break;
          }
          if (t3.__disposed) {
            n3 = true;
            break;
          }
        }
        if (!n3 || false === t2.reimportDisposed)
          return e3;
      }
      const a2 = t2.pathOverride || e2.path;
      if (e2.preImported = this._importFile(a2, "function" == typeof (null === (i2 = e2.file) || void 0 === i2 ? void 0 : i2.arrayBuffer) ? e2.file : void 0, t2, n2), o2 = await e2.preImported, o2 && (this.dispatchEvent({ type: "processFileStart", path: a2, result: o2 }), o2 = await this.processImported(o2, t2), this.dispatchEvent({ type: "processFileEnd", path: a2, result: o2 })), o2) {
        const t3 = [];
        Array.isArray(o2) ? t3.push(...o2) : (null === (s2 = o2.userData) || void 0 === s2 ? void 0 : s2.rootSceneModelRoot) ? t3.push(...o2.children) : t3.push(o2), t3.forEach((t4) => {
          var n3;
          return null === (n3 = t4.addEventListener) || void 0 === n3 ? void 0 : n3.call(t4, "dispose", () => {
            (null == e2 ? void 0 : e2.preImported) && (e2.preImported = void 0);
          });
        });
      }
      return o2;
    }
    async importSingle(e2, t2 = {}) {
      var n2;
      return "string" == typeof e2 ? await this.importSinglePath(e2, t2) : null === (n2 = await this.importAsset(e2, t2)) || void 0 === n2 ? void 0 : n2[0];
    }
    async importSinglePath(e2, t2) {
      var n2;
      return null === (n2 = await this.importPath(e2, t2)) || void 0 === n2 ? void 0 : n2[0];
    }
    async importPath(e2, t2 = {}) {
      const n2 = { ...t2 };
      delete n2.pathOverride, delete n2.forceImport, delete n2.reimportDisposed, delete n2.fileHandler, delete n2.importedFile;
      const r2 = JSON.stringify(n2);
      let i2;
      return i2 = this._cachedAssets.find((t3) => t3.path === e2 && t3._options === r2) || { path: e2 }, i2._options = r2, t2.importedFile && (i2.file = t2.importedFile), await this.importAsset(i2, t2);
    }
    async processImportedSingle(e2, t2 = {}) {
      return (await this.processImported(e2, t2))[0];
    }
    async processImported(e2, t2 = {}) {
      var r2, i2, s2, o2, a2, l2, c2, u2;
      let p2 = e2;
      if (!p2)
        return [];
      if (false === t2.processImported)
        return [p2];
      if (Array.isArray(p2)) {
        const e3 = [];
        for (const n2 of p2)
          e3.push(...await this.processImported(n2, t2));
        return e3;
      }
      if (null === (r2 = p2.userData) || void 0 === r2 ? void 0 : r2.rootSceneModelRoot) {
        if (t2._rootSceneImported = true, p2.__processedChildren && !t2.forceImporterReprocess)
          return p2.__processedChildren;
        if (!(p2.children.length < 1))
          return p2.animations && (p2.children[0].animations || (p2.children[0].animations = []), p2.children[0].animations.push(...p2.animations)), p2.__importedViewerConfig && (p2.children[0].__importedViewerConfig = p2.__importedViewerConfig), p2.userData.__importData && (p2.children[0].userData.__importData = p2.userData.__importData), p2.__processedChildren = await this.processImported([...p2.children], t2), p2.__processedChildren;
        if ((null === (i2 = p2.animations) || void 0 === i2 ? void 0 : i2.length) > 0 && console.error("AssetImporter: animations in empty scene not supported yet. animations will be ignored", p2.animations), !p2.__importedViewerConfig)
          return [];
        p2 = p2.__importedViewerConfig;
      }
      if ((null === (s2 = p2.userData) || void 0 === s2 ? void 0 : s2.iModel) && (p2 = p2.userData.iModel), (null === (o2 = p2.userData) || void 0 === o2 ? void 0 : o2.iMaterial) && (p2 = p2.userData.iMaterial), p2.assetImporterProcessed && !t2.forceImporterReprocess)
        return [p2];
      const d2 = p2.__rootPath, h2 = p2.__rootBlob;
      if (!p2.assetType) {
        if (p2.isBufferGeometry && (p2 = new n.Kj0(p2, new n.Wid())), p2.isObject3D)
          if (p2.isLight)
            p2 = Bs(p2);
          else {
            const e3 = [];
            p2.traverse((t3) => {
              t3 !== p2 && t3.isLight && e3.push(t3);
            });
            for (const t3 of e3)
              Bs(t3);
            p2 = new Nt(p2, t2);
          }
        p2.isTexture && (p2.assetType = "texture", t2._testDataTextureComplete && (p2.isDataTexture && (null === (a2 = p2.image) || void 0 === a2 ? void 0 : a2.data) && (p2.image.complete = true), (null === (l2 = p2.image) || void 0 === l2 ? void 0 : l2.complete) && (p2.needsUpdate = true)), void 0 !== t2.generateMipmaps && (p2.generateMipmaps = t2.generateMipmaps), p2.generateMipmaps || p2.isRenderTargetTexture || (p2.minFilter = p2.minFilter === n.D1R ? n.wem : p2.minFilter, p2.magFilter = p2.magFilter === n.D1R ? n.wem : p2.magFilter)), p2.isMaterial && (p2.assetType = "material");
      }
      if (null != p2.assetType)
        return p2.userData && (p2.userData.rootPath || !d2 || d2.startsWith("blob:") || d2.startsWith("/") || (p2.userData.rootPath = d2), h2 && (p2.userData.__sourceBlob = h2, p2.userData.__needsSourceBuffer && (p2.userData.__sourceBuffer = await h2.arrayBuffer(), delete p2.userData.__needsSourceBuffer))), p2 = await this._processors.process(p2.assetType, p2, {}), p2.assetImporterProcessed = true, [p2];
      if (p2 instanceof Map)
        return [...(await this.importFiles(p2, t2)).values()].flat();
      if (p2.type && "ViewerApp" !== p2.type && "ThreeViewer" !== p2.type) {
        const e3 = this._viewer.getPluginByType(p2.type);
        if (e3) {
          let t3 = p2._importedResources || {};
          return p2.resources && (t3 = await (null === (c2 = this._viewer.getManager()) || void 0 === c2 ? void 0 : c2.importConfigResources(p2.resources)), delete p2.resources, p2._importedResources = t3), "function" == typeof e3.fromJSON && (await Promise.resolve(e3.fromJSON(p2, t3)), p2.assetImporterProcessed = false), [];
        }
      }
      return p2.plugins || "ViewerApp" === p2.type || "ThreeViewer" === p2.type ? (p2.resources = await (null === (u2 = this._viewer.getManager()) || void 0 === u2 ? void 0 : u2.importConfigResources(p2.resources)), await this._viewer.getManager().importViewerConfig(p2), p2.assetImporterProcessed = false, []) : (console.warn("WebGi AssetImporter: unknown/null asset type: ", p2, p2.plugins), [p2]);
    }
    dispose() {
      var e2;
      this.clearCache(), null === (e2 = this._processors) || void 0 === e2 || e2.dispose();
    }
    clearLoaderCache() {
      this._loaderCache.forEach((e2) => {
        e2.loader.dispose && e2.loader.dispose();
      }), this._loaderCache = [];
    }
    clearCache() {
      this.clearLoaderCache(), this._cachedAssets = [];
    }
  }
  function Ds(e2) {
    if (!e2)
      return n.ywz;
    const t2 = e2.extensions.has("EXT_color_buffer_half_float") || e2.capabilities.isWebGL2 && e2.extensions.has("EXT_color_buffer_float"), r2 = e2.capabilities.isWebGL2 || e2.extensions.has("OES_texture_float") || e2.extensions.has("WEBGL_color_buffer_float");
    return t2 ? n.cLu : r2 ? n.VzW : n.ywz;
  }
  function Bs(e2) {
    var t2, n2;
    if (!e2.isLight)
      return e2;
    if ("light" === e2.assetType)
      return e2;
    if (e2.uiConfig)
      return console.warn("ui config already exists, not supported", e2), e2;
    let r2;
    if (e2.children.length, e2.isDirectionalLight && (r2 = new sr()), e2.isAmbientLight && (r2 = new lr()), e2.isSpotLight && (r2 = new or()), e2.isPointLight && (r2 = new ar()), r2) {
      null === (n2 = (t2 = r2.lightObject).copy) || void 0 === n2 || n2.call(t2, e2);
      const i2 = e2.parent;
      (null == i2 ? void 0 : i2.isObject3D) && (i2.remove(e2), e2.dispose(), e2.userData.iModel = r2, i2.add(r2.lightObject), r2.uuid = e2.uuid), ye(r2.lightObject, i2);
    } else
      console.warn("unknown light type: ", e2);
    return r2;
  }
  class Os extends n.u7G {
    constructor(e2) {
      super(e2);
    }
    async loadAsync(e2, t2) {
      var r2;
      const i2 = new n.hH6(this.manager);
      i2.setPath(this.path), i2.setRequestHeader(this.requestHeader), i2.setWithCredentials(this.withCredentials);
      const s2 = await i2.loadAsync(e2, t2);
      try {
        const e3 = JSON.parse(s2);
        if (e3.images && this.importer) {
          const t3 = {};
          let i3 = e3.images;
          Array.isArray(i3) || (i3 = Object.values(i3));
          for (const i4 of e3.images) {
            if (!i4.url || !i4.uuid)
              continue;
            const e4 = null === (r2 = await this.importer.importPath(i4.url, { processImported: false })) || void 0 === r2 ? void 0 : r2[0], s3 = null == e4 ? void 0 : e4.source;
            if (!e4 || !s3)
              continue;
            const o2 = new n.Hw6(s3.data);
            o2.uuid = i4.uuid, t3[o2.uuid] = o2, e4.dispose();
          }
          return await Nn.LoadRootPathTextures(e3.textures, t3 || e3.images, this.importer), this.parse(e3, t3);
        }
        return this.parse(e3);
      } catch (t3) {
        throw console.error(t3), this.manager.itemError(e2), t3;
      }
    }
    parse(e2, t2) {
      var n2, r2;
      let i2;
      const s2 = { p: new Promise((e3) => {
        i2 = e3;
      }) };
      if (e2.images || e2.textures) {
        const n3 = new Nn(this.manager);
        let r3 = {};
        const o3 = (e3) => {
          i2(), s2.p = void 0, Object.values(r3).forEach((e4) => {
            var t3;
            e4.isTexture && (null === (t3 = e4.image) || void 0 === t3 ? void 0 : t3.complete) && (e4.needsUpdate = true);
          });
        };
        let a3 = e2.images || [];
        Array.isArray(a3) || (a3 = Object.values(a3));
        const l3 = t2 || n3.parseImages(a3, o3);
        let c2 = e2.textures;
        Array.isArray(c2) || (c2 = Object.values(c2)), r3 = n3.parseTextures2(c2, l3, o3), this.setTextures(r3);
      }
      this.materials || console.warn("A Material Manager is not set to import three materials, trying standard materials");
      const o2 = { ...e2 };
      if (Object.entries(o2).forEach(([e3, t3]) => {
        t3 && "string" == typeof t3 && this.textures[t3] && (o2[e3] = this.textures[t3]);
      }), void 0 !== e2.vertexColors && ("number" == typeof e2.vertexColors ? o2.vertexColors = e2.vertexColors > 0 : o2.vertexColors = e2.vertexColors), void 0 !== e2.normalScale) {
        const t3 = e2.normalScale;
        false === Array.isArray(t3) && (o2.normalScale = [t3, t3]);
      }
      let a2 = e2.type;
      "MeshPhysicalMaterial" !== a2 && "MeshStandardMaterial" !== a2 && "PhysicalMaterial" !== a2 || (a2 = It.TYPE), o2.userData = ce(o2.userData, void 0, false, this);
      const l2 = null !== (r2 = null === (n2 = this.materials) || void 0 === n2 ? void 0 : n2.generateFromTemplateType(a2, o2)) && void 0 !== r2 ? r2 : super.parse(e2);
      return this.setTextures({}), l2.userData.imageLoadAwaiter = s2, l2;
    }
  }
  class Ls extends t.SimpleEventDispatcher {
    constructor(e2, t2, { simpleCache: r2 = false, storage: i2 } = {}) {
      if (super(), this._sceneUpdated = this._sceneUpdated.bind(this), this.addAsset = this.addAsset.bind(this), this.addProcessedAssets = this.addProcessedAssets.bind(this), this.addImported = this.addImported.bind(this), (r2 || i2) && (r2 && (n.CtF.enabled = true), i2 && window.Cache && "function" == typeof window.Cache && i2 instanceof window.Cache)) {
        const e3 = { ...n.CtF };
        n.CtF.get = (t3, n2, r3) => n2 ? t3.startsWith("data:") || t3.startsWith("blob") || t3.startsWith("chrome-extension") ? Promise.resolve(void 0) : i2.match(t3).then((e4) => {
          if (e4)
            switch (n2) {
              case "arraybuffer":
                return e4.arrayBuffer();
              case "blob":
                return e4.blob();
              case "document":
                return e4.text().then((e5) => new DOMParser().parseFromString(e5, null != r3 ? r3 : "text/html"));
              case "json":
                return e4.json();
              default:
                if (void 0 === r3)
                  return e4.text();
                {
                  const t4 = /charset="?([^;"\s]*)"?/i.exec(r3), n3 = t4 && t4[1] ? t4[1].toLowerCase() : void 0, i3 = new TextDecoder(n3);
                  return e4.arrayBuffer().then((e5) => i3.decode(e5));
                }
            }
        }) : e3.get(t3), n.CtF.add = async (t3, n2, r3) => {
          if (!r3)
            return e3.add(t3, n2);
          t3.startsWith("data:") || t3.startsWith("blob") || t3.startsWith("chrome-extension") || (await i2.match(t3) && await i2.delete(t3), await i2.put(t3, new Response(n2, { status: 200 })));
        }, n.CtF.remove = (t3, n2) => {
          if (!n2)
            return e3.remove(t3);
          i2.delete(t3);
        };
      }
      this.storage = i2, this._importer = e2, this._materials = t2;
    }
    async addAsset(e2, t2 = {}) {
      if (!this._importer || !this._viewer)
        return [];
      const n2 = await this._importer.importAsset(e2, t2);
      return n2 ? (this.addProcessedAssets(n2, t2), n2) : (console.warn("WebGi AssetManager: Unable to import", e2, n2), []);
    }
    async addFromPath(e2, t2 = {}) {
      if (!this._importer || !this._viewer)
        return [];
      const n2 = await this._importer.importPath(e2, t2);
      return n2 ? (this.addProcessedAssets(n2, t2), n2) : (e2 && !e2.split("?")[0].endsWith(".vjson") && console.warn("WebGi AssetManager: Unable to import", e2, n2), []);
    }
    addProcessedAssets(e2, t2) {
      return e2.map((n2) => {
        var r2;
        return null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.scene.addSceneObject(n2, { ...t2, allImported: e2 });
      });
    }
    async addAssetSingle(e2, t2 = {}) {
      var n2;
      return e2 ? null === (n2 = await ("string" == typeof e2 ? this.addFromPath : this.addAsset).call(this, e2, t2)) || void 0 === n2 ? void 0 : n2[0] : void 0;
    }
    async addImported(e2, t2 = {}) {
      var n2;
      return null === (n2 = this._importer) || void 0 === n2 ? void 0 : n2.processImported(e2, t2).then((e3) => (this.addProcessedAssets(e3, t2), e3));
    }
    async addImportedSingle(e2, t2 = {}) {
      return this.addImported(e2, t2).then((e3) => null == e3 ? void 0 : e3[0]);
    }
    _sceneUpdated(e2) {
      var t2;
      if ("addSceneObject" === e2.type) {
        const n2 = e2.object;
        "material" === n2.assetType && (null === (t2 = this._materials) || void 0 === t2 || t2.processMaterial(n2, {}));
      } else
        console.error("Unexpected");
    }
    onAdded(e2) {
      this._viewer = e2, this._materials || (this._materials = new Ut(), this._viewer.scene.addEventListener("addSceneObject", this._sceneUpdated)), this._importer || (this._importer = new ks(e2, !!e2.getPluginByType("debug")), this._importer.processors.add("model", { forAssetType: "model", process: (e3, t3) => (jt(e3, (e4) => {
        var t4;
        return null === (t4 = this._materials) || void 0 === t4 ? void 0 : t4.processModel(e4, { recursive: false });
      }), e3) }), this._importer.processors.add("model", { forAssetType: "model", process: this._materials.processModel }), this._importer.processors.add("material", { forAssetType: "material", process: (e3, t3) => {
        var r2;
        return (null === (r2 = this.materials) || void 0 === r2 ? void 0 : r2.findMaterial(e3.uuid)) && (console.warn("WebGi AssetManager: Material with same UUID already exists, creating new UUID"), e3.uuid = n.M8C.generateUUID(), e3.userData.uuid && (e3.userData.uuid = e3.uuid)), this._materials.processMaterial(e3, t3);
      } })), this._importer.Importers.push(new Ft(Os, [It.TypeSlug], false, (e3) => (e3 && (e3.materials = this._materials), e3 && (e3.importer = this._importer), e3)));
      const t2 = this.importViewerConfig.bind(this);
      this._importer.Importers.push(new Ft(class extends Gt {
        async loadAsync(e3, n2) {
          return t2(await super.loadAsync(e3, n2));
        }
      }, [Ls.ViewerTypeSlug], true));
    }
    onRemove(e2) {
      var t2, n2;
      e2 === this._viewer && (null === (t2 = this._importer) || void 0 === t2 || t2.dispose(), this._importer = void 0, this._viewer.scene.removeEventListener("addSceneObject", this._sceneUpdated), null === (n2 = this._materials) || void 0 === n2 || n2.dispose(), this._materials = void 0);
    }
    get importer() {
      return this._importer;
    }
    get exporter() {
      var e2, t2;
      return null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPluginByType("AssetExporterPlugin")) || void 0 === t2 ? void 0 : t2.exporter;
    }
    get materials() {
      return this._materials;
    }
    exportViewerConfig(e2 = true, n2) {
      if (!this._viewer)
        return {};
      const r2 = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, extras: {}, ...n2 }, i2 = this._viewer.toJSON(r2);
      return e2 || Object.values(r2).forEach((e3) => {
        e3 && Object.values(e3).forEach((e4) => {
          e4.url && (e4.url.data instanceof ArrayBuffer || Array.isArray(e4.url.data)) && ("Uint16Array" === e4.url.type ? (e4.url.data instanceof Uint16Array || (e4.url.data = new Uint16Array(e4.url.data)), e4.url.data = "data:application/octet-stream;base64," + (0, t.arrayBufferToBase64)(e4.url.data.buffer)) : "Uint8Array" === e4.url.type ? (e4.url.data instanceof Uint8Array || (e4.url.data = new Uint8Array(e4.url.data)), e4.url.data = "data:application/octet-stream;base64," + (0, t.arrayBufferToBase64)(e4.url.data.buffer)) : e4.url.data instanceof ArrayBuffer ? e4.url.data = "data:application/octet-stream;base64," + (0, t.arrayBufferToBase64)(e4.url.data.buffer) : console.warn("Unsupported buffer type", e4.url.type));
        });
      }), i2.resources = r2, i2;
    }
    exportPluginPresets(e2) {
      var t2;
      const n2 = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, extras: {} };
      return { plugins: null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.serializePlugins(n2, e2), resources: n2 };
    }
    exportPluginPreset(e2) {
      if (!e2.toJSON)
        return;
      const t2 = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, extras: {} }, n2 = e2.toJSON(t2);
      return n2.resources = t2, n2;
    }
    async importPluginPreset(e2, t2) {
      var n2;
      const r2 = e2.type;
      if (!(t2 = t2 || (null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.getPluginByType(r2))))
        return void console.warn(`WebGi: No plugin found for type ${r2} to import preset`);
      if (!t2.fromJSON)
        return void console.warn(`WebGi: Plugin ${r2} does not support importing presets`);
      const i2 = e2.resources || {};
      e2.resources && delete e2.resources;
      const s2 = await this.importConfigResources(i2);
      return await t2.fromJSON(e2, s2), s2 && (e2.resources = s2), t2;
    }
    async importViewerConfig(e2, t2) {
      if (!this._viewer || !this._importer)
        return void console.warn("WebGi: No viewer or importer");
      const n2 = await this.importConfigResources(e2.resources || {}, t2);
      this.applyViewerConfig(e2, n2);
    }
    applyViewerConfig(e2, t2) {
      var n2;
      if (this._viewer && this._importer)
        if ((t2 = t2 || e2.resources).__isLoadedResources) {
          this._viewer.fromJSON(e2, t2);
          for (const e3 of Object.values(t2.materials))
            e3.__useCount ? delete e3.__useCount : null === (n2 = this._materials) || void 0 === n2 || n2.unregisterMaterial(e3);
          for (const e3 of Object.values(t2.textures))
            e3.__useCount && delete e3.__useCount;
        } else
          console.error("Cannot load viewer config: resources not loaded", e2);
      else
        console.warn("WebGi: No viewer or importer");
    }
    async importConfigResources(e2, n2, r2) {
      var i2, s2, o2;
      if (!this._importer)
        throw "Importer not initialized yet.";
      if (e2.__isLoadedResources)
        return e2;
      const a2 = {};
      Object.values(e2).forEach((e3) => {
        e3 && Object.values(e3).forEach((e4) => {
          if (!e4 || !e4.url)
            return;
          if ("string" != typeof e4.url.data)
            return;
          const n3 = e4.url.data.match(/^data:.*;base64,(.*)$/);
          (null == n3 ? void 0 : n3[1]) ? e4.url.data = (0, t.base64ToArrayBuffer)(null == n3 ? void 0 : n3[1]) : ("Uint8Array" !== e4.url.type && console.error("Unsupported buffer type string for ", e4.url.type, "use base64"), e4.url.data = new TextEncoder().encode(e4.url.data).buffer);
        });
      }), n2 = null != n2 ? n2 : new Nn(this._importer.loadingManager), a2.animations = e2.animations ? n2.parseAnimations(e2.animations) : {}, r2 && r2.animations && (a2.animations = { ...a2.animations, ...r2.animations }), a2.shapes = e2.shapes ? n2.parseShapes(e2.shapes) : {}, r2 && r2.shapes && (a2.shapes = { ...a2.shapes, ...r2.shapes }), a2.geometries = e2.geometries ? n2.parseGeometries(e2.geometries, a2.shapes) : {}, r2 && r2.geometries && (a2.geometries = { ...a2.geometries, ...r2.geometries }), a2.images = e2.images ? await n2.parseImagesAsync(Object.values(e2.images)) : {}, r2 && r2.images && (a2.images = { ...a2.images, ...r2.images }), await Nn.LoadRootPathTextures(e2.textures, a2.images, this._importer), a2.textures = e2.textures ? n2.parseTextures2(Object.values(e2.textures), a2.images, () => {
        Object.values(a2.textures).forEach((e3) => {
          var t2;
          e3.isTexture && (null === (t2 = e3.image) || void 0 === t2 ? void 0 : t2.complete) && (e3.needsUpdate = true);
        });
      }) : {};
      for (const e3 of Object.entries(a2.textures))
        e3[1] = null === (i2 = await this._importer.processImported(e3[1], {})) || void 0 === i2 ? void 0 : i2[0], e3[1] ? a2.textures[e3[0]] = e3[1] : delete a2.textures[e3[0]];
      r2 && r2.textures && (a2.textures = { ...a2.textures, ...r2.textures });
      const l2 = e2.materials ? Object.values(e2.materials) : [];
      for (const e3 of l2)
        Object.entries(e3).forEach(([t2, n3]) => {
          n3 && n3.resource && n3.uuid && "textures" === n3.resource && (e3[t2] = n3.uuid);
        });
      if (a2.materials = n2.parseMaterials2(l2, a2.textures, this._materials), r2 && r2.materials && (a2.materials = { ...a2.materials, ...r2.materials }), e2.object && (a2.object = n2.parseObject(e2.object, a2.geometries, a2.materials, a2.textures, a2.animations), e2.skeletons && (a2.skeletons = n2.parseSkeletons(e2.skeletons, a2.object), n2.bindSkeletons(a2.object, a2.skeletons))), e2.extras) {
        a2.extras = e2.extras;
        for (const n3 of Object.values(e2.extras))
          if (n3.uuid && n3.url)
            if ("string" == typeof n3.url) {
              const e3 = await (null === (s2 = this._importer) || void 0 === s2 ? void 0 : s2.importPath(n3.url));
              (null == e3 ? void 0 : e3.length) > 0 && (a2.extras[n3.uuid] = e3[0]);
            } else if (n3.url.data) {
              const e3 = new File([(0, t.getTypedArray)(n3.url.type, n3.url.data)], n3.url.path), r3 = await (null === (o2 = this._importer) || void 0 === o2 ? void 0 : o2.importAsset({ path: e3.name, file: e3 }));
              (null == r3 ? void 0 : r3.length) > 0 && (a2.extras[n3.uuid] = r3[0]);
            } else
              console.warn("WebGi: invalid URL type while loading extra resource");
      }
      return r2 && r2.extras && (a2.extras = { ...a2.extras, ...r2.extras }), a2.__isLoadedResources = true, a2;
    }
  }
  Ls.PluginType = "AssetManager", Ls.ViewerTypeSlug = "vjson";
  class Us {
    get inputEl() {
      return this._inputEl;
    }
    get el() {
      return this._el;
    }
    constructor(e2, t2, n2) {
      this._el = e2, this._inputEl = t2, this._listeners = { drop: [], dropstart: [], droperror: [] }, this._onDragover = this._onDragover.bind(this), this._onDrop = this._onDrop.bind(this), this._onSelect = this._onSelect.bind(this), null == e2 || e2.addEventListener("dragover", this._onDragover, false), null == e2 || e2.addEventListener("drop", this._onDrop, false), null == t2 || t2.addEventListener("change", this._onSelect), n2 && Object.entries(n2).forEach(([e3, t3]) => t3 && this.on(e3, t3));
    }
    on(e2, t2) {
      return this._listeners[e2].push(t2), this;
    }
    _emit(e2, t2) {
      return this._listeners[e2].forEach((e3) => e3(t2)), this;
    }
    destroy() {
      const e2 = this._el, t2 = this._inputEl;
      null == e2 || e2.removeEventListener("dragover", this._onDragover), null == e2 || e2.removeEventListener("drop", this._onDrop), null == t2 || t2.removeEventListener("change", this._onSelect);
    }
    _onDrop(e2) {
      var t2, n2;
      e2.stopPropagation(), e2.preventDefault(), this._emit("dropstart");
      const r2 = Array.from((null === (t2 = e2.dataTransfer) || void 0 === t2 ? void 0 : t2.files) || []), i2 = Array.from((null === (n2 = e2.dataTransfer) || void 0 === n2 ? void 0 : n2.items) || []);
      if (0 !== r2.length || 0 !== i2.length)
        if (i2.length > 0) {
          const e3 = i2.map((e4) => e4.webkitGetAsEntry());
          this._loadNextEntry(/* @__PURE__ */ new Map(), e3);
        } else
          this._emit("drop", { files: new Map(r2.map((e3) => (e3.filePath = e3.name, [e3.filePath, e3]))) });
      else
        this._fail("Required drag-and-drop APIs are not supported in this browser.");
    }
    _onDragover(e2) {
      e2.stopPropagation(), e2.preventDefault(), e2.dataTransfer && (e2.dataTransfer.dropEffect = "copy");
    }
    _onSelect(e2) {
      var t2;
      if (!this._inputEl)
        return void console.warn("Invalid Dropzone event ", e2);
      this._emit("dropstart");
      const n2 = [].slice.call(null !== (t2 = this._inputEl.files) && void 0 !== t2 ? t2 : new FileList()), r2 = /* @__PURE__ */ new Map();
      n2.forEach((e3) => {
        e3.filePath = e3.webkitRelativePath || e3.name, r2.set(e3.filePath, e3);
      }), this._emit("drop", { files: r2 });
    }
    _loadNextEntry(e2, t2) {
      const n2 = t2.pop();
      if (n2)
        if (n2.isFile)
          n2.file((r2) => {
            r2.filePath = n2.fullPath, e2.set(n2.fullPath, r2), this._loadNextEntry(e2, t2);
          }, () => console.error("Could not load file: %s", n2.fullPath));
        else if (n2.isDirectory) {
          const r2 = n2.createReader(), i2 = (n3) => {
            n3.length ? (t2 = t2.concat(n3), r2.readEntries(i2)) : this._loadNextEntry(e2, t2);
          };
          r2.readEntries(i2);
        } else
          console.warn("Unknown asset type: " + n2.fullPath), this._loadNextEntry(e2, t2);
      else
        this._emit("drop", { files: e2 });
    }
    _fail(e2) {
      this._emit("droperror", { message: e2 });
    }
  }
  class Fs extends t.SimpleEventDispatcher {
    constructor(e2) {
      super(), this._domElement = e2, this._allowedExtensions = void 0, this.importerParams = { autoScale: true, autoScaleRadius: 2, pseudoCenter: false, autoCenter: true, autoImport: true, autoAdd: true, centerOffset: new n.Pa4(0.5, 0.5, 3) }, this.dependencies = [Ls], this.uiConfig = { type: "folder", label: "Drop Options", expanded: true, children: [{ label: "Auto Center", type: "checkbox", property: [this.importerParams, "autoCenter"], limitedUi: true }, { label: "Auto Scale", type: "checkbox", property: [this.importerParams, "autoScale"], limitedUi: true }, { label: "Auto scale radius", type: "slider", bounds: [0.5, 100], property: [this.importerParams, "autoScaleRadius"] }, { label: "Select local file", type: "button", value: () => this.promptForFile() }] };
    }
    onAdded(e2) {
      this._inputEl = document.createElement("input"), this._viewer = e2, this._inputEl.type = "file", this._dropzone = new Us(this._domElement || e2.canvas, this._inputEl, { drop: this._onFileDrop.bind(this) });
    }
    async _onFileDrop({ files: e2 }) {
      var t2, n2, r2, i2, s2, o2;
      if (!e2)
        return;
      const a2 = this._viewer;
      if (!a2)
        return;
      if (void 0 !== this._allowedExtensions)
        for (const r3 of e2.keys())
          this._allowedExtensions.includes(null !== (n2 = null === (t2 = r3.split(".").pop()) || void 0 === t2 ? void 0 : t2.toLowerCase()) && void 0 !== n2 ? n2 : "") || e2.delete(r3);
      if (e2.size < 1)
        return;
      const l2 = a2.getPlugin(Ls), c2 = { type: "drop", files: e2 };
      if (this.importerParams.autoImport) {
        const t3 = { allowedExtensions: this.allowedExtensions, ...this.importerParams };
        if (c2.imported = await (null === (r2 = l2.importer) || void 0 === r2 ? void 0 : r2.importFiles(e2, t3)), this.importerParams.autoAdd) {
          const e3 = null !== (o2 = [...null !== (s2 = null === (i2 = c2.imported) || void 0 === i2 ? void 0 : i2.values()) && void 0 !== s2 ? s2 : []].flat(2).filter((e4) => !!e4)) && void 0 !== o2 ? o2 : [];
          if (c2.assets = l2.addProcessedAssets(e3, { ...this.importerParams }), !t3._rootSceneImported)
            for (const e4 of c2.assets)
              e4.modelObject && e4.modelObject.dispatchEvent({ type: "select", value: e4.modelObject });
        }
      }
      this.dispatchEvent(c2);
    }
    promptForFile() {
      var e2;
      null === (e2 = this._inputEl) || void 0 === e2 || e2.click();
    }
    onRemove(e2) {
      var t2;
      null === (t2 = this._dropzone) || void 0 === t2 || t2.destroy(), this._dropzone = void 0, this._viewer = void 0;
    }
    get allowedExtensions() {
      return this._allowedExtensions;
    }
    set allowedExtensions(e2) {
      this._allowedExtensions = e2, this._inputEl && (this._inputEl.accept = e2 ? e2.map((e3) => "." + e3).join(", ") : "");
    }
  }
  Fs.PluginType = "Dropzone";
  var Ns = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  function js(e2) {
    return Object.getPrototypeOf(e2).constructor.PluginType;
  }
  class zs extends t.SimpleEventDispatcher {
    get useRgbm() {
      return this._useRgbm;
    }
    get screenShader() {
      return this._screenShader;
    }
    get useGBufferDepth() {
      return this._useGBufferDepth;
    }
    get isAntialiased() {
      return this._isAntialiased;
    }
    constructor({ isAntialiased: r2 = false, useRgbm: i2 = true, useGBufferDepth: s2 = false, screenShader: o2 = "", ...a2 }) {
      var l2;
      super(), this.console = console, this._state = e.None, this.plugins = {}, this._needsResize = false, this.resizeObserver = window.ResizeObserver ? new window.ResizeObserver((e2) => this.resize()) : void 0, this._lastSize = new n.FM8(), this._onContextRestore = (e2) => {
        this.enabled = true, this._canvas.width = this._lastSize.width, this._canvas.height = this._lastSize.height, this.resize(), this.scene.setDirty({ sceneUpdate: true, frameFade: false });
      }, this._onContextLost = (e2) => {
        this._lastSize.set(this._canvas.width, this._canvas.height), this._canvas.width = 2, this._canvas.height = 2, this.resize(), this.enabled = false;
      }, this.resize = () => {
        this._needsResize = true, this.setDirty();
      }, this._needsReset = true, this.enabled = true, this.renderEnabled = true, this._isRenderingFrame = false, this.maxFramePerLoop = 1, this.rendersPerFrame = 1, this._rawBackground = null, this._sceneEnvironmentChanged = () => {
        this._rawBackground === Gs && this.scene.setBackground(this.scene.getEnvironment());
      }, this._addSceneObject = (e2) => {
        var t2;
        if (!e2 || !e2.object)
          return;
        const n2 = e2.object.__importedViewerConfig || (null === (t2 = e2.object.modelObject) || void 0 === t2 ? void 0 : t2.__importedViewerConfig);
        if (!n2)
          return;
        const r3 = this.getManager();
        !function(e3, t3) {
          var n3;
          const r4 = (t3.version ? t3.version : "0.0.0").split(".").map((e4) => parseInt(e4));
          if ("ViewerApp" !== t3.type || 0 !== r4[0] || !(r4[1] < 7 || 7 === r4[1] && r4[2].toString()[0] < "6"))
            return;
          const i3 = /* @__PURE__ */ new Set();
          ((null === (n3 = e3.options) || void 0 === n3 ? void 0 : n3.allImported) ? e3.options.allImported : [e3.object]).forEach((e4) => e4.traverse((e5) => {
            e5.material && i3.add(e5.material);
          })), i3.forEach((e4) => {
            const t4 = e4.map;
            if (!t4)
              return;
            const n4 = t4.repeat, r5 = t4.offset, i4 = t4.center, s3 = t4.rotation;
            ["alphaMap", "aoMap", "bumpMap", "displacementMap", "emissiveMap", "lightMap", "metalnessMap", "normalMap", "roughnessMap", "transmissionMap"].forEach((t5) => {
              const o3 = e4[t5];
              o3 && (o3.repeat.copy(n4), o3.offset.copy(r5), o3.center.copy(i4), o3.rotation = s3, o3.needsUpdate = true);
            }), e4.needsUpdate = true;
          });
        }(e2, n2), r3 ? r3.applyViewerConfig(n2, n2.resources) : this.fromJSON(n2, n2.resources);
      }, this.alert = async (e2) => alert(e2), this.confirm = async (e2) => confirm(e2), this.prompt = async (e2, t2, n2 = true) => prompt(e2, t2), this._useRgbm = i2, this._useGBufferDepth = s2, this._screenShader = o2, this._canvas = a2.canvas || (0, t.createCanvasElement)();
      let c2 = a2.container;
      if (c2 && !a2.canvas && c2.appendChild(this._canvas), c2 || (c2 = null !== (l2 = this._canvas.parentElement) && void 0 !== l2 ? l2 : void 0), !c2)
        throw new Error("No container.");
      this._container = c2, this._animationLoop = this._animationLoop.bind(this), this.setDirty = this.setDirty.bind(this), this._setActiveCameraView = this._setActiveCameraView.bind(this), window.webGiViewers || (window.webGiViewers = []), window.webGiViewers.push(this), async function() {
        var e2;
        const n2 = window.location.href, r3 = "https://dev-sandbox.pixotronics.com/webgi/";
        if (!n2.startsWith(r3))
          return true;
        if (null !== (0, t.getUrlQueryParam)("noUpdate"))
          return true;
        const i3 = null === (e2 = n2.match(/\/webgi\/([0-9.a-zA-Z-]+)/)) || void 0 === e2 ? void 0 : e2[1], s3 = (await (await fetch(r3 + "version.txt")).text()).split("\n")[0];
        if (i3 && i3 !== s3) {
          if (confirm(`New version ${s3} is available, do you want to open?`)) {
            const e3 = window.location.href.replace(i3, s3);
            return window.location.href = e3, false;
          }
          window.location.href.includes("noUpdate") || (window.location.href += (window.location.href.includes("?") ? "&" : "?") + "noUpdate");
        }
      }();
      const u2 = new nt(void 0, void 0, this._canvas);
      u2.autoLookAtTarget = true, this.addEventListener("postFrame", () => {
        var e2, t2;
        const n2 = d2.scene.activeCamera;
        if (n2 && n2.interactionsEnabled) {
          const r3 = null === (e2 = this.getPluginByType("Progressive")) || void 0 === e2 ? void 0 : e2.postFrameConvergedRecordingDelta();
          if (void 0 !== r3 && 0 === r3)
            return;
          null === (t2 = n2.controls) || void 0 === t2 || t2.update();
        }
      }), this.scene = new it(u2), this.scene.addEventListener("environmentChanged", this._sceneEnvironmentChanged), this.scene.addEventListener("addSceneObject", this._addSceneObject), this.scene.addEventListener("setView", this._setActiveCameraView), this.scene.addEventListener("activateMain", this._setActiveCameraView), this._renderer = new fe({ canvas: this._canvas, animationLoop: this._animationLoop, targetOptions: { samples: r2 ? 4 : 0, colorSpace: i2 ? k : n.aCh, type: i2 ? n.ywz : n.cLu, depthBuffer: !s2, generateMipmaps: !!r2, minFilter: r2 ? n.FDw : n.wem } }), this._isAntialiased = r2 && this._renderer.isWebGL2;
      let p2 = true;
      this._renderer.rendererObject.userData || (p2 = false, this._renderer.rendererObject.userData = {}), this._renderer.rendererObject.userData.renderTransmissionPass = !p2;
      const d2 = this;
      this.renderFilter = { passId: "render", passObject: new At(this, p2), update() {
        const e2 = this.passObject;
        e2.scene = d2.scene.modelObject, e2.camera = d2.scene.renderCamera.cameraObject;
      } };
      const h2 = { passId: "screen", after: ["render"], required: ["render"], passObject: Vs(o2) };
      [this.renderFilter, h2].forEach((e2) => this._renderer.registerPass(e2)), this._renderer.pipeline = ["render", "screen"], this.scene.addEventListener("textureUpdate", (e2) => this.setDirty(this.scene, e2)), this.scene.addEventListener("sceneMaterialUpdate", (e2) => this.setDirty(this.scene, e2)), this.scene.addEventListener("sceneUpdate", (e2) => {
        this.setDirty(this.scene, e2), false !== e2.geometryChanged && this.renderer.resetShadows();
      }), this.scene.addEventListener("update", (e2) => this.setDirty(this.scene, e2)), this._renderer.addEventListener("update", (e2) => this.setDirty(this._renderer, e2)), this.resizeObserver && this.resizeObserver.observe(this._canvas), window && window.addEventListener("resize", this.resize), this._canvas.addEventListener("webglcontextrestored", this._onContextRestore, false), this._canvas.addEventListener("webglcontextlost", this._onContextLost, false), this.renderer.addEventListener("resize", () => {
        this.scene.activeCamera.refreshAspect();
      }), this.scene.setBackgroundColor("#ffffff"), a2.assetManager && this.addPluginSync(new Ls(void 0, void 0, "boolean" == typeof a2.assetManager ? {} : a2.assetManager)), a2.dropzone && this.addPluginSync(new Fs()), this.console.log("WebGi Viewer instance initialized, version: ", zs.VERSION);
    }
    setDirty(e2, t2) {
      this._needsReset = true, e2 = null != e2 ? e2 : this, this.dispatchEvent({ ...null != t2 ? t2 : {}, type: "update", source: e2 });
    }
    get renderer() {
      return this._renderer;
    }
    dispose() {
      var e2;
      for (const e3 of [...Object.values(this.plugins)])
        this.removePlugin(e3, true);
      this.scene.dispose(), this.renderer.dispose(), this._canvas.removeEventListener("webglcontextrestored", this._onContextRestore, false), this._canvas.removeEventListener("webglcontextlost", this._onContextLost, false), null === (e2 = window.webGiViewers) || void 0 === e2 || e2.splice(window.webGiViewers.indexOf(this), 1), this.resizeObserver ? this.resizeObserver.unobserve(this._canvas) : window.removeEventListener("resize", this.resize), this.dispatchEvent({ type: "dispose" });
    }
    _renderEnabledChanged() {
      this.dispatchEvent({ type: this.renderEnabled ? "renderEnabled" : "renderDisabled" });
    }
    _animationLoop({ time: e2, deltaTime: t2, xrFrame: n2 }) {
      var r2, i2;
      if (this.enabled && this.renderEnabled)
        if (this._isRenderingFrame)
          this.console.warn("animation loop: frame skip");
        else {
          this._isRenderingFrame = true;
          for (let s2 = 0; s2 < this.maxFramePerLoop; s2++) {
            if (this._needsReset && (this._renderer.reset(), this._needsReset = false), this._needsResize) {
              const e3 = [this._canvas.clientWidth, this._canvas.clientHeight];
              if (n2) {
                const t3 = null === (i2 = null === (r2 = this._renderer.rendererObject.xr.getCamera()) || void 0 === r2 ? void 0 : r2.cameras[0]) || void 0 === i2 ? void 0 : i2.viewport;
                t3 ? (0 === t3.x && 0 === t3.y || this.console.warn("x and y must be 0?"), e3[0] = t3.width, e3[1] = t3.height, this.console.log("resize for xr", e3)) : this._needsResize = false;
              }
              this._needsResize && (this._renderer.setSize(...e3), this._needsResize = false);
            }
            this.dispatchEvent({ type: "preFrame", target: this, time: e2, deltaTime: t2, xrFrame: n2 });
            const s3 = Object.values(this.plugins).filter((e3) => e3.dirty);
            s3.length > 0 && this.setDirty(s3), this._needsReset && (this._renderer.reset(), this._needsReset = false), this._renderer.updateDirty();
            const o2 = this._renderer.dirty;
            if (o2)
              for (let e3 = 0; e3 < this.rendersPerFrame; e3++) {
                this.dispatchEvent({ type: "preRender", target: this });
                try {
                  this.scene.renderCamera = this.scene.activeCamera, this._renderer.render(this._renderer.defaultRenderToScreen);
                } catch (e4) {
                  this.console.error(e4), this.enabled = false;
                }
                this.dispatchEvent({ type: "postRender", target: this });
              }
            if (this.dispatchEvent({ type: "postFrame", target: this }), !o2)
              break;
          }
          this._isRenderingFrame = false;
        }
    }
    get state() {
      return this._state;
    }
    get container() {
      return this._canvas.parentElement !== this._container && this.console.error("ViewerApp: Canvas is not in the container, this might cause issues with some plugins."), this._container;
    }
    get canvas() {
      return this._canvas;
    }
    get canvasTexture() {
      if (!this._canvas)
        throw new Error("Canvas not found");
      return this._canvasTexture || (this._canvasTexture = new n.ROQ(this._canvas), this._canvasTexture.flipY = false, this._canvasTexture.needsUpdate = true), this._canvasTexture;
    }
    getPlugin(e2) {
      return "string" == typeof e2 ? this.getPluginByType(e2) : this.plugins[e2.PluginType];
    }
    getPluginByType(e2) {
      return this.plugins[e2];
    }
    async getOrAddPlugin(e2, ...t2) {
      return this.getPlugin(e2) || this.addPlugin(e2, ...t2);
    }
    getOrAddPluginSync(e2, ...t2) {
      return this.getPlugin(e2) || this.addPluginSync(e2, ...t2);
    }
    async addPlugin(e2, ...t2) {
      let n2;
      if (e2.prototype) {
        const r3 = this.getPlugin(e2);
        if (r3)
          return console.error(`Plugin of type ${js(r3)} already exists, no new plugin created`, r3), r3;
        n2 = new e2(...t2);
      } else
        n2 = e2;
      const r2 = js(n2);
      if (!r2)
        return this.console.error("PluginType is not defined for", n2), n2;
      for (const e3 of n2.dependencies || [])
        await this.getOrAddPlugin(e3);
      return this.plugins[r2] && (this.console.error(`Plugin of type ${r2} already exists, old plugin will be removed and disposed`, this.plugins[r2], n2), await this.removePlugin(this.plugins[r2], true)), this.plugins[r2] = n2, await n2.onAdded(this), this.dispatchEvent({ type: "addPlugin", target: this, plugin: n2 }), this.setDirty(n2), n2;
    }
    addPluginSync(e2, ...t2) {
      let n2;
      if (e2.prototype) {
        const r3 = this.getPlugin(e2);
        if (r3)
          return console.error(`Plugin of type ${js(r3)} already exists, no new plugin created`, r3), r3;
        n2 = new e2(...t2);
      } else
        n2 = e2;
      const r2 = js(n2);
      if (!r2)
        return this.console.error("PluginType is not defined for", n2), n2;
      for (const e3 of n2.dependencies || [])
        this.getOrAddPluginSync(e3);
      return this.plugins[r2] && (this.console.error(`Plugin of type ${r2} already exists, old plugin will be removed and disposed`, this.plugins[r2], n2), this.removePluginSync(this.plugins[r2], true)), this.plugins[r2] = n2, n2.onAdded(this), this.dispatchEvent({ type: "addPlugin", target: this, plugin: n2 }), this.setDirty(n2), n2;
    }
    async addPlugins(e2) {
      for (const t2 of e2)
        await this.addPlugin(t2);
    }
    async addPluginsSync(e2) {
      for (const t2 of e2)
        this.addPluginSync(t2);
    }
    async removePlugin(e2, t2 = true) {
      const n2 = js(e2);
      this.plugins[n2] && (await e2.onRemove(this), delete this.plugins[n2], t2 && e2.onDispose && await e2.onDispose(this), this.setDirty(e2));
    }
    removePluginSync(e2, t2 = true) {
      const n2 = js(e2);
      this.plugins[n2] && (e2.onRemove(this), delete this.plugins[n2], t2 && e2.onDispose && e2.onDispose(this), this.setDirty(e2));
    }
    createCamera(e2) {
      var t2;
      const n2 = null !== (t2 = e2.userData.iCamera) && void 0 !== t2 ? t2 : new nt(e2, { controlsMode: "", aspect: "auto" }, this._canvas);
      return void 0 === e2.userData.autoLookAtTarget ? (n2.autoLookAtTarget = false, e2.userData.autoLookAtTarget = false) : n2.autoLookAtTarget = e2.userData.autoLookAtTarget, n2;
    }
    setSize(e2) {
      this._canvas.style.width = (null == e2 ? void 0 : e2.width) ? e2.width + "px" : "100%", this._canvas.style.height = (null == e2 ? void 0 : e2.height) ? e2.height + "px" : "100%", this.resize();
    }
    async doOnce(e2, t2) {
      return new Promise((n2) => {
        const r2 = async (...i2) => {
          this.removeEventListener(e2, r2), n2(await (null == t2 ? void 0 : t2(...i2)));
        };
        this.addEventListener(e2, r2);
      });
    }
    setBackgroundColor(e2) {
      return console.warn("viewer.setBackground is deprecated, use viewer.scene.setBackgroundColor instead."), this.setBackgroundColor(e2);
    }
    setBackground(e2) {
      if (console.warn("viewer.setBackground is deprecated, use viewer.scene.setBackground instead."), this._rawBackground = e2, null == e2 || "string" != typeof e2 && "number" != typeof e2 && !e2.isColor)
        !e2 && this.useRgbm && this.console.error("Transparent background not supported with HDR RGBM rendering mode");
      else if (e2 === Gs)
        return this.scene.setBackground("environment");
      !e2 || (null == e2 ? void 0 : e2.isTexture) ? (this.scene.setBackground(e2), e2 || this.scene.setBackgroundColor(e2)) : this.scene.setBackgroundColor(e2);
    }
    getBackground(e2 = false) {
      var t2;
      if (console.warn("viewer.getBackground is deprecated, use viewer.scene.background instead."), e2)
        return this._rawBackground;
      let n2 = null !== (t2 = this._rawBackground) && void 0 !== t2 ? t2 : this.scene.getBackground();
      return n2 ? ((null == n2 ? void 0 : n2.isVector4) && (n2 = Et(n2, 7).getHexString()), (null == n2 ? void 0 : n2.isColor) ? n2.getHexString() : this._rawBackground === Gs ? this.scene.getEnvironment() : n2) : null;
    }
    getManager() {
      return this.getPluginByType("AssetManager") || this.addPluginSync(Ls);
    }
    resetCamera({ rootObject: e2, centerOffset: t2 = new n.Pa4(1, 1, 1), targetOffset: r2 = new n.Pa4(0, 0, 0), ...i2 } = {}) {
      if (this.scene.activeCamera) {
        this.scene.matrixWorldNeedsUpdate = true, this.scene.updateMatrixWorld(true);
        const i3 = e2 ? new h().expandByObject(e2, true, true) : this.scene.getBounds(true), s2 = i3.getCenter(new n.Pa4()), o2 = 0.5 * i3.getSize(new n.Pa4()).length();
        s2.add(r2.clone().multiplyScalar(o2)), this.scene.activeCamera.position = new n.Pa4(s2.x + t2.x * o2, s2.y + t2.y * o2, s2.z + t2.z * o2), this.scene.activeCamera.target = s2, this.setDirty();
      }
    }
    async fitToView(e2, t2 = 1.5, n2, r2) {
      var i2, s2;
      const o2 = this.getPluginByType("CameraViews");
      o2 ? await (null == o2 ? void 0 : o2.animateToFitObject(e2, t2, n2, r2, { min: (null !== (s2 = null === (i2 = this.scene.activeCamera.getControls()) || void 0 === i2 ? void 0 : i2.minDistance) && void 0 !== s2 ? s2 : 0.5) + 0.5, max: 1e3 })) : this.console.error("CameraViews plugin is required for fitToView to work");
    }
    async createObject3D(e2, t2 = false) {
      var r2;
      return null === (r2 = this.getManager()) || void 0 === r2 ? void 0 : r2.addImportedSingle(e2 || new n.Tme(), { autoScale: false, pseudoCenter: false, addToRoot: t2 });
    }
    createPhysicalMaterial(e2) {
      return this.createMaterial("standard", e2);
    }
    createMaterial(e2, t2) {
      var n2, r2, i2, s2;
      if (null == t2 ? void 0 : t2.isMaterial) {
        const e3 = null === (r2 = null === (n2 = this.getManager()) || void 0 === n2 ? void 0 : n2.materials) || void 0 === r2 ? void 0 : r2.findMaterial(t2.uuid);
        if (e3)
          return e3;
      }
      return null === (s2 = null === (i2 = this.getManager()) || void 0 === i2 ? void 0 : i2.materials) || void 0 === s2 ? void 0 : s2.generateFromTemplate(e2, t2);
    }
    serializePlugins(e2, t2) {
      return Object.entries(this.plugins).map((n2) => {
        var r2, i2;
        if (!t2 || t2.includes(n2[1].constructor.PluginType))
          return false !== n2[1].serializeWithViewer ? null === (i2 = (r2 = n2[1]).toJSON) || void 0 === i2 ? void 0 : i2.call(r2, e2) : void 0;
      }).filter((e3) => !!e3);
    }
    deserializePlugins(e2, t2) {
      return e2.forEach((e3) => {
        var n2;
        if (!e3.type)
          return void this.console.warn("Invalid plugin to import ", e3);
        const r2 = this.getPluginByType(e3.type);
        r2 && (null === (n2 = r2.fromJSON) || void 0 === n2 || n2.call(r2, e3, t2));
      }), this;
    }
    traverseSceneObjects(e2) {
      this.scene.modelRoot.modelObject.traverse(e2);
    }
    toJSON(e2, t2) {
      const n2 = Object.assign({ version: zs.VERSION, type: "ViewerApp", metadata: { generator: "WebGiViewerApp", version: 1 }, plugins: this.serializePlugins(e2, t2) }, le(this, true, e2));
      return n2.backgroundIntensity = this.scene.backgroundIntensity, n2.useLegacyLights = this.renderer.useLegacyLights, n2.background = n2.scene.background || n2.scene.backgroundColor, "environment" === n2.background && (n2.background = "envMapBackground"), n2;
    }
    fromJSON(e2, t2) {
      var r2, i2, s2, o2, a2;
      const l2 = { ...e2 };
      return void 0 !== l2.backgroundIntensity && void 0 === (null === (r2 = l2.scene) || void 0 === r2 ? void 0 : r2.backgroundIntensity) && (this.console.warn("old file format, backgroundIntensity moved to RootScene"), this.scene.backgroundIntensity = l2.backgroundIntensity, delete l2.backgroundIntensity), void 0 !== l2.useLegacyLights && void 0 === (null === (i2 = l2.renderManager) || void 0 === i2 ? void 0 : i2.useLegacyLights) && (this.console.warn("old file format, useLegacyLights moved to BaseRenderer"), this.renderer.useLegacyLights = l2.useLegacyLights, delete l2.useLegacyLights), void 0 !== l2.background && void 0 === (null === (s2 = l2.scene) || void 0 === s2 ? void 0 : s2.background) && (this.console.warn("old file format, background moved to RootScene"), "envMapBackground" === l2.background ? l2.background = "environment" : "number" == typeof l2.background ? l2.background = new n.Ilk().setHex(l2.background, n.GUF) : "string" == typeof l2.background ? l2.background = new n.Ilk().setStyle(l2.background, n.GUF) : (null === (o2 = l2.background) || void 0 === o2 ? void 0 : o2.isColor) && (l2.background = new n.Ilk(l2.background)), (null === (a2 = l2.background) || void 0 === a2 ? void 0 : a2.isColor) ? (this.scene.backgroundColor = l2.background, this.scene.background = null) : l2.background ? (this.scene.backgroundColor = new n.Ilk("#ffffff"), l2.scene.background = l2.background) : (this.scene.backgroundColor = null, this.scene.background = null), delete l2.background), ce(l2, this, true, t2), Array.isArray(l2.plugins) && this.deserializePlugins(l2.plugins, t2), this;
    }
    get renderManager() {
      return this._renderer;
    }
    get assetManager() {
      return this.getManager();
    }
    async load(e2, t2) {
      if (e2)
        return await this.assetManager.addAssetSingle(e2, t2);
    }
    async setEnvironmentMap(e2, { setBackground: t2 = false, ...n2 } = {}) {
      return this.scene.environment = e2 && !e2.isTexture ? await this.assetManager.importer.importSingle(e2, n2) || null : e2 || null, t2 ? this.setBackgroundMap(this.scene.environment) : this.scene.environment;
    }
    async setBackgroundMap(e2, { setEnvironment: t2 = false, ...n2 } = {}) {
      return this.scene.background = e2 && !e2.isTexture ? await this.assetManager.importer.importSingle(e2, n2) || null : e2 || null, t2 ? this.setEnvironmentMap(this.scene.background) : this.scene.background;
    }
    _setActiveCameraView(e2 = {}) {
      if ("setView" === e2.type) {
        if (!e2.camera)
          return void this.console.warn("Cannot find camera", e2);
        this.scene.activeCamera.copyFromCamera(e2.camera);
      } else
        "activateMain" === e2.type && (this.scene.activeCamera = e2.camera ? this.createCamera(e2.camera) : void 0);
    }
  }
  zs.VERSION = "0.9.20", Ns([ie("renderManager")], zs.prototype, "_renderer", void 0), Ns([ie()], zs.prototype, "scene", void 0), Ns([(0, t.onChange)(zs.prototype._renderEnabledChanged)], zs.prototype, "renderEnabled", void 0);
  const Gs = "envMapBackground";
  function Vs(e2) {
    return (null == e2 ? void 0 : e2.isShaderPass2) ? e2 : new dt({ ...r, fragmentShader: `
                       varying vec2 vUv;
                       
                       ${Array.isArray(e2) ? e2[0] : (null == e2 ? void 0 : e2.pars) || ""}
                       
                       void main() {

                            gl_FragColor = tDiffuseTexelToLinear (texture2D(tDiffuse, vUv));
                            
                            ${Array.isArray(e2) ? e2[1] : "string" == typeof e2 ? e2 : (null == e2 ? void 0 : e2.main) || ""}
                            
                        }`, uniforms: { tDiffuse: { value: null } } }, "tDiffuse");
  }
  class Hs extends dt {
    constructor(e2) {
      super({ vertexShader: r.vertexShader, uniforms: { tDiffuse: { value: null }, tNormalDepth: { value: null }, tGBufferFlags: { value: null }, tTransparent: { value: null } }, defines: {}, fragmentShader: `
                varying vec2 vUv;
                ${e2[0]}
                void main() {
                    gl_FragColor = tDiffuseTexelToLinear (texture2D(tDiffuse, vUv));
                    #glMarker
                    ${e2[1]}
                    
                    gl_FragColor.rgb *= gl_FragColor.a; // premultiply alpha
                }
                ` }, "tDiffuse", "tTransparent"), this.uiConfig = void 0, this.material.transparent = false, this.material.side = n.Wl3;
    }
    render(e2, t2, n2, r2, i2) {
      super.render(e2, t2, n2, r2, i2), this._lastReadBuffer = n2, this.needsSwap = true;
    }
    reRender(e2, t2, n2, r2) {
      this._lastReadBuffer && this.render(e2, t2, this._lastReadBuffer, n2, r2);
    }
    dispose() {
      this._lastReadBuffer = void 0, super.dispose();
    }
  }
  class Qs extends yt {
    get renderToScreen() {
      return this._renderToScreen;
    }
    constructor(e2 = true, t2 = true) {
      super(), this.depthTonemap = e2, this.passId = "combinedPost", this.dependencies = [wt], this.toJSON = void 0, this._beforeFilters = [], this._afterFilters = ["render", "screen"], this._requiredFilters = ["render"], this._renderToScreen = true, this._postFrame = () => {
        var e3, t3;
        this._needsReRender && this._renderToScreen && this._viewer && this.pass && (this._needsReRender = false, null === (t3 = (e3 = this.pass).update) || void 0 === t3 || t3.call(e3), this.pass.passObject.reRender(this._viewer.renderer.rendererObject, null));
      }, this._needsReRender = false, this._setDirty = this._setDirty.bind(this), this._renderToScreen = t2;
    }
    async onAdded(e2) {
      var n2, r2;
      return (null === (r2 = null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.screenShader) || void 0 === r2 ? void 0 : r2.isShaderPass2) && (this._renderToScreen = false), this._renderToScreen && (0, t.safeSetProperty)(e2.renderer.passes.find((e3) => "screen" === e3.passId), "enabled", false, true, true), e2.addEventListener("postFrame", this._postFrame), super.onAdded(e2);
    }
    async onRemove(e2) {
      return this._renderToScreen && (0, t.safeSetProperty)(e2.renderer.passes.find((e3) => "screen" === e3.passId), "enabled", true, true, true), super.onRemove(e2);
    }
    passCtor(e2) {
      var n2, r2;
      const i2 = e2.screenShader, s2 = ["", ""];
      this._renderToScreen && !i2.isShaderPass2 && (s2[0] = Array.isArray(i2) ? i2[0] : (null == i2 ? void 0 : i2.pars) || "", s2[1] = Array.isArray(i2) ? i2[1] : "string" == typeof i2 ? i2 : (null == i2 ? void 0 : i2.main) || "");
      const o2 = new Hs(s2);
      return (0, t.safeSetProperty)(null === (r2 = null === (n2 = o2.uiConfig) || void 0 === n2 ? void 0 : n2.children) || void 0 === r2 ? void 0 : r2.find((e3) => "Enabled" === (null == e3 ? void 0 : e3.label)), "hidden", true, true), o2;
    }
    _update(e2) {
      var t2, n2, r2;
      return !!super._update(e2) && (this._pass.passObject.updateShaderProperties(null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(wt)), this._pass.passObject.material.uniforms.tTransparent.value = (null === (r2 = null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.renderFilter.passObject.transparentTarget) || void 0 === r2 ? void 0 : r2.texture) || null, true);
    }
    _setDirty() {
      this.pass && (this.pass.dirty = true);
    }
    get uiConfig() {
      var e2, t2, n2;
      return null !== (n2 = null === (t2 = null === (e2 = this.pass) || void 0 === e2 ? void 0 : e2.passObject) || void 0 === t2 ? void 0 : t2.uiConfig) && void 0 !== n2 ? n2 : {};
    }
    addExtension(e2) {
      this.pass.passObject.material.registerMaterialExtensions([e2]);
    }
    reRender() {
      this._renderToScreen ? this._needsReRender = true : this._setDirty();
    }
  }
  Qs.PluginType = "CombinedPostPlugin";
  var Ws = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  class qs extends gt {
    constructor() {
      super(...arguments), this.enabled = true, this.dependencies = [Qs];
    }
    get uiConfig() {
      var e2;
      return null === (e2 = this._extension) || void 0 === e2 ? void 0 : e2.uiConfig;
    }
    get config() {
      return this._extension;
    }
    disposeExtension() {
    }
    async onAdded(e2) {
      var t2;
      await super.onAdded(e2), this._extension = this.generateExtension(e2), null === (t2 = e2.getPlugin(Qs)) || void 0 === t2 || t2.addExtension(this._extension);
    }
    async onRemove(e2) {
      this.disposeExtension(), this._extension = void 0, await super.onRemove(e2);
    }
  }
  function Xs(e2, t2, n2) {
    return e2 & ~(1 << t2) | (n2 ? 1 : 0) << t2;
  }
  function Ys(e2, t2) {
    return e2 & ~(1 << t2);
  }
  Ws([ie("extension")], qs.prototype, "_extension", void 0), Ws([ie()], qs.prototype, "enabled", void 0);
  var Ks, Js = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  const Zs = n.dZ3;
  let $s = Ks = class {
    constructor(e2, r2 = true) {
      this.depthTonemap = r2, this.toneMapping = n.LY2, this.tonemapBackground = true, this.clipBackground = false, this.exposure = 1, this.saturation = 1, this.contrast = 1, this.renderDepth = false, this.enabled = true, this._rendererState = {}, this.extraUniforms = { opacity: { value: 1 }, toneMappingContrast: { value: 1 }, toneMappingSaturation: { value: 1 } }, this.parsFragmentSnippet = (e3, n2) => this.enabled ? t.glsl`
            ${this.depthTonemap ? _t : ""}
            #define USE_DEPTH_TONEMAP ${this.depthTonemap ? "1" : "0"}
            uniform float opacity;
            uniform float toneMappingContrast;
            uniform float toneMappingSaturation;
            ${"int getToneMapBit(in int number){\n#ifdef WebGL2Context\nreturn(number/2)%2;\n#else\nreturn int(mod(floor(float(number)/2.),2.));\n#endif\n}vec3 TonemappingSaturation(vec3 rgb){const vec3 W=vec3(0.2125,0.7154,0.0721);vec3 intensity=vec3(dot(rgb,W));return mix(intensity,rgb,toneMappingSaturation);}vec3 TonemappingContrast(vec3 color){return(color-vec3(0.5))*toneMappingContrast+vec3(0.5);}vec4 ToneMapping(in vec4 color){vec4 outColor=opacity*color;\n#if USE_DEPTH_TONEMAP > 0\nbool doTonemap=getToneMapBit(getGBufferFlags(vUv).a)>0;float depth=getDepth(vUv);vec4 transparentCol=tTransparentTexelToLinear(texture2D(tTransparent,vUv));\n#if TONEMAP_BACKGROUND < 1 || TRANSPARENT_BACKGROUND > 0\nbool isBackground=depth>0.99&&transparentCol.a<0.001;if(isBackground)doTonemap=false;\n#endif\nif(doTonemap){\n#endif\n#if defined( TONE_MAPPING )\noutColor.rgb=toneMapping(outColor.rgb);outColor.rgb=TonemappingContrast(outColor.rgb);outColor.rgb=TonemappingSaturation(outColor.rgb);\n#endif\n#if USE_DEPTH_TONEMAP > 0\n}\n#if TRANSPARENT_BACKGROUND > 0\nif(isBackground)outColor.a=0.;if(depth>0.99&&transparentCol.a>=0.001)outColor.a=transparentCol.a;\n#endif\nif(depth<0.00001)outColor.a=0.;\n#if defined(DEBUG_DEPTH) && DEBUG_DEPTH > 0\noutColor.rgb=vec3(sRGBToLinear(vec4((1.-depth))).x);\n#endif\n#endif\nreturn outColor;}"}
        ` : "", this._combinedPostPlugin = e2.getPlugin(Qs), this._setDirty = this._setDirty.bind(this), this.depthTonemap = r2;
    }
    shaderExtender(e2, t2, n2) {
      this.enabled && (e2.fragmentShader = ot(e2.fragmentShader, "#glMarker", "\ngl_FragColor = ToneMapping(gl_FragColor);\n", { prepend: true }));
    }
    onObjectRender(e2, t2, r2) {
      if (!this.enabled)
        return;
      const { toneMapping: i2, toneMappingExposure: s2, outputColorSpace: o2 } = r2;
      this._rendererState.toneMapping = i2, this._rendererState.toneMappingExposure = s2, this._rendererState.outputColorSpace = o2;
      let a2 = this.tonemapBackground ? "1" : "0";
      t2.materialObject.defines.TONEMAP_BACKGROUND !== a2 && (t2.materialObject.defines.TONEMAP_BACKGROUND = a2, t2.materialObject.needsUpdate = true), a2 = this.clipBackground ? "1" : "0", t2.materialObject.defines.TRANSPARENT_BACKGROUND !== a2 && (t2.materialObject.defines.TRANSPARENT_BACKGROUND = a2, t2.materialObject.needsUpdate = true), a2 = this.renderDepth ? "1" : "0", t2.materialObject.defines.DEBUG_DEPTH !== a2 && (t2.materialObject.defines.DEBUG_DEPTH = a2, t2.materialObject.needsUpdate = true), r2.toneMapping = this.toneMapping, r2.toneMappingExposure = this.exposure, r2.outputColorSpace = n.KI_, t2.materialObject.toneMapped = true, t2.materialObject.needsUpdate = true, this.extraUniforms.toneMappingContrast.value = this.contrast, this.extraUniforms.toneMappingSaturation.value = this.saturation;
    }
    onAfterRender(e2, t2, n2) {
      n2.toneMapping = this._rendererState.toneMapping, n2.toneMappingExposure = this._rendererState.toneMappingExposure, n2.outputColorSpace = this._rendererState.outputColorSpace;
    }
    getUiConfig() {
      return this.uiConfig;
    }
    computeCacheKey(e2) {
      return this.enabled ? "1" : "0";
    }
    isCompatible(e2) {
      return true;
    }
    _setDirty() {
      this._combinedPostPlugin && (this._combinedPostPlugin.pass.dirty = true);
    }
    setDirty() {
      var e2;
      null === (e2 = this.__setDirty) || void 0 === e2 || e2.call(this), this._setDirty();
    }
  };
  $s.PluginType = "Tonemap", Js([Ne("Mode", [["Linear", n.EoG], ["Reinhard", n.CdI], ["Cineon", n.YGz], ["ACESFilmic", n.LY2], ["Uncharted2", Zs]].map((e2) => ({ label: e2[0], value: e2[1] })), { limitedUi: true }), (0, t.onChange)(Ks.prototype._setDirty), ie()], $s.prototype, "toneMapping", void 0), Js([(0, t.onChange)(Ks.prototype._setDirty), Oe("Tonemap Background", { limitedUi: true }), ie()], $s.prototype, "tonemapBackground", void 0), Js([(0, t.onChange)(Ks.prototype._setDirty), Oe("Clip Background"), ie()], $s.prototype, "clipBackground", void 0), Js([(0, t.onChange)(Ks.prototype._setDirty), Ue("Exposure", [0, 2 * Math.PI], 0.01, { limitedUi: true }), ie()], $s.prototype, "exposure", void 0), Js([(0, t.onChange)(Ks.prototype._setDirty), Ue("Saturation", [0, 2], 0.01, { limitedUi: true }), ie()], $s.prototype, "saturation", void 0), Js([(0, t.onChange)(Ks.prototype._setDirty), Ue("Contrast", [0, 2], 0.01, { limitedUi: true }), ie()], $s.prototype, "contrast", void 0), Js([(0, t.onChange)(Ks.prototype._setDirty), Oe("Render Depth")], $s.prototype, "renderDepth", void 0), $s = Ks = Js([We("Tonemapping")], $s);
  class eo extends qs {
    constructor(e2 = true) {
      super(), this.depthTonemap = e2, this.depthTonemap = e2, this.updateGBuffer = this.updateGBuffer.bind(this);
    }
    fromJSON(e2, t2) {
      return e2.pass && ((e2 = { ...e2 }).extension = { ...e2.pass }, delete e2.extension.enabled, delete e2.pass), super.fromJSON(e2, t2);
    }
    async onAdded(e2) {
      var t2;
      await super.onAdded(e2), null === (t2 = e2.getPlugin(wt)) || void 0 === t2 || t2.registerGBufferUpdater(this.updateGBuffer);
    }
    generateExtension(e2) {
      return new $s(e2, this.depthTonemap);
    }
    get exposure() {
      var e2, t2;
      return null !== (t2 = null === (e2 = this._extension) || void 0 === e2 ? void 0 : e2.exposure) && void 0 !== t2 ? t2 : 1;
    }
    set exposure(e2) {
      this._extension && (this._extension.exposure = e2, this._extension.setDirty());
    }
    get saturation() {
      var e2, t2;
      return null !== (t2 = null === (e2 = this._extension) || void 0 === e2 ? void 0 : e2.saturation) && void 0 !== t2 ? t2 : 1;
    }
    set saturation(e2) {
      this._extension && (this._extension.saturation = e2, this._extension.setDirty());
    }
    get contrast() {
      var e2, t2;
      return null !== (t2 = null === (e2 = this._extension) || void 0 === e2 ? void 0 : e2.contrast) && void 0 !== t2 ? t2 : 1;
    }
    set contrast(e2) {
      this._extension && (this._extension.contrast = e2, this._extension.setDirty());
    }
    get toneMapping() {
      var e2, t2;
      return null !== (t2 = null === (e2 = this._extension) || void 0 === e2 ? void 0 : e2.toneMapping) && void 0 !== t2 ? t2 : n.EoG;
    }
    set toneMapping(e2) {
      this._extension && (this._extension.toneMapping = e2, this._extension.setDirty());
    }
    updateGBuffer(e2, t2) {
      var r2, i2;
      if (e2 instanceof n.Kj0 && (null === (r2 = e2.material) || void 0 === r2 ? void 0 : r2.userData)) {
        const n2 = false === (null === (i2 = e2.material) || void 0 === i2 ? void 0 : i2.userData.postTonemap) ? 0 : 1;
        t2.w = Xs(t2.w, 1, n2);
      }
    }
  }
  eo.PluginType = "Tonemap", n.WdD.tonemapping_pars_fragment = n.WdD.tonemapping_pars_fragment.replace("vec3 CustomToneMapping( vec3 color ) { return color; }", "\n\n// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\n	// John Hable's filmic operator from Uncharted 2 video game\n	color *= toneMappingExposure;\n	return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( 1.0 ) ) );\n\n}\n\nvec3 CustomToneMapping( vec3 color ) { return Uncharted2ToneMapping( color ); }\n\n");
  var to, no = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let ro = to = class {
    constructor(e2) {
      this.enabled = false, this.aberrationIntensity = 0.01, this.extraUniforms = { aberrationIntensity: { value: 1 } }, this.parsFragmentSnippet = (e3, n2) => this.enabled ? t.glsl`
            uniform float aberrationIntensity;
            ${"vec4 chromaticAberration(){vec2 distFromCenter=vUv-0.5;vec2 aberrated=aberrationIntensity*pow(distFromCenter,vec2(2.));vec4 color=tDiffuseTexelToLinear(texture2D(tDiffuse,vUv));vec4 outColor=vec4(tDiffuseTexelToLinear(texture2D(tDiffuse,vUv+aberrated)).r,color.g,tDiffuseTexelToLinear(texture2D(tDiffuse,vUv-aberrated)).b,color.a);return outColor;}"}
        ` : "", this._combinedPostPlugin = e2.getPlugin(Qs), this._setDirty = this._setDirty.bind(this);
    }
    shaderExtender(e2, t2, n2) {
      this.enabled && (e2.fragmentShader = ot(e2.fragmentShader, "#glMarker", " \n            gl_FragColor = chromaticAberration();\n            #glMarker\n        "));
    }
    onObjectRender(e2, t2, n2) {
      this.enabled && (this.extraUniforms.aberrationIntensity.value = this.aberrationIntensity);
    }
    getUiConfig() {
      return this.uiConfig;
    }
    computeCacheKey(e2) {
      return this.enabled ? "1" : "0";
    }
    isCompatible(e2) {
      return true;
    }
    _setDirty() {
      this._combinedPostPlugin && (this._combinedPostPlugin.pass.dirty = true);
    }
    setDirty() {
      var e2;
      null === (e2 = this.__setDirty) || void 0 === e2 || e2.call(this), this._setDirty();
    }
  };
  ro.PluginType = "ChromaticAberration", no([(0, t.onChange)(to.prototype._setDirty), Oe("Enable"), ie()], ro.prototype, "enabled", void 0), no([(0, t.onChange)(to.prototype._setDirty), Ue("Intensity", [0, 0.1], 1e-3, { limitedUi: true }), ie()], ro.prototype, "aberrationIntensity", void 0), ro = to = no([We("ChromaticAberration")], ro);
  class io extends qs {
    constructor() {
      super();
    }
    generateExtension(e2) {
      return new ro(e2);
    }
    get intensity() {
      var e2, t2;
      return null !== (t2 = null === (e2 = this._extension) || void 0 === e2 ? void 0 : e2.aberrationIntensity) && void 0 !== t2 ? t2 : 1;
    }
    set intensity(e2) {
      this._extension && (this._extension.aberrationIntensity = e2, this._extension.setDirty());
    }
  }
  io.PluginType = "ChromaticAberration";
  class so extends gt {
    get passes() {
      if (!this._passes)
        throw "Plugin not yet added to the viewer";
      return this._passes;
    }
    get pipeline() {
      return this._pipeline;
    }
    set pipeline(e2) {
      this._pipeline = e2;
    }
    constructor() {
      super(), this._pipeline = [];
    }
    async onAdded(e2) {
      await super.onAdded(e2);
      const t2 = this.createPasses(e2);
      this._passes = Object.fromEntries(t2.map((t3) => (t3.passId || (console.warn("no id found for pass", t3), t3.passId = ke()), e2.renderer.registerPass(t3, true), [t3.passId, t3])));
    }
    async onRemove(e2) {
      var t2;
      if (this._passes) {
        for (const n2 of [...Object.values(this._passes)]) {
          const r2 = n2;
          e2.renderer.unregisterPass(r2), null === (t2 = null == r2 ? void 0 : r2.dispose) || void 0 === t2 || t2.call(r2);
        }
        this._passes = void 0;
      }
      await super.onRemove(e2);
    }
    toJSON(e2) {
      var t2;
      const n2 = super.toJSON(e2);
      if (!n2.type)
        return n2;
      const r2 = Object.entries(this.passes);
      n2.passes = {};
      for (const [i2, s2] of r2)
        n2.passes[i2] = le(null !== (t2 = null == s2 ? void 0 : s2.passObject) && void 0 !== t2 ? t2 : s2, false, e2);
      return n2;
    }
    fromJSON(e2, t2) {
      var n2;
      if (!super.fromJSON(e2, t2))
        return null;
      if (e2.passes) {
        const r2 = Object.entries(this.passes);
        for (const [i2, s2] of r2)
          ce(e2.passes[i2], null !== (n2 = null == s2 ? void 0 : s2.passObject) && void 0 !== n2 ? n2 : s2, false, t2);
      }
      return this;
    }
  }
  var oo = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  class ao extends dt {
    constructor(e2, t2, i2 = "rgba") {
      super({ vertexShader: r.vertexShader, fragmentShader: t2 + "uniform vec2 tDiffuseSize;uniform vec2 bilDirection;varying vec2 vUv;uniform bool smoothEnabled;uniform float edgeSharpness;vec4 bilaterialAO(){vec4 color=clamp((texture2D(tDiffuse,vUv.xy)).B_SRC_ACCESSOR,0.,5.);if(!smoothEnabled)return color;float depth;vec3 normal;getDepthNormal(vUv.xy,depth,normal);float gaussianWeights[4];gaussianWeights[0]=0.153170;gaussianWeights[1]=0.144893;gaussianWeights[2]=0.122649;gaussianWeights[3]=0.092902;float Z=gaussianWeights[0]+0.03;vec4 final_colour=Z*color;vec2 nuv;vec4 cc;float dp;vec3 nor;vec2 direction=bilDirection/tDiffuseSize.xy;\n#pragma unroll_loop_start\nfor(int i=0;i<6;i++){direction*=-1.;nuv=vUv+2.*direction*float(UNROLLED_LOOP_INDEX/2+1);getDepthNormal(nuv,dp,nor);if(dp<0.999){float normalCloseness=dot(normal,nor);normalCloseness*=normalCloseness;float normalError=(1.-normalCloseness)*8.;float normalWeight=max((1.-normalError*edgeSharpness),0.00);float depthWeight=max(0.,1.-edgeSharpness*4000.*abs(depth-dp));float kernelWeight=gaussianWeights[UNROLLED_LOOP_INDEX/2]+0.03;float bilateralWeight=kernelWeight*depthWeight*normalWeight;Z+=bilateralWeight;cc=clamp((texture2D(tDiffuse,nuv)).B_SRC_ACCESSOR,0.,5.);final_colour+=bilateralWeight*cc;}}\n#pragma unroll_loop_end\nfinal_colour/=Z;return final_colour;}void main(){vec4 ao=clamp(bilaterialAO(),vec4(0.),vec4(1.));gl_FragColor=ao;}", uniforms: { bilDirection: { value: new n.FM8(1, 0) }, tNormalDepth: { value: null }, tDiffuse: { value: e2.texture }, tDiffuseSize: { value: new n.FM8() } }, defines: { B_SRC_ACCESSOR: i2 } }, "tDiffuse"), this.smoothEnabled = true, this.edgeSharpness = 0.1, this._target = e2, this.clear = false, this.needsSwap = false;
    }
    render(e2, t2, n2, r2, i2) {
      var s2, o2, a2, l2;
      this.enabled && (this.uniforms.bilDirection.value.set(1, 0), this.uniforms.tDiffuse.value = this._target.texture, this.uniforms.tDiffuseSize.value.set((null === (s2 = this.uniforms.tDiffuse.value) || void 0 === s2 ? void 0 : s2.image.width) || 0, (null === (o2 = this.uniforms.tDiffuse.value) || void 0 === o2 ? void 0 : o2.image.height) || 0), super.render(e2, t2, this._target, r2, i2), this.uniforms.bilDirection.value.set(0, 1), this.uniforms.tDiffuse.value = t2.texture, this.uniforms.tDiffuseSize.value.set((null === (a2 = this.uniforms.tDiffuse.value) || void 0 === a2 ? void 0 : a2.image.width) || 0, (null === (l2 = this.uniforms.tDiffuse.value) || void 0 === l2 ? void 0 : l2.image.height) || 0), super.render(e2, this._target, t2, r2, i2));
    }
  }
  oo([ie(), j()], ao.prototype, "smoothEnabled", void 0), oo([ie(), j()], ao.prototype, "edgeSharpness", void 0);
  var lo = "varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);}", co = "#ifndef BASIC_RANDOM_HELPERS\n#define BASIC_RANDOM_HELPERS \nuniform float frameCount;float random(float n){return fract(sin(n)*43758.5453123);}float random2(vec2 n,float x){n+=x;return fract(sin(dot(n.xy,vec2(12.9898,78.233)))*43758.5453);}float random3(vec3 v){v=fract(v*443.8975);v+=dot(v,v.yzx+19.19);return fract((v.x+v.y)*v.z);}float interleavedGradientNoise(const in vec2 fragCoord,const in float seed){vec3 magic=vec3(0.06711056,0.00583715,52.9829189);return fract(magic.z*fract(dot(fragCoord.xy+seed*vec2(2.083,4.867),magic.xy)));}vec3 hash3(vec2 p){vec3 q=vec3(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)),dot(p,vec2(419.2,371.9)));return fract(sin(q)*43758.5453);}\n#endif\n", uo = "#ifndef SIMPLE_CAMERA_HELPERS\n#define SIMPLE_CAMERA_HELPERS \n#ifndef USE_TRANSMISSION\nuniform mat4 projectionMatrix;\n#endif\nvec3 viewToScreen(const in vec3 pos){vec4 projected=projectionMatrix*vec4(pos,1.);return vec3(0.5+0.5*projected.xy/projected.w,projected.w);}\n#endif\n", po = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  class ho extends dt {
    constructor(e2, r2, i2) {
      super({ defines: { LINEAR_DEPTH: 1, NUM_SAMPLES: 11, NUM_SPIRAL_TURNS: 3, DEPTH_NORMAL_TEXTURE: 1, DEPTH_PACKING_MODE: 2, PERSPECTIVE_CAMERA: 1, CHECK_GBUFFER_FLAG: 0 }, uniforms: { tLastThis: { value: null }, tNormalDepth: { value: null }, tGBufferFlags: { value: null }, screenSize: { value: new n.FM8(512, 512) }, saoData: { value: new n.Ltg() }, frameCount: { value: 0 }, cameraNearFar: { value: new n.FM8(0.1, 1e3) }, projection: { value: new n.yGw() }, saoBiasEpsilon: { value: new n.Ltg(1, 1, 1, 1) }, sceneBoundingRadius: { value: 0 } }, vertexShader: lo, fragmentShader: `

${co}

${i2}

#include <common>
#include <packing>
varying vec2 vUv;uniform vec2 cameraNearFar;uniform mat4 projection;uniform sampler2D tLastThis;uniform vec4 saoData;uniform vec4 saoBiasEpsilon;uniform vec2 screenSize;const float INV_NUM_SAMPLES=1./float(NUM_SAMPLES);int getSelectionBit(in int number){
#ifdef WebGL2Context
return(number/8)%2;
#else
return int(mod(floor(float(number)/4.),2.));
#endif
}float getViewZFromNDCZ(const in float depth){
#if PERSPECTIVE_CAMERA == 1
return perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);
#else
return orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);
#endif
}vec3 packFloatToRGB(const in float x){const vec3 code=vec3(1.,255.,65025.);vec3 pack=vec3(code*x);pack.gb=fract(pack.gb);pack.rg-=pack.gb*(1./256.);return pack;}vec3 getViewPositionFromViewZ(const in vec2 uv,const in float viewDepth){vec2 uv_=2.*uv-1.;float xe=-(uv_.x+projection[2][0])*viewDepth/projection[0][0];float ye=-(uv_.y+projection[2][1])*viewDepth/projection[1][1];return vec3(xe,ye,viewDepth);}float decodeDepth(const in vec2 uv){vec4 uncodedDepth;
#if DEPTH_PACKING_MODE == 2
uncodedDepth=texture2D(tNormalDepth,uv);
#else
uncodedDepth=texture2D(tDepth,uv);
#endif
#if DEPTH_PACKING_MODE == 0
return uncodedDepth.x;
#elif DEPTH_PACKING_MODE == 1
#if LINEAR_DEPTH == 1
return pow2(unpackRGBAToDepth(uncodedDepth));
#else
return unpackRGBAToDepth(uncodedDepth);
#endif
#else
return pow2(unpack16(uncodedDepth.xy));
#endif
}vec3 getPositionFromOffset(const in vec2 uvOffset){float d=decodeDepth(uvOffset);
#if LINEAR_DEPTH == 0
float centerViewZ=getViewZFromNDCZ(d);return getViewPositionFromViewZ(uvOffset,centerViewZ);
#else
d=mix(-cameraNearFar.x,-cameraNearFar.y,d);return getViewPositionFromViewZ(uvOffset,d);
#endif
}float getCavityAO(){float cutoff=-0.65;float curvature=float(getGBufferFlags(vUv).r)/255.;curvature=2.*curvature-1.;curvature=curvature*4.;float smoothCurvature=smoothstep(0.,1.,curvature-cutoff);smoothCurvature+=saoData.x;smoothCurvature=clamp(smoothCurvature,0.,1.);return 1.-smoothCurvature;}float getOcclusion(const in vec2 uv,const in int id,const in float randomAngle,const in float occlusionSphereRadius,const in vec3 centerPosition,const in vec3 centerNormal){float screenSpaceRadius=(float(id)+mod(randomAngle,1.)+0.5)*INV_NUM_SAMPLES;float angle=screenSpaceRadius*(float(NUM_SPIRAL_TURNS)*6.28318)+randomAngle;screenSpaceRadius=(screenSpaceRadius*occlusionSphereRadius);vec2 uvOffset=uv+floor(screenSpaceRadius*vec2(cos(angle),sin(angle)))/screenSize;
#if CHECK_GBUFFER_FLAG == 1
if(getSelectionBit(getGBufferFlags(uvOffset.xy).a)<1)return 0.;
#endif
vec3 samplePosition=getPositionFromOffset(uvOffset);vec3 direction=samplePosition-centerPosition;float d2=dot(direction,direction)/(saoBiasEpsilon.w*saoBiasEpsilon.w);float ao=max((dot(centerNormal,direction)/saoBiasEpsilon.w-saoBiasEpsilon.x)/(saoBiasEpsilon.z*d2+saoBiasEpsilon.y),0.);return ao;}void main(){float centerDepth;vec3 centerNormal;getDepthNormal(vUv,centerDepth,centerNormal);
#if LINEAR_DEPTH == 0
float centerViewZ=getViewZFromNDCZ(centerDepth);
#else
float centerViewZ=mix(-cameraNearFar.x,-cameraNearFar.y,centerDepth);
#endif
vec3 centerPosition=getViewPositionFromViewZ(vUv,centerViewZ);float occlusionSphereScreenRadius=0.09*saoData.z*saoBiasEpsilon.w/(-centerPosition.z);float randomAngle=6.2*random3(vec3(vUv,frameCount*0.1));float sum=0.;sum+=getOcclusion(vUv,0,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#if NUM_SAMPLES > 1
sum+=getOcclusion(vUv,1,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 2
sum+=getOcclusion(vUv,2,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 3
sum+=getOcclusion(vUv,3,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 4
sum+=getOcclusion(vUv,4,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 5
sum+=getOcclusion(vUv,5,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 6
sum+=getOcclusion(vUv,6,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 7
sum+=getOcclusion(vUv,7,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 8
sum+=getOcclusion(vUv,8,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 9
sum+=getOcclusion(vUv,9,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 10
sum+=getOcclusion(vUv,10,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
float aoValue=sum*saoData.y*INV_NUM_SAMPLES;float cavityAO=getCavityAO();aoValue=saoData.w>0.?max(aoValue,cavityAO):aoValue;aoValue=clamp(1.-max(aoValue,0.),0.,1.);gl_FragColor.gba=packFloatToRGB(centerDepth);gl_FragColor.r=(vec4(aoValue)).r;}

            ` }, "tDiffuse"), this.parameters = { intensity: 0.25, occlusionWorldRadius: 1, bias: 1e-3, falloff: 1.3, useSmallScaleAO: false, intensitySmallAO: 0.2, autoRadius: false, projScale: 1 }, this._smoothEnabled = true, this.materialExtension = { shaderExtender: (e3, t2, n2) => {
        e3.defines.SSAO_ENABLED && (e3.fragmentShader = ot(e3.fragmentShader, "#include <aomap_fragment>", "#ifndef USE_TRANSMISSION\n#if defined(SSAO_ENABLED) && SSAO_ENABLED > 0\nfloat ambientOcclusion=tSSAOMapTexelToLinear(texture2D(tSSAOMap,viewToScreen(vViewPosition.xyz).xy)).r;reflectedLight.indirectDiffuse*=ambientOcclusion;\n#if defined( USE_ENVMAP )\nfloat dotNV=saturate(dot(geometry.normal,geometry.viewDir));reflectedLight.indirectSpecular*=computeSpecularOcclusion(dotNV,ambientOcclusion,material.roughness);\n#endif\n#else\n#include <aomap_fragment>\n#endif\n#endif\n"));
      }, onObjectRender: (e3, t2, n2) => {
        var r3, i3;
        this.materialExtension.extraUniforms.tSSAOMap.value = null === (r3 = this._target) || void 0 === r3 ? void 0 : r3.texture;
        const s2 = t2.materialObject;
        let o2 = this.enabled && false !== n2.userData.screenSpaceRendering && !(null === (i3 = t2.userData) || void 0 === i3 ? void 0 : i3.ssaoDisabled) ? 1 : 0;
        s2.defines.SSAO_ENABLED !== o2 && (s2.defines.SSAO_ENABLED = o2, s2.needsUpdate = true), o2 = this._target.texture, this.materialExtension.extraUniforms.tSSAOMap.value !== o2 && (this.materialExtension.extraUniforms.tSSAOMap.value = o2, s2.needsUpdate = true);
      }, parsFragmentSnippet: (e3) => {
        var n2;
        return t.glsl`
             uniform sampler2D tSSAOMap;
             ${L("tSSAOMap", null === (n2 = this._target) || void 0 === n2 ? void 0 : n2.texture, e3.capabilities.isWebGL2)}
            ${uo}
        `;
      }, extraUniforms: { tSSAOMap: { value: null } }, computeCacheKey: (e3) => {
        var t2, n2;
        return this.enabled ? "1" : "0" + (null === (n2 = null === (t2 = this._target) || void 0 === t2 ? void 0 : t2.texture) || void 0 === n2 ? void 0 : n2.colorSpace);
      }, isCompatible: (e3) => {
        var t2;
        return !(null === (t2 = e3.materialObject.userData) || void 0 === t2 ? void 0 : t2.ssaoDisabled) && e3.isMeshStandardMaterial2;
      } }, this._renderer = e2, this._target = r2, this.needsSwap = false, this.clear = true, this.bilateralPass = new ao(this._target, i2, "rrrr");
    }
    get smoothEnabled() {
      return this._smoothEnabled;
    }
    set smoothEnabled(e2) {
      this._smoothEnabled = e2, this.bilateralPass.enabled = e2, this.bilateralPass.uniforms.smoothEnabled.value = e2;
    }
    render(e2, t2, n2, r2, i2) {
      this.enabled && (this._updateParameters(), this._renderer.blit(this._target.texture, t2, {}), this.uniforms.tLastThis.value = t2.texture, super.render(e2, this._target, n2, r2, i2), this._smoothEnabled && this.bilateralPass.render(e2, t2, n2, r2, i2));
    }
    _updateParameters() {
      const e2 = this.material.uniforms.saoData.value;
      e2.x = this.parameters.intensitySmallAO, e2.y = this.parameters.intensity, e2.z = this.parameters.occlusionWorldRadius, e2.w = this.parameters.useSmallScaleAO, e2.z *= this.parameters.projScale;
      const t2 = this.material.uniforms.saoBiasEpsilon.value;
      if (t2.x = this.parameters.bias, t2.y = 1e-3, t2.z = this.parameters.falloff, this.parameters.autoRadius) {
        const e3 = this.material.uniforms.sceneBoundingRadius.value;
        t2.w = e3;
      } else
        t2.w = 1;
    }
  }
  po([ie()], ho.prototype, "bilateralPass", void 0), po([ie()], ho.prototype, "parameters", void 0);
  class fo extends so {
    get aoTarget() {
      return this._aoTarget;
    }
    constructor() {
      super(), this.dependencies = [Ls, wt], this.setDirty = this.setDirty.bind(this), this.updateGBuffer = this.updateGBuffer.bind(this);
    }
    async onAdded(e2) {
      var t2;
      return e2.getPluginByType("Ground") && console.error("GroundPlugin must be added after SSAOPlugin"), null === (t2 = e2.getPlugin(wt)) || void 0 === t2 || t2.registerGBufferUpdater(this.updateGBuffer), super.onAdded(e2);
    }
    updateGBuffer(e2, t2) {
      var r2;
      if (e2 instanceof n.Kj0 && (null === (r2 = e2.material) || void 0 === r2 ? void 0 : r2.userData)) {
        const n2 = e2.material.userData.ssaoCastDisabled || e2.material.userData.pluginsDisabled, r3 = n2 ? 0 : 1;
        t2.w = Xs(t2.w, 3, r3), n2 && this.passes.ssao.passObject && 1 !== this.passes.ssao.passObject.material.defines.CHECK_GBUFFER_FLAG && (this.passes.ssao.passObject.material.defines.CHECK_GBUFFER_FLAG = 1, this.passes.ssao.passObject.material.needsUpdate = true);
      }
    }
    createPasses(e2) {
      var t2, r2;
      return this._aoTarget = e2.renderer.createTarget({ sizeMultiplier: 1 }), [vt(e2, { passId: "ssao", after: ["gbuffer"], before: ["render"], required: ["render", "gbuffer"], passObject: new ho(e2.renderer, this._aoTarget, null !== (r2 = null === (t2 = e2.getPlugin(wt)) || void 0 === t2 ? void 0 : t2.getUnpackSnippet()) && void 0 !== r2 ? r2 : ""), update() {
        var t3;
        const r3 = Math.max(1, null !== (t3 = (null == e2 ? void 0 : e2.scene.activeCamera.modelObject).fov) && void 0 !== t3 ? t3 : 1), i2 = ((null == e2 ? void 0 : e2.canvas.height) || 1) / (2 * Math.tan(0.5 * r3 * n.M8C.DEG2RAD));
        this.passObject.parameters.projScale = i2, this.passObject.bilateralPass.updateShaderProperties([e2.getPlugin(wt)]);
      } }, () => [e2.getPlugin(wt), e2.scene.activeCamera, e2.renderer, e2.scene])];
    }
    async onRemove(e2) {
      return e2.renderer.disposeTarget(this._aoTarget), super.onRemove(e2);
    }
    setDirty() {
      var e2;
      null === (e2 = this._viewer) || void 0 === e2 || e2.setDirty();
    }
    get enabled() {
      var e2, t2;
      return (null === (t2 = null === (e2 = this.passes.ssao) || void 0 === e2 ? void 0 : e2.passObject) || void 0 === t2 ? void 0 : t2.enabled) || false;
    }
    set enabled(e2) {
      var t2;
      (null === (t2 = this.passes.ssao) || void 0 === t2 ? void 0 : t2.passObject) && (this.passes.ssao.passObject.enabled = e2);
    }
    get uiConfig() {
      var e2;
      if (this._uiConfig)
        return this._uiConfig;
      const t2 = this, n2 = t2.passes.ssao.passObject;
      return this._uiConfig = { type: "folder", label: "SS Ambient Occlusion", children: [{ type: "checkbox", label: "Enabled", property: [n2, "enabled"], onChange: t2.setDirty }, { type: "checkbox", label: "Enable Cavity", property: [n2.parameters, "useSmallScaleAO"], onChange: t2.setDirty }, { type: "slider", label: "Cavity Brightness", bounds: [0, 0.5], stepSize: 0.01, property: [n2.parameters, "intensitySmallAO"], onChange: t2.setDirty }, { type: "slider", label: "Intensity", bounds: [0, 5], property: [n2.parameters, "intensity"], onChange: t2.setDirty }, { type: "slider", label: "Radius", bounds: [0.1, 20], property: [n2.parameters, "occlusionWorldRadius"], onChange: t2.setDirty }, { type: "slider", label: "Bias", bounds: [1e-5, 0.01], property: [n2.parameters, "bias"], onChange: t2.setDirty }, { type: "slider", label: "Falloff", bounds: [0.01, 3], property: [n2.parameters, "falloff"], onChange: t2.setDirty }, { type: "slider", label: "Num samples", stepSize: 1, bounds: [1, 11], property: [null === (e2 = n2.material) || void 0 === e2 ? void 0 : e2.defines, "NUM_SAMPLES"], onChange: [() => n2.material.needsUpdate = true, t2.setDirty] }, { type: "checkbox", property: [n2.bilateralPass, "smoothEnabled"], onChange: t2.setDirty }, { type: "checkbox", property: [n2.parameters, "autoRadius"], onChange: t2.setDirty }, { type: "vec4", property: [n2.bilateralPass, "edgeSharpness"], onChange: t2.setDirty }] };
    }
  }
  fo.PluginType = "SSAO";
  var mo, _o = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let go = mo = class extends dt {
    constructor() {
      super({ vertexShader: r.vertexShader, defines: { PASS_STEP: 1 }, uniforms: { tSource: { value: null }, tDiffuse: { value: null }, opacity: { value: 1 }, tDiffuseSize: { value: new n.FM8() }, weight: { value: 1 }, tNormalDepth: { value: null }, tGBufferFlags: { value: null } }, fragmentShader: _t + "\nuniform float intensity;uniform float opacity;uniform vec2 tDiffuseSize;varying vec2 vUv;uniform float weight;\n#if PASS_STEP == 0\nuniform vec4 prefilter;vec4 Prefilter(vec4 c){if(getDepth(vUv)>0.999){return vec4(0.);}float brightness=max(c.r,max(c.g,c.b));float soft=brightness+prefilter.x*(prefilter.y-1.);soft=clamp(soft,0.,prefilter.z);soft=soft*soft*prefilter.w;float contribution=max(soft,brightness-prefilter.x);contribution/=max(brightness,0.001);return vec4(c.rgb*contribution,c.a);}\n#endif\nvec4 Sample(vec2 uv){return tDiffuseTexelToLinear(texture2D(tDiffuse,uv));}vec4 SampleBox(vec2 uv,float delta){vec4 o=vec2(-delta,delta).xxyy/tDiffuseSize.xyxy;vec4 s=Sample(uv+o.xy)+Sample(uv+o.zy)+Sample(uv+o.xw)+Sample(uv+o.zw);return s*0.25;}int getBloomBit(in int number){\n#ifdef WebGL2Context\nreturn(number/4)%2;\n#else\nreturn int(mod(floor(float(number)/4.),2.));\n#endif\n}void main(){\n#if PASS_STEP == 0 \nint doBloom=getBloomBit(getGBufferFlags(vUv).a);gl_FragColor=float(doBloom)*weight*Prefilter(SampleBox(vUv,1.));gl_FragColor.a=1.;\n#elif PASS_STEP == 1 \ngl_FragColor=weight*(SampleBox(vUv,1.));gl_FragColor.a=1.;\n#elif PASS_STEP == 2 \ngl_FragColor=(SampleBox(vUv,0.5));gl_FragColor.a=1.;\n#elif PASS_STEP == 3 \nvec4 texel=tSourceTexelToLinear(texture2D(tSource,vUv));vec4 bloom=intensity*SampleBox(vUv,0.5).rgba;float brightness=max(bloom.r,max(bloom.g,bloom.b));texel.rgb+=bloom.rgb;texel.a=min(1.,texel.a+brightness);gl_FragColor=texel;\n#elif PASS_STEP == 4 \nvec4 texel=vec4(0.);texel.rgb+=intensity*SampleBox(vUv,0.5).rgb;texel.a=1.;gl_FragColor=texel;\n#endif\n#include <encodings_fragment>\n}" }, "tDiffuse", "tSource"), this.uiConfig = void 0, this.prefilter = new n.Ltg(2, 0.5, 0, 0), this.threshold = 2, this.softThreshold = 0.5, this.intensity = 0.2, this.bloomIterations = 4, this.radius = 0.6, this.power = 1, this.bloomDebug = false, this._weights = [], this._updateWeights = this._updateWeights.bind(this), this._thresholdsUpdated = this._thresholdsUpdated.bind(this), this._updateWeights(), this._thresholdsUpdated(), this.clear = true, this.userData = { setDirty: () => {
        this.setDirty();
      } };
    }
    _thresholdsUpdated() {
      this.prefilter.x = this.threshold, this.prefilter.y = this.softThreshold, this.prefilter.z = 2 * this.prefilter.x * this.prefilter.y, this.prefilter.w = 0.125 / (this.uniforms.prefilter.value.z + 1e-5);
    }
    render(e2, t2, r2, i2, s2) {
      const o2 = e2.baseRenderer;
      this.material.defines.PASS_STEP = 0, this.clear = true;
      const a2 = r2;
      let l2 = 0.5, c2 = a2.width * l2, u2 = a2.height * l2;
      const p2 = [];
      let d2 = o2.getTempTarget({ sizeMultiplier: 1, type: n.cLu });
      p2.push(d2);
      let h2 = a2;
      this.material.needsUpdate = true, this.material.uniforms.weight.value = this._weights[0], super.render(e2, d2, h2, i2, s2), h2 = d2;
      let f2 = 1;
      for (; f2 < this.bloomIterations && (c2 /= 2, u2 /= 2, l2 /= 2, !(u2 < 2 || c2 < 2)); f2++) {
        d2 = o2.getTempTarget({ sizeMultiplier: l2, type: n.cLu }), p2.push(d2), this.material.defines.PASS_STEP = 1;
        let t3 = this._weights[f2];
        t3 = 0 !== this._weights[f2 - 1] ? this._weights[f2] / this._weights[f2 - 1] : this._weights[f2], this.material.uniforms.weight.value = t3, this.material.needsUpdate = true, super.render(e2, d2, h2, i2, s2), h2 = d2;
      }
      this.clear = false;
      const m2 = e2.autoClear;
      for (e2.autoClear = false, f2 -= 2; f2 >= 0; f2--)
        d2 = p2[f2], p2[f2] = void 0, this.material.defines.PASS_STEP = 2, this.material.transparent = true, this.material.blending = n.WMw, this.material.needsUpdate = true, e2.autoClear = false, super.render(e2, d2, h2, i2, s2), this.material.blending = n.jFi, o2.releaseTempTarget(h2), h2 = d2;
      this.clear = true, e2.autoClear = m2, e2.autoClear = true, this.bloomDebug ? (this.material.defines.PASS_STEP = 4, this.material.needsUpdate = true, super.render(e2, t2, h2, i2, s2)) : (this.uniforms.tSource.value = a2.texture, this.material.defines.PASS_STEP = 3, this.material.needsUpdate = true, super.render(e2, t2, h2, i2, s2), this.uniforms.tSource.value = null), o2.releaseTempTarget(h2);
    }
    _updateWeights() {
      if (!this._weights)
        return;
      const e2 = Math.max(Math.min(this.radius, 1), 0), t2 = 1 / (this.bloomIterations - 1);
      for (let n2 = 0; n2 < this.bloomIterations; n2++) {
        let r2 = n2 * t2 + 0.1, i2 = 1.2 - r2;
        r2 = Math.pow(r2, this.power), i2 = Math.pow(i2, this.power), this._weights[n2] = i2 * (1 - e2) + r2 * e2;
      }
      this.setDirty();
    }
  };
  function vo(e2) {
    const t2 = null == e2 ? void 0 : e2.userData;
    return !!t2 && (t2[yo.PluginType] || (t2[yo.PluginType] = {}), t2[yo.PluginType].enable = true, e2.isMaterial && (e2.needsUpdate = true), true);
  }
  _o([j()], go.prototype, "prefilter", void 0), _o([Ue("Threshold", [0, 2]), (0, t.onChange)(mo.prototype._thresholdsUpdated), ie()], go.prototype, "threshold", void 0), _o([Ue("Soft Threshold", [0, 1]), (0, t.onChange)(mo.prototype._thresholdsUpdated), ie()], go.prototype, "softThreshold", void 0), _o([Ue("Intensity", [0, 3]), ie(), j()], go.prototype, "intensity", void 0), _o([Ue("Iterations", [0, 7], 1), (0, t.onChange)(mo.prototype._updateWeights), ie()], go.prototype, "bloomIterations", void 0), _o([Ue("Radius", [0, 1], 0.01), (0, t.onChange)(mo.prototype._updateWeights), ie()], go.prototype, "radius", void 0), _o([Ue("Power", [0.2, 10], 0.01), (0, t.onChange)(mo.prototype._updateWeights), ie()], go.prototype, "power", void 0), _o([Oe("Debug")], go.prototype, "bloomDebug", void 0), go = mo = _o([We("Bloom")], go);
  class yo extends yt {
    constructor() {
      super(...arguments), this.passId = "bloom", this._beforeFilters = ["combinedPost", "screen"], this._afterFilters = ["render", "progressive"], this._requiredFilters = ["render"], this.materialExtension = { uuid: ke(), getUiConfig: (e2) => {
        if (e2.__uiConfigs || (e2.__uiConfigs = {}), e2.__uiConfigs[this.materialExtension.uuid])
          return e2.__uiConfigs[this.materialExtension.uuid];
        const t2 = this._getUiConfig(e2);
        return e2.__uiConfigs[this.materialExtension.uuid] = t2, t2;
      }, isCompatible: (e2) => true };
    }
    setDirty() {
      this.pass.dirty = true;
    }
    _getUiConfig(e2) {
      const t2 = { type: "folder", label: "Bloom", children: [{ type: "checkbox", label: "Enabled", get value() {
        var t3, n2;
        return null === (n2 = null === (t3 = e2.materialObject.userData[yo.PluginType]) || void 0 === t3 ? void 0 : t3.enable) || void 0 === n2 || n2;
      }, set value(n2) {
        var r2;
        const i2 = e2.materialObject.userData[yo.PluginType];
        n2 !== (null == i2 ? void 0 : i2.enable) && (i2 || vo(e2.materialObject), e2.materialObject.userData[yo.PluginType].enable = n2, null === (r2 = t2.uiRefresh) || void 0 === r2 || r2.call(t2, "postFrame", true));
      }, onChange: this.setDirty }] };
      return t2;
    }
    passCtor(e2) {
      const t2 = new go();
      return this.updateGBuffer = this.updateGBuffer.bind(this), this.setDirty = this.setDirty.bind(this), t2;
    }
    async onAdded(e2) {
      var t2, n2;
      await super.onAdded(e2), null === (t2 = e2.getPlugin(wt)) || void 0 === t2 || t2.registerGBufferUpdater(this.updateGBuffer);
      const r2 = e2.getPlugin(Ls);
      null === (n2 = null == r2 ? void 0 : r2.materials) || void 0 === n2 || n2.registerMaterialExtension(this.materialExtension);
    }
    updateGBuffer(e2, t2) {
      var r2, i2, s2, o2;
      if (e2 instanceof n.Kj0 && (null === (r2 = e2.material) || void 0 === r2 ? void 0 : r2.userData)) {
        const n2 = false === (null === (s2 = null === (i2 = e2.material) || void 0 === i2 ? void 0 : i2.userData[yo.PluginType]) || void 0 === s2 ? void 0 : s2.enable) || (null === (o2 = e2.material) || void 0 === o2 ? void 0 : o2.userData.pluginsDisabled) ? 0 : 1;
        t2.w = Xs(t2.w, 2, n2);
      }
    }
    _update(e2) {
      var t2, n2;
      return null === (t2 = e2.getPlugin(wt)) || void 0 === t2 || t2.updateShaderProperties(null === (n2 = this.pass) || void 0 === n2 ? void 0 : n2.passObject.material), super._update(e2);
    }
    get uiConfig() {
      var e2;
      return null === (e2 = this.pass) || void 0 === e2 ? void 0 : e2.passObject.uiConfig;
    }
  }
  yo.PluginType = "Bloom";
  var bo = "vec2 poisson_disk_samples[16];void setPds(){poisson_disk_samples[0]=vec2(-0.399691779231,0.728591545584);poisson_disk_samples[1]=vec2(-0.48622557676,-0.84016533712);poisson_disk_samples[2]=vec2(0.770309468987,-0.24906070432);poisson_disk_samples[3]=vec2(0.556596796154,0.820359876432);poisson_disk_samples[4]=vec2(-0.933902004071,0.0600539051593);poisson_disk_samples[5]=vec2(0.330144964342,0.207477293384);poisson_disk_samples[6]=vec2(0.289013230975,-0.686749271417);poisson_disk_samples[7]=vec2(-0.0832470893559,-0.187351643125);poisson_disk_samples[8]=vec2(-0.296314525615,0.254474834305);poisson_disk_samples[9]=vec2(-0.850977666059,0.484642744689);poisson_disk_samples[10]=vec2(0.829287915319,0.2345063545);poisson_disk_samples[11]=vec2(-0.773042143899,-0.543741521254);poisson_disk_samples[12]=vec2(0.0561133030864,0.928419742597);poisson_disk_samples[13]=vec2(-0.205799249508,-0.562072714492);poisson_disk_samples[14]=vec2(-0.526991665882,-0.193690188118);poisson_disk_samples[15]=vec2(-0.051789270667,-0.935374050821);}", wo = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  const Ao = { uniforms: { colorTexture: { value: null }, tNormalDepth: { value: null }, blurTexture: { value: null }, cocTexture: { value: null }, cocTextureSize: { value: new n.FM8() }, cameraNearFar: { value: new n.FM8() } }, vertexShader: lo, fragmentShader: _t + "\n#include <common>\n#include <packing>\nvarying vec2 vUv;uniform vec2 cocTextureSize;uniform vec2 nearFarBlurScale;uniform vec2 cameraNearFar;uniform vec2 focalDepthRange;uniform vec2 crossCenter;uniform float crossRadius;uniform float crossAlpha;uniform vec3 crossColor;float smoothBoundary(float d,float smooothFactor){smooothFactor*=0.5;float value=smoothstep(-smooothFactor,smooothFactor,d);return value;}float circle(vec2 p,float r){return min((length(p)-r),-(length(p)-r-0.01));}float computeCoc(){float depth=getDepth(vUv);if(depth>1.-0.01)return max(nearFarBlurScale.x,nearFarBlurScale.y);depth=mix(cameraNearFar.x,cameraNearFar.y,depth);float coc=(depth-focalDepthRange.x)/focalDepthRange.y;coc=clamp(coc,-1.,1.);return(coc>0.?coc*nearFarBlurScale.y:coc*nearFarBlurScale.x);}void main(){vec4 blur=blurTextureTexelToLinear(texture2D(blurTexture,vUv));float scale=0.5;blur+=blurTextureTexelToLinear(texture2D(blurTexture,vUv+scale*vec2(1.,1.)/cocTextureSize));blur+=blurTextureTexelToLinear(texture2D(blurTexture,vUv+scale*vec2(-1.,1.)/cocTextureSize));blur+=blurTextureTexelToLinear(texture2D(blurTexture,vUv+scale*vec2(-1.,-1.)/cocTextureSize));blur+=blurTextureTexelToLinear(texture2D(blurTexture,vUv+scale*vec2(1.,-1.)/cocTextureSize));blur/=5.;vec2 uvNearest=(floor(vUv*cocTextureSize)+0.5)/cocTextureSize;float coc=abs(min(2.*cocTextureTexelToLinear(texture2D(cocTexture,uvNearest)).a-1.,computeCoc()));float cocLower=0.005;float cocHigher=0.3;vec4 outColor=vec4(mix(colorTextureTexelToLinear(texture2D(colorTexture,vUv)).rgb,blur.rgb,smoothstep(cocLower,cocHigher,coc)),1.);vec2 d=vUv-crossCenter;if(length(d)>crossRadius+0.05){float dist=circle(d,crossRadius);gl_FragColor=outColor;}else{d.x*=cocTextureSize.x/cocTextureSize.y;float dist=circle(d,crossRadius);dist=smoothBoundary(dist,2.*fwidth(dist));vec4 color=outColor;vec3 dofCircleColor=mix(crossColor,color.rgb,1.-crossAlpha);gl_FragColor=vec4(mix(color.rgb,dofCircleColor,dist),color.a);}\n#include <encodings_fragment>\n}" }, xo = (pt({ uniforms: { cocTexture: { value: null }, colorTexture: { value: null }, colorTextureSize: { value: new n.FM8() }, direction: { value: new n.FM8() } }, vertexShader: lo, fragmentShader: "#include <common>\nvarying vec2 vUv;uniform vec2 colorTextureSize;uniform vec2 direction;const float MAXIMUM_BLUR_SIZE=16.;const float SIGMA=5.;const int NUM_SAMPLES=4;float normpdf(in float x,in float sigma){return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;}vec3 weightedBlur(){float cocIn=2.*cocTextureTexelToLinear(texture2D(cocTexture,vUv)).a-1.;float kernelRadius=MAXIMUM_BLUR_SIZE*cocIn;vec2 invSize=1./colorTextureSize;cocIn*=cocIn*cocIn;float centreSpaceWeight=normpdf(0.,SIGMA)*abs(cocIn);float weightSum=centreSpaceWeight;vec3 centreSample=colorTextureTexelToLinear(texture2D(colorTexture,vUv)).rgb;vec3 diffuseSum=centreSample*weightSum;vec2 delta=invSize*kernelRadius/float(NUM_SAMPLES);for(int i=1;i<=NUM_SAMPLES;i++){float spaceWeight=normpdf(float(i),SIGMA);vec2 texcoord=direction*delta*float(i);vec4 rightSample=colorTextureTexelToLinear(texture2D(colorTexture,vUv+texcoord));vec4 leftSample=colorTextureTexelToLinear(texture2D(colorTexture,vUv-texcoord));float leftCocWeight=abs(2.*cocTextureTexelToLinear(texture2D(cocTexture,vUv-texcoord)).a-1.);float rightCocWeight=abs(2.*cocTextureTexelToLinear(texture2D(cocTexture,vUv+texcoord)).a-1.);leftCocWeight*=leftCocWeight*leftCocWeight;rightCocWeight*=rightCocWeight*rightCocWeight;diffuseSum+=((leftSample.rgb*leftCocWeight)+(rightSample.rgb*rightCocWeight))*spaceWeight;weightSum+=(spaceWeight*(leftCocWeight+rightCocWeight));}return diffuseSum/weightSum;}void main(){gl_FragColor=vec4(weightedBlur(),1.);\n#include <encodings_fragment>\n}" }, "colorTexture", "cocTexture"), pt({ uniforms: { colorTexture: { value: null }, colorTextureSize: { value: new n.FM8() }, direction: { value: new n.FM8() }, frameCount: { value: 0 }, blurRadius: { value: 16 } }, vertexShader: lo, fragmentShader: co + "\n" + bo + "\n#include <common>\nvarying vec2 vUv;uniform vec2 colorTextureSize;uniform float blurRadius;vec4 CircularBlur(){vec4 color=colorTextureTexelToLinear(texture2D(colorTexture,vUv));\n#ifdef DOF_MODE\nfloat blurDist=blurRadius*(2.*color.a-1.);\n#else\nfloat blurDist=blurRadius*color.a;\n#endif\nfloat rnd=PI2*random3(vec3(vUv,frameCount*0.1));float costheta=cos(rnd);float sintheta=sin(rnd);vec4 rotationMatrix=vec4(costheta,-sintheta,sintheta,costheta);vec3 colorSum=vec3(0.);float weightSum=0.001;vec2 ofs;vec4 sampleColor;setPds();\n#pragma unroll_loop_start\nfor(int i=0;i<16;i++){ofs=poisson_disk_samples[UNROLLED_LOOP_INDEX];ofs=vec2(dot(ofs,rotationMatrix.xy),dot(ofs,rotationMatrix.zw));sampleColor=colorTextureTexelToLinear(texture2D(colorTexture,vUv+blurDist*ofs/colorTextureSize.xy));\n#ifdef DOF_MODE\nsampleColor.a=abs(sampleColor.a*2.-1.);sampleColor.a*=sampleColor.a*sampleColor.a;\n#endif\ncolorSum+=sampleColor.rgb*sampleColor.a;weightSum+=sampleColor.a;}\n#pragma unroll_loop_end\ncolorSum/=weightSum;return vec4(min(vec3(72.),max(vec3(0.),colorSum)),1.);}void main(){gl_FragColor=CircularBlur();\n#include <encodings_fragment>\n}", defines: { DOF_MODE: 1 } }, "colorTexture"));
  class Eo extends dt {
    constructor() {
      super(Ao, "colorTexture", "cocTexture", "blurTexture"), this.dofBlurMaterial = xo, this.nearFarBlurScale = new n.FM8(0.25, 0.25), this.focalDepthRange = new n.FM8(0.5, 1.5), this.crossCenter = new n.FM8(0.5, 0.5), this.crossRadius = 0.04, this.crossAlpha = 1, this.crossColor = new n.Ilk(16750848), this.uiConfig = { type: "folder", label: "Depth of Field", children: [{ type: "checkbox", label: "Enabled", limitedUi: true, property: [this, "enabled"] }, { type: "slider", label: "Depth Range", bounds: [0.5, 3], property: [this.focalDepthRange, "y"] }, { type: "slider", label: "Near Blur scale", bounds: [0, 1], property: [this.nearFarBlurScale, "x"] }, { type: "slider", label: "Far Blur scale", bounds: [0, 1], property: [this.nearFarBlurScale, "y"] }] }, this.material.extensions.derivatives = true, this.computeCocMaterial = pt({ uniforms: { colorTexture: { value: null }, tNormalDepth: this.uniforms.tNormalDepth, cameraNearFar: this.uniforms.cameraNearFar, nearFarBlurScale: this.uniforms.nearFarBlurScale, focalDepthRange: this.uniforms.focalDepthRange }, vertexShader: lo, fragmentShader: _t + "\n#include <common>\n#include <packing>\nvarying vec2 vUv;uniform vec2 nearFarBlurScale;uniform vec2 cameraNearFar;uniform vec2 focalDepthRange;float computeCoc(){float depth=getDepth(vUv);if(depth==1.)return max(nearFarBlurScale.x,nearFarBlurScale.y);depth=mix(cameraNearFar.x,cameraNearFar.y,depth);float coc=(depth-focalDepthRange.x)/focalDepthRange.y;coc=clamp(coc,-1.,1.);return(coc>0.?coc*nearFarBlurScale.y:coc*nearFarBlurScale.x);}void main(){gl_FragColor=vec4(colorTextureTexelToLinear(texture2D(colorTexture,vUv)).rgb,0.5*computeCoc()+0.5);\n#include <encodings_fragment>\n}" }, "colorTexture"), this.expandCocMaterial = pt({ uniforms: { colorTexture: { value: null }, colorTextureSize: { value: new n.FM8() }, direction: { value: new n.FM8() }, tNormalDepth: this.uniforms.tNormalDepth, nearFarBlurScale: this.uniforms.nearFarBlurScale }, vertexShader: lo, fragmentShader: _t + "\n#include <common>\nvarying vec2 vUv;uniform vec2 colorTextureSize;uniform vec2 direction;uniform vec2 nearFarBlurScale;const float MAXIMUM_BLUR_SIZE=4.;float expandNear(const in vec2 offset,const in bool isBackground){float coc=0.;vec2 sampleOffsets=MAXIMUM_BLUR_SIZE*offset/5.;float coc0=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv)).a-1.;float coc1=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-5.*sampleOffsets)).a-1.;float coc2=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-4.*sampleOffsets)).a-1.;float coc3=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-3.*sampleOffsets)).a-1.;float coc4=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-2.*sampleOffsets)).a-1.;float coc5=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-1.*sampleOffsets)).a-1.;float coc6=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+1.*sampleOffsets)).a-1.;float coc7=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+2.*sampleOffsets)).a-1.;float coc8=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+3.*sampleOffsets)).a-1.;float coc9=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+4.*sampleOffsets)).a-1.;float coc10=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+5.*sampleOffsets)).a-1.;if(isBackground){coc=abs(coc0)*0.095474+(abs(coc1)+abs(coc10))*0.084264+(abs(coc2)+abs(coc9))*0.088139+(abs(coc3)+abs(coc8))*0.091276+(abs(coc4)+abs(coc7))*0.093585+(abs(coc5)+abs(coc6))*0.094998;}else{coc=min(coc0,0.);coc=min(coc1*0.3,coc);coc=min(coc2*0.5,coc);coc=min(coc3*0.75,coc);coc=min(coc4*0.8,coc);coc=min(coc5*0.95,coc);coc=min(coc6*0.95,coc);coc=min(coc7*0.8,coc);coc=min(coc8*0.75,coc);coc=min(coc9*0.5,coc);coc=min(coc10*0.3,coc);if(abs(coc0)>abs(coc))coc=coc0;}return coc;}void main(){vec2 offset=2.*direction/colorTextureSize;bool isBackground=getDepth(vUv)>1.-0.001;float coc=expandNear(offset,isBackground);gl_FragColor=vec4(colorTextureTexelToLinear(texture2D(colorTexture,vUv)).rgb,0.5*coc+0.5);\n#include <encodings_fragment>\n}" }, "colorTexture");
    }
    render(e2, t2, r2, i2, s2) {
      if (!this.enabled)
        return;
      const o2 = e2.baseRenderer, a2 = { minFilter: n.TyD, magFilter: n.TyD, type: n.cLu, colorSpace: n.GUF, sizeMultiplier: 0.5, format: n.wk1, depthBuffer: false, generateMipmaps: false }, l2 = o2.getTempTarget(a2), c2 = o2.getTempTarget(a2);
      if (this.computeCocMaterial.uniforms.colorTexture.value = r2.texture, o2.blit(void 0, l2, { material: this.computeCocMaterial }), this.expandCocMaterial.uniforms.colorTexture.value = l2.texture, this.expandCocMaterial.uniforms.direction.value.set(1, 0), o2.blit(void 0, c2, { material: this.expandCocMaterial }), this.expandCocMaterial.uniforms.colorTexture.value = c2.texture, this.expandCocMaterial.uniforms.direction.value.set(0, 1), o2.blit(void 0, l2, { material: this.expandCocMaterial }), this.dofBlurMaterial.uniforms.frameCount)
        this.dofBlurMaterial.uniforms.colorTexture.value = l2.texture, o2.blit(void 0, c2, { material: this.dofBlurMaterial });
      else {
        const e3 = o2.getTempTarget(a2);
        this.dofBlurMaterial.uniforms.cocTexture.value = l2.texture, this.dofBlurMaterial.uniforms.colorTexture.value = l2.texture, this.dofBlurMaterial.uniforms.direction.value.set(1, 0), o2.blit(void 0, e3, { material: this.dofBlurMaterial }), this.dofBlurMaterial.uniforms.colorTexture.value = e3.texture, this.dofBlurMaterial.uniforms.direction.value.set(0, 1), o2.blit(void 0, c2, { material: this.dofBlurMaterial }), o2.releaseTempTarget(e3);
      }
      this.material.uniforms.blurTexture.value = c2.texture, this.material.uniforms.cocTexture.value = l2.texture, super.render(e2, t2, r2, i2, s2), o2.releaseTempTarget(l2), o2.releaseTempTarget(c2);
    }
  }
  wo([ie(), j()], Eo.prototype, "nearFarBlurScale", void 0), wo([ie(), j()], Eo.prototype, "focalDepthRange", void 0), wo([j()], Eo.prototype, "crossCenter", void 0), wo([j()], Eo.prototype, "crossRadius", void 0), wo([j()], Eo.prototype, "crossAlpha", void 0), wo([j()], Eo.prototype, "crossColor", void 0);
  class Co extends dt {
    constructor(e2) {
      super({ vertexShader: r.vertexShader, fragmentShader: t.glsl`
                uniform vec4 weight;
                uniform vec4 weight2;
                varying vec2 vUv;
                void main() {
                    vec4 texel = clamp(weight * tDiffuseTexelToLinear ( texture2D( tDiffuse, vUv ) ) + weight2 * tDiffuse2TexelToLinear ( texture2D( tDiffuse2, vUv ) ), vec4(0), vec4(8));
                    gl_FragColor = texel;
                    #include <encodings_fragment>
                }
            `, uniforms: { tDiffuse: { value: null }, tDiffuse2: { value: e2 }, weight: { value: new n.Ltg(1, 1, 1, 1) }, weight2: { value: new n.Ltg(1, 1, 1, 1) } } }, "tDiffuse", "tDiffuse2"), this.clear = false, this.needsSwap = true;
    }
    set weights2(e2) {
      this.uniforms.weight2.value.copy(e2);
    }
    get weights2() {
      return this.uniforms.weight2.value;
    }
    set weights1(e2) {
      this.uniforms.weight.value.copy(e2);
    }
    get weights1() {
      return this.uniforms.weight.value;
    }
    set blendTexture(e2) {
      this.uniforms.tDiffuse2.value = e2;
    }
  }
  var So = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  const Mo = [{ x: 0, y: 0 }, { x: -0.5, y: 0 }, { x: -0.375, y: -0.25 }, { x: -0.1875, y: -0.125 }, { x: -0.125, y: -0.375 }, { x: 0.0625, y: -0.0625 }, { x: 0.125, y: -0.3125 }, { x: 0.375, y: -0.4375 }, { x: 0.3125, y: -0.1875 }, { x: 0.25, y: 0.0625 }, { x: 0.4375, y: 0.25 }, { x: 0.1875, y: 0.3125 }, { x: 0, y: 0.4375 }, { x: -0.0625, y: 0.1875 }, { x: -0.25, y: 0.375 }, { x: -0.4375, y: 0.5 }, { x: -0.3125, y: 0.125 }];
  class To extends so {
    constructor(e2 = 2 * Mo.length) {
      super(), this._lastFrames = /* @__PURE__ */ new Map(), this.enabled = true, this.jitter = true, this._hasSetOffset = false, this.trackedJitterCameras = /* @__PURE__ */ new Set(), this._addSceneObject = (e3) => {
        const t2 = e3.object;
        (t2.modelObject || t2.lightObject) && (t2.modelObject || t2.lightObject).traverse((e4) => {
          var t3;
          (null === (t3 = null == e4 ? void 0 : e4.shadow) || void 0 === t3 ? void 0 : t3.camera) && e4.shadow.mapSize && this.trackedJitterCameras.add([e4.shadow.camera, e4.shadow.mapSize]);
        });
      }, this._jitterCamera = (e3) => {
        var t2;
        const n2 = e3.target;
        if (this.jitter && n2.renderer.frameCount > 1) {
          const e4 = (e5, t3) => {
            const r3 = { ...Mo[n2.renderer.frameCount % Mo.length] };
            e5.setViewOffset(t3.width, t3.height, r3.x, r3.y, t3.width, t3.height);
          }, r2 = n2.scene.activeCamera.cameraObject;
          e4(r2, { width: n2.canvas.clientWidth * n2.renderer.displayCanvasScaling, height: n2.canvas.clientHeight * n2.renderer.displayCanvasScaling }), this.trackedJitterCameras.forEach((t3) => e4(...t3)), this._hasSetOffset = true, null === (t2 = this._viewer) || void 0 === t2 || t2.renderer.resetShadows();
        }
      }, this._resetCameraJitter = (e3) => {
        const t2 = e3.target;
        this._hasSetOffset && (t2.scene.activeCamera.cameraObject.clearViewOffset(), this._hasSetOffset = false);
      }, this.uiConfig = Qe("Progressive", this), this.maxFrameCount = e2;
    }
    async onAdded(e2) {
      return await super.onAdded(e2);
    }
    async onRemove(e2) {
      e2.removeEventListener("preRender", this._jitterCamera), e2.removeEventListener("postRender", this._resetCameraJitter), e2.scene.removeEventListener("addSceneObject", this._addSceneObject), this._lastFrames.forEach((t2) => e2.renderer.disposeTarget(t2)), this._lastFrames.clear(), await super.onRemove(e2);
    }
    get lastFrame() {
      var e2;
      return this._lastFrames.get(null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.scene.renderCamera.cameraObject.uuid);
    }
    getLastFrame(e2) {
      return e2 ? this._lastFrames.get(e2.cameraObject.uuid) : this.lastFrame;
    }
    createPasses(e2) {
      e2.addEventListener("preRender", this._jitterCamera), e2.addEventListener("postRender", this._resetCameraJitter), e2.scene.addEventListener("addSceneObject", this._addSceneObject);
      const t2 = this, n2 = vt(e2, { passId: "progressive", get dirty() {
        var e3;
        return t2.jitter && ((null === (e3 = t2._viewer) || void 0 === e3 ? void 0 : e3.renderer.frameCount) || 0) < t2.maxFrameCount;
      }, after: ["render"], before: ["combinedPost", "screen"], required: ["render"], passObject: new class extends Co {
        render(n3, r2, i2, s2, o2) {
          if (t2.lastFrame) {
            if (e2.renderer.frameCount < 1)
              return this.needsSwap = false, void ((null == i2 ? void 0 : i2.texture) && e2.renderer.blit(i2.texture, t2.lastFrame, {}));
            this.needsSwap = true, super.render(n3, r2, i2, s2, o2), e2.renderer.blit(r2.texture, t2.lastFrame, {});
          } else
            e2.console.error("lastFrame render target undefined");
        }
      }(), update() {
        if (!t2.lastFrame && e2.scene.renderCamera && t2._lastFrames.set(e2.scene.renderCamera.cameraObject.uuid, e2.renderer.composerTarget.clone(true)), !t2.lastFrame)
          return void console.error("lastFrame render target undefined");
        let n3 = 1 / (Math.max(e2.renderer.frameCount, 0) + 1);
        this.passObject.weights1.set(n3, n3, n3, n3), n3 = 1 - n3, this.passObject.weights2.set(n3, n3, n3, n3), this.passObject.blendTexture = t2.lastFrame.texture, this.passObject.material.uniformsNeedUpdate = true;
      } });
      return [n2];
    }
    isConverged(e2 = false) {
      var t2;
      return ((null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.renderer.frameCount) || 0) >= this.maxFrameCount - 1 + (e2 ? 1 : 0);
    }
    updateShaderProperties(e2) {
      var t2, n2;
      return e2.uniforms.tLastFrame && (e2.uniforms.tLastFrame.value = null !== (n2 = null === (t2 = this.lastFrame) || void 0 === t2 ? void 0 : t2.texture) && void 0 !== n2 ? n2 : void 0), this;
    }
    postFrameConvergedRecordingDelta(e2 = "CanvasRecorder") {
      const t2 = this._viewer.getPluginByType(e2);
      return t2 && t2.isRecording() && t2.convergeMode ? this.isConverged(true) ? 1 / t2.videoFrameRate : 0 : -1;
    }
  }
  To.PluginType = "Progressive", So([ie(), ze("Frame count")], To.prototype, "maxFrameCount", void 0), So([ie(), Oe("Jitter")], To.prototype, "jitter", void 0);
  class Po extends yt {
    async startTransition(e2) {
      this._viewer && this._pass && !this.isDisabled() && (this._target || (this._target = this._viewer.renderer.getTempTarget({ sizeMultiplier: 1, minFilter: n.wem, magFilter: n.wem, colorSpace: this._viewer.renderer.composerTarget.texture.colorSpace })), this._fadeTimeState < 500 && (this._toSaveFrame = true), this._fadeTimeState = Math.max(e2, this._fadeTimeState), this._fadeTime = this._fadeTimeState, this.setDirty(), await (0, t.timeout)(e2));
    }
    stopTransition() {
      this._fadeTimeState = 0;
    }
    constructor() {
      super(), this.passId = "frameFade", this._fadeTime = 0, this._fadeTimeState = 0, this._toSaveFrame = false, this._beforeFilters = ["progressive", "taa"], this._afterFilters = ["render"], this._requiredFilters = ["render", "progressive"], this.dependencies = [To], this.fadeOnActiveCameraChange = true, this.fadeOnMaterialUpdate = true, this.fadeOnSceneUpdate = true, this.pointerEnabled = true, this._fadeCam = (e2) => false !== e2.frameFade && this.fadeOnActiveCameraChange && this.startTransition(e2.fadeDuration || 1e3), this._fadeMat = (e2) => {
        false !== e2.frameFade && this.fadeOnMaterialUpdate && this.startTransition(e2.fadeDuration || 200);
      }, this._fadeScene = (e2) => {
        false !== e2.frameFade && this.fadeOnSceneUpdate && this.startTransition(e2.fadeDuration || 500);
      }, this._onPointerMove = (e2) => {
        var t2;
        const n2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.canvas;
        if (!n2)
          return void (this.pointerEnabled = false);
        if (!e2.buttons || e2.target !== n2)
          return void (this.pointerEnabled = true);
        const r2 = n2.getBoundingClientRect(), i2 = (e2.clientX - r2.left) / r2.width, s2 = (e2.clientY - r2.top) / r2.height;
        this.pointerEnabled = i2 < 0 || i2 > 1 || s2 < 0 || s2 > 1;
      }, this._disabledBy = [], this.startTransition = this.startTransition.bind(this), this.stopTransition = this.stopTransition.bind(this), this._fadeCam = this._fadeCam.bind(this), this._fadeMat = this._fadeMat.bind(this);
    }
    async onAdded(e2) {
      await super.onAdded(e2), e2.scene.addEventListener("activeCameraChange", this._fadeCam), e2.scene.addEventListener("activeCameraUpdate", this.stopTransition), e2.scene.addEventListener("sceneMaterialUpdate", this._fadeMat), e2.scene.addEventListener("sceneUpdate", this._fadeScene), window.addEventListener("pointermove", this._onPointerMove);
    }
    async onRemove(e2) {
      return e2.scene.removeEventListener("activeCameraChange", this._fadeCam), e2.scene.removeEventListener("activeCameraUpdate", this.stopTransition), e2.scene.removeEventListener("sceneMaterialUpdate", this._fadeMat), e2.scene.removeEventListener("sceneUpdate", this._fadeScene), window.removeEventListener("pointermove", this._onPointerMove), super.onRemove(e2);
    }
    passCtor(e2) {
      const n2 = this, r2 = e2.getPlugin(To), i2 = new class extends Co {
        constructor() {
          super(...arguments), this._lastTime = 0, this._saveNextFrame = false, this.uiConfig = Qe("Frame Fade", this);
        }
        render(i3, s2, o2, a2, l2) {
          this.needsSwap = false;
          const c2 = n2._target;
          if (!c2 || !n2.pointerEnabled || !this.enabled || !n2.dirty || n2._fadeTimeState < 1e-3 || e2.scene.renderCamera !== e2.scene.activeCamera)
            return;
          n2._toSaveFrame && (this._saveNextFrame = true, n2._toSaveFrame = false), this._saveNextFrame && r2.lastFrame && (e2.renderer.blit(r2.lastFrame.texture, c2), this._lastTime = 0, this._saveNextFrame = false), this.blendTexture = null == c2 ? void 0 : c2.texture;
          const u2 = n2._fadeTimeState / n2._fadeTime;
          this.weights2.setScalar(u2), this.weights2.w = 1, this.weights1.setScalar(1 - u2), this.weights1.w = 1, super.render(i3, s2, o2, a2, l2), this.needsSwap = true;
          const p2 = (0, t.now)();
          this._lastTime < 10 && (this._lastTime = p2 - 10);
          const d2 = p2 - this._lastTime;
          this._lastTime = p2, n2._fadeTimeState -= d2;
        }
      }();
      return i2.enabled = true, i2;
    }
    setDirty() {
      var e2;
      this.enabled && (null === (e2 = this._viewer) || void 0 === e2 || e2.setDirty());
    }
    get dirty() {
      return this.enabled && this._fadeTimeState > 0;
    }
    set dirty(e2) {
      console.warn("FrameFadePlugin.dirty is readonly");
    }
    _update(e2) {
      return !!super._update(e2) && (this.isDisabled() && this.stopTransition(), this._fadeTimeState < 1 && (this._toSaveFrame = false, this._target && this._viewer && (this._viewer.renderer.releaseTempTarget(this._target), this._target = void 0)), true);
    }
    get uiConfig() {
      var e2, t2;
      return null === (t2 = null === (e2 = this.pass) || void 0 === e2 ? void 0 : e2.passObject) || void 0 === t2 ? void 0 : t2.uiConfig;
    }
    disable(e2) {
      this._disabledBy.includes(e2) || this._disabledBy.push(e2);
    }
    enable(e2) {
      const t2 = this._disabledBy.indexOf(e2);
      t2 >= 0 && this._disabledBy.splice(t2, 1);
    }
    isDisabled() {
      return !this.pointerEnabled || this._disabledBy.length > 0 || !this.enabled;
    }
  }
  Po.PluginType = "FrameFade";
  var Io = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  class Ro extends yt {
    passCtor(e2) {
      return new Eo();
    }
    constructor(e2 = true, t2 = false) {
      super(), this.passId = "depthOfField", this._beforeFilters = ["progressive", "tonemap", "screen"], this._afterFilters = ["render"], this._requiredFilters = ["render"], this.dependencies = [wt], this.enableEdit = false, this._focalPointHit = new n.Pa4(0, 0, 0), this.crossFadeTime = 200, this._focalPointHitTime = 0, this._tempVec = new n.Pa4(), this.enabled = e2, this.enableEdit = t2, this._onObjectHit = this._onObjectHit.bind(this), this.setDirty = this.setDirty.bind(this);
    }
    setFocalPoint(e2, n2 = true, r2 = false) {
      var i2, s2;
      this._focalPointHit.copy(e2), n2 && (null === (s2 = null === (i2 = this._viewer) || void 0 === i2 ? void 0 : i2.getPlugin(Po)) || void 0 === s2 || s2.startTransition(this._frameFadeTime)), r2 && (this._focalPointHitTime = (0, t.now)()), this.setDirty();
    }
    getFocalPoint() {
      return this._focalPointHit;
    }
    get depthRange() {
      var e2, t2;
      return null !== (t2 = null === (e2 = this.pass) || void 0 === e2 ? void 0 : e2.passObject.focalDepthRange.y) && void 0 !== t2 ? t2 : 0;
    }
    set depthRange(e2) {
      this.pass && (this.pass.passObject.focalDepthRange.y = e2), this.setDirty();
    }
    get nearBlurScale() {
      var e2, t2;
      return null !== (t2 = null === (e2 = this.pass) || void 0 === e2 ? void 0 : e2.passObject.nearFarBlurScale.x) && void 0 !== t2 ? t2 : 0;
    }
    set nearBlurScale(e2) {
      this.pass && (this.pass.passObject.nearFarBlurScale.x = e2), this.setDirty();
    }
    get farBlurScale() {
      var e2, t2;
      return null !== (t2 = null === (e2 = this.pass) || void 0 === e2 ? void 0 : e2.passObject.nearFarBlurScale.y) && void 0 !== t2 ? t2 : 0;
    }
    set farBlurScale(e2) {
      this.pass && (this.pass.passObject.nearFarBlurScale.y = e2), this.setDirty();
    }
    get _frameFadeTime() {
      return 2.5 * this.crossFadeTime;
    }
    _onObjectHit(e2) {
      var t2, n2;
      this._pass && e2.intersects.intersect && this.enabled && this.enableEdit && (this._focalPointHit.copy(e2.intersects.intersect.point), this._focalPointHitTime = e2.time, e2.intersects.selectedObject = null, null === (n2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(Po)) || void 0 === n2 || n2.startTransition(this._frameFadeTime), this.setDirty());
    }
    async onAdded(e2) {
      var t2;
      await super.onAdded(e2), null === (t2 = e2.getPluginByType("Picking")) || void 0 === t2 || t2.addEventListener("hitObject", this._onObjectHit);
    }
    async onRemove(e2) {
      var t2;
      return null === (t2 = e2.getPluginByType("Picking")) || void 0 === t2 || t2.removeEventListener("hitObject", this._onObjectHit), super.onRemove(e2);
    }
    setDirty() {
      var e2;
      null === (e2 = this._viewer) || void 0 === e2 || e2.setDirty();
    }
    _update(e2) {
      var r2, i2;
      if (!super._update(e2))
        return false;
      const s2 = null === (r2 = this.pass) || void 0 === r2 ? void 0 : r2.passObject;
      if (!s2)
        return false;
      const o2 = e2.getPlugin(wt);
      null == o2 || o2.updateShaderProperties(s2.material), s2.dofBlurMaterial.uniforms.frameCount && (null === (i2 = e2.renderer) || void 0 === i2 || i2.updateShaderProperties(s2.dofBlurMaterial));
      const a2 = e2.scene.renderCamera;
      if (!a2)
        return false;
      a2.cameraObject.updateMatrixWorld(true), a2.updateShaderProperties(s2.material), a2.cameraObject.getWorldPosition(this._tempVec), this._tempVec.subVectors(this._focalPointHit, this._tempVec), s2.focalDepthRange.x = this._tempVec.length(), s2.focalDepthRange.x *= a2.cameraObject.getWorldDirection(new n.Pa4()).dot(this._tempVec.normalize());
      let l2 = ((0, t.now)() - this._focalPointHitTime) / this.crossFadeTime;
      if (l2 = 1 - Math.min(1, Math.max(0, l2)), Math.abs(l2 - s2.crossAlpha) > 0.01 && (s2.crossAlpha = l2, this.setDirty()), l2 > 0) {
        const e3 = this._tempVec.copy(this._focalPointHit).project(a2.cameraObject).addScalar(1).divideScalar(2);
        s2.crossCenter.set(e3.x, e3.y), s2.computeCocMaterial.uniformsNeedUpdate = true, s2.expandCocMaterial.uniformsNeedUpdate = true;
      }
      return true;
    }
    get uiConfig() {
      var e2, n2, r2, i2, s2;
      if (this._uiConfig)
        return this._uiConfig;
      const o2 = null === (n2 = null === (e2 = this._pass) || void 0 === e2 ? void 0 : e2.passObject) || void 0 === n2 ? void 0 : n2.uiConfig;
      return o2 ? (null === (i2 = null === (r2 = o2.children) || void 0 === r2 ? void 0 : r2.map((e3) => (0, t.getOrCall)(e3))) || void 0 === i2 || i2.flat(2).forEach((e3) => e3 && (e3.onChange = this.setDirty)), null === (s2 = o2.children) || void 0 === s2 || s2.push({ type: "checkbox", label: "Enable Edit", limitedUi: true, property: [this, "enableEdit"] }), this._uiConfig = o2, o2) : {};
    }
  }
  Ro.PluginType = "DepthOfField", Io([ie()], Ro.prototype, "enableEdit", void 0), Io([ie("focalPoint")], Ro.prototype, "_focalPointHit", void 0), Io([ie()], Ro.prototype, "crossFadeTime", void 0);
  var ko = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let Do = class extends gt {
    addThinFilmLayer(e2) {
      return Bo(e2.materialObject);
    }
    _loaderCreate({ loader: e2 }) {
      e2.isGLTFLoader2 && e2.register((e3) => new Oo(e3));
    }
    constructor() {
      super(), this.enabled = true, this.dependencies = [Ls], this._defines = {}, this._uniforms = { thinBaseLayerFactors: { value: new n.Ltg() }, thinNoiseLayerFactors: { value: new n.Ltg() }, thinColorNoiseParams: { value: new n.Ltg() }, thinFilmFactor: { value: 0.8 } }, this.materialExtension = { parsFragmentSnippet: (e2, t2) => {
        var n2;
        return this.enabled && (null === (n2 = null == t2 ? void 0 : t2.materialObject.userData._thinFilmLayer) || void 0 === n2 ? void 0 : n2.hasThinFilm) ? co + "\n#ifndef VORONOISE_HELPER\n#define VORONOISE_HELPER \nfloat voronoise(in vec2 p,float u,float v){float k=1.+63.*pow(1.-v,6.);vec2 i=floor(p);vec2 f=fract(p);vec2 a=vec2(0.,0.);for(int y=-2;y<=2;y++)for(int x=-2;x<=2;x++){vec2 g=vec2(x,y);vec3 o=hash3(i+g)*vec3(u,u,1.);vec2 d=g-f+o.xy;float w=pow(1.-smoothstep(0.,1.414,length(d)),k);a+=vec2(o.z*w,w);}return a.x/a.y;}vec3 voronoise3(vec2 p,float u,float v){return vec3(voronoise(p,u,v),voronoise(p+vec2(0.435,0.23),u,v),voronoise(p-vec2(0.83,0.45),u,v));}vec3 voronoiseNormal(vec2 p,float u,float v){return vec3(voronoise(p,u,v),voronoise(p+vec2(0.435,0.23),u,v),1.);}\n#endif\n\n#ifndef HSV_HELPERS\n#define HSV_HELPERS \nvec3 hsv2rgb(vec3 c){vec4 K=vec4(1.,2./3.,1./3.,3.);vec3 p=abs(fract(c.xxx+K.xyz)*6.-K.www);return c.z*mix(K.xxx,clamp(p-K.xxx,0.,1.),c.y);}vec3 rgb2hsv(vec3 c){vec4 K=vec4(0.,-1./3.,2./3.,-1.);vec4 p=c.g<c.b?vec4(c.bg,K.wz):vec4(c.gb,K.xy);vec4 q=c.r<p.x?vec4(p.xyw,c.r):vec4(c.r,p.yzx);float d=q.x-min(q.w,q.y);float e=1.0e-10;return vec3(abs(q.z+(q.w-q.y)/(6.*d+e)),d/(q.x+e),q.x);}\n#endif \n\nuniform vec4 thinBaseLayerFactors;\nuniform vec4 thinNoiseLayerFactors;\nuniform vec4 thinColorNoiseParams;\nuniform float thinFilmFactor;\n        " : "";
      }, shaderExtender: (e2, t2, n2) => {
        var r2;
        if (!this.enabled || !(null === (r2 = t2.materialObject.userData._thinFilmLayer) || void 0 === r2 ? void 0 : r2.hasThinFilm))
          return;
        const i2 = "#glMarker beforeAccumulation";
        e2.fragmentShader = e2.fragmentShader.replace(i2, "vec3 incident=normalize(vViewPosition.xyz);float hWeight=1.-dot(normal,incident);vec3 noiseV=voronoise3(vUv.xy*thinColorNoiseParams.xy*60.,thinColorNoiseParams.z,thinColorNoiseParams.w);float hWeight2=1.-dot(normalize(noiseV),incident);vec3 film=hsv2rgb(vec3(fract(hWeight+thinBaseLayerFactors.x),thinBaseLayerFactors.y,thinBaseLayerFactors.z))*thinBaseLayerFactors.a;vec3 film2=hsv2rgb(vec3(fract(hWeight2+thinNoiseLayerFactors.x),thinNoiseLayerFactors.y,thinNoiseLayerFactors.z))*thinNoiseLayerFactors.a;film=(film+film2)/(thinBaseLayerFactors.a+thinNoiseLayerFactors.a);diffuseColor.rgb=mix(diffuseColor.rgb,film,thinFilmFactor);" + i2), e2.defines.USE_UV = "";
      }, onObjectRender: (e2, t2) => {
        var n2;
        const r2 = null === (n2 = t2.materialObject.userData) || void 0 === n2 ? void 0 : n2._thinFilmLayer;
        if (!(null == r2 ? void 0 : r2.hasThinFilm))
          return;
        this._uniforms.thinBaseLayerFactors.value.fromArray(r2.baseLayerFactors), this._uniforms.thinNoiseLayerFactors.value.fromArray(r2.noiseLayerFactors), this._uniforms.thinColorNoiseParams.value.fromArray(r2.colorNoiseParams), this._uniforms.thinFilmFactor.value = r2.filmFactor;
        const i2 = this.enabled ? 1 : 0;
        t2.materialObject.defines.THIN_FILM_LAYER_ENABLED !== i2 && (t2.materialObject.defines.THIN_FILM_LAYER_ENABLED = i2, t2.materialObject.needsUpdate = true);
      }, extraUniforms: { ...this._uniforms }, computeCacheKey: (e2) => {
        var t2, n2;
        return (this.enabled ? "1" : "0") + ((null === (n2 = null === (t2 = e2.materialObject.userData) || void 0 === t2 ? void 0 : t2._thinFilmLayer) || void 0 === n2 ? void 0 : n2.hasThinFilm) ? "1" : "0");
      }, isCompatible: (e2) => e2.isMeshStandardMaterial2 || e2.isDiamondMaterial, updaters: () => [], getUiConfig: (e2) => {
        const t2 = this._viewer, n2 = { type: "folder", label: "ThinFilmLayer", children: [{ type: "checkbox", label: "Enabled", get value() {
          var t3;
          return (null === (t3 = e2.materialObject.userData._thinFilmLayer) || void 0 === t3 ? void 0 : t3.hasThinFilm) || false;
        }, set value(r2) {
          var i2, s2;
          r2 !== (null === (i2 = e2.materialObject.userData._thinFilmLayer) || void 0 === i2 ? void 0 : i2.hasThinFilm) && (r2 ? Bo(e2.materialObject) || t2.alert("Cannot add thin film.") : e2.materialObject.userData._thinFilmLayer && (e2.materialObject.userData._thinFilmLayer.hasThinFilm = false, e2.materialObject.needsUpdate = true), null === (s2 = n2.uiRefresh) || void 0 === s2 || s2.call(n2, "postFrame", true));
        }, onChange: this.setDirty }, () => ({ type: "slider", bounds: [0, 1], label: "Intensity", hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._thinFilmLayer) || void 0 === t3 ? void 0 : t3.hasThinFilm);
        }, property: [e2.materialObject.userData._thinFilmLayer, "filmFactor"], onChange: this.setDirty }), () => ({ type: "vec4", label: "Base Layer", bounds: [0, 1], hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._thinFilmLayer) || void 0 === t3 ? void 0 : t3.hasThinFilm);
        }, property: [e2.materialObject.userData._thinFilmLayer, "baseLayerFactors"], onChange: this.setDirty }), () => ({ type: "vec4", label: "Noise Layer", bounds: [0, 1], hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._thinFilmLayer) || void 0 === t3 ? void 0 : t3.hasThinFilm);
        }, property: [e2.materialObject.userData._thinFilmLayer, "noiseLayerFactors"], onChange: this.setDirty }), () => ({ type: "vec4", label: "Noise Params", bounds: [0, 1], hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._thinFilmLayer) || void 0 === t3 ? void 0 : t3.hasThinFilm);
        }, property: [e2.materialObject.userData._thinFilmLayer, "colorNoiseParams"], onChange: this.setDirty })] };
        return n2;
      } }, this.setDirty = () => {
        var e2;
        null === (e2 = this._viewer) || void 0 === e2 || e2.setDirty();
      }, this._loaderCreate = this._loaderCreate.bind(this);
    }
    async onAdded(e2) {
      var t2, n2, r2, i2, s2;
      await super.onAdded(e2);
      const o2 = e2.getPlugin(Ls);
      null === (t2 = null == o2 ? void 0 : o2.materials) || void 0 === t2 || t2.registerMaterialExtension(this.materialExtension), null === (n2 = null == o2 ? void 0 : o2.importer) || void 0 === n2 || n2.addEventListener("loaderCreate", this._loaderCreate), null === (s2 = null === (i2 = null === (r2 = null == o2 ? void 0 : o2.exporter) || void 0 === r2 ? void 0 : r2.getExporter("gltf", "glb")) || void 0 === i2 ? void 0 : i2.extensions) || void 0 === s2 || s2.push(Lo);
    }
    async onRemove(e2) {
      var t2, n2, r2, i2;
      return null === (n2 = null === (t2 = e2.getPlugin(Ls)) || void 0 === t2 ? void 0 : t2.materials) || void 0 === n2 || n2.unregisterMaterialExtension(this.materialExtension), null === (i2 = null === (r2 = e2.getPlugin(Ls)) || void 0 === r2 ? void 0 : r2.importer) || void 0 === i2 || i2.removeEventListener("loaderCreate", this._loaderCreate), super.onRemove(e2);
    }
  };
  function Bo(e2) {
    const t2 = null == e2 ? void 0 : e2.userData;
    if (!t2)
      return false;
    t2._thinFilmLayer || (t2._thinFilmLayer = {});
    const n2 = t2._thinFilmLayer;
    return n2.hasThinFilm = true, void 0 === n2.baseLayerFactors && (n2.baseLayerFactors = [0.3, 0.6, 1, 0.9]), void 0 === n2.noiseLayerFactors && (n2.noiseLayerFactors = [0.7, 0.5, 0.9, 0.7]), void 0 === n2.colorNoiseParams && (n2.colorNoiseParams = [0.5, 0.5, 0.5, 0.7]), void 0 === n2.filmFactor && (n2.filmFactor = 0.3), e2.isMaterial && (e2.needsUpdate = true), true;
  }
  Do.PluginType = "ThinFilmLayerPlugin", Do.THIN_FILM_LAYER_GLTF_EXTENSION = "WEBGI_materials_thin_film_layer", ko([Oe("Enabled", (e2) => ({ onChange: e2.setDirty })), ie()], Do.prototype, "enabled", void 0), Do = ko([We("ThinFilmLayer Materials")], Do);
  class Oo {
    constructor(e2) {
      this.parser = e2, this.name = Do.THIN_FILM_LAYER_GLTF_EXTENSION;
    }
    async extendMaterialParams(e2, t2) {
      const n2 = this.parser.json.materials[e2];
      if (!n2.extensions || !n2.extensions[this.name])
        return Promise.resolve();
      const r2 = n2.extensions[this.name];
      return t2.userData || (t2.userData = {}), Bo(t2), t2.userData._thinFilmLayer = ce(r2, t2.userData._thinFilmLayer, false, {}), Promise.resolve();
    }
  }
  const Lo = (e2) => ({ writeMaterial: (t2, n2) => {
    if (!t2.isMeshStandardMaterial || !t2.userData._thinFilmLayer)
      return;
    if (!t2.userData._thinFilmLayer.hasThinFilm)
      return;
    n2.extensions = n2.extensions || {};
    const r2 = le(t2.userData._thinFilmLayer, false);
    n2.extensions[Do.THIN_FILM_LAYER_GLTF_EXTENSION] = r2, e2.extensionsUsed[Do.THIN_FILM_LAYER_GLTF_EXTENSION] = true;
  } });
  class Uo {
    async apply(e2, t2, n2) {
      var r2, i2, s2, o2;
      if (!t2)
        return void (this.selected = void 0);
      let a2 = this.presets.find((e3) => function(e4, t3) {
        return ("string" == typeof e4 ? e4 : e4.path) === ("string" == typeof t3 ? t3 : t3.path);
      }(e3, t2));
      return a2 || (this.presets.push(t2), a2 = t2), this.selected = a2, "string" != typeof a2 ? null === (i2 = null === (r2 = e2.getManager()) || void 0 === r2 ? void 0 : r2.importer) || void 0 === i2 ? void 0 : i2.importAsset(a2, n2) : null === (o2 = null === (s2 = e2.getManager()) || void 0 === s2 ? void 0 : s2.importer) || void 0 === o2 ? void 0 : o2.importPath(a2, n2);
    }
    clear() {
      this.selected = void 0;
    }
    constructor(e2) {
      this.presets = [], this.name = "", this.selected = void 0, e2 && (this.name = e2);
    }
  }
  class Fo extends Uo {
    constructor() {
      super(...arguments), this.name = "Background";
    }
    async apply(e2, t2) {
      const r2 = await super.apply(e2, t2), i2 = null == r2 ? void 0 : r2[0];
      return i2 && (i2.colorSpace = n.KI_, e2.scene.background = i2, e2.scene.backgroundColor = new n.Ilk(1, 1, 1)), i2;
    }
  }
  class No extends Uo {
    constructor() {
      super(...arguments), this.name = "Environment";
    }
    async apply(e2, t2) {
      const n2 = await super.apply(e2, t2), r2 = null == n2 ? void 0 : n2[0];
      return r2 && (e2.scene.environment = r2), r2;
    }
  }
  class jo extends Uo {
    constructor(e2 = "envMap") {
      super(), this.key = e2, this.name = "GemEnvironment", this.name += e2.split("Map")[1];
    }
    async apply(e2, n2) {
      const r2 = await super.apply(e2, n2), i2 = null == r2 ? void 0 : r2[0];
      return (0, t.safeSetProperty)(e2.getPluginByType("Diamond"), this.key, i2), i2;
    }
  }
  class zo extends Uo {
    async apply(e2, t2) {
      var n2, r2;
      const i2 = await super.apply(e2, t2, { processImported: false });
      return i2 ? null === (r2 = null === (n2 = e2.getManager()) || void 0 === n2 ? void 0 : n2.importer) || void 0 === r2 ? void 0 : r2.processImported(i2) : void 0;
    }
  }
  class Go extends zo {
    constructor() {
      super(...arguments), this.name = "MaterialLibraries";
    }
    async apply(e2, t2) {
      const n2 = await super.apply(e2, t2);
      return n2 && await e2.alert("Material Library successfully imported."), n2;
    }
  }
  class Vo extends Uo {
    constructor() {
      super(...arguments), this.name = "VJSON", this.usePresetCamera = false;
    }
    async apply(e2, t2) {
      const n2 = e2.scene.activeCamera.toJSON(), r2 = await super.apply(e2, t2);
      return this.usePresetCamera || e2.scene.activeCamera.fromJSON(n2), r2;
    }
  }
  class Ho extends gt {
    constructor() {
      super(...arguments), this.toJSON = null, this.enabled = true, this.presetGroups = [], this.uiConfig = { type: "folder", label: "Presets", expanded: true, limitedUi: true, children: [() => this.presetGroups.map((e2) => ({ type: "dropdown", label: e2.name, limitedUi: true, children: [{ value: "", label: "none" }, ...e2.presets.map((e3) => {
        var t2;
        return { label: (null === (t2 = Qo(e3)) || void 0 === t2 ? void 0 : t2.split("/").pop()) || "", value: Qo(e3) };
      })], getValue: () => Qo(e2.selected) || "", setValue: (t2) => {
        e2.apply(this._viewer, e2.presets.find((e3) => Qo(e3) === t2));
      } })), { type: "button", label: "Download Selection", limitedUi: true, value: () => {
        const e2 = this.exportPresets();
        (0, t.downloadFile)(new File([JSON.stringify(e2, null, 2)], "preset.template.json", { type: "application/json" }));
      } }, { type: "button", label: "Export Preset Groups", limitedUi: false, value: () => {
        const e2 = this.exportPresetGroups();
        (0, t.downloadFile)(new File([JSON.stringify(e2, null, 2)], "presetGroups.json", { type: "application/json" }));
      } }] };
    }
    async onAdded(e2) {
      var t2, n2;
      await super.onAdded(e2), this.presetGroups.push(new Fo()), this.presetGroups.push(new No()), this.presetGroups.push(new jo()), this.presetGroups.push(new jo("envMap2")), this.presetGroups.push(new jo("envMap3")), this.presetGroups.push(new zo("Ground")), this.presetGroups.push(new zo("CameraViews")), this.presetGroups.push(new zo("MaterialConfiguration")), this.presetGroups.push(new Go()), null === (n2 = (t2 = this.uiConfig).uiRefresh) || void 0 === n2 || n2.call(t2, "postFrame", true);
    }
    exportPresets() {
      const e2 = Object.fromEntries(this.presetGroups.map((e3) => [e3.name, Qo(e3.selected) || void 0]).filter(([, e3]) => e3));
      return e2.type = Ho.PluginType, e2;
    }
    async fromJSON(e2, t2) {
      var n2, r2;
      if (!super.fromJSON(e2, t2))
        return null;
      const i2 = { ...e2 };
      if (delete i2.type, i2.VJSON && this._viewer) {
        const e3 = this.presetGroups.find((e4) => "VJSON" === e4.name), t3 = null == e3 ? void 0 : e3.presets;
        e3 && t3 && await e3.apply(this._viewer, { path: i2.VJSON }), delete i2.VJSON;
      }
      const s2 = [];
      for (const [e3, t3] of Object.entries(i2)) {
        const n3 = this.presetGroups.find((t4) => t4.name === e3), r3 = null == n3 ? void 0 : n3.presets;
        if (!n3 || !r3)
          continue;
        const i3 = "string" == typeof t3 ? { path: t3 } : t3;
        s2.push(n3.apply(this._viewer, i3));
      }
      return await Promise.all(s2), null === (r2 = (n2 = this.uiConfig).uiRefresh) || void 0 === r2 || r2.call(n2, "postFrame", true), this;
    }
    async loadPresetGroups(e2) {
      var t2;
      "string" == typeof e2 && e2.startsWith("http") && (e2 = await fetch(e2).then(async (e3) => e3.json()));
      for (const [n2, r2] of Object.entries(e2)) {
        const e3 = null === (t2 = this.presetGroups.find((e4) => e4.name === n2)) || void 0 === t2 ? void 0 : t2.presets;
        null == e3 || e3.push(...r2);
      }
    }
    exportPresetGroups() {
      return Object.fromEntries(this.presetGroups.map((e2) => [e2.name, e2.presets.map(Qo)]).filter(([, e2]) => e2.length > 0));
    }
    clear() {
      this.presetGroups.forEach((e2) => {
        e2.clear();
      });
    }
  }
  function Qo(e2) {
    return e2 && "string" != typeof e2 ? e2.path : e2;
  }
  Ho.PluginType = "PresetLibraryPlugin";
  var Wo, qo = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let Xo = Wo = class {
    constructor(e2) {
      this.enabled = false, this.grainMultiply = false, this.grainIntensity = 10, this.extraUniforms = { grainIntensity: { value: 1 }, grainMultiply: { value: 1 } }, this.parsFragmentSnippet = (e3, n2) => this.enabled ? t.glsl`
            uniform float grainIntensity;
            uniform bool grainMultiply;
            ${"vec4 grain(in vec4 color){float x=(vUv.x+4.)*(vUv.y+4.)*(10.);vec4 grain=vec4(mod((mod(x,13.)+1.)*(mod(x,123.)+1.),0.01)-0.005)*grainIntensity;vec4 outColor=color;if(grainMultiply){grain=1.-grain;outColor.rgb=color.rgb*vec3(grain);}else{outColor.rgb=color.rgb+vec3(grain);}return outColor;}"}
        ` : "", this._combinedPostPlugin = e2.getPlugin(Qs), this._setDirty = this._setDirty.bind(this);
    }
    shaderExtender(e2, t2, n2) {
      this.enabled && (e2.fragmentShader = ot(e2.fragmentShader, "#glMarker", " \n            gl_FragColor = grain(gl_FragColor);\n            #glMarker\n        "));
    }
    onObjectRender(e2, t2, n2) {
      this.enabled && (this.extraUniforms.grainIntensity.value = this.grainIntensity, this.extraUniforms.grainMultiply.value = this.grainMultiply);
    }
    getUiConfig() {
      return this.uiConfig;
    }
    computeCacheKey(e2) {
      return this.enabled ? "1" : "0";
    }
    isCompatible(e2) {
      return true;
    }
    _setDirty() {
      this._combinedPostPlugin && (this._combinedPostPlugin.pass.dirty = true);
    }
    setDirty() {
      var e2;
      null === (e2 = this.__setDirty) || void 0 === e2 || e2.call(this), this._setDirty();
    }
  };
  qo([(0, t.onChange)(Wo.prototype._setDirty), Oe("Enable"), ie()], Xo.prototype, "enabled", void 0), qo([(0, t.onChange)(Wo.prototype._setDirty), Oe("Multiply"), ie()], Xo.prototype, "grainMultiply", void 0), qo([(0, t.onChange)(Wo.prototype._setDirty), Ue("Intensity", [0, 20], 0.01, { limitedUi: true }), ie()], Xo.prototype, "grainIntensity", void 0), Xo = Wo = qo([We("FilmicGrain")], Xo);
  class Yo extends qs {
    constructor() {
      super();
    }
    generateExtension(e2) {
      return new Xo(e2);
    }
    get intensity() {
      var e2, t2;
      return null !== (t2 = null === (e2 = this._extension) || void 0 === e2 ? void 0 : e2.grainIntensity) && void 0 !== t2 ? t2 : 1;
    }
    set intensity(e2) {
      this._extension && (this._extension.grainIntensity = e2, this._extension.setDirty());
    }
    get multiply() {
      var e2, t2;
      return null !== (t2 = null === (e2 = this._extension) || void 0 === e2 ? void 0 : e2.grainMultiply) && void 0 !== t2 && t2;
    }
    set multiply(e2) {
      this._extension && (this._extension.grainMultiply = e2, this._extension.setDirty());
    }
  }
  Yo.PluginType = "FilmicGrain";
  class Ko extends t.SimpleEventDispatcher {
    get scene() {
      return this._scene;
    }
    set scene(e2) {
      var t2;
      null === (t2 = this._scene) || void 0 === t2 || t2.removeEventListener("activeCameraChange", this._activeCameraChange), this._scene = e2, this._scene.addEventListener("activeCameraChange", this._activeCameraChange);
    }
    constructor(e2, t2, r2, i2) {
      super(), this.hoverEnabled = false, this._mouseDownPos = new n.FM8(), this._scene = e2, this._camera = null != r2 ? r2 : this._scene.activeCamera, this.domElement = t2, this._time = this.time, this._mouseDownTime = 0, this._mouseUpTime = 1, this.selectionCondition = null != i2 ? i2 : (e3) => false !== e3.userData.userSelectable && false !== e3.userData.bboxVisible && null != e3.material && "ShadowMaterial" !== e3.material.type, this.raycaster = new n.iMs(), this.mouse = new n.FM8(), this._selected = [], this._hovering = [], this.cursorStyles = { default: "grab", down: "grabbing" }, this._activeCameraChange = this._activeCameraChange.bind(this), this._scene.addEventListener("activeCameraChange", this._activeCameraChange), this.domElement.style.touchAction = "none", this.domElement.style.cursor = this.cursorStyles.default, this.domElement.addEventListener("pointermove", (e3) => this.onPointerMove(e3)), this.domElement.addEventListener("pointerleave", (e3) => this.onPointerLeave(e3)), this.domElement.addEventListener("pointerout", (e3) => this.onPointerLeave(e3)), this.domElement.addEventListener("pointercancel", (e3) => this.onPointerCancel(e3)), this.domElement.addEventListener("pointerenter", (e3) => this.onPointerEnter(e3)), this.domElement.addEventListener("pointerdown", (e3) => this.onPointerDown(e3)), this.domElement.addEventListener("pointerup", (e3) => this.onPointerUp(e3));
    }
    _activeCameraChange() {
      this.camera = this._scene.activeCamera;
    }
    get camera() {
      return this._camera;
    }
    set camera(e2) {
      this._camera = e2;
    }
    get selectedObject() {
      return this._selected.length > 0 ? this._selected[0] : null;
    }
    set selectedObject(e2) {
      1 === this._selected.length && this._selected[0] === e2 || (this._selected = e2 ? Array.isArray(e2) ? [...e2] : [e2] : [], this.dispatchEvent({ type: "selectedObjectChanged", object: this.selectedObject }));
    }
    get hoverObject() {
      return this._hovering.length > 0 ? this._hovering[0] : null;
    }
    set hoverObject(e2) {
      this._hovering = e2 ? Array.isArray(e2) ? [...e2] : [e2] : [], this.dispatchEvent({ type: "hoverObjectChanged", object: this.hoverObject });
    }
    get time() {
      return this._time = (0, t.now)(), this._time;
    }
    get isMouseDown() {
      return this.mouseDownDeltaTime < 0;
    }
    get mouseDownDeltaTime() {
      return this._mouseUpTime - this._mouseDownTime;
    }
    onPointerMove(e2) {
      var t2, n2;
      false !== e2.isPrimary && (this.updateMouseFromEvent(e2), this.hoverEnabled && (this.hoverObject = null !== (n2 = null === (t2 = this.checkIntersection()) || void 0 === t2 ? void 0 : t2.intersects[0].object) && void 0 !== n2 ? n2 : null));
    }
    onPointerLeave(e2) {
      false !== e2.isPrimary && (this.domElement.style.cursor = this.cursorStyles.default, (this.hoverEnabled || this.hoverObject) && (this.hoverObject = null));
    }
    onPointerEnter(e2) {
    }
    onPointerCancel(e2) {
    }
    updateMouseFromEvent(e2) {
      const t2 = this.domElement.getBoundingClientRect();
      this.mouse.x = (e2.clientX - t2.x) / t2.width * 2 - 1, this.mouse.y = -(e2.clientY - t2.y) / t2.height * 2 + 1;
    }
    onPointerDown(e2) {
      false !== e2.isPrimary && (this.domElement.style.cursor = this.cursorStyles.down, this._mouseDownTime = this.time, this._mouseDownPos.copy(this.mouse));
    }
    onDoubleClick(e2) {
      console.log("double click");
    }
    onPointerUp(e2) {
      if (false === e2.isPrimary)
        return;
      this.domElement.style.cursor = this.cursorStyles.default, this._mouseUpTime = this.time;
      const t2 = this.mouseDownDeltaTime, n2 = this._mouseDownPos.distanceTo(this.mouse);
      t2 < Ko.PointerClickMaxTime && n2 < Ko.PointerClickMaxDistance && this.onPointerClick(e2);
    }
    onPointerClick(e2) {
      if (false === e2.isPrimary)
        return;
      this.updateMouseFromEvent(e2);
      const t2 = this.checkIntersection();
      t2 && this.dispatchEvent({ type: "hitObject", time: this._mouseUpTime, intersects: t2 }), this.selectedObject = (null == t2 ? void 0 : t2.selectedObject) || null;
    }
    addPasses() {
    }
    checkIntersection() {
      var e2;
      const t2 = null === (e2 = this._camera) || void 0 === e2 ? void 0 : e2.cameraObject;
      if (!t2)
        return null;
      this.raycaster.setFromCamera(this.mouse, t2);
      let n2 = this.raycaster.intersectObject(this._scene.modelRoot.modelObject, true);
      const r2 = [], i2 = n2.filter((e3) => !r2.includes(e3.object.id) && (r2.push(e3.object.id), true));
      n2 = i2;
      let s2, o2 = null;
      const a2 = [];
      for (const e3 of n2) {
        for (o2 = e3.object, s2 = e3; !(null == o2 || o2.visible && this.selectionCondition(o2)); )
          o2 = o2.parent;
        null != o2 && a2.push(e3);
      }
      if (n2 = a2, n2.length > 0) {
        if (o2 = n2[0].object, s2 = n2[0], this._firstHit && o2.id !== this._firstHit.id)
          o2 = s2.object;
        else
          for (let e3 = 0; e3 < n2.length; e3++)
            if (this.selectedObject && this.selectedObject.id === n2[e3].object.id) {
              const t3 = e3 + 1;
              if (!(t3 < n2.length))
                return null;
              s2 = n2[t3], o2 = s2.object;
            }
        this._firstHit = n2[0].object;
      }
      return o2 && s2 && o2 ? { selectedObject: o2, intersect: s2, intersects: n2, mouse: this.mouse.toArray() } : null;
    }
    isHovering() {
      return null != this.hoverObject;
    }
    isSelected() {
      return null != this.selectedObject;
    }
  }
  Ko.PointerClickMaxTime = 200, Ko.PointerClickMaxDistance = 0.1;
  const Jo = new n.ZzF(), Zo = new n.Pa4();
  class $o extends n.L5s {
    constructor() {
      super(), this.isLineSegmentsGeometry = true, this.type = "LineSegmentsGeometry", this.setIndex([0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5]), this.setAttribute("position", new n.a$l([-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], 3)), this.setAttribute("uv", new n.a$l([-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], 2));
    }
    applyMatrix4(e2) {
      const t2 = this.attributes.instanceStart, n2 = this.attributes.instanceEnd;
      return void 0 !== t2 && (t2.applyMatrix4(e2), n2.applyMatrix4(e2), t2.needsUpdate = true), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this;
    }
    setPositions(e2) {
      let t2;
      e2 instanceof Float32Array ? t2 = e2 : Array.isArray(e2) && (t2 = new Float32Array(e2));
      const r2 = new n.$TI(t2, 6, 1);
      return this.setAttribute("instanceStart", new n.kB5(r2, 3, 0)), this.setAttribute("instanceEnd", new n.kB5(r2, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;
    }
    setColors(e2) {
      let t2;
      e2 instanceof Float32Array ? t2 = e2 : Array.isArray(e2) && (t2 = new Float32Array(e2));
      const r2 = new n.$TI(t2, 6, 1);
      return this.setAttribute("instanceColorStart", new n.kB5(r2, 3, 0)), this.setAttribute("instanceColorEnd", new n.kB5(r2, 3, 3)), this;
    }
    fromWireframeGeometry(e2) {
      return this.setPositions(e2.attributes.position.array), this;
    }
    fromEdgesGeometry(e2) {
      return this.setPositions(e2.attributes.position.array), this;
    }
    fromMesh(e2) {
      return this.fromWireframeGeometry(new n.Uk6(e2.geometry)), this;
    }
    fromLineSegments(e2) {
      const t2 = e2.geometry;
      return this.setPositions(t2.attributes.position.array), this;
    }
    computeBoundingBox() {
      null === this.boundingBox && (this.boundingBox = new n.ZzF());
      const e2 = this.attributes.instanceStart, t2 = this.attributes.instanceEnd;
      void 0 !== e2 && void 0 !== t2 && (this.boundingBox.setFromBufferAttribute(e2), Jo.setFromBufferAttribute(t2), this.boundingBox.union(Jo));
    }
    computeBoundingSphere() {
      null === this.boundingSphere && (this.boundingSphere = new n.aLr()), null === this.boundingBox && this.computeBoundingBox();
      const e2 = this.attributes.instanceStart, t2 = this.attributes.instanceEnd;
      if (void 0 !== e2 && void 0 !== t2) {
        const n2 = this.boundingSphere.center;
        this.boundingBox.getCenter(n2);
        let r2 = 0;
        for (let i2 = 0, s2 = e2.count; i2 < s2; i2++)
          Zo.fromBufferAttribute(e2, i2), r2 = Math.max(r2, n2.distanceToSquared(Zo)), Zo.fromBufferAttribute(t2, i2), r2 = Math.max(r2, n2.distanceToSquared(Zo));
        this.boundingSphere.radius = Math.sqrt(r2), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
      }
    }
    toJSON() {
    }
    applyMatrix(e2) {
      return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e2);
    }
  }
  class ea extends $o {
    constructor(e2) {
      super(), this.isWireframeGeometry2 = true, this.type = "WireframeGeometry2", this.fromWireframeGeometry(new n.Uk6(e2));
    }
  }
  n.rBU.line = { worldUnits: { value: 1 }, linewidth: { value: 1 }, resolution: { value: new n.FM8(1, 1) }, dashOffset: { value: 0 }, dashScale: { value: 1 }, dashSize: { value: 1 }, gapSize: { value: 1 } }, n.Vj0.line = { uniforms: n.rDY.merge([n.rBU.common, n.rBU.fog, n.rBU.line]), vertexShader: "\n		#include <common>\n		#include <color_pars_vertex>\n		#include <fog_pars_vertex>\n		#include <logdepthbuf_pars_vertex>\n		#include <clipping_planes_pars_vertex>\n\n		uniform float linewidth;\n		uniform vec2 resolution;\n\n		attribute vec3 instanceStart;\n		attribute vec3 instanceEnd;\n\n		attribute vec3 instanceColorStart;\n		attribute vec3 instanceColorEnd;\n\n		#ifdef WORLD_UNITS\n\n			varying vec4 worldPos;\n			varying vec3 worldStart;\n			varying vec3 worldEnd;\n\n			#ifdef USE_DASH\n\n				varying vec2 vUv;\n\n			#endif\n\n		#else\n\n			varying vec2 vUv;\n\n		#endif\n\n		#ifdef USE_DASH\n\n			uniform float dashScale;\n			attribute float instanceDistanceStart;\n			attribute float instanceDistanceEnd;\n			varying float vLineDistance;\n\n		#endif\n\n		void trimSegment( const in vec4 start, inout vec4 end ) {\n\n			// trim end segment so it terminates between the camera plane and the near plane\n\n			// conservative estimate of the near plane\n			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n			float nearEstimate = - 0.5 * b / a;\n\n			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n			end.xyz = mix( start.xyz, end.xyz, alpha );\n\n		}\n\n		void main() {\n\n			#ifdef USE_COLOR\n\n				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n			#endif\n\n			#ifdef USE_DASH\n\n				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n				vUv = uv;\n\n			#endif\n\n			float aspect = resolution.x / resolution.y;\n\n			// camera space\n			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n			#ifdef WORLD_UNITS\n\n				worldStart = start.xyz;\n				worldEnd = end.xyz;\n\n			#else\n\n				vUv = uv;\n\n			#endif\n\n			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n			// perhaps there is a more elegant solution -- WestLangley\n\n			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n			if ( perspective ) {\n\n				if ( start.z < 0.0 && end.z >= 0.0 ) {\n\n					trimSegment( start, end );\n\n				} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n					trimSegment( end, start );\n\n				}\n\n			}\n\n			// clip space\n			vec4 clipStart = projectionMatrix * start;\n			vec4 clipEnd = projectionMatrix * end;\n\n			// ndc space\n			vec3 ndcStart = clipStart.xyz / clipStart.w;\n			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n			// direction\n			vec2 dir = ndcEnd.xy - ndcStart.xy;\n\n			// account for clip-space aspect ratio\n			dir.x *= aspect;\n			dir = normalize( dir );\n\n			#ifdef WORLD_UNITS\n\n				// get the offset direction as perpendicular to the view vector\n				vec3 worldDir = normalize( end.xyz - start.xyz );\n				vec3 offset;\n				if ( position.y < 0.5 ) {\n\n					offset = normalize( cross( start.xyz, worldDir ) );\n\n				} else {\n\n					offset = normalize( cross( end.xyz, worldDir ) );\n\n				}\n\n				// sign flip\n				if ( position.x < 0.0 ) offset *= - 1.0;\n\n				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n				// don't extend the line if we're rendering dashes because we\n				// won't be rendering the endcaps\n				#ifndef USE_DASH\n\n					// extend the line bounds to encompass  endcaps\n					start.xyz += - worldDir * linewidth * 0.5;\n					end.xyz += worldDir * linewidth * 0.5;\n\n					// shift the position of the quad so it hugs the forward edge of the line\n					offset.xy -= dir * forwardOffset;\n					offset.z += 0.5;\n\n				#endif\n\n				// endcaps\n				if ( position.y > 1.0 || position.y < 0.0 ) {\n\n					offset.xy += dir * 2.0 * forwardOffset;\n\n				}\n\n				// adjust for linewidth\n				offset *= linewidth * 0.5;\n\n				// set the world position\n				worldPos = ( position.y < 0.5 ) ? start : end;\n				worldPos.xyz += offset;\n\n				// project the worldpos\n				vec4 clip = projectionMatrix * worldPos;\n\n				// shift the depth of the projected points so the line\n				// segments overlap neatly\n				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n				clip.z = clipPose.z * clip.w;\n\n			#else\n\n				vec2 offset = vec2( dir.y, - dir.x );\n				// undo aspect ratio adjustment\n				dir.x /= aspect;\n				offset.x /= aspect;\n\n				// sign flip\n				if ( position.x < 0.0 ) offset *= - 1.0;\n\n				// endcaps\n				if ( position.y < 0.0 ) {\n\n					offset += - dir;\n\n				} else if ( position.y > 1.0 ) {\n\n					offset += dir;\n\n				}\n\n				// adjust for linewidth\n				offset *= linewidth;\n\n				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n				offset /= resolution.y;\n\n				// select end\n				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n				// back to clip space\n				offset *= clip.w;\n\n				clip.xy += offset;\n\n			#endif\n\n			gl_Position = clip;\n\n			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n			#include <logdepthbuf_vertex>\n			#include <clipping_planes_vertex>\n			#include <fog_vertex>\n\n		}\n		", fragmentShader: "\n		uniform vec3 diffuse;\n		uniform float opacity;\n		uniform float linewidth;\n\n		#ifdef USE_DASH\n\n			uniform float dashOffset;\n			uniform float dashSize;\n			uniform float gapSize;\n\n		#endif\n\n		varying float vLineDistance;\n\n		#ifdef WORLD_UNITS\n\n			varying vec4 worldPos;\n			varying vec3 worldStart;\n			varying vec3 worldEnd;\n\n			#ifdef USE_DASH\n\n				varying vec2 vUv;\n\n			#endif\n\n		#else\n\n			varying vec2 vUv;\n\n		#endif\n\n		#include <common>\n		#include <color_pars_fragment>\n		#include <fog_pars_fragment>\n		#include <logdepthbuf_pars_fragment>\n		#include <clipping_planes_pars_fragment>\n\n		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n			float mua;\n			float mub;\n\n			vec3 p13 = p1 - p3;\n			vec3 p43 = p4 - p3;\n\n			vec3 p21 = p2 - p1;\n\n			float d1343 = dot( p13, p43 );\n			float d4321 = dot( p43, p21 );\n			float d1321 = dot( p13, p21 );\n			float d4343 = dot( p43, p43 );\n			float d2121 = dot( p21, p21 );\n\n			float denom = d2121 * d4343 - d4321 * d4321;\n\n			float numer = d1343 * d4321 - d1321 * d4343;\n\n			mua = numer / denom;\n			mua = clamp( mua, 0.0, 1.0 );\n			mub = ( d1343 + d4321 * ( mua ) ) / d4343;\n			mub = clamp( mub, 0.0, 1.0 );\n\n			return vec2( mua, mub );\n\n		}\n\n		void main() {\n\n			#include <clipping_planes_fragment>\n\n			#ifdef USE_DASH\n\n				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n			#endif\n\n			float alpha = opacity;\n\n			#ifdef WORLD_UNITS\n\n				// Find the closest points on the view ray and the line segment\n				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n				vec3 lineDir = worldEnd - worldStart;\n				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n				vec3 p1 = worldStart + lineDir * params.x;\n				vec3 p2 = rayEnd * params.y;\n				vec3 delta = p1 - p2;\n				float len = length( delta );\n				float norm = len / linewidth;\n\n				#ifndef USE_DASH\n\n					#ifdef USE_ALPHA_TO_COVERAGE\n\n						float dnorm = fwidth( norm );\n						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n					#else\n\n						if ( norm > 0.5 ) {\n\n							discard;\n\n						}\n\n					#endif\n\n				#endif\n\n			#else\n\n				#ifdef USE_ALPHA_TO_COVERAGE\n\n					// artifacts appear on some hardware if a derivative is taken within a conditional\n					float a = vUv.x;\n					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n					float len2 = a * a + b * b;\n					float dlen = fwidth( len2 );\n\n					if ( abs( vUv.y ) > 1.0 ) {\n\n						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n					}\n\n				#else\n\n					if ( abs( vUv.y ) > 1.0 ) {\n\n						float a = vUv.x;\n						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n						float len2 = a * a + b * b;\n\n						if ( len2 > 1.0 ) discard;\n\n					}\n\n				#endif\n\n			#endif\n\n			vec4 diffuseColor = vec4( diffuse, alpha );\n\n			#include <logdepthbuf_fragment>\n			#include <color_fragment>\n\n			gl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n			#include <tonemapping_fragment>\n			#include <encodings_fragment>\n			#include <fog_fragment>\n			#include <premultiplied_alpha_fragment>\n\n		}\n		" };
  class ta extends n.jyz {
    constructor(e2) {
      super({ type: "LineMaterial", uniforms: n.rDY.clone(n.Vj0.line.uniforms), vertexShader: n.Vj0.line.vertexShader, fragmentShader: n.Vj0.line.fragmentShader, clipping: true }), this.isLineMaterial = true, Object.defineProperties(this, { color: { enumerable: true, get: function() {
        return this.uniforms.diffuse.value;
      }, set: function(e3) {
        this.uniforms.diffuse.value = e3;
      } }, worldUnits: { enumerable: true, get: function() {
        return "WORLD_UNITS" in this.defines;
      }, set: function(e3) {
        true === e3 ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
      } }, linewidth: { enumerable: true, get: function() {
        return this.uniforms.linewidth.value;
      }, set: function(e3) {
        this.uniforms.linewidth.value = e3;
      } }, dashed: { enumerable: true, get: function() {
        return Boolean("USE_DASH" in this.defines);
      }, set(e3) {
        Boolean(e3) !== Boolean("USE_DASH" in this.defines) && (this.needsUpdate = true), true === e3 ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
      } }, dashScale: { enumerable: true, get: function() {
        return this.uniforms.dashScale.value;
      }, set: function(e3) {
        this.uniforms.dashScale.value = e3;
      } }, dashSize: { enumerable: true, get: function() {
        return this.uniforms.dashSize.value;
      }, set: function(e3) {
        this.uniforms.dashSize.value = e3;
      } }, dashOffset: { enumerable: true, get: function() {
        return this.uniforms.dashOffset.value;
      }, set: function(e3) {
        this.uniforms.dashOffset.value = e3;
      } }, gapSize: { enumerable: true, get: function() {
        return this.uniforms.gapSize.value;
      }, set: function(e3) {
        this.uniforms.gapSize.value = e3;
      } }, opacity: { enumerable: true, get: function() {
        return this.uniforms.opacity.value;
      }, set: function(e3) {
        this.uniforms.opacity.value = e3;
      } }, resolution: { enumerable: true, get: function() {
        return this.uniforms.resolution.value;
      }, set: function(e3) {
        this.uniforms.resolution.value.copy(e3);
      } }, alphaToCoverage: { enumerable: true, get: function() {
        return Boolean("USE_ALPHA_TO_COVERAGE" in this.defines);
      }, set: function(e3) {
        Boolean(e3) !== Boolean("USE_ALPHA_TO_COVERAGE" in this.defines) && (this.needsUpdate = true), true === e3 ? (this.defines.USE_ALPHA_TO_COVERAGE = "", this.extensions.derivatives = true) : (delete this.defines.USE_ALPHA_TO_COVERAGE, this.extensions.derivatives = false);
      } } }), this.setValues(e2);
    }
  }
  const na = new n.Pa4(), ra = new n.Pa4();
  class ia extends n.Kj0 {
    constructor(e2 = new $o(), t2 = new ta({ color: 16777215 * Math.random() })) {
      super(e2, t2), this.isWireframe = true, this.type = "Wireframe";
    }
    computeLineDistances() {
      const e2 = this.geometry, t2 = e2.attributes.instanceStart, r2 = e2.attributes.instanceEnd, i2 = new Float32Array(2 * t2.count);
      for (let e3 = 0, n2 = 0, s3 = t2.count; e3 < s3; e3++, n2 += 2)
        na.fromBufferAttribute(t2, e3), ra.fromBufferAttribute(r2, e3), i2[n2] = 0 === n2 ? 0 : i2[n2 - 1], i2[n2 + 1] = i2[n2] + na.distanceTo(ra);
      const s2 = new n.$TI(i2, 2, 1);
      return e2.setAttribute("instanceDistanceStart", new n.kB5(s2, 1, 0)), e2.setAttribute("instanceDistanceEnd", new n.kB5(s2, 1, 1)), this;
    }
  }
  class sa extends n.ZAu {
    _updater() {
      const e2 = this._object;
      if (e2) {
        const t2 = new h().expandByObject(e2, false);
        t2.getCenter(this.position);
        const r2 = t2.getBoundingSphere(new n.aLr()).radius;
        this.scale.setScalar(r2 * this.boundingScaleMultiplier), this.setVisible(true);
      } else
        this.setVisible(false);
    }
    constructor() {
      super(), this.assetType = "widget", this.modelObject = this, this._object = null, this.boundingScaleMultiplier = 1, this.position.set(0, 0, 0), this.visible = false, this.renderOrder = 1, this.userData.bboxVisible = false, this._updater = this._updater.bind(this);
    }
    _initGeometry(e2) {
      if (this._geometry)
        return;
      const t2 = new ea(e2);
      this._geometry = t2;
      const r2 = new ta({ color: "#ff2222", transparent: true, opacity: 0.9, linewidth: 5, resolution: new n.FM8(1024, 1024), dashed: false, toneMapped: false }), i2 = new ia(t2, r2);
      i2.computeLineDistances(), i2.scale.set(1, 1, 1), i2.visible = true, this.add(i2);
    }
    setVisible(e2) {
      var t2;
      e2 !== this.visible && (this.visible = e2, null === (t2 = this.setDirty) || void 0 === t2 || t2.call(this, { sceneUpdate: false }));
    }
    attach(e2) {
      return this.detach(), e2 ? (this._object = e2, this._object.addEventListener("objectUpdate", this._updater), this._updater(), this) : this;
    }
    detach() {
      var e2;
      return this._object ? (null === (e2 = this._object) || void 0 === e2 || e2.removeEventListener("objectUpdate", this._updater), this._object = null, this._updater(), this) : this;
    }
    get object() {
      return this._object;
    }
  }
  class oa extends sa {
    constructor() {
      super(), this.boundingScaleMultiplier = 1 / 1.7, this._initGeometry(new n.DvJ(2, 2, 2, 1, 1, 1));
    }
    _updater() {
      super._updater();
      const e2 = this.object;
      e2 && (new h().expandByObject(e2, false).getSize(this.scale).multiplyScalar(this.boundingScaleMultiplier).clampScalar(0.1, 100), this.setVisible(true));
    }
  }
  const aa = new n.iMs(), la = new n.Pa4(), ca = new n.Pa4(), ua = new n._fP(), pa = { X: new n.Pa4(1, 0, 0), Y: new n.Pa4(0, 1, 0), Z: new n.Pa4(0, 0, 1) }, da = { type: "change" }, ha = { type: "mouseDown" }, fa = { type: "mouseUp", mode: null }, ma = { type: "objectChange" };
  class _a2 extends n.Tme {
    constructor(e2, t2) {
      super(), void 0 === t2 && (console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'), t2 = document), this.isTransformControls = true, this.visible = false, this.domElement = t2, this.domElement.style.touchAction = "none";
      const r2 = new Ua();
      this._gizmo = r2, this.add(r2);
      const i2 = new Fa();
      this._plane = i2, this.add(i2);
      const s2 = this;
      function o2(e3, t3) {
        let n2 = t3;
        Object.defineProperty(s2, e3, { get: function() {
          return void 0 !== n2 ? n2 : t3;
        }, set: function(t4) {
          n2 !== t4 && (n2 = t4, i2[e3] = t4, r2[e3] = t4, s2.dispatchEvent({ type: e3 + "-changed", value: t4 }), s2.dispatchEvent(da));
        } }), s2[e3] = t3, i2[e3] = t3, r2[e3] = t3;
      }
      o2("camera", e2), o2("object", void 0), o2("enabled", true), o2("axis", null), o2("mode", "translate"), o2("translationSnap", null), o2("rotationSnap", null), o2("scaleSnap", null), o2("space", "world"), o2("size", 1), o2("dragging", false), o2("showX", true), o2("showY", true), o2("showZ", true);
      const a2 = new n.Pa4(), l2 = new n.Pa4(), c2 = new n._fP(), u2 = new n._fP(), p2 = new n.Pa4(), d2 = new n._fP(), h2 = new n.Pa4(), f2 = new n.Pa4(), m2 = new n.Pa4(), _2 = new n.Pa4();
      o2("worldPosition", a2), o2("worldPositionStart", l2), o2("worldQuaternion", c2), o2("worldQuaternionStart", u2), o2("cameraPosition", p2), o2("cameraQuaternion", d2), o2("pointStart", h2), o2("pointEnd", f2), o2("rotationAxis", m2), o2("rotationAngle", 0), o2("eye", _2), this._offset = new n.Pa4(), this._startNorm = new n.Pa4(), this._endNorm = new n.Pa4(), this._cameraScale = new n.Pa4(), this._parentPosition = new n.Pa4(), this._parentQuaternion = new n._fP(), this._parentQuaternionInv = new n._fP(), this._parentScale = new n.Pa4(), this._worldScaleStart = new n.Pa4(), this._worldQuaternionInv = new n._fP(), this._worldScale = new n.Pa4(), this._positionStart = new n.Pa4(), this._quaternionStart = new n._fP(), this._scaleStart = new n.Pa4(), this._getPointer = ga.bind(this), this._onPointerDown = ya.bind(this), this._onPointerHover = va.bind(this), this._onPointerMove = ba.bind(this), this._onPointerUp = wa.bind(this), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp);
    }
    updateMatrixWorld() {
      void 0 !== this.object && (this.object.updateMatrixWorld(), null === this.object.parent ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale), this._parentQuaternionInv.copy(this._parentQuaternion).invert(), this._worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale), this.camera.isOrthographicCamera ? this.camera.getWorldDirection(this.eye).negate() : this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld(this);
    }
    pointerHover(e2) {
      if (void 0 === this.object || true === this.dragging)
        return;
      aa.setFromCamera(e2, this.camera);
      const t2 = Aa(this._gizmo.picker[this.mode], aa);
      this.axis = t2 ? t2.object.name : null;
    }
    pointerDown(e2) {
      if (void 0 !== this.object && true !== this.dragging && 0 === e2.button && null !== this.axis) {
        aa.setFromCamera(e2, this.camera);
        const t2 = Aa(this._plane, aa, true);
        t2 && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(t2.point).sub(this.worldPositionStart)), this.dragging = true, ha.mode = this.mode, this.dispatchEvent(ha);
      }
    }
    pointerMove(e2) {
      const t2 = this.axis, n2 = this.mode, r2 = this.object;
      let i2 = this.space;
      if ("scale" === n2 ? i2 = "local" : "E" !== t2 && "XYZE" !== t2 && "XYZ" !== t2 || (i2 = "world"), void 0 === r2 || null === t2 || false === this.dragging || -1 !== e2.button)
        return;
      aa.setFromCamera(e2, this.camera);
      const s2 = Aa(this._plane, aa, true);
      if (s2) {
        if (this.pointEnd.copy(s2.point).sub(this.worldPositionStart), "translate" === n2)
          this._offset.copy(this.pointEnd).sub(this.pointStart), "local" === i2 && "XYZ" !== t2 && this._offset.applyQuaternion(this._worldQuaternionInv), -1 === t2.indexOf("X") && (this._offset.x = 0), -1 === t2.indexOf("Y") && (this._offset.y = 0), -1 === t2.indexOf("Z") && (this._offset.z = 0), "local" === i2 && "XYZ" !== t2 ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), r2.position.copy(this._offset).add(this._positionStart), this.translationSnap && ("local" === i2 && (r2.position.applyQuaternion(ua.copy(this._quaternionStart).invert()), -1 !== t2.search("X") && (r2.position.x = Math.round(r2.position.x / this.translationSnap) * this.translationSnap), -1 !== t2.search("Y") && (r2.position.y = Math.round(r2.position.y / this.translationSnap) * this.translationSnap), -1 !== t2.search("Z") && (r2.position.z = Math.round(r2.position.z / this.translationSnap) * this.translationSnap), r2.position.applyQuaternion(this._quaternionStart)), "world" === i2 && (r2.parent && r2.position.add(la.setFromMatrixPosition(r2.parent.matrixWorld)), -1 !== t2.search("X") && (r2.position.x = Math.round(r2.position.x / this.translationSnap) * this.translationSnap), -1 !== t2.search("Y") && (r2.position.y = Math.round(r2.position.y / this.translationSnap) * this.translationSnap), -1 !== t2.search("Z") && (r2.position.z = Math.round(r2.position.z / this.translationSnap) * this.translationSnap), r2.parent && r2.position.sub(la.setFromMatrixPosition(r2.parent.matrixWorld))));
        else if ("scale" === n2) {
          if (-1 !== t2.search("XYZ")) {
            let e3 = this.pointEnd.length() / this.pointStart.length();
            this.pointEnd.dot(this.pointStart) < 0 && (e3 *= -1), ca.set(e3, e3, e3);
          } else
            la.copy(this.pointStart), ca.copy(this.pointEnd), la.applyQuaternion(this._worldQuaternionInv), ca.applyQuaternion(this._worldQuaternionInv), ca.divide(la), -1 === t2.search("X") && (ca.x = 1), -1 === t2.search("Y") && (ca.y = 1), -1 === t2.search("Z") && (ca.z = 1);
          r2.scale.copy(this._scaleStart).multiply(ca), this.scaleSnap && (-1 !== t2.search("X") && (r2.scale.x = Math.round(r2.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), -1 !== t2.search("Y") && (r2.scale.y = Math.round(r2.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), -1 !== t2.search("Z") && (r2.scale.z = Math.round(r2.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
        } else if ("rotate" === n2) {
          this._offset.copy(this.pointEnd).sub(this.pointStart);
          const e3 = 20 / this.worldPosition.distanceTo(la.setFromMatrixPosition(this.camera.matrixWorld));
          "E" === t2 ? (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1) : "XYZE" === t2 ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(la.copy(this.rotationAxis).cross(this.eye)) * e3) : "X" !== t2 && "Y" !== t2 && "Z" !== t2 || (this.rotationAxis.copy(pa[t2]), la.copy(pa[t2]), "local" === i2 && la.applyQuaternion(this.worldQuaternion), this.rotationAngle = this._offset.dot(la.cross(this.eye).normalize()) * e3), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), "local" === i2 && "E" !== t2 && "XYZE" !== t2 ? (r2.quaternion.copy(this._quaternionStart), r2.quaternion.multiply(ua.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), r2.quaternion.copy(ua.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), r2.quaternion.multiply(this._quaternionStart).normalize());
        }
        this.dispatchEvent(da), this.dispatchEvent(ma);
      }
    }
    pointerUp(e2) {
      0 === e2.button && (this.dragging && null !== this.axis && (fa.mode = this.mode, this.dispatchEvent(fa)), this.dragging = false, this.axis = null);
    }
    dispose() {
      this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.traverse(function(e2) {
        e2.geometry && e2.geometry.dispose(), e2.material && e2.material.dispose();
      });
    }
    attach(e2) {
      return this.object = e2, this.visible = true, this;
    }
    detach() {
      return this.object = void 0, this.visible = false, this.axis = null, this;
    }
    reset() {
      this.enabled && this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(da), this.dispatchEvent(ma), this.pointStart.copy(this.pointEnd));
    }
    getRaycaster() {
      return aa;
    }
    getMode() {
      return this.mode;
    }
    setMode(e2) {
      this.mode = e2;
    }
    setTranslationSnap(e2) {
      this.translationSnap = e2;
    }
    setRotationSnap(e2) {
      this.rotationSnap = e2;
    }
    setScaleSnap(e2) {
      this.scaleSnap = e2;
    }
    setSize(e2) {
      this.size = e2;
    }
    setSpace(e2) {
      this.space = e2;
    }
  }
  function ga(e2) {
    if (this.domElement.ownerDocument.pointerLockElement)
      return { x: 0, y: 0, button: e2.button };
    {
      const t2 = this.domElement.getBoundingClientRect();
      return { x: (e2.clientX - t2.left) / t2.width * 2 - 1, y: -(e2.clientY - t2.top) / t2.height * 2 + 1, button: e2.button };
    }
  }
  function va(e2) {
    if (this.enabled)
      switch (e2.pointerType) {
        case "mouse":
        case "pen":
          this.pointerHover(this._getPointer(e2));
      }
  }
  function ya(e2) {
    this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(e2.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(e2)), this.pointerDown(this._getPointer(e2)));
  }
  function ba(e2) {
    this.enabled && this.pointerMove(this._getPointer(e2));
  }
  function wa(e2) {
    this.enabled && (this.domElement.releasePointerCapture(e2.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(e2)));
  }
  function Aa(e2, t2, n2) {
    const r2 = t2.intersectObject(e2, true);
    for (let e3 = 0; e3 < r2.length; e3++)
      if (r2[e3].object.visible || n2)
        return r2[e3];
    return false;
  }
  const xa = new n.USm(), Ea = new n.Pa4(0, 1, 0), Ca = new n.Pa4(0, 0, 0), Sa = new n.yGw(), Ma = new n._fP(), Ta = new n._fP(), Pa = new n.Pa4(), Ia = new n.yGw(), Ra = new n.Pa4(1, 0, 0), ka = new n.Pa4(0, 1, 0), Da = new n.Pa4(0, 0, 1), Ba = new n.Pa4(), Oa = new n.Pa4(), La = new n.Pa4();
  class Ua extends n.Tme {
    constructor() {
      super(), this.isTransformControlsGizmo = true, this.type = "TransformControlsGizmo";
      const e2 = new n.vBJ({ depthTest: false, depthWrite: false, fog: false, toneMapped: false, transparent: true }), t2 = new n.nls({ depthTest: false, depthWrite: false, fog: false, toneMapped: false, transparent: true }), r2 = e2.clone();
      r2.opacity = 0.15;
      const i2 = t2.clone();
      i2.opacity = 0.5;
      const s2 = e2.clone();
      s2.color.setHex(16711680);
      const o2 = e2.clone();
      o2.color.setHex(65280);
      const a2 = e2.clone();
      a2.color.setHex(255);
      const l2 = e2.clone();
      l2.color.setHex(16711680), l2.opacity = 0.5;
      const c2 = e2.clone();
      c2.color.setHex(65280), c2.opacity = 0.5;
      const u2 = e2.clone();
      u2.color.setHex(255), u2.opacity = 0.5;
      const p2 = e2.clone();
      p2.opacity = 0.25;
      const d2 = e2.clone();
      d2.color.setHex(16776960), d2.opacity = 0.25, e2.clone().color.setHex(16776960);
      const h2 = e2.clone();
      h2.color.setHex(7895160);
      const f2 = new n.fHI(0, 0.04, 0.1, 12);
      f2.translate(0, 0.05, 0);
      const m2 = new n.DvJ(0.08, 0.08, 0.08);
      m2.translate(0, 0.04, 0);
      const _2 = new n.u9r();
      _2.setAttribute("position", new n.a$l([0, 0, 0, 1, 0, 0], 3));
      const g2 = new n.fHI(75e-4, 75e-4, 0.5, 3);
      function v2(e3, t3) {
        const r3 = new n.XvJ(e3, 75e-4, 3, 64, t3 * Math.PI * 2);
        return r3.rotateY(Math.PI / 2), r3.rotateX(Math.PI / 2), r3;
      }
      g2.translate(0, 0.25, 0);
      const y2 = { X: [[new n.Kj0(f2, s2), [0.5, 0, 0], [0, 0, -Math.PI / 2]], [new n.Kj0(f2, s2), [-0.5, 0, 0], [0, 0, Math.PI / 2]], [new n.Kj0(g2, s2), [0, 0, 0], [0, 0, -Math.PI / 2]]], Y: [[new n.Kj0(f2, o2), [0, 0.5, 0]], [new n.Kj0(f2, o2), [0, -0.5, 0], [Math.PI, 0, 0]], [new n.Kj0(g2, o2)]], Z: [[new n.Kj0(f2, a2), [0, 0, 0.5], [Math.PI / 2, 0, 0]], [new n.Kj0(f2, a2), [0, 0, -0.5], [-Math.PI / 2, 0, 0]], [new n.Kj0(g2, a2), null, [Math.PI / 2, 0, 0]]], XYZ: [[new n.Kj0(new n.pQR(0.1, 0), p2.clone()), [0, 0, 0]]], XY: [[new n.Kj0(new n.DvJ(0.15, 0.15, 0.01), u2.clone()), [0.15, 0.15, 0]]], YZ: [[new n.Kj0(new n.DvJ(0.15, 0.15, 0.01), l2.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]], XZ: [[new n.Kj0(new n.DvJ(0.15, 0.15, 0.01), c2.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]] }, b2 = { X: [[new n.Kj0(new n.fHI(0.2, 0, 0.6, 4), r2), [0.3, 0, 0], [0, 0, -Math.PI / 2]], [new n.Kj0(new n.fHI(0.2, 0, 0.6, 4), r2), [-0.3, 0, 0], [0, 0, Math.PI / 2]]], Y: [[new n.Kj0(new n.fHI(0.2, 0, 0.6, 4), r2), [0, 0.3, 0]], [new n.Kj0(new n.fHI(0.2, 0, 0.6, 4), r2), [0, -0.3, 0], [0, 0, Math.PI]]], Z: [[new n.Kj0(new n.fHI(0.2, 0, 0.6, 4), r2), [0, 0, 0.3], [Math.PI / 2, 0, 0]], [new n.Kj0(new n.fHI(0.2, 0, 0.6, 4), r2), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]], XYZ: [[new n.Kj0(new n.pQR(0.2, 0), r2)]], XY: [[new n.Kj0(new n.DvJ(0.2, 0.2, 0.01), r2), [0.15, 0.15, 0]]], YZ: [[new n.Kj0(new n.DvJ(0.2, 0.2, 0.01), r2), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]], XZ: [[new n.Kj0(new n.DvJ(0.2, 0.2, 0.01), r2), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]] }, w2 = { START: [[new n.Kj0(new n.pQR(0.01, 2), i2), null, null, null, "helper"]], END: [[new n.Kj0(new n.pQR(0.01, 2), i2), null, null, null, "helper"]], DELTA: [[new n.x12(function() {
        const e3 = new n.u9r();
        return e3.setAttribute("position", new n.a$l([0, 0, 0, 1, 1, 1], 3)), e3;
      }(), i2), null, null, null, "helper"]], X: [[new n.x12(_2, i2.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]], Y: [[new n.x12(_2, i2.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]], Z: [[new n.x12(_2, i2.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]] }, A2 = { XYZE: [[new n.Kj0(v2(0.5, 1), h2), null, [0, Math.PI / 2, 0]]], X: [[new n.Kj0(v2(0.5, 0.5), s2)]], Y: [[new n.Kj0(v2(0.5, 0.5), o2), null, [0, 0, -Math.PI / 2]]], Z: [[new n.Kj0(v2(0.5, 0.5), a2), null, [0, Math.PI / 2, 0]]], E: [[new n.Kj0(v2(0.75, 1), d2), null, [0, Math.PI / 2, 0]]] }, x2 = { AXIS: [[new n.x12(_2, i2.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]] }, E2 = { XYZE: [[new n.Kj0(new n.xo$(0.25, 10, 8), r2)]], X: [[new n.Kj0(new n.XvJ(0.5, 0.1, 4, 24), r2), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]], Y: [[new n.Kj0(new n.XvJ(0.5, 0.1, 4, 24), r2), [0, 0, 0], [Math.PI / 2, 0, 0]]], Z: [[new n.Kj0(new n.XvJ(0.5, 0.1, 4, 24), r2), [0, 0, 0], [0, 0, -Math.PI / 2]]], E: [[new n.Kj0(new n.XvJ(0.75, 0.1, 2, 24), r2)]] }, C2 = { X: [[new n.Kj0(m2, s2), [0.5, 0, 0], [0, 0, -Math.PI / 2]], [new n.Kj0(g2, s2), [0, 0, 0], [0, 0, -Math.PI / 2]], [new n.Kj0(m2, s2), [-0.5, 0, 0], [0, 0, Math.PI / 2]]], Y: [[new n.Kj0(m2, o2), [0, 0.5, 0]], [new n.Kj0(g2, o2)], [new n.Kj0(m2, o2), [0, -0.5, 0], [0, 0, Math.PI]]], Z: [[new n.Kj0(m2, a2), [0, 0, 0.5], [Math.PI / 2, 0, 0]], [new n.Kj0(g2, a2), [0, 0, 0], [Math.PI / 2, 0, 0]], [new n.Kj0(m2, a2), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]], XY: [[new n.Kj0(new n.DvJ(0.15, 0.15, 0.01), u2), [0.15, 0.15, 0]]], YZ: [[new n.Kj0(new n.DvJ(0.15, 0.15, 0.01), l2), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]], XZ: [[new n.Kj0(new n.DvJ(0.15, 0.15, 0.01), c2), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]], XYZ: [[new n.Kj0(new n.DvJ(0.1, 0.1, 0.1), p2.clone())]] }, S2 = { X: [[new n.Kj0(new n.fHI(0.2, 0, 0.6, 4), r2), [0.3, 0, 0], [0, 0, -Math.PI / 2]], [new n.Kj0(new n.fHI(0.2, 0, 0.6, 4), r2), [-0.3, 0, 0], [0, 0, Math.PI / 2]]], Y: [[new n.Kj0(new n.fHI(0.2, 0, 0.6, 4), r2), [0, 0.3, 0]], [new n.Kj0(new n.fHI(0.2, 0, 0.6, 4), r2), [0, -0.3, 0], [0, 0, Math.PI]]], Z: [[new n.Kj0(new n.fHI(0.2, 0, 0.6, 4), r2), [0, 0, 0.3], [Math.PI / 2, 0, 0]], [new n.Kj0(new n.fHI(0.2, 0, 0.6, 4), r2), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]], XY: [[new n.Kj0(new n.DvJ(0.2, 0.2, 0.01), r2), [0.15, 0.15, 0]]], YZ: [[new n.Kj0(new n.DvJ(0.2, 0.2, 0.01), r2), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]], XZ: [[new n.Kj0(new n.DvJ(0.2, 0.2, 0.01), r2), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]], XYZ: [[new n.Kj0(new n.DvJ(0.2, 0.2, 0.2), r2), [0, 0, 0]]] }, M2 = { X: [[new n.x12(_2, i2.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]], Y: [[new n.x12(_2, i2.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]], Z: [[new n.x12(_2, i2.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]] };
      function T2(e3) {
        const t3 = new n.Tme();
        for (const n2 in e3)
          for (let r3 = e3[n2].length; r3--; ) {
            const i3 = e3[n2][r3][0].clone(), s3 = e3[n2][r3][1], o3 = e3[n2][r3][2], a3 = e3[n2][r3][3], l3 = e3[n2][r3][4];
            i3.name = n2, i3.tag = l3, s3 && i3.position.set(s3[0], s3[1], s3[2]), o3 && i3.rotation.set(o3[0], o3[1], o3[2]), a3 && i3.scale.set(a3[0], a3[1], a3[2]), i3.updateMatrix();
            const c3 = i3.geometry.clone();
            c3.applyMatrix4(i3.matrix), i3.geometry = c3, i3.renderOrder = 1 / 0, i3.position.set(0, 0, 0), i3.rotation.set(0, 0, 0), i3.scale.set(1, 1, 1), t3.add(i3);
          }
        return t3;
      }
      this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = T2(y2)), this.add(this.gizmo.rotate = T2(A2)), this.add(this.gizmo.scale = T2(C2)), this.add(this.picker.translate = T2(b2)), this.add(this.picker.rotate = T2(E2)), this.add(this.picker.scale = T2(S2)), this.add(this.helper.translate = T2(w2)), this.add(this.helper.rotate = T2(x2)), this.add(this.helper.scale = T2(M2)), this.picker.translate.visible = false, this.picker.rotate.visible = false, this.picker.scale.visible = false;
    }
    updateMatrixWorld(e2) {
      const t2 = "local" === ("scale" === this.mode ? "local" : this.space) ? this.worldQuaternion : Ta;
      this.gizmo.translate.visible = "translate" === this.mode, this.gizmo.rotate.visible = "rotate" === this.mode, this.gizmo.scale.visible = "scale" === this.mode, this.helper.translate.visible = "translate" === this.mode, this.helper.rotate.visible = "rotate" === this.mode, this.helper.scale.visible = "scale" === this.mode;
      let n2 = [];
      n2 = n2.concat(this.picker[this.mode].children), n2 = n2.concat(this.gizmo[this.mode].children), n2 = n2.concat(this.helper[this.mode].children);
      for (let e3 = 0; e3 < n2.length; e3++) {
        const r2 = n2[e3];
        let i2;
        if (r2.visible = true, r2.rotation.set(0, 0, 0), r2.position.copy(this.worldPosition), i2 = this.camera.isOrthographicCamera ? (this.camera.top - this.camera.bottom) / this.camera.zoom : this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), r2.scale.set(1, 1, 1).multiplyScalar(i2 * this.size / 4), "helper" !== r2.tag) {
          if (r2.quaternion.copy(t2), "translate" === this.mode || "scale" === this.mode) {
            const e4 = 0.99, n3 = 0.2;
            "X" === r2.name && Math.abs(Ea.copy(Ra).applyQuaternion(t2).dot(this.eye)) > e4 && (r2.scale.set(1e-10, 1e-10, 1e-10), r2.visible = false), "Y" === r2.name && Math.abs(Ea.copy(ka).applyQuaternion(t2).dot(this.eye)) > e4 && (r2.scale.set(1e-10, 1e-10, 1e-10), r2.visible = false), "Z" === r2.name && Math.abs(Ea.copy(Da).applyQuaternion(t2).dot(this.eye)) > e4 && (r2.scale.set(1e-10, 1e-10, 1e-10), r2.visible = false), "XY" === r2.name && Math.abs(Ea.copy(Da).applyQuaternion(t2).dot(this.eye)) < n3 && (r2.scale.set(1e-10, 1e-10, 1e-10), r2.visible = false), "YZ" === r2.name && Math.abs(Ea.copy(Ra).applyQuaternion(t2).dot(this.eye)) < n3 && (r2.scale.set(1e-10, 1e-10, 1e-10), r2.visible = false), "XZ" === r2.name && Math.abs(Ea.copy(ka).applyQuaternion(t2).dot(this.eye)) < n3 && (r2.scale.set(1e-10, 1e-10, 1e-10), r2.visible = false);
          } else
            "rotate" === this.mode && (Ma.copy(t2), Ea.copy(this.eye).applyQuaternion(ua.copy(t2).invert()), -1 !== r2.name.search("E") && r2.quaternion.setFromRotationMatrix(Sa.lookAt(this.eye, Ca, ka)), "X" === r2.name && (ua.setFromAxisAngle(Ra, Math.atan2(-Ea.y, Ea.z)), ua.multiplyQuaternions(Ma, ua), r2.quaternion.copy(ua)), "Y" === r2.name && (ua.setFromAxisAngle(ka, Math.atan2(Ea.x, Ea.z)), ua.multiplyQuaternions(Ma, ua), r2.quaternion.copy(ua)), "Z" === r2.name && (ua.setFromAxisAngle(Da, Math.atan2(Ea.y, Ea.x)), ua.multiplyQuaternions(Ma, ua), r2.quaternion.copy(ua)));
          r2.visible = r2.visible && (-1 === r2.name.indexOf("X") || this.showX), r2.visible = r2.visible && (-1 === r2.name.indexOf("Y") || this.showY), r2.visible = r2.visible && (-1 === r2.name.indexOf("Z") || this.showZ), r2.visible = r2.visible && (-1 === r2.name.indexOf("E") || this.showX && this.showY && this.showZ), r2.material._color = r2.material._color || r2.material.color.clone(), r2.material._opacity = r2.material._opacity || r2.material.opacity, r2.material.color.copy(r2.material._color), r2.material.opacity = r2.material._opacity, this.enabled && this.axis && (r2.name === this.axis || this.axis.split("").some(function(e4) {
            return r2.name === e4;
          })) && (r2.material.color.setHex(16776960), r2.material.opacity = 1);
        } else
          r2.visible = false, "AXIS" === r2.name ? (r2.visible = !!this.axis, "X" === this.axis && (ua.setFromEuler(xa.set(0, 0, 0)), r2.quaternion.copy(t2).multiply(ua), Math.abs(Ea.copy(Ra).applyQuaternion(t2).dot(this.eye)) > 0.9 && (r2.visible = false)), "Y" === this.axis && (ua.setFromEuler(xa.set(0, 0, Math.PI / 2)), r2.quaternion.copy(t2).multiply(ua), Math.abs(Ea.copy(ka).applyQuaternion(t2).dot(this.eye)) > 0.9 && (r2.visible = false)), "Z" === this.axis && (ua.setFromEuler(xa.set(0, Math.PI / 2, 0)), r2.quaternion.copy(t2).multiply(ua), Math.abs(Ea.copy(Da).applyQuaternion(t2).dot(this.eye)) > 0.9 && (r2.visible = false)), "XYZE" === this.axis && (ua.setFromEuler(xa.set(0, Math.PI / 2, 0)), Ea.copy(this.rotationAxis), r2.quaternion.setFromRotationMatrix(Sa.lookAt(Ca, Ea, ka)), r2.quaternion.multiply(ua), r2.visible = this.dragging), "E" === this.axis && (r2.visible = false)) : "START" === r2.name ? (r2.position.copy(this.worldPositionStart), r2.visible = this.dragging) : "END" === r2.name ? (r2.position.copy(this.worldPosition), r2.visible = this.dragging) : "DELTA" === r2.name ? (r2.position.copy(this.worldPositionStart), r2.quaternion.copy(this.worldQuaternionStart), la.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), la.applyQuaternion(this.worldQuaternionStart.clone().invert()), r2.scale.copy(la), r2.visible = this.dragging) : (r2.quaternion.copy(t2), this.dragging ? r2.position.copy(this.worldPositionStart) : r2.position.copy(this.worldPosition), this.axis && (r2.visible = -1 !== this.axis.search(r2.name)));
      }
      super.updateMatrixWorld(e2);
    }
  }
  class Fa extends n.Kj0 {
    constructor() {
      super(new n._12(1e5, 1e5, 2, 2), new n.vBJ({ visible: false, wireframe: true, side: n.ehD, transparent: true, opacity: 0.1, toneMapped: false })), this.isTransformControlsPlane = true, this.type = "TransformControlsPlane";
    }
    updateMatrixWorld(e2) {
      let t2 = this.space;
      switch (this.position.copy(this.worldPosition), "scale" === this.mode && (t2 = "local"), Ba.copy(Ra).applyQuaternion("local" === t2 ? this.worldQuaternion : Ta), Oa.copy(ka).applyQuaternion("local" === t2 ? this.worldQuaternion : Ta), La.copy(Da).applyQuaternion("local" === t2 ? this.worldQuaternion : Ta), Ea.copy(Oa), this.mode) {
        case "translate":
        case "scale":
          switch (this.axis) {
            case "X":
              Ea.copy(this.eye).cross(Ba), Pa.copy(Ba).cross(Ea);
              break;
            case "Y":
              Ea.copy(this.eye).cross(Oa), Pa.copy(Oa).cross(Ea);
              break;
            case "Z":
              Ea.copy(this.eye).cross(La), Pa.copy(La).cross(Ea);
              break;
            case "XY":
              Pa.copy(La);
              break;
            case "YZ":
              Pa.copy(Ba);
              break;
            case "XZ":
              Ea.copy(La), Pa.copy(Oa);
              break;
            case "XYZ":
            case "E":
              Pa.set(0, 0, 0);
          }
          break;
        default:
          Pa.set(0, 0, 0);
      }
      0 === Pa.length() ? this.quaternion.copy(this.cameraQuaternion) : (Ia.lookAt(la.set(0, 0, 0), Pa, Ea), this.quaternion.setFromRotationMatrix(Ia)), super.updateMatrixWorld(e2);
    }
  }
  class Na extends _a2 {
    _keyDownListener(e2) {
      if (this.enabled && this.object) {
        switch (e2.keyCode) {
          case 81:
            this.setSpace("local" === this.space ? "world" : "local");
            break;
          case 16:
            this.setTranslationSnap(100), this.setRotationSnap(n.M8C.degToRad(15)), this.setScaleSnap(0.25);
            break;
          case 87:
            this.setMode("translate");
            break;
          case 69:
            this.setMode("rotate");
            break;
          case 82:
            this.setMode("scale");
            break;
          case 187:
          case 107:
            this.setSize(this.size + 0.1);
            break;
          case 189:
          case 109:
            this.setSize(Math.max(this.size - 0.1, 0.1));
            break;
          case 88:
            this.showX = !this.showX;
            break;
          case 89:
            this.showY = !this.showY;
            break;
          case 90:
            this.showZ = !this.showZ;
            break;
          case 32:
            this.enabled = !this.enabled;
            break;
          default:
            return;
        }
        this._scene.setDirty({ sceneUpdate: true, frameFade: true });
      }
    }
    _keyUpListener(e2) {
      this.enabled && (16 === e2.keyCode && (this.setTranslationSnap(null), this.setRotationSnap(null), this.setScaleSnap(null)), this.object && e2.keyCode);
    }
    constructor(e2) {
      super(e2.scene.activeCamera.cameraObject, e2.canvas), this.modelObject = this, this.assetType = "widget", this._activeCameraChange = this._activeCameraChange.bind(this), this._scene = e2.scene, this._scene.addEventListener("activeCameraChange", this._activeCameraChange), this.visible = false, this.userData.bboxVisible = false, this.addEventListener("objectChange", () => {
        var e3;
        null === (e3 = null == this ? void 0 : this.object) || void 0 === e3 || e3.dispatchEvent({ type: "objectUpdate", fadeFrame: false });
      }), this.addEventListener("dragging-changed", (t2) => {
        const n2 = null == e2 ? void 0 : e2.getPlugin(Po);
        n2 && (t2.value ? n2.disable("TransformControls") : n2.enable("TransformControls")), this._scene.activeCamera.setInteractions(!t2.value, this.uuid);
      }), this._keyDownListener = this._keyDownListener.bind(this), this._keyUpListener = this._keyUpListener.bind(this), window.addEventListener("keydown", this._keyDownListener), window.addEventListener("keyup", this._keyUpListener), this._scene.addWidget(this);
    }
    _activeCameraChange() {
      this.camera = this._scene.activeCamera.cameraObject;
    }
    dispose() {
      window.removeEventListener("keydown", this._keyDownListener), window.removeEventListener("keyup", this._keyUpListener), this._scene.removeEventListener("activeCameraChange", this._activeCameraChange), this._scene.modelObject.remove(this), super.dispose();
    }
  }
  var ja = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  class za extends gt {
    get picker() {
      return this._picker;
    }
    setDirty() {
      var e2;
      null === (e2 = this._viewer) || void 0 === e2 || e2.setDirty();
    }
    constructor(e2 = oa, t2 = false, n2 = true, r2 = false) {
      super(), this.enabled = true, this._enableWidget = true, this.autoFocus = false, this._onObjectHit = (e3) => {
        this._viewer && (this.enabled ? this.dispatchEvent(e3) : e3.intersects.selectedObject = null);
      }, this._uiConfigChildren = [{ label: "Enabled", type: "checkbox", property: [this, "enabled"] }, { label: "AutoFocus", type: "checkbox", property: [this, "autoFocus"], onChange: () => {
        const e3 = this.getSelectedObject();
        this.autoFocus && e3 && this.setSelectedObject(e3, true);
      } }], e2 && (this._widget = new e2()), this._controls = t2, this._pickUi = n2, this.autoFocus = r2;
    }
    getSelectedObject() {
      var e2;
      if (this.enabled)
        return (null === (e2 = this._picker) || void 0 === e2 ? void 0 : e2.selectedObject) || void 0;
    }
    setSelectedObject(e2, t2 = false) {
      if (!this.enabled)
        return;
      if (!this._picker)
        return;
      const n2 = this.autoFocus;
      this.autoFocus = false, this._picker.selectedObject = e2 || null, this.autoFocus = n2, (n2 || t2) && this.focusObject(e2);
    }
    async onAdded(e2) {
      await super.onAdded(e2), this._picker = new Ko(e2.scene, e2.canvas, void 0, (e3) => {
        var t2, n2;
        if (!e3.material)
          return false;
        let r2 = e3, i2 = false;
        for (; r2; ) {
          if (!r2.visible)
            return false;
          if ("model" === (null !== (t2 = r2.userData.iModel) && void 0 !== t2 ? t2 : r2).assetType && (i2 = true), "widget" === (null !== (n2 = r2.userData.iModel) && void 0 !== n2 ? n2 : r2).assetType)
            return false;
          if (false === r2.userData.userSelectable)
            return false;
          if (false === r2.userData.bboxVisible)
            return false;
          r2 = r2.parent;
        }
        return i2;
      }), this._widget && e2.scene.addWidget(this._widget), this._transformControls = new Na(e2), this._transformControls.enabled = this._controls, this._picker.addEventListener("selectedObjectChanged", (t2) => {
        var n2, r2, i2;
        this.dispatchEvent(t2);
        const s2 = (null === (n2 = this._picker) || void 0 === n2 ? void 0 : n2.selectedObject) || void 0;
        if (this._pickUi) {
          const e3 = null == s2 ? void 0 : s2.uiConfig, t3 = this.uiConfig;
          t3.children = [...this._uiConfigChildren], e3 && t3.children.push(e3), null === (r2 = t3.uiRefresh) || void 0 === r2 || r2.call(t3);
        }
        const o2 = this._widget;
        o2 && this._enableWidget && (s2 ? o2.attach(s2) : o2.detach());
        const a2 = this._transformControls;
        a2 && (null === (i2 = this._viewer) || void 0 === i2 ? void 0 : i2.scene.activeCamera.controls) && (s2 && a2.enabled ? a2.attach(s2) : a2.detach()), e2.setDirty(), this.autoFocus && this.focusObject(s2);
      }), this._picker.addEventListener("hoverObjectChanged", this.dispatchEvent), this._picker.addEventListener("hitObject", this._onObjectHit), e2.scene.addEventListener("select", (e3) => {
        void 0 === e3.value ? console.warn("WebGi: e.value must be set for picking, can be null to unselect") : this.setSelectedObject(e3.value, this.autoFocus || e3.focusCamera);
      }), e2.scene.addEventListener("addSceneObject", async (t2) => {
        var n2, r2, i2;
        const s2 = t2.object, o2 = this.getSelectedObject();
        if (o2 && "material" === (null == s2 ? void 0 : s2.assetType) && "function" == typeof (null == o2 ? void 0 : o2.setMaterial) && (null === (n2 = null == o2 ? void 0 : o2.modelObject) || void 0 === n2 ? void 0 : n2.isMesh) && await e2.confirm("Applying material: Apply material to the selected object?")) {
          const t3 = o2.material;
          if (Array.isArray(t3))
            console.warn("WebGi: Dropping on material array not yet fully supported."), o2.setMaterial(s2);
          else {
            let n3 = Array.from(null !== (r2 = null == t3 ? void 0 : t3.userData.__appliedMeshes) && void 0 !== r2 ? r2 : []);
            (n3.length > 1 ? !await e2.confirm("Applying material: Apply to all objects using this material?") : n3.length < 1) && (n3 = [o2]);
            for (const e3 of n3)
              e3 && (null === (i2 = e3.setMaterial) || void 0 === i2 || i2.call(e3, s2));
          }
        }
      }), e2.scene.addEventListener("sceneUpdate", (t2) => {
        if (!t2.hierarchyChanged)
          return;
        const n2 = this.getSelectedObject();
        let r2 = false;
        null == n2 || n2.traverseAncestors((t3) => {
          t3 === e2.scene.modelObject && (r2 = true);
        }), r2 || this.setSelectedObject(void 0);
      });
    }
    async focusObject(e2) {
      var t2, n2, r2, i2;
      const s2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPluginByType("CameraViews");
      await (null == s2 ? void 0 : s2.animateToFitObject(e2, 1.25, 1e3, "easeOut", { min: (null !== (i2 = null === (r2 = null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.scene.activeCamera.getControls()) || void 0 === r2 ? void 0 : r2.minDistance) && void 0 !== i2 ? i2 : 0.5) + 0.5, max: 50 }));
    }
    enableWidget(e2) {
      var t2, n2, r2;
      if (this._enableWidget = e2, e2) {
        const e3 = (null === (t2 = this._picker) || void 0 === t2 ? void 0 : t2.selectedObject) || void 0;
        e3 && (null === (n2 = this._widget) || void 0 === n2 || n2.attach(e3));
      } else
        null === (r2 = this._widget) || void 0 === r2 || r2.detach();
    }
    get uiConfig() {
      return this._pickUi ? this._uiConfig ? this._uiConfig : this._uiConfig = { type: "panel", label: "Picker", expanded: true, children: [...this._uiConfigChildren] } : {};
    }
    get transformControls() {
      return this._transformControls;
    }
    get widget() {
      return this._widget;
    }
  }
  za.PluginType = "Picking", ja([ie()], za.prototype, "enabled", void 0), ja([ie()], za.prototype, "autoFocus", void 0);
  var Ga, Va = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let Ha = Ga = class extends gt {
    enableCustomBump(e2, t2, n2) {
      var r2, i2;
      const s2 = null === (r2 = e2.materialObject) || void 0 === r2 ? void 0 : r2.userData;
      if (!s2)
        return false;
      if (void 0 === s2._hasCustomBump) {
        const e3 = s2.__appliedMeshes;
        let t3 = true;
        if (e3)
          for (const { geometry: n3 } of e3)
            !n3 || n3.attributes.position && n3.attributes.normal && n3.attributes.uv || (t3 = false);
        if (!t3)
          return false;
      }
      return s2._hasCustomBump = true, s2._customBumpScale = null !== (i2 = null != n2 ? n2 : s2._customBumpScale) && void 0 !== i2 ? i2 : 1e-3, s2._customBumpMap = null != t2 ? t2 : s2._customBumpMap, e2.materialObject.needsUpdate = true, true;
    }
    _loaderCreate({ loader: e2 }) {
      e2.isGLTFLoader2 && e2.register((e3) => new Qa(e3));
    }
    constructor() {
      super(), this.enabled = true, this.dependencies = [Ls], this.bicubicFiltering = true, this._defines = { CUSTOM_BUMP_MAP_DEBUG: false, CUSTOM_BUMP_MAP_BICUBIC: true }, this._uniforms = { customBumpUvTransform: { value: new n.Vkp() }, customBumpScale: { value: 1e-3 }, customBumpMap: { value: null } }, this.materialExtension = { parsFragmentSnippet: (e2, t2) => this.enabled && (null == t2 ? void 0 : t2.materialObject.userData._hasCustomBump) ? "#if defined(CUSTOM_BUMP_MAP_ENABLED) && CUSTOM_BUMP_MAP_ENABLED > 0\n#if CUSTOM_BUMP_MAP_BICUBIC > 0  \nvec4 cubic_cb(float v){vec4 n=vec4(1.,2.,3.,4.)-v;vec4 s=n*n*n;float x=s.x;float y=s.y-4.*s.x;float z=s.z-4.*s.y+6.*s.x;float w=6.-x-y-z;return vec4(x,y,z,w)*(1./6.);}vec4 textureBicubic_cb(sampler2D sampler,vec2 texCoords){vec2 texSize=vec2(textureSize(sampler,0));vec2 invTexSize=1./texSize;texCoords=texCoords*texSize-0.5;vec2 fxy=fract(texCoords);texCoords-=fxy;vec4 xcubic=cubic_cb(fxy.x);vec4 ycubic=cubic_cb(fxy.y);vec4 c=texCoords.xxyy+vec2(-0.5,+1.5).xyxy;vec4 s=vec4(xcubic.xz+xcubic.yw,ycubic.xz+ycubic.yw);vec4 offset=c+vec4(xcubic.yw,ycubic.yw)/s;offset*=invTexSize.xxyy;vec4 sample0=texture(sampler,offset.xz);vec4 sample1=texture(sampler,offset.yz);vec4 sample2=texture(sampler,offset.xw);vec4 sample3=texture(sampler,offset.yw);float sx=s.x/(s.x+s.y);float sy=s.z/(s.z+s.w);return mix(mix(sample3,sample2,sx),mix(sample1,sample0,sx),sy);}\n#endif\nvarying vec2 vCustomBumpUv;uniform sampler2D customBumpMap;uniform float customBumpScale;vec2 dHdxy_fwd_cb(){vec2 dSTdx=dFdx(vCustomBumpUv);vec2 dSTdy=dFdy(vCustomBumpUv);\n#if CUSTOM_BUMP_MAP_BICUBIC > 0\nfloat Hll=customBumpScale*textureBicubic_cb(customBumpMap,vCustomBumpUv).x;float dBx=customBumpScale*textureBicubic_cb(customBumpMap,vCustomBumpUv+dSTdx).x-Hll;float dBy=customBumpScale*textureBicubic_cb(customBumpMap,vCustomBumpUv+dSTdy).x-Hll;\n#else\nfloat Hll=customBumpScale*texture2D(customBumpMap,vCustomBumpUv).x;float dBx=customBumpScale*texture2D(customBumpMap,vCustomBumpUv+dSTdx).x-Hll;float dBy=customBumpScale*texture2D(customBumpMap,vCustomBumpUv+dSTdy).x-Hll;\n#endif\nreturn vec2(dBx,dBy);}\n#ifndef USE_BUMPMAP\nvec3 perturbNormalArb(vec3 surf_pos,vec3 surf_norm,vec2 dHdxy,float faceDirection){vec3 vSigmaX=dFdx(surf_pos.xyz);vec3 vSigmaY=dFdy(surf_pos.xyz);vec3 vN=surf_norm;vec3 R1=cross(vSigmaY,vN);vec3 R2=cross(vN,vSigmaX);float fDet=dot(vSigmaX,R1)*faceDirection;vec3 vGrad=sign(fDet)*(dHdxy.x*R1+dHdxy.y*R2);return normalize(abs(fDet)*surf_norm-vGrad);}\n#endif\n#endif\n" : "", shaderExtender: (e2, t2, n2) => {
        var r2;
        this.enabled && t2.materialObject.userData._hasCustomBump && (null === (r2 = t2.materialObject.userData) || void 0 === r2 ? void 0 : r2._customBumpMap) && (e2.fragmentShader = ot(e2.fragmentShader, "#glMarker beforeAccumulation", "\n#if defined(CUSTOM_BUMP_MAP_ENABLED) && CUSTOM_BUMP_MAP_ENABLED > 0\n    normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd_cb(), faceDirection );\n#endif\n                ", { prepend: true }), e2.vertexShader = ot(e2.vertexShader, "#include <uv_pars_vertex>", "\n#if defined(CUSTOM_BUMP_MAP_ENABLED) && CUSTOM_BUMP_MAP_ENABLED > 0\n                varying vec2 vCustomBumpUv;\n                uniform mat3 customBumpUvTransform;\n#endif\n                ", { prepend: true }), e2.vertexShader = ot(e2.vertexShader, "#include <uv_vertex>", "\n#if defined(CUSTOM_BUMP_MAP_ENABLED) && CUSTOM_BUMP_MAP_ENABLED > 0\n                vCustomBumpUv = ( customBumpUvTransform * vec3( uv, 1 ) ).xy;\n#endif\n                ", { prepend: true }), e2.defines.USE_UV = "");
      }, onObjectRender: (e2, t2) => {
        var n2;
        const r2 = t2.materialObject.userData;
        if (!(null == r2 ? void 0 : r2._hasCustomBump))
          return;
        const i2 = e2;
        if (!i2.isMesh || !i2.geometry)
          return;
        const s2 = (null === (n2 = r2._customBumpMap) || void 0 === n2 ? void 0 : n2.isTexture) ? r2._customBumpMap : null;
        this._uniforms.customBumpMap.value = s2, this._uniforms.customBumpScale.value = s2 ? r2._customBumpScale : 0, s2 && (s2.updateMatrix(), this._uniforms.customBumpUvTransform.value.copy(s2.matrix));
        let o2 = this.enabled && s2 ? 1 : 0;
        t2.materialObject.defines.CUSTOM_BUMP_MAP_ENABLED !== o2 && (t2.materialObject.defines.CUSTOM_BUMP_MAP_ENABLED = o2, t2.materialObject.needsUpdate = true), o2 = +this._defines.CUSTOM_BUMP_MAP_DEBUG, t2.materialObject.defines.CUSTOM_BUMP_MAP_DEBUG !== o2 && (t2.materialObject.defines.CUSTOM_BUMP_MAP_DEBUG = o2, t2.materialObject.needsUpdate = true), o2 = +this._defines.CUSTOM_BUMP_MAP_BICUBIC, t2.materialObject.defines.CUSTOM_BUMP_MAP_BICUBIC !== o2 && (t2.materialObject.defines.CUSTOM_BUMP_MAP_BICUBIC = o2, t2.materialObject.needsUpdate = true);
      }, extraUniforms: { ...this._uniforms }, computeCacheKey: (e2) => {
        var t2, n2, r2;
        return (this.enabled ? "1" : "0") + ((null === (t2 = e2.materialObject.userData) || void 0 === t2 ? void 0 : t2._hasCustomBump) ? "1" : "0") + (null === (r2 = null === (n2 = e2.materialObject.userData) || void 0 === n2 ? void 0 : n2._customBumpMap) || void 0 === r2 ? void 0 : r2.uuid);
      }, isCompatible: (e2) => e2.isMeshStandardMaterial2, updaters: () => [], getUiConfig: (e2) => {
        const t2 = this._viewer, n2 = this.enableCustomBump, r2 = { type: "folder", label: "CustomBumpMap", children: [{ type: "checkbox", label: "Enabled", get value() {
          return e2.materialObject.userData._hasCustomBump || false;
        }, set value(i2) {
          var s2;
          i2 !== e2.materialObject.userData._hasCustomBump && (i2 ? n2(e2) || t2.alert("One or more geometries cannot be made anisotropic.") : (e2.materialObject.userData._hasCustomBump = false, e2.materialObject.needsUpdate = true), null === (s2 = r2.uiRefresh) || void 0 === s2 || s2.call(r2, "postFrame", true));
        }, onChange: this.setDirty }, { type: "slider", label: "Bump Scale", bounds: [-1, 1], hidden: () => !e2.materialObject.userData._hasCustomBump, property: [e2.materialObject.userData, "_customBumpScale"], onChange: this.setDirty }, { type: "image", label: "Bump Map", hidden: () => !e2.materialObject.userData._hasCustomBump, property: [e2.materialObject.userData, "_customBumpMap"], onChange: () => {
          e2.materialObject.needsUpdate = true, this.setDirty();
        } }, X(e2.materialObject.userData, "_customBumpMap")] };
        return r2;
      } }, this.setDirty = () => {
        var e2, t2, n2;
        null === (t2 = (e2 = this.materialExtension).setDirty) || void 0 === t2 || t2.call(e2), null === (n2 = this._viewer) || void 0 === n2 || n2.setDirty();
      }, this.enableCustomBumpSelected = () => {
        var e2, t2, n2;
        const r2 = null === (n2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPlugin(za)) || void 0 === t2 ? void 0 : t2.getSelectedObject()) || void 0 === n2 ? void 0 : n2.material;
        return "material" === (null == r2 ? void 0 : r2.assetType) && this.enableCustomBump(r2);
      }, this._loaderCreate = this._loaderCreate.bind(this);
    }
    async onAdded(e2) {
      var t2, n2, r2, i2, s2;
      await super.onAdded(e2);
      const o2 = e2.getPlugin(Ls);
      null === (t2 = null == o2 ? void 0 : o2.materials) || void 0 === t2 || t2.registerMaterialExtension(this.materialExtension), null === (n2 = null == o2 ? void 0 : o2.importer) || void 0 === n2 || n2.addEventListener("loaderCreate", this._loaderCreate), null === (s2 = null === (i2 = null === (r2 = null == o2 ? void 0 : o2.exporter) || void 0 === r2 ? void 0 : r2.getExporter("gltf", "glb")) || void 0 === i2 ? void 0 : i2.extensions) || void 0 === s2 || s2.push(Wa);
    }
    async onRemove(e2) {
      var t2, n2, r2, i2, s2, o2, a2, l2, c2, u2, p2, d2;
      null === (n2 = null === (t2 = e2.getPlugin(Ls)) || void 0 === t2 ? void 0 : t2.materials) || void 0 === n2 || n2.unregisterMaterialExtension(this.materialExtension), null === (i2 = null === (r2 = e2.getPlugin(Ls)) || void 0 === r2 ? void 0 : r2.importer) || void 0 === i2 || i2.removeEventListener("loaderCreate", this._loaderCreate);
      const h2 = null === (l2 = null === (a2 = null === (o2 = null === (s2 = e2.getPlugin(Ls)) || void 0 === s2 ? void 0 : s2.exporter) || void 0 === o2 ? void 0 : o2.getExporter("gltf", "glb")) || void 0 === a2 ? void 0 : a2.extensions) || void 0 === l2 ? void 0 : l2.indexOf(Wa);
      return void 0 !== h2 && -1 !== h2 && (null === (d2 = null === (p2 = null === (u2 = null === (c2 = e2.getPlugin(Ls)) || void 0 === c2 ? void 0 : c2.exporter) || void 0 === u2 ? void 0 : u2.getExporter("gltf", "glb")) || void 0 === p2 ? void 0 : p2.extensions) || void 0 === d2 || d2.splice(h2, 1)), super.onRemove(e2);
    }
  };
  Ha.PluginType = "CustomBumpMapPlugin", Ha.CUSTOM_BUMP_MAP_GLTF_EXTENSION = "WEBGI_materials_custom_bump_map", Va([Oe("Enabled", (e2) => ({ onChange: e2.setDirty })), ie()], Ha.prototype, "enabled", void 0), Va([Oe("Bicubic", (e2) => ({ onChange: e2.setDirty })), z("CUSTOM_BUMP_MAP_BICUBIC", void 0, true, Ga.prototype.setDirty), ie()], Ha.prototype, "bicubicFiltering", void 0), Va([je("Enable CustomBumpMap", (e2) => ({ hidden: () => {
    var t2;
    return !(null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(za));
  } }))], Ha.prototype, "enableCustomBumpSelected", void 0), Ha = Ga = Va([We("CustomBumpMap Materials")], Ha);
  class Qa {
    constructor(e2) {
      this.parser = e2, this.name = Ha.CUSTOM_BUMP_MAP_GLTF_EXTENSION;
    }
    async extendMaterialParams(e2, t2) {
      var r2;
      const i2 = this.parser, s2 = i2.json.materials[e2];
      if (!s2.extensions || !s2.extensions[this.name])
        return Promise.resolve();
      const o2 = [], a2 = s2.extensions[this.name];
      t2.userData || (t2.userData = {}), t2.userData._hasCustomBump = true, t2.userData._customBumpScale = null !== (r2 = a2.customBumpScale) && void 0 !== r2 ? r2 : 0;
      const l2 = a2.customBumpMap;
      return l2 && o2.push(i2.assignTexture(t2.userData, "_customBumpMap", l2).then((e3) => {
        e3.colorSpace = n.KI_;
      })), Promise.all(o2);
    }
  }
  const Wa = (e2) => ({ writeMaterial: (t2, n2) => {
    if (!t2.isMeshStandardMaterial || !t2.userData._hasCustomBump)
      return;
    if ((t2.userData._customBumpScale || 0) < 1e-3)
      return;
    n2.extensions = n2.extensions || {};
    const r2 = {};
    if (r2.customBumpScale = t2.userData._customBumpScale || 1, t2.userData._customBumpMap) {
      const n3 = { index: e2.processTexture(t2.userData._customBumpMap) };
      e2.applyTextureTransform(n3, t2.userData._customBumpMap), r2.customBumpMap = n3;
    }
    n2.extensions[Ha.CUSTOM_BUMP_MAP_GLTF_EXTENSION] = r2, e2.extensionsUsed[Ha.CUSTOM_BUMP_MAP_GLTF_EXTENSION] = true;
  } });
  var qa, Xa = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let Ya = qa = class extends gt {
    get animationState() {
      return this._animationState;
    }
    get animationTime() {
      return this._animationTime;
    }
    get animationDuration() {
      return this._animationDuration;
    }
    setTime(e2) {
      this._animationTime = Math.max(0, Math.min(e2, this._animationDuration));
    }
    _wheel({ deltaY: e2 }) {
      this.enabled && Math.abs(e2) > 1e-3 && (this._scrollAnimationState = -1 * Math.sign(e2));
    }
    _drag(e2) {
      this.enabled && this._viewer && ("x" === this.dragAxis ? this._dragAnimationState = e2.delta.x * this._viewer.canvas.width / 4 : this._dragAnimationState = e2.delta.y * this._viewer.canvas.height / 4);
    }
    _postFrame() {
      var e2, n2;
      if (!this._viewer)
        return;
      const r2 = this._viewer, i2 = this.animateOnScroll, s2 = this.animateOnDrag;
      if (!this.enabled || this.animations.length < 1 || "playing" !== this._animationState && !i2 && !s2)
        return this._lastFrameTime = 0, void (this._fadeDisabled && (null === (e2 = this._viewer.getPluginByType("FrameFade")) || void 0 === e2 || e2.enable(qa.PluginType), this._fadeDisabled = false));
      if (this._animationTime < 1e-4 && this.dispatchEvent({ type: "checkpointBegin" }), this.autoIncrementTime) {
        const e3 = (0, t.now)() / 1e3;
        this._lastFrameTime < 1 && (this._lastFrameTime = e3 - 1 / 30);
        let r3 = e3 - this._lastFrameTime;
        if (r3 *= this.animationSpeed, this._lastFrameTime = e3, i2 && s2 ? r3 *= (0, t.absMax)(this._scrollAnimationState, this._dragAnimationState) : i2 ? r3 *= this._scrollAnimationState : s2 && (r3 *= this._dragAnimationState), Math.abs(r3) < 1e-4)
          return;
        const o3 = null === (n2 = this._viewer.getPluginByType("Progressive")) || void 0 === n2 ? void 0 : n2.postFrameConvergedRecordingDelta();
        if (o3 && o3 > 0 && (r3 = o3), 0 === o3)
          return;
        const a3 = Math.abs(this.timeScale);
        this._animationTime += r3 * (a3 > 0 ? a3 : 1);
      }
      const o2 = this._animationTime - this._lastAnimationTime;
      this._lastAnimationTime = this._animationTime;
      const a2 = this.timeScale < 0 ? (isFinite(this._animationDuration) ? this._animationDuration : 0) - this._animationTime : this._animationTime;
      if (this.animations.map((e3) => {
        e3.mixer.setTime(a2);
      }), !(Math.abs(o2) < 1e-5)) {
        if (Math.abs(this._scrollAnimationState) < 1e-3 ? this._scrollAnimationState = 0 : this._scrollAnimationState *= 1 - this.scrollAnimationDamping, Math.abs(this._dragAnimationState) < 1e-3 ? this._dragAnimationState = 0 : this._dragAnimationState *= 1 - this.dragAnimationDamping, this.dispatchEvent({ type: "animationStep", delta: o2, time: a2 }), r2.scene.activeCamera.cameraObject.userData.__animatingCamera && r2.scene.activeCamera.setDirty(), r2.scene.refreshActiveCameraNearFar(), r2.renderer.resetShadows(), r2.setDirty(), !this._fadeDisabled) {
          const e3 = this._viewer.getPluginByType("FrameFade");
          e3 && (e3.disable(qa.PluginType), this._fadeDisabled = true);
        }
        this._animationTime >= this._animationDuration && this.dispatchEvent({ type: "checkpointEnd" });
      }
    }
    constructor() {
      super(), this.enabled = true, this._lastAnimationTime = 0, this.autoIncrementTime = true, this.animations = [], this.loopAnimations = true, this.loopRepetitions = 1 / 0, this.timeScale = 1, this.animationSpeed = 1, this.animateOnScroll = false, this._scrollAnimationState = 0, this.scrollAnimationDamping = 0.1, this.animateOnDrag = false, this.dragAxis = "y", this.autoplayOnLoad = false, this.syncMaxDuration = false, this._dragAnimationState = 0, this.dragAnimationDamping = 0.3, this.dependencies = [Ls], this._pointerDragHelper = new t.PointerDragHelper(), this._lastFrameTime = 0, this._fadeDisabled = false, this._objectAdded = (e2) => {
        const t2 = e2.object;
        if ("model" !== t2.assetType || !t2.modelObject)
          return;
        if (!this._viewer)
          return;
        let r2 = false;
        t2.modelObject.traverse((e3) => {
          var i2;
          const s2 = e3.animations;
          if (s2.length < 1)
            return;
          const o2 = Math.max(...s2.map((e4) => e4.duration));
          (null !== (i2 = t2.modelObject.userData.gltfAnim_SyncMaxDuration) && void 0 !== i2 ? i2 : this.syncMaxDuration) && (s2.forEach((e4) => e4.duration = o2), t2.modelObject.userData.gltfAnim_SyncMaxDuration = true);
          const a2 = new n.Xcj(this._viewer.scene.modelRoot.modelObject), l2 = s2.map((e4) => a2.clipAction(e4).setLoop(this.loopAnimations ? n.YKA : n.jAl, this.loopRepetitions));
          l2.forEach((e4) => e4.clampWhenFinished = true), this.animations.push({ mixer: a2, clips: s2, actions: l2, duration: o2 }), r2 = true;
        }), r2 && (this._onPropertyChange(!this.autoplayOnLoad), this.autoplayOnLoad && this.playAnimation());
      }, this._animationTime = 0, this._animationDuration = 0, this._animationState = "none", this.uiConfig = void 0, this._lastAnimId = "", this.timelineMarkers = [], this._postFrame = this._postFrame.bind(this), this._wheel = this._wheel.bind(this), this.playClips = this.playClips.bind(this), this.playClip = this.playClip.bind(this), this.playAnimation = this.playAnimation.bind(this), this.playPauseAnimation = this.playPauseAnimation.bind(this), this.pauseAnimation = this.pauseAnimation.bind(this), this.stopAnimation = this.stopAnimation.bind(this), this.resetAnimation = this.resetAnimation.bind(this), this._onPropertyChange = this._onPropertyChange.bind(this), this._loaderCreate = this._loaderCreate.bind(this), this._pointerDragHelper.addEventListener("drag", this._drag.bind(this));
    }
    _loaderCreate({ loader: e2 }) {
      e2.isGLTFLoader2 && e2.register((e3) => new Ka(e3, this));
    }
    async onAdded(e2) {
      var t2, n2, r2, i2, s2, o2;
      null === (n2 = null === (t2 = e2.getPlugin(Ls)) || void 0 === t2 ? void 0 : t2.importer) || void 0 === n2 || n2.addEventListener("loaderCreate", this._loaderCreate), e2.scene.addEventListener("addSceneObject", this._objectAdded), null === (o2 = null === (s2 = null === (i2 = null === (r2 = e2.getPlugin(Ls)) || void 0 === r2 ? void 0 : r2.exporter) || void 0 === i2 ? void 0 : i2.getExporter("gltf", "glb")) || void 0 === s2 ? void 0 : s2.extensions) || void 0 === o2 || o2.push(Ja), e2.addEventListener("postFrame", this._postFrame), window.addEventListener("wheel", this._wheel), this._pointerDragHelper.element = e2.canvas;
      let a2 = -1;
      return Object.defineProperty(e2.scene.modelRoot, "currentTimelineMarker", { get: () => a2, set: (t3) => e2.scene.modelRoot.dispatchEvent({ type: "animationTimelineMarker", marker: this.timelineMarkers[a2 = t3] }) }), e2.scene.modelRoot.addEventListener("animationTimelineMarker", ({ marker: e3 }) => {
        var t3;
        if (!this._viewer)
          return;
        if (!e3)
          return this._viewer.scene.activeCamera = null === (t3 = this._viewer) || void 0 === t3 ? void 0 : t3.scene.defaultCamera, void this._viewer.setDirty();
        const n3 = e3.camera;
        n3 && (n3.userData.__animatingCamera = true, this._viewer.scene.activeCamera = this._viewer.createCamera(n3));
      }), super.onAdded(e2);
    }
    async onRemove(e2) {
      for (var t2, n2; this.animations.length; )
        this.animations.pop();
      return e2.scene.removeEventListener("addSceneObject", this._objectAdded), null === (n2 = null === (t2 = e2.getPlugin(Ls)) || void 0 === t2 ? void 0 : t2.importer) || void 0 === n2 || n2.addEventListener("loaderCreate", this._loaderCreate), e2.removeEventListener("postFrame", this._postFrame), window.removeEventListener("wheel", this._wheel), this._pointerDragHelper.element = void 0, super.onRemove(e2);
    }
    _onPropertyChange(e2 = true) {
      this._animationDuration = Math.max(...this.animations.map(({ duration: e3 }) => e3)) * (this.loopAnimations ? this.loopRepetitions : 1), "playing" === this._animationState && e2 && this.playAnimation();
    }
    onStateChange() {
      var e2, n2;
      null === (n2 = null === (e2 = this.uiConfig) || void 0 === e2 ? void 0 : e2.children) || void 0 === n2 || n2.map((e3) => e3 && (0, t.getOrCall)(e3)).flat(2).forEach((e3) => {
        var t2;
        return null === (t2 = null == e3 ? void 0 : e3.uiRefresh) || void 0 === t2 ? void 0 : t2.call(e3);
      });
    }
    playPauseAnimation() {
      "playing" === this._animationState ? this.pauseAnimation() : this.playAnimation();
    }
    async playClip(e2, t2 = false) {
      return this.playClips([e2], t2);
    }
    async playClips(e2, t2 = false) {
      const n2 = [];
      return this.animations.forEach(({ actions: t3 }) => {
        t3.forEach((t4) => {
          e2.includes(t4.getClip().name) && n2.push(t4);
        });
      }), this.playAnimation(t2, n2);
    }
    async playAnimation(e2 = false, t2) {
      var r2;
      if (!this.enabled)
        return;
      let i2 = false;
      "playing" === this._animationState && (this.stopAnimation(false), i2 = true);
      let s2 = 0;
      const o2 = !t2;
      t2 || (t2 = [], this.animations.forEach(({ mixer: e3, actions: n2, clips: r3 }) => {
        t2.push(...n2);
      })), i2 ? this.resetAnimation() : "paused" !== this.animationState && (t2.forEach((e3) => {
        e3.reset();
      }), this._animationTime = 0);
      const a2 = ke();
      this._lastAnimId = a2;
      for (const e3 of t2)
        e3.setLoop(this.loopAnimations ? n.YKA : n.jAl, this.loopRepetitions), e3.play(), s2 = Math.max(s2, e3.getClip().duration / Math.abs(e3.timeScale));
      if (this._animationState = "playing", null === (r2 = this._viewer) || void 0 === r2 || r2.setDirty(), o2) {
        if (!isFinite(this._animationDuration))
          return;
        await new Promise((e3, t3) => {
          const n2 = () => {
            this.removeEventListener("checkpointEnd", n2), e3();
          };
          this.addEventListener("checkpointEnd", n2);
        });
      } else {
        const e3 = this.loopAnimations ? this.loopRepetitions : 1;
        if (s2 *= e3, !isFinite(s2))
          return;
        await new Promise((e4, t3) => {
          const n2 = (t4) => {
            t4.time >= s2 && (this.removeEventListener("animationStep", n2), e4());
          };
          this.addEventListener("animationStep", n2);
        });
      }
      a2 === this._lastAnimId && this.stopAnimation(e2);
    }
    pauseAnimation() {
      var e2;
      "playing" === this._animationState ? (this._animationState = "paused", null === (e2 = this._viewer) || void 0 === e2 || e2.setDirty()) : console.warn("pauseAnimation called when animation was not playing.");
    }
    resumeAnimation() {
      var e2;
      "paused" === this._animationState ? (this._animationState = "playing", null === (e2 = this._viewer) || void 0 === e2 || e2.setDirty()) : console.warn("resumeAnimation called when animation was not paused.");
    }
    stopAnimation(e2 = false) {
      var t2, n2;
      this._animationState = "stopped", e2 ? this.resetAnimation() : null === (t2 = this._viewer) || void 0 === t2 || t2.setDirty(), this._lastAnimId = "", this._viewer && this._fadeDisabled && (null === (n2 = this._viewer.getPluginByType("FrameFade")) || void 0 === n2 || n2.enable(qa.PluginType), this._fadeDisabled = false);
    }
    resetAnimation() {
      var e2;
      "stopped" === this._animationState || "none" === this._animationState ? (this.animations.forEach(({ mixer: e3, actions: t2, clips: n2 }) => {
        e3.stopAllAction(), e3.setTime(0);
      }), this._animationTime = 0, null === (e2 = this._viewer) || void 0 === e2 || e2.setDirty()) : this.stopAnimation(true);
    }
  };
  Ya.PluginType = "GLTFAnimation", Ya.AnimationMarkersExtension = "WEBGI_animation_markers", Xa([ie()], Ya.prototype, "autoIncrementTime", void 0), Xa([Le()], Ya.prototype, "animationState", null), Xa([Le()], Ya.prototype, "animationTime", null), Xa([Le()], Ya.prototype, "animationDuration", null), Xa([(0, t.onChange2)(qa.prototype._onPropertyChange), Oe("Loop", { limitedUi: true }), ie()], Ya.prototype, "loopAnimations", void 0), Xa([(0, t.onChange2)(qa.prototype._onPropertyChange), ie()], Ya.prototype, "loopRepetitions", void 0), Xa([Ue("Timescale", [-2, 2], 0.01), ie()], Ya.prototype, "timeScale", void 0), Xa([Ue("Speed", [0.1, 4], 0.1, { limitedUi: true }), ie()], Ya.prototype, "animationSpeed", void 0), Xa([Oe(), ie()], Ya.prototype, "animateOnScroll", void 0), Xa([Oe(), ie()], Ya.prototype, "animateOnDrag", void 0), Xa([Ne("Drag Axis", [{ label: "x" }, { label: "y" }]), ie()], Ya.prototype, "dragAxis", void 0), Xa([Oe(), ie()], Ya.prototype, "autoplayOnLoad", void 0), Xa([Oe("syncMaxDuration(dev)"), ie()], Ya.prototype, "syncMaxDuration", void 0), Xa([(0, t.onChange)(qa.prototype.onStateChange)], Ya.prototype, "_animationState", void 0), Xa([je("Play/Pause", (e2) => ({ label: () => "playing" === e2.animationState ? "Pause" : "Play", limitedUi: true }))], Ya.prototype, "playPauseAnimation", null), Xa([je("Stop", { limitedUi: true })], Ya.prototype, "stopAnimation", null), Xa([je("Reset", { limitedUi: true })], Ya.prototype, "resetAnimation", null), Ya = qa = Xa([We("GLTF Animations")], Ya);
  class Ka {
    constructor(e2, t2) {
      this.parser = e2, this.name = Ya.AnimationMarkersExtension, this.plugin = t2;
    }
    async afterRoot(e2) {
      var t2;
      let r2 = [];
      for (const e3 of this.parser.json.scenes || []) {
        if (!e3.extensions)
          continue;
        const t3 = e3.extensions[this.name];
        for (const e4 of (null == t3 ? void 0 : t3.markers) || []) {
          const t4 = void 0 !== e4.camera ? await this.parser.getDependency("camera", e4.camera) : void 0;
          if (void 0 === e4.time) {
            const t5 = 30;
            e4.time = e4.frame / t5, console.error("Update timeline markers plugin for correct times.");
          }
          r2.push({ name: e4.name, frame: e4.frame, time: e4.time, camera: t4 });
        }
      }
      if (r2.length < 1)
        return;
      r2 = r2.sort((e3, t3) => e3.frame - t3.frame);
      const i2 = null !== (t2 = e2.scene) && void 0 !== t2 ? t2 : e2.scenes[0];
      if (!i2)
        return;
      i2.userData.__markers = r2;
      const s2 = this.plugin.timelineMarkers, o2 = r2.map((e3) => e3.time);
      let a2 = s2.length;
      const l2 = r2.map((e3) => a2++), c2 = Math.max(...o2) + 0.01;
      s2.push(...r2);
      const u2 = new n.dUE(".currentTimelineMarker", o2, l2, n.Syv), p2 = new n.m7l("animationTimelineMarker", c2, [u2]);
      p2.__gltfExport = false, e2.animations.push(p2);
    }
  }
  const Ja = (e2) => ({ afterParse(t2) {
    const n2 = e2.json.scenes[e2.json.scene || 0];
    n2.extensions = n2.extensions || {};
    const r2 = { markers: [] }, i2 = [];
    if ((Array.isArray(t2) ? t2 : [t2]).forEach((e3) => e3.traverse((e4) => {
      e4.userData.__markers && i2.push(...e4.userData.__markers);
    })), i2.sort((e3, t3) => e3.frame - t3.frame), !(i2.length < 1)) {
      for (const t3 of i2) {
        const n3 = t3.camera;
        if (n3) {
          const i3 = e2.nodeMap.get(n3);
          if (void 0 === i3) {
            console.warn("Camera not found in gltf export", n3, e2.nodeMap);
            continue;
          }
          const s2 = e2.json.nodes[i3].camera;
          t3.camera = s2, r2.markers.push(t3);
        }
      }
      n2.extensions[Ya.AnimationMarkersExtension] = r2, e2.extensionsUsed[Ya.AnimationMarkersExtension] = true;
    }
  } });
  var Za = "#ifndef BASIC_CAMERA_HELPERS\n#define BASIC_CAMERA_HELPERS \nuniform vec2 cameraNearFar;uniform vec3 cameraPositionWorld;uniform mat4 projection;\n#ifndef THREE_PACKING_INCLUDED\n#define THREE_PACKING_INCLUDED \n#include <packing>\n#endif\nfloat linstep(float edge0,float edge1,float value){return clamp((value-edge0)/(edge1-edge0),0.,1.);}float depthToViewZ(const in float depth){return(depth>0.999)?-cameraNearFar.y*1000.:-mix(cameraNearFar.x,cameraNearFar.y,depth);}float viewZToDepth(const in float viewZ){return linstep(-cameraNearFar.x,-cameraNearFar.y,viewZ);}vec4 viewToScreen3(const in vec3 pos){vec4 projected=projection*vec4(pos,1.);projected.z=pos.z;projected.w=1./projected.w;projected.xyz*=projected.w;projected.xy=0.5+0.5*projected.xy;return projected;}vec3 screenToView(const in vec2 uv,const in float viewZ){vec2 uv_=2.*uv-1.;float xe=-(uv_.x+projection[2][0])*viewZ/projection[0][0];float ye=-(uv_.y+projection[2][1])*viewZ/projection[1][1];return vec3(xe,ye,viewZ);}\n#endif\n", $a = "#define PI  3.141592653589793\nmat3 GetTangentBasis(vec3 TangentZ){vec3 up=vec3(0.,0.,1.);vec3 TangentX=normalize(cross(dot(TangentZ,up)<0.8?up:vec3(1.,0.,0.),TangentZ));vec3 TangentY=cross(TangentZ,TangentX);return mat3(TangentX,TangentY,TangentZ);}vec4 CosineSampleHemisphere(vec2 E){float Phi=2.*PI*E.x;float CosTheta=sqrt(E.y);float SinTheta=sqrt(1.-CosTheta*CosTheta);vec3 H;H.x=SinTheta*cos(Phi);H.y=SinTheta*sin(Phi);H.z=CosTheta;float PDF=CosTheta*(1./PI);return vec4(H,PDF);}vec4 UniformSampleHemisphere(vec2 E){float Phi=2.*PI*E.x;float CosTheta=E.y;float SinTheta=sqrt(1.-CosTheta*CosTheta);vec3 H;H.x=SinTheta*cos(Phi);H.y=SinTheta*sin(Phi);H.z=CosTheta;float PDF=1./(2.*PI);return vec4(H,PDF);}vec2 UniformSampleDiskConcentric(vec2 E){vec2 p=2.*E-1.;float Radius;float Phi;if(abs(p.x)>abs(p.y)){Radius=p.x;Phi=(PI/4.)*(p.y/p.x);}else{Radius=p.y;Phi=(PI/2.)-(PI/4.)*(p.x/p.y);}return vec2(Radius*cos(Phi),Radius*sin(Phi));}vec2 UniformSampleDiskConcentricApprox(vec2 E){vec2 sf=E*sqrt(2.)-sqrt(0.5);vec2 sq=sf*sf;float root=sqrt(2.*max(sq.x,sq.y)-min(sq.x,sq.y));if(sq.x>sq.y){sf.x=sf.x>0.?root:-root;}else{sf.y=sf.y>0.?root:-root;}return sf;}", el = "#ifndef SSRT_PARS_SNIP\n#define SSRT_PARS_SNIP \n#define pow2(a)a*a\nfloat getDepth2(const in vec2 uv,const in float lod){float viewDepth=getDepth(uv);return depthToViewZ(viewDepth);}\n#define LOD_DEPTH  1.0\n#define LOD_COLOR  5.0\nvoid _traceRay(in vec4 ray_origin,in vec4 ray_dir,in float tolerance,inout vec3 state,in int loopMax,in float iStepCount){vec4 sample_uv;float d,hit;float dLod=0.;\n#pragma unroll_loop_start\nfor(int i=0;i<8;i++){if(UNROLLED_LOOP_INDEX<loopMax){sample_uv=ray_origin+ray_dir*state.y;d=getDepth2(sample_uv.xy,dLod);d=sample_uv.z/sample_uv.w-d;if(abs(d+tolerance)<tolerance){hit=clamp(state.x/(state.x-d),0.,1.)-1.;hit=(state.y+hit*iStepCount);state.z=min(state.z,hit);}state.x=d;state.y+=1.*iStepCount;}}\n#pragma unroll_loop_end\n}vec3 traceRay(in vec3 ray_origin_view,in vec3 ray_dir_view,in float tolerance,inout vec3 state,in int _STEP_COUNT){vec4 sample_uv;vec4 ray_origin=viewToScreen3(ray_origin_view);vec3 ray_end_view=ray_origin_view+ray_dir_view;vec4 ray_dir=viewToScreen3(ray_end_view);vec2 clamp_end=clamp(ray_dir.xy,vec2(0.),vec2(1.));vec2 correction=abs(ray_dir.xy-clamp_end);correction=(step(0.01,correction)*correction/(abs(clamp_end-ray_origin.xy)+0.01))+1.;correction.x=1./min(max(correction.y,correction.x),10.);ray_dir=ray_dir-ray_origin;ray_dir.xyw*=correction.x;float iStepCount=1./float(_STEP_COUNT);tolerance*=0.125;_traceRay(ray_origin,ray_dir,tolerance,state,_STEP_COUNT,iStepCount);if(_STEP_COUNT>8&&state.z>0.98)_traceRay(ray_origin,ray_dir,tolerance,state,_STEP_COUNT-8,iStepCount);if(_STEP_COUNT>15&&state.z>0.98)_traceRay(ray_origin,ray_dir,tolerance,state,_STEP_COUNT-16,iStepCount);if(_STEP_COUNT>23&&state.z>0.98)_traceRay(ray_origin,ray_dir,tolerance,state,_STEP_COUNT-16,iStepCount);sample_uv=ray_origin+ray_dir*state.z;sample_uv.z/=sample_uv.w;state.z=state.z<0.999?state.z:9999999.;return sample_uv.xyz;}\n#endif\n", tl = "#ifndef BASIC_HELPERS\n#define BASIC_HELPERS \nfloat saturate2(float v,float mx){return max(0.,min(mx,v));}vec3 saturate2(vec3 v){return max(vec3(0.),min(vec3(1.),v));}\n#endif\n", nl = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  class rl extends dt {
    get ssgiEnabled() {
      return parseInt(this.material.defines.SSGI_ENABLED) > 0.5;
    }
    set ssgiEnabled(e2) {
      e2 = e2 && this._giActivated, this.material.defines.SSGI_ENABLED = e2 ? 1 : 0, this.material.needsUpdate = true;
    }
    constructor(e2, r2, i2, s2 = false) {
      super({ vertexShader: lo, fragmentShader: `

${tl}
${Za}
${co}
${$a}
${i2}

${el}

varying vec2 vUv;uniform float frameCount2;uniform float intensity;uniform float objectRadius;uniform float rayCount;uniform float power;uniform float bias;uniform float falloff;uniform float tolerance;uniform bool autoRadius;uniform vec2 screenSize;vec3 ComputeUniformL(vec3 N,vec2 E){vec3 L;L.xy=E;L.z=interleavedGradientNoise(gl_FragCoord.xy,frameCount2*5.);L=L*2.-1.;return L;}vec2 GetRandomE(float seed){vec2 rand_e;rand_e.x=random3(vec3(gl_FragCoord.xy,frameCount2+seed));rand_e.y=random3(vec3(gl_FragCoord.yx,rand_e.x+(frameCount2)*7.));return rand_e;}vec4 calculateGI(in float seed,in vec3 screenPos,in vec3 normal,in float radiusFactor){vec3 viewPos=screenToView(screenPos.xy,screenPos.z);normal=normalize(normal);vec2 E=GetRandomE(seed);vec3 L=ComputeUniformL(normal,E);L=normalize(L);L*=sign(dot(L,normal));float cameraDist=length(cameraPositionWorld);float rayLen=autoRadius?length(viewPos-screenToView(screenPos.xy+objectRadius/10.,screenPos.z)):mix((cameraNearFar.y)+viewPos.z,-viewPos.z-cameraNearFar.x,L.z*0.5+0.5)*objectRadius;rayLen*=radiusFactor;float r=interleavedGradientNoise(gl_FragCoord.xy,frameCount2*14.+seed)+0.05;rayLen=max(rayLen,0.001);vec3 state=vec3(1.,(r+0.5)/float(RTAO_STEP_COUNT),2.);viewPos+=normal*max(-0.01*viewPos.z,0.001);vec3 screenHitP=traceRay(viewPos,L*rayLen,tolerance*rayLen,state,RTAO_STEP_COUNT);vec3 viewHitP=screenToView(screenHitP.xy,screenHitP.z);vec3 LRes=viewHitP-viewPos;if(state.z>1.)LRes=vec3(9999999.);float dist=length(LRes)*falloff;float EPS=0.01;float zBias=(viewPos.z)*bias;float ao=(max(dot(normal,L)+zBias,0.))/(dist*dist+EPS);
#if defined(SSGI_ENABLED) && SSGI_ENABLED > 0
vec3 hitColor=tLastFrameTexelToLinear(texture2D(tLastFrame,screenHitP.xy)).rgb;vec3 hitNormal=getViewNormal(screenHitP.xy);float giWeight=1.;giWeight=saturate2(giWeight/(dist+EPS),1.);giWeight*=saturate2((dot(normal,L)),1.);giWeight*=saturate2((dot(hitNormal,-L)),1.);return vec4(hitColor*giWeight,ao);
#endif
return vec4(0,0,0,ao);}float normpdf(in float x,in float sigma){return exp(-0.5*x*x/(sigma*sigma));}vec4 getLastThis(sampler2D tex,float depth,vec3 normal){vec2 direction=vec2(1,1);vec4 color=clamp(tLastThisTexelToLinear(texture2D(tex,vUv.xy)),0.,5.);return color;}void main(){float depth;vec3 normal;getDepthNormal(vUv,depth,normal);if(depth>0.99){discard;gl_FragColor=getLastThis(tLastThis,depth,normal);return;}float viewZ=depthToViewZ(depth);vec3 screenPos=vec3(vUv.x,vUv.y,viewZ);vec4 gi=vec4(0.);gi+=calculateGI(8.,screenPos,normal,1.);if(rayCount>1.5)gi=max(gi,calculateGI(2.,screenPos,normal,0.4));if(rayCount>2.5)gi=max(gi,calculateGI(3.,screenPos,normal,1.5));if(rayCount>3.5)gi=max(gi,calculateGI(1.,screenPos,normal,0.6));if(rayCount>4.5)gi=max(gi,calculateGI(3.,screenPos,normal,1.));gi.a=min(1.,gi.a);gi.a=max(0.,gi.a);gi.rgb=min(vec3(3.),gi.rgb);gi.rgb=max(vec3(0.),gi.rgb);if(frameCount2<3.){gl_FragColor=gi;return;}gl_FragColor=(texture2D(tLastThis,vUv));gl_FragColor=((gi+(gl_FragColor)*frameCount2)/(frameCount2+1.));}

            `, uniforms: { tLastThis: { value: null }, tDiffuse: { value: null }, tNormalDepth: { value: null }, tLastFrame: { value: null }, opacity: { value: 1 }, intensity: { value: 2.14 }, rayCount: { value: 0.1 }, objectRadius: { value: 1 }, autoRadius: { value: !s2 }, power: { value: 1.1 }, bias: { value: 0.015 }, falloff: { value: 0.7 }, tolerance: { value: 1.5 }, frameCount: { value: 0 }, frameCount2: { value: 0 }, projection: { value: new n.yGw() }, screenSize: { value: new n.FM8() }, cameraPositionWorld: { value: new n.Pa4() }, cameraNearFar: { value: new n.FM8(0.1, 1e3) } }, defines: { PERSPECTIVE_CAMERA: 1, SSGI_ENABLED: s2 ? 1 : 0 } }, "tDiffuse", "tLastFrame", "tLastThis"), this.materialExtension = { shaderExtender: (e3, t2, n2) => {
        var r3;
        if (!e3.defines.SSRTAO_ENABLED)
          return;
        this.materialExtension.extraUniforms.tSSGIMap.value = null === (r3 = this._target) || void 0 === r3 ? void 0 : r3.texture;
        const i3 = t2.materialObject;
        let s3 = this.material.defines.SSGI_ENABLED;
        i3.defines.SSGI_ENABLED !== s3 && (i3.defines.SSGI_ENABLED = s3, i3.needsUpdate = true), s3 = this._target.texture, this.materialExtension.extraUniforms.tSSGIMap.value !== s3 && (this.materialExtension.extraUniforms.tSSGIMap.value = s3, i3.needsUpdate = true);
        const o2 = "vec3 totalDiffuse =";
        e3.fragmentShader = e3.fragmentShader.replace(o2, `

            
            #if defined(SSRTAO_ENABLED) && SSRTAO_ENABLED > 0
vec4 ssgi=tSSGIMapTexelToLinear(texture2D(tSSGIMap,viewToScreen(vViewPosition.xyz).xy));float ambientOcclusion=1.-ssgi.a;ambientOcclusion=max(0.,ambientOcclusion);ambientOcclusion=pow(ambientOcclusion,ssaoPower);ambientOcclusion=min(1.,ambientOcclusion);reflectedLight.indirectDiffuse*=ambientOcclusion;
#if defined(SSGI_ENABLED) && SSGI_ENABLED > 0
vec3 ssgiColor=ssgi.rgb*ssgiIntensity;reflectedLight.indirectDiffuse+=ssgiColor*(material.diffuseColor.rgb);
#endif
#if defined( USE_ENVMAP )
float dotNV=saturate(dot(geometry.normal,geometry.viewDir));float specularOcclusion=saturate(pow(dotNV+ambientOcclusion,exp2(-16.*material.roughness-1.))-1.+ambientOcclusion);reflectedLight.indirectSpecular*=specularOcclusion;
#if defined(SSGI_ENABLED) && SSGI_ENABLED > 0
#if !defined(SSR_ENABLED) || SSR_ENABLED < 1
reflectedLight.indirectSpecular+=ssgiColor*material.specularColor;
#endif
#endif
#endif
#endif

            
            // reflectedLight.directDiffuse = vec3(0.);
            // reflectedLight.indirectDiffuse = vec3(0.);
            // reflectedLight.directSpecular = vec3(0.);
            // reflectedLight.indirectSpecular = vec3(0.);
            
            
${o2}`), e3.fragmentShader = e3.fragmentShader.replace("#include <aomap_fragment>", ""), e3.defines.USE_UV = "";
      }, onObjectRender: (e3, t2, n2) => {
        var r3, i3, s3;
        const o2 = t2.materialObject, a2 = !o2.transparent && o2.transmission < 1e-3, l2 = this.enabled && a2 && (this.renderWithCamera || this._renderer.frameCount > 1) && false !== n2.userData.screenSpaceRendering && !(null === (r3 = o2.userData) || void 0 === r3 ? void 0 : r3.ssrtaoDisabled) && !(null === (i3 = o2.userData) || void 0 === i3 ? void 0 : i3.ssaoDisabled) && !(null === (s3 = o2.userData) || void 0 === s3 ? void 0 : s3.pluginsDisabled) ? 1 : 0;
        o2.defines.SSRTAO_ENABLED !== l2 && (o2.defines.SSRTAO_ENABLED = l2, o2.needsUpdate = true);
      }, parsFragmentSnippet: (e3) => {
        var n2;
        return t.glsl`
            uniform float ssaoPower;
            uniform float ssgiIntensity;
            uniform sampler2D tSSGIMap;
            ${L("tSSGIMap", null === (n2 = this._target) || void 0 === n2 ? void 0 : n2.texture, e3.capabilities.isWebGL2)}

            ${uo}

        `;
      }, extraUniforms: { tSSGIMap: { value: null }, ssaoPower: this.material.uniforms.power, ssgiIntensity: this.material.uniforms.intensity }, computeCacheKey: (e3) => {
        var t2, n2, r3, i3;
        return this.enabled ? "1" : "0" + (null === (n2 = null === (t2 = this._target) || void 0 === t2 ? void 0 : t2.texture) || void 0 === n2 ? void 0 : n2.colorSpace) + (null === (i3 = null === (r3 = this._target) || void 0 === r3 ? void 0 : r3.texture) || void 0 === i3 ? void 0 : i3.uuid) + this.material.defines.SSGI_ENABLED;
      }, isCompatible: (e3) => {
        var t2;
        return !(null === (t2 = e3.materialObject.userData) || void 0 === t2 ? void 0 : t2.ssaoDisabled) && e3.isMeshStandardMaterial2;
      } }, this.intensity = 2, this.power = 1.1, this.autoRadius = true, this.objectRadius = 2, this.tolerance = 1, this.bias = 0.15, this.falloff = 0.7, this.rayCount = 2, this.stepCount = 4, this.smoothEnabled = true, this.renderWithCamera = true, this.uiConfig = { type: "folder", label: "SS Global illumination (Dev)", children: [...He(this), { type: "checkbox", label: "GI Enabled", hidden: () => !this._giActivated, property: [this, "ssgiEnabled"] }] }, this._renderer = e2, this._target = r2, this.needsSwap = true, this._giActivated = s2, this.ssgiEnabled = s2, this.bilateralPass = new ao(this._target, i2, "rgba");
    }
    render(e2, t2, n2, r2, i2) {
      this.needsSwap = false, !this.renderWithCamera && this._renderer.frameCount < 2 || (this._renderer.blit(this._target.texture, t2), this.uniforms.tLastThis.value = t2.texture, super.render(e2, this._target, n2, r2, i2), this.smoothEnabled && this.bilateralPass.render(e2, t2, n2, r2, i2));
    }
  }
  nl([ie()], rl.prototype, "bilateralPass", void 0), nl([Ue("Intensity", [0, 4]), ie(), j()], rl.prototype, "intensity", void 0), nl([Ue("Power", [0, 3]), ie(), j()], rl.prototype, "power", void 0), nl([Oe("Auto radius"), ie(), j()], rl.prototype, "autoRadius", void 0), nl([Ue("Object Radius", [0.01, 10]), ie(), j()], rl.prototype, "objectRadius", void 0), nl([Ue("Tolerance", [0.1, 5]), ie(), j()], rl.prototype, "tolerance", void 0), nl([Ue("Bias", [-0.3, 0.3]), ie(), j()], rl.prototype, "bias", void 0), nl([Ue("Falloff", [1e-4, 4]), ie(), j()], rl.prototype, "falloff", void 0), nl([Ue("Ray Count", [1, 5], 1), ie(), j()], rl.prototype, "rayCount", void 0), nl([Ue("Step count", [1, 16], 1), ie(), z("RTAO_STEP_COUNT")], rl.prototype, "stepCount", void 0), nl([Oe("Smooth Enabled"), ie()], rl.prototype, "smoothEnabled", void 0), nl([Oe("Render with Camera")], rl.prototype, "renderWithCamera", void 0);
  class il extends so {
    get rtgiTarget() {
      return this._rtgiTarget;
    }
    constructor(e2 = true) {
      super(), this.dependencies = [Ls, wt, To], this._initEnabled = false, this.setDirty = this.setDirty.bind(this), this._initEnabled = e2;
    }
    async onAdded(e2) {
      var t2, n2;
      await super.onAdded(e2), this.enabled = this._initEnabled, null === (n2 = (t2 = this.uiConfig).uiRefresh) || void 0 === n2 || n2.call(t2, "postFrame", true);
    }
    get enabled() {
      var e2, t2;
      return (null === (t2 = null === (e2 = this.passes.ssrtgi) || void 0 === e2 ? void 0 : e2.passObject) || void 0 === t2 ? void 0 : t2.enabled) || false;
    }
    set enabled(e2) {
      var t2;
      (null === (t2 = this.passes.ssrtgi) || void 0 === t2 ? void 0 : t2.passObject) && (this.passes.ssrtgi.passObject.enabled = e2);
    }
    createPasses(e2) {
      var t2, n2, r2;
      return this._rtgiTarget = e2.renderer.createTarget({ sizeMultiplier: 1 }), null === (t2 = this._viewer) || void 0 === t2 || t2.getPluginByType("debug"), [vt(e2, { passId: "ssrtgi", after: ["gbuffer"], before: ["render"], required: ["render", "gbuffer", "progressive"], passObject: new rl(e2.renderer, this._rtgiTarget, null !== (r2 = null === (n2 = e2.getPlugin(wt)) || void 0 === n2 ? void 0 : n2.getUnpackSnippet()) && void 0 !== r2 ? r2 : "", true), update: () => {
        var t3;
        const n3 = this.enabled;
        if (n3) {
          const e3 = null === (t3 = this._viewer) || void 0 === t3 ? void 0 : t3.getPluginByType("SSAO");
          (null == e3 ? void 0 : e3.enabled) && (e3.enabled = false);
        }
        n3 && this.passes.ssrtgi.passObject.bilateralPass.updateShaderProperties([e2.getPlugin(wt)]);
      } }, () => [e2.getPlugin(wt), e2.getPlugin(To), e2.scene.activeCamera, e2.renderer])];
    }
    async onRemove(e2) {
      return e2.renderer.disposeTarget(this._rtgiTarget), super.onRemove(e2);
    }
    setDirty() {
      var e2;
      null === (e2 = this._viewer) || void 0 === e2 || e2.setDirty();
    }
    get uiConfig() {
      var e2, n2, r2, i2, s2;
      const o2 = null !== (r2 = null === (n2 = null === (e2 = this.passes.ssrtgi) || void 0 === e2 ? void 0 : e2.passObject) || void 0 === n2 ? void 0 : n2.uiConfig) && void 0 !== r2 ? r2 : {};
      return null === (s2 = null === (i2 = o2.children) || void 0 === i2 ? void 0 : i2.map((e3) => (0, t.getOrCall)(e3))) || void 0 === s2 || s2.flat(2).forEach((e3) => e3 && (e3.onChange = this.setDirty)), o2;
    }
  }
  il.PluginType = "SSGI";
  let sl = class extends ht {
    constructor(e2, t2, r2) {
      super(e2, t2, null != r2 ? r2 : new ol(), new n.Ilk(0, 0, 0), 1), this.enabled = true, this._firstCall = true;
    }
    render(e2, t2, n2, r2, i2) {
      this.enabled && super.render(e2, t2, n2, r2, i2);
    }
  };
  sl = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  }([We("High Precision Normal Buffer")], sl);
  class ol extends n.RSm {
    constructor() {
      super();
    }
    onBeforeRender(e2, t2, r2, i2, s2) {
      var o2, a2, l2;
      let c2 = s2.material;
      Array.isArray(c2) && (c2 = c2[0]), this.normalMap = null !== (o2 = null == c2 ? void 0 : c2.normalMap) && void 0 !== o2 ? o2 : null, this.bumpMap = null !== (a2 = null == c2 ? void 0 : c2.bumpMap) && void 0 !== a2 ? a2 : null, this.bumpScale = null == c2 ? void 0 : c2.bumpScale, (null == c2 ? void 0 : c2.normalScale) && this.normalScale.copy(null == c2 ? void 0 : c2.normalScale), this.needsUpdate = true, this.side = null !== (l2 = c2.side) && void 0 !== l2 ? l2 : n.ehD;
    }
  }
  class al extends yt {
    passCtor(e2) {
      this._normalTarget = e2.renderer.createTarget({ depthBuffer: true, type: n.cLu, minFilter: n.TyD, magFilter: n.TyD, generateMipmaps: false }), this._normalTarget.texture.name = "normalBuffer", this._normalTarget.texture.generateMipmaps = false;
      const t2 = this._normalTarget, r2 = /* @__PURE__ */ new Set(), i2 = /* @__PURE__ */ new Set();
      return new class extends sl {
        render(e3, n2, s2, o2, a2) {
          const l2 = e3.getRenderTarget(), c2 = e3.getActiveCubeFace(), u2 = e3.getActiveMipmapLevel();
          this.scene && (this.scene.traverse(({ material: e4 }) => {
            e4 && ((e4.transparent && e4.userData.renderToDepth || !e4.transparent && 0 === e4.transmission && false === e4.userData.renderToDepth) && (r2.add(e4), e4.transparent = !e4.transparent), Math.abs(e4.transmission || 0) > 0 && e4.userData.renderToDepth && (i2.add([e4, e4.transmission]), e4.transmission = 0));
          }), H(e3, { shadowMapRender: false, backgroundRender: false, opaqueRender: true, transparentRender: false, transmissionRender: false, mainRenderPass: false }, () => super.render(e3, n2, t2, o2, a2)), r2.forEach((e4) => e4.transparent = !e4.transparent), r2.clear(), i2.forEach(([e4, t3]) => e4.transmission = t3), i2.clear(), e3.setRenderTarget(l2, c2, u2));
        }
      }();
    }
    _update(e2) {
      if (!super._update(e2))
        return false;
      const t2 = this.pass.passObject;
      return t2.scene = e2.scene.modelObject, t2.camera = e2.scene.activeCamera.cameraObject, true;
    }
    constructor(e2 = true) {
      super(), this.passId = "normalBuffer", this._beforeFilters = ["render"], this._afterFilters = [], this._requiredFilters = ["render"], this.enabled = e2;
    }
    getNormalBuffer() {
      return this._normalTarget;
    }
    async onDispose(e2) {
    }
    async onRemove(e2) {
      var t2, n2;
      return e2.renderer.disposeTarget(null === (n2 = null === (t2 = this._normalTarget) || void 0 === t2 ? void 0 : t2.dispose) || void 0 === n2 ? void 0 : n2.call(t2)), super.onRemove(e2);
    }
    updateShaderProperties(e2) {
      var t2, n2;
      return e2.uniforms.tNormalBuffer ? e2.uniforms.tNormalBuffer.value = this.enabled && null !== (n2 = null === (t2 = this.getNormalBuffer()) || void 0 === t2 ? void 0 : t2.texture) && void 0 !== n2 ? n2 : null : console.warn("BaseRenderer: no uniform: tNormalBuffer"), this;
    }
    get uiConfig() {
      var e2;
      return null === (e2 = this.pass) || void 0 === e2 ? void 0 : e2.passObject.uiConfig;
    }
  }
  al.PluginType = "NormalBufferPlugin";
  var ll = function(e2, t2) {
    return ll = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
      e3.__proto__ = t3;
    } || function(e3, t3) {
      for (var n2 in t3)
        Object.prototype.hasOwnProperty.call(t3, n2) && (e3[n2] = t3[n2]);
    }, ll(e2, t2);
  };
  function cl(e2, t2) {
    if ("function" != typeof t2 && null !== t2)
      throw new TypeError("Class extends value " + String(t2) + " is not a constructor or null");
    function n2() {
      this.constructor = e2;
    }
    ll(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (n2.prototype = t2.prototype, new n2());
  }
  var ul, pl = function() {
    function e2() {
    }
    return e2._xfnv1a = function(e3) {
      for (var t2 = 2166136261, n2 = 0; n2 < e3.length; n2++)
        t2 = Math.imul(t2 ^ e3.charCodeAt(n2), 16777619);
      return function() {
        return t2 += t2 << 13, t2 ^= t2 >>> 7, t2 += t2 << 3, t2 ^= t2 >>> 17, (t2 += t2 << 5) >>> 0;
      };
    }, e2;
  }(), dl = function(e2) {
    function t2(n2) {
      var r2 = e2.call(this) || this;
      return r2.a = t2._xfnv1a(n2)(), r2;
    }
    return cl(t2, e2), t2.prototype.next = function() {
      var e3 = this.a += 1831565813;
      return e3 = Math.imul(e3 ^ e3 >>> 15, 1 | e3), (((e3 ^= e3 + Math.imul(e3 ^ e3 >>> 7, 61 | e3)) ^ e3 >>> 14) >>> 0) / 4294967296;
    }, t2;
  }(pl), hl = function(e2) {
    function t2(n2) {
      var r2 = e2.call(this) || this, i2 = t2._xfnv1a(n2);
      return r2.a = i2(), r2.b = i2(), r2.c = i2(), r2.d = i2(), r2;
    }
    return cl(t2, e2), t2.prototype.next = function() {
      this.a >>>= 0, this.b >>>= 0, this.c >>>= 0, this.d >>>= 0;
      var e3 = this.a + this.b | 0;
      return this.a = this.b ^ this.b >>> 9, this.b = this.c + (this.c << 3) | 0, this.c = this.c << 21 | this.c >>> 11, this.d = this.d + 1 | 0, e3 = e3 + this.d | 0, this.c = this.c + e3 | 0, (e3 >>> 0) / 4294967296;
    }, t2;
  }(pl), fl = function(e2) {
    function t2(n2) {
      var r2 = e2.call(this) || this, i2 = t2._xfnv1a(n2);
      return r2.a = i2(), r2.b = i2(), r2.c = i2(), r2.d = i2(), r2;
    }
    return cl(t2, e2), t2.prototype.next = function() {
      var e3 = this.b << 9, t3 = 5 * this.a;
      return t3 = t3 << 7 | 9 * (t3 >>> 25), this.c ^= this.a, this.d ^= this.b, this.b ^= this.c, this.a ^= this.d, this.c ^= e3, this.d = this.d << 11 | this.d >>> 21, (t3 >>> 0) / 4294967296;
    }, t2;
  }(pl);
  !function(e2) {
    e2.sfc32 = "sfc32", e2.mulberry32 = "mulberry32", e2.xoshiro128ss = "xoshiro128ss";
  }(ul || (ul = {}));
  var ml = function() {
    function e2(e3, t2) {
      void 0 === t2 && (t2 = ul.sfc32), this.str = e3, this.prng = t2, this.generator = this._initializeGenerator();
    }
    return e2.prototype.next = function() {
      return this.generator.next();
    }, e2.prototype._initializeGenerator = function() {
      if (function(e4) {
        return null === e4;
      }(e3 = this.str) || function(e4) {
        return void 0 === e4;
      }(e3))
        return this.wrap();
      var e3;
      switch (this.prng) {
        case "sfc32":
          return new hl(this.str);
        case "mulberry32":
          return new dl(this.str);
        case "xoshiro128ss":
          return new fl(this.str);
        default:
          return this.wrap();
      }
    }, e2.prototype.wrap = function() {
      return { next: function() {
        return Math.random();
      } };
    }, e2;
  }(), _l = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  class gl extends sr {
    constructor(e2, t2, r2, i2) {
      super(e2, t2), this._shadowParams = { enabled: true, radius: 2, width: 1024, height: 1024, bias: -1e-3, normalBias: 0, near: 1.5, far: 4, frustumSize: 4 }, this._randomParams = { focus: 1, spread: 0.01, distanceScale: 50, minDistanceScale: new n.Pa4(10, 10, 10), normalDirection: new n.Pa4(0.01, 0.98, 0.01).normalize(), direction: new n.Pa4(-0.9, 0.5, -1) }, this.isRandomizedDirectionalLight = true, this.shadowParams = null != r2 ? r2 : {}, this.randomParams = null != i2 ? i2 : {}, this.updateShadowParams = this.updateShadowParams.bind(this);
    }
    get shadowParams() {
      return this._shadowParams;
    }
    set shadowParams(e2) {
      Object.keys(e2).forEach((t2) => void 0 === e2[t2] && delete e2[t2]), this._shadowParams = { ...this._shadowParams, ...e2 }, this.updateShadowParams();
    }
    get randomParams() {
      return this._randomParams;
    }
    set randomParams(e2) {
      Object.keys(e2).forEach((t2) => void 0 === e2[t2] && delete e2[t2]), Object.assign(this._randomParams, e2);
    }
    updateShadowParams() {
      this.castShadow = this._shadowParams.enabled, this.shadow.mapSize.x = this._shadowParams.width, this.shadow.mapSize.y = this._shadowParams.height, this.shadow.bias = this._shadowParams.bias, this.shadow.normalBias = this._shadowParams.normalBias, this.refreshShadowCamNearFar(), this.shadow.radius = this._shadowParams.radius, this.shadow.camera.right = this._shadowParams.frustumSize / 2, this.shadow.camera.left = -this._shadowParams.frustumSize / 2, this.shadow.camera.top = this._shadowParams.frustumSize / 2, this.shadow.camera.bottom = -this._shadowParams.frustumSize / 2, this.shadow.camera.updateProjectionMatrix(), this.matrixWorldNeedsUpdate = true;
    }
    randomizePosition(e2, t2 = null, r2 = null) {
      const i2 = new ml(e2.toString()), s2 = new n.FM8(i2.next() * Math.PI * 2, Math.asin(2 * i2.next() - 1));
      let o2 = new n.Pa4(Math.cos(s2.x) * Math.cos(s2.y), Math.sin(s2.y), Math.sin(s2.x) * Math.cos(s2.y));
      const a2 = new n.FM8();
      for (let e3 = 0; e3 < 5; e3++) {
        a2.set(i2.next(), i2.next()), o2 = vl(a2, this._randomParams.normalDirection, 0.4), i2.next() < Math.sqrt(null != t2 ? t2 : this._randomParams.focus) && (a2.set(i2.next(), i2.next()), o2 = vl(a2, this._randomParams.direction, Math.pow((null != r2 ? r2 : this._randomParams.spread) / 2, 2)));
        const e4 = o2.dot(this._randomParams.normalDirection);
        if (e4 > 0 && e4 < 0.4)
          break;
      }
      o2.normalize(), o2.multiplyScalar(this._randomParams.distanceScale), this.position.set(0, 0, 0), this.target.position.copy(o2.normalize().negate()), this.target.updateMatrixWorld(), this.refreshShadowCamNearFar(), this.updateMatrixWorld();
    }
    refreshShadowCamNearFar() {
      const e2 = new n.Pa4().subVectors(this.target.position, this.shadow.camera.position).length();
      this.shadow.camera.near = e2 - this._shadowParams.near * this._shadowParams.frustumSize / 2, this.shadow.camera.far = e2 + this._shadowParams.far * this._shadowParams.frustumSize / 2;
    }
    dispose() {
    }
    get uiConfig() {
      if (this._uiConfig)
        return this._uiConfig;
    }
    fromJSON(e2, t2) {
      return super.fromJSON(e2, t2) ? (this.updateShadowParams(), this) : null;
    }
  }
  function vl(e2, t2, r2) {
    t2 = t2.clone().normalize();
    const i2 = new n.Pa4(0, -t2.z, t2.y).normalize(), s2 = new n.Pa4().crossVectors(t2, i2).normalize(), o2 = e2;
    o2.x = 2 * o2.x * Math.PI, o2.y = 1 - o2.y * r2;
    const a2 = Math.sqrt(1 - o2.y * o2.y);
    return i2.multiplyScalar(Math.cos(o2.x) * a2).add(s2.multiplyScalar(Math.sin(o2.x) * a2)).add(t2.multiplyScalar(o2.y));
  }
  _l([ie("shadowParams")], gl.prototype, "_shadowParams", void 0), _l([ie("randomParams")], gl.prototype, "_randomParams", void 0);
  var yl = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  class bl extends gt {
    get cameraHelper() {
      return this._cameraHelper;
    }
    constructor(e2 = true) {
      super(), this.enabled = true, this.light = new gl("#cceeff", 1), this.lightLayers = 1, this._preRender = () => {
        var e3, t2, n2;
        if (!this.enabled)
          return void (this.light.layers.mask = 0);
        const r2 = null !== (t2 = null === (e3 = this._viewer) || void 0 === e3 ? void 0 : e3.renderer.frameCount) && void 0 !== t2 ? t2 : 0;
        this.light.randomizePosition(r2 < 5 ? 0 : r2), this.light.layers.mask = this.lightLayers, this.light.updateShadowParams(), null === (n2 = this._cameraHelper) || void 0 === n2 || n2.update();
      }, this._setDirty = this._setDirty.bind(this), this.enabled = e2;
    }
    async onAdded(e2) {
      await super.onAdded(e2), this._cameraHelper = new n.Rki(this.light.shadow.camera), this._cameraHelper.visible = false, this._cameraHelper.userData.bboxVisible = false, e2.scene.add(this._cameraHelper), e2.scene.addLight(this.light, { addToRoot: true }), e2.addEventListener("preRender", this._preRender);
    }
    async onRemove(e2) {
      return e2.removeEventListener("preRender", this._preRender), this.light.removeFromParent(), super.onRemove(e2);
    }
    _setDirty(e2 = false) {
      var t2, n2;
      e2 ? null === (t2 = this._viewer) || void 0 === t2 || t2.scene.setDirty() : null === (n2 = this._viewer) || void 0 === n2 || n2.setDirty();
    }
    get uiConfig() {
      return this._uiConfig ? this._uiConfig : this._uiConfig = { type: "folder", label: "Progressive Shadow", children: [{ type: "checkbox", label: "Enabled", property: [this, "enabled"], onChange: this._setDirty }, { type: "folder", label: "Directional Light", children: [{ type: "checkbox", label: "Visible", property: [this.light, "visible"], onChange: this._setDirty }, { type: "slider", label: "Intensity", bounds: [0, 10], property: [this.light, "intensity"], onChange: this._setDirty }, { type: "color", label: "Color", property: [this.light, "color"], onChange: this._setDirty }, { type: "checkbox", label: "Shadow Enabled", property: [this.light.shadowParams, "enabled"], onChange: [this.light.updateShadowParams, this._setDirty] }, { type: "slider", bounds: [0, 1], property: [this.light.randomParams, "focus"], onChange: this._setDirty }, { type: "slider", bounds: [0, 1], property: [this.light.randomParams, "spread"], onChange: this._setDirty }, { type: "slider", bounds: [0.01, 60], property: [this.light.randomParams, "distanceScale"], onChange: this._setDirty }, { type: "vec3", bounds: [-5, 5], property: [this.light.randomParams, "direction"], onChange: this._setDirty }, { type: "slider", bounds: [0.01, 10], property: [this.light.shadowParams, "radius"], onChange: [this.light.updateShadowParams, this._setDirty] }, { type: "slider", bounds: [0.01, 30], property: [this.light.shadowParams, "frustumSize"], onChange: [this.light.updateShadowParams, this._setDirty] }, { type: "slider", bounds: [-0.01, 0.01], property: [this.light.shadowParams, "bias"], onChange: [this.light.updateShadowParams, this._setDirty] }, { type: "slider", bounds: [-0.05, 0.05], property: [this.light.shadowParams, "normalBias"], onChange: [this.light.updateShadowParams, this._setDirty] }] }] };
    }
  }
  bl.PluginType = "RandomizedDirectionalLight", yl([ie()], bl.prototype, "enabled", void 0), yl([ie("rdLight")], bl.prototype, "light", void 0), yl([ie()], bl.prototype, "lightLayers", void 0);
  var wl = "uniform float objectRadius;uniform float radius;uniform float tolerance;uniform bool autoRadius;\n#ifndef D_sceneBoundingRadius\n#define D_sceneBoundingRadius \nuniform float sceneBoundingRadius;\n#endif\nvec3 ComputeReflectionL(vec3 N,vec2 E,vec3 V,float rough){float rough4=rough*rough*rough*rough;float phi=2.*PI*E.x;float cos_theta=pow(max(E.y,0.000001),rough4/(2.-rough4));float sin_theta=sqrt(max(0.,1.-cos_theta*cos_theta));vec3 half_vec=vec3(sin_theta*cos(phi),sin_theta*sin(phi),cos_theta);vec3 tangentX=normalize(cross(abs(N.z)<0.999?vec3(0.,0.,1.):vec3(1.,0.,0.),N));vec3 tangentY=cross(N,tangentX);half_vec=half_vec.x*tangentX+half_vec.y*tangentY+half_vec.z*N;vec3 ray_dir=(2.*dot(V,half_vec))*half_vec-V;return ray_dir;}vec2 GetRandomE(float seed){vec2 rand_e;rand_e.x=interleavedGradientNoise(gl_FragCoord.xy,frameCount*117.);rand_e.y=fract(rand_e.x*38.65435);rand_e.y=mix(rand_e.y,1.,0.7);return rand_e;}vec4 calculateSSR(in float seed,in vec3 screenPos,in vec3 normal,in float radiusFactor,in float roughness){vec3 viewPos=screenToView(screenPos.xy,screenPos.z);normal=normalize(normal);vec2 E=GetRandomE(seed);vec3 L=ComputeReflectionL(normal,E,-normalize(viewPos),roughness);L=normalize(L);float cameraDist=length(cameraPositionWorld);float rayLen=autoRadius?mix((cameraDist+objectRadius*sceneBoundingRadius)+viewPos.z,-viewPos.z-max(0.,cameraDist-objectRadius*sceneBoundingRadius),L.z*0.5+0.5):objectRadius*sceneBoundingRadius;rayLen*=radiusFactor;float r=interleavedGradientNoise(gl_FragCoord.xy,frameCount+seed);rayLen=max(rayLen,0.001);int steps=SSR_STEP_COUNT/(frameCount<float(SSR_LOW_QUALITY_FRAMES)?2:1);vec3 state=vec3(0.,(r+0.5)/float(steps),2.);viewPos+=normal*max(-0.0001*viewPos.z,0.001);vec3 screenHitP=traceRay(viewPos,L*rayLen,tolerance*rayLen,state,steps);if(state.z<0.99){vec3 hitColor=(tLastFrameTexelToLinear(texture2D(tLastFrame,screenHitP.xy))).rgb;float ssrWeight=1.;return vec4(hitColor*ssrWeight,1.);}return vec4(0.);}", Al = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let xl = class extends dt {
    constructor(e2, t2, r2, i2 = true) {
      super({ vertexShader: lo, fragmentShader: `

varying vec2 vUv;

${tl}
${Za}
${co}
${$a}
${r2}

${el}

${wl}

uniform sampler2D tLastThis;void main(){vec4 texel=tDiffuseTexelToLinear(texture2D(tDiffuse,vUv));vec4 lastAO=tLastThisTexelToLinear(texture2D(tLastThis,vUv));float depth;vec3 normal;getDepthNormal(vUv,depth,normal);if(depth>=0.999){discard;}float viewZ=depthToViewZ(depth);vec3 screenPos=vec3(vUv.x,vUv.y,viewZ);vec3 viewPos=screenToView(screenPos.xy,screenPos.z);viewPos.z=viewZ/viewPos.z;vec4 ao=vec4(0.);ao+=calculateSSR(8.,screenPos,normal,1.,0.1);ao.rgb=min(vec3(3.),ao.rgb);ao.rgb=max(vec3(0.),ao.rgb);if(frameCount<1.){gl_FragColor=ao;return;}if(ao.a<0.01){gl_FragColor.rgb=lastAO.rgb;gl_FragColor.a=(((lastAO.a)*frameCount)/(frameCount+1.));}else{gl_FragColor=((ao+(lastAO)*frameCount)/(frameCount+1.));}
#include <encodings_fragment>
}


            `, uniforms: { tLastThis: { value: null }, tDiffuse: { value: null }, tNormalDepth: { value: null }, tLastFrame: { value: null }, opacity: { value: 1 }, intensity: { value: 0 }, boost: { value: new n.Pa4(0, 0, 0) }, objectRadius: { value: 0 }, autoRadius: { value: false }, power: { value: 0 }, maskFrontFactor: { value: -0.1 }, tolerance: { value: 0 }, frameCount: { value: 0 }, projection: { value: new n.yGw() }, cameraPositionWorld: { value: new n.Pa4() }, cameraNearFar: { value: new n.FM8(0.1, 1e3) }, sceneBoundingRadius: { value: 0 } }, defines: { PERSPECTIVE_CAMERA: 1, SSR_STEP_COUNT: 16, SSR_LOW_QUALITY_FRAMES: 2, SSR_MASK_FRONT_RAYS: true, SSR_INLINE: i2 ? "1" : "0", SSR_NON_PHYSICAL: "0" } }, "tDiffuse", "tLastThis", "tLastFrame"), this.uiConfig = void 0, this.materialExtension = { shaderExtender: (e3, t3, n2) => {
        var r3, i3, s2, o2, a2;
        let l2 = !this.enabled || false === n2.userData.screenSpaceRendering || (null === (r3 = t3.materialObject.userData) || void 0 === r3 ? void 0 : r3.pluginsDisabled) || (null === (i3 = t3.materialObject.userData) || void 0 === i3 ? void 0 : i3.ssreflDisabled) ? 0 : 1;
        if (t3.materialObject.defines.SSR_ENABLED !== l2 && (t3.materialObject.defines.SSR_ENABLED = l2, t3.materialObject.needsUpdate = true), !e3.defines.SSR_ENABLED)
          return;
        l2 = this.material.defines.SSR_STEP_COUNT, t3.materialObject.defines.SSR_STEP_COUNT !== l2 && (t3.materialObject.defines.SSR_STEP_COUNT = l2, t3.materialObject.needsUpdate = true), l2 = this.material.defines.SSR_LOW_QUALITY_FRAMES, t3.materialObject.defines.SSR_LOW_QUALITY_FRAMES !== l2 && (t3.materialObject.defines.SSR_LOW_QUALITY_FRAMES = l2, t3.materialObject.needsUpdate = true), l2 = this.material.defines.PERSPECTIVE_CAMERA, t3.materialObject.defines.PERSPECTIVE_CAMERA !== l2 && (t3.materialObject.defines.PERSPECTIVE_CAMERA = l2, t3.materialObject.needsUpdate = true), l2 = this.material.defines.SSR_INLINE, t3.materialObject.defines.SSR_INLINE !== l2 && (t3.materialObject.defines.SSR_INLINE = l2, t3.materialObject.needsUpdate = true), l2 = this.material.defines.SSR_MASK_FRONT_RAYS ? 1 : 0, t3.materialObject.defines.SSR_MASK_FRONT_RAYS !== l2 && (t3.materialObject.defines.SSR_MASK_FRONT_RAYS = l2, t3.materialObject.needsUpdate = true), l2 = (null === (s2 = t3.materialObject.userData) || void 0 === s2 ? void 0 : s2.ssreflNonPhysical) ? "1" : "0", t3.materialObject.defines.SSR_NON_PHYSICAL !== l2 && (t3.materialObject.defines.SSR_NON_PHYSICAL = l2, t3.materialObject.needsUpdate = true), l2 = null !== (a2 = null === (o2 = this._target) || void 0 === o2 ? void 0 : o2.texture) && void 0 !== a2 ? a2 : null, this.materialExtension.extraUniforms.tSSRMap.value !== l2 && (this.materialExtension.extraUniforms.tSSRMap.value = l2, t3.materialObject.needsUpdate = true);
        const c2 = "#glMarker beforeModulation";
        e3.fragmentShader = e3.fragmentShader.replace(c2, `

            
            #if defined(SSR_ENABLED) && SSR_ENABLED > 0
vec3 screenPos=viewToScreen(geometry.position);vec4 ssrColor=vec4(0,0,0,0);float alphaModifier=1.-clamp(material.roughness*.3,0.,1.);alphaModifier*=ssrIntensity;
#if defined(SSR_MASK_FRONT_RAYS) && SSR_MASK_FRONT_RAYS > 0
alphaModifier*=clamp(-4.*dot(geometry.viewDir,normal)+(4.+ssrMaskFrontFactor),0.,1.);
#endif
#ifdef USE_TRANSMISSION
alphaModifier*=1.-transmission;
#endif
float vignette=1.;if(true){float fadeStrength=0.1;float dist=min(min(1.-screenPos.x,1.-screenPos.y),min(screenPos.x,screenPos.y));float fade=dist*dist/(fadeStrength+0.001);fade=clamp(fade,0.,1.);fade=pow(fade,0.3);vignette=fade;}alphaModifier*=vignette;vec3 specularColor=EnvironmentBRDF(geometry.normal,geometry.viewDir,material.specularColor.rgb,material.specularF90,material.roughness);if(length(specularColor.rgb)*alphaModifier>0.01&&roughnessFactor<0.9){
#if defined(SSR_INLINE) && SSR_INLINE > 0
ssrColor=calculateSSR(8.,vec3(screenPos.xy,geometry.position.z),geometry.normal,1.,material.roughness);
#else
ssrColor=tSSRMapTexelToLinear(texture2D(tSSRMap,screenPos.xy));
#endif 
}ssrColor.rgb*=ssrBoost;ssrColor.a*=alphaModifier;ssrColor.a=min(ssrColor.a,1.);
#if defined(SSR_NON_PHYSICAL) && SSR_NON_PHYSICAL > 0
diffuseColor.a=max(ssrColor.a,diffuseColor.a*diffuseColor.a);reflectedLight.indirectSpecular=mix(reflectedLight.indirectSpecular,saturate(diffuseColor.rgb*ssrColor.rgb),1.);reflectedLight.indirectDiffuse=diffuseColor.rgb*(1.-ssrColor.a);reflectedLight.directDiffuse=vec3(0.);reflectedLight.directSpecular=vec3(0.);
#else
reflectedLight.indirectSpecular=mix(reflectedLight.indirectSpecular,saturate(specularColor.rgb*ssrColor.rgb),ssrColor.a);
#endif
#endif

            
            // reflectedLight.directDiffuse = vec3(0.);
            // reflectedLight.indirectDiffuse = vec3(0.);
            // reflectedLight.directSpecular = vec3(0.);
            // reflectedLight.indirectSpecular = vec3(0.);
            
            
${c2}`);
      }, onObjectRender: (e3, t3, n2) => {
        var r3, i3;
        const s2 = !this.enabled || false === n2.userData.screenSpaceRendering || (null === (r3 = t3.materialObject.userData) || void 0 === r3 ? void 0 : r3.pluginsDisabled) || (null === (i3 = t3.materialObject.userData) || void 0 === i3 ? void 0 : i3.ssreflDisabled) ? 0 : 1;
        t3.materialObject.defines.SSR_ENABLED !== s2 && (t3.materialObject.defines.SSR_ENABLED = s2, t3.materialObject.needsUpdate = true);
      }, parsFragmentSnippet: (e3, t3) => {
        var n2, r3, i3;
        return !this.enabled || false === e3.userData.screenSpaceRendering || (null === (n2 = null == t3 ? void 0 : t3.materialObject.userData) || void 0 === n2 ? void 0 : n2.ssreflDisabled) || (null === (r3 = null == t3 ? void 0 : t3.materialObject.userData) || void 0 === r3 ? void 0 : r3.pluginsDisabled) ? "" : "\nuniform float ssrPower;\nuniform float ssrIntensity;\nuniform float ssrMaskFrontFactor;\nuniform vec3 ssrBoost;\nuniform sampler2D tSSRMap;\nuniform sampler2D tLastFrame;\n" + L("tSSRMap", null === (i3 = this._target) || void 0 === i3 ? void 0 : i3.texture, e3.capabilities.isWebGL2) + L("tLastFrame", this.materialExtension.extraUniforms.tLastFrame.value, e3.capabilities.isWebGL2) + (this._inline ? `
#if 1
// #if SSR_INLINE
    ${tl}
    
    #define THREE_PACKING_INCLUDED
    ${Za}
    
    ${co}
    ${$a}
    ${_t}
    
    ${el}
    
    ${wl}
// #endif // SSR_INLINE
#endif
` : "") + `
${uo}
        `;
      }, extraUniforms: { tSSRMap: { value: null }, ssrPower: this.material.uniforms.power, ssrIntensity: this.material.uniforms.intensity, ssrMaskFrontFactor: this.material.uniforms.maskFrontFactor, ssrBoost: this.material.uniforms.boost, tNormalDepth: this.material.uniforms.tNormalDepth, tLastFrame: this.material.uniforms.tLastFrame, objectRadius: this.material.uniforms.objectRadius, autoRadius: this.material.uniforms.autoRadius, tolerance: this.material.uniforms.tolerance, frameCount: this.material.uniforms.frameCount, projection: this.material.uniforms.projection, cameraPositionWorld: this.material.uniforms.cameraPositionWorld, cameraNearFar: this.material.uniforms.cameraNearFar, sceneBoundingRadius: this.material.uniforms.sceneBoundingRadius }, computeCacheKey: (e3) => {
        var t3, n2, r3;
        return this.enabled ? "1" : "0" + (null === (n2 = null === (t3 = this._target) || void 0 === t3 ? void 0 : t3.texture) || void 0 === n2 ? void 0 : n2.colorSpace) + (this.enabled && !(null === (r3 = e3.materialObject.userData) || void 0 === r3 ? void 0 : r3.ssreflDisabled) ? 1 : 0) + Object.values(this.material.defines).map((e4) => e4 + "").join(",");
      }, isCompatible: (e3) => {
        var t3;
        return !(null === (t3 = e3.materialObject.userData) || void 0 === t3 ? void 0 : t3.ssreflDisabled) && e3.isMeshStandardMaterial2;
      } }, this.intensity = 1, this.boost = new n.Pa4(1, 1, 1), this.objectRadius = 1, this.autoRadius = true, this.power = 1.1, this.tolerance = 0.5, this.stepCount = 16, this.lowQualityFrames = 0, this.maskFrontRays = true, this.maskFrontFactor = -0.2, this._renderer = e2, this._target = t2, this.needsSwap = false, this._inline = i2;
    }
    render(e2, t2, n2, r2, i2) {
      if (this._inline)
        this.needsSwap = false;
      else {
        if (!this._target)
          throw "Target must be set when inline = false";
        this._renderer.blit(this._target.texture, t2, {}), this.uniforms.tLastThis.value = t2.texture, super.render(e2, this._target, n2, r2, i2), this.needsSwap = false;
      }
    }
  };
  Al([Ue("Intensity", [0, 4]), ie(), j()], xl.prototype, "intensity", void 0), Al([Fe("Boost"), ie(), j()], xl.prototype, "boost", void 0), Al([Ue("Object Radius", [0.01, 2]), ie(), j()], xl.prototype, "objectRadius", void 0), Al([Oe("Auto radius"), ie(), j()], xl.prototype, "autoRadius", void 0), Al([Ue("Power", [0, 3]), ie(), j()], xl.prototype, "power", void 0), Al([Ue("Tolerance", [0.1, 5]), ie(), j()], xl.prototype, "tolerance", void 0), Al([Ue("Step count", [1, 32], 1), ie(), z("SSR_STEP_COUNT")], xl.prototype, "stepCount", void 0), Al([Ue("Low Quality Frames", [0, 4], 1), ie(), z("SSR_LOW_QUALITY_FRAMES")], xl.prototype, "lowQualityFrames", void 0), Al([Oe("Ignore front rays"), ie(), z("SSR_MASK_FRONT_RAYS")], xl.prototype, "maskFrontRays", void 0), Al([Ue("Mask front rays factor", [-1, 1], 0.01, (e2) => ({ hidden: () => !e2.maskFrontRays })), ie(), j()], xl.prototype, "maskFrontFactor", void 0), xl = Al([We("Screen Space Reflections")], xl);
  class El extends so {
    get ssrTarget() {
      return this._ssrTarget;
    }
    constructor() {
      super(), this.dependencies = [Ls, wt, To], this.inlineSSR = true, this.setDirty = this.setDirty.bind(this);
    }
    get enabled() {
      var e2, t2;
      return (null === (t2 = null === (e2 = this.passes.ssr) || void 0 === e2 ? void 0 : e2.passObject) || void 0 === t2 ? void 0 : t2.enabled) || false;
    }
    set enabled(e2) {
      var t2;
      (null === (t2 = this.passes.ssr) || void 0 === t2 ? void 0 : t2.passObject) && (this.passes.ssr.passObject.enabled = e2);
    }
    async onAdded(e2) {
      var t2, n2;
      e2.getPluginByType("Ground") && console.error("GroundPlugin must be added after SSRPlugin"), await super.onAdded(e2), null === (n2 = (t2 = this.uiConfig).uiRefresh) || void 0 === n2 || n2.call(t2, "postFrame", true);
    }
    createPasses(e2) {
      var t2, n2;
      return this._ssrTarget = this.inlineSSR ? void 0 : e2.renderer.createTarget({ sizeMultiplier: 1 }), [vt(e2, { passId: "ssr", after: ["gbuffer"], before: ["render"], required: ["render", "gbuffer", "progressive"], passObject: new xl(e2.renderer, this._ssrTarget, null !== (n2 = null === (t2 = e2.getPlugin(wt)) || void 0 === t2 ? void 0 : t2.getUnpackSnippet()) && void 0 !== n2 ? n2 : "", this.inlineSSR) }, () => [e2.getPlugin(wt), e2.getPlugin(To), e2.scene.activeCamera, e2.renderer, e2.scene])];
    }
    async onRemove(e2) {
      return this._ssrTarget && e2.renderer.disposeTarget(this._ssrTarget), super.onRemove(e2);
    }
    setDirty() {
      var e2;
      null === (e2 = this._viewer) || void 0 === e2 || e2.setDirty();
    }
    get uiConfig() {
      var e2, n2, r2, i2, s2;
      const o2 = null !== (r2 = null === (n2 = null === (e2 = this.passes.ssr) || void 0 === e2 ? void 0 : e2.passObject) || void 0 === n2 ? void 0 : n2.uiConfig) && void 0 !== r2 ? r2 : {};
      return null === (s2 = null === (i2 = o2.children) || void 0 === i2 ? void 0 : i2.map((e3) => (0, t.getOrCall)(e3))) || void 0 === s2 || s2.flat(2).forEach((e3) => e3 && (e3.onChange = this.setDirty)), o2;
    }
  }
  El.PluginType = "SSReflection";
  var Cl = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let Sl = class extends gt {
    makeAnisotropic(e2) {
      var t2;
      const n2 = null === (t2 = e2.materialObject) || void 0 === t2 ? void 0 : t2.userData;
      if (!n2)
        return false;
      if (void 0 === n2._isAnisotropic) {
        const e3 = n2.__appliedMeshes;
        let t3 = true;
        if (e3)
          for (const { geometry: n3 } of e3)
            !n3 || n3.index && n3.attributes.position && n3.attributes.normal && n3.attributes.uv || (t3 = false), t3 && !n3.attributes.tangent && n3.computeTangents();
        if (!t3)
          return false;
      }
      return n2._isAnisotropic = true, void 0 === n2._anisotropyFactor && (n2._anisotropyFactor = 1), void 0 === n2._anisotropyNoise && (n2._anisotropyNoise = 0), void 0 === n2._anisotropyDirectionMode && (n2._anisotropyDirectionMode = "DIRECTION"), e2.materialObject.needsUpdate = true, true;
    }
    _loaderCreate({ loader: e2 }) {
      e2.isGLTFLoader2 && e2.register((e3) => new Ml(e3));
    }
    constructor() {
      super(), this.enabled = true, this.dependencies = [Ls], this._defines = { ANISOTROPY_DEBUG: false }, this._uniforms = { anisotropyFactor: { value: 1 }, anisotropyNoise: { value: 1 }, anisotropyDirection: { value: 1 }, anisotropyDirectionMap: { value: null }, frameCount: { value: 0 } }, this.materialExtension = { shaderExtender: (e2, r2, i2) => {
        var s2;
        if (!this.enabled || !r2.materialObject.userData._isAnisotropic)
          return;
        const o2 = null === (s2 = r2.materialObject.userData) || void 0 === s2 ? void 0 : s2._anisotropyDirectionMap, a2 = t.glsl`
                //#if ANISOTROPY_ENABLED
                ${co}
                ${"uniform float anisotropyFactor;uniform float anisotropyNoise;\n#if ANISOTROPY_TEX_MODE == 0\nuniform float anisotropyDirection;\n#else\nuniform sampler2D anisotropyDirectionMap;\n#endif\nconst float MIN_ROUGHNESS=0.05;float D_GGX_Anisotropy(float at,float ab,float ToH,float BoH,float NoH){float a2=at*ab;highp vec3 d=vec3(ab*ToH,at*BoH,a2*NoH);highp float d2=dot(d,d);float b2=a2/d2;return a2*b2*b2*(1./PI);}float V_GGX_SmithCorrelated_Anisotropy(float at,float ab,float ToV,float BoV,float ToL,float BoL,float NoV,float NoL){float lambdaV=NoL*length(vec3(at*ToV,ab*BoV,NoV));float lambdaL=NoV*length(vec3(at*ToL,ab*BoL,NoL));float v=0.5/(lambdaV+lambdaL);return saturate(v);}vec3 indirectAnisotropyBentNormal(const in vec3 normal,const in vec3 viewDir,const in float roughness,const in vec3 anisotropicT,const in vec3 anisotropicB){vec3 aDirection=anisotropyFactor>=0.?anisotropicB:anisotropicT;vec3 aTangent=cross(aDirection,viewDir);vec3 aNormal=cross(aTangent,aDirection);float bendFactor=abs(anisotropyFactor)*saturate(5.*max(roughness,MIN_ROUGHNESS));return normalize(mix(normal,aNormal,bendFactor));}vec3 BRDF_GGX_Anisotropy(const in vec3 lightDir,const in vec3 viewDir,const in vec3 normal,const in vec3 f0,const in float f90,const in float roughness,const in vec3 anisotropicT,const in vec3 anisotropicB){float alpha=pow2(roughness);vec3 halfDir=normalize(lightDir+viewDir);float dotNL=saturate(dot(normal,lightDir));float dotNV=saturate(dot(normal,viewDir));float dotNH=saturate(dot(normal,halfDir));float dotVH=saturate(dot(viewDir,halfDir));float dotTV=dot(anisotropicT,viewDir);float dotBV=dot(anisotropicB,viewDir);float dotTL=dot(anisotropicT,lightDir);float dotBL=dot(anisotropicB,lightDir);float dotTH=dot(anisotropicT,halfDir);float dotBH=dot(anisotropicB,halfDir);float aspect=sqrt(1.-min(1.-MIN_ROUGHNESS,abs(anisotropyFactor)*0.9));if(anisotropyFactor>0.)aspect=1./aspect;float at=roughness*aspect;float ab=roughness/aspect;vec3 F=F_Schlick(f0,f90,dotVH);float V=V_GGX_SmithCorrelated_Anisotropy(at,ab,dotTV,dotBV,dotTL,dotBL,dotNV,dotNL);float D=D_GGX_Anisotropy(at,ab,dotTH,dotBH,dotNH);return F*(V*D);}"}
            ` + (o2 ? L("anisotropyDirectionMap", o2, i2.capabilities.isWebGL2) : "") + "\n";
        e2.fragmentShader = ot(e2.fragmentShader, "#include <common>", a2, { append: true }), e2.fragmentShader = e2.fragmentShader.replace("#include <lights_fragment_begin>", n.WdD.lights_fragment_begin), e2.fragmentShader = ot(ot(e2.fragmentShader, "IncidentLight directLight;", "float rnd=(random2(vUv.xy,frameCount)-0.5)*anisotropyNoise*material.roughness;\n#if ANISOTROPY_TEX_MODE < 2\n#if ANISOTROPY_TEX_MODE == 0 \nfloat rot=saturate(anisotropyDirection);\n#else \nfloat rot=(anisotropyDirectionMapTexelToLinear(texture2D(anisotropyDirectionMap,vUv)).r);\n#endif\nrot=rot*2.*PI+rnd;vec2 rot2=vec2(sin(rot),cos(rot));\n#else \nvec2 rot2=(anisotropyDirectionMapTexelToLinear(texture2D(anisotropyDirectionMap,vUv)).rg*2.-1.)+vec2(rnd,rnd);rot2=normalize(rot2);const float anisoSpecMultiplier=0.25;float matSpecAniso=(length(material.specularColor.rgb))*2.*PI;rot2=mix(rot2,vec2(sin(matSpecAniso),cos(matSpecAniso)),anisoSpecMultiplier);rot2=normalize(rot2);\n#endif\nvec3 anisotropicT=(tbn[0]*rot2.x+tbn[1]*rot2.y);anisotropicT=normalize(anisotropicT-normal*dot(anisotropicT,normal));vec3 anisotropicB=normalize(cross(normal,anisotropicT));", { prepend: true }), "RE_Direct( directLight, geometry, material, reflectedLight )", "RE_Direct( directLight, geometry, material, reflectedLight, anisotropicT, anisotropicB )", { replaceAll: true });
        let l2 = ot(n.WdD.lights_physical_pars_fragment, "void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {", "void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight, const in vec3 anisotropicT, const in vec3 anisotropicB ) {");
        l2 = ot(l2, "BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material )", "BRDF_GGX_Anisotropy( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness, anisotropicT, anisotropicB )"), e2.fragmentShader = ot(e2.fragmentShader, "#include <lights_physical_pars_fragment>", l2), e2.fragmentShader = ot(e2.fragmentShader, "#include <normal_fragment_begin>", n.WdD.normal_fragment_begin), e2.fragmentShader = ot(e2.fragmentShader, "#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )", "#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) || defined( USE_TANGENT )");
        let c2 = t.glsl`
                #if defined( USE_ENVMAP )
                vec3 anisotropyBentNormal = indirectAnisotropyBentNormal(geometry.normal, geometry.viewDir, material.roughness, anisotropicT, anisotropicB);
                #endif
            ` + n.WdD.lights_fragment_maps;
        c2 = ot(c2, "getIBLIrradiance( geometry.normal )", "getIBLIrradiance( anisotropyBentNormal )"), c2 = ot(c2, "getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness )", "getIBLRadiance( geometry.viewDir, anisotropyBentNormal, material.roughness )"), e2.fragmentShader = ot(e2.fragmentShader, "#include <lights_fragment_maps>", c2), e2.defines.USE_UV = "", e2.vertexTangents = true;
      }, onObjectRender: (e2, t2) => {
        var n2;
        const r2 = t2.materialObject.userData;
        if (!(null == r2 ? void 0 : r2._isAnisotropic))
          return;
        const i2 = e2;
        if (!i2.isMesh || !i2.geometry)
          return;
        if (!i2.geometry.attributes.tangent)
          throw new Error("No tangents on the geometry");
        this._uniforms.anisotropyFactor.value = r2._anisotropyFactor, this._uniforms.anisotropyNoise.value = r2._anisotropyNoise, this._uniforms.anisotropyDirectionMap.value = (null === (n2 = r2._anisotropyDirectionMap) || void 0 === n2 ? void 0 : n2.isTexture) ? r2._anisotropyDirectionMap : null, this._uniforms.anisotropyDirection.value = r2._anisotropyDirection;
        let s2 = this.enabled ? 1 : 0;
        t2.materialObject.defines.ANISOTROPY_ENABLED !== s2 && (t2.materialObject.defines.ANISOTROPY_ENABLED = s2, t2.materialObject.needsUpdate = true), s2 = +this._defines.ANISOTROPY_DEBUG, t2.materialObject.defines.ANISOTROPY_DEBUG !== s2 && (t2.materialObject.defines.ANISOTROPY_DEBUG = s2, t2.materialObject.needsUpdate = true), s2 = r2._anisotropyDirectionMode, this._uniforms.anisotropyDirectionMap.value || (s2 = "CONSTANT"), s2 = "DIRECTION" === s2 ? 2 : "ROTATION" === s2 ? 1 : 0, t2.materialObject.defines.ANISOTROPY_TEX_MODE !== s2 && (t2.materialObject.defines.ANISOTROPY_TEX_MODE = s2, t2.materialObject.needsUpdate = true);
      }, extraUniforms: { ...this._uniforms }, computeCacheKey: (e2) => {
        var t2, n2, r2;
        return (this.enabled ? "1" : "0") + ((null === (t2 = e2.materialObject.userData) || void 0 === t2 ? void 0 : t2._isAnisotropic) ? "1" : "0") + (null === (r2 = null === (n2 = e2.materialObject.userData) || void 0 === n2 ? void 0 : n2._anisotropyDirectionMap) || void 0 === r2 ? void 0 : r2.uuid);
      }, isCompatible: (e2) => e2.isMeshStandardMaterial2, updaters: () => {
        var e2;
        return [null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.renderer];
      }, getUiConfig: (e2) => {
        const t2 = this._viewer, n2 = this.makeAnisotropic, r2 = { type: "folder", label: "Anisotropy", children: [{ type: "checkbox", label: "Enabled", get value() {
          return e2.materialObject.userData._isAnisotropic || false;
        }, set value(i2) {
          var s2;
          i2 !== e2.materialObject.userData._isAnisotropic && (i2 ? n2(e2) || t2.alert("One or more geometries cannot be made anisotropic.") : (e2.materialObject.userData._isAnisotropic = false, e2.materialObject.needsUpdate = true), null === (s2 = r2.uiRefresh) || void 0 === s2 || s2.call(r2, "postFrame", true));
        }, onChange: this.setDirty }, { type: "slider", label: "Factor", bounds: [-2, 2], hidden: () => !e2.materialObject.userData._isAnisotropic, property: [e2.materialObject.userData, "_anisotropyFactor"], onChange: this.setDirty }, { type: "slider", label: "Noise", bounds: [0, 2], hidden: () => !e2.materialObject.userData._isAnisotropic, property: [e2.materialObject.userData, "_anisotropyNoise"], onChange: this.setDirty }, { type: "image", label: "Texture", hidden: () => !e2.materialObject.userData._isAnisotropic, property: [e2.materialObject.userData, "_anisotropyDirectionMap"], onChange: () => {
          e2.materialObject.needsUpdate = true, this.setDirty();
        } }, { type: "dropdown", label: "Mode", hidden: () => !e2.materialObject.userData._isAnisotropic, property: [e2.materialObject.userData, "_anisotropyDirectionMode"], children: ["CONSTANT", "ROTATION", "DIRECTION"].map((e3) => ({ label: e3 })), onChange: () => {
          e2.materialObject.needsUpdate = true, this.setDirty();
        } }] };
        return r2;
      } }, this.setDirty = () => {
        var e2, t2, n2;
        null === (t2 = (e2 = this.materialExtension).setDirty) || void 0 === t2 || t2.call(e2), null === (n2 = this._viewer) || void 0 === n2 || n2.setDirty();
      }, this.makeSelectedAnisotropic = () => {
        var e2, t2, n2;
        const r2 = null === (n2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPlugin(za)) || void 0 === t2 ? void 0 : t2.getSelectedObject()) || void 0 === n2 ? void 0 : n2.material;
        return "material" === (null == r2 ? void 0 : r2.assetType) && this.makeAnisotropic(r2);
      }, this._loaderCreate = this._loaderCreate.bind(this);
    }
    async onAdded(e2) {
      var t2, n2, r2, i2, s2;
      await super.onAdded(e2);
      const o2 = e2.getPlugin(Ls);
      null === (t2 = null == o2 ? void 0 : o2.materials) || void 0 === t2 || t2.registerMaterialExtension(this.materialExtension), null === (n2 = null == o2 ? void 0 : o2.importer) || void 0 === n2 || n2.addEventListener("loaderCreate", this._loaderCreate), null === (s2 = null === (i2 = null === (r2 = null == o2 ? void 0 : o2.exporter) || void 0 === r2 ? void 0 : r2.getExporter("gltf", "glb")) || void 0 === i2 ? void 0 : i2.extensions) || void 0 === s2 || s2.push(Tl);
    }
    async onRemove(e2) {
      var t2, n2, r2, i2;
      return null === (n2 = null === (t2 = e2.getPlugin(Ls)) || void 0 === t2 ? void 0 : t2.materials) || void 0 === n2 || n2.unregisterMaterialExtension(this.materialExtension), null === (i2 = null === (r2 = e2.getPlugin(Ls)) || void 0 === r2 ? void 0 : r2.importer) || void 0 === i2 || i2.removeEventListener("loaderCreate", this._loaderCreate), super.onRemove(e2);
    }
  };
  Sl.PluginType = "AnisotropyPlugin", Sl.ANISOTROPY_GLTF_EXTENSION = "WEBGI_materials_anisotropy", Cl([Oe("Enabled", (e2) => ({ onChange: e2.setDirty })), ie()], Sl.prototype, "enabled", void 0), Cl([je("Make Anisotropy", (e2) => ({ hidden: () => {
    var t2;
    return !(null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(za));
  } }))], Sl.prototype, "makeSelectedAnisotropic", void 0), Sl = Cl([We("Anisotropy Materials")], Sl);
  class Ml {
    constructor(e2) {
      this.parser = e2, this.name = Sl.ANISOTROPY_GLTF_EXTENSION;
    }
    async extendMaterialParams(e2, t2) {
      var r2, i2, s2;
      const o2 = this.parser, a2 = o2.json.materials[e2];
      if (!a2.extensions || !a2.extensions[this.name])
        return Promise.resolve();
      const l2 = [], c2 = a2.extensions[this.name];
      t2.userData || (t2.userData = {}), t2.userData._isAnisotropic = true, t2.userData._anisotropyFactor = null !== (r2 = c2.anisotropyFactor) && void 0 !== r2 ? r2 : 0, t2.userData._anisotropyNoise = null !== (s2 = null !== (i2 = c2.anisotropyNoiseFactor) && void 0 !== i2 ? i2 : c2.anisotropyNoise) && void 0 !== s2 ? s2 : 0;
      let { anisotropyDirectionMode: u2, anisotropyDirection: p2 } = c2;
      return u2 || (u2 = c2.anisotropyTextureMode), p2 || (p2 = c2.anisotropyRotation), t2.userData._anisotropyDirectionMode = u2 && "number" == typeof (null == p2 ? void 0 : p2.index) ? u2 : "CONSTANT", "ROTATION" === u2 || "DIRECTION" === u2 ? l2.push(o2.assignTexture(t2.userData, "_anisotropyDirectionMap", p2).then((e3) => {
        e3.colorSpace = n.KI_;
      })) : t2.userData._anisotropyDirection = null != p2 ? p2 : 0, Promise.all(l2);
    }
    afterRoot(e2) {
      var t2;
      return null === (t2 = e2.scene) || void 0 === t2 || t2.traverse((e3) => {
        var t3, n2;
        if (!(null === (n2 = null === (t3 = e3.material) || void 0 === t3 ? void 0 : t3.userData) || void 0 === n2 ? void 0 : n2._isAnisotropic))
          return;
        const r2 = e3.geometry;
        r2.attributes.tangent || (r2.computeTangents(), r2.attributes.tangent.needsUpdate = true);
      }), null;
    }
  }
  const Tl = (e2) => ({ writeMaterial: (t2, n2) => {
    if (!t2.isMeshStandardMaterial || !t2.userData._isAnisotropic)
      return;
    if ((t2.userData._anisotropyFactor || 0) < 1e-3)
      return;
    n2.extensions = n2.extensions || {};
    const r2 = {};
    if (r2.anisotropyFactor = t2.userData._anisotropyFactor || 1, r2.anisotropyNoiseFactor = t2.userData._anisotropyNoise || 0, r2.anisotropyDirectionMode = t2.userData._anisotropyDirectionMode || "CONSTANT", t2.userData._anisotropyDirectionMap && "CONSTANT" !== r2.anisotropyDirectionMode) {
      const n3 = { index: e2.processTexture(t2.userData._anisotropyDirectionMap) };
      e2.applyTextureTransform(n3, t2.userData._anisotropyDirectionMap), r2.anisotropyDirection = n3;
    } else
      r2.anisotropyDirectionMode = "CONSTANT", r2.anisotropyDirection = t2.userData._anisotropyDirection || 0;
    n2.extensions[Sl.ANISOTROPY_GLTF_EXTENSION] = r2, e2.extensionsUsed[Sl.ANISOTROPY_GLTF_EXTENSION] = true;
  } });
  var Pl, Il = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let Rl = Pl = class extends gt {
    static AddFragmentClipping(e2, t2, n2, r2, i2) {
      var s2, o2, a2;
      const l2 = null === (s2 = e2.materialObject) || void 0 === s2 ? void 0 : s2.userData;
      if (!l2)
        return false;
      l2._fragmentClippingExt || (l2._fragmentClippingExt = {});
      const c2 = l2._fragmentClippingExt;
      return c2.clipEnabled = true, void 0 === c2.clipPosition && (c2.clipPosition = null !== (o2 = null == t2 ? void 0 : t2.toArray()) && void 0 !== o2 ? o2 : [0, 0, 0, 0]), void 0 === c2.clipParams && (c2.clipParams = null !== (a2 = null == n2 ? void 0 : n2.toArray()) && void 0 !== a2 ? a2 : [1, 0, 0, 0]), void 0 === c2.clipMode && (c2.clipMode = null != r2 ? r2 : kl.Circle), void 0 === c2.clipInvert && (c2.clipInvert = null != i2 && i2), e2.materialObject.isMaterial && (e2.needsUpdate = true), true;
    }
    _loaderCreate({ loader: e2 }) {
      e2.isGLTFLoader2 && e2.register((e3) => new Dl(e3));
    }
    constructor() {
      super(), this.enabled = true, this.dependencies = [Ls, wt], this._plane = new n.JOQ(), this._viewNormalMatrix = new n.Vkp(), this._defines = { FRAG_CLIPPING_DEBUG: false }, this._uniforms = { fragClippingPosition: { value: new n.Ltg() }, fragClippingParams: { value: new n.Ltg() }, fragClippingCamAspect: { value: 1 } }, this.materialExtension = { parsFragmentSnippet: (e2, n2) => {
        var r2;
        return this.enabled && (null === (r2 = null == n2 ? void 0 : n2.materialObject.userData._fragmentClippingExt) || void 0 === r2 ? void 0 : r2.clipEnabled) ? uo + t.glsl`
uniform vec4 fragClippingPosition;
uniform vec4 fragClippingParams;
uniform float fragClippingCamAspect;
#if FRAG_CLIPPING_MODE == ${kl.Circle}
float fragClippingCircle(){
    vec2 pos = viewToScreen(vViewPosition.xyz).xy;
    float radius = fragClippingParams.x;
    vec2 center = fragClippingPosition.xy;
    pos.y /= fragClippingCamAspect;
    center.y /= fragClippingCamAspect;
    return length(pos - center) - radius;
}
#elif FRAG_CLIPPING_MODE == ${kl.Ellipse}
float fragClippingEllipse(){
    vec2 pos = viewToScreen(vViewPosition.xyz).xy;
    vec2 radius = fragClippingParams.xy;
    vec2 center = fragClippingPosition.xy;
    pos.y /= fragClippingCamAspect;
    center.y /= fragClippingCamAspect;
    return length((pos - center) / radius) - 1.0;
}
#elif FRAG_CLIPPING_MODE == ${kl.Rectangle}
float fragClippingRectangle(){
    vec2 pos = viewToScreen(vViewPosition.xyz).xy;
    vec2 radius = fragClippingParams.xy;
    vec2 center = fragClippingPosition.xy;
    pos.y /= fragClippingCamAspect;
    center.y /= fragClippingCamAspect;
    vec2 d = abs(pos - center) - radius;
    return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}
#elif FRAG_CLIPPING_MODE == ${kl.Plane}
float fragClippingPlane(){
    vec3 pos = vViewPosition.xyz;
    vec3 normal = fragClippingParams.xyz;
    float d = dot(pos, normal) - fragClippingParams.w;
    return d;
}
#elif FRAG_CLIPPING_MODE == ${kl.Sphere}
float fragClippingSphere(){
    vec3 pos = vViewPosition.xyz;
    vec3 center = fragClippingPosition.xyz;
    float radius = fragClippingParams.x;
    pos.y /= fragClippingCamAspect;
    center.y /= fragClippingCamAspect;
    return length(pos - center) - radius;
}
#endif
        ` : "";
      }, shaderExtender: (e2, n2, r2) => {
        var i2;
        this.enabled && (null === (i2 = n2.materialObject.userData._fragmentClippingExt) || void 0 === i2 ? void 0 : i2.clipEnabled) && (e2.fragmentShader = ot(e2.fragmentShader, "#glMarker mainStart", t.glsl`
    float fragClippingDist = 0.0;
    #if FRAG_CLIPPING_MODE == ${kl.Circle}
    fragClippingDist = fragClippingCircle();
    #elif FRAG_CLIPPING_MODE == ${kl.Ellipse}
    fragClippingDist = fragClippingEllipse();
    #elif FRAG_CLIPPING_MODE == ${kl.Rectangle}
    fragClippingDist = fragClippingRectangle();
    #elif FRAG_CLIPPING_MODE == ${kl.Plane}
    fragClippingDist = fragClippingPlane();
    #elif FRAG_CLIPPING_MODE == ${kl.Sphere}
    fragClippingDist = fragClippingSphere();
    #endif
    #if FRAG_CLIPPING_DEBUG
    gl_FragColor = vec4(max(fragClippingDist, 0.0), 0.0, 0.0, 1.0); 
//    gl_FragColor = vec4(vViewPosition.xyz, 1.0);
    #include <encodings_fragment>
    return;
    #endif
    
    #if FRAG_CLIPPING_INVERSE == 1
    if (fragClippingDist > 0.0) discard;
    #else
    if (fragClippingDist < 0.0) discard;
    #endif
            `, { append: true }));
      }, onObjectRender: (e2, t2) => {
        var r2, i2, s2, o2, a2, l2;
        let c2 = null === (r2 = t2.materialObject.userData) || void 0 === r2 ? void 0 : r2._fragmentClippingExt;
        if (t2.materialObject.userData.isGBufferMaterial && e2 && (c2 = null === (s2 = null === (i2 = e2.material) || void 0 === i2 ? void 0 : i2.userData) || void 0 === s2 ? void 0 : s2._fragmentClippingExt), !(null == c2 ? void 0 : c2.clipEnabled))
          return;
        if (this._uniforms.fragClippingPosition.value.fromArray(c2.clipPosition), c2.clipMode === kl.Plane) {
          const e3 = null === (o2 = this._viewer) || void 0 === o2 ? void 0 : o2.scene.activeCamera.cameraObject.matrixWorldInverse;
          this._plane.normal.set(c2.clipParams[0], c2.clipParams[1], c2.clipParams[2]), this._plane.constant = c2.clipParams[3], this._viewNormalMatrix.getNormalMatrix(e3), this._plane.applyMatrix4(e3, this._viewNormalMatrix), this._uniforms.fragClippingParams.value.set(this._plane.normal.x, this._plane.normal.y, this._plane.normal.z, this._plane.constant);
        } else
          this._uniforms.fragClippingParams.value.fromArray(c2.clipParams);
        (null === (a2 = this._viewer) || void 0 === a2 ? void 0 : a2.scene.activeCamera.cameraObject) instanceof n.cPb ? this._uniforms.fragClippingCamAspect.value = null === (l2 = this._viewer) || void 0 === l2 ? void 0 : l2.scene.activeCamera.cameraObject.aspect : this._uniforms.fragClippingCamAspect.value = 1;
        let u2 = this.enabled ? 1 : 0;
        u2 = +this._defines.FRAG_CLIPPING_DEBUG, t2.materialObject.defines.FRAG_CLIPPING_DEBUG !== u2 && (t2.materialObject.defines.FRAG_CLIPPING_DEBUG = u2, t2.materialObject.needsUpdate = true), u2 = +c2.clipMode, t2.materialObject.defines.FRAG_CLIPPING_MODE !== u2 && (t2.materialObject.defines.FRAG_CLIPPING_MODE = u2, t2.materialObject.needsUpdate = true), u2 = +c2.clipInvert, t2.materialObject.defines.FRAG_CLIPPING_INVERSE !== u2 && (t2.materialObject.defines.FRAG_CLIPPING_INVERSE = u2, t2.materialObject.needsUpdate = true);
      }, extraUniforms: { ...this._uniforms }, computeCacheKey: (e2) => {
        var t2, n2;
        return (this.enabled ? "1" : "0") + ((null === (n2 = null === (t2 = e2.materialObject.userData) || void 0 === t2 ? void 0 : t2._fragmentClippingExt) || void 0 === n2 ? void 0 : n2.clipEnabled) ? "1" : "0");
      }, isCompatible: (e2) => e2.isMeshStandardMaterial2 || e2.userData.isGBufferMaterial, updaters: () => [], getUiConfig: (e2) => {
        const t2 = this._viewer, n2 = { type: "folder", label: "FragmentClipping", children: [{ type: "checkbox", label: "Enabled", getValue: () => {
          var t3;
          return (null === (t3 = e2.materialObject.userData._fragmentClippingExt) || void 0 === t3 ? void 0 : t3.clipEnabled) || false;
        }, setValue: (r2) => {
          var i2, s2;
          r2 !== (null === (i2 = e2.materialObject.userData._fragmentClippingExt) || void 0 === i2 ? void 0 : i2.clipEnabled) && (r2 ? Pl.AddFragmentClipping(e2.materialObject) || t2.alert("Cannot add fragment clipping extension.") : e2.materialObject.userData._fragmentClippingExt && (e2.materialObject.userData._fragmentClippingExt.clipEnabled = false, e2.materialObject.needsUpdate = true), null === (s2 = n2.uiRefresh) || void 0 === s2 || s2.call(n2, "postFrame", true));
        }, onChange: this.setDirty }, () => ({ type: "dropdown", label: "Mode", children: Object.entries(kl).map((e3) => ({ label: e3[0], value: e3[1] })), hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._fragmentClippingExt) || void 0 === t3 ? void 0 : t3.clipEnabled);
        }, property: [e2.materialObject.userData._fragmentClippingExt, "clipMode"], onChange: this.setDirty }), () => ({ type: "vec4", label: "Position", hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._fragmentClippingExt) || void 0 === t3 ? void 0 : t3.clipEnabled);
        }, property: [e2.materialObject.userData._fragmentClippingExt, "clipPosition"], onChange: this.setDirty }), () => ({ type: "vec4", label: "Params", hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._fragmentClippingExt) || void 0 === t3 ? void 0 : t3.clipEnabled);
        }, property: [e2.materialObject.userData._fragmentClippingExt, "clipParams"], onChange: this.setDirty }), () => ({ type: "toggle", label: "Invert", hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._fragmentClippingExt) || void 0 === t3 ? void 0 : t3.clipEnabled);
        }, property: [e2.materialObject.userData._fragmentClippingExt, "clipInvert"], onChange: this.setDirty })] };
        return n2;
      } }, this.setDirty = () => {
        var e2, t2, n2;
        null === (t2 = (e2 = this.materialExtension).setDirty) || void 0 === t2 || t2.call(e2), null === (n2 = this._viewer) || void 0 === n2 || n2.setDirty();
      }, this._loaderCreate = this._loaderCreate.bind(this);
    }
    async onAdded(e2) {
      var t2, n2, r2, i2, s2, o2, a2;
      await super.onAdded(e2);
      const l2 = e2.getPlugin(Ls);
      null === (t2 = null == l2 ? void 0 : l2.materials) || void 0 === t2 || t2.registerMaterialExtension(this.materialExtension), null === (n2 = null == l2 ? void 0 : l2.importer) || void 0 === n2 || n2.addEventListener("loaderCreate", this._loaderCreate), null === (s2 = null === (i2 = null === (r2 = null == l2 ? void 0 : l2.exporter) || void 0 === r2 ? void 0 : r2.getExporter("gltf", "glb")) || void 0 === i2 ? void 0 : i2.extensions) || void 0 === s2 || s2.push(Bl), null === (a2 = null === (o2 = e2.getPlugin(wt)) || void 0 === o2 ? void 0 : o2.material) || void 0 === a2 || a2.registerMaterialExtensions([this.materialExtension]);
    }
    async onRemove(e2) {
      var t2, n2, r2, i2;
      return null === (n2 = null === (t2 = e2.getPlugin(Ls)) || void 0 === t2 ? void 0 : t2.materials) || void 0 === n2 || n2.unregisterMaterialExtension(this.materialExtension), null === (i2 = null === (r2 = e2.getPlugin(Ls)) || void 0 === r2 ? void 0 : r2.importer) || void 0 === i2 || i2.removeEventListener("loaderCreate", this._loaderCreate), super.onRemove(e2);
    }
  };
  var kl;
  Rl.PluginType = "FragmentClippingExtensionPlugin1", Rl.FRAGMENT_CLIPPING_EXTENSION_GLTF_EXTENSION = "WEBGI_materials_fragment_clipping_extension", Il([Oe("Enabled", (e2) => ({ onChange: e2.setDirty })), ie()], Rl.prototype, "enabled", void 0), Rl = Pl = Il([We("FragmentClipping Materials")], Rl), function(e2) {
    e2[e2.Circle = 0] = "Circle", e2[e2.Ellipse = 1] = "Ellipse", e2[e2.Rectangle = 2] = "Rectangle", e2[e2.Plane = 3] = "Plane", e2[e2.Sphere = 4] = "Sphere";
  }(kl || (kl = {}));
  class Dl {
    constructor(e2) {
      this.parser = e2, this.name = Rl.FRAGMENT_CLIPPING_EXTENSION_GLTF_EXTENSION;
    }
    async extendMaterialParams(e2, t2) {
      const n2 = this.parser.json.materials[e2];
      if (!n2.extensions || !n2.extensions[this.name])
        return Promise.resolve();
      const r2 = n2.extensions[this.name];
      return t2.userData || (t2.userData = {}), Rl.AddFragmentClipping(t2), t2.userData._fragmentClippingExt = ce(r2, t2.userData._fragmentClippingExt, false, {}), Promise.resolve();
    }
  }
  const Bl = (e2) => ({ writeMaterial: (t2, n2) => {
    if (!t2.isMeshStandardMaterial || !t2.userData._fragmentClippingExt)
      return;
    if (!t2.userData._fragmentClippingExt.clipEnabled)
      return;
    n2.extensions = n2.extensions || {};
    const r2 = le(t2.userData._fragmentClippingExt, false);
    n2.extensions[Rl.FRAGMENT_CLIPPING_EXTENSION_GLTF_EXTENSION] = r2, e2.extensionsUsed[Rl.FRAGMENT_CLIPPING_EXTENSION_GLTF_EXTENSION] = true;
  } });
  var Ol, Ll = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let Ul = Ol = class extends gt {
    constructor(e2 = false) {
      super(), this.enabled = false, this.worldRadius = 100, this.tripodHeight = 10, this.originPosition = new n.Pa4(0, 0, 0), this._paramsChanged = this._paramsChanged.bind(this), this.enabled = e2, this.addEventListener("deserialize", this._paramsChanged);
    }
    _paramsChanged() {
      var e2, t2, r2, i2;
      if (!this._viewer)
        return;
      const s2 = this._viewer.scene.background;
      if (this.enabled && s2 !== this._viewer.scene.environment && "environment" !== s2)
        if (s2 && s2.isDataTexture)
          s2.mapping = n.dSO;
        else if (confirm("Background must be same as environment, do you want to change it?")) {
          const n2 = this._viewer.getPluginByType("SimpleBackgroundEnvUiPlugin1");
          n2 ? (n2.envmapBg = true, null === (t2 = (e2 = n2.uiConfig).uiRefresh) || void 0 === t2 || t2.call(e2, "postFrame", true)) : this._viewer.scene.setBackground("environment");
        } else
          this.enabled = false;
      const o2 = null === (r2 = this._viewer.renderer.rendererObject.background.getBoxMesh2()) || void 0 === r2 ? void 0 : r2.material, a2 = null !== (i2 = null == o2 ? void 0 : o2.uniforms) && void 0 !== i2 ? i2 : n.Vj0.backgroundCube.uniforms;
      a2.tripodHeight || (a2.tripodHeight = { value: 1 }), a2.worldRadius || (a2.worldRadius = { value: 1 }), a2.originPosition || (a2.originPosition = { value: new n.Pa4() }), a2.tripodHeight.value = this.tripodHeight, a2.worldRadius.value = this.worldRadius, a2.originPosition.value.copy(this.originPosition), o2 && (!this.enabled && o2.defines.HDRi_GROUND_PROJ ? delete o2.defines.HDRi_GROUND_PROJ : this.enabled && (o2.defines.HDRi_GROUND_PROJ = "1"), o2.needsUpdate = true), this._viewer.setDirty();
    }
    async onAdded(e2) {
      var t2, r2, i2;
      await super.onAdded(e2), (null === (i2 = null === (r2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.renderer) || void 0 === r2 ? void 0 : r2.rendererObject) || void 0 === i2 ? void 0 : i2.background.getBoxMesh()) && e2.console.error("HDRi Ground Plugin must be added before setting any cube or env map"), n.Vj0.backgroundCube.fragmentShader.includes("#ifdef HDRi_GROUND_PROJ") || (n.Vj0.backgroundCube.fragmentShader = ot(n.Vj0.backgroundCube.fragmentShader, "void main() {", "#ifdef HDRi_GROUND_PROJ\nfloat intersectPlane1(const in vec3 r0,const in vec3 rd,const in vec3 n,const in vec3 p0){float t=dot(p0-r0,n)/(dot(n,rd)+1e-6);return t<0.?1000.:t;}float intersectSphere1(in vec3 ro,in vec3 rd,in vec3 sph,in float rad){vec3 oc=ro-sph;float b=dot(oc,rd);float c=dot(oc,oc)-rad*rad;float t=b*b-c;return t<0.?t:-b+sqrt(t);}\n#define PI_HALF  1.5707963267948966\nuniform float worldRadius;uniform float tripodHeight;uniform vec3 originPosition;vec3 hdriProject(){vec3 p=normalize(vWorldDirection);vec3 camPos=cameraPosition;camPos.y-=tripodHeight;float t=intersectSphere1(camPos,p,originPosition,worldRadius);if(t>0.){float t2=intersectPlane1(camPos,p,vec3(0,-1,0),originPosition+vec3(0.,-tripodHeight,0.));p=(camPos+min(t,t2)*p)/worldRadius;}else p=vec3(0.,1.,0.);return p;}\n#endif\n", { prepend: true }), n.Vj0.backgroundCube.fragmentShader = ot(n.Vj0.backgroundCube.fragmentShader, "vec3 vReflect = vWorldDirection;", "\nvec3 vReflect = \n#ifdef HDRi_GROUND_PROJ\nhdriProject()\n#else\nvWorldDirection\n#endif\n;\n")), e2.scene.addEventListener("environmentChanged", this._paramsChanged);
    }
  };
  Ul.PluginType = "HDRiGroundPlugin", Ll([ie(), (0, t.onChange)(Ol.prototype._paramsChanged), Oe("Enabled")], Ul.prototype, "enabled", void 0), Ll([ie(), (0, t.onChange)(Ol.prototype._paramsChanged), Ue("World Radius", [1, 1e3], 0.01)], Ul.prototype, "worldRadius", void 0), Ll([ie(), (0, t.onChange)(Ol.prototype._paramsChanged), Ue("Tripod height", [0, 50], 0.01)], Ul.prototype, "tripodHeight", void 0), Ll([ie(), (0, t.onChange)(Ol.prototype._paramsChanged), Fe("Origin Position", void 0, 1e-3, (e2) => ({ onChange: e2._paramsChanged }))], Ul.prototype, "originPosition", void 0), Ul = Ol = Ll([We("HDRi Ground")], Ul);
  var Fl, Nl = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let jl = Fl = class extends gt {
    constructor(e2 = true) {
      super(), this.enabled = true, this.radius = 0.015, this.intensity = 1, this.tolerance = 1.5, this._defines = {}, this.onlySSCSDebug = false, this.stepCount = 2, this.dependencies = [wt, Ls], this.materialExtension = { shaderExtender: (e3, r2, i2) => {
        if (!e3.defines.SSCS_ENABLED)
          return;
        const s2 = t.glsl`
                #ifndef D_sceneBoundingRadius
                #define D_sceneBoundingRadius
                uniform float sceneBoundingRadius;
                #endif
                float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, vec3 lightDirection ) {
                    vec3 ray_origin_view = -vViewPosition;
                    float rnd = interleavedGradientNoise(gl_FragCoord.xy, frameCount+34.);
                    float cameraDist = length(cameraPositionWorld);
//                    float radius = mix((cameraNearFar.y) + ray_origin_view.z, -ray_origin_view.z - cameraNearFar.x, rnd * 0.5 + 0.5)*sscsRadius;
                    float radius = mix((cameraDist + sceneBoundingRadius) + ray_origin_view.z, -ray_origin_view.z - max(0.0, cameraDist - sceneBoundingRadius), rnd * 0.5 + 0.5)*sscsRadius;
                    vec3 state = vec3(1.,(rnd+0.5)/float(SSCS_STEP_COUNT),2.);
                    traceRay(ray_origin_view, normalize(lightDirection) * radius, sscsTolerance * radius * 2., state, SSCS_STEP_COUNT);
                    state.z = state.z > 0.99 ? 1. : max(0.,min(state.z * state.z * (1.-sscsIntensity), 1.));
                    
                #if defined(SSCS_DEBUG) && SSCS_DEBUG > 0
                    return state.z;
                #endif
            `, o2 = `
#if SSCS_ENABLED

    uniform float sscsIntensity;
    uniform float sscsRadius;
    uniform float sscsTolerance;

    ${tl}
    
    #define THREE_PACKING_INCLUDED
    ${Za}
    
    ${_t}
    ${co}
    
    ${el}

#endif
            
            ` + n.WdD.shadowmap_pars_fragment.replace("float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {", `${s2}
`).replace("return shadow;", "return min(shadow, state.z);");
        e3.fragmentShader = e3.fragmentShader.replace("#include <shadowmap_pars_fragment>", o2), e3.fragmentShader = e3.fragmentShader.replace("#include <lights_fragment_begin>", n.WdD.lights_fragment_begin), e3.fragmentShader = ot(e3.fragmentShader, "directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;", "directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ], directLight.direction ) : 1.0;"), e3.fragmentShader = ot(e3.fragmentShader, "directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;", "directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ], directLight.direction ) : 1.0;");
      }, onObjectRender: (e3, t2, n2) => {
        var r2, i2;
        const s2 = t2.materialObject;
        let o2 = !this.enabled || false === n2.userData.screenSpaceRendering || (null === (r2 = s2.userData) || void 0 === r2 ? void 0 : r2.sscsDisabled) || (null === (i2 = s2.userData) || void 0 === i2 ? void 0 : i2.pluginsDisabled) ? 0 : 1;
        s2.defines.SSCS_ENABLED !== o2 && (s2.defines.SSCS_ENABLED = o2, s2.needsUpdate = true), o2 = this._defines.SSCS_STEP_COUNT, s2.defines.SSCS_STEP_COUNT !== o2 && (s2.defines.SSCS_STEP_COUNT = o2, s2.needsUpdate = true), o2 = +this._defines.SSCS_DEBUG, s2.defines.SSCS_DEBUG !== o2 && (s2.defines.SSCS_DEBUG = o2, s2.needsUpdate = true);
      }, parsFragmentSnippet: () => "\n", extraUniforms: { ...Fl._uniforms }, computeCacheKey: (e3) => this.enabled ? "1" : "0", isCompatible: (e3) => e3.isMeshStandardMaterial2, updaters: () => {
        var e3, t2, n2, r2, i2;
        return [null === (e3 = this._viewer) || void 0 === e3 ? void 0 : e3.getPlugin(wt), null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(To), null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.scene.renderCamera, null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.renderer, null === (i2 = this._viewer) || void 0 === i2 ? void 0 : i2.scene];
      } }, this.enabled = e2, this.userData = { setDirty: () => {
        var e3;
        null === (e3 = this._viewer) || void 0 === e3 || e3.setDirty();
      } };
    }
    async onAdded(e2) {
      var t2, n2;
      await super.onAdded(e2), null === (n2 = null === (t2 = e2.getPlugin(Ls)) || void 0 === t2 ? void 0 : t2.materials) || void 0 === n2 || n2.registerMaterialExtension(this.materialExtension);
    }
    async onRemove(e2) {
      var t2, n2;
      return null === (n2 = null === (t2 = e2.getPlugin(Ls)) || void 0 === t2 ? void 0 : t2.materials) || void 0 === n2 || n2.unregisterMaterialExtension(this.materialExtension), super.onRemove(e2);
    }
  };
  jl.PluginType = "SSContactShadows", jl._uniforms = { tNormalDepth: { value: null }, frameCount: { value: 0 }, projection: { value: new n.yGw() }, cameraPositionWorld: { value: new n.Pa4() }, cameraNearFar: { value: new n.FM8(0.1, 1e3) }, sceneBoundingRadius: { value: 0 } }, Nl([Oe("Enabled"), ie()], jl.prototype, "enabled", void 0), Nl([j({ uniforms: Fl._uniforms, propKey: "sscsRadius" }), Ue("Radius", [1e-4, 0.1], 1e-4), ie()], jl.prototype, "radius", void 0), Nl([j({ uniforms: Fl._uniforms, propKey: "sscsIntensity" }), Ue("Intensity", [1e-4, 1], 1e-4), ie()], jl.prototype, "intensity", void 0), Nl([j({ uniforms: Fl._uniforms, propKey: "sscsTolerance" }), Ue("Tolerance", [0.1, 5]), ie()], jl.prototype, "tolerance", void 0), Nl([z("SSCS_DEBUG", void 0, true), Oe("Debug only SSCS"), ie()], jl.prototype, "onlySSCSDebug", void 0), Nl([z("SSCS_STEP_COUNT", void 0, true), Ue("Step count", [1, 8], 1), ie()], jl.prototype, "stepCount", void 0), jl = Fl = Nl([We("Screen Space Contact Shadows")], jl);
  class zl {
    constructor(e2) {
      this._normalsCache = {}, this._renderer = e2, this._scene = new n.xsS(), this._mesh = new n.Kj0(), this._mesh.frustumCulled = false, this._scene.add(this._mesh), this._mesh.position.set(0, 0, 0), this._mesh.material = new Gl();
    }
    dispose() {
      var e2;
      null === (e2 = this._mesh.geometry) || void 0 === e2 || e2.dispose(), this._mesh.material.dispose(), this.disposeAllTargets();
    }
    disposeTarget(e2) {
      e2.split(";").forEach((e3) => {
        var t2;
        return null === (t2 = this._normalsCache[e3]) || void 0 === t2 ? void 0 : t2.dispose();
      });
    }
    disposeAllTargets() {
      Object.values(this._normalsCache).forEach((e2) => e2.dispose()), this._normalsCache = {};
    }
    hasCapturedNormalMap(e2) {
      return !!e2.userData._normalsCaptureMap;
    }
    _getPrecisionType(e2) {
      return "low" === e2 ? n.ywz : "medium" === e2 ? n.cLu : "high" === e2 ? n.VzW : n.cLu;
    }
    captureNormalMap(e2, t2, r2 = 512, i2 = "medium", s2) {
      if (!e2)
        throw "No geometry";
      if (this.hasCapturedNormalMap(e2))
        return false;
      const o2 = null == t2 ? void 0 : t2.split(";").find((e3) => this._normalsCache[e3]);
      if (o2) {
        const n2 = this._normalsCache[o2];
        return null == t2 || t2.split(";").forEach((e3) => e3 !== o2 && (this._normalsCache[e3] = n2)), n2.width !== r2 && console.warn("last cacheKey normalMapRes mismatch, check model", r2), e2.userData._normalsCaptureMap = n2, false;
      }
      const a2 = this._renderer.createTargetCustom({ width: r2, height: r2 }, { minFilter: n.TyD, magFilter: n.TyD, generateMipmaps: false, type: this._getPrecisionType(i2) }, n.oAp);
      if (a2.attachedGeometries = [], a2.autoDispose = zl.AutoDisposeTargets, !a2)
        throw "Unable to create render target";
      const l2 = () => {
        var t3;
        const r3 = new n._am(1e-4, 100, a2);
        this._scene.add(r3);
        const i3 = e2.userData.normalsCaptureOffsets;
        void 0 !== i3.center && this._mesh.material.uniforms.offsetCenter.value.fromArray(i3.center), void 0 !== i3.offsetMatrixInv && this._mesh.material.uniforms.offsetMatrixInv.value.fromArray(i3.offsetMatrixInv), void 0 !== i3.radius && (this._mesh.material.uniforms.radius.value = i3.radius), this._mesh.geometry = e2, (null == s2 ? void 0 : s2.morphTargetInfluences) && (null === (t3 = e2.morphAttributes) || void 0 === t3 ? void 0 : t3.position) && (this._mesh.morphTargetInfluences = s2.morphTargetInfluences, this._mesh.morphTargetDictionary = s2.morphTargetDictionary);
        const o3 = this._renderer.rendererObject.getClearColor(new n.Ilk()), l3 = this._renderer.rendererObject.getClearAlpha();
        this._renderer.rendererObject.setClearColor(new n.Ilk(0, 0, 0), 1), r3.update(this._renderer.rendererObject, this._scene), this._renderer.rendererObject.setClearColor(o3, l3), this._mesh.morphTargetInfluences = void 0, this._mesh.morphTargetDictionary = void 0, this._scene.remove(r3), this._mesh.geometry = void 0, e2.userData._normalsCaptureMap = a2;
      };
      return l2(), this._renderer.addEventListener("contextRestored", l2), a2.attachedGeometries.push(e2), e2.addEventListener("dispose", () => {
        var t3, n2;
        a2.attachedGeometries = null !== (n2 = null === (t3 = a2.attachedGeometries) || void 0 === t3 ? void 0 : t3.filter((t4) => t4 !== e2)) && void 0 !== n2 ? n2 : [], delete e2.userData._normalsCaptureMap, this._renderer.removeEventListener("contextRestored", l2), a2.autoDispose && !a2.attachedGeometries.length && a2.dispose();
      }), null == t2 || t2.split(";").forEach((e3) => this._normalsCache[e3] = a2), a2.addEventListener("dispose", () => {
        var e3;
        null == t2 || t2.split(";").forEach((e4) => delete this._normalsCache[e4]), this._renderer.removeEventListener("contextRestored", l2), null === (e3 = a2.attachedGeometries) || void 0 === e3 || e3.forEach((e4) => delete e4.userData._normalsCaptureMap);
      }), true;
    }
  }
  zl.AutoDisposeTargets = true;
  class Gl extends n.jyz {
    constructor() {
      super({ vertexShader: "varying vec3 vNormal;varying vec3 vecPosition;uniform mat4 offsetMatrixInv;uniform vec3 offsetCenter;\n#include <morphtarget_pars_vertex>\nvoid main(){vNormal=normalize((offsetMatrixInv*vec4(normal,0.)).xyz);\n#include <begin_vertex>\ntransformed-=offsetCenter;\n#include <morphtarget_vertex>\nvec4 offsetPos=offsetMatrixInv*vec4(transformed,1.);vecPosition=(modelMatrix*offsetPos).xyz;gl_Position=projectionMatrix*modelViewMatrix*offsetPos;}", fragmentShader: "varying vec3 vNormal;varying vec3 vecPosition;uniform float radius;void main(){vec3 color=normalize(vNormal);color=color*0.5+0.5;gl_FragColor=vec4(color.x,color.y,color.z,length(vecPosition)/radius);}", side: n.ehD, clipping: false, uniforms: { radius: { value: 1 }, offsetMatrixInv: { value: new n.yGw().identity() }, offsetCenter: { value: new n.Pa4() } } });
    }
  }
  var Vl = __webpackgi_require__2(654);
  function Hl(e2) {
    const t2 = new n.Pa4(0, 0, 0), r2 = new n.Pa4(0, 0, 0), i2 = new n.Pa4(0, 0, 0), s2 = new n.Pa4(0, 0, 0), o2 = e2.getAttribute("position"), a2 = e2.index;
    if (a2)
      for (let n2 = Math.max(0, e2.drawRange.start), l3 = Math.min(a2.count, e2.drawRange.start + e2.drawRange.count) - 1; n2 < l3 / 3; n2 += 3) {
        const e3 = a2.getX(n2), l4 = a2.getX(n2 + 1), c3 = a2.getX(n2 + 2);
        r2.set(o2.getX(e3), o2.getY(e3), o2.getZ(e3)), i2.set(o2.getX(l4), o2.getY(l4), o2.getZ(l4)), s2.set(o2.getX(c3), o2.getY(c3), o2.getZ(c3)), i2.sub(r2), s2.sub(r2), s2.cross(i2), s2.normalize(), t2.add(s2);
      }
    else
      for (let e3 = 0; e3 < o2.count; e3 += 3)
        r2.set(o2.getX(e3), o2.getY(e3), o2.getZ(e3)), i2.set(o2.getX(e3 + 1), o2.getY(e3 + 1), o2.getZ(e3 + 1)), s2.set(o2.getX(e3 + 2), o2.getY(e3 + 2), o2.getZ(e3 + 2)), i2.sub(r2), s2.sub(r2), s2.cross(i2), s2.normalize(), t2.add(s2);
    t2.normalize();
    let l2 = false, c2 = 0;
    for (; !l2; ) {
      const e3 = c2 / 3, n2 = a2 ? a2.getX(e3) : e3, s3 = a2 ? a2.getX(e3 + 1) : e3 + 1;
      r2.set(o2.getX(n2), o2.getY(n2), o2.getZ(n2)), i2.set(o2.getX(s3), o2.getY(s3), o2.getZ(s3)), r2.sub(i2), r2.normalize();
      const u3 = t2.dot(r2);
      Math.abs(u3 - 1) > 1e-3 && r2.length() > 0.5 && (l2 = true), c2 += 3;
    }
    i2.crossVectors(r2, t2), i2.normalize(), r2.crossVectors(t2, i2), r2.normalize();
    const u2 = new n.yGw();
    u2.elements[0] = r2.x, u2.elements[1] = r2.y, u2.elements[2] = r2.z, u2.elements[3] = 0, u2.elements[4] = t2.x, u2.elements[5] = t2.y, u2.elements[6] = t2.z, u2.elements[7] = 0, u2.elements[8] = i2.x, u2.elements[9] = i2.y, u2.elements[10] = i2.z, u2.elements[11] = 0, u2.elements[12] = 0, u2.elements[13] = 0, u2.elements[14] = 0, u2.elements[15] = 1, e2.computeBoundingSphere();
    const p2 = e2.boundingSphere.radius, d2 = new n.yGw().makeScale(p2, p2, p2);
    return u2.multiply(d2), u2;
  }
  function Ql(e2, t2, r2) {
    const i2 = new n.Pa4().copy(e2), s2 = new n.Pa4().copy(t2), o2 = new n.Pa4().copy(r2);
    return i2.dot(s2.cross(o2)) / 6;
  }
  function Wl(e2, t2, r2) {
    const i2 = new n.Pa4().copy(e2), s2 = new n.Pa4().copy(t2), o2 = new n.Pa4().copy(r2);
    return s2.sub(i2), o2.sub(i2), o2.cross(s2), 0.5 * o2.length();
  }
  function ql(e2) {
    const t2 = e2.getAttribute("position"), r2 = e2.getAttribute("normal");
    if (t2.count / 3 > 1500)
      return console.warn("DiamondPlugin:: Too many faces. Mirror/Topology issues will not be fixed", t2.count / 3), Hl(e2);
    const i2 = new n.Pa4(0, 0, 0), s2 = new n.Pa4(0, 0, 0), o2 = new n.Pa4(0, 0, 0), a2 = e2.index, l2 = [];
    if (a2)
      for (let n2 = Math.max(0, e2.drawRange.start), r3 = Math.min(a2.count, e2.drawRange.start + e2.drawRange.count) - 1; n2 < r3; n2 += 3) {
        const e3 = a2.getX(n2), r4 = a2.getX(n2 + 1), c3 = a2.getX(n2 + 2);
        i2.set(t2.getX(e3), t2.getY(e3), t2.getZ(e3)), s2.set(t2.getX(r4), t2.getY(r4), t2.getZ(r4)), o2.set(t2.getX(c3), t2.getY(c3), t2.getZ(c3)), l2.push(i2.toArray(), s2.toArray(), o2.toArray());
      }
    else
      for (let e3 = 0; e3 < t2.count; e3++)
        i2.set(t2.getX(e3), t2.getY(e3), t2.getZ(e3)), l2.push(i2.toArray());
    const c2 = function(e3, t3) {
      const r3 = new n.Pa4();
      for (let t4 = 0; t4 < e3.length; t4 += 3)
        r3.x += e3[t4], r3.y += e3[t4 + 1], r3.z += e3[t4 + 2];
      r3.multiplyScalar(1 / (e3.length / 3));
      const i3 = new n.Pa4(), s3 = new n.Pa4(), o3 = new n.Pa4(), a3 = new n.Pa4(), l3 = new n.Pa4();
      let c3 = 0, u3 = 0, p3 = t3.length;
      p3 % 3 != 0 && (p3 -= p3 % 3);
      for (let e4 = 0; e4 < p3; e4 += 3) {
        i3.set(t3[e4][0], t3[e4][1], t3[e4][2]), s3.set(t3[e4 + 1][0], t3[e4 + 1][1], t3[e4 + 1][2]), o3.set(t3[e4 + 2][0], t3[e4 + 2][1], t3[e4 + 2][2]), l3.copy(i3).add(s3).add(o3);
        const n2 = Wl(i3, s3, o3);
        l3.multiplyScalar(n2 / 3), a3.add(l3), c3 += n2, u3 += Ql(i3, s3, o3);
      }
      return a3.multiplyScalar(1 / c3), { centre: r3, com: a3, volume: u3, area: c3 };
    }(t2.array, l2);
    if (c2.volume < 0) {
      console.warn("DiamondPlugin:: Negative Volume, Fixing Normals");
      for (let e3 = 0; e3 < r2.count; e3++)
        r2.setX(e3, -r2.getX(e3)), r2.setY(e3, -r2.getY(e3)), r2.setZ(e3, -r2.getZ(e3));
      r2.needsUpdate = true;
    }
    const u2 = [];
    for (let e3 = 0; e3 < t2.array.length; e3 += 3)
      u2.push([t2.array[e3], t2.array[e3 + 1], t2.array[e3 + 2]]);
    const p2 = console.log;
    console.log = () => {
    };
    const d2 = (0, Vl.getEigenVectors)(u2);
    console.log = p2;
    const h2 = new n.yGw();
    h2.elements[0] = d2[0].vector[0], h2.elements[1] = d2[0].vector[1], h2.elements[2] = d2[0].vector[2], h2.elements[3] = 0, h2.elements[4] = d2[1].vector[0], h2.elements[5] = d2[1].vector[1], h2.elements[6] = d2[1].vector[2], h2.elements[7] = 0, h2.elements[8] = d2[2].vector[0], h2.elements[9] = d2[2].vector[1], h2.elements[10] = d2[2].vector[2], h2.elements[11] = 0, h2.elements[12] = 0, h2.elements[13] = 0, h2.elements[14] = 0, h2.elements[15] = 1;
    const f2 = new n.Pa4();
    f2.copy(c2.com).sub(c2.centre), f2.normalize();
    const m2 = new n.Pa4(d2[2].vector[0], d2[2].vector[1], d2[2].vector[2]);
    f2.dot(m2) < 0 && (h2.elements[4] = -d2[1].vector[0], h2.elements[5] = -d2[1].vector[1], h2.elements[6] = -d2[1].vector[2], h2.elements[8] = -d2[2].vector[0], h2.elements[9] = -d2[2].vector[1], h2.elements[10] = -d2[2].vector[2]), e2.computeBoundingSphere();
    const _2 = e2.boundingSphere.radius, g2 = new n.yGw().makeScale(_2, _2, _2);
    return h2.multiply(g2), h2;
  }
  const Xl = { ...Mt, color: new n.Ilk(1, 1, 1), envMapIntensity: 1, envMapRotation: 0, dispersion: 0.012, squashFactor: 0.98, geometryFactor: 0.5, gammaFactor: 1, absorptionFactor: 1, reflectivity: 0.5, refractiveIndex: 2.4, boostFactors: new n.Pa4(0.892, 0.892, 0.98595025), wireframe: false, envMapRotationOffset: 0, wireframeLinewidth: 0, skinning: false, transmission: 0, morphTargets: false, morphNormals: false, rayBounces: 1, diamondOrientedEnvMap: 0, envMapIndex: 0 };
  var Yl = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  class Kl extends n.jyz {
    get mmMaterial() {
      return this;
    }
    get materialObject() {
      return this;
    }
    onBeforeRender(e2, t2, r2, i2, s2) {
      var o2, a2;
      super.onBeforeRender(e2, t2, r2, i2, s2), void 0 === this.envMapIntensity || this.userData.separateEnvMapIntensity || void 0 === t2.envMapIntensity || (this.userData.__envIntensity = this.envMapIntensity, this.envMapIntensity = t2.envMapIntensity), void 0 !== this.envMap && void 0 !== t2.fixedEnvMapDirection && (t2.fixedEnvMapDirection ? this.defines.FIX_ENV_DIRECTION || (this.defines.FIX_ENV_DIRECTION = "1", this.needsUpdate = true) : void 0 !== this.defines.FIX_ENV_DIRECTION && (delete this.defines.FIX_ENV_DIRECTION, this.needsUpdate = true)), this.uniforms.envMapRotation.value = ((null === (o2 = this.envMap) || void 0 === o2 ? void 0 : o2.rotation) || 0) + this.envMapRotationOffset, this.uniforms.envMapRotationQuat.value.setFromEuler(new n.USm(this.envMapRotationOffsetX, this.envMapRotationOffsetY, this.envMapRotationOffsetZ)), this.extraUniformsToUpload.inverseModelMatrix.value.copy(s2.matrixWorld).invert();
      const l2 = i2.userData.normalsCaptureOffsets;
      l2 && (this.extraUniformsToUpload.centerOffset.value.fromArray(l2.centerOffset), this.extraUniformsToUpload.modelOffsetMatrix.value.fromArray(l2.offsetMatrix).premultiply(s2.matrixWorld), this.extraUniformsToUpload.modelOffsetMatrixInv.value.copy(this.extraUniformsToUpload.modelOffsetMatrix.value).invert(), this.extraUniformsToUpload.radius.value = l2.radius);
      const c2 = null === (a2 = i2.userData._normalsCaptureMap) || void 0 === a2 ? void 0 : a2.texture;
      this.normalsCaptureMap !== c2 && (this.normalsCaptureMap = c2), this.dispatchEvent({ type: "beforeRender", renderer: e2, scene: t2, camera: r2, geometry: i2, object: s2 });
    }
    onAfterRender(e2, t2, n2, r2, i2) {
      super.onAfterRender(e2, t2, n2, r2, i2), void 0 !== this.userData.__envIntensity && (this.envMapIntensity = this.userData.__envIntensity, delete this.userData.__envIntensity), this.dispatchEvent({ type: "afterRender", renderer: e2, scene: t2, camera: n2, geometry: r2, object: i2 });
    }
    constructor(e2) {
      var t2;
      super({ side: n.ehD, defines: { DIA_ORIENT_ENVMAP: 0, RAY_BOUNCES: 5, ENV_MAP_TYPE: 0, PI: 3.1428 }, vertexShader: "#ifndef USE_ENVMAP\n#define USE_ENVMAP  \n#endif\nvarying vec3 vWorldPosition;varying vec3 vWorldNormal;varying vec3 vViewPosition;varying vec3 vNormal;varying vec2 vUv;\n#ifdef USE_INSTANCING\nuniform mat4 inverseModelMatrix;uniform mat4 modelOffsetMatrix;varying mat4 vModelInstanceOffsetMatrix;varying mat4 vModelInstanceOffsetMatrixInv;\n#endif\n#include <morphtarget_pars_vertex>\n#ifdef USE_MORPHTARGETS\nvarying vec3 vCenterOffset;\n#ifndef USE_INSTANCING\nuniform mat4 modelOffsetMatrixInv;\n#endif\n#endif\nvoid main(){\n#ifdef USE_INSTANCING\nvWorldNormal=(modelMatrix*instanceMatrix*vec4(normal,0.)).xyz;\n#else\nvWorldNormal=(modelMatrix*vec4(normal,0.)).xyz;\n#endif\n#include <beginnormal_vertex>\n#include <defaultnormal_vertex>\n#include <normal_vertex>\n#include <begin_vertex>\n#ifdef USE_MORPHTARGETS\nvCenterOffset=transformed;\n#include <morphtarget_vertex>\nvCenterOffset=transformed-vCenterOffset;\n#ifndef USE_INSTANCING\nvCenterOffset=(modelOffsetMatrixInv*modelMatrix*vec4(vCenterOffset,1.)).xyz;\n#endif\n#endif\n#include <project_vertex>\nvViewPosition=-mvPosition.xyz;vUv=uv;\n#include <worldpos_vertex>\nvWorldPosition=worldPosition.xyz;\n#ifdef USE_INSTANCING\nvModelInstanceOffsetMatrix=modelMatrix*instanceMatrix*inverseModelMatrix*modelOffsetMatrix;vModelInstanceOffsetMatrixInv=inverse(vModelInstanceOffsetMatrix);\n#ifdef USE_MORPHTARGETS\nvCenterOffset=(vModelInstanceOffsetMatrixInv*modelMatrix*vec4(vCenterOffset,1.)).xyz;\n#endif\n#endif\n}", fragmentShader: "varying vec3 vWorldNormal;varying vec3 vWorldPosition;varying vec3 vViewPosition;varying vec3 vNormal;varying vec2 vUv;uniform float radius;uniform vec3 centerOffset;\n#ifdef USE_INSTANCING\nvarying mat4 vModelInstanceOffsetMatrix;varying mat4 vModelInstanceOffsetMatrixInv;\n#define MODEL_OFFSET_MATRIX  vModelInstanceOffsetMatrix\n#define INV_MODEL_OFFSET_MATRIX  vModelInstanceOffsetMatrixInv\n#else\nuniform mat4 modelOffsetMatrixInv;uniform mat4 modelOffsetMatrix;\n#define MODEL_OFFSET_MATRIX  modelOffsetMatrix\n#define INV_MODEL_OFFSET_MATRIX  modelOffsetMatrixInv\n#endif\n#ifdef USE_MORPHTARGETS\nvarying vec3 vCenterOffset;\n#define CENTER_OFFSET  (centerOffset + vCenterOffset)\n#else\n#define CENTER_OFFSET  (centerOffset) \n#endif\nuniform mat4 projectionMatrix;uniform samplerCube tCubeMapNormals;\n#if ENV_MAP_TYPE == 0\nuniform samplerCube envMap;\n#elif ENV_MAP_TYPE == 1\nuniform sampler2D envMap;\n#endif\nuniform float envMapIntensity;uniform float transmission;uniform vec2 transmissionSamplerSize;uniform sampler2D transmissionSamplerMap;uniform float refractiveIndex;uniform float rIndexDelta;uniform float squashFactor;uniform float geometryFactor;uniform vec3 color;uniform vec3 colorCorrection;uniform vec3 boostFactors;uniform float gammaFactor;uniform float absorptionFactor;uniform float envMapRotation;uniform vec4 envMapRotationQuat;uniform float reflectivity;vec3 BRDF_Specular_GGX_Environment(const in vec3 viewDir,const in vec3 normal,const in vec3 specularColor,const in float roughness){float dotNV=abs(dot(normal,viewDir));const vec4 c0=vec4(-1,-0.0275,-0.572,0.022);const vec4 c1=vec4(1,0.0425,1.04,-0.04);vec4 r=roughness*c0+c1;float a004=min(r.x*r.x,exp2(-9.28*dotNV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec2 cartesianToPolar(vec3 n){vec2 uv;uv.x=atan(n.z,n.x)/(PI*2.)+0.5;uv.y=asin(n.y)/PI+0.5;return uv;}vec4 sampleEnvMap(vec3 direction){\n#if !defined(USE_ENVMAP)\nreturn vec4(direction,1);\n#else\nfloat cs=cos(envMapRotation);float sn=sin(envMapRotation);float temp=cs*direction.x+sn*direction.z;direction.z=-sn*direction.x+cs*direction.z;direction.x=temp;direction.x*=-1.;direction.y*=-1.;direction.z*=-1.;vec3 t=2.*cross(envMapRotationQuat.xyz,direction);direction+=envMapRotationQuat.w*t+cross(envMapRotationQuat.xyz,t);\n#if ENV_MAP_TYPE == 0\nreturn(textureCube(envMap,direction));\n#elif ENV_MAP_TYPE == 1\nreturn(texture2D(envMap,cartesianToPolar(direction)));\n#endif\nreturn vec4(1,0,1,1);\n#endif\n}vec4 SampleSpecularReflection(vec3 direction){\n#if defined(FIX_ENV_DIRECTION)\ndirection=(viewMatrix*vec4(direction,0.)).xyz;\n#endif\nreturn envMapIntensity*(sampleEnvMap(direction));}vec4 SampleSpecularContribution(vec3 direction){\n#if DIA_ORIENT_ENVMAP < 1\ndirection=mat3(MODEL_OFFSET_MATRIX)*direction;\n#endif\n#if defined(FIX_ENV_DIRECTION)\ndirection=(viewMatrix*vec4(direction,0.)).xyz;\n#endif\ndirection=normalize(direction);direction.x*=-1.;direction.z*=-1.;return envMapIntensity*(sampleEnvMap(direction));}vec4 SampleSpecularContributionRef(vec3 origin,int i){vec4 ndcPos=projectionMatrix*viewMatrix*vec4(origin,1.);vec2 refractionCoords=ndcPos.xy/ndcPos.w;refractionCoords+=1.;refractionCoords/=2.;return transmissionSamplerMapTexelToLinear(texture2D(transmissionSamplerMap,refractionCoords));}vec3 intersectSphere(vec3 origin,vec3 direction){origin-=CENTER_OFFSET;direction.y/=squashFactor;float A=dot(direction,direction);float B=2.*dot(origin,direction);float C=dot(origin,origin)-radius*radius;float disc=B*B-4.*A*C;if(disc>0.){disc=sqrt(disc);float t1=(-B+disc)*geometryFactor/A;float t2=(-B-disc)*geometryFactor/A;float t=(t1>t2)?t1:t2;direction.y*=squashFactor;return vec3(origin+CENTER_OFFSET+direction*t);}return vec3(0.);}vec3 linePlaneIntersect(in vec3 pointOnLine,in vec3 lineDirection,in vec3 pointOnPlane,in vec3 planeNormal){return lineDirection*(dot(planeNormal,pointOnPlane-pointOnLine)/dot(planeNormal,lineDirection))+pointOnLine;}vec4 getNormalDistance(vec3 d){return textureCube(tCubeMapNormals,d);}vec3 getSurfaceNormal(vec4 surfaceInfos){vec3 surfaceNormal=surfaceInfos.rgb;surfaceNormal=surfaceNormal*2.-1.;return-normalize(surfaceNormal);}vec3 intersect(vec3 rayOrigin,vec3 rayDirection){vec3 sphereHitPoint=intersectSphere(rayOrigin,rayDirection);vec3 direction1=normalize(sphereHitPoint-CENTER_OFFSET);vec4 normalDistanceData1=getNormalDistance(direction1);float distance1=normalDistanceData1.a*radius;vec3 pointOnPlane1=CENTER_OFFSET+direction1*distance1;vec3 planeNormal1=getSurfaceNormal(normalDistanceData1);vec3 hitPoint1=linePlaneIntersect(rayOrigin,rayDirection,pointOnPlane1,planeNormal1);vec3 direction2=normalize(hitPoint1-CENTER_OFFSET);vec4 normalDistanceData2=getNormalDistance(direction2);float distance2=normalDistanceData2.a*radius;vec3 pointOnPlane2=CENTER_OFFSET+direction2*distance2;vec3 hitPoint=hitPoint1;vec3 planeNormal2=getSurfaceNormal(normalDistanceData2);hitPoint=linePlaneIntersect(rayOrigin,rayDirection,pointOnPlane2,planeNormal2);return hitPoint;}vec3 debugBounces(int count){vec3 color=vec3(1.,1.,1.);if(count==1)color=vec3(0.,1.,0.);else if(count==2)color=vec3(0.,0.,1.);else if(count==3)color=vec3(1.,1.,0.);else if(count==4)color=vec3(0.,1.,1.);else color=vec3(0.,1.,0.);if(count==0)color=vec3(1.,0.,0.);return color;}vec3 getRefractionColor(vec3 origin,vec3 direction,vec3 normal){vec3 outColor=vec3(0.);const float n1=1.;const float epsilon=1e-4;float f0=(2.4-n1)/(2.4+n1);f0*=f0;vec3 attenuationFactor=vec3(1.);vec3 newDirection=refract(direction,normal,n1/refractiveIndex);vec3 brdfRefracted=BRDF_Specular_GGX_Environment(newDirection,-normal,vec3(f0),0.);attenuationFactor*=(vec3(1.)-brdfRefracted);int count=0;mat4 invModelOffsetMatrix=INV_MODEL_OFFSET_MATRIX;newDirection=normalize((invModelOffsetMatrix*vec4(newDirection,0.)).xyz);origin=(invModelOffsetMatrix*vec4(origin,1.)).xyz;for(int i=0;i<RAY_BOUNCES;i++){vec3 intersectedPos=intersect(origin,newDirection);vec3 dist=intersectedPos-origin;vec3 d=normalize(intersectedPos-CENTER_OFFSET);vec3 mappedNormal=getNormalDistance(d).rgb;mappedNormal=2.*mappedNormal-1.;mappedNormal=-normalize(mappedNormal);float r=length(dist)/radius*absorptionFactor;attenuationFactor*=exp(-r*(1.-color));origin=intersectedPos;vec3 origin2=(MODEL_OFFSET_MATRIX*vec4(intersectedPos,1)).xyz;vec3 oldDir=newDirection;newDirection=refract(newDirection,mappedNormal,refractiveIndex/n1);if(dot(newDirection,newDirection)<epsilon){newDirection=reflect(oldDir,mappedNormal);if(i==RAY_BOUNCES-1){vec3 brdfReflected=BRDF_Specular_GGX_Environment(-oldDir,mappedNormal,vec3(f0),0.);vec3 d1=mat3(MODEL_OFFSET_MATRIX)*oldDir;d1=normalize(d1);float cosT=1.-dot(direction,d1);outColor+=((transmission>0.&&cosT<transmission)?SampleSpecularContributionRef(origin2+0.5*d1*cosT,i).rgb:SampleSpecularContribution(oldDir).rgb)*attenuationFactor*colorCorrection*boostFactors*(vec3(1.)-brdfReflected);}}else{vec3 brdfRefracted=vec3(1.)-BRDF_Specular_GGX_Environment(newDirection,-mappedNormal,vec3(f0),0.);vec3 d1=normalize(mat3(MODEL_OFFSET_MATRIX)*newDirection);float cosT=1.-dot(direction,d1);if(transmission>0.&&cosT<transmission){outColor+=SampleSpecularContributionRef(origin2+0.5*d1*cosT,i).rgb*brdfRefracted*attenuationFactor*colorCorrection*boostFactors;}else{vec3 dir0=newDirection;vec3 dir1=refract(oldDir,mappedNormal,(refractiveIndex+rIndexDelta)/n1);vec3 dir2=refract(oldDir,mappedNormal,(refractiveIndex-rIndexDelta)/n1);outColor+=vec3(SampleSpecularContribution(dir1).r,SampleSpecularContribution(dir0).g,SampleSpecularContribution(dir2).b)*brdfRefracted*attenuationFactor*colorCorrection*boostFactors;}newDirection=reflect(oldDir,mappedNormal);vec3 brdfReflected=BRDF_Specular_GGX_Environment(newDirection,mappedNormal,vec3(f0),0.);attenuationFactor*=brdfReflected*boostFactors;count++;}}return outColor;}void main(){vec3 normalizedNormal=normalize(vWorldNormal);vec3 viewVector=normalize(vWorldPosition-cameraPosition);const float n1=1.;const float epsilon=1e-4;float f0=(2.4-n1)/(2.4+n1);f0*=f0;vec3 attenuationFactor=vec3(1.);vec3 reflectedDirection=reflect(viewVector,normalizedNormal);vec3 brdfReflected=BRDF_Specular_GGX_Environment(reflectedDirection,normalizedNormal,vec3(f0),0.);vec3 reflectionColor=SampleSpecularReflection(reflectedDirection).rgb*brdfReflected*reflectivity*2.;vec3 refractionColor=getRefractionColor(vWorldPosition,viewVector,normalizedNormal);vec3 normal=normalize(vNormal);vec3 diffuseColor=vec3(1.);\n#glMarker beforeAccumulation\ngl_FragColor=vec4((refractionColor.rgb+reflectionColor.rgb)*diffuseColor,1.);gl_FragColor.rgb=pow(gl_FragColor.rgb,vec3(gammaFactor));\n#include <encodings_fragment>\n}", uniforms: { envMap: { value: e2.envMap || null }, envMapRotation: { value: 0 }, envMapRotationQuat: { value: new n._fP() }, transmission: { value: 0 }, transmissionSamplerMap: { value: null }, transmissionSamplerSize: { value: new n.FM8() }, normalOffset: { value: 0 }, distanceOffset: { value: 0 }, colorCorrection: { value: new n.Pa4(1, 1, 1) } } }), this.typeSlug = Kl.TypeSlug, this.assetType = "material", this.__envMap = [], this.isDiamondMaterial = true, this.color = new n.Ilk(1, 1, 1), this.envMapIntensity = 1, this.envMapRotationOffset = 0, this.envMapRotationOffsetX = 0, this.envMapRotationOffsetY = 0, this.envMapRotationOffsetZ = 0, this.dispersion = 0.012, this.absorptionFactor = 1, this.refractiveIndex = 2.4, this.squashFactor = 0.98, this.geometryFactor = 0.5, this.gammaFactor = 1, this.boostFactors = new n.Pa4(0.892, 0.892, 0.98595025), this.transmission = 0, this.reflectivity = 0.5, this.rayBounces = 5, this.diamondOrientedEnvMap = 0, this.normalsCaptureMap = null, this.extraUniformsToUpload = { inverseModelMatrix: { value: new n.yGw().identity() }, radius: { value: 1 }, centerOffset: { value: new n.Pa4(0, 0, 0) }, modelOffsetMatrix: { value: new n.yGw().identity() }, modelOffsetMatrixInv: { value: new n.yGw().identity() } }, this.envMapIndex = 0, this.setDirty = this.setDirty.bind(this), this.userData.setDirty = (e3) => {
        console.warn("WebGi DiamondMaterial: userData.setDirty is deprecated. Use setDirty instead."), this.setDirty(e3);
      }, this.userData.separateEnvMapIntensity = true, this.setValues(e2), this.materialExtensions = at.RegisterExtensions(this, null !== (t2 = null == e2 ? void 0 : e2.customMaterialExtensions) && void 0 !== t2 ? t2 : []);
    }
    registerMaterialExtensions(e2) {
      this.materialExtensions = [...this.materialExtensions, ...at.RegisterExtensions(this, e2)];
    }
    unregisterMaterialExtensions(e2) {
    }
    onBeforeCompile(e2, t2) {
      at.ApplyMaterialExtensions(this, e2, this.materialExtensions, t2), this.dispatchEvent({ type: "beforeCompile", shader: e2, renderer: t2 }), e2.fragmentShader = e2.fragmentShader.replaceAll("#glMarker", "// "), e2.vertexShader = e2.vertexShader.replaceAll("#glMarker", "// "), super.onBeforeCompile(e2, t2);
    }
    customProgramCacheKey() {
      return super.customProgramCacheKey() + at.CacheKeyForExtensions(this, this.materialExtensions);
    }
    setDirty(e2) {
      var t2, n2;
      this.needsUpdate = true, this.dispatchEvent({ ...e2, type: "materialUpdate", frameFade: null == e2 ? void 0 : e2.last }), null === (n2 = null === (t2 = this._uiConfig) || void 0 === t2 ? void 0 : t2.uiRefresh) || void 0 === n2 || n2.call(t2, "postFrame", true, 1);
    }
    set envMaps(e2) {
      this.__envMap = e2, this.refreshEnvUniform();
    }
    refreshEnvUniform() {
      var e2;
      this.uniforms.envMap.value = this.envMap, this.defines.ENV_MAP_TYPE = (null === (e2 = this.uniforms.envMap.value) || void 0 === e2 ? void 0 : e2.isCubeTexture) ? 0 : 1, this.needsUpdate = true;
    }
    get envMap() {
      var e2, t2;
      return null !== (t2 = null !== (e2 = this.__envMap[this.envMapIndex]) && void 0 !== e2 ? e2 : this.__envMap[0]) && void 0 !== t2 ? t2 : null;
    }
    set envMap(e2) {
      console.error("Setting separate envmap for individual diamond material not supported yet.");
    }
    clone() {
      return super.clone();
    }
    toJSON(e2) {
      const t2 = { metadata: { version: 4.6, type: "DiamondMaterial", generator: "DiamondMaterial.toJSON" } };
      return t2.name = this.name, t2.uuid = this.uuid, t2.color = this.color.getHex(), t2.envMapIntensity = this.envMapIntensity, t2.envMapIndex = this.envMapIndex, t2.envMapRotationOffset = this.envMapRotationOffset, t2.dispersion = this.dispersion, t2.squashFactor = this.squashFactor, t2.geometryFactor = this.geometryFactor, t2.gammaFactor = this.gammaFactor, t2.absorptionFactor = this.absorptionFactor, t2.reflectivity = this.reflectivity, t2.refractiveIndex = this.refractiveIndex, t2.rayBounces = this.rayBounces, t2.diamondOrientedEnvMap = this.diamondOrientedEnvMap, t2.boostFactors = { x: this.boostFactors.x, y: this.boostFactors.y, z: this.boostFactors.z, isVector3: true }, t2.transmission = this.transmission, t2.isDiamondMaterialParameters = true, t2.type = Kl.TYPE, t2.userData = {}, K(t2.userData, this.userData), t2.userData.uuid = this.userData.uuid, t2;
    }
    get uiConfig() {
      const e2 = this;
      return this._uiConfigChildren || (this._uiConfigChildren = [{ type: "input", property: [this, "name"] }, { type: "checkbox", property: [this, "wireframe"] }, { type: "dropdown", label: "Environment", property: [this, "envMapIndex"], children: [0, 1, 2].map((e3) => ({ label: "env" + (e3 + 1), value: e3 })) }, ...He(this), { type: "input", label: "Mesh count", get value() {
        var t2, n2, r2;
        return null !== (r2 = null === (n2 = null === (t2 = e2.userData) || void 0 === t2 ? void 0 : t2.__appliedMeshes) || void 0 === n2 ? void 0 : n2.size) && void 0 !== r2 ? r2 : 0;
      }, set value(e3) {
      }, disabled: true }, { type: "input", label: "uuid", get value() {
        return e2.uuid;
      }, set value(e3) {
      }, disabled: true }, { type: "checkbox", label: "Render to Depth", hidden: () => 0 === this.transmission, get value() {
        return true === e2.userData.renderToDepth;
      }, set value(t2) {
        e2.userData.renderToDepth = t2 || void 0;
      } }, { type: "button", label: "Download .dmat", value: () => {
        const n2 = new Blob([JSON.stringify(e2.toJSON(), null, 2)], { type: "application/json" });
        (0, t.downloadBlob)(n2, "diamond-material.dmat");
      } }]), this._uiConfig || (this._uiConfig = { type: "folder", label: "Diamond Material", expanded: true, children: this._uiConfigChildren, limitedUi: true }), this._uiConfig.children = [...this._uiConfigChildren, ...this.materialExtensions.map((e3) => {
        var t2;
        return null === (t2 = e3.getUiConfig) || void 0 === t2 ? void 0 : t2.call(e3, this);
      })].filter((e3) => e3), this._uiConfig;
    }
    copyProps(e2) {
      if (!e2.isDiamondMaterialParameters && !e2.isDiamondMaterial && !e2.isDiamond && e2.type !== Kl.TYPE)
        return console.warn("WebGi DiamondMaterial: Material type is not supported", e2), this;
      const n2 = {}, r2 = Array.from(Object.keys(Xl));
      (0, t.copyProps)(e2, n2, r2);
      const i2 = n2.userData;
      return delete n2.userData, this.setValues(n2), K(this.userData, i2), this.setDirty(), this;
    }
    fromJSON(e2, t2) {
      return this.copyProps(e2);
    }
  }
  Kl.TypeSlug = "dmat", Kl.TYPE = "DiamondMaterial", Yl([Ge("Color", { limitedUi: true }), j()], Kl.prototype, "color", void 0), Yl([Ue("Env Intensity", [0, 5], 0.01, { limitedUi: true }), j()], Kl.prototype, "envMapIntensity", void 0), Yl([Ue("Env Rotation Offset", [-Math.PI, Math.PI], 0.01), (0, t.onChange2)(Kl.prototype.setDirty)], Kl.prototype, "envMapRotationOffset", void 0), Yl([Ue("Env Rotation Offset X", [-Math.PI, Math.PI], 0.01), (0, t.onChange2)(Kl.prototype.setDirty)], Kl.prototype, "envMapRotationOffsetX", void 0), Yl([Ue("Env Rotation Offset Y", [-Math.PI, Math.PI], 0.01), (0, t.onChange2)(Kl.prototype.setDirty)], Kl.prototype, "envMapRotationOffsetY", void 0), Yl([Ue("Env Rotation Offset Z", [-Math.PI, Math.PI], 0.01), (0, t.onChange2)(Kl.prototype.setDirty)], Kl.prototype, "envMapRotationOffsetZ", void 0), Yl([Ue("Dispersion", [0, 0.1], 1e-4, { limitedUi: true }), j({ propKey: "rIndexDelta" })], Kl.prototype, "dispersion", void 0), Yl([Ue("Absorption", [0, 15], 0.01, { limitedUi: true }), j()], Kl.prototype, "absorptionFactor", void 0), Yl([Ue("Refractive Index", [0, 4], 0.01, { limitedUi: true }), j()], Kl.prototype, "refractiveIndex", void 0), Yl([j()], Kl.prototype, "squashFactor", void 0), Yl([j()], Kl.prototype, "geometryFactor", void 0), Yl([Ue("Gamma", [0.1, 4], 0.01, { limitedUi: true }), j()], Kl.prototype, "gammaFactor", void 0), Yl([Fe("RGB Boost", void 0, void 0, { limitedUi: true }), j()], Kl.prototype, "boostFactors", void 0), Yl([Ue("Transmission", [0, 1], 0.01, { limitedUi: true }), j()], Kl.prototype, "transmission", void 0), Yl([Ue("Reflectivity", [0, 2], 0.01, { limitedUi: true }), j()], Kl.prototype, "reflectivity", void 0), Yl([z("RAY_BOUNCES", void 0, true), Ue("Ray Bounces", [1, 16], 1)], Kl.prototype, "rayBounces", void 0), Yl([z("DIA_ORIENT_ENVMAP", void 0, true), Ue("Diamond Oriented Lighting", [0, 1], 1)], Kl.prototype, "diamondOrientedEnvMap", void 0), Yl([j({ propKey: "tCubeMapNormals" })], Kl.prototype, "normalsCaptureMap", void 0), Yl([(0, t.onChange)(Kl.prototype.refreshEnvUniform)], Kl.prototype, "envMapIndex", void 0);
  const Jl = { ES256: { name: "ECDSA", namedCurve: "P-256", hash: { name: "SHA-256" } }, ES384: { name: "ECDSA", namedCurve: "P-384", hash: { name: "SHA-384" } }, ES512: { name: "ECDSA", namedCurve: "P-521", hash: { name: "SHA-512" } }, HS256: { name: "HMAC", hash: { name: "SHA-256" } }, HS384: { name: "HMAC", hash: { name: "SHA-384" } }, HS512: { name: "HMAC", hash: { name: "SHA-512" } }, RS256: { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-256" } }, RS384: { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-384" } }, RS512: { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-512" } } }, Zl = function(e2) {
    return JSON.parse(atob(e2.split(".")[1]));
  }, $l = async function(e2, t2, n2) {
    const r2 = Jl[n2.algorithm || "RS512"], i2 = await crypto.subtle.importKey("jwk", t2, r2, true, ["verify"]), s2 = e2.split("."), o2 = new Uint8Array(atob(s2[2].replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "")).split("").map((e3) => e3.charCodeAt(0))), a2 = new Uint8Array((s2[0] + "." + s2[1]).split("").map((e3) => e3.charCodeAt(0)));
    return await crypto.subtle.verify(r2, i2, o2, a2);
  };
  class ec {
    constructor(e2, t2) {
      this.PRODUCT_ID = "IJewel3D_WebGi_V0", this.KEY_TYPE_ID = "online-v1", this.TOKEN_FILE = "0.txt", this.PUBLIC_KEY_FILE = "1.json", this.KEY_SERVER = "https://license.ijewel3d.com", this.KEY_SERVER_VERIFY = "/api/v1/verify", this.KEY_SERVER_CERTS = "/api/v1/certs/" + this.KEY_TYPE_ID, this.id = "", this.idHash = "", this.appVersion = "", this.appName = "", this._storage = { getItem: async (e3) => localStorage.getItem(e3), setItem: async (e3, t3) => (localStorage.setItem(e3, t3), t3) }, this.silent = true, this.appVersion = t2, this.appName = e2;
    }
    _getOriginId() {
      const e2 = function(e3) {
        let t2, n2, r2, i2;
        const s2 = function(e4, t3, n3) {
          if (e4.length != t3)
            return false;
          for (let r3 = 0; r3 < t3; r3++)
            for (let t4 = 0; t4 < n3.length; t4 += 2)
              if (r3 == n3[t4] && e4.charCodeAt(r3) != n3[t4 + 1])
                return false;
          return true;
        }, o2 = function(e4, t3, n3) {
          return s2(t3, n3, e4);
        }, a2 = function(e4, t3, n3) {
          return o2(t3, e4, n3);
        };
        for (let n3 in e3)
          if (s2(n3, 8, [7, 116, 5, 101, 3, 117, 0, 100])) {
            t2 = n3;
            break;
          }
        for (let r3 in e3[t2])
          if (a2(r3, [5, 110, 0, 100], 6)) {
            n2 = r3;
            break;
          }
        for (let n3 in e3[t2])
          if (a2(n3, [7, 110, 0, 108], 8)) {
            r2 = n3;
            break;
          }
        if (!("~" > n2)) {
          for (let n3 in e3[t2][r2])
            if (o2([7, 101, 0, 104], n3, 8)) {
              i2 = n3;
              break;
            }
        }
        if (!t2 || !e3[t2])
          return;
        const l2 = e3[t2][n2], c2 = !!e3[t2][r2] && e3[t2][r2][i2], u2 = l2 || c2;
        return u2 || void 0;
      }(window);
      if (!e2)
        throw new Error("Failed to get origin");
      return e2;
    }
    _getStorage() {
      return this._storage;
    }
    async init() {
      var e2, t2;
      if (this.id = this.id || this._getOriginId(), !this.id)
        throw new Error("Failed to get machine id");
      this.idHash = await async function(e3) {
        const t3 = new TextEncoder().encode(e3), n3 = await crypto.subtle.digest("SHA-256", t3);
        return Array.from(new Uint8Array(n3)).map((e4) => e4.toString(16).padStart(2, "0")).join("");
      }(this.id);
      const n2 = this._getStorage(), r2 = this.idHash + this.TOKEN_FILE;
      let i2 = null !== (e2 = await n2.getItem(r2)) && void 0 !== e2 ? e2 : await n2.setItem(r2, "");
      const s2 = this.idHash + this.PUBLIC_KEY_FILE, o2 = null !== (t2 = await n2.getItem(s2)) && void 0 !== t2 ? t2 : null;
      let a2 = await this.getPublicKey().catch(() => null);
      return !a2 && o2 && (a2 = JSON.parse(o2)), a2 !== o2 && await n2.setItem(s2, JSON.stringify(a2)), a2 || this._throw(new Error("Failed to get public key")), { token: i2, publicKey: a2 };
    }
    async verify(e2, t2) {
      var n2;
      try {
        let r2, i2 = (t2 = null != t2 ? t2 : await this.init()).token;
        i2 && !await $l(i2, t2.publicKey, { algorithm: "RS512", throwError: false }) && (i2 = ""), i2 && (r2 = Zl(i2), (null === (n2 = r2.payload) || void 0 === n2 ? void 0 : n2.key) !== e2 && (i2 = "")), i2 && i2.length || (i2 = await this.setLicenseKey(e2)), r2 = Zl(i2);
        let s2 = false;
        return s2 = s2 || await $l(i2, t2.publicKey, { algorithm: "RS512", throwError: false }), s2 = s2 || await this.verifyData(r2), s2;
      } catch (e3) {
        return this.silent || console.error(e3), false;
      }
    }
    async writeToken(e2) {
      const t2 = this.idHash + this.TOKEN_FILE;
      await this._getStorage().setItem(t2, e2);
    }
    async verifyData(e2) {
      var t2, n2, r2;
      return (null === (t2 = e2.payload) || void 0 === t2 ? void 0 : t2.sub) === this.id && (null === (n2 = e2.payload) || void 0 === n2 ? void 0 : n2.app) === this.appName + "_" + this.appVersion && (null === (r2 = e2.payload) || void 0 === r2 ? void 0 : r2.pid) === this.PRODUCT_ID;
    }
    async _getPublicKeyFromServer() {
      return fetch(this.KEY_SERVER + this.KEY_SERVER_CERTS).then((e2) => e2.json()).catch((e2) => ({ error: e2 }));
    }
    async _validateKeyFromServer(e2) {
      return await fetch(this.KEY_SERVER + this.KEY_SERVER_VERIFY, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ key: e2, id: this.id, app: { name: this.appName, version: this.appVersion }, pid: this.PRODUCT_ID }) }).then((e3) => e3.json()).catch((e3) => ({ error: e3 }));
    }
    _throw(e2) {
      if (!this.silent)
        throw e2;
      return null;
    }
    async setLicenseKey(e2) {
      const t2 = await this._validateKeyFromServer(e2);
      if (t2.error)
        return this._throw(t2.error);
      const n2 = t2.token;
      return n2 ? (await this.writeToken(n2), n2) : this._throw(new Error("Invalid license key, no token"));
    }
    async getPublicKey() {
      const e2 = await this._getPublicKeyFromServer();
      if (e2.error)
        return this._throw(e2.error);
      return e2.jwk || this._throw(new Error("Invalid public key"));
    }
  }
  var tc = __webpackgi_require__2(701), nc = __webpackgi_require__2.n(tc), rc = __webpackgi_require__2(236), ic = __webpackgi_require__2.n(rc), sc = __webpackgi_require__2(850), oc = __webpackgi_require__2.n(sc), ac = __webpackgi_require__2(182), lc = __webpackgi_require__2.n(ac), cc = __webpackgi_require__2(213), uc = __webpackgi_require__2.n(cc), pc = __webpackgi_require__2(27), dc = {};
  pc.Z && pc.Z.locals && (dc.locals = pc.Z.locals);
  var hc, fc = 0, mc = {};
  mc.styleTagTransform = uc(), mc.setAttributes = oc(), mc.insert = function(e2, t2) {
    (t2.target || document.head).appendChild(e2);
  }, mc.domAPI = ic(), mc.insertStyleElement = lc(), dc.use = function(e2) {
    return mc.options = e2 || {}, fc++ || (hc = nc()(pc.Z, mc)), dc;
  }, dc.unuse = function() {
    fc > 0 && !--fc && (hc(), hc = null);
  };
  var _c = dc, gc = __webpackgi_require__2(356), vc = {};
  gc.Z && gc.Z.locals && (vc.locals = gc.Z.locals);
  var yc, bc = 0, wc = {};
  wc.styleTagTransform = uc(), wc.setAttributes = oc(), wc.insert = function(e2, t2) {
    (t2.target || document.head).appendChild(e2);
  }, wc.domAPI = ic(), wc.insertStyleElement = lc(), vc.use = function(e2) {
    return wc.options = e2 || {}, bc++ || (yc = nc()(gc.Z, wc)), vc;
  }, vc.unuse = function() {
    bc > 0 && !--bc && (yc(), yc = null);
  };
  var Ac = vc;
  class xc extends gt {
    _onEnabledChange() {
      this.enabled || (this._mainDiv.style.display = "none");
    }
    constructor(e2, n2) {
      super(), this.container = n2, this.enabled = true, this.dependencies = [Ls], this.processState = /* @__PURE__ */ new Map(), this._mainDiv = (0, t.createDiv)({ id: "assetManager" + e2, addToBody: false, innerHTML: "" }), this._contentDiv = (0, t.createDiv)({ id: "assetManager" + e2 + "Content", addToBody: false, innerHTML: "" }), this.enabled || (this._mainDiv.style.display = "none"), this._mainDiv.appendChild(this._contentDiv);
    }
    async onAdded(e2) {
      var t2, n2, r2, i2, s2, o2, a2, l2, c2, u2, p2, d2, h2;
      await super.onAdded(e2), (null !== (t2 = this.container) && void 0 !== t2 ? t2 : e2.container).appendChild(this._mainDiv), this._updateMainDiv(this.processState), null === (r2 = null === (n2 = e2.getManager()) || void 0 === n2 ? void 0 : n2.importer) || void 0 === r2 || r2.addEventListener("importFile", (e3) => {
        "done" !== e3.state ? this.processState.set(e3.path, { state: e3.state, progress: e3.progress ? 100 * e3.progress : void 0 }) : this.processState.delete(e3.path), this._updateMainDiv(this.processState);
      }), null === (s2 = null === (i2 = e2.getManager()) || void 0 === i2 ? void 0 : i2.importer) || void 0 === s2 || s2.addEventListener("processFileStart", (e3) => {
        this.processState.set(e3.path, { state: "processing", progress: void 0 }), this._updateMainDiv(this.processState);
      }), null === (a2 = null === (o2 = e2.getManager()) || void 0 === o2 ? void 0 : o2.importer) || void 0 === a2 || a2.addEventListener("processFileEnd", (e3) => {
        this.processState.delete(e3.path), this._updateMainDiv(this.processState);
      }), null === (c2 = null === (l2 = e2.getManager()) || void 0 === l2 ? void 0 : l2.exporter) || void 0 === c2 || c2.addEventListener("exportFile", (e3) => {
        "done" !== e3.state ? this.processState.set(e3.obj.name, { state: e3.state, progress: e3.progress ? 100 * e3.progress : void 0 }) : this.processState.delete(e3.obj.name), this._updateMainDiv(this.processState);
      }), null === (u2 = e2.getPluginByType("FileTransferPlugin")) || void 0 === u2 || u2.addEventListener("transferFile", (e3) => {
        "done" !== e3.state ? this.processState.set(e3.path, { state: e3.state, progress: e3.progress ? 100 * e3.progress : void 0 }) : this.processState.delete(e3.path), this._updateMainDiv(this.processState);
      }), null === (p2 = e2.getPluginByType("MaterialConfiguratorPlugin")) || void 0 === p2 || p2.addEventListener("progress", (e3) => {
        "done" !== e3.state ? this.processState.set("MatpreviewGeneration", { state: e3.state, progress: 0 }) : this.processState.delete("MatpreviewGeneration"), this._updateMainDiv(this.processState);
      }), null === (d2 = e2.getPluginByType("SwitchNodePlugin")) || void 0 === d2 || d2.addEventListener("progress", (e3) => {
        "done" !== e3.state ? this.processState.set("SwitchNodeGeneration", { state: e3.state, progress: 0 }) : this.processState.delete("SwitchNodeGeneration"), this._updateMainDiv(this.processState);
      }), null === (h2 = e2.getPluginByType("ThemePlugin")) || void 0 === h2 || h2.addEventListener("progress", (e3) => {
        "done" !== e3.state ? this.processState.set("ThemeInit", { state: e3.state, progress: 0 }) : this.processState.delete("ThemeInit"), this._updateMainDiv(this.processState);
      });
    }
    async onRemove(e2) {
      var t2;
      return this._mainDiv.remove(), null === (t2 = this._contentDiv) || void 0 === t2 || t2.remove(), this.processState.clear(), super.onRemove(e2);
    }
  }
  !function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    s2 > 3 && o2 && Object.defineProperty(t2, n2, o2);
  }([Oe("Enabled"), (0, t.onChange)(xc.prototype._onEnabledChange), ie()], xc.prototype, "enabled", void 0);
  var Ec, Cc = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let Sc = Ec = class extends xc {
    refresh() {
      this._updateMainDiv(this._isPreviewing ? this._previewState : this.processState, false);
    }
    togglePreview() {
      this.maximize(), this._isPreviewing = !this._isPreviewing, this.refresh(), this._isPreviewing ? this.show() : this.hideWithDelay();
    }
    constructor(e2) {
      super("LoadingScreen", e2), this.styles = _c, this.spinners = [{ styles: Ac, html: '<span class="loader"></span>' }], this.loader = 0, this.loadingTextHeader = "Loading Files", this.errorTextHeader = "Error Loading Files", this.showFileNames = true, this.showProcessStates = true, this.showProgress = true, this.hideOnOnlyErrors = true, this.hideOnFilesLoad = true, this.hideOnSceneObjectLoad = false, this.minimizeOnSceneObjectLoad = true, this.showOnFilesLoading = true, this.showOnSceneEmpty = true, this.hideDelay = 500, this.backgroundOpacity = 0.5, this.backgroundBlur = 24, this.background = "#ffffff", this.textColor = "#222222", this.logoImage = "https://static.webgi.xyz/logo.svg", this._isPreviewing = false, this._previewState = /* @__PURE__ */ new Map([["file.glb", { state: "downloading", progress: 50 }], ["environment.hdr", { state: "adding" }]]), this.loadingElement = (0, t.createDiv)({ classList: ["loadingScreenLoadingElement"], addToBody: false }), this.filesElement = (0, t.createDiv)({ classList: ["loadingScreenFilesElement"], addToBody: false }), this.logoElement = (0, t.createDiv)({ classList: ["loadingScreenLogoElement"], addToBody: false }), this._isHidden = false, this._temp = document.createElement("template"), this._sceneUpdate = (e3) => {
        if (!this._viewer)
          return;
        if (!e3.hierarchyChanged)
          return;
        const n2 = this._viewer.scene.modelRoot.children;
        0 === n2.length && this.showOnSceneEmpty && this.show(), n2.length > 0 ? this.hideOnSceneObjectLoad ? this.hideWithDelay() : this.minimizeOnSceneObjectLoad && this._viewer.scene.environment && (0, t.timeout)(this.hideDelay + 300).then(() => this.minimize()) : this.minimizeOnSceneObjectLoad && this.maximize();
      }, this._mainDiv.prepend(this.loadingElement), this._mainDiv.prepend(this.logoElement), this._mainDiv.appendChild(this.filesElement);
    }
    async hide() {
      this._isHidden = true, this._mainDiv.style.opacity = "0", await (0, t.timeout)(502), this._isHidden && (this._mainDiv.style.display = "none", this._showMainDiv());
    }
    async hideWithDelay() {
      if (this._isHidden = true, await (0, t.timeout)(this.hideDelay), this._isHidden)
        return this.hide();
    }
    show() {
      this._isHidden && (this._isHidden = false, this._showMainDiv(), this._mainDiv.style.display = "flex");
    }
    _showMainDiv() {
      this._mainDiv.style.opacity = "1";
    }
    minimize() {
      this._mainDiv.classList.add("minimizedLoadingScreen"), this.showFileNames || (this.loadingElement.style.display = "block");
    }
    maximize() {
      this._mainDiv.classList.remove("minimizedLoadingScreen"), this.loadingElement.style.display = "";
    }
    _setHTML(e2, t2) {
      this._temp.innerHTML = t2, this._temp.innerHTML.trim() == e2.innerHTML.trim() || (e2.innerHTML = t2);
    }
    _updateMainDiv(e2, t2 = true) {
      if (!this._viewer)
        return;
      if (!this._contentDiv)
        return;
      if (!this.enabled)
        return void (this._mainDiv.style.display = "none");
      if (this.showFileNames) {
        let t3 = "";
        e2.forEach((e3, n3) => {
          t3 += (this.showProcessStates ? `<span class="loadingScreenProcessState">${e3.state}</span>: ` : "") + (n3 || "").split("/").pop() + (this.showProgress && e3.progress ? " - " + e3.progress.toFixed(0) + "%" : "") + "<br>";
        }), this._setHTML(this.filesElement, t3);
      } else
        this._setHTML(this.filesElement, "");
      const n2 = [...e2.values()].filter((e3) => "error" === e3.state);
      n2.length > 0 && n2.length === e2.size && !this.hideOnOnlyErrors ? this._setHTML(this._contentDiv, this.errorTextHeader) : this._setHTML(this._contentDiv, this.loadingTextHeader), this._setHTML(this.loadingElement, this.spinners[this.loader].html), this._mainDiv.style.setProperty("--b-opacity", this.backgroundOpacity.toString()), this._mainDiv.style.setProperty("--b-background", this.background), this._mainDiv.style.backdropFilter = `blur(${this.backgroundBlur}px)`, this._mainDiv.style.color = this.textColor, this._setHTML(this.logoElement, this.logoImage ? `<img class="loadingScreenLogoImage" src="${this.logoImage}"/>` : ""), t2 && (this.hideOnFilesLoad && (0 === e2.size || n2.length === e2.size && this.hideOnOnlyErrors) ? this.hideDelay ? this.hideWithDelay() : this.hide() : e2.size > 0 && this.showOnFilesLoading && this.show());
    }
    async onAdded(e2) {
      var t2;
      this.styles.use({ target: null !== (t2 = this.container) && void 0 !== t2 ? t2 : e2.container }), this.spinners.forEach((t3) => {
        var n2;
        t3.styles.use({ target: null !== (n2 = this.container) && void 0 !== n2 ? n2 : e2.container });
      }), e2.scene.addEventListener("sceneUpdate", this._sceneUpdate), await super.onAdded(e2);
    }
    async onRemove(e2) {
      e2.scene.removeEventListener("sceneUpdate", this._sceneUpdate), await super.onRemove(e2);
    }
  };
  Sc.PluginType = "LoadingScreenPlugin", Cc([Ne("Loader", ["Spinner 1"].map((e2, t2) => ({ value: t2, label: e2 }))), ie()], Sc.prototype, "loader", void 0), Cc([ze("Loading text header"), (0, t.onChange)(Ec.prototype.refresh), ie()], Sc.prototype, "loadingTextHeader", void 0), Cc([ze("Error text header"), ie()], Sc.prototype, "errorTextHeader", void 0), Cc([Oe("Show file names"), ie(), (0, t.onChange)(Ec.prototype.refresh)], Sc.prototype, "showFileNames", void 0), Cc([Oe("Show process states"), ie(), (0, t.onChange)(Ec.prototype.refresh)], Sc.prototype, "showProcessStates", void 0), Cc([Oe("Show progress"), ie(), (0, t.onChange)(Ec.prototype.refresh)], Sc.prototype, "showProgress", void 0), Cc([Oe("Hide on only errors"), ie()], Sc.prototype, "hideOnOnlyErrors", void 0), Cc([Oe("Hide on files load"), ie()], Sc.prototype, "hideOnFilesLoad", void 0), Cc([Oe("Hide on scene object load"), ie()], Sc.prototype, "hideOnSceneObjectLoad", void 0), Cc([Oe("Minimize on scene object load"), ie()], Sc.prototype, "minimizeOnSceneObjectLoad", void 0), Cc([Oe("Show when files start loading"), ie()], Sc.prototype, "showOnFilesLoading", void 0), Cc([Oe("Show when scene empty"), ie()], Sc.prototype, "showOnSceneEmpty", void 0), Cc([ze("Hide delay (ms)"), ie()], Sc.prototype, "hideDelay", void 0), Cc([Ue("Background Opacity", [0, 1]), (0, t.onChange)(Ec.prototype.refresh), ie()], Sc.prototype, "backgroundOpacity", void 0), Cc([Ue("Background Blur", [0, 100]), (0, t.onChange)(Ec.prototype.refresh), ie()], Sc.prototype, "backgroundBlur", void 0), Cc([ze("Background Color"), (0, t.onChange)(Ec.prototype.refresh), ie()], Sc.prototype, "background", void 0), Cc([ze("Text Color"), (0, t.onChange)(Ec.prototype.refresh), ie()], Sc.prototype, "textColor", void 0), Cc([ze("Logo Image"), (0, t.onChange)(Ec.prototype.refresh), ie()], Sc.prototype, "logoImage", void 0), Cc([je("Toggle preview")], Sc.prototype, "togglePreview", null), Cc([je("Minimize")], Sc.prototype, "minimize", null), Cc([je("Maximize")], Sc.prototype, "maximize", null), Sc = Ec = Cc([We("Loading Screen")], Sc);
  const Mc = "iJewel3dSDK_WebGi", Tc = zs.VERSION, Pc = "https://playground.ijewel3d.com/logo_black.svg", Ic = (e2) => setTimeout(() => console.error(new Error(e2)), 612);
  class Rc extends gt {
    setKey(e2) {
      this._checking || this._checkPromise ? console.warn("Already checking key, ignored") : (this._checking = Date.now(), this._checkPromise = this._check(e2), this._checkPromise.then(() => this._checkPromise = void 0));
    }
    async _check(e2) {
      const t2 = new ec(Mc, Tc);
      await t2.verify(e2) || (Ic(this._errMessage), this._logoContainer = this._createContainerLogo());
    }
    _createContainerLogo() {
      const e2 = document.createElement("div");
      e2.innerHTML = kc, e2.style.position = "absolute", e2.style.padding = "1rem", e2.style.left = "0", e2.style.bottom = "0", e2.style.width = "100%", e2.style.height = "auto", e2.style.display = "flex", e2.style.alignItems = "center", e2.style.backgroundColor = "rgba(0, 0, 0, 0)", e2.style.zIndex = "9999", e2.style.pointerEvents = "none";
      const t2 = e2.children[0];
      t2.style.width = "calc(min(20%, 150px))", t2.style.height = "auto", t2.onclick = () => {
        window.open("https://ijewel3d.com/", "_top");
      }, this._logoContainer = e2;
      const n2 = document.getElementById("webgi-logo");
      return n2 && n2.remove(), e2;
    }
    constructor() {
      super(), this._errMessage = `iJewel3D ${Mc} ${Tc}. FOR EVALUATION PURPOSES ONLY. For more information visit: https://ijewel3d.com/`, this._checking = 0, this._licenseInUse = false, setInterval(() => {
        var e2;
        if (this._checkPromise) {
          const e3 = 15e3;
          Date.now() - this._checking > e3 && (Ic(this._errMessage), this._logoContainer = this._createContainerLogo(), "function" == typeof this._checkPromise.cancel && this._checkPromise.cancel(), this._checkPromise = void 0);
        }
        if (this._logoContainer && !this._logoContainer.parentElement && this._viewer && this._licenseInUse) {
          this._lContainer.appendChild(this._logoContainer);
          const t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPlugin(Sc);
          t2 && (t2.logoImage = Pc);
        }
      }, 5e3);
    }
    get _lContainer() {
      var e2;
      const t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.container;
      if (!t2)
        return document.body;
      const n2 = window.getComputedStyle(t2).position;
      return "absolute" !== n2 && "relative" !== n2 && "fixed" !== n2 ? document.body : t2;
    }
    use() {
      var e2;
      if (!this._licenseInUse && (this._licenseInUse = true, !this._checking)) {
        Ic(this._errMessage), this._logoContainer = this._createContainerLogo(), this._lContainer.appendChild(this._logoContainer);
        const t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPlugin(Sc);
        t2 && (t2.logoImage = Pc);
      }
    }
    unuse() {
    }
    async onAdded(e2) {
      await super.onAdded(e2);
    }
  }
  const kc = '\n<!--Notice - iJewel3D License Required to remove attribution. Check the details at https://developer.ijewel3d.com/ -->\n<svg width="320" height="150" viewBox="0 0 320 150" fill="none" xmlns="http://www.w3.org/2000/svg">\n<g filter="url(#filter0_d_2013_189)">\n<path d="M63.0313 37.6615C63.0313 37.0497 62.8369 36.5115 62.4485 36.0465C62.0601 35.5815 61.5625 35.2879 60.9555 35.1411L71.2491 30.8711V79.1495C71.2491 82.3555 70.4357 85.2195 68.7971 87.7275C67.1705 90.2355 64.7063 91.5315 61.4047 91.6175C57.6903 91.3975 55.0441 89.5015 53.4295 85.9275C52.7983 84.4475 52.4707 82.9315 52.4707 81.3655H53.2961C53.2961 82.8455 53.5873 84.2395 54.1701 85.5495C54.8013 86.6875 55.7967 87.4335 57.1319 87.7635C58.4793 88.0935 59.6809 87.9715 60.7613 87.3835C61.5139 86.9075 62.0359 86.1115 62.3635 84.9995C62.6791 83.8855 62.8735 82.7715 62.9219 81.6455C62.9827 80.5335 63.0069 79.7375 63.0069 79.2595L63.0313 37.6615Z" fill="white"/>\n<path d="M49.4 38.5287C49.4 37.9169 49.2056 37.3785 48.8172 36.9137C48.4288 36.4487 47.9312 36.1551 47.3242 36.0083L57.6178 31.7383V65.5675L49.4 69.8375V38.5287Z" fill="white"/>\n<path d="M106.949 51.1695H82.6592C82.5742 54.4355 83.3026 57.6775 84.8442 60.8955C86.3736 64.1135 88.9228 66.1455 92.4672 66.9895C96.8372 67.5515 100.77 66.4635 104.254 63.7215C104.861 63.1595 105.419 62.5475 105.917 61.8755C105.977 61.7895 106.05 61.7395 106.172 61.7035C106.281 61.6795 106.39 61.7035 106.499 61.7895C106.584 61.8495 106.633 61.9235 106.669 62.0335C106.694 62.1435 106.669 62.2535 106.584 62.3635C106.062 63.0375 105.492 63.6735 104.885 64.2855C101.595 67.9675 97.4562 70.1695 92.4794 70.8915C86.8834 71.0875 82.5014 69.1175 79.2968 64.9695C76.1044 60.8355 74.3928 56.2455 74.1744 51.2295C74.0044 47.2171 74.8178 43.4487 76.6264 39.9495C78.4228 36.4503 81.239 33.9055 85.0506 32.3149C88.1824 31.1403 91.3748 30.7977 94.64 31.2627C99.2284 32.2415 102.567 34.8231 104.642 39.0075C106.257 42.5923 107.034 46.3117 106.949 50.2147V51.1695ZM82.6592 50.3369H98.3544C98.3788 50.2759 98.3908 50.2391 98.3908 50.2147C99.6896 46.7521 100.382 43.3875 100.467 40.0841C100.333 36.0711 98.318 33.4405 94.4458 32.2171C89.8818 31.3239 86.495 32.9267 84.2736 37.0253C82.9748 40.6225 82.4286 44.3663 82.6592 48.2449V50.3369Z" fill="white"/>\n<path d="M168.843 32.9737C169.013 32.4965 168.965 32.0561 168.721 31.6523C168.467 31.2485 168.091 31.0283 167.557 31.0039H172.581C171.223 31.1139 170.275 31.7991 169.717 33.0593L155.429 70.4619L155.637 71.0119H146.799L138.411 48.9647L130.193 70.4619L130.401 71.0119H121.564L107.155 33.1817C106.597 31.8969 105.638 31.1751 104.254 31.0039H117.206C116.708 31.0649 116.332 31.2853 116.065 31.6889C115.798 32.0927 115.749 32.5455 115.919 33.0471L129.781 69.2879L137.963 47.8269L132.403 33.1817C131.845 31.8969 130.885 31.1751 129.501 31.0039H142.417C142.029 31.0649 141.713 31.2363 141.459 31.5299C141.203 31.8235 141.083 32.1539 141.083 32.5087C141.083 32.8635 141.107 32.8513 141.167 33.0471L142.417 36.2281L142.829 37.4027L155.029 69.2879L168.843 32.9737Z" fill="white"/>\n<path d="M202.55 51.1695H178.262C178.176 54.4355 178.904 57.6775 180.434 60.8955C181.976 64.1135 184.512 66.1455 188.058 66.9895C192.428 67.5515 196.36 66.4635 199.844 63.7215C200.45 63.1595 201.01 62.5475 201.506 61.8755C201.556 61.7895 201.64 61.7395 201.762 61.7035C201.872 61.6795 201.98 61.7035 202.09 61.7895C202.174 61.8495 202.224 61.9235 202.26 62.0335C202.284 62.1435 202.26 62.2535 202.174 62.3635C201.652 63.0375 201.082 63.6735 200.476 64.2855C197.186 67.9675 193.046 70.1695 188.07 70.8915C182.474 71.0875 178.092 69.1175 174.888 64.9695C171.694 60.8355 169.984 56.2455 169.764 51.2295C169.594 47.2171 170.42 43.4487 172.216 39.9495C174.014 36.4503 176.83 33.9055 180.64 32.3149C183.772 31.1403 186.964 30.7977 190.23 31.2627C194.818 32.2415 198.156 34.8231 200.232 39.0075C201.858 42.5923 202.636 46.3117 202.55 50.2147V51.1695ZM178.262 50.3369H193.956C193.982 50.2759 193.994 50.2391 193.994 50.2147C195.292 46.7521 195.984 43.3875 196.068 40.0841C195.936 36.0711 193.92 33.4405 190.048 32.2171C185.484 31.3239 182.086 32.9267 179.876 37.0253C178.578 40.6225 178.03 44.3663 178.262 48.2449V50.3369Z" fill="white"/>\n<path d="M214.3 68.798C214.3 69.386 214.494 69.886 214.884 70.302C215.272 70.718 215.758 70.964 216.34 71.012H204.006C204.59 70.952 205.076 70.73 205.464 70.328C205.852 69.924 206.046 69.434 206.046 68.846V17.4478C206.046 16.8606 205.852 16.3588 205.464 15.9184C205.076 15.4902 204.59 15.2332 204.006 15.1476L214.3 11V68.798Z" fill="white"/>\n<path d="M60.2022 15.5255L57.1676 13.2007C57.1554 13.1885 57.1432 13.1885 57.1312 13.1763C57.119 13.1641 57.0946 13.1641 57.0826 13.1641H49.1196C49.0954 13.1641 49.0832 13.1641 49.071 13.1763C49.059 13.1885 49.0468 13.1885 49.0346 13.2007L46 15.5255H60.2022Z" fill="white"/>\n<path d="M46.0977 16.0044L52.9925 22.1586H53.0047C53.0167 22.1708 53.0289 22.1708 53.0411 22.183C53.0531 22.183 53.0775 22.1952 53.0897 22.1952C53.1017 22.1952 53.1261 22.1954 53.1381 22.183C53.1503 22.183 53.1625 22.1708 53.1745 22.1586H53.1867L60.0815 15.9922H46.0977V16.0044Z" fill="white"/>\n<path d="M237.681 55.6091C237.293 55.6091 237.183 55.4611 237.183 55.1691C237.183 54.7531 237.377 54.4211 237.681 54.4211C237.985 54.4211 238.785 54.6431 239.817 54.6431C241.613 54.6431 242.937 53.2111 242.937 50.8739C242.937 48.5369 242.719 48.3901 240.947 48.3901C239.173 48.3901 238.785 49.4791 238.215 50.9227C238.021 51.3631 237.827 51.4971 237.523 51.4971C237.219 51.4971 236.589 51.1551 236.589 50.5067C236.589 49.2465 238.457 47.7539 241.019 47.7539C243.581 47.7539 245.267 48.5003 245.267 51.1311C245.267 53.7611 242.937 54.7531 241.213 54.8991V54.9971C242.719 55.2671 244.479 56.3311 244.479 58.4711C244.479 62.0191 241.601 63.4511 238.627 63.4511C235.653 63.4511 234.027 61.7391 234.027 60.6251C234.027 59.5111 234.621 59.3651 235.157 59.3651C235.691 59.3651 235.679 59.6091 235.799 60.0631C236.297 61.8971 237.099 62.8151 238.725 62.8151C240.351 62.8151 242.027 61.5791 242.027 58.1771C242.027 54.7771 241.553 55.4011 239.611 55.4011C238.689 55.4011 237.997 55.6091 237.681 55.6091Z" fill="white"/>\n<path d="M259.105 45.918L259.203 45.9914L255.513 61.1146C255.317 61.8366 255.293 62.3746 255.707 62.3746C256.325 62.3746 257.333 60.7586 257.745 59.9386L258.219 60.2826C257.455 62.0186 256.229 63.5006 254.601 63.5006C252.975 63.5006 253.255 62.5086 253.667 60.8946C253.885 60.0986 254.105 59.2786 254.287 58.4706H254.237C252.915 60.9066 250.997 63.5006 248.387 63.5006C245.777 63.5006 246.201 61.9826 246.201 60.4786C246.201 57.7246 248.521 51.7786 253.825 51.7786C259.129 51.7786 255.305 52.0226 255.695 52.2686L256.727 47.9002C256.895 47.1782 256.871 47.0314 256.313 46.9826L254.991 46.8356L255.087 46.4198L259.105 45.918ZM249.491 62.3506C251.603 62.3506 254.261 57.7866 254.979 55.0086C255.123 54.3606 255.391 53.5166 255.525 52.9286C255.257 52.7566 254.663 52.5126 253.971 52.5126C250.377 52.5126 248.387 58.2146 248.387 60.6726C248.387 61.8106 248.775 62.3366 249.491 62.3506Z" fill="white"/>\n<path d="M257.663 71.0129H235.571C226.649 71.0129 219.389 63.6969 219.389 54.7029C219.389 45.7109 226.649 38.3945 235.571 38.3945H257.663C266.585 38.3945 273.843 45.7109 273.843 54.7029C273.843 63.6969 266.585 71.0129 257.663 71.0129ZM235.571 39.3855C227.183 39.3855 220.361 46.2615 220.361 54.7149C220.361 63.1709 227.183 70.0469 235.571 70.0469H257.663C266.051 70.0469 272.871 63.1709 272.871 54.7149C272.871 46.2615 266.051 39.3855 257.663 39.3855H235.571Z" fill="white"/>\n</g>\n<g filter="url(#filter1_d_2013_189)">\n<path d="M17.656 134.564H15.892C13.54 131.344 12 126.584 12 121.768C12 117.148 13.484 112.332 15.892 109H17.656C15.5 112.024 13.988 116.728 13.988 121.768C13.988 126.696 15.444 131.484 17.656 134.564Z" fill="white"/>\n<path d="M32.1018 130.169H20.0898V110.121H32.0738V111.969H22.1059V119.193H31.1498V121.013H22.1059V128.321H32.1018V130.169Z" fill="white"/>\n<path d="M41.7111 130.169L34.0391 110.121H36.1951L41.5431 124.065C41.9631 125.157 42.3551 126.249 42.8031 127.649C43.2231 126.193 43.7271 124.793 44.0351 124.037L49.3551 110.121H51.4271L43.8111 130.169H41.7111Z" fill="white"/>\n<path d="M51.5889 130.169H49.5449L56.9089 110.121H59.4009L66.8489 130.169H64.7489L62.7889 124.849H53.5489L51.5889 130.169ZM57.8889 112.949L54.1649 123.085H62.1449L58.3929 112.949C58.3089 112.669 58.1689 112.333 58.1409 112.137C58.1129 112.305 58.0009 112.669 57.8889 112.949Z" fill="white"/>\n<path d="M71.6527 110.121V128.321H80.8647V130.169H69.6367V110.121H71.6527Z" fill="white"/>\n<path d="M82.8945 123.197V110.121H84.9105V123.113C84.9105 126.641 86.8425 128.545 90.3425 128.545C93.7585 128.545 95.6905 126.585 95.6905 123.113V110.121H97.7065V123.197C97.7065 127.733 94.9065 130.505 90.3425 130.505C85.6945 130.505 82.8945 127.761 82.8945 123.197Z" fill="white"/>\n<path d="M101.601 130.169H99.5566L106.921 110.121H109.413L116.861 130.169H114.761L112.801 124.849H103.561L101.601 130.169ZM107.901 112.949L104.177 123.085H112.157L108.405 112.949C108.321 112.669 108.181 112.333 108.153 112.137C108.125 112.305 108.013 112.669 107.901 112.949Z" fill="white"/>\n<path d="M115.715 111.969V110.121H130.079V111.969H123.891V130.169H121.875V111.969H115.715Z" fill="white"/>\n<path d="M134.872 110.121V130.169H132.855V110.121H134.872Z" fill="white"/>\n<path d="M157.609 120.146C157.609 126.222 153.662 130.506 148.062 130.506C142.434 130.506 138.514 126.222 138.514 120.146C138.514 114.07 142.462 109.758 148.062 109.758C153.69 109.758 157.609 114.042 157.609 120.146ZM155.537 120.146C155.537 115.134 152.486 111.718 148.062 111.718C143.638 111.718 140.614 115.134 140.614 120.146C140.614 125.158 143.638 128.574 148.062 128.574C152.486 128.574 155.537 125.13 155.537 120.146Z" fill="white"/>\n<path d="M163.28 130.169H161.264V110.121H163.308L174.34 126.809V110.121H176.328V130.169H174.34L163.28 113.481V130.169Z" fill="white"/>\n<path d="M194.508 130.169L186.836 110.121H188.992L194.34 124.065C194.76 125.157 195.152 126.249 195.6 127.649C196.02 126.193 196.524 124.793 196.832 124.037L202.152 110.121H204.224L196.608 130.169H194.508Z" fill="white"/>\n<path d="M218.94 130.169H206.928V110.121H218.912V111.969H208.944V119.193H217.988V121.013H208.944V128.321H218.94V130.169Z" fill="white"/>\n<path d="M225.051 130.169H223.035V110.121H230.511C234.571 110.121 237.035 112.361 237.035 115.917C237.035 118.801 235.523 120.817 232.947 121.517L237.231 130.169H234.991L230.903 121.853H225.051V130.169ZM225.051 111.941V120.033H230.567C233.339 120.033 234.963 118.521 234.963 115.973C234.963 113.369 233.255 111.941 230.511 111.941H225.051Z" fill="white"/>\n<path d="M239.74 115.33C239.74 111.97 242.428 109.758 246.46 109.758C250.072 109.758 252.452 111.774 252.76 115.134H250.716C250.492 112.866 248.952 111.578 246.432 111.578C243.604 111.578 241.756 113.034 241.756 115.302C241.756 117.066 242.792 118.186 244.892 118.718L248.336 119.558C251.472 120.314 253.096 122.106 253.096 124.822C253.096 128.294 250.408 130.506 246.264 130.506C242.372 130.506 239.74 128.462 239.488 125.186H241.56C241.672 127.286 243.52 128.658 246.264 128.658C249.204 128.658 251.08 127.23 251.08 124.934C251.08 123.142 250.072 121.966 247.916 121.462L244.528 120.622C241.392 119.866 239.74 118.074 239.74 115.33Z" fill="white"/>\n<path d="M258.739 110.121V130.169H256.723V110.121H258.739Z" fill="white"/>\n<path d="M281.477 120.146C281.477 126.222 277.529 130.506 271.929 130.506C266.301 130.506 262.381 126.222 262.381 120.146C262.381 114.07 266.329 109.758 271.929 109.758C277.557 109.758 281.477 114.042 281.477 120.146ZM279.405 120.146C279.405 115.134 276.353 111.718 271.929 111.718C267.505 111.718 264.481 115.134 264.481 120.146C264.481 125.158 267.505 128.574 271.929 128.574C276.353 128.574 279.405 125.13 279.405 120.146Z" fill="white"/>\n<path d="M287.149 130.169H285.133V110.121H287.177L298.209 126.809V110.121H300.197V130.169H298.209L287.149 113.481V130.169Z" fill="white"/>\n<path d="M304.42 134.564H302.656C304.868 131.484 306.352 126.696 306.352 121.768C306.352 116.728 304.812 112.024 302.656 109H304.42C306.856 112.332 308.312 117.148 308.312 121.768C308.312 126.584 306.772 131.344 304.42 134.564Z" fill="white"/>\n</g>\n<defs>\n<filter id="filter0_d_2013_189" x="35" y="4" width="249.842" height="102.617" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">\n<feFlood flood-opacity="0" result="BackgroundImageFix"/>\n<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>\n<feOffset dy="4"/>\n<feGaussianBlur stdDeviation="5.5"/>\n<feComposite in2="hardAlpha" operator="out"/>\n<feColorMatrix type="matrix" values="0 0 0 0 0.123486 0 0 0 0 0.123486 0 0 0 0 0.123486 0 0 0 0.45 0"/>\n<feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow_2013_189"/>\n<feBlend mode="normal" in="SourceGraphic" in2="effect1_dropShadow_2013_189" result="shape"/>\n</filter>\n<filter id="filter1_d_2013_189" x="1" y="102" width="318.312" height="47.5625" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">\n<feFlood flood-opacity="0" result="BackgroundImageFix"/>\n<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>\n<feOffset dy="4"/>\n<feGaussianBlur stdDeviation="5.5"/>\n<feComposite in2="hardAlpha" operator="out"/>\n<feColorMatrix type="matrix" values="0 0 0 0 0.123486 0 0 0 0 0.123486 0 0 0 0 0.123486 0 0 0 0.45 0"/>\n<feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow_2013_189"/>\n<feBlend mode="normal" in="SourceGraphic" in2="effect1_dropShadow_2013_189" result="shape"/>\n</filter>\n</defs>\n</svg>\n';
  var Dc = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  class Bc extends Rc {
    get envMapRotation() {
      var e2, t2;
      return null !== (t2 = null === (e2 = this.envMap) || void 0 === e2 ? void 0 : e2.rotation) && void 0 !== t2 ? t2 : 0;
    }
    set envMapRotation(e2) {
      var t2;
      const n2 = [this.envMap, this.envMap2, this.envMap3];
      for (const r2 of n2)
        r2 && (r2.rotation = e2, null === (t2 = this._viewer) || void 0 === t2 || t2.scene.setDirty());
    }
    refreshEnvMaps() {
      var e2, t2, n2;
      if (!this._viewer)
        return;
      const r2 = this.getEnvMaps(), i2 = (null === (t2 = null === (e2 = this._viewer.getPlugin(Ls)) || void 0 === e2 ? void 0 : e2.materials) || void 0 === t2 ? void 0 : t2.getMaterialsOfType(Kl.TypeSlug)) || [];
      for (const e3 of i2)
        e3 && (e3.envMaps = r2);
      null === (n2 = this._viewer) || void 0 === n2 || n2.scene.setDirty();
    }
    constructor() {
      super(), this.offsetCache = {}, this.enabled = true, this.envMap = null, this.envMap2 = null, this.envMap3 = null, this.forceSceneEnvMap = false, this.getEnvMaps = () => {
        var e2;
        if (!this.forceSceneEnvMap && this.envMap)
          return [this.envMap, this.envMap2, this.envMap3];
        const t2 = (null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.scene.environment) || null;
        return [t2, t2, t2];
      }, this._modelProcessor = { forAssetType: "model", processAsync: async (e2, t2) => {
        const n2 = [];
        return e2.modelObject.traverse((e3) => {
          var t3, r2, i2, s2;
          const o2 = null === (r2 = null === (t3 = e3.userData) || void 0 === t3 ? void 0 : t3.gltfExtensions) || void 0 === r2 ? void 0 : r2[Bc.DIAMOND_GLTF_EXTENSION];
          o2 && e3.geometry && (this.prepareDiamondMesh(e3, o2), delete e3.userData.gltfExtensions[Bc.DIAMOND_GLTF_EXTENSION]), e3.material && !n2.includes(e3.material) && (null === (s2 = null === (i2 = e3.material.userData) || void 0 === i2 ? void 0 : i2.gltfExtensions) || void 0 === s2 ? void 0 : s2[Bc.DIAMOND_GLTF_EXTENSION]) && (e3.material.materialObject || console.warn("WebGi DiamondPlugin: material not processed", e3.material), n2.push(e3.material));
        }), n2.forEach((e3) => {
          const t3 = e3.userData.gltfExtensions[Bc.DIAMOND_GLTF_EXTENSION];
          t3 && this._convertToDiamondMaterial(e3, t3);
        }), e2;
      } }, this.uiConfig = { type: "folder", label: "Diamonds", children: [{ type: "checkbox", label: "Use Scene Environment", property: [this, "forceSceneEnvironment"], limitedUi: true }, { type: "image", label: "Environment", hidden: () => this.forceSceneEnvMap, property: [this, "envMap"], limitedUi: true }, { type: "slider", bounds: [0, 2 * Math.PI], hidden: () => this.forceSceneEnvMap, label: "Env Rotation", property: [this, "envMapRotation"], limitedUi: true }, { type: "image", label: "Environment 2", hidden: () => this.forceSceneEnvMap, property: [this, "envMap2"] }, { type: "image", label: "Environment 3", hidden: () => this.forceSceneEnvMap, property: [this, "envMap3"] }, { type: "button", label: "Make Diamond", hidden: () => {
        var e2, t2, n2;
        const r2 = null === (n2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPlugin(za)) || void 0 === t2 ? void 0 : t2.getSelectedObject()) || void 0 === n2 ? void 0 : n2.material;
        return !!Array.isArray(r2) || (null == r2 ? void 0 : r2.typeSlug) !== It.TypeSlug;
      }, value: async () => {
        var e2, t2, n2, r2, i2, s2;
        const o2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPlugin(za)) || void 0 === t2 ? void 0 : t2.getSelectedObject();
        if (!(null == o2 ? void 0 : o2.material))
          return;
        const a2 = await (null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.prompt("Cache key: Enter optional cache key unique to the diamond shape.", "", false)), l2 = (await (null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.prompt("Cache size: Enter size of the cache [64-1024]", "512", false)) || "512").toLowerCase(), c2 = l2.endsWith("high") ? "high" : l2.endsWith("low") ? "low" : "medium";
        let u2 = parseInt(l2);
        isFinite(u2) || (u2 = 512), u2 < 64 && (u2 = 64), (null === (i2 = o2.material.userData) || void 0 === i2 ? void 0 : i2.__appliedMeshes.size) > 1 && await (null === (s2 = this._viewer) || void 0 === s2 ? void 0 : s2.confirm("Convert all: Apply diamond material to all the meshes with the same material?")) ? this.makeDiamond(o2.material, { cacheKey: a2 || void 0, normalMapRes: u2, normalMapPrecision: c2 }, {}) : this.makeDiamondMesh(o2, { cacheKey: a2 || void 0, normalMapRes: u2, normalMapPrecision: c2 }, {}), this.refreshUi();
      }, limitedUi: true }, { type: "button", label: "Make Standard", hidden: () => {
        var e2, t2, n2;
        const r2 = null === (n2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPlugin(za)) || void 0 === t2 ? void 0 : t2.getSelectedObject()) || void 0 === n2 ? void 0 : n2.material;
        return !!Array.isArray(r2) || (null == r2 ? void 0 : r2.typeSlug) !== Kl.TypeSlug;
      }, value: async () => {
        var e2, t2, n2, r2, i2, s2, o2, a2;
        const l2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPlugin(za)) || void 0 === t2 ? void 0 : t2.getSelectedObject(), c2 = null == l2 ? void 0 : l2.material;
        if (!c2)
          return;
        const u2 = c2.userData._baseMaterial;
        let p2 = null === (i2 = null === (r2 = null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.getManager()) || void 0 === r2 ? void 0 : r2.materials) || void 0 === i2 ? void 0 : i2.findMaterial(u2);
        if (p2 && !p2.isDiamondMaterial || (p2 = null === (s2 = this._viewer) || void 0 === s2 ? void 0 : s2.createPhysicalMaterial({ color: c2.color })), p2) {
          const e3 = c2.userData.__appliedMeshes.size > 1 && await (null === (o2 = this._viewer) || void 0 === o2 ? void 0 : o2.confirm("Convert all with this material?")) ? Array.from(c2.userData.__appliedMeshes) : [l2];
          for (const t3 of e3)
            null === (a2 = null == t3 ? void 0 : t3.setMaterial) || void 0 === a2 || a2.call(t3, p2);
        }
        this.refreshUi();
      }, limitedUi: true }, { type: "button", label: "Auto Instance Diamonds (dev)", hidden: () => {
        var e2, t2, n2, r2;
        const i2 = null === (n2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPlugin(za)) || void 0 === t2 ? void 0 : t2.getSelectedObject()) || void 0 === n2 ? void 0 : n2.material;
        return !!Array.isArray(i2) || (null == i2 ? void 0 : i2.typeSlug) !== Kl.TypeSlug || (null === (r2 = i2.userData.__appliedMeshes) || void 0 === r2 ? void 0 : r2.size) < 2;
      }, value: async () => {
        var e2, t2;
        const n2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPlugin(za)) || void 0 === t2 ? void 0 : t2.getSelectedObject();
        if (!n2)
          return;
        const r2 = n2.material;
        r2 && !Array.isArray(r2) && _e(r2);
      } }, { type: "button", label: "Clear Cache", value: () => {
        this.disposeAllCacheMaps();
      } }] }, this.refreshEnvMaps = this.refreshEnvMaps.bind(this), this.refreshUi = this.refreshUi.bind(this);
    }
    refreshUi() {
      var e2, t2, n2;
      null === (e2 = this._viewer) || void 0 === e2 || e2.setDirty(), null === (n2 = null === (t2 = this.uiConfig) || void 0 === t2 ? void 0 : t2.uiRefresh) || void 0 === n2 || n2.call(t2, "postFrame", true);
    }
    async onAdded(e2) {
      var t2, r2, i2, s2, o2, a2, l2;
      this._normalCapture = new zl(e2.renderer), this.offsetCache = {}, e2.scene.addEventListener("materialChanged", (e3) => {
        var t3, n2, r3, i3, s3;
        if (null === (t3 = e3.material) || void 0 === t3 ? void 0 : t3.isDiamondMaterial) {
          const t4 = e3.material, o3 = e3.mesh || e3.object;
          if (o3.geometry && !(null === (n2 = this._normalCapture) || void 0 === n2 ? void 0 : n2.hasCapturedNormalMap(o3))) {
            const e4 = null !== (s3 = null === (i3 = null === (r3 = null == t4 ? void 0 : t4.userData) || void 0 === r3 ? void 0 : r3.gltfExtensions) || void 0 === i3 ? void 0 : i3[Bc.DIAMOND_GLTF_EXTENSION]) && void 0 !== s3 ? s3 : {};
            void 0 === e4.cacheKey && !o3.userData._diamondCacheKey && (null == t4 ? void 0 : t4.name) && (e4.cacheKey = t4.name), this.prepareDiamondMesh(o3, e4);
          }
          const a3 = this.getEnvMaps();
          t4.envMaps = a3;
        }
      }), e2.scene.addEventListener("environmentChanged", this.refreshEnvMaps);
      const c2 = e2.getPlugin(Ls);
      null === (t2 = null == c2 ? void 0 : c2.importer) || void 0 === t2 || t2.processors.add("model", this._modelProcessor), null === (r2 = e2.getPlugin(za)) || void 0 === r2 || r2.addEventListener("selectedObjectChanged", this.refreshUi);
      const u2 = this.getEnvMaps, p2 = new Ft(class extends Gt {
        async loadAsync(e3, t3) {
          var n2;
          const r3 = await super.loadAsync(e3, t3);
          return r3.type === Kl.TYPE || r3.isDiamondMaterialParameters ? (r3.envMap = u2(), null === (n2 = null == c2 ? void 0 : c2.materials) || void 0 === n2 ? void 0 : n2.generateFromTemplate("diamond", r3)) : (console.error("Invalid material type for Diamond Material.", r3), null);
        }
      }, [Kl.TypeSlug], false);
      return null === (i2 = null == c2 ? void 0 : c2.importer) || void 0 === i2 || i2.Importers.push(p2), null === (a2 = null === (o2 = null === (s2 = null == c2 ? void 0 : c2.exporter) || void 0 === s2 ? void 0 : s2.getExporter("gltf", "glb")) || void 0 === o2 ? void 0 : o2.extensions) || void 0 === a2 || a2.push(Oc), null === (l2 = null == c2 ? void 0 : c2.materials) || void 0 === l2 || l2.registerMaterialTemplate({ name: "diamond", materialType: Kl.TYPE, isDiamondMaterialParameters: true, generator: (e3, t3) => {
        const r3 = !((null == t3 ? void 0 : t3.metadata) || !t3.isDiamondMaterialParameters) || (null == t3 ? void 0 : t3.metadata) && (null == t3 ? void 0 : t3.metadata.version) <= 4.5, i3 = null == t3 ? void 0 : t3.color;
        r3 && "number" == typeof t3.color && (t3.color = new n.Ilk().setHex(t3.color, n.GUF).getHex());
        const s3 = new Kl(e3);
        return s3.envMaps = this.getEnvMaps(), t3 && s3.copyProps(t3), t3.color = i3, s3;
      } }), super.onAdded(e2);
    }
    async onRemove(e2) {
      var t2, n2, r2, i2;
      return null === (t2 = this._normalCapture) || void 0 === t2 || t2.dispose(), this._normalCapture = void 0, this.offsetCache = {}, null === (r2 = null === (n2 = e2.getPlugin(Ls)) || void 0 === n2 ? void 0 : n2.importer) || void 0 === r2 || r2.processors.remove("model", this._modelProcessor), null === (i2 = e2.getPlugin(za)) || void 0 === i2 || i2.removeEventListener("selectedObjectChanged", this.refreshUi), super.onRemove(e2);
    }
    prepareDiamondMesh(e2, { cacheKey: t2, normalMapRes: n2, normalMapPrecision: r2 }) {
      var i2, s2, o2;
      this.use(), e2.userData._diamondCacheKey = null != t2 ? t2 : e2.userData._diamondCacheKey, e2.userData._diamondNormalMapRes = null != n2 ? n2 : e2.userData._diamondNormalMapRes, e2.userData._diamondNormalMapPrecision = null != r2 ? r2 : e2.userData._diamondNormalMapPrecision, t2 = t2 && t2.length > 0 ? t2.includes(";" + e2.geometry.uuid) ? t2 : t2 + ";" + e2.geometry.uuid : e2.geometry.uuid, this._computeOffsets(e2.geometry, e2.geometry.uuid);
      const a2 = null !== (s2 = null === (i2 = this._normalCapture) || void 0 === i2 ? void 0 : i2.captureNormalMap(e2.geometry, t2, n2, r2, e2)) && void 0 !== s2 ? s2 : [void 0, false], l2 = null === (o2 = this._viewer) || void 0 === o2 ? void 0 : o2.getPluginByType("debug");
      l2 && a2 && (l2.counters.normalsCapture || (l2.counters.normalsCapture = 0), l2.counters.normalsCapture++, console.log("DEBUG: new normal map captured", l2.counters.normalsCapture, t2), l2.addTexture("normal" + l2.counters.normalsCapture, () => {
        var t3, n3;
        return null === (n3 = null === (t3 = e2.geometry) || void 0 === t3 ? void 0 : t3.userData._normalsCaptureMap) || void 0 === n3 ? void 0 : n3.texture;
      }, [40, 110 * l2.counters.normalsCapture - 100, 200, 100], void 0, void 0, "postRender", true));
    }
    makeDiamond(e2, t2, n2) {
      var r2, i2;
      Array.from(null !== (r2 = null == e2 ? void 0 : e2.userData.__appliedMeshes) && void 0 !== r2 ? r2 : []).forEach((e3) => {
        (null == e3 ? void 0 : e3.isMesh) && e3.geometry && this.prepareDiamondMesh(e3, t2);
      }), this._convertToDiamondMaterial(e2, n2), null === (i2 = this._viewer) || void 0 === i2 || i2.setDirty();
    }
    makeDiamondMesh(e2, t2, n2) {
      if (!e2.modelObject.isMesh || !e2.geometry || !e2.setMaterial)
        return;
      this.prepareDiamondMesh(e2.modelObject, t2);
      const r2 = Array.isArray(e2.material) ? e2.material[0] : e2.material, i2 = this._convertToDiamondMaterial(r2, n2, false);
      e2.setMaterial(i2);
    }
    _convertToDiamondMaterial(e2, t2 = { isDiamond: true }, r2 = true) {
      var i2, s2, o2, a2, l2, c2, u2, p2;
      let d2 = { ...null != t2 ? t2 : {} };
      d2.isDiamond || d2.isDiamondMaterialParameters ? Array.isArray(d2.boostFactors) && (d2.boostFactors = new n.Pa4().fromArray(d2.boostFactors)) : d2 = { isDiamondMaterialParameters: true }, d2.color = null !== (s2 = null !== (i2 = d2.color) && void 0 !== i2 ? i2 : null == e2 ? void 0 : e2.color) && void 0 !== s2 ? s2 : new n.Ilk(1, 1, 1), d2.name = null !== (a2 = null !== (o2 = d2.name) && void 0 !== o2 ? o2 : null == e2 ? void 0 : e2.name) && void 0 !== a2 ? a2 : "diamond";
      const h2 = null === (u2 = null === (c2 = null === (l2 = this._viewer) || void 0 === l2 ? void 0 : l2.getManager()) || void 0 === c2 ? void 0 : c2.materials) || void 0 === u2 ? void 0 : u2.generateFromTemplate("diamond", d2);
      if (h2 && e2 && !e2.isDiamondMaterial && (h2.userData._baseMaterial = e2.uuid), r2) {
        const n2 = (e3) => {
          var t3;
          return null !== (t3 = e3.setMaterial) && void 0 !== t3 ? t3 : (t4) => {
            e3.material = t4.materialObject;
          };
        };
        Array.from(null !== (p2 = null == e2 ? void 0 : e2.userData.__appliedMeshes) && void 0 !== p2 ? p2 : []).forEach((e3) => {
          n2(e3)(h2), this.prepareDiamondMesh(e3, t2);
        });
      }
      return h2;
    }
    _computeOffsets(e2, r2, i2 = false) {
      var s2;
      if (e2.userData.normalsCaptureOffsets) {
        if (null === (0, t.getUrlQueryParam)("recomputeOffsets"))
          return e2.userData.normalsCaptureOffsets;
        console.warn("WebGi DiamondPlugin: recomputeOffsets", e2.userData.normalsCaptureOffsets);
      }
      let o2;
      (null === (s2 = e2.morphAttributes) || void 0 === s2 ? void 0 : s2.position) && (o2 = e2.morphAttributes, e2.morphAttributes = {}), e2.computeBoundingBox();
      const a2 = e2.boundingBox.getCenter(new n.Pa4()).toArray(), l2 = ql(e2).toArray(), c2 = new n.yGw().fromArray(l2).invert(), u2 = new n.Pa4().fromArray(a2).applyMatrix4(c2).toArray(), p2 = { center: a2, offsetMatrix: l2, offsetMatrixInv: c2.toArray(), radius: 1, centerOffset: u2 };
      return e2.userData.normalsCaptureOffsets = p2, o2 && (e2.morphAttributes = o2, e2.computeBoundingBox()), null !== (0, t.getUrlQueryParam)("recomputeOffsets") && console.warn("WebGi DiamondPlugin: recomputeOffsets", p2), p2;
    }
    disposeCacheMap(e2) {
      var t2;
      null === (t2 = this._normalCapture) || void 0 === t2 || t2.disposeTarget(e2);
    }
    disposeAllCacheMaps() {
      var e2;
      null === (e2 = this._normalCapture) || void 0 === e2 || e2.disposeAllTargets();
    }
  }
  Bc.PluginType = "Diamond", Bc.DIAMOND_GLTF_EXTENSION = "WEBGI_materials_diamond", Dc([(0, t.onChange)(Bc.prototype.refreshEnvMaps), ie()], Bc.prototype, "envMap", void 0), Dc([(0, t.onChange)(Bc.prototype.refreshEnvMaps), ie()], Bc.prototype, "envMap2", void 0), Dc([(0, t.onChange)(Bc.prototype.refreshEnvMaps), ie()], Bc.prototype, "envMap3", void 0), Dc([(0, t.onChange)(Bc.prototype.refreshEnvMaps), ie()], Bc.prototype, "forceSceneEnvMap", void 0);
  const Oc = (e2) => ({ writeMaterial: (t2, n2) => {
    t2.isDiamondMaterial && (n2.extensions = n2.extensions || {}, n2.extensions[Bc.DIAMOND_GLTF_EXTENSION] = t2.toJSON(), e2.extensionsUsed[Bc.DIAMOND_GLTF_EXTENSION] = true);
  }, writeMesh: (t2, n2) => {
    var r2, i2;
    if (!(null == t2 ? void 0 : t2.material.isDiamondMaterial))
      return;
    n2.extensions = n2.extensions || {};
    const s2 = {};
    null === (i2 = null === (r2 = t2.userData) || void 0 === r2 ? void 0 : r2.gltfExtensions) || void 0 === i2 || delete i2[Bc.DIAMOND_GLTF_EXTENSION], t2.userData._diamondNormalMapRes && (s2.normalMapRes = t2.userData._diamondNormalMapRes), t2.userData._diamondNormalMapPrecision && (s2.normalMapPrecision = t2.userData._diamondNormalMapPrecision), t2.userData._diamondCacheKey && (s2.cacheKey = t2.userData._diamondCacheKey), n2.extensions[Bc.DIAMOND_GLTF_EXTENSION] = s2, e2.extensionsUsed[Bc.DIAMOND_GLTF_EXTENSION] = true;
  } });
  class Lc {
    static async GetClonedCanvas(e2, { rect: t2 = { x: 0, y: 0, width: e2.width, height: e2.height, assumeClientRect: false }, displayPixelRatio: n2 = 1, scale: r2 = 1 }) {
      var i2, s2, o2;
      const a2 = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      a2.width = t2.width * r2 * n2, a2.height = t2.height * r2 * n2, t2.assumeClientRect && (t2.x *= e2.width / (n2 * e2.clientWidth), t2.y *= e2.height / (n2 * e2.clientHeight), t2.width *= e2.width / (n2 * e2.clientWidth), t2.height *= e2.height / (n2 * e2.clientHeight));
      const l2 = a2.getContext("2d");
      if (!l2)
        return console.error("snapshot: cannot create context"), a2;
      const c2 = e2.style.background || (null === (i2 = e2.parentElement) || void 0 === i2 ? void 0 : i2.style.background) || "";
      if (c2.includes("url")) {
        const r3 = null === (s2 = /url\("(.*)"\)/gi.exec(c2)) || void 0 === s2 ? void 0 : s2[1];
        if (r3) {
          const i3 = new Image();
          i3.src = r3, await new Promise((e3, t3) => {
            i3.onload = () => e3(), i3.onerror = () => t3(), i3.complete && e3();
          }), l2.drawImage(i3, i3.width * t2.x * n2 / e2.width, i3.height * t2.y * n2 / e2.height, i3.width * t2.width * n2 / e2.width, i3.height * t2.height * n2 / e2.height, 0, 0, a2.width, a2.height);
        }
      } else
        l2.fillStyle = e2.style.background || (null === (o2 = e2.parentElement) || void 0 === o2 ? void 0 : o2.style.backgroundColor) || "#00000000", l2.fillRect(0, 0, a2.width, a2.height);
      return null == l2 || l2.drawImage(e2, t2.x * n2, t2.y * n2, t2.width * n2, t2.height * n2, 0, 0, a2.width, a2.height), this.Debug && (document.body.appendChild(a2), a2.style.position = "absolute", a2.style.top = "0", a2.style.left = "0", a2.style.borderWidth = "2px", a2.style.borderColor = "#ff00ff", setTimeout(() => a2.remove(), 5e3)), a2;
    }
    static async GetDataUrl(e2, { mimeType: t2 = "image/png", ...n2 }) {
      const r2 = false === n2.cloneCanvas ? e2 : await this.GetClonedCanvas(e2, n2), i2 = r2.toDataURL(t2);
      return this.Debug || r2 === e2 || r2.remove(), i2;
    }
    static async GetImage(e2, { mimeType: t2 = "image/png", ...n2 } = {}) {
      const r2 = await this.GetDataUrl(e2, n2);
      return new Promise((e3, t3) => {
        const n3 = new Image();
        n3.onload = () => {
          e3(n3);
        }, n3.src = r2;
      });
    }
    static async GetBlob(e2, t2 = {}) {
      const n2 = false === t2.cloneCanvas ? e2 : await this.GetClonedCanvas(e2, t2), r2 = await new Promise((e3, r3) => {
        var i2;
        n2.toBlob((t3) => {
          t3 ? e3(t3) : r3();
        }, null !== (i2 = t2.mimeType) && void 0 !== i2 ? i2 : "image/png");
      });
      return this.Debug || n2 === e2 || n2.remove(), r2;
    }
    static async GetFile(e2, n2 = "image.png", r2 = {}) {
      var i2;
      return r2.getDataUrl ? await this.GetDataUrl(e2, r2) : new File([await this.GetBlob(e2, r2)], n2, { type: null !== (i2 = r2.mimeType) && void 0 !== i2 ? i2 : "image/png", lastModified: (0, t.now)() });
    }
  }
  Lc.Debug = false;
  var Uc = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let Fc = class extends gt {
    constructor() {
      super(), this.enabled = true, this.filename = "snapshot.png", this.downloadSnapshot = this.downloadSnapshot.bind(this);
    }
    async getFile(e2, t2 = { waitForProgressive: true }) {
      return t2.getDataUrl = false, await this._getFile(e2 || this.filename, t2);
    }
    async getDataUrl(e2 = {}) {
      var t2;
      return e2.getDataUrl = true, null !== (t2 = await this._getFile("", e2)) && void 0 !== t2 ? t2 : "";
    }
    async _getFile(e2, n2 = {}) {
      var r2, i2, s2;
      const o2 = null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.canvas;
      if (o2) {
        const r3 = this._viewer.renderer.displayCanvasScaling;
        void 0 !== n2.displayPixelRatio && n2.displayPixelRatio !== r3 && (this._viewer.renderer.displayCanvasScaling = n2.displayPixelRatio);
        const a2 = null === (i2 = this._viewer) || void 0 === i2 ? void 0 : i2.getPlugin(To);
        if (n2.waitForProgressive && a2 && void 0 === n2.timeout)
          for (; !a2.isConverged(true); )
            await (0, t.timeout)(64);
        else
          await (0, t.timeout)(null !== (s2 = n2.timeout) && void 0 !== s2 ? s2 : 200);
        n2.displayPixelRatio = 1;
        const l2 = await Lc.GetFile(o2, e2, n2);
        return n2.displayPixelRatio = this._viewer.renderer.displayCanvasScaling, this._viewer.renderer.displayCanvasScaling = r3, l2;
      }
    }
    async downloadSnapshot(e2, t2 = { waitForProgressive: true }) {
      const n2 = await this.getFile(e2, t2);
      n2 && await this._downloadBlob(n2, n2.name);
    }
    async _downloadBlob(e2, t2) {
      var n2, r2;
      const i2 = null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.getPluginByType("FileTransferPlugin");
      i2 ? await i2.exportFile(e2, t2) : null === (r2 = this._viewer) || void 0 === r2 || r2.console.error("FileTransferPlugin required to export/download file");
    }
  };
  Fc.PluginType = "CanvasSnipper", Uc([ze("Filename"), ie()], Fc.prototype, "filename", void 0), Uc([je("Download .png", { limitedUi: true })], Fc.prototype, "downloadSnapshot", null), Fc = Uc([We("Image Export")], Fc);
  var Nc = function(e2) {
    return function(t2) {
      return 1 - e2(1 - t2);
    };
  }, jc = function(e2) {
    return function(t2) {
      return t2 <= 0.5 ? e2(2 * t2) / 2 : (2 - e2(2 * (1 - t2))) / 2;
    };
  }, zc = function(e2) {
    return function(t2) {
      return Math.pow(t2, e2);
    };
  }, Gc = function(e2) {
    return function(t2) {
      return t2 * t2 * ((e2 + 1) * t2 - e2);
    };
  }, Vc = function(e2) {
    var t2 = Gc(e2);
    return function(e3) {
      return (e3 *= 2) < 1 ? 0.5 * t2(e3) : 0.5 * (2 - Math.pow(2, -10 * (e3 - 1)));
    };
  }, Hc = function(e2) {
    return e2;
  }, Qc = zc(2), Wc = Nc(Qc), qc = jc(Qc), Xc = function(e2) {
    return 1 - Math.sin(Math.acos(e2));
  }, Yc = Nc(Xc), Kc = jc(Yc), Jc = Gc(1.525), Zc = Nc(Jc), $c = jc(Jc), eu = Vc(1.525), tu = function(e2) {
    if (1 === e2 || 0 === e2)
      return e2;
    var t2 = e2 * e2;
    return e2 < 0.36363636363636365 ? 7.5625 * t2 : e2 < 0.7272727272727273 ? 9.075 * t2 - 9.9 * e2 + 3.4 : e2 < 0.9 ? 12.066481994459833 * t2 - 19.63545706371191 * e2 + 8.898060941828255 : 10.8 * e2 * e2 - 20.52 * e2 + 10.72;
  }, nu = Nc(tu), ru = function(e2) {
    return e2 < 0.5 ? 0.5 * (1 - tu(1 - 2 * e2)) : 0.5 * tu(2 * e2 - 1) + 0.5;
  }, iu = function() {
    return iu = Object.assign || function(e2) {
      for (var t2, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
        for (var i2 in t2 = arguments[n2])
          Object.prototype.hasOwnProperty.call(t2, i2) && (e2[i2] = t2[i2]);
      return e2;
    }, iu.apply(this, arguments);
  };
  function su(e2, t2) {
    var n2 = {};
    for (var r2 in e2)
      Object.prototype.hasOwnProperty.call(e2, r2) && t2.indexOf(r2) < 0 && (n2[r2] = e2[r2]);
    if (null != e2 && "function" == typeof Object.getOwnPropertySymbols) {
      var i2 = 0;
      for (r2 = Object.getOwnPropertySymbols(e2); i2 < r2.length; i2++)
        t2.indexOf(r2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(e2, r2[i2]) && (n2[r2[i2]] = e2[r2[i2]]);
    }
    return n2;
  }
  Object.create, Object.create;
  var ou = function() {
  }, au = function() {
  }, lu = function(e2, t2, n2) {
    return Math.min(Math.max(n2, e2), t2);
  }, cu = 1e-3, uu = 0.01, pu = 10, du = 0.05, hu = 1;
  var fu = 12;
  function mu(e2, t2) {
    return e2 * Math.sqrt(1 - t2 * t2);
  }
  var _u = ["duration", "bounce"], gu = ["stiffness", "damping", "mass"];
  function vu(e2, t2) {
    return t2.some(function(t3) {
      return void 0 !== e2[t3];
    });
  }
  function yu(e2) {
    var t2 = e2.from, n2 = void 0 === t2 ? 0 : t2, r2 = e2.to, i2 = void 0 === r2 ? 1 : r2, s2 = e2.restSpeed, o2 = void 0 === s2 ? 2 : s2, a2 = e2.restDelta, l2 = su(e2, ["from", "to", "restSpeed", "restDelta"]), c2 = { done: false, value: n2 }, u2 = function(e3) {
      var t3 = iu({ velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: false }, e3);
      if (!vu(e3, gu) && vu(e3, _u)) {
        var n3 = function(e4) {
          var t4, n4, r3 = e4.duration, i3 = void 0 === r3 ? 800 : r3, s3 = e4.bounce, o3 = void 0 === s3 ? 0.25 : s3, a3 = e4.velocity, l3 = void 0 === a3 ? 0 : a3, c3 = e4.mass, u3 = void 0 === c3 ? 1 : c3;
          ou(i3 <= 1e3 * pu, "Spring duration must be 10 seconds or less");
          var p3 = 1 - o3;
          p3 = lu(du, hu, p3), i3 = lu(uu, pu, i3 / 1e3), p3 < 1 ? (t4 = function(e5) {
            var t5 = e5 * p3, n5 = t5 * i3, r4 = t5 - l3, s4 = mu(e5, p3), o4 = Math.exp(-n5);
            return cu - r4 / s4 * o4;
          }, n4 = function(e5) {
            var n5 = e5 * p3 * i3, r4 = n5 * l3 + l3, s4 = Math.pow(p3, 2) * Math.pow(e5, 2) * i3, o4 = Math.exp(-n5), a4 = mu(Math.pow(e5, 2), p3);
            return (-t4(e5) + cu > 0 ? -1 : 1) * ((r4 - s4) * o4) / a4;
          }) : (t4 = function(e5) {
            return Math.exp(-e5 * i3) * ((e5 - l3) * i3 + 1) - cu;
          }, n4 = function(e5) {
            return Math.exp(-e5 * i3) * (i3 * i3 * (l3 - e5));
          });
          var d3 = function(e5, t5, n5) {
            for (var r4 = n5, i4 = 1; i4 < fu; i4++)
              r4 -= e5(r4) / t5(r4);
            return r4;
          }(t4, n4, 5 / i3);
          if (i3 *= 1e3, isNaN(d3))
            return { stiffness: 100, damping: 10, duration: i3 };
          var h3 = Math.pow(d3, 2) * u3;
          return { stiffness: h3, damping: 2 * p3 * Math.sqrt(u3 * h3), duration: i3 };
        }(e3);
        (t3 = iu(iu(iu({}, t3), n3), { velocity: 0, mass: 1 })).isResolvedFromDuration = true;
      }
      return t3;
    }(l2), p2 = u2.stiffness, d2 = u2.damping, h2 = u2.mass, f2 = u2.velocity, m2 = u2.duration, _2 = u2.isResolvedFromDuration, g2 = bu, v2 = bu;
    function y2() {
      var e3 = f2 ? -f2 / 1e3 : 0, t3 = i2 - n2, r3 = d2 / (2 * Math.sqrt(p2 * h2)), s3 = Math.sqrt(p2 / h2) / 1e3;
      if (null != a2 || (a2 = Math.abs(i2 - n2) <= 1 ? 0.01 : 0.4), r3 < 1) {
        var o3 = mu(s3, r3);
        g2 = function(n3) {
          var a3 = Math.exp(-r3 * s3 * n3);
          return i2 - a3 * ((e3 + r3 * s3 * t3) / o3 * Math.sin(o3 * n3) + t3 * Math.cos(o3 * n3));
        }, v2 = function(n3) {
          var i3 = Math.exp(-r3 * s3 * n3);
          return r3 * s3 * i3 * (Math.sin(o3 * n3) * (e3 + r3 * s3 * t3) / o3 + t3 * Math.cos(o3 * n3)) - i3 * (Math.cos(o3 * n3) * (e3 + r3 * s3 * t3) - o3 * t3 * Math.sin(o3 * n3));
        };
      } else if (1 === r3)
        g2 = function(n3) {
          return i2 - Math.exp(-s3 * n3) * (t3 + (e3 + s3 * t3) * n3);
        };
      else {
        var l3 = s3 * Math.sqrt(r3 * r3 - 1);
        g2 = function(n3) {
          var o4 = Math.exp(-r3 * s3 * n3), a3 = Math.min(l3 * n3, 300);
          return i2 - o4 * ((e3 + r3 * s3 * t3) * Math.sinh(a3) + l3 * t3 * Math.cosh(a3)) / l3;
        };
      }
    }
    return y2(), { next: function(e3) {
      var t3 = g2(e3);
      if (_2)
        c2.done = e3 >= m2;
      else {
        var n3 = 1e3 * v2(e3), r3 = Math.abs(n3) <= o2, s3 = Math.abs(i2 - t3) <= a2;
        c2.done = r3 && s3;
      }
      return c2.value = c2.done ? i2 : t3, c2;
    }, flipTarget: function() {
      var e3;
      f2 = -f2, n2 = (e3 = [i2, n2])[0], i2 = e3[1], y2();
    } };
  }
  yu.needsInterpolation = function(e2, t2) {
    return "string" == typeof e2 || "string" == typeof t2;
  };
  var bu = function(e2) {
    return 0;
  }, wu = function(e2, t2, n2) {
    var r2 = t2 - e2;
    return 0 === r2 ? 1 : (n2 - e2) / r2;
  }, Au = function(e2, t2, n2) {
    return -n2 * e2 + n2 * t2 + e2;
  }, xu = function(e2, t2) {
    return function(n2) {
      return Math.max(Math.min(n2, t2), e2);
    };
  }, Eu = function(e2) {
    return e2 % 1 ? Number(e2.toFixed(5)) : e2;
  }, Cu = /(-)?([\d]*\.?[\d])+/g, Su = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))/gi, Mu = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))$/i;
  function Tu(e2) {
    return "string" == typeof e2;
  }
  var Pu = { test: function(e2) {
    return "number" == typeof e2;
  }, parse: parseFloat, transform: function(e2) {
    return e2;
  } }, Iu = iu(iu({}, Pu), { transform: xu(0, 1) }), Ru = (iu(iu({}, Pu), { default: 1 }), function(e2, t2) {
    return function(n2) {
      return Boolean(Tu(n2) && Mu.test(n2) && n2.startsWith(e2) || t2 && Object.prototype.hasOwnProperty.call(n2, t2));
    };
  }), ku = function(e2, t2, n2) {
    return function(r2) {
      var i2;
      if (!Tu(r2))
        return r2;
      var s2 = r2.match(Cu), o2 = s2[0], a2 = s2[1], l2 = s2[2], c2 = s2[3];
      return (i2 = {})[e2] = parseFloat(o2), i2[t2] = parseFloat(a2), i2[n2] = parseFloat(l2), i2.alpha = void 0 !== c2 ? parseFloat(c2) : 1, i2;
    };
  }, Du = xu(0, 255), Bu = iu(iu({}, Pu), { transform: function(e2) {
    return Math.round(Du(e2));
  } }), Ou = { test: Ru("rgb", "red"), parse: ku("red", "green", "blue"), transform: function(e2) {
    var t2 = e2.red, n2 = e2.green, r2 = e2.blue, i2 = e2.alpha, s2 = void 0 === i2 ? 1 : i2;
    return "rgba(" + Bu.transform(t2) + ", " + Bu.transform(n2) + ", " + Bu.transform(r2) + ", " + Eu(Iu.transform(s2)) + ")";
  } }, Lu = { test: Ru("#"), parse: function(e2) {
    var t2 = "", n2 = "", r2 = "", i2 = "";
    return e2.length > 5 ? (t2 = e2.substr(1, 2), n2 = e2.substr(3, 2), r2 = e2.substr(5, 2), i2 = e2.substr(7, 2)) : (t2 = e2.substr(1, 1), n2 = e2.substr(2, 1), r2 = e2.substr(3, 1), i2 = e2.substr(4, 1), t2 += t2, n2 += n2, r2 += r2, i2 += i2), { red: parseInt(t2, 16), green: parseInt(n2, 16), blue: parseInt(r2, 16), alpha: i2 ? parseInt(i2, 16) / 255 : 1 };
  }, transform: Ou.transform }, Uu = function(e2) {
    return { test: function(t2) {
      return Tu(t2) && t2.endsWith(e2) && 1 === t2.split(" ").length;
    }, parse: parseFloat, transform: function(t2) {
      return "" + t2 + e2;
    } };
  }, Fu = (Uu("deg"), Uu("%")), Nu = (Uu("px"), Uu("vh"), Uu("vw"), iu(iu({}, Fu), { parse: function(e2) {
    return Fu.parse(e2) / 100;
  }, transform: function(e2) {
    return Fu.transform(100 * e2);
  } }), { test: Ru("hsl", "hue"), parse: ku("hue", "saturation", "lightness"), transform: function(e2) {
    var t2 = e2.hue, n2 = e2.saturation, r2 = e2.lightness, i2 = e2.alpha, s2 = void 0 === i2 ? 1 : i2;
    return "hsla(" + Math.round(t2) + ", " + Fu.transform(Eu(n2)) + ", " + Fu.transform(Eu(r2)) + ", " + Eu(Iu.transform(s2)) + ")";
  } }), ju = function(e2, t2, n2) {
    var r2 = e2 * e2, i2 = t2 * t2;
    return Math.sqrt(Math.max(0, n2 * (i2 - r2) + r2));
  }, zu = [Lu, Ou, Nu], Gu = function(e2) {
    return zu.find(function(t2) {
      return t2.test(e2);
    });
  }, Vu = function(e2) {
    return "'" + e2 + "' is not an animatable color. Use the equivalent color code instead.";
  }, Hu = function(e2, t2) {
    var n2 = Gu(e2), r2 = Gu(t2);
    if (au(!!n2, Vu(e2)), au(!!r2, Vu(t2)), au(n2.transform === r2.transform, "Both colors must be hex/RGBA, OR both must be HSLA."), !n2 || !r2 || n2.transform !== r2.transform)
      return function(n3) {
        return "" + (n3 > 0 ? t2 : e2);
      };
    var i2 = n2.parse(e2), s2 = r2.parse(t2), o2 = iu({}, i2), a2 = n2 === Nu ? Au : ju;
    return function(e3) {
      for (var t3 in o2)
        "alpha" !== t3 && (o2[t3] = a2(i2[t3], s2[t3], e3));
      return o2.alpha = Au(i2.alpha, s2.alpha, e3), n2.transform(o2);
    };
  }, Qu = { test: function(e2) {
    return Ou.test(e2) || Lu.test(e2) || Nu.test(e2);
  }, parse: function(e2) {
    return Ou.test(e2) ? Ou.parse(e2) : Nu.test(e2) ? Nu.parse(e2) : Lu.parse(e2);
  }, transform: function(e2) {
    return Tu(e2) ? e2 : e2.hasOwnProperty("red") ? Ou.transform(e2) : Nu.transform(e2);
  } }, Wu = "${c}", qu = "${n}";
  function Xu(e2) {
    "number" == typeof e2 && (e2 = "" + e2);
    var t2 = [], n2 = 0, r2 = e2.match(Su);
    r2 && (n2 = r2.length, e2 = e2.replace(Su, Wu), t2.push.apply(t2, r2.map(Qu.parse)));
    var i2 = e2.match(Cu);
    return i2 && (e2 = e2.replace(Cu, qu), t2.push.apply(t2, i2.map(Pu.parse))), { values: t2, numColors: n2, tokenised: e2 };
  }
  function Yu(e2) {
    return Xu(e2).values;
  }
  function Ku(e2) {
    var t2 = Xu(e2), n2 = t2.values, r2 = t2.numColors, i2 = t2.tokenised, s2 = n2.length;
    return function(e3) {
      for (var t3 = i2, n3 = 0; n3 < s2; n3++)
        t3 = t3.replace(n3 < r2 ? Wu : qu, n3 < r2 ? Qu.transform(e3[n3]) : Eu(e3[n3]));
      return t3;
    };
  }
  var Ju = function(e2) {
    return "number" == typeof e2 ? 0 : e2;
  }, Zu = { test: function(e2) {
    var t2, n2, r2, i2;
    return isNaN(e2) && Tu(e2) && (null !== (n2 = null === (t2 = e2.match(Cu)) || void 0 === t2 ? void 0 : t2.length) && void 0 !== n2 ? n2 : 0) + (null !== (i2 = null === (r2 = e2.match(Su)) || void 0 === r2 ? void 0 : r2.length) && void 0 !== i2 ? i2 : 0) > 0;
  }, parse: Yu, createTransformer: Ku, getAnimatableNone: function(e2) {
    var t2 = Yu(e2);
    return Ku(e2)(t2.map(Ju));
  } }, $u = { x: 0, y: 0, z: 0 }, ep = function(e2) {
    return "number" == typeof e2;
  }, tp = function(e2, t2) {
    return function(n2) {
      return t2(e2(n2));
    };
  }, np = function() {
    for (var e2 = [], t2 = 0; t2 < arguments.length; t2++)
      e2[t2] = arguments[t2];
    return e2.reduce(tp);
  };
  function rp(e2, t2) {
    return ep(e2) ? function(n2) {
      return Au(e2, t2, n2);
    } : Qu.test(e2) ? Hu(e2, t2) : ap(e2, t2);
  }
  var ip = function(e2, t2) {
    var n2 = function(e3, t3, n3) {
      if (n3 || 2 === arguments.length)
        for (var r3, i3 = 0, s2 = t3.length; i3 < s2; i3++)
          !r3 && i3 in t3 || (r3 || (r3 = Array.prototype.slice.call(t3, 0, i3)), r3[i3] = t3[i3]);
      return e3.concat(r3 || Array.prototype.slice.call(t3));
    }([], e2), r2 = n2.length, i2 = e2.map(function(e3, n3) {
      return rp(e3, t2[n3]);
    });
    return function(e3) {
      for (var t3 = 0; t3 < r2; t3++)
        n2[t3] = i2[t3](e3);
      return n2;
    };
  }, sp = function(e2, t2) {
    var n2 = iu(iu({}, e2), t2), r2 = {};
    for (var i2 in n2)
      void 0 !== e2[i2] && void 0 !== t2[i2] && (r2[i2] = rp(e2[i2], t2[i2]));
    return function(e3) {
      for (var t3 in r2)
        n2[t3] = r2[t3](e3);
      return n2;
    };
  };
  function op(e2) {
    for (var t2 = Zu.parse(e2), n2 = t2.length, r2 = 0, i2 = 0, s2 = 0, o2 = 0; o2 < n2; o2++)
      r2 || "number" == typeof t2[o2] ? r2++ : void 0 !== t2[o2].hue ? s2++ : i2++;
    return { parsed: t2, numNumbers: r2, numRGB: i2, numHSL: s2 };
  }
  var ap = function(e2, t2) {
    var n2 = Zu.createTransformer(t2), r2 = op(e2), i2 = op(t2);
    return r2.numHSL === i2.numHSL && r2.numRGB === i2.numRGB && r2.numNumbers >= i2.numNumbers ? np(ip(r2.parsed, i2.parsed), n2) : (ou(true, "Complex values '" + e2 + "' and '" + t2 + "' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition."), function(n3) {
      return "" + (n3 > 0 ? t2 : e2);
    });
  }, lp = function(e2, t2) {
    return function(n2) {
      return Au(e2, t2, n2);
    };
  };
  function cp(e2, t2, n2) {
    var r2 = void 0 === n2 ? {} : n2, i2 = r2.clamp, s2 = void 0 === i2 || i2, o2 = r2.ease, a2 = r2.mixer, l2 = e2.length;
    au(l2 === t2.length, "Both input and output ranges must be the same length"), au(!o2 || !Array.isArray(o2) || o2.length === l2 - 1, "Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values."), e2[0] > e2[l2 - 1] && (e2 = [].concat(e2), t2 = [].concat(t2), e2.reverse(), t2.reverse());
    var c2 = function(e3, t3, n3) {
      for (var r3 = [], i3 = n3 || ("number" == typeof (c3 = e3[0]) ? lp : "string" == typeof c3 ? Qu.test(c3) ? Hu : ap : Array.isArray(c3) ? ip : "object" == typeof c3 ? sp : void 0), s3 = e3.length - 1, o3 = 0; o3 < s3; o3++) {
        var a3 = i3(e3[o3], e3[o3 + 1]);
        if (t3) {
          var l3 = Array.isArray(t3) ? t3[o3] : t3;
          a3 = np(l3, a3);
        }
        r3.push(a3);
      }
      var c3;
      return r3;
    }(t2, o2, a2), u2 = 2 === l2 ? function(e3, t3) {
      var n3 = e3[0], r3 = e3[1], i3 = t3[0];
      return function(e4) {
        return i3(wu(n3, r3, e4));
      };
    }(e2, c2) : function(e3, t3) {
      var n3 = e3.length, r3 = n3 - 1;
      return function(i3) {
        var s3 = 0, o3 = false;
        if (i3 <= e3[0] ? o3 = true : i3 >= e3[r3] && (s3 = r3 - 1, o3 = true), !o3) {
          for (var a3 = 1; a3 < n3 && !(e3[a3] > i3 || a3 === r3); a3++)
            ;
          s3 = a3 - 1;
        }
        var l3 = wu(e3[s3], e3[s3 + 1], i3);
        return t3[s3](l3);
      };
    }(e2, c2);
    return s2 ? function(t3) {
      return u2(lu(e2[0], e2[l2 - 1], t3));
    } : u2;
  }
  function up(e2, t2) {
    return e2.map(function() {
      return t2 || qc;
    }).splice(0, e2.length - 1);
  }
  function pp(e2) {
    var t2 = e2.from, n2 = void 0 === t2 ? 0 : t2, r2 = e2.to, i2 = void 0 === r2 ? 1 : r2, s2 = e2.ease, o2 = e2.offset, a2 = e2.duration, l2 = void 0 === a2 ? 300 : a2, c2 = { done: false, value: n2 }, u2 = Array.isArray(i2) ? i2 : [n2, i2], p2 = function(e3, t3) {
      return e3.map(function(e4) {
        return e4 * t3;
      });
    }(o2 && o2.length === u2.length ? o2 : function(e3) {
      var t3 = e3.length;
      return e3.map(function(e4, n3) {
        return 0 !== n3 ? n3 / (t3 - 1) : 0;
      });
    }(u2), l2);
    function d2() {
      return cp(p2, u2, { ease: Array.isArray(s2) ? s2 : up(u2, s2) });
    }
    var h2 = d2();
    return { next: function(e3) {
      return c2.value = h2(e3), c2.done = e3 >= l2, c2;
    }, flipTarget: function() {
      u2.reverse(), h2 = d2();
    } };
  }
  function dp(e2) {
    var t2 = e2.velocity, n2 = void 0 === t2 ? 0 : t2, r2 = e2.from, i2 = void 0 === r2 ? 0 : r2, s2 = e2.power, o2 = void 0 === s2 ? 0.8 : s2, a2 = e2.timeConstant, l2 = void 0 === a2 ? 350 : a2, c2 = e2.restDelta, u2 = void 0 === c2 ? 0.5 : c2, p2 = e2.modifyTarget, d2 = { done: false, value: i2 }, h2 = o2 * n2, f2 = i2 + h2, m2 = void 0 === p2 ? f2 : p2(f2);
    return m2 !== f2 && (h2 = m2 - i2), { next: function(e3) {
      var t3 = -h2 * Math.exp(-e3 / l2);
      return d2.done = !(t3 > u2 || t3 < -u2), d2.value = d2.done ? m2 : m2 + t3, d2;
    }, flipTarget: function() {
    } };
  }
  var hp = { keyframes: pp, spring: yu, decay: dp }, fp = 1 / 60 * 1e3, mp = "undefined" != typeof performance ? function() {
    return performance.now();
  } : function() {
    return Date.now();
  }, _p = "undefined" != typeof window ? function(e2) {
    return window.requestAnimationFrame(e2);
  } : function(e2) {
    return setTimeout(function() {
      return e2(mp());
    }, fp);
  }, gp = true, vp = false, yp = false, bp = { delta: 0, timestamp: 0 }, wp = ["read", "update", "preRender", "render", "postRender"], Ap = wp.reduce(function(e2, t2) {
    return e2[t2] = function(e3) {
      var t3 = [], n2 = [], r2 = 0, i2 = false, s2 = /* @__PURE__ */ new WeakSet(), o2 = { schedule: function(e4, o3, a2) {
        void 0 === o3 && (o3 = false), void 0 === a2 && (a2 = false);
        var l2 = a2 && i2, c2 = l2 ? t3 : n2;
        return o3 && s2.add(e4), -1 === c2.indexOf(e4) && (c2.push(e4), l2 && i2 && (r2 = t3.length)), e4;
      }, cancel: function(e4) {
        var t4 = n2.indexOf(e4);
        -1 !== t4 && n2.splice(t4, 1), s2.delete(e4);
      }, process: function(a2) {
        var l2;
        if (i2 = true, t3 = (l2 = [n2, t3])[0], (n2 = l2[1]).length = 0, r2 = t3.length)
          for (var c2 = 0; c2 < r2; c2++) {
            var u2 = t3[c2];
            u2(a2), s2.has(u2) && (o2.schedule(u2), e3());
          }
        i2 = false;
      } };
      return o2;
    }(function() {
      return vp = true;
    }), e2;
  }, {}), xp = wp.reduce(function(e2, t2) {
    var n2 = Ap[t2];
    return e2[t2] = function(e3, t3, r2) {
      return void 0 === t3 && (t3 = false), void 0 === r2 && (r2 = false), vp || Mp(), n2.schedule(e3, t3, r2);
    }, e2;
  }, {}), Ep = wp.reduce(function(e2, t2) {
    return e2[t2] = Ap[t2].cancel, e2;
  }, {}), Cp = function(e2) {
    return Ap[e2].process(bp);
  }, Sp = function(e2) {
    vp = false, bp.delta = gp ? fp : Math.max(Math.min(e2 - bp.timestamp, 40), 1), bp.timestamp = e2, yp = true, wp.forEach(Cp), yp = false, vp && (gp = false, _p(Sp));
  }, Mp = function() {
    vp = true, gp = true, yp || _p(Sp);
  }, Tp = function() {
    return bp;
  }, Pp = xp;
  function Ip(e2, t2, n2) {
    return void 0 === n2 && (n2 = 0), e2 - t2 - n2;
  }
  var Rp = function(e2) {
    var t2 = function(t3) {
      var n2 = t3.delta;
      return e2(n2);
    };
    return { start: function() {
      return Pp.update(t2, true);
    }, stop: function() {
      return Ep.update(t2);
    } };
  };
  function kp(e2) {
    var t2, n2, r2, i2, s2, o2 = e2.from, a2 = e2.autoplay, l2 = void 0 === a2 || a2, c2 = e2.driver, u2 = void 0 === c2 ? Rp : c2, p2 = e2.elapsed, d2 = void 0 === p2 ? 0 : p2, h2 = e2.repeat, f2 = void 0 === h2 ? 0 : h2, m2 = e2.repeatType, _2 = void 0 === m2 ? "loop" : m2, g2 = e2.repeatDelay, v2 = void 0 === g2 ? 0 : g2, y2 = e2.onPlay, b2 = e2.onStop, w2 = e2.onComplete, A2 = e2.onRepeat, x2 = e2.onUpdate, E2 = su(e2, ["from", "autoplay", "driver", "elapsed", "repeat", "repeatType", "repeatDelay", "onPlay", "onStop", "onComplete", "onRepeat", "onUpdate"]), C2 = E2.to, S2 = 0, M2 = E2.duration, T2 = false, P2 = true, I2 = function(e3) {
      if (Array.isArray(e3.to))
        return pp;
      if (hp[e3.type])
        return hp[e3.type];
      var t3 = new Set(Object.keys(e3));
      return t3.has("ease") || t3.has("duration") && !t3.has("dampingRatio") ? pp : t3.has("dampingRatio") || t3.has("stiffness") || t3.has("mass") || t3.has("damping") || t3.has("restSpeed") || t3.has("restDelta") ? yu : pp;
    }(E2);
    (null === (n2 = (t2 = I2).needsInterpolation) || void 0 === n2 ? void 0 : n2.call(t2, o2, C2)) && (s2 = cp([0, 100], [o2, C2], { clamp: false }), o2 = 0, C2 = 100);
    var R2 = I2(iu(iu({}, E2), { from: o2, to: C2 }));
    return l2 && (null == y2 || y2(), (r2 = u2(function(e3) {
      if (P2 || (e3 = -e3), d2 += e3, !T2) {
        var t3 = R2.next(Math.max(0, d2));
        i2 = t3.value, s2 && (i2 = s2(i2)), T2 = P2 ? t3.done : d2 <= 0;
      }
      null == x2 || x2(i2), T2 && (0 === S2 && (null != M2 || (M2 = d2)), S2 < f2 ? function(e4, t4, n3, r3) {
        return r3 ? e4 >= t4 + n3 : e4 <= -n3;
      }(d2, M2, v2, P2) && (S2++, "reverse" === _2 ? d2 = function(e4, t4, n3, r3) {
        return void 0 === n3 && (n3 = 0), void 0 === r3 && (r3 = true), r3 ? Ip(t4 + -e4, t4, n3) : t4 - (e4 - t4) + n3;
      }(d2, M2, v2, P2 = S2 % 2 == 0) : (d2 = Ip(d2, M2, v2), "mirror" === _2 && R2.flipTarget()), T2 = false, A2 && A2()) : (r2.stop(), w2 && w2()));
    })).start()), { stop: function() {
      null == b2 || b2(), r2.stop();
    } };
  }
  const Dp = { linear: Hc, easeIn: Qc, easeOut: Wc, easeInOut: qc, circIn: Xc, circOut: Yc, circInOut: Kc, backIn: Jc, backOut: Zc, backInOut: $c, anticipate: eu, bounceOut: tu, bounceIn: nu, bounceInOut: ru, easeInOutSine: function(e2) {
    return -(Math.cos(Math.PI * e2) - 1) / 2;
  } };
  function Bp(e2, t2, n2) {
    const r2 = e2[t2], i2 = () => {
      null == n2 || n2();
    };
    return r2.isColor ? (e3) => {
      r2.set(e3), i2();
    } : "function" == typeof r2.copy ? (e3) => {
      r2.copy(e3), i2();
    } : (n3) => {
      e2[t2] = n3, i2();
    };
  }
  function Op(e2) {
    return "boolean" != typeof e2;
  }
  async function Lp(e2, n2, r2, i2, s2 = false) {
    n2 in e2 || console.error("invalid key", n2, e2);
    const o2 = Bp(e2, n2), a2 = s2 || void 0 === r2.from ? e2[n2] : r2.from, l2 = (e3) => {
      var t2;
      o2(e3), null === (t2 = r2.onUpdate) || void 0 === t2 || t2.call(r2, e3);
    };
    if (Op(a2))
      return "function" == typeof r2.to && (r2 = { ...r2, to: r2.to(a2, e2) }), Up({ ...r2, from: a2, onUpdate: l2 }, i2);
    {
      const { duration: e3 } = r2;
      return (0, t.timeout)(null != e3 ? e3 : 0).then(() => l2(r2.to));
    }
  }
  async function Up(e2, t2) {
    const n2 = e2.onComplete, r2 = e2.onStop, i2 = e2.onEnd;
    return e2 = { ...e2 }, new Promise((s2, o2) => {
      e2.onComplete = () => {
        try {
          null == n2 || n2();
        } catch (e3) {
          return null == i2 || i2(), void o2(e3);
        }
        null == i2 || i2(), s2();
      }, e2.onStop = () => {
        try {
          null == r2 || r2();
        } catch (e3) {
          return null == i2 || i2(), void o2(e3);
        }
        null == i2 || i2(), s2();
      };
      const a2 = kp(e2);
      t2 && t2.push(a2);
    });
  }
  var Fp = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let Np = 1, jp = class {
    constructor(e2, t2, r2, i2, s2) {
      this.position = new n.Pa4(), this.target = new n.Pa4(), this.quaternion = new n._fP(), this.up = new n.Pa4(), this.name = "Camera View", this.snap = "", this.focusView = () => {
      }, this.deleteView = () => {
      }, this.updateView = () => {
      }, this.uiConfig = Qe(this.name, this), e2 && (this.position = e2), t2 && (this.target = t2), r2 && (this.up = r2), i2 && (this.quaternion = i2), s2 && (this.snap = s2), this.name = "#view" + Np++;
    }
    _nameChanged() {
      var e2, t2;
      this.uiConfig && (this.uiConfig.label = this.name, null === (t2 = (e2 = this.uiConfig).uiRefresh) || void 0 === t2 || t2.call(e2));
    }
  };
  Fp([ie(), Fe()], jp.prototype, "position", void 0), Fp([ie(), Fe()], jp.prototype, "target", void 0), Fp([ie(), Fe()], jp.prototype, "quaternion", void 0), Fp([ie(), Fe()], jp.prototype, "up", void 0), Fp([ie(), ze()], jp.prototype, "name", void 0), Fp([Ve()], jp.prototype, "snap", void 0), Fp([je()], jp.prototype, "focusView", void 0), Fp([je()], jp.prototype, "deleteView", void 0), Fp([je()], jp.prototype, "updateView", void 0), jp = Fp([pe("CameraView")], jp);
  class zp extends gt {
    get animationLooping() {
      return this._animationLooping;
    }
    get animating() {
      return this._animating;
    }
    constructor() {
      super(), this.enabled = true, this._cameraViews = [], this.viewLooping = false, this.viewPauseTime = 200, this.animEase = "easeInOutSine", this.animDuration = 1e3, this.rotationOffset = 0.25, this.interpolateMode = "spherical", this.animateOnScroll = false, this.seekOnScroll = false, this._animating = false, this.dependencies = [], this._scrollAnimationState = 0, this.scrollAnimationDamping = 0.1, this._updaters = [], this._lastFrameTime = 0, this._fadeDisabled = false, this._viewQueue = [], this._animationLooping = false, this._infiniteLooping = true, this._driver = (e2) => ({ start: () => this._updaters.push({ u: e2, time: 0 }), stop: () => this._updaters.splice(this._updaters.findIndex((t2) => t2.u === e2), 1) }), this.focusNext = (e2 = true) => {
        if (this._animating)
          return;
        if (this._cameraViews.length < 2)
          return;
        let t2 = this._cameraViews.findIndex((e3) => e3 === this._currentView);
        t2 < 0 && (t2 = -1), t2 += 1, e2 ? t2 %= this._cameraViews.length : t2 = Math.min(t2, this._cameraViews.length - 1), this.focusView(this._cameraViews[t2]);
      }, this.focusPrevious = (e2 = true) => {
        if (this._animating)
          return;
        if (this._cameraViews.length < 2 || !this._currentView)
          return;
        let t2 = this._cameraViews.findIndex((e3) => e3 === this._currentView);
        t2 < 0 && (t2 = 0), t2 -= 1, t2 = e2 ? (t2 + this._cameraViews.length) % this._cameraViews.length : Math.max(t2, 0), this.focusView(this._cameraViews[t2]);
      }, this._popAnimations = [], this.uiConfig = { type: "folder", label: "Camera Views", children: [() => [...this._cameraViews.map((e2) => e2.uiConfig)], ...He(this)] }, this.addCurrentView = this.addCurrentView.bind(this), this.animateAllViews = this.animateAllViews.bind(this), this.recordAllViews = this.recordAllViews.bind(this), this.resetToFirstView = this.resetToFirstView.bind(this), this._wheel = this._wheel.bind(this), this._pointerMove = this._pointerMove.bind(this), this._postFrame = this._postFrame.bind(this);
    }
    get camViews() {
      return this._cameraViews;
    }
    _wheel(e2) {
      this.enabled && (this.seekOnScroll && !this._animating || Math.abs(e2.deltaY) > 1e-3 && (this._scrollAnimationState = -1 * Math.sign(e2.deltaY)));
    }
    _pointerMove(e2) {
      var t2;
      if (this.enabled && !this._animating && this.seekOnScroll) {
        const r2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.scene.activeCamera;
        if (!r2)
          return;
        const i2 = new n.$V(), s2 = r2.position, o2 = r2.target, a2 = new n._fP().setFromUnitVectors(r2.cameraObject.up, new n.Pa4(0, 1, 0)), l2 = a2.clone().invert(), c2 = s2.clone().sub(o2);
        c2.applyQuaternion(a2), i2.setFromVector3(c2), i2.theta += this.rotationOffset * e2.movementX / this._viewer.canvas.clientWidth, i2.phi += this.rotationOffset * e2.movementY / this._viewer.canvas.clientHeight, i2.makeSafe(), c2.setFromSpherical(i2), c2.applyQuaternion(l2), s2.copy(o2).add(c2), r2.positionUpdated(false), r2.targetUpdated();
      }
    }
    async onAdded(e2) {
      await super.onAdded(e2), e2.addEventListener("preFrame", (e3) => {
        this.seekOnScroll || this._animating ? this._viewer.scene.activeCamera.setInteractions(false, zp.PluginType) : this._viewer.scene.activeCamera.setInteractions(true, zp.PluginType);
      }), e2.addEventListener("postFrame", this._postFrame), window.addEventListener("wheel", this._wheel), window.addEventListener("pointermove", this._pointerMove);
    }
    _postFrame() {
      var e2, n2;
      if (!this._viewer)
        return;
      if (!this.enabled || !this._animating)
        return this._lastFrameTime = 0, void (this._fadeDisabled && (null === (e2 = this._viewer.getPluginByType("FrameFade")) || void 0 === e2 || e2.enable(zp.PluginType), this._fadeDisabled = false));
      const r2 = (0, t.now)() / 1e3;
      this._lastFrameTime < 1 && (this._lastFrameTime = r2 - 1 / 60);
      let i2 = r2 - this._lastFrameTime;
      this._lastFrameTime = r2, i2 *= this.animateOnScroll ? this._scrollAnimationState : 1;
      const s2 = null === (n2 = this._viewer.getPluginByType("Progressive")) || void 0 === n2 ? void 0 : n2.postFrameConvergedRecordingDelta();
      if (s2 && s2 > 0 && (i2 = s2), 0 !== s2 && (i2 *= 1e3, !(i2 <= 0 || (this._updaters.forEach((e3) => {
        let t2 = i2;
        e3.time + t2 < 0 && (t2 = -e3.time), e3.time += t2, Math.abs(t2) > 1e-3 && e3.u(t2);
      }), this._scrollAnimationState < 1e-3 ? this._scrollAnimationState = 0 : this._scrollAnimationState *= 1 - this.scrollAnimationDamping, this._fadeDisabled)))) {
        const e3 = this._viewer.getPluginByType("FrameFade");
        e3 && (e3.disable(zp.PluginType), this._fadeDisabled = true);
      }
    }
    async onRemove(e2) {
      return e2.removeEventListener("postFrame", this._postFrame), window.removeEventListener("wheel", this._wheel), window.removeEventListener("pointermove", this._pointerMove), super.onRemove(e2);
    }
    async _animationLoop() {
      if (!this._animationLooping) {
        for (this._animationLooping = true; (this.viewLooping || !this._infiniteLooping) && this.enabled && !(this._cameraViews.length < 1); ) {
          if (0 === this._viewQueue.length) {
            if (!this._infiniteLooping)
              break;
            this._viewQueue.push(...this._cameraViews);
          }
          await this.animateToView(this._viewQueue.shift()), await (0, t.timeout)(2 + this.viewPauseTime);
        }
        this._animationLooping = false;
      }
    }
    async animateAllViews() {
      if (this.enabled && !(this.viewLooping || this._cameraViews.length < 2)) {
        for (; this._viewQueue.length > 0; )
          this._viewQueue.pop();
        this._viewQueue.push(...this._cameraViews), this._viewQueue.push(this._viewQueue.shift()), this._infiniteLooping = false, await this._animationLoop(), this._infiniteLooping = true;
      }
    }
    async resetToFirstView(e2 = 100) {
      this.enabled && (this._currentView = void 0, await this.animateToView(this._cameraViews[0], e2), await (0, t.timeout)(2));
    }
    async recordAllViews(e2, t2 = true) {
      var n2;
      if (!this.enabled)
        return;
      const r2 = null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.getPluginByType("CanvasRecorder");
      if (r2 && r2.enabled && !(this._cameraViews.length < 1)) {
        if (await this.resetToFirstView(), !r2.isRecording())
          return new Promise((n3, i2) => {
            const s2 = () => {
              r2.removeEventListener("start", o2), r2.removeEventListener("stop", s2), r2.removeEventListener("error", a2);
            }, o2 = async () => {
              var i3;
              s2(), null == e2 || e2(), await this.animateAllViews();
              const o3 = await r2.stopRecording();
              if (t2) {
                const e3 = await (null === (i3 = this._viewer) || void 0 === i3 ? void 0 : i3.prompt("Canvas Recorder: Save file as", "recording.mp4"));
                null !== e3 && o3 && await this._downloadBlob(o3, e3 || "recording.mp4");
              }
              n3(o3);
            }, a2 = async () => {
              s2(), i2();
            };
            r2.addEventListener("start", o2), r2.addEventListener("stop", s2), r2.addEventListener("error", a2), r2.startRecording() || console.error("cannot start recording");
          });
        console.error("CanvasRecorderPlugin is already recording");
      }
    }
    async addCurrentView() {
      var e2, t2;
      if (!this.enabled)
        return;
      const n2 = this.getCurrentCameraView();
      n2.snap = await (null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPlugin(Fc)) || void 0 === t2 ? void 0 : t2.getDataUrl({ displayPixelRatio: 0.25, mimeType: "image/jpg" })) || "", this.addView(n2);
    }
    addView(e2) {
      var t2, n2;
      this._cameraViews.push(e2), null === (n2 = (t2 = this.uiConfig).uiRefresh) || void 0 === n2 || n2.call(t2), this.dispatchEvent({ type: "viewAdd", view: e2 });
    }
    getCurrentCameraView(e2, t2 = true, r2) {
      var i2, s2, o2;
      if (e2 || (e2 = null === (i2 = this._viewer) || void 0 === i2 ? void 0 : i2.scene.activeCamera), !e2)
        return new jp();
      const a2 = new n.Pa4();
      e2.cameraObject.updateWorldMatrix(true, false);
      const l2 = e2.cameraObject.matrixWorld;
      a2.x = l2.elements[4], a2.y = l2.elements[5], a2.z = l2.elements[6], a2.normalize();
      const c2 = e2.target.clone(), u2 = e2.position.clone(), p2 = e2.cameraObject.parent;
      p2 && (t2 ? u2.applyMatrix4(p2.matrixWorld) : a2.transformDirection(p2.matrixWorld.clone().invert()));
      const d2 = t2 ? e2.cameraObject.getWorldQuaternion(new n._fP()) : e2.cameraObject.quaternion.clone();
      return r2 ? (r2.position.copy(u2), r2.target.copy(c2), r2.up.copy(a2), r2.quaternion.copy(d2)) : ((r2 = new jp(u2, c2, a2, d2, "")).focusView = async () => r2 && this.focusView(r2), r2.deleteView = () => r2 && this.deleteView(r2), r2.updateView = () => this.getCurrentCameraView(e2, t2, r2)), null === (o2 = (s2 = r2.uiConfig).uiRefresh) || void 0 === o2 || o2.call(s2, "postFrame", true), r2;
    }
    setCurrentCameraView(e2) {
      var t2;
      const n2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.scene.activeCamera;
      n2 && (n2.position.copy(e2.position), n2.target.copy(e2.target), n2.cameraObject.quaternion.copy(e2.quaternion), n2.positionUpdated());
    }
    async focusView(e2) {
      return this.animateToView(e2);
    }
    deleteView(e2) {
      var t2, n2;
      const r2 = this._cameraViews.indexOf(e2);
      r2 >= 0 && this._cameraViews.splice(r2, 1), null === (n2 = (t2 = this.uiConfig).uiRefresh) || void 0 === n2 || n2.call(t2), this.dispatchEvent({ type: "viewDelete", view: e2 });
    }
    async stopAllAnimations() {
      for (this.viewLooping = false, this._popAnimations.forEach((e2) => {
        var t2;
        return null === (t2 = null == e2 ? void 0 : e2.stop) || void 0 === t2 ? void 0 : t2.call(e2);
      }), this._popAnimations = []; this._animating || this._animationLooping; )
        await (0, t.timeout)(100);
    }
    async animateToView(e2, r2, i2, s2 = false) {
      var o2, a2;
      const l2 = null === (o2 = this._viewer) || void 0 === o2 ? void 0 : o2.scene.activeCamera;
      if (!l2)
        return;
      if (this._animating) {
        this._popAnimations.forEach((e4) => (null == e4 ? void 0 : e4.stop) && e4.stop()), this._popAnimations = [];
        let e3 = 0;
        for (; this._animating && (await (0, t.timeout)(100), !(e3++ > 20)); )
          ;
        if (this._animating)
          return void console.warn("Unable to stop all animations, maybe because of viewLooping?");
      }
      this._currentView = e2, this._animating = true, this.dispatchEvent({ type: "startViewChange", view: e2 }), void 0 === r2 && (r2 = this.animDuration), r2 = Math.max(10, r2);
      const c2 = "function" == typeof i2 ? i2 : Dp[i2 || this.animEase], u2 = this._driver, p2 = [];
      this._popAnimations = [];
      const d2 = this._popAnimations;
      if ("spherical" === this.interpolateMode)
        p2.push(async function(e3, t2, r3, i3, s3, o3, a3) {
          const l3 = e3.target.clone(), c3 = new n.Pa4(), u3 = new n.Pa4(), p3 = e3.cameraObject.parent, d3 = e3.cameraObject.up.clone(), h2 = Gp({ position: e3.cameraObject.getWorldPosition(new n.Pa4()), up: p3 ? d3.transformDirection(p3.matrixWorld) : d3 }, l3), f2 = Gp(t2, t2.target), m2 = new n.$V();
          function _2() {
            e3.position.copy(p3 ? p3.worldToLocal(u3) : u3), e3.target.copy(c3), e3.positionUpdated();
          }
          return Up({ from: 0, to: 1, duration: r3, ease: i3, driver: s3, onUpdate: (e4) => {
            m2.phi = Vp(h2.phi, f2.phi, e4), m2.theta = Vp(h2.theta, f2.theta, e4), m2.radius = n.M8C.lerp(h2.radius, f2.radius, e4), c3.copy(l3).lerp(t2.target, e4), u3.setFromSpherical(m2), u3.add(c3), _2();
          }, onComplete: () => {
            u3.copy(t2.position), c3.copy(t2.target), _2();
          }, onStop: () => {
            throw new Error("Animation Stopped");
          } }, o3);
        }(l2, e2, r2, c2, u2, d2));
      else if ("linear" === this.interpolateMode) {
        p2.push(Up({ from: l2.position.clone(), to: e2.position.clone(), duration: r2, ease: c2, driver: u2, onUpdate: (e3) => l2.position = e3, onComplete: () => l2.position = e2.position, onStop: () => {
          throw new Error("Animation stopped");
        } }, d2)), p2.push(Up({ from: l2.target.clone(), to: e2.target.clone(), duration: r2, ease: c2, driver: u2, onUpdate: (e3) => {
          l2.target = e3, l2.targetUpdated();
        }, onComplete: () => {
          l2.target = e2.target, l2.targetUpdated();
        } }, d2));
        const t2 = l2.cameraObject.quaternion.clone(), i3 = new n._fP();
        p2.push(Up({ from: 0, to: 1, duration: r2, ease: c2, driver: u2, onUpdate: (n2) => {
          i3.copy(t2).slerp(e2.quaternion, n2), l2.cameraObject.quaternion.copy(i3), l2.cameraObject.updateProjectionMatrix();
        }, onComplete: () => {
          l2.cameraObject.quaternion.copy(e2.quaternion), l2.cameraObject.updateProjectionMatrix();
        } }, d2));
      }
      await Promise.allSettled(p2).catch((e3) => {
        if (s2)
          throw e3;
      }), null === (a2 = this._viewer) || void 0 === a2 || a2.setDirty(), this._animating = false, this.dispatchEvent({ type: "viewChange", view: e2 }), await (0, t.timeout)(10);
    }
    fromJSON(e2, t2) {
      var n2, r2;
      return this._cameraViews.forEach((e3) => this.deleteView(e3)), super.fromJSON(e2, t2) ? (this._cameraViews.forEach((e3) => e3.focusView = async () => this.focusView(e3)), this._cameraViews.forEach((e3) => e3.deleteView = () => this.deleteView(e3)), this._cameraViews.forEach((e3) => e3.updateView = () => this.getCurrentCameraView(void 0, void 0, e3)), null === (r2 = (n2 = this.uiConfig).uiRefresh) || void 0 === r2 || r2.call(n2), this) : null;
    }
    async animateToObject(e2, t2 = 4, r2, i2, s2 = { min: 0.5, max: 5 }) {
      if (!this._viewer)
        return;
      const o2 = new h().expandByObject(e2 || this._viewer.scene.modelRoot.modelObject, false, true), a2 = o2.getCenter(new n.Pa4()), l2 = o2.getSize(new n.Pa4()).length() / 2;
      await this.animateToTarget(Math.min(s2.max, Math.max(s2.min, l2 * t2)), a2, r2, i2);
    }
    async animateToFitObject(e2, t2 = 1.5, r2 = 1e3, i2, s2 = { min: 0.5, max: 50 }) {
      if (!this._viewer)
        return;
      const o2 = new h().expandByObject(e2 || this._viewer.scene.modelRoot.modelObject, false, true), a2 = o2.getCenter(new n.Pa4()), l2 = o2.getSize(new n.Pa4());
      let c2 = this._viewer.scene.activeCamera.cameraObject, u2 = 1;
      if (c2.isPerspectiveCamera) {
        const e3 = Math.max(1, c2.fov) * (Math.PI / 180), t3 = 2 * Math.atan(Math.tan(e3 / 2) * c2.aspect), n2 = l2.z / 2 + Math.abs(l2.x / 2 / Math.tan(t3 / 2)), r3 = l2.z / 2 + Math.abs(l2.y / 2 / Math.tan(e3 / 2));
        u2 = Math.max(n2, r3);
      }
      await this.animateToTarget(Math.min(s2.max, Math.max(s2.min, u2 * t2)), a2, r2, i2);
    }
    async animateToTarget(e2, t2, r2, i2) {
      const s2 = this.getCurrentCameraView();
      s2.target.copy(t2);
      const o2 = new n.Pa4().subVectors(s2.target, s2.position).normalize();
      s2.position.copy(o2.multiplyScalar(-e2).add(s2.target)), await this.animateToView(s2, r2, i2);
    }
    async _downloadBlob(e2, t2) {
      var n2, r2;
      const i2 = null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.getPluginByType("FileTransferPlugin");
      i2 ? await i2.exportFile(e2, t2) : null === (r2 = this._viewer) || void 0 === r2 || r2.console.error("FileTransferPlugin required to export/download file");
    }
  }
  function Gp(e2, t2) {
    const r2 = e2.position.clone();
    r2.sub(t2);
    const i2 = new n.$V().setFromVector3(r2);
    return i2.makeSafe(), i2;
  }
  function Vp(e2, t2, n2) {
    const r2 = t2 - e2;
    return r2 >= Math.PI ? e2 + (r2 - 2 * Math.PI) * n2 : r2 <= -Math.PI ? e2 + (r2 + 2 * Math.PI) * n2 : e2 + r2 * n2;
  }
  function Hp(e2, t2, n2) {
    const r2 = (1 - n2) * Math.cos(e2) + n2 * Math.cos(t2), i2 = (1 - n2) * Math.sin(e2) + n2 * Math.sin(t2);
    return Math.atan2(i2, r2);
  }
  zp.PluginType = "CameraViews", Fp([ie("cameraViews")], zp.prototype, "_cameraViews", void 0), Fp([(0, t.onChange)(zp.prototype._animationLoop), ie(), Oe("Loop All Views", { limitedUi: true })], zp.prototype, "viewLooping", void 0), Fp([ie(), ze("View Pause Time")], zp.prototype, "viewPauseTime", void 0), Fp([ie(), Ne("Ease", Object.keys(Dp).map((e2) => ({ label: e2 })))], zp.prototype, "animEase", void 0), Fp([ie(), Ue("Duration", [10, 1e4], 10, { limitedUi: true })], zp.prototype, "animDuration", void 0), Fp([ie(), Ue("RotationOffset", [0.2, 0.75], 0.01)], zp.prototype, "rotationOffset", void 0), Fp([ie(), Ne("Interpolation", ["spherical", "linear"].map((e2) => ({ label: e2 })))], zp.prototype, "interpolateMode", void 0), Fp([Oe(), ie()], zp.prototype, "seekOnScroll", void 0), Fp([je("Animate All Views", { limitedUi: true })], zp.prototype, "animateAllViews", null), Fp([je("Record All Views")], zp.prototype, "recordAllViews", null), Fp([je("Add Current View")], zp.prototype, "addCurrentView", null), Fp([je("Focus Next")], zp.prototype, "focusNext", void 0), Fp([je("Focus Previous")], zp.prototype, "focusPrevious", void 0);
  const Qp = new n.Pa4();
  function Wp(e2, t2, n2) {
    let r2 = e2.dot(t2);
    r2 = Math.min(Math.max(r2, -1), 1);
    const i2 = Math.acos(r2) * n2;
    return Qp.copy(e2).multiplyScalar(r2).sub(t2).negate().normalize(), e2.multiplyScalar(Math.cos(i2)).add(Qp.multiplyScalar(Math.sin(i2)));
  }
  var qp, Xp = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let Yp = qp = class {
    constructor(e2) {
      this.enabled = false, this.power = 0.5, this.bgcolor = new n.Ilk(0), this.extraUniforms = { power: { value: 0.5 }, bgcolor: { value: new n.Ilk() } }, this.parsFragmentSnippet = (e3, n2) => this.enabled ? t.glsl`
            uniform float power;
            uniform vec3 bgcolor;
            ${"vec4 Vignette(in vec4 color){vec2 uv=vUv*(1.-vUv);float vig=uv.x*uv.y*16.;vig=pow(vig,power);return vec4(mix(color.rgb,vec3(bgcolor),1.-vig),color.a);}"}
        ` : "", this._combinedPostPlugin = e2.getPlugin(Qs), this._setDirty = this._setDirty.bind(this);
    }
    shaderExtender(e2, t2, n2) {
      this.enabled && (e2.fragmentShader = ot(e2.fragmentShader, "#glMarker", " \n            gl_FragColor = Vignette(gl_FragColor);\n            #glMarker\n        "));
    }
    onObjectRender(e2, t2, n2) {
      this.enabled && (this.extraUniforms.power.value = this.power, this.extraUniforms.bgcolor.value.copy(this.bgcolor));
    }
    getUiConfig() {
      return this.uiConfig;
    }
    computeCacheKey(e2) {
      return this.enabled ? "1" : "0";
    }
    isCompatible(e2) {
      return true;
    }
    _setDirty() {
      this._combinedPostPlugin && (this._combinedPostPlugin.pass.dirty = true);
    }
    setDirty() {
      var e2;
      null === (e2 = this.__setDirty) || void 0 === e2 || e2.call(this), this._setDirty();
    }
  };
  Yp.PluginType = "Vignette", Xp([(0, t.onChange)(qp.prototype._setDirty), Oe("Enable"), ie()], Yp.prototype, "enabled", void 0), Xp([(0, t.onChange)(qp.prototype._setDirty), Ue("Power", [0.1, 4], 0.01, { limitedUi: true }), ie()], Yp.prototype, "power", void 0), Xp([(0, t.onChange)(qp.prototype._setDirty), Ge("Color"), ie()], Yp.prototype, "bgcolor", void 0), Yp = qp = Xp([We("Vignette")], Yp);
  class Kp extends qs {
    constructor() {
      super();
    }
    generateExtension(e2) {
      return new Yp(e2);
    }
    get power() {
      var e2, t2;
      return null !== (t2 = null === (e2 = this._extension) || void 0 === e2 ? void 0 : e2.power) && void 0 !== t2 ? t2 : 1;
    }
    set power(e2) {
      this._extension && (this._extension.power = e2, this._extension.setDirty());
    }
    get color() {
      var e2, t2;
      return null !== (t2 = null === (e2 = this._extension) || void 0 === e2 ? void 0 : e2.bgcolor) && void 0 !== t2 ? t2 : new n.Ilk();
    }
    set color(e2) {
      this._extension && (this._extension.bgcolor.set(e2), this._extension.setDirty());
    }
  }
  Kp.PluginType = "Vignette";
  var Jp = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let Zp = class extends gt {
    constructor() {
      super(), this.enabled = true, this.dependencies = [Ls], this.scenes = [], this.assets = {}, this.toJSON = void 0, this._isPlaying = false, this._isPlayingLoop = false, this._options = {}, this.minSceneTime = 2e3, this.loadScenes = this.loadScenes.bind(this), this.play = this.play.bind(this), this.stop = this.stop.bind(this), this.downloadScenes = this.downloadScenes.bind(this), this.promptLoadScenes = this.promptLoadScenes.bind(this);
    }
    get loadedScenes() {
      return this.scenes.length;
    }
    async promptLoadScenes() {
      const e2 = await (0, t.uploadFile)(true, false, "model/gltf");
      await this.loadScenes(e2);
    }
    async loadScenes(e2) {
      var t2, n2;
      const r2 = await Promise.all(e2.map(async (e3) => await e3.arrayBuffer()));
      for (let t3 = 0; t3 < e2.length; t3++) {
        const n3 = e2[t3];
        this.scenes.push({ [n3.name]: new Uint8Array(r2[t3]) }), this.assets[n3.name] = { path: n3.name, file: n3 };
      }
      null === (n2 = null === (t2 = this.uiConfig) || void 0 === t2 ? void 0 : t2.uiRefresh) || void 0 === n2 || n2.call(t2);
    }
    async play() {
      var e2, n2;
      if (!this._viewer)
        return;
      if (this._isPlaying || this._isPlayingLoop)
        return;
      this._isPlaying = true, this._isPlayingLoop = true;
      const r2 = null !== (e2 = this._viewer.getPluginByType("AssetManagerBasicPopupPlugin")) && void 0 !== e2 ? e2 : this._viewer.getPluginByType("LoadingScreenPlugin");
      null == r2 || r2.enabled, r2 && (r2.enabled = false);
      const i2 = this._viewer.getPluginByType("FrameFade"), s2 = this._viewer.getPluginByType("GLTFAnimation"), o2 = this._viewer.getPluginByType("CameraViews");
      for (; this._isPlaying; )
        for (const e3 of this.scenes) {
          if (!this._isPlaying)
            break;
          const a2 = Object.keys(e3);
          null == s2 || s2.stopAnimation(false), await (null == o2 ? void 0 : o2.stopAllAnimations()), this._viewer.scene.removeSceneModels(), this._viewer.renderEnabled = false;
          for (const t2 of a2) {
            let r3 = this.assets[t2];
            r3 || (r3 = { path: t2, file: new File([e3[t2]], t2) }, this.assets[t2] = r3), await (null === (n2 = this._viewer.getManager()) || void 0 === n2 ? void 0 : n2.addAssetSingle(r3, this._options));
          }
          if (!this._isPlaying)
            break;
          this._viewer.renderEnabled = true, r2 && (r2.enabled = false), i2 && (i2.enabled = true, await i2.startTransition(1e3));
          const l2 = [(0, t.timeout)(this.minSceneTime)];
          s2 && l2.push(s2.playAnimation()), o2 && l2.push(o2.animateAllViews()), await Promise.all(l2);
        }
      this._isPlayingLoop = false;
    }
    stop() {
      this._isPlaying = false;
    }
    async downloadScenes() {
      const e2 = {};
      for (const t2 of this.scenes)
        for (const n3 of Object.keys(t2)) {
          const r3 = e2[n3] ? n3 + "_" : n3;
          e2[r3] = t2[r3];
        }
      const n2 = Es(e2), r2 = new Blob([n2], { type: "application/zip" });
      (0, t.downloadBlob)(r2, "scenes.glbloop");
    }
    async onAdded(e2) {
      var n2, r2;
      await super.onAdded(e2);
      const i2 = this;
      null === (r2 = null === (n2 = e2.getManager()) || void 0 === n2 ? void 0 : n2.importer) || void 0 === r2 || r2.Importers.push(new Ft(class extends Rs {
        load(e3, n3, r3, s2) {
          super.load(e3, (e4) => {
            i2.loadScenes([...e4.values()]), null == n3 || n3(null), (0, t.timeout)(100).then(i2.play);
          }, r3, s2);
        }
      }, ["glbloop"], true));
    }
  };
  Zp.PluginType = "SceneLoopPlugin", Jp([Le("Loaded scenes")], Zp.prototype, "loadedScenes", null), Jp([je("Load Scenes")], Zp.prototype, "promptLoadScenes", null), Jp([Le("Playing")], Zp.prototype, "_isPlaying", void 0), Jp([ze("Min Scene Time")], Zp.prototype, "minSceneTime", void 0), Jp([je("Play")], Zp.prototype, "play", null), Jp([je("Stop")], Zp.prototype, "stop", null), Jp([je("Download Scenes")], Zp.prototype, "downloadScenes", null), Zp = Jp([We("Scene Loop")], Zp);
  var $p = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let ed = class extends ht {
    constructor(e2, t2, r2) {
      super(e2, t2, null != r2 ? r2 : new td(), new n.Ilk(0.5, 0.5, 0.5), 1), this.enabled = true, this._firstCall = true;
    }
    render(e2, t2, n2, r2, i2) {
      if (!this.enabled || !this.camera)
        return;
      const s2 = this.overrideMaterial;
      s2.uniforms.currentProjectionViewMatrix.value.copy(this.camera.projectionMatrix).multiply(this.camera.matrixWorldInverse), this._firstCall && (s2.uniforms.lastProjectionViewMatrix.value.copy(s2.uniforms.currentProjectionViewMatrix.value), this._firstCall = false), super.render(e2, t2, n2, r2, i2), s2.uniforms.lastProjectionViewMatrix.value.copy(s2.uniforms.currentProjectionViewMatrix.value);
    }
  };
  $p([Oe("Enabled")], ed.prototype, "enabled", void 0), ed = $p([We("Velocity Buffer (TAA)")], ed);
  class td extends n.jyz {
    constructor() {
      super({ vertexShader: "#ifdef USE_ALPHAMAP\n#define USE_UV \n#endif\n#include <uv_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec3 vWorldPosition;varying vec3 vWorldPositionPrevious;uniform mat4 modelMatrixPrevious;void main(){\n#include <uv_vertex>\n#include <skinbase_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\nvec4 mvPosition=vec4(transformed,1.);\n#ifdef USE_INSTANCING\nmvPosition=instanceMatrix*mvPosition;\n#endif\nvWorldPosition=(modelMatrix*mvPosition).xyz;vWorldPositionPrevious=(modelMatrixPrevious*mvPosition).xyz;mvPosition=modelViewMatrix*mvPosition;gl_Position=projectionMatrix*mvPosition;\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n}", fragmentShader: "varying vec3 vWorldPosition;varying vec3 vWorldPositionPrevious;uniform mat4 currentProjectionViewMatrix;uniform mat4 lastProjectionViewMatrix;vec2 computeScreenSpaceVelocity2(){vec4 currentPositionClip=currentProjectionViewMatrix*vec4(vWorldPosition,1.);vec4 prevPositionClip=lastProjectionViewMatrix*vec4(vWorldPositionPrevious,1.);vec2 currentPositionNDC=currentPositionClip.xy/currentPositionClip.w;vec2 prevPositionNDC=prevPositionClip.xy/prevPositionClip.w;if(prevPositionNDC.x>=1.||prevPositionNDC.x<=-1.||prevPositionNDC.x>=1.||prevPositionNDC.y<=-1.){return vec2(0.);}return 0.5*(currentPositionNDC-prevPositionNDC);}void main(){vec2 velocity=clamp(computeScreenSpaceVelocity2(),-1.,1.);velocity=sign(velocity)*pow(abs(velocity),vec2(1./4.));velocity=velocity*0.5+0.5;gl_FragColor=vec4(velocity.x,velocity.y,1.,1.);}", uniforms: { cameraNearFar: { value: new n.FM8(0.1, 1e3) }, alphaMap: { value: null }, alphaTest: { value: null }, alphaMapTransform: { value: new n.Vkp() }, currentProjectionViewMatrix: { value: new n.yGw() }, lastProjectionViewMatrix: { value: new n.yGw() } } }), this.extraUniformsToUpload = { modelMatrixPrevious: { value: new n.yGw().identity() } }, this._previousWorldMatrices = {};
    }
    onBeforeRender(e2, t2, r2, i2, s2) {
      var o2, a2;
      const l2 = this._previousWorldMatrices[s2.uuid];
      this.extraUniformsToUpload.modelMatrixPrevious.value.copy(null != l2 ? l2 : s2.matrixWorld), l2 ? l2.copy(s2.matrixWorld) : this._previousWorldMatrices[s2.uuid] = s2.matrixWorld.clone();
      let c2 = s2.material;
      Array.isArray(c2) && (c2 = c2[0]), this.uniforms.alphaMap.value = null !== (o2 = null == c2 ? void 0 : c2.alphaMap) && void 0 !== o2 ? o2 : null, this.uniforms.alphaTest.value = !c2 || !c2.alphaTest || c2.alphaTest < 1e-7 ? 1e-3 : c2.alphaTest;
      let u2 = this.uniforms.alphaMap.value ? 1 : void 0;
      u2 !== this.defines.USE_ALPHAMAP && (void 0 === u2 ? delete this.defines.USE_ALPHAMAP : this.defines.USE_ALPHAMAP = u2, this.needsUpdate = true), u2 = c2.userData.ALPHA_I_RGBA_PACKING ? 1 : void 0, u2 !== this.defines.ALPHA_I_RGBA_PACKING && (void 0 === u2 ? delete this.defines.ALPHA_I_RGBA_PACKING : this.defines.ALPHA_I_RGBA_PACKING = u2, this.needsUpdate = true), this.side = null !== (a2 = c2.side) && void 0 !== a2 ? a2 : n.ehD;
    }
  }
  class nd extends yt {
    passCtor(e2) {
      const t2 = e2.renderer.createTarget({ depthBuffer: true, type: n.ywz });
      t2.texture.name = "velocityBuffer", this._velocityBuffers.push(t2), e2.getPluginByType("debug");
      const r2 = /* @__PURE__ */ new Set(), i2 = /* @__PURE__ */ new Set();
      return new class extends ed {
        render(n2, s2, o2, a2, l2) {
          var c2;
          if (e2.renderer.frameCount > 0)
            return;
          const u2 = n2.getRenderTarget(), p2 = n2.getActiveCubeFace(), d2 = n2.getActiveMipmapLevel();
          null === (c2 = this.scene) || void 0 === c2 || c2.traverse(({ material: e3 }) => {
            var t3, n3;
            if (!e3)
              return;
            const s3 = e3.userData.renderToDepth && !e3.userData.pluginsDisabled && !(null === (t3 = e3.userData[nd.PluginType]) || void 0 === t3 ? void 0 : t3.disabled), o3 = false === e3.userData.renderToDepth || e3.userData.pluginsDisabled || (null === (n3 = e3.userData[nd.PluginType]) || void 0 === n3 ? void 0 : n3.disabled);
            (e3.transparent && s3 || !e3.transparent && !e3.transmission && o3) && (r2.add(e3), e3.transparent = !e3.transparent), Math.abs(e3.transmission || 0) > 0 && s3 && (i2.add([e3, e3.transmission]), e3.transmission = 0);
          }), H(n2, { shadowMapRender: false, backgroundRender: false, opaqueRender: true, transparentRender: false, transmissionRender: false, mainRenderPass: false }, () => super.render(n2, s2, t2, a2, l2)), r2.forEach((e3) => e3.transparent = !e3.transparent), r2.clear(), i2.forEach(([e3, t3]) => e3.transmission = t3), i2.clear(), n2.setRenderTarget(u2, p2, d2);
        }
      }();
    }
    _update(e2) {
      if (!super._update(e2))
        return false;
      if (e2.renderer.frameCount > 0)
        return false;
      const t2 = this.pass.passObject;
      return t2.scene = e2.scene.modelObject, e2.scene.renderCamera.updateShaderProperties(t2.overrideMaterial), t2.camera = e2.scene.renderCamera.cameraObject, true;
    }
    constructor(e2 = true) {
      super(), this.passId = "velocityBuffer", this._beforeFilters = ["render"], this._afterFilters = [], this._requiredFilters = ["render"], this._velocityBuffers = [], this.enabled = e2;
    }
    getVelocityBuffer() {
      return this._velocityBuffers.length > 0 ? this._velocityBuffers[0] : void 0;
    }
    async onDispose(e2) {
    }
    async onRemove(e2) {
      return this._velocityBuffers.forEach((t2) => {
        var n2;
        return e2.renderer.disposeTarget(null === (n2 = null == t2 ? void 0 : t2.dispose) || void 0 === n2 ? void 0 : n2.call(t2));
      }), super.onRemove(e2);
    }
    updateShaderProperties(e2) {
      var t2, n2;
      return e2.uniforms.tVelocity ? e2.uniforms.tVelocity.value = this.enabled && null !== (n2 = null === (t2 = this.getVelocityBuffer()) || void 0 === t2 ? void 0 : t2.texture) && void 0 !== n2 ? n2 : null : console.warn("BaseRenderer: no uniform: tVelocity"), this;
    }
    get uiConfig() {
      var e2;
      return null === (e2 = this.pass) || void 0 === e2 ? void 0 : e2.passObject.uiConfig;
    }
  }
  nd.PluginType = "VelocityBuffer";
  var rd, id = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let sd = rd = class {
    constructor(e2) {
      this.enabled = false, this.lutBackground = true, this.intensity = 1, this.lutMap = void 0, this.lutMap1 = void 0, this.lutMap2 = void 0, this.extraUniforms = { intensity: { value: 1 }, lutSize: { value: 1 }, lutSize1: { value: 1 }, lutSize2: { value: 1 }, lut3d: { value: null }, lut3d1: { value: null }, lut3d2: { value: null }, lut2d: { value: null }, lut2d1: { value: null }, lut2d2: { value: null } }, this.extraDefines = { USE_LUT: 0, USE_LUT1: 0, USE_LUT2: 0, USE_3DTEXTURE: 0, LUT_BACKGROUND: 0 }, this.parsFragmentSnippet = (e3, t2) => this.enabled ? "#if (USE_LUT == 1 || USE_LUT1 == 1 || USE_LUT2 == 1)\nuniform float lutSize;uniform float lutSize1;uniform float lutSize2;uniform float intensity;\n#if USE_3DTEXTURE == 1\nprecision highp sampler3D;\n#if USE_LUT == 1\nuniform sampler3D lut3d;\n#endif\n#if USE_LUT1 == 1\nuniform sampler3D lut3d1;\n#endif\n#if USE_LUT2 == 1\nuniform sampler3D lut3d2;\n#endif\n#else\n#if USE_LUT == 1\nuniform sampler2D lut2d;\n#endif\n#if USE_LUT1 == 1\nuniform sampler2D lut2d1;\n#endif\n#if USE_LUT2 == 1\nuniform sampler2D lut2d2;\n#endif\nvec3 lutLookup(sampler2D tex,float size,vec3 rgb){float sliceHeight=1./size;float yPixelHeight=1./(size*size);float slice=rgb.b*size;float interp=fract(slice);float slice0=slice-interp;float centeredInterp=interp-0.5;float slice1=slice0+sign(centeredInterp);float greenOffset=clamp(rgb.g*sliceHeight,yPixelHeight*0.5,sliceHeight-yPixelHeight*0.5);vec2 uv0=vec2(rgb.r,slice0*sliceHeight+greenOffset);vec2 uv1=vec2(rgb.r,slice1*sliceHeight+greenOffset);vec3 sample0=texture2D(tex,uv0).rgb;vec3 sample1=texture2D(tex,uv1).rgb;return mix(sample0,sample1,abs(centeredInterp));}\n#endif\nint getLUTBit(in int number){\n#ifdef WebGL2Context\nreturn number%2;\n#else\nreturn int(mod(float(number),2.));\n#endif\n}int getLUTIndex(in int number){\n#ifdef WebGL2Context\nreturn number%8;\n#else\nreturn int(mod(float(number),8.));\n#endif\n}vec3 getUVW(in float lutSize,in vec4 color){float pixelWidth=1./lutSize;float halfPixelWidth=0.5/lutSize;vec3 uvw=vec3(halfPixelWidth)+color.rgb*(1.-pixelWidth);return uvw;}vec4 colorLookUp(in vec4 color){vec4 outColor;float lutFac=float(getLUTBit(getGBufferFlags(vUv).a));float lutIndex=float(getLUTIndex(getGBufferFlags(vUv).g));\n#if USE_3DTEXTURE == 1\nif(lutIndex==0.){\n#if USE_LUT == 1\noutColor=vec4(texture(lut3d,getUVW(lutSize,color)).rgb,color.a);\n#endif\n}else if(lutIndex==1.){\n#if USE_LUT1 == 1\noutColor=vec4(texture(lut3d1,getUVW(lutSize1,color)).rgb,color.a);\n#endif\n}else if(lutIndex==2.){\n#if USE_LUT2 == 1\noutColor=vec4(texture(lut3d2,getUVW(lutSize2,color)).rgb,color.a);\n#endif\n}else{\n#if USE_LUT == 1\noutColor=vec4(texture(lut3d,getUVW(lutSize,color)).rgb,color.a);\n#endif\n}\n#else\nif(lutIndex==0.){outColor=vec4(lutLookup(lut2d,lutSize,getUVW(lutSize,color)),color.a);}else if(lutIndex==1.){\n#if USE_LUT1 == 1\noutColor=vec4(lutLookup(lut2d1,lutSize,getUVW(lutSize1,color)),color.a);\n#endif\n}else if(lutIndex==2.){\n#if USE_LUT2 == 1\noutColor=vec4(lutLookup(lut2d2,lutSize,getUVW(lutSize2,color)),color.a);\n#endif\n}else{outColor=vec4(lutLookup(lut2d,lutSize,getUVW(lutSize,color)),color.a);}\n#endif\noutColor=mix(color,outColor,lutFac);return vec4(mix(color,outColor,intensity));}\n#endif\n" : "", this._viewer = e2, this._combinedPostPlugin = e2.getPlugin(Qs), this._setDirty = this._setDirty.bind(this), this.setDirty = this.setDirty.bind(this);
    }
    _updateParams() {
      if (!this.enabled)
        return;
      const e2 = this._viewer.renderer.rendererObject.capabilities.isWebGL2 ? 1 : 0;
      let t2 = e2 ? this.extraUniforms.lut3d : this.extraUniforms.lut2d;
      this._updateLUTMap(this.lutMap, t2, this.extraUniforms.lutSize, e2), this.extraDefines.USE_LUT = this.lutMap ? 1 : 0, t2 = e2 ? this.extraUniforms.lut3d1 : this.extraUniforms.lut2d1, this._updateLUTMap(this.lutMap1, t2, this.extraUniforms.lutSize1, e2), this.extraDefines.USE_LUT1 = this.lutMap1 ? 1 : 0, t2 = e2 ? this.extraUniforms.lut3d2 : this.extraUniforms.lut2d2, this._updateLUTMap(this.lutMap2, t2, this.extraUniforms.lutSize2, e2), this.extraDefines.USE_LUT2 = this.lutMap2 ? 1 : 0, this.extraUniforms.intensity.value = this.intensity, this.extraDefines.LUT_BACKGROUND = this.lutBackground ? 1 : 0, this.extraDefines.USE_3DTEXTURE = e2, this._setDirty();
    }
    _updateLUTMap(e2, t2, n2, r2) {
      if (e2) {
        let i2 = 1;
        1 == r2 ? (t2.value = e2.texture3D, i2 = e2.texture3D.image.width) : e2.texture && (t2.value = e2.texture, i2 = e2.texture.image.width), t2.value.needsUpdate = true, n2.value = i2;
      }
    }
    shaderExtender(e2, t2, n2) {
      this.enabled && (e2.fragmentShader = ot(e2.fragmentShader, "#glMarker", " \n            #if USE_LUT == 1\n                bool isBackground = getDepth(vUv)>0.9999;\n                #if LUT_BACKGROUND == 1\n                    gl_FragColor = colorLookUp(gl_FragColor);\n                #else\n                    gl_FragColor = isBackground ? gl_FragColor : colorLookUp(gl_FragColor);\n                #endif\n            #endif\n            #glMarker\n        "));
    }
    computeCacheKey(e2) {
      return this.enabled ? "1" : "0";
    }
    isCompatible(e2) {
      return true;
    }
    _setDirty() {
      var e2;
      null === (e2 = this.__setDirty) || void 0 === e2 || e2.call(this), this._combinedPostPlugin && (this._combinedPostPlugin.pass.dirty = true);
    }
    setDirty() {
      this._setDirty();
    }
  };
  function od(e2) {
    const t2 = null == e2 ? void 0 : e2.userData;
    if (!t2)
      return false;
    t2[ad.PluginType] || (t2[ad.PluginType] = {});
    const n2 = t2[ad.PluginType];
    return n2.enable = true, void 0 === n2.index && (n2.index = 0), e2.isMaterial && (e2.needsUpdate = true), true;
  }
  id([ie(), (0, t.onChange)(rd.prototype._updateParams), Oe("Enable")], sd.prototype, "enabled", void 0), id([ie(), (0, t.onChange)(rd.prototype._updateParams), Oe("LUT Background")], sd.prototype, "lutBackground", void 0), id([ie(), (0, t.onChange)(rd.prototype._updateParams), Ue("Intensity")], sd.prototype, "intensity", void 0), id([(0, t.onChange)(rd.prototype._updateParams), Ve("LUT"), ie()], sd.prototype, "lutMap", void 0), id([(0, t.onChange)(rd.prototype._updateParams), Ve("LUT1"), ie()], sd.prototype, "lutMap1", void 0), id([(0, t.onChange)(rd.prototype._updateParams), Ve("LUT2"), ie()], sd.prototype, "lutMap2", void 0), sd = rd = id([We("LUT")], sd);
  class ad extends qs {
    _getUiConfig(e2) {
      var t2, n2;
      const r2 = { type: "folder", label: "LUT", children: [{ type: "checkbox", label: "Enabled", get value() {
        var t3, n3;
        return null === (n3 = null === (t3 = e2.materialObject.userData[ad.PluginType]) || void 0 === t3 ? void 0 : t3.enable) || void 0 === n3 || n3;
      }, set value(t3) {
        var n3;
        const i2 = e2.materialObject.userData[ad.PluginType];
        t3 !== (null == i2 ? void 0 : i2.enable) && (i2 || od(e2.materialObject), e2.materialObject.userData[ad.PluginType].enable = t3, null === (n3 = r2.uiRefresh) || void 0 === n3 || n3.call(r2, "postFrame", true));
      }, onChange: null === (t2 = this._extension) || void 0 === t2 ? void 0 : t2.setDirty }, { type: "dropdown", children: [["LUT 0", 0], ["LUT 1", 1], ["LUT 2", 2]].map((e3) => ({ label: e3[0], value: e3[1] })), label: "index", hidden: () => {
        const t3 = e2.materialObject.userData[ad.PluginType];
        return !!t3 && !t3.enable;
      }, get value() {
        var t3, n3;
        return null !== (n3 = null === (t3 = e2.materialObject.userData[ad.PluginType]) || void 0 === t3 ? void 0 : t3.index) && void 0 !== n3 ? n3 : 0;
      }, set value(t3) {
        var n3;
        e2.materialObject.userData[ad.PluginType] || od(e2.materialObject), e2.materialObject.userData[ad.PluginType].index = t3, null === (n3 = r2.uiRefresh) || void 0 === n3 || n3.call(r2, "postFrame", true);
      }, onChange: null === (n2 = this._extension) || void 0 === n2 ? void 0 : n2.setDirty }] };
      return r2;
    }
    constructor() {
      super(), this.materialExtension = { uuid: ke(), getUiConfig: (e2) => {
        if (e2.__uiConfigs || (e2.__uiConfigs = {}), e2.__uiConfigs[this.materialExtension.uuid])
          return e2.__uiConfigs[this.materialExtension.uuid];
        const t2 = this._getUiConfig(e2);
        return e2.__uiConfigs[this.materialExtension.uuid] = t2, t2;
      }, computeCacheKey: (e2) => {
        var t2;
        return (this.enabled ? "1" : "0") + ((null === (t2 = e2.materialObject.userData[ad.PluginType]) || void 0 === t2 ? void 0 : t2.enable) ? "1" : "0");
      }, isCompatible: (e2) => true }, this.updateGBuffer = this.updateGBuffer.bind(this);
    }
    async onAdded(e2) {
      var t2, n2;
      await super.onAdded(e2), null === (t2 = e2.getPlugin(wt)) || void 0 === t2 || t2.registerGBufferUpdater(this.updateGBuffer);
      const r2 = e2.getPlugin(Ls);
      null === (n2 = null == r2 ? void 0 : r2.materials) || void 0 === n2 || n2.registerMaterialExtension(this.materialExtension);
    }
    generateExtension(e2) {
      return new sd(e2);
    }
    updateGBuffer(e2, t2) {
      var r2, i2;
      if (e2 instanceof n.Kj0 && (null === (r2 = e2.material) || void 0 === r2 ? void 0 : r2.userData)) {
        const n2 = null === (i2 = e2.material) || void 0 === i2 ? void 0 : i2.userData[ad.PluginType];
        if (n2) {
          const e3 = false === n2.enable ? 0 : 1;
          t2.w = Xs(t2.w, 0, e3);
          for (let e4 = 0; e4 < 3; e4++)
            t2.y = Ys(t2.y, e4);
          let r3 = n2.enable ? n2.index : 0;
          r3 = Math.min(r3, 7), t2.y = t2.y | r3;
        } else
          t2.w = Xs(t2.w, 0, 1);
      }
    }
  }
  ad.PluginType = "LUTPlugin1";
  class ld {
    constructor(e2) {
      this._zee = new n.Pa4(0, 0, 1), this._euler = new n.USm(), this._q0 = new n._fP(), this._q1 = new n._fP(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)), this._q2 = new n._fP(), this._initQuaternionDest = new n._fP(), this.onScreenOrientationChangeEvent = () => {
        this.screenOrientation = screen.orientation;
      }, this.onDeviceOrientationChangeEvent = (e3) => {
        this.deviceOrientation = e3;
      }, this._isConnected = false, this._viewer = e2;
    }
    getOffsetFromCenter(e2 = true) {
      if (!this.deviceOrientation)
        return new n.FM8();
      this.getQuaternion(e2, this._q2);
      const t2 = new n.Pa4(0, 0, 1);
      return t2.applyQuaternion(this._q2), new n.FM8(t2.x, t2.y);
    }
    getQuaternion(e2, t2) {
      if (t2 || (t2 = new n._fP()), !this.deviceOrientation)
        return t2.identity();
      const r2 = this.deviceOrientation, i2 = null !== r2.alpha ? n.M8C.degToRad(r2.alpha) : 0, s2 = null !== r2.beta ? n.M8C.degToRad(r2.beta) : 0, o2 = null !== r2.gamma ? n.M8C.degToRad(r2.gamma) : 0, a2 = this.screenOrientation ? n.M8C.degToRad(this.screenOrientation.angle) : 0;
      return this._toQuaternion(t2, i2, s2, o2, a2, e2), t2;
    }
    _toQuaternion(e2, t2, n2, r2, i2, s2) {
      this._euler.set(n2, t2, -r2, "YXZ"), e2.setFromEuler(this._euler), e2.multiply(this._q1);
      const o2 = document.getElementById("debug");
      return o2 && (o2.textContent = i2 + ""), e2.multiply(this._q0.setFromAxisAngle(this._zee, -i2)), this._initQuaternionDest.__init || (this._initQuaternionDest.copy(e2).invert(), this._initQuaternionDest.__init = true), s2 && e2.premultiply(this._initQuaternionDest), e2;
    }
    static IsCompatible() {
      return void 0 !== window.DeviceOrientationEvent && "ontouchstart" in window;
    }
    addPermissionMessage() {
      this.permissionMessage = document.createElement("div"), this.permissionMessage.innerHTML = "Tap on the screen to allow gyroscope", this.permissionMessage.style.visibility = "visible", this.permissionMessage.style.width = "100%", this.permissionMessage.style.height = "40px", this.permissionMessage.style.color = "black", this.permissionMessage.style.position = "absolute", this.permissionMessage.style.textAlign = "center", this.permissionMessage.style.fontSize = "12px", this.permissionMessage.style.bottom = "20%", this._viewer.container.appendChild(this.permissionMessage);
    }
    connect() {
      var e2;
      if (!this._isConnected)
        return this._isConnected = true, this.onScreenOrientationChangeEvent(), !!window.DeviceOrientationEvent && (this.askPermission(), null === (e2 = this._viewer) || void 0 === e2 || e2.renderer.rendererObject.domElement.addEventListener("click", this.askPermission.bind(this)), window.addEventListener("orientationchange", this.onScreenOrientationChangeEvent), window.addEventListener("deviceorientation", this.onDeviceOrientationChangeEvent), true);
    }
    askPermission() {
      this.onScreenOrientationChangeEvent(), "function" == typeof DeviceMotionEvent.requestPermission && (this.addPermissionMessage(), DeviceOrientationEvent.requestPermission().then((e2) => {
        "granted" == e2 && (window.addEventListener("orientationchange", this.onScreenOrientationChangeEvent), window.addEventListener("deviceorientation", this.onDeviceOrientationChangeEvent), this._viewer.container.removeChild(this.permissionMessage));
      }).catch((e2) => {
        console.error("DeviceOrientationControls2: Unable to use DeviceOrientation API:", e2);
      }));
    }
    disconnect() {
      this._isConnected && (this._isConnected = false, window.removeEventListener("orientationchange", this.onScreenOrientationChangeEvent), window.removeEventListener("deviceorientation", this.onDeviceOrientationChangeEvent), this._initQuaternionDest = new n._fP());
    }
  }
  class cd {
    constructor() {
      this._mousePos = new n.FM8(0, 0), this._isConnected = false;
    }
    getOffsetFromCenter() {
      return new n.FM8(this._mousePos.x / window.innerWidth * 2 - 1, -(this._mousePos.y / window.innerHeight * 2 - 1));
    }
    connect() {
      this._isConnected || (this._isConnected = true, window.addEventListener("mousemove", this._onMouseMove.bind(this)));
    }
    disconnect() {
      this._isConnected && (this._isConnected = false, window.removeEventListener("mousemove", this._onMouseMove.bind(this)));
    }
    _onMouseMove(e2) {
      this._mousePos.set(e2.clientX, e2.clientY);
    }
  }
  var ud, pd = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let dd = ud = class extends gt {
    constructor() {
      super(), this.enabled = false, this.enableEdit = false, this.invert = false, this.sensitivity = 0.5, this.focalPointHit = new n.Pa4(0, 0, 0), this.damping = 0.5, this.cameraView = "", this._target = new n.Pa4(), this._center = new n.Pa4(), this._pointerDown = false, this._focalDistance = 100, this._updateProjectionMatrix = () => {
        var e2, t2;
        if (!this.enabled)
          return void (null === (t2 = (e2 = this._object)._updateProjectionMatrixParallax) || void 0 === t2 || t2.call(e2));
        const r2 = this._object, i2 = r2.near;
        let s2 = i2 * Math.tan(0.5 * n.M8C.DEG2RAD * r2.fov) / r2.zoom, o2 = 2 * s2, a2 = r2.aspect * o2, l2 = -0.5 * a2;
        if (null !== r2.view && r2.view.enabled) {
          const e3 = r2.view.fullWidth, t3 = r2.view.fullHeight;
          l2 += r2.view.offsetX * a2 / e3, s2 -= r2.view.offsetY * o2 / t3, a2 *= r2.view.width / e3, o2 *= r2.view.height / t3;
        }
        l2 -= this._offX * i2 / this._focalDistance, s2 -= this._offY * i2 / this._focalDistance;
        const c2 = r2.filmOffset;
        0 !== c2 && (l2 += i2 * c2 / r2.getFilmWidth()), r2.projectionMatrix.makePerspective(l2, l2 + a2, s2, s2 - o2, i2, r2.far), r2.projectionMatrixInverse.copy(r2.projectionMatrix).invert();
      }, this._preFrame = (e2) => {
        this.update(e2.deltaTime);
      }, this._offX = 0, this._offY = 0, this._xDamper = new t.Damper(), this._yDamper = new t.Damper(), this._onEnabledChange = this._onEnabledChange.bind(this), this._onDampingChange = this._onDampingChange.bind(this), this._onObjectHit = this._onObjectHit.bind(this), this._onActiveCameraChange = this._onActiveCameraChange.bind(this);
    }
    async onAdded(e2) {
      var t2, n2, r2;
      await super.onAdded(e2), ld.IsCompatible() ? this._input = new ld(e2) : this._input = new cd(), e2.scene.addEventListener("activeCameraChange", this._onActiveCameraChange), this.addIndicator(), e2.addEventListener("preFrame", this._preFrame), null === (t2 = this._viewer) || void 0 === t2 || t2.container.addEventListener("pointerdown", this.onPointerDown.bind(this)), null === (n2 = this._viewer) || void 0 === n2 || n2.container.addEventListener("pointerup", this.onPointerUp.bind(this)), null === (r2 = e2.getPluginByType("Picking")) || void 0 === r2 || r2.addEventListener("hitObject", this._onObjectHit), this._onEnabledChange();
    }
    _onActiveCameraChange() {
      var e2, t2, n2, r2;
      this._object && (null === (e2 = this._object) || void 0 === e2 ? void 0 : e2._updateProjectionMatrixParallax) && (this._object.updateProjectionMatrix = this._object._updateProjectionMatrixParallax, delete this._object._updateProjectionMatrixParallax), this._focalDistance = 0.01, this._object = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.scene.activeCamera.cameraObject, (null === (n2 = this._object) || void 0 === n2 ? void 0 : n2.isOrthographicCamera) ? null === (r2 = this._viewer) || void 0 === r2 || r2.console.warn("ParallaxCameraControllerPlugin: Orthographic camera is not supported") : this.enabled && (this._object._updateProjectionMatrixParallax = this._object.updateProjectionMatrix, this._object.updateProjectionMatrix = this._updateProjectionMatrix);
    }
    addIndicator() {
      var e2;
      this._viewer && (this._indicator && this._indicator.remove(), this._indicator = document.createElement("div"), this._indicator.style.width = "40px", this._indicator.style.height = "40px", this._indicator.style.borderRadius = "100%", this._indicator.style.border = "4px solid #ff4444", this._indicator.style.transform = "translate(-50%, -50%)", this._indicator.style.position = "absolute", this._indicator.style.top = "0", this._indicator.style.left = "0", this._indicator.style.zIndex = "10000", this._indicator.style.opacity = "0", this._indicator.style.transition = "opacity 0.5s", this._indicator.style.pointerEvents = "none", null === (e2 = this._viewer) || void 0 === e2 || e2.container.appendChild(this._indicator));
    }
    onPointerDown(e2) {
      this.enabled && this._viewer && (this._pointerDown = true, this.enableEdit && this._indicator && (this._indicator.style.top = e2.clientY - this._viewer.container.offsetTop + "px", this._indicator.style.left = e2.clientX - this._viewer.container.offsetLeft + "px"));
    }
    onPointerUp() {
      this._pointerDown = false;
    }
    update(e2) {
      if (!this.enabled || this._pointerDown || !this._input || !this._object || !this._viewer)
        return;
      this._viewer.scene.activeCamera.setInteractions(false, ud.PluginType), this._updateFocalDistance();
      const t2 = this._object.matrixWorld.elements, r2 = new n.Pa4(t2[0], t2[1], t2[2]), i2 = new n.Pa4(t2[4], t2[5], t2[6]);
      this._object.position.copy(this._center), this._viewer.scene.activeCamera.positionUpdated();
      let s2 = this.sensitivity;
      this.invert && (s2 *= -1), this._offX = this._xDamper.update(this._offX, this._input.getOffsetFromCenter().x * s2, e2, 1), this._offY = this._yDamper.update(this._offY, this._input.getOffsetFromCenter().y * s2, e2, 1);
      const o2 = this._object;
      o2.position.add(i2.multiplyScalar(this._offY)).add(r2.multiplyScalar(this._offX)), o2.updateProjectionMatrix(), o2.updateMatrixWorld(), this._dirty = true;
    }
    _onObjectHit(e2) {
      var t2, n2;
      e2.intersects.intersect && this.enableEdit && (this.focalPointHit.copy(e2.intersects.intersect.point), e2.intersects.selectedObject = null, null === (n2 = null === (t2 = this.uiConfig) || void 0 === t2 ? void 0 : t2.uiRefresh) || void 0 === n2 || n2.call(t2, "postFrame", true), this._indicator && (this._indicator.style.display = "block", this._indicator.style.opacity = "1", setTimeout(() => {
        var e3, t3;
        this._indicator.style.opacity = "0", setTimeout(() => this._indicator.style.display = "none", 600), null === (t3 = null === (e3 = this.uiConfig) || void 0 === e3 ? void 0 : e3.uiRefresh) || void 0 === t3 || t3.call(e3, "postFrame", true);
      }, 200)));
    }
    _updateFocalDistance() {
      if (!this._object)
        return;
      const e2 = this._object, t2 = new n.Pa4();
      e2.getWorldDirection(t2), t2.normalize(), this._focalDistance = this.focalPointHit.clone().sub(e2.position).dot(t2);
    }
    _onEnabledChange() {
      var e2, t2, n2;
      if (this._viewer) {
        if (this.enabled) {
          if (null === (e2 = this._input) || void 0 === e2 || e2.connect(), this._onActiveCameraChange(), !this._object)
            return;
          this._viewer.scene.activeCamera.setInteractions(false, ud.PluginType);
          const t3 = this._viewer.getPluginByType("CameraViews"), n3 = null == t3 ? void 0 : t3.camViews.find((e3) => e3.name === this.cameraView);
          t3 && n3 && t3.setCurrentCameraView(n3), this._updateFocalDistance(), this._center.copy(this._object.position), this._object.lookAt(this._viewer.scene.activeCamera.target);
        } else if (this._object) {
          this._onActiveCameraChange(), this._viewer.scene.activeCamera.setInteractions(true, ud.PluginType), this._object.position.copy(this._center), this._object.lookAt(this._viewer.scene.activeCamera.target);
          const e3 = this._object;
          e3.updateProjectionMatrix(), e3.updateMatrixWorld();
        }
        null === (n2 = null === (t2 = this.uiConfig) || void 0 === t2 ? void 0 : t2.uiRefresh) || void 0 === n2 || n2.call(t2, "postFrame", true);
      }
    }
    _onDampingChange() {
      this._xDamper && this._yDamper && (this._xDamper.setDecayTime(100 * this.damping), this._yDamper.setDecayTime(100 * this.damping));
    }
    dispose() {
      var e2;
      null === (e2 = this._input) || void 0 === e2 || e2.disconnect();
    }
  };
  dd.PluginType = "ParallaxCameraControllerPlugin", pd([(0, t.onChange)(ud.prototype._onEnabledChange), ie(), Oe("Enabled")], dd.prototype, "enabled", void 0), pd([ie(), Oe("enableEdit")], dd.prototype, "enableEdit", void 0), pd([ie(), Oe("Invert")], dd.prototype, "invert", void 0), pd([ie(), Ue("Sensitivity", [0.1, 2], 0.01)], dd.prototype, "sensitivity", void 0), pd([ie("focalPoint"), Fe("Focal Point Hit", void 0, 1e-3)], dd.prototype, "focalPointHit", void 0), pd([(0, t.onChange)(ud.prototype._onDampingChange), ie(), Ue("Damping", [0, 1], 1e-3)], dd.prototype, "damping", void 0), pd([ie(), ze("Camera View")], dd.prototype, "cameraView", void 0), dd = ud = pd([We("Parallax Camera Controller")], dd);
  var hd = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let fd = class extends gt {
    addNoiseBumpMaterial(e2) {
      return md(e2.materialObject);
    }
    _loaderCreate({ loader: e2 }) {
      e2.isGLTFLoader2 && e2.register((e3) => new _d(e3));
    }
    constructor() {
      super(), this.enabled = true, this.dependencies = [Ls], this._uniforms = { noiseBumpParams: { value: new n.FM8() }, noiseBumpScale: { value: 0.05 }, noiseBumpFlakeScale: { value: 1e3 }, noiseFlakeClamp: { value: 1 }, noiseFlakeRadius: { value: 0.5 }, flakeParams: { value: new n.Ltg(0, 1, 3, 0) }, flakeFallOffParams: { value: new n.Pa4(0, 1, 0) }, useColorFlakes: { value: false } }, this.materialExtension = { parsFragmentSnippet: (e2, t2) => {
        var n2;
        return this.enabled && (null === (n2 = null == t2 ? void 0 : t2.materialObject.userData._noiseBumpMat) || void 0 === n2 ? void 0 : n2.hasBump) ? co + "\n#ifndef VORONOI_HELPER\n#define VORONOI_HELPER \nfloat voronoi_distance(vec2 a,vec2 b,float metric){return distance(a,b);}float voronoi_f1_2d(in vec2 coord,in float randomness,in float flakeClamp,in float flakeRadius,inout vec3 outColor){vec2 cellPosition=floor(coord);vec2 localPosition=coord-cellPosition;float minDistance=8.;vec2 targetOffset,targetPosition;for(int j=-1;j<=1;j++){for(int i=-1;i<=1;i++){vec2 cellOffset=vec2(i,j);vec2 pointPosition=cellOffset+hash3(cellPosition+cellOffset).xy*randomness;float distanceToPoint=voronoi_distance(pointPosition,localPosition,1.);if(distanceToPoint<minDistance){targetOffset=cellOffset;minDistance=distanceToPoint;targetPosition=pointPosition;}}}float outDistance=minDistance;float dist=step(flakeRadius,outDistance);outColor=hash3(cellPosition+hash3(cellPosition+targetOffset).xy*randomness+targetOffset);vec3 outColor1=minDistance<flakeRadius?outColor:vec3(0.5,0.5,1.);outDistance=mix(dist,minDistance,flakeClamp);outColor=mix(outColor1,outColor,flakeClamp);return outDistance;}\n#endif\n\nuniform vec2 noiseBumpParams;uniform float noiseBumpScale;uniform float noiseBumpFlakeScale;uniform float noiseFlakeClamp;uniform float noiseFlakeRadius;uniform bool useColorFlakes;uniform vec4 flakeParams;uniform vec3 flakeFallOffParams;vec3 perturbNormalArb_nb(vec3 surf_pos,vec3 surf_norm,vec2 dHdxy,float faceDirection){vec3 vSigmaX=dFdx(surf_pos.xyz);vec3 vSigmaY=dFdy(surf_pos.xyz);vec3 vN=surf_norm;vec3 R1=cross(vSigmaY,vN);vec3 R2=cross(vN,vSigmaX);float fDet=dot(vSigmaX,R1)*faceDirection;vec3 vGrad=sign(fDet)*(dHdxy.x*R1+dHdxy.y*R2);return normalize(abs(fDet)*surf_norm-vGrad);}\n" : "";
      }, shaderExtender: (e2, t2, n2) => {
        var r2;
        if (!this.enabled || !(null === (r2 = t2.materialObject.userData._noiseBumpMat) || void 0 === r2 ? void 0 : r2.hasBump))
          return;
        const i2 = "#glMarker beforeAccumulation";
        e2.fragmentShader = e2.fragmentShader.replace(i2, "vec3 outColor,outColor1,outColor2,outColor3,outColor4,outColor5;float distFac=length(vViewPosition.xyz);float level=1.;vec2 uvMod=noiseBumpFlakeScale*noiseBumpParams.xy*vUv*level;float voronoiDist=clamp(voronoi_f1_2d(uvMod,1.,noiseFlakeClamp,noiseFlakeRadius,outColor),0.,1.);vec3 oldNormal=normal;normal=perturbNormalArb_nb(-vViewPosition,normal,(2.*outColor.xy-1.)*noiseBumpScale,faceDirection);float oldRoughnessFactor=roughnessFactor;float oldMetalnessFactor=metalnessFactor;roughnessFactor=mix(roughnessFactor,flakeParams.x,1.-voronoiDist);metalnessFactor=mix(metalnessFactor,flakeParams.y,1.-voronoiDist);\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\nvec3 sparkleRadiance=getIBLRadiance(normalize(vViewPosition),normal,roughnessFactor);float sparkleIntensity=length(sparkleRadiance);float sparkleIntensityMultiplier=sparkleIntensity>1.3?flakeParams.z:1.;vec3 oldDiffuseColor=diffuseColor.rgb;vec2 cellPosition_=floor(uvMod);vec3 colorRGB=useColorFlakes?hash3(cellPosition_):vec3(1.);float fallOff_=mix(1.,1./(1.+flakeFallOffParams.y*distFac+flakeFallOffParams.z*distFac*distFac),flakeFallOffParams.x);diffuseColor.rgb*=mix(vec3(1.),sparkleIntensityMultiplier*colorRGB*fallOff_,vec3(1.-voronoiDist));if(sparkleIntensity<flakeParams.w){float mixFactor=1.;roughnessFactor=mix(roughnessFactor,oldRoughnessFactor,mixFactor);metalnessFactor=mix(metalnessFactor,oldMetalnessFactor,mixFactor);normal=normalize(mix(normal,oldNormal,mixFactor));diffuseColor.rgb=mix(diffuseColor.rgb,oldDiffuseColor,mixFactor);}\n#endif\n\n" + i2), e2.defines.USE_UV = "", e2.extensionDerivatives = true;
      }, onObjectRender: (e2, t2) => {
        var n2;
        const r2 = null === (n2 = t2.materialObject.userData) || void 0 === n2 ? void 0 : n2._noiseBumpMat;
        if (!(null == r2 ? void 0 : r2.hasBump))
          return;
        this._uniforms.noiseBumpParams.value.fromArray(r2.bumpNoiseParams), this._uniforms.noiseBumpScale.value = r2.bumpScale, this._uniforms.noiseBumpFlakeScale.value = r2.flakeScale, this._uniforms.noiseFlakeClamp.value = r2.flakeClamp, this._uniforms.noiseFlakeRadius.value = r2.flakeRadius, r2.flakeParams && this._uniforms.flakeParams.value.copy(r2.flakeParams), r2.flakeFallOffParams && this._uniforms.flakeFallOffParams.value.copy(r2.flakeFallOffParams), this._uniforms.useColorFlakes.value = r2.useColorFlakes;
        const i2 = this.enabled ? 1 : 0;
        t2.materialObject.defines.NOISE_BUMP_MATERIAL_ENABLED !== i2 && (t2.materialObject.defines.NOISE_BUMP_MATERIAL_ENABLED = i2, t2.materialObject.needsUpdate = true);
      }, extraUniforms: { ...this._uniforms }, computeCacheKey: (e2) => {
        var t2, n2;
        return (this.enabled ? "1" : "0") + ((null === (n2 = null === (t2 = e2.materialObject.userData) || void 0 === t2 ? void 0 : t2._noiseBumpMat) || void 0 === n2 ? void 0 : n2.hasBump) ? "1" : "0");
      }, isCompatible: (e2) => e2.isMeshStandardMaterial2, updaters: () => [], getUiConfig: (e2) => {
        const t2 = this._viewer, n2 = { type: "folder", label: "SparkleBump (NoiseBump)", children: [{ type: "checkbox", label: "Enabled", get value() {
          var t3;
          return (null === (t3 = e2.materialObject.userData._noiseBumpMat) || void 0 === t3 ? void 0 : t3.hasBump) || false;
        }, set value(r2) {
          var i2, s2;
          r2 !== (null === (i2 = e2.materialObject.userData._noiseBumpMat) || void 0 === i2 ? void 0 : i2.hasBump) && (r2 ? md(e2.materialObject) || t2.alert("Cannot add noise bump.") : e2.materialObject.userData._noiseBumpMat && (e2.materialObject.userData._noiseBumpMat.hasBump = false, e2.materialObject.needsUpdate = true), null === (s2 = n2.uiRefresh) || void 0 === s2 || s2.call(n2, "postFrame", true));
        }, onChange: this.setDirty }, () => ({ type: "vec4", label: "Bump Noise Params", bounds: [0, 1], hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._noiseBumpMat) || void 0 === t3 ? void 0 : t3.hasBump);
        }, property: [e2.materialObject.userData._noiseBumpMat, "bumpNoiseParams"], onChange: this.setDirty }), () => ({ type: "slider", label: "Bump Scale", bounds: [0, 1e-3], stepSize: 1e-5, hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._noiseBumpMat) || void 0 === t3 ? void 0 : t3.hasBump);
        }, property: [e2.materialObject.userData._noiseBumpMat, "bumpScale"], onChange: this.setDirty }), () => ({ type: "slider", label: "Flake Scale", bounds: [100, 1e4], stepSize: 1e-4, hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._noiseBumpMat) || void 0 === t3 ? void 0 : t3.hasBump);
        }, property: [e2.materialObject.userData._noiseBumpMat, "flakeScale"], onChange: this.setDirty }), () => ({ type: "slider", label: "Flake Clamp", bounds: [0, 1], stepSize: 1, hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._noiseBumpMat) || void 0 === t3 ? void 0 : t3.hasBump);
        }, property: [e2.materialObject.userData._noiseBumpMat, "flakeClamp"], onChange: this.setDirty }), () => ({ type: "slider", label: "Flake Radius", bounds: [0.01, 1], stepSize: 1e-3, hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._noiseBumpMat) || void 0 === t3 ? void 0 : t3.hasBump);
        }, property: [e2.materialObject.userData._noiseBumpMat, "flakeRadius"], onChange: this.setDirty }), () => {
          var t3;
          return { type: "slider", label: "Flake Roughness", bounds: [0, 1], stepSize: 0.01, hidden: () => {
            var t4;
            return !(null === (t4 = e2.materialObject.userData._noiseBumpMat) || void 0 === t4 ? void 0 : t4.hasBump);
          }, property: [null === (t3 = e2.materialObject.userData._noiseBumpMat) || void 0 === t3 ? void 0 : t3.flakeParams, "x"], onChange: this.setDirty };
        }, () => {
          var t3;
          return { type: "slider", label: "Flake Metalness", bounds: [0, 1], stepSize: 0.01, hidden: () => {
            var t4;
            return !(null === (t4 = e2.materialObject.userData._noiseBumpMat) || void 0 === t4 ? void 0 : t4.hasBump);
          }, property: [null === (t3 = e2.materialObject.userData._noiseBumpMat) || void 0 === t3 ? void 0 : t3.flakeParams, "y"], onChange: this.setDirty };
        }, () => {
          var t3;
          return { type: "slider", label: "Flake Strength", bounds: [0, 100], stepSize: 1e-3, hidden: () => {
            var t4;
            return !(null === (t4 = e2.materialObject.userData._noiseBumpMat) || void 0 === t4 ? void 0 : t4.hasBump);
          }, property: [null === (t3 = e2.materialObject.userData._noiseBumpMat) || void 0 === t3 ? void 0 : t3.flakeParams, "z"], onChange: this.setDirty };
        }, () => {
          var t3;
          return { type: "slider", label: "Flake Threshold", bounds: [0.1, 10], stepSize: 1e-3, hidden: () => {
            var t4;
            return !(null === (t4 = e2.materialObject.userData._noiseBumpMat) || void 0 === t4 ? void 0 : t4.hasBump);
          }, property: [null === (t3 = e2.materialObject.userData._noiseBumpMat) || void 0 === t3 ? void 0 : t3.flakeParams, "w"], onChange: this.setDirty };
        }, () => {
          var t3;
          return { type: "slider", label: "Falloff", stepSize: 1, bounds: [0, 1], hidden: () => {
            var t4;
            return !(null === (t4 = e2.materialObject.userData._noiseBumpMat) || void 0 === t4 ? void 0 : t4.hasBump);
          }, property: [null === (t3 = e2.materialObject.userData._noiseBumpMat) || void 0 === t3 ? void 0 : t3.flakeFallOffParams, "x"], onChange: this.setDirty };
        }, () => {
          var t3;
          return { type: "slider", label: "Linear falloff factor", bounds: [0, 10], stepSize: 1e-3, hidden: () => {
            var t4;
            return !(null === (t4 = e2.materialObject.userData._noiseBumpMat) || void 0 === t4 ? void 0 : t4.hasBump);
          }, property: [null === (t3 = e2.materialObject.userData._noiseBumpMat) || void 0 === t3 ? void 0 : t3.flakeFallOffParams, "y"], onChange: this.setDirty };
        }, () => {
          var t3;
          return { type: "slider", label: "Quadratic falloff factor", bounds: [0, 10], stepSize: 1e-3, hidden: () => {
            var t4;
            return !(null === (t4 = e2.materialObject.userData._noiseBumpMat) || void 0 === t4 ? void 0 : t4.hasBump);
          }, property: [null === (t3 = e2.materialObject.userData._noiseBumpMat) || void 0 === t3 ? void 0 : t3.flakeFallOffParams, "z"], onChange: this.setDirty };
        }, () => ({ type: "checkbox", label: "Colored Flakes", hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._noiseBumpMat) || void 0 === t3 ? void 0 : t3.hasBump);
        }, property: [e2.materialObject.userData._noiseBumpMat, "useColorFlakes"], onChange: this.setDirty })] };
        return n2;
      } }, this.setDirty = () => {
        var e2, t2, n2;
        null === (t2 = (e2 = this.materialExtension).setDirty) || void 0 === t2 || t2.call(e2), null === (n2 = this._viewer) || void 0 === n2 || n2.setDirty();
      }, this._loaderCreate = this._loaderCreate.bind(this);
    }
    async onAdded(e2) {
      var t2, n2, r2, i2, s2;
      await super.onAdded(e2);
      const o2 = e2.getPlugin(Ls);
      null === (t2 = null == o2 ? void 0 : o2.materials) || void 0 === t2 || t2.registerMaterialExtension(this.materialExtension), null === (n2 = null == o2 ? void 0 : o2.importer) || void 0 === n2 || n2.addEventListener("loaderCreate", this._loaderCreate), null === (s2 = null === (i2 = null === (r2 = null == o2 ? void 0 : o2.exporter) || void 0 === r2 ? void 0 : r2.getExporter("gltf", "glb")) || void 0 === i2 ? void 0 : i2.extensions) || void 0 === s2 || s2.push(gd);
    }
    async onRemove(e2) {
      var t2, n2, r2, i2;
      return null === (n2 = null === (t2 = e2.getPlugin(Ls)) || void 0 === t2 ? void 0 : t2.materials) || void 0 === n2 || n2.unregisterMaterialExtension(this.materialExtension), null === (i2 = null === (r2 = e2.getPlugin(Ls)) || void 0 === r2 ? void 0 : r2.importer) || void 0 === i2 || i2.removeEventListener("loaderCreate", this._loaderCreate), super.onRemove(e2);
    }
  };
  function md(e2) {
    const t2 = null == e2 ? void 0 : e2.userData;
    if (!t2)
      return false;
    t2._noiseBumpMat || (t2._noiseBumpMat = {});
    const r2 = t2._noiseBumpMat;
    return r2.hasBump = true, void 0 === r2.bumpNoiseParams && (r2.bumpNoiseParams = [0.5, 0.5]), void 0 === r2.bumpScale && (r2.bumpScale = 0.05), void 0 === r2.flakeScale && (r2.flakeScale = 0.05), void 0 === r2.flakeClamp && (r2.flakeClamp = 1), void 0 === r2.flakeRadius && (r2.flakeRadius = 0.3), void 0 === r2.useColorFlakes && (r2.useColorFlakes = false), void 0 === r2.flakeParams && (r2.flakeParams = new n.Ltg(0, 1, 3, 0)), void 0 === r2.flakeFallOffParams && (r2.flakeFallOffParams = new n.Pa4(0, 1, 0)), e2.isMaterial && (e2.needsUpdate = true), true;
  }
  fd.PluginType = "NoiseBumpMaterialPlugin", fd.NOISE_BUMP_MATERIAL_GLTF_EXTENSION = "WEBGI_materials_noise_bump", hd([Oe("Enabled", (e2) => ({ onChange: e2.setDirty })), ie()], fd.prototype, "enabled", void 0), fd = hd([We("NoiseBump Materials")], fd);
  class _d {
    constructor(e2) {
      this.parser = e2, this.name = fd.NOISE_BUMP_MATERIAL_GLTF_EXTENSION;
    }
    async extendMaterialParams(e2, t2) {
      const n2 = this.parser.json.materials[e2];
      if (!n2.extensions || !n2.extensions[this.name])
        return Promise.resolve();
      const r2 = n2.extensions[this.name];
      return t2.userData || (t2.userData = {}), md(t2), t2.userData._noiseBumpMat = ce(r2, t2.userData._noiseBumpMat, false, {}), Promise.resolve();
    }
  }
  const gd = (e2) => ({ writeMaterial: (t2, n2) => {
    if (!t2.isMeshStandardMaterial || !t2.userData._noiseBumpMat)
      return;
    if (!t2.userData._noiseBumpMat.hasBump)
      return;
    n2.extensions = n2.extensions || {};
    const r2 = le(t2.userData._noiseBumpMat, false);
    n2.extensions[fd.NOISE_BUMP_MATERIAL_GLTF_EXTENSION] = r2, e2.extensionsUsed[fd.NOISE_BUMP_MATERIAL_GLTF_EXTENSION] = true;
  } });
  class vd extends dt {
    constructor(e2, t2) {
      super({ vertexShader: r.vertexShader, fragmentShader: t2 + "\n" + Za + "\n#include <common>\nvarying vec2 vUv;uniform vec2 previousRTSize;uniform mat4 lastProjectionViewMatrix;uniform mat4 currentProjectionViewMatrix;uniform mat4 inverseViewMatrix;uniform vec2 jitterSample;uniform vec2 feedBack;uniform bool firstFrame;\n#if HAS_VELOCITY_BUFFER == 1\nuniform sampler2D tVelocity;\n#endif\nvec3 find_closest_fragment_3x3(const in vec2 uv){const vec3 offset=vec3(-1.,1.,0.);vec2 texelSize=1./previousRTSize;vec3 dtr=vec3(1,1,getDepth(uv+offset.yy*texelSize));vec3 dtc=vec3(0,1,getDepth(uv+offset.zy*texelSize));vec3 dtl=vec3(-1,1,getDepth(uv+offset.xy*texelSize));vec3 dml=vec3(-1,0,getDepth(uv+offset.xz*texelSize));vec3 dmc=vec3(0,0,getDepth(uv));vec3 dmr=vec3(1,0,getDepth(uv+offset.yz*texelSize));vec3 dbl=vec3(-1,-1,getDepth(uv+offset.xx*texelSize));vec3 dbc=vec3(0,-1,getDepth(uv+offset.zx*texelSize));vec3 dbr=vec3(1,-1,getDepth(uv+offset.yx*texelSize));vec3 dmin=dtl;if(dmin.z>dtc.z)dmin=dtc;if(dmin.z>dtr.z)dmin=dtr;if(dmin.z>dml.z)dmin=dml;if(dmin.z>dmc.z)dmin=dmc;if(dmin.z>dmr.z)dmin=dmr;if(dmin.z>dbl.z)dmin=dbl;if(dmin.z>dbc.z)dmin=dbc;if(dmin.z>dbr.z)dmin=dbr;return vec3(uv+texelSize.xy*dmin.xy,dmin.z);}vec3 find_closest_fragment_5tap(const in vec2 uv){vec2 texelSize=1./previousRTSize;vec2 offset=vec2(1.,-1.);vec3 dtl=vec3(-1,1,getDepth(uv+offset.yx*texelSize));vec3 dtr=vec3(1,1,getDepth(uv+offset.xx*texelSize));vec3 dmc=vec3(0,0,getDepth(uv));vec3 dbl=vec3(-1,-1,getDepth(uv+offset.yy*texelSize));vec3 dbr=vec3(1,-1,getDepth(uv+offset.xy*texelSize));vec3 dmin=dtl;if(dmin.z>dtr.z)dmin=dtr;if(dmin.z>dmc.z)dmin=dmc;if(dmin.z>dbl.z)dmin=dbl;if(dmin.z>dbr.z)dmin=dbr;return vec3(uv+dmin.xy*texelSize,dmin.z);}vec4 clip_aabb(const in vec4 aabb_min,const in vec4 aabb_max,vec4 p){const float FLT_EPS=1e-8;vec4 p_clip=0.5*(aabb_max+aabb_min);vec4 e_clip=0.5*(aabb_max-aabb_min)+FLT_EPS;vec4 v_clip=p-p_clip;vec4 v_unit=abs(v_clip/e_clip);float ma_unit=max(v_unit.x,max(v_unit.y,v_unit.z));if(ma_unit>1.)return p_clip+v_clip/ma_unit;else return p;}\n#if HAS_VELOCITY_BUFFER == 0\nvec2 computeScreenSpaceVelocity(const in vec3 worldPosition){vec4 currentPositionClip=currentProjectionViewMatrix*vec4(worldPosition,1.);vec4 prevPositionClip=lastProjectionViewMatrix*vec4(worldPosition,1.);vec2 currentPositionNDC=currentPositionClip.xy/currentPositionClip.w;vec2 prevPositionNDC=prevPositionClip.xy/prevPositionClip.w;if(prevPositionNDC.x>=1.||prevPositionNDC.x<=-1.||prevPositionNDC.x>=1.||prevPositionNDC.y<=-1.){return vec2(0.);}return 0.5*(currentPositionNDC-prevPositionNDC);}\n#endif\nvec4 computeTAA(const in vec2 uv,const in vec2 screenSpaceVelocity){vec2 jitterOffset=jitterSample/previousRTSize;vec2 uvUnJitter=uv;vec4 currentColor=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter));vec4 previousColor=previousRTTexelToLinear(texture2D(previousRT,uv-screenSpaceVelocity));const vec3 offset=vec3(1.,-1.,0.);vec2 texelSize=1./previousRTSize;float texelSpeed=length(screenSpaceVelocity);vec4 tl=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.yx*texelSize));vec4 tc=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.zx*texelSize));vec4 tr=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.xx*texelSize));vec4 ml=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.yz*texelSize));vec4 mc=currentColor;vec4 mr=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.xz*texelSize));vec4 bl=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.yy*texelSize));vec4 bc=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.zy*texelSize));vec4 br=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.xy*texelSize));vec4 corners=2.*(tr+bl+br+tl)-2.*mc;mc+=(mc-(corners*0.166667))*2.718282*0.3;mc=max(vec4(0.),mc);vec4 min5=min(tc,min(ml,min(mc,min(mr,bc))));vec4 max5=max(tc,max(ml,max(mc,max(mr,bc))));vec4 cmin=min(min5,min(tl,min(tr,min(bl,br))));vec4 cmax=max(min5,max(tl,max(tr,max(bl,br))));;cmin=0.5*(cmin+min5);cmax=0.5*(cmax+max5);previousColor=clip_aabb(cmin,cmax,previousColor);float lum0=luminance(currentColor.rgb);float lum1=luminance(previousColor.rgb);float unbiased_diff=abs(lum0-lum1)/max(lum0,max(lum1,0.2));float unbiased_weight=1.-unbiased_diff;float unbiased_weight_sqr=unbiased_weight*unbiased_weight;float k_feedback=mix(feedBack.x,feedBack.y,unbiased_weight_sqr);return mix(currentColor,previousColor,k_feedback);}vec3 getWorldPositionFromViewZ(const in vec2 uv,const in float viewDepth){vec2 uv_=2.*uv-1.;float xe=-(uv_.x+projection[2][0])*viewDepth/projection[0][0];float ye=-(uv_.y+projection[2][1])*viewDepth/projection[1][1];return(inverseViewMatrix*vec4(xe,ye,viewDepth,1.)).xyz;}void main(){vec2 jitterOffset=jitterSample/previousRTSize;\n#if HAS_VELOCITY_BUFFER == 0\n#if QUALITY == 1\nvec3 c_frag=find_closest_fragment_3x3(vUv);\n#else\nvec3 c_frag=find_closest_fragment_5tap(vUv);\n#endif\n#else\nvec3 c_frag=vec3(0.);\n#endif\nif(c_frag.z>=0.999){gl_FragColor=currentRTTexelToLinear(texture2D(currentRT,vUv-jitterOffset));}else{\n#if HAS_VELOCITY_BUFFER == 0\nfloat sampleViewZ=mix(-cameraNearFar.x,-cameraNearFar.y,c_frag.z);vec3 worldPosition=getWorldPositionFromViewZ(c_frag.xy,sampleViewZ);vec2 screenSpaceVelocity=computeScreenSpaceVelocity(worldPosition);\n#else\nvec2 screenSpaceVelocity=texture2D(tVelocity,vUv).xy*2.-1.;screenSpaceVelocity=sign(screenSpaceVelocity)*pow(abs(screenSpaceVelocity),vec2(4.));\n#endif\ngl_FragColor=firstFrame?currentRTTexelToLinear(texture2D(currentRT,vUv)):computeTAA(vUv,screenSpaceVelocity);}\n#include <encodings_fragment>\n}", uniforms: { currentRT: { value: null }, previousRT: { value: null }, previousRTSize: { value: new n.FM8() }, cameraNearFar: { value: new n.FM8() }, lastProjectionViewMatrix: { value: new n.yGw() }, currentProjectionViewMatrix: { value: new n.yGw() }, projection: { value: new n.yGw() }, inverseViewMatrix: { value: new n.yGw() }, jitterSample: { value: new n.FM8() }, firstFrame: { value: true }, tNormalDepth: { value: null }, tVelocity: { value: null } }, defines: { HAS_VELOCITY_BUFFER: 0, QUALITY: 1, UNJITTER: 0 } }, "currentRT", "previousRT"), this.taaEnabled = true, this.feedBack = new n.FM8(0.88, 0.97), this.uiConfig = { type: "folder", label: "Temporal AA", children: [{ type: "checkbox", label: "Enabled", property: [this, "enabled"], onChange: () => this.onSizeUpdate() }, { type: "input", label: "Feedback", stepSize: 1e-4, property: [this, "feedBack"], onChange: this.setDirty }] }, this.onSizeUpdate = this.onSizeUpdate.bind(this), this.target = e2, this.clear = false, this.needsSwap = true;
    }
    render(e2, t2, n2, r2, i2) {
      if (!this.taaEnabled || !this.enabled)
        return void (this.needsSwap = false);
      this.needsSwap = true;
      const s2 = this.uniforms.tVelocity.value ? 1 : 0;
      s2 !== this.material.defines.HAS_VELOCITY_BUFFER && (this.material.defines.HAS_VELOCITY_BUFFER = s2, this.material.needsUpdate = true), this.uniforms.previousRT.value = this.target.texture, super.render(e2, t2, n2, r2, i2), this.uniforms.lastProjectionViewMatrix.value.copy(this.uniforms.currentProjectionViewMatrix.value), this.uniforms.firstFrame.value = false;
    }
    updateCameraProperties(e2) {
      e2 && (this.uniforms.currentProjectionViewMatrix.value.multiplyMatrices(e2.projectionMatrix, e2.matrixWorldInverse), this.uniforms.inverseViewMatrix.value.copy(e2.matrixWorld));
    }
    onSizeUpdate() {
      this.uniforms.firstFrame.value = true, this.setDirty();
    }
    setSize(e2, t2) {
      super.setSize(e2, t2), this.onSizeUpdate();
    }
  }
  !function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    s2 > 3 && o2 && Object.defineProperty(t2, n2, o2);
  }([ie(), j()], vd.prototype, "feedBack", void 0);
  class yd extends yt {
    constructor() {
      super(...arguments), this.passId = "taa", this._beforeFilters = ["progressive"], this._afterFilters = [], this._requiredFilters = ["render", "progressive"], this.dependencies = [wt], this._stableNoise = true, this._stableNoiseConfig = { label: "Stable Noise (Use Total Frame Count)", type: "checkbox", property: [this, "stableNoise"] };
    }
    passCtor(e2) {
      if (!e2.getPlugin(To))
        throw "Add ProgressivePlugin before TAA";
      const t2 = new vd(e2.getPlugin(To).lastFrame, e2.getPlugin(wt).getUnpackSnippet());
      return e2.renderer.addEventListener("resize", t2.onSizeUpdate), t2;
    }
    setDirty() {
      var e2;
      null === (e2 = this._viewer) || void 0 === e2 || e2.setDirty();
    }
    async onDispose(e2) {
      return this.pass && e2.renderer.removeEventListener("resize", this.pass.passObject.onSizeUpdate), super.onDispose(e2);
    }
    _update(e2) {
      if (!super._update(e2))
        return false;
      const t2 = e2.renderer.frameCount, n2 = this._pass.passObject;
      if (n2.taaEnabled = t2 <= 1 && e2.scene.renderCamera === e2.scene.activeCamera, !n2.taaEnabled)
        return false;
      const r2 = e2.scene.renderCamera;
      return n2.updateShaderProperties([e2.getPlugin(wt), r2, e2.getPluginByType("VelocityBuffer")]), n2.target = e2.getPlugin(To).lastFrame, n2.updateCameraProperties(null == r2 ? void 0 : r2.cameraObject), true;
    }
    async onAdded(e2) {
      await super.onAdded(e2), this.stableNoise = this._stableNoise;
    }
    get stableNoise() {
      var e2, t2;
      return null !== (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.renderer.stableNoise) && void 0 !== t2 ? t2 : this._stableNoise;
    }
    set stableNoise(e2) {
      this._viewer && (this._viewer.renderer.stableNoise = e2), this._stableNoise = e2;
    }
    get uiConfig() {
      var e2;
      const t2 = null === (e2 = this.pass) || void 0 === e2 ? void 0 : e2.passObject.uiConfig;
      if (t2 && t2.children)
        return t2.children.includes(this._stableNoiseConfig) || t2.children.push(this._stableNoiseConfig), t2;
    }
  }
  yd.PluginType = "TAA";
  var bd = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let wd = class extends gt {
    constructor() {
      super(), this.toJSON = void 0, this.enabled = true, this._lastSize = ["100%", "100%"], this._lastFsElement = null, this._fsChangeHandler = (e2) => {
        var t2;
        if (this.isFullScreen())
          this.dispatchEvent({ type: "enter" });
        else {
          const e3 = this._lastFsElement || (null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.canvas);
          e3 && (e3.style.width = this._lastSize[0], e3.style.height = this._lastSize[1]), document.removeEventListener("webkitfullscreenchange", this._fsChangeHandler, false), document.removeEventListener("mozfullscreenchange", this._fsChangeHandler, false), document.removeEventListener("fullscreenchange", this._fsChangeHandler, false), document.removeEventListener("MSFullscreenChange", this._fsChangeHandler, false), this.dispatchEvent({ type: "exit" });
        }
      }, this.enter = this.enter.bind(this), this.exit = this.exit.bind(this);
    }
    async enter(e2) {
      var t2;
      if (this.isFullScreen())
        return;
      const n2 = e2 || (null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.canvas);
      return n2 ? (this._lastFsElement = n2, document.addEventListener && (document.addEventListener("webkitfullscreenchange", this._fsChangeHandler, false), document.addEventListener("mozfullscreenchange", this._fsChangeHandler, false), document.addEventListener("fullscreenchange", this._fsChangeHandler, false), document.addEventListener("MSFullscreenChange", this._fsChangeHandler, false)), this._lastSize = [n2.style.width, n2.style.height], n2.style.width = "100%", n2.style.height = "100%", n2.requestFullscreen ? n2.requestFullscreen() : n2.mozRequestFullScreen ? n2.mozRequestFullScreen() : n2.webkitRequestFullscreen ? n2.webkitRequestFullscreen() : n2.msRequestFullscreen ? n2.msRequestFullscreen() : void 0) : void 0;
    }
    async exit() {
      return document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.msExitFullscreen ? document.msExitFullscreen() : void 0;
    }
    async toggle(e2) {
      return this.isFullScreen() ? this.exit() : this.enter(e2);
    }
    isFullScreen() {
      return document.webkitIsFullScreen || document.mozFullScreen || void 0 !== document.msFullscreenElement;
    }
  };
  wd.PluginType = "FullScreenPlugin", bd([je("Enter FullScreen")], wd.prototype, "enter", null), bd([je("Exit FullScreen")], wd.prototype, "exit", null), bd([je("Toggle FullScreen")], wd.prototype, "toggle", null), wd = bd([We("Full Screen")], wd);
  const Ad = (e2, t2) => {
    const n2 = {};
    for (const r2 of e2.mappings)
      for (const e3 of r2.variants)
        n2[t2[e3]] = { material: null, gltfMaterialIndex: r2.material };
    return n2;
  }, xd = "KHR_materials_variants";
  class Ed {
    constructor(e2) {
      this.parser = e2, this.name = xd;
    }
    async afterRoot(e2) {
      const t2 = this.parser, n2 = t2.json;
      if (!n2.extensions || !n2.extensions[this.name])
        return;
      const r2 = ((e3) => {
        const t3 = [], n3 = /* @__PURE__ */ new Set();
        for (const r3 of e3) {
          let e4 = r3, i2 = 0;
          for (; n3.has(e4); )
            e4 = r3 + "." + ++i2;
          n3.add(e4), t3.push(e4);
        }
        return t3;
      })((n2.extensions[this.name].variants || []).map((e3) => e3.name));
      for (const i2 of e2.scenes)
        i2.traverse((e3) => {
          const i3 = t2.associations.get(e3);
          if (!i3 || void 0 === i3.meshes || void 0 === i3.primitives)
            return;
          const s2 = n2.meshes[i3.meshes].primitives[i3.primitives].extensions;
          s2 && s2[this.name] && (e3.userData._variantMaterials = Ad(s2[this.name], r2));
        });
      await Promise.all(e2.scenes.map(async (e3) => {
        const n3 = [];
        return e3.traverse((e4) => {
          return void 0 !== (r3 = e4).material && r3.userData && r3.userData._variantMaterials && n3.push((async (e5) => {
            const n4 = e5.material, r4 = e5.userData._variantMaterials, i2 = [];
            for (const n5 in r4) {
              const s2 = r4[n5];
              if (s2.material)
                continue;
              const o2 = s2.gltfMaterialIndex;
              i2.push(t2.getDependency("material", o2).then((i3) => {
                e5.material = i3, t2.assignFinalMaterial(e5), r4[n5].material = e5.material;
              }));
            }
            return Promise.all(i2).then(() => {
              e5.material = n4;
            });
          })(e4));
          var r3;
        }), e3.userData.__importData || (e3.userData.__importData = {}), e3.userData.__importData[xd] = { names: r2 }, Promise.all(n3);
      }));
    }
  }
  const Cd = (e2) => void 0 !== e2.material && e2.userData && e2.userData._variantMaterials && !!Object.values(e2.userData._variantMaterials).filter((e3) => Sd(null == e3 ? void 0 : e3.material)), Sd = (e2) => e2 && e2.isMaterial && !Array.isArray(e2);
  class Md {
    constructor(e2) {
      this.writer = e2, this.name = xd, this.variantNames = [];
    }
    beforeParse(e2) {
      const t2 = /* @__PURE__ */ new Set();
      for (const n2 of e2)
        n2.traverse((e3) => {
          if (!Cd(e3))
            return;
          const n3 = e3.userData._variantMaterials;
          for (const e4 in n3) {
            const r2 = n3[e4];
            Sd(r2.material) && t2.add(e4);
          }
        });
      t2.forEach((e3) => this.variantNames.push(e3));
    }
    writeMesh(e2, t2) {
      var n2;
      if (!Cd(e2))
        return;
      const r2 = e2.userData, i2 = r2._variantMaterials, s2 = {};
      for (const e3 in i2) {
        const t3 = i2[e3].material;
        if (!Sd(t3))
          continue;
        const n3 = this.variantNames.indexOf(e3), r3 = this.writer.processMaterial(t3);
        s2[r3] || (s2[r3] = { material: r3, variants: [] }), s2[r3].variants.push(n3);
      }
      const o2 = Object.values(s2).map((e3) => e3.variants.sort((e4, t3) => e4 - t3) && e3).sort((e3, t3) => e3.material - t3.material);
      if (0 === o2.length)
        return;
      const a2 = Sd(r2._originalMaterial) && null !== (n2 = this.writer.processMaterial(r2._originalMaterial)) && void 0 !== n2 ? n2 : -1;
      for (const e3 of t2.primitives)
        a2 >= 0 && (e3.material = a2), e3.extensions = e3.extensions || {}, e3.extensions[this.name] = { mappings: o2 };
    }
    afterParse(e2) {
      if (0 === this.variantNames.length)
        return;
      const t2 = this.writer.json;
      t2.extensions = t2.extensions || {};
      const n2 = this.variantNames.map((e3) => ({ name: e3 }));
      t2.extensions[this.name] = { variants: n2 }, this.writer.extensionsUsed[this.name] = true;
    }
  }
  function Td(e2) {
    return new Md(e2);
  }
  class Pd extends gt {
    constructor() {
      super(), this.enabled = true, this.toJSON = void 0, this.dependencies = [Ls], this.variants = {}, this.selectedVariant = "", this._objectAdded = (e2) => {
        var t2, n2;
        const r2 = e2.object;
        "model" === (null == r2 ? void 0 : r2.assetType) && r2.modelObject && this._viewer && (r2.modelObject.traverse((e3) => {
          var t3, n3, r3, i2, s2;
          if (e3.userData._variantMaterials)
            for (const i3 of Object.values(e3.userData._variantMaterials))
              (null == i3 ? void 0 : i3.material) && (i3.material = (null === (r3 = null === (n3 = null === (t3 = this._viewer) || void 0 === t3 ? void 0 : t3.getManager()) || void 0 === n3 ? void 0 : n3.materials) || void 0 === r3 ? void 0 : r3.processMaterial(i3.material, {})) || i3.material);
          const o2 = null === (s2 = null === (i2 = e3.userData) || void 0 === i2 ? void 0 : i2.__importData) || void 0 === s2 ? void 0 : s2[xd];
          if (!o2)
            return;
          const a2 = o2.names || [];
          for (const t4 of a2)
            this.variants[t4] || (this.variants[t4] = []), this.variants[t4].push(e3);
          delete e3.userData.__importData[xd];
        }), null === (n2 = (t2 = this.uiConfig).uiRefresh) || void 0 === n2 || n2.call(t2));
      }, this.uiConfig = { type: "folder", label: "KHR Material Variants", children: [() => ({ children: [null, ...Object.keys(this.variants)].map((e2) => e2 ? { label: e2 } : { label: "none", value: "" }), type: "dropdown", label: "Variant", property: [this, "selectedVariant"] })] }, this._loaderCreate = this._loaderCreate.bind(this);
    }
    async onAdded(e2) {
      var t2, n2, r2, i2;
      await super.onAdded(e2), e2.scene.addEventListener("addSceneObject", this._objectAdded);
      const s2 = e2.getPlugin(Ls);
      null === (t2 = null == s2 ? void 0 : s2.importer) || void 0 === t2 || t2.addEventListener("loaderCreate", this._loaderCreate), null === (i2 = null === (r2 = null === (n2 = null == s2 ? void 0 : s2.exporter) || void 0 === n2 ? void 0 : n2.getExporter("gltf", "glb")) || void 0 === r2 ? void 0 : r2.extensions) || void 0 === i2 || i2.push(Td);
    }
    _loaderCreate({ loader: e2 }) {
      e2.isGLTFLoader2 && e2.register((e3) => new Ed(e3));
    }
    async onRemove(e2) {
      var t2, n2, r2, i2, s2, o2;
      e2.scene.removeEventListener("addSceneObject", this._objectAdded);
      const a2 = e2.getPlugin(Ls);
      null === (t2 = a2.importer) || void 0 === t2 || t2.removeEventListener("loaderCreate", this._loaderCreate);
      const l2 = null === (i2 = null === (r2 = null === (n2 = a2.exporter) || void 0 === n2 ? void 0 : n2.getExporter("gltf", "glb")) || void 0 === r2 ? void 0 : r2.extensions) || void 0 === i2 ? void 0 : i2.indexOf(Td);
      return void 0 !== l2 && -1 !== l2 && (null === (o2 = null === (s2 = a2.exporter.getExporter("gltf", "glb")) || void 0 === s2 ? void 0 : s2.extensions) || void 0 === o2 || o2.splice(l2, 1)), this.variants = {}, super.onRemove(e2);
    }
    _variantChanged() {
      this.applyVariant(this.selectedVariant || "", true);
    }
    applyVariant(e2, t2 = false, n2, r2 = true) {
      if (!t2 && !n2 && this.selectedVariant === e2)
        return;
      if (!e2)
        return;
      n2 || (this.selectedVariant = e2);
      const i2 = n2 ? Array.isArray(n2) ? n2 : [n2] : e2 ? this.variants[e2] || [] : Object.values(this.variants).flat();
      for (const t3 of i2) {
        const n3 = /* @__PURE__ */ new Set(), i3 = (t4) => {
          var r3, i4;
          if (!t4.userData._variantMaterials || n3.has(t4))
            return;
          const s2 = e2 ? null === (r3 = t4.userData._variantMaterials[e2]) || void 0 === r3 ? void 0 : r3.material : t4.userData._originalMaterial;
          s2 && (t4.userData._originalMaterial || (t4.userData._originalMaterial = t4.material), null === (i4 = null == t4 ? void 0 : t4.setMaterial) || void 0 === i4 || i4.call(t4, s2)), n3.add(t4);
        };
        r2 ? t3.traverse(i3) : i3(t3);
      }
    }
  }
  Pd.PluginType = "GLTFKHRMaterialVariantsPlugin", function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    s2 > 3 && o2 && Object.defineProperty(t2, n2, o2);
  }([(0, t.onChange)(Pd.prototype._variantChanged)], Pd.prototype, "selectedVariant", void 0);
  function Id(e2) {
    const t2 = null == e2 ? void 0 : e2.userData;
    if (!t2)
      return false;
    t2._ssBevel || (t2._ssBevel = {});
    const n2 = t2._ssBevel;
    return n2.hasSSBevel = true, void 0 === n2.radius && (n2.radius = 0), e2.isMaterial && (e2.needsUpdate = true), true;
  }
  let Rd = class extends dt {
    constructor(e2, r2, i2, s2) {
      super({ defines: { NUM_SAMPLES: 16 }, uniforms: { tNormalDepth: { value: null }, tNormalBuffer: { value: null }, tGBufferFlags: { value: null }, edgeMaskBuffer: { value: null }, screenSize: { value: new n.FM8() }, radius: { value: 1 }, samples: { value: null }, frameCount: { value: 0 }, dpr: { value: 1 }, cameraPositionWorld: { value: new n.Pa4(1, 1, 1) } }, vertexShader: lo, fragmentShader: `

            ${i2}

            ${co}

            uniform sampler2D tNormalBuffer;uniform sampler2D edgeMaskBuffer;uniform vec2 screenSize;uniform float dpr;const float depthStep=0.02;uniform vec2 samples[NUM_SAMPLES];uniform vec3 cameraPositionWorld;varying vec2 vUv;
#include <common>
float getBevelRadius(in float number){return floor(number/8.);}vec3 smoothNormal(){vec2 uv=gl_FragCoord.xy/screenSize;vec4 texel=texture2D(tNormalDepth,uv);vec4 edgeMask=texture2D(edgeMaskBuffer,uv);vec3 avgNormal=2.*texture2D(tNormalBuffer,uv).rgb-1.;float depth=pow(unpack16(texel.xy),2.);vec2 invScreenSize=vec2(1.)/screenSize;vec4 mask=texture2D(tGBufferFlags,uv);float weightSum=0.;float radius=getBevelRadius(mask.g*255.)*2.*dpr;float randomAngle=6.2*random(frameCount*0.1);float theta=randomAngle;float snTheta=sin(theta);float csTheta=cos(theta);mat2 randomRotationMatrix=mat2(csTheta,snTheta,-snTheta,csTheta);float d_=dot(cameraPositionWorld,cameraPositionWorld);float radiusModifier=clamp(1./(1.+pow(d_,0.5)),0.,1.);for(int i=0;i<5;i++){float x=float(i)-2.;for(int j=0;j<5;j++){float y=float(j)-2.;vec2 offset=randomRotationMatrix*vec2(x,y)*radius*radiusModifier*invScreenSize;vec4 texel=texture2D(tNormalDepth,uv+offset);float offsetDepth=pow(unpack16(texel.xy),2.);float depthWeight=abs(offsetDepth-depth);depthWeight=(1.-step(depthStep,depthWeight));vec3 offsetNormal=2.*texture2D(tNormalBuffer,uv+offset).rgb-1.;if(dot(offsetNormal,offsetNormal)>0.){avgNormal+=offsetNormal*depthWeight;}}}return normalize(avgNormal);}void main(){vec2 uv=gl_FragCoord.xy/screenSize;vec4 edgeMask=texture2D(edgeMaskBuffer,uv);vec3 normal=vec3(0.);if(edgeMask.x>0.){normal=smoothNormal();}else{normal=2.*texture2D(tNormalBuffer,uv).rgb-1.;}gl_FragColor=vec4(vec3(0.5*normal+0.5),1.);}
            
            ` }, "tDiffuse"), this.uiConfig = void 0, this.materialExtension = { shaderExtender: (e3, t2, n2) => {
        var r3, i3;
        this.enabled && (null === (i3 = null === (r3 = t2.materialObject.userData) || void 0 === r3 ? void 0 : r3._ssBevel) || void 0 === i3 ? void 0 : i3.hasSSBevel) && (e3.fragmentShader = ot(e3.fragmentShader, "#include <normal_fragment_maps>", " \n                normal = 2. * texture2D(tSSBevelMap, viewToScreen(vViewPosition.xyz).xy).rgb - 1.;\n                normal = normalize(normal);\n                //geometryNormal = normal;\n            "));
      }, onObjectRender: (e3, t2, n2) => {
        var r3, i3;
        if (!this.enabled || !(null === (i3 = null === (r3 = t2.materialObject.userData) || void 0 === r3 ? void 0 : r3._ssBevel) || void 0 === i3 ? void 0 : i3.hasSSBevel))
          return;
        const s3 = t2.materialObject, o2 = this._target.texture;
        this.materialExtension.extraUniforms.tSSBevelMap.value !== o2 && (this.materialExtension.extraUniforms.tSSBevelMap.value = o2, s3.needsUpdate = true);
      }, getUiConfig: (e3) => {
        const t2 = { type: "folder", label: "SSBevel (Dev)", children: [{ type: "checkbox", label: "Enabled", get value() {
          var t3;
          return (null === (t3 = e3.materialObject.userData._ssBevel) || void 0 === t3 ? void 0 : t3.hasSSBevel) || false;
        }, set value(n2) {
          var r3, i3;
          n2 !== (null === (r3 = e3.materialObject.userData._ssBevel) || void 0 === r3 ? void 0 : r3.hasSSBevel) && (n2 ? Id(e3.materialObject) || alert("Cannot add screen space bevel.") : e3.materialObject.userData._ssBevel && (e3.materialObject.userData._ssBevel.hasSSBevel = false, e3.materialObject.needsUpdate = true), null === (i3 = t2.uiRefresh) || void 0 === i3 || i3.call(t2, "postFrame", true));
        }, onChange: this.setDirty }, () => ({ type: "slider", bounds: [0, 8], label: "radius", hidden: () => {
          var t3;
          return !(null === (t3 = e3.materialObject.userData._ssBevel) || void 0 === t3 ? void 0 : t3.hasSSBevel);
        }, property: [e3.materialObject.userData._ssBevel, "radius"], onChange: this.setDirty })] };
        return t2;
      }, parsFragmentSnippet: (e3, n2) => {
        var r3, i3;
        return this.enabled && (null === (i3 = null === (r3 = null == n2 ? void 0 : n2.materialObject.userData) || void 0 === r3 ? void 0 : r3._ssBevel) || void 0 === i3 ? void 0 : i3.hasSSBevel) ? t.glsl`
            uniform sampler2D tSSBevelMap;
            ${uo}
            ` : "";
      }, extraUniforms: { tSSBevelMap: { value: null } }, computeCacheKey: (e3) => {
        var t2, n2;
        return (this.enabled ? "1" : "0") + ((null === (n2 = null === (t2 = e3.materialObject.userData) || void 0 === t2 ? void 0 : t2._ssBevel) || void 0 === n2 ? void 0 : n2.hasSSBevel) ? "1" : "0");
      }, isCompatible: (e3) => e3.isMeshStandardMaterial2 }, this._target = r2, this.needsSwap = false, this.clear = true, this._viewerApp = s2, this._edgeMaterial = new ct({ uniforms: { tNormalDepth: { value: null }, tNormalBuffer: { value: null }, tGBufferFlags: { value: null }, screenSize: { value: null }, radius: { value: 10 }, cameraNearFar: { value: new n.FM8(1, 1) }, cameraPositionWorld: { value: new n.Pa4(1, 1, 1) } }, vertexShader: lo, fragmentShader: "uniform vec2 screenSize;uniform sampler2D tNormalDepth;uniform sampler2D tNormalBuffer;uniform sampler2D tGBufferFlags;uniform float radius;uniform vec2 cameraNearFar;uniform vec3 cameraPositionWorld;const float depthStep=0.2;const float normalThreshold=0.9;float unpack16(vec2 value){return(value.x*0.996108949416342426275150501169264316558837890625+value.y*0.00389105058365758760263730664519243873655796051025390625);}vec3 unpackNormal(vec2 enc){vec2 fenc=enc*4.-2.;float f=dot(fenc,fenc);float g=sqrt(1.-f/4.);return vec3(fenc*g,1.-f/2.);}void lookupNormalDepth(out float depth,out vec3 normal,vec2 off){vec2 uv=(gl_FragCoord.st+off)/screenSize;vec4 texel=texture2D(tNormalDepth,uv);depth=mix(cameraNearFar.x,cameraNearFar.y,pow(unpack16(texel.xy),2.));normal=2.*texture2D(tNormalBuffer,uv).rgb-1.;}float getBorderWeight(){float depth1,depth2,depth3,depth4;vec3 normal1,normal2,normal3,normal4;float d_=dot(cameraPositionWorld,cameraPositionWorld);float radiusModifier=clamp(3./(1.+pow(d_,0.5)),0.,1.);float modRad=radius;lookupNormalDepth(depth1,normal1,vec2(0.,modRad));lookupNormalDepth(depth2,normal2,vec2(0.,-modRad));lookupNormalDepth(depth3,normal3,vec2(modRad,0.));lookupNormalDepth(depth4,normal4,vec2(-modRad,0.));vec2 uv=(gl_FragCoord.st)/screenSize;float mask=step(0.0001,texture2D(tGBufferFlags,uv).g);float mask1=texture2D(tGBufferFlags,uv+vec2(0.,modRad)/screenSize).b*255.;float mask2=texture2D(tGBufferFlags,uv+vec2(0.,-modRad)/screenSize).b*255.;float mask3=texture2D(tGBufferFlags,uv+vec2(modRad,0.)/screenSize).b*255.;float mask4=texture2D(tGBufferFlags,uv+vec2(-modRad,0.)/screenSize).b*255.;float maskWeight=max(abs(mask1-mask2),abs(mask3-mask4))*255.;maskWeight=(step(maskWeight,0.01));float a1=dot(normal1,normal2);float a2=dot(normal3,normal4);float normalWeight=min(abs(a1),abs(a2));normalWeight=1.-step(normalThreshold,normalWeight);float depthWeight=max(abs(depth1-depth2),abs(depth3-depth4));depthWeight=(step(depthWeight,depthStep));return normalWeight*depthWeight*maskWeight*mask;}void main(){float weight=getBorderWeight();vec2 uv=gl_FragCoord.st/screenSize;vec4 texel=texture2D(tNormalDepth,uv);float depth=pow(unpack16(texel.xy),2.);vec3 outColor=vec3(0.);if(depth>0.999){weight=0.;}else{outColor=vec3(weight);}gl_FragColor=vec4(outColor,1.);}" }), this._separableBlurMaterial = new ct({ defines: { KERNEL_RADIUS: 3, SIGMA: 3 }, uniforms: { colorTexture: { value: null }, maskTexture: { value: null }, texSize: { value: new n.FM8(0.5, 0.5) }, direction: { value: new n.FM8(0.5, 0.5) } }, vertexShader: lo, fragmentShader: "varying vec2 vUv;uniform sampler2D colorTexture;uniform sampler2D maskTexture;uniform vec2 texSize;uniform vec2 direction;float gaussianPdf(in float x,in float sigma){return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;}void main(){vec2 invSize=1./texSize;float fSigma=float(SIGMA);float weightSum=gaussianPdf(0.,fSigma);vec4 mask=texture2D(maskTexture,vUv);vec3 diffuseSum=texture2D(colorTexture,vUv).rgb*weightSum;for(int i=1;i<KERNEL_RADIUS;i++){float x=float(i);float w=gaussianPdf(x,fSigma);vec2 uvOffset=direction*invSize*x;vec3 sample1=texture2D(colorTexture,vUv+uvOffset).rgb;vec3 sample2=texture2D(colorTexture,vUv-uvOffset).rgb;diffuseSum+=(sample1+sample2)*w;weightSum+=2.*w;}gl_FragColor=vec4(diffuseSum/weightSum,1.);}" });
    }
    render(e2, t2, r2, i2, s2) {
      var o2, a2;
      if (!this.enabled)
        return;
      const l2 = e2.baseRenderer, c2 = { minFilter: n.wem, magFilter: n.wem, isAntialiased: false, format: n.wk1, depthBuffer: false, generateMipmaps: false }, u2 = l2.getTempTarget(c2);
      this._renderEdges(l2, u2), this._blurEdges(l2, u2), this._viewerApp.scene.renderCamera.updateShaderProperties(this.material), null === (o2 = this._viewerApp.getPlugin(wt)) || void 0 === o2 || o2.updateShaderProperties(this.material), null === (a2 = this._viewerApp.getPlugin(al)) || void 0 === a2 || a2.updateShaderProperties(this.material), this._viewerApp.renderer.updateShaderProperties(this.material), this.uniforms.edgeMaskBuffer.value = u2.texture, this.uniforms.dpr.value = this._viewerApp.renderer.displayCanvasScaling, super.render(e2, this._target, u2, i2, s2), l2.releaseTempTarget(u2);
    }
    _initsamples() {
      const e2 = [], t2 = 1 / 8;
      return e2.push(new n.FM8(-8, 0).multiplyScalar(t2)), e2.push(new n.FM8(-6, -4).multiplyScalar(t2)), e2.push(new n.FM8(-3, -2).multiplyScalar(t2)), e2.push(new n.FM8(-2, -6).multiplyScalar(t2)), e2.push(new n.FM8(1, -1).multiplyScalar(t2)), e2.push(new n.FM8(2, -5).multiplyScalar(t2)), e2.push(new n.FM8(6, -7).multiplyScalar(t2)), e2.push(new n.FM8(5, -3).multiplyScalar(t2)), e2.push(new n.FM8(4, 1).multiplyScalar(t2)), e2.push(new n.FM8(7, 4).multiplyScalar(t2)), e2.push(new n.FM8(3, 5).multiplyScalar(t2)), e2.push(new n.FM8(0, 7).multiplyScalar(t2)), e2.push(new n.FM8(-1, 3).multiplyScalar(t2)), e2.push(new n.FM8(-4, 6).multiplyScalar(t2)), e2.push(new n.FM8(-7, 8).multiplyScalar(t2)), e2.push(new n.FM8(-5, 2).multiplyScalar(t2)), e2;
    }
    _blurEdges(e2, t2) {
      var r2, i2;
      const s2 = { minFilter: n.wem, magFilter: n.wem, isAntialiased: false, format: n.wk1, depthBuffer: false, generateMipmaps: false, sizeMultiplier: 0.5 }, o2 = e2.getTempTarget(s2), a2 = (null === (r2 = t2.texture.image) || void 0 === r2 ? void 0 : r2.width) || 1, l2 = (null === (i2 = t2.texture.image) || void 0 === i2 ? void 0 : i2.height) || 1;
      this._separableBlurMaterial.uniforms.texSize.value = new n.FM8(a2, l2), this._separableBlurMaterial.uniforms.colorTexture.value = t2.texture, this._separableBlurMaterial.uniforms.direction.value = new n.FM8(1, 0), e2.blit(void 0, o2, { material: this._separableBlurMaterial }), this._separableBlurMaterial.uniforms.texSize.value = new n.FM8(a2 / 2, l2 / 2), this._separableBlurMaterial.uniforms.colorTexture.value = o2.texture, this._separableBlurMaterial.uniforms.direction.value = new n.FM8(0, 1), e2.blit(void 0, t2, { material: this._separableBlurMaterial }), e2.releaseTempTarget(o2);
    }
    _renderEdges(e2, t2) {
      var r2, i2, s2, o2;
      const a2 = (null === (r2 = t2.texture.image) || void 0 === r2 ? void 0 : r2.width) || 1, l2 = (null === (i2 = t2.texture.image) || void 0 === i2 ? void 0 : i2.height) || 1;
      this._edgeMaterial.uniforms.screenSize.value = new n.FM8(a2, l2), this._viewerApp.scene.renderCamera.updateShaderProperties(this._edgeMaterial), null === (s2 = this._viewerApp.getPlugin(wt)) || void 0 === s2 || s2.updateShaderProperties(this._edgeMaterial), null === (o2 = this._viewerApp.getPlugin(al)) || void 0 === o2 || o2.updateShaderProperties(this._edgeMaterial), e2.blit(void 0, t2, { material: this._edgeMaterial });
    }
  };
  Rd = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  }([We("SSBevel")], Rd);
  class kd extends yt {
    get bevelTarget() {
      return this._bevelTarget;
    }
    constructor(e2 = true) {
      super(), this.passId = "ssBevel", this._beforeFilters = ["render"], this._afterFilters = ["gbuffer", "normalBuffer"], this._requiredFilters = ["render", "gbuffer", "normalBuffer"], this._lastEnabled = false, this.dependencies = [Ls, wt, al], this.enabled = e2, this.setDirty = this.setDirty.bind(this), this._loaderCreate = this._loaderCreate.bind(this), this.updateGBuffer = this.updateGBuffer.bind(this);
    }
    _loaderCreate({ loader: e2 }) {
      e2.isGLTFLoader2 && e2.register((e3) => new Dd(e3));
    }
    passCtor(e2) {
      var t2, r2;
      return this._bevelTarget = e2.renderer.createTarget({ depthBuffer: true, type: n.cLu, minFilter: n.TyD, magFilter: n.TyD, generateMipmaps: false }), this._bevelTarget.texture.name = "bevelBuffer", this._bevelTarget.texture.generateMipmaps = false, e2.getPluginByType("debug"), new Rd(e2.renderer, this._bevelTarget, null !== (r2 = null === (t2 = e2.getPlugin(wt)) || void 0 === t2 ? void 0 : t2.getUnpackSnippet()) && void 0 !== r2 ? r2 : "", e2);
    }
    async onAdded(e2) {
      var t2, n2, r2, i2, s2, o2, a2, l2;
      await super.onAdded(e2);
      const c2 = e2.getPlugin(Ls);
      return (null === (t2 = this.pass) || void 0 === t2 ? void 0 : t2.passObject.materialExtension) && (null === (n2 = null == c2 ? void 0 : c2.materials) || void 0 === n2 || n2.registerMaterialExtension(null === (r2 = this.pass) || void 0 === r2 ? void 0 : r2.passObject.materialExtension)), null === (i2 = null == c2 ? void 0 : c2.importer) || void 0 === i2 || i2.addEventListener("loaderCreate", this._loaderCreate), null === (a2 = null === (o2 = null === (s2 = null == c2 ? void 0 : c2.exporter) || void 0 === s2 ? void 0 : s2.getExporter("gltf", "glb")) || void 0 === o2 ? void 0 : o2.extensions) || void 0 === a2 || a2.push(Bd), null === (l2 = e2.getPlugin(wt)) || void 0 === l2 || l2.registerGBufferUpdater(this.updateGBuffer), super.onAdded(e2);
    }
    async onRemove(e2) {
      return e2.renderer.disposeTarget(this._bevelTarget), super.onRemove(e2);
    }
    setDirty() {
      var e2, t2, n2, r2;
      null === (e2 = this._viewer) || void 0 === e2 || e2.setDirty(), null === (r2 = null === (t2 = this.pass) || void 0 === t2 ? void 0 : (n2 = t2.passObject.materialExtension).setDirty) || void 0 === r2 || r2.call(n2);
    }
    _update(e2) {
      var t2, n2;
      let r2 = this.enabled;
      if (r2 && !this._lastEnabled) {
        const e3 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPluginByType("NormalBufferPlugin");
        e3 && !e3.enabled && (e3.enabled = true), e3 || null === (n2 = this._viewer) || void 0 === n2 || n2.console.error("SSBevelPlugin needs NormalBufferPlugin");
      }
      return this._lastEnabled = r2, r2;
    }
    get uiConfig() {
      var e2, n2, r2, i2, s2;
      const o2 = null !== (r2 = null === (n2 = null === (e2 = this.pass) || void 0 === e2 ? void 0 : e2.passObject) || void 0 === n2 ? void 0 : n2.uiConfig) && void 0 !== r2 ? r2 : {};
      return null === (s2 = null === (i2 = o2.children) || void 0 === i2 ? void 0 : i2.map((e3) => (0, t.getOrCall)(e3))) || void 0 === s2 || s2.flat(2).forEach((e3) => e3 && (e3.onChange = this.setDirty)), o2;
    }
    updateGBuffer(e2, t2) {
      var r2, i2, s2;
      if (e2 instanceof n.Kj0 && (null === (r2 = e2.material) || void 0 === r2 ? void 0 : r2.userData)) {
        for (let e3 = 3; e3 < 8; e3++)
          t2.y = Ys(t2.y, e3);
        let n2 = (null === (i2 = e2.material) || void 0 === i2 ? void 0 : i2.userData._ssBevel) ? null === (s2 = e2.material) || void 0 === s2 ? void 0 : s2.userData._ssBevel.radius : 0;
        n2 = Math.min(n2, 31), n2 <<= 3, t2.y = t2.y | n2;
      }
    }
  }
  kd.PluginType = "SSBevelPlugin", kd.SSBEVEL_GLTF_EXTENSION = "WEBGI_materials_ssbevel";
  class Dd {
    constructor(e2) {
      this.parser = e2, this.name = kd.SSBEVEL_GLTF_EXTENSION;
    }
    async extendMaterialParams(e2, t2) {
      const n2 = this.parser.json.materials[e2];
      if (!n2.extensions || !n2.extensions[this.name])
        return Promise.resolve();
      const r2 = n2.extensions[this.name];
      return t2.userData || (t2.userData = {}), Id(t2), t2.userData._ssBevel = ce(r2, t2.userData._ssBevel, false, {}), Promise.resolve();
    }
  }
  const Bd = (e2) => ({ writeMaterial: (t2, n2) => {
    if (!t2.isMeshStandardMaterial || !t2.userData._ssBevel)
      return;
    if (!t2.userData._ssBevel.hasSSBevel)
      return;
    n2.extensions = n2.extensions || {};
    const r2 = le(t2.userData._ssBevel, false);
    n2.extensions[kd.SSBEVEL_GLTF_EXTENSION] = r2, e2.extensionsUsed[kd.SSBEVEL_GLTF_EXTENSION] = true;
  } });
  class Od {
    constructor() {
      this.uiConfig = void 0, this.enabled = true;
    }
    shaderExtender(e2, t2, n2) {
      this.enabled && (e2.fragmentShader = ot(e2.fragmentShader, "#glMarker", " \n            gl_FragColor = LinearTosRGB(gl_FragColor);\n            #glMarker\n        "));
    }
    computeCacheKey(e2) {
      return this.enabled ? "1" : "0";
    }
    isCompatible(e2) {
      return true;
    }
  }
  class Ld extends qs {
    generateExtension(e2) {
      return new Od();
    }
  }
  Ld.PluginType = "GammaCorrection";
  var Ud = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let Fd = class extends gt {
    addTriplanarMapping(e2) {
      var t2;
      const n2 = null === (t2 = e2.materialObject) || void 0 === t2 ? void 0 : t2.userData;
      return !!n2 && (n2._triplanarMapping || (n2._triplanarMapping = {}), n2._triplanarMapping.enable = true, void 0 === n2._triplanarMapping.scaleFactor && (n2._triplanarMapping.scaleFactor = 1), void 0 === n2._triplanarMapping.blendFactor && (n2._triplanarMapping.blendFactor = 1), void 0 === n2._triplanarMapping.offsetFactor && (n2._triplanarMapping.offsetFactor = 0), e2.materialObject.needsUpdate = true, true);
    }
    _loaderCreate({ loader: e2 }) {
      e2.isGLTFLoader2 && e2.register((e3) => new Nd(e3));
    }
    constructor() {
      super(), this.enabled = true, this.dependencies = [Ls], this._uniforms = { triplanarScale: { value: 1 }, triplanarBlend: { value: 1 }, triplanarOffset: { value: 0 } }, this.materialExtension = { shaderExtender: (e2, r2, i2) => {
        var s2, o2;
        if (!this.enabled || !(null === (o2 = null === (s2 = r2.materialObject.userData) || void 0 === s2 ? void 0 : s2._triplanarMapping) || void 0 === o2 ? void 0 : o2.enable))
          return;
        const a2 = t.glsl`
                #ifndef USE_TRANSMISSION
                    varying vec3 vWorldPosition;
                #endif
                varying vec3 vWorldNormal;
            `;
        e2.vertexShader = ot(e2.vertexShader, "#include <common>", a2, { prepend: true });
        const l2 = t.glsl`
                // same as worldpos_vertex.glsl.js but added a !
                #if !(defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0)
                vec4 worldPosition = vec4( transformed, 1.0 );
                #ifdef USE_INSTANCING
                worldPosition = instanceMatrix * worldPosition;
                #endif
                worldPosition = modelMatrix * worldPosition;
                #endif
                
                #ifndef USE_TRANSMISSION
                    vWorldPosition = worldPosition.xyz; 
                #endif
                vWorldNormal = normalize((modelMatrix * vec4(objectNormal, 0.)).xyz);
            `;
        e2.vertexShader = ot(e2.vertexShader, "#include <worldpos_vertex>", l2, { append: true });
        const c2 = t.glsl`
                ${"struct TriplanarUV{vec2 x;vec2 y;vec2 z;};uniform float triplanarScale;uniform float triplanarBlend;uniform float triplanarOffset;vec3 getTriplanarWeights(in vec3 position,in vec3 normal){vec3 triW=abs(normal);triW=clamp(triW-vec3(triplanarOffset),vec3(0.),vec3(1.));triW=pow(triW,vec3(triplanarBlend));return triW/(triW.x+triW.y+triW.z);}TriplanarUV getTriplanarUV(in vec3 position,in vec3 normal){TriplanarUV triUV;triUV.x=position.zy*triplanarScale;triUV.y=position.xz*triplanarScale;triUV.z=position.xy*triplanarScale;if(normal.x<0.){triUV.x.x=-triUV.x.x;}if(normal.y<0.){triUV.y.x=-triUV.y.x;}if(normal.z>=0.){triUV.z.x=-triUV.z.x;}return triUV;}vec4 textureTriplanar(in sampler2D tex,in vec3 position,in vec3 normal){TriplanarUV triUV=getTriplanarUV(position,normal);vec4 texX=texture2D(tex,triUV.x);vec4 texY=texture2D(tex,triUV.y);vec4 texZ=texture2D(tex,triUV.z);vec3 triW=getTriplanarWeights(position,normal);return texX*triW.x+texY*triW.y+texZ*triW.z;}"}
                #ifndef USE_TRANSMISSION
                    varying vec3 vWorldPosition;
                #endif
                varying vec3 vWorldNormal;
            `;
        e2.fragmentShader = ot(e2.fragmentShader, "#include <common>", c2, { prepend: true });
        const u2 = t.glsl`

            #ifdef USE_BUMPMAP

            uniform sampler2D bumpMap;
            uniform float bumpScale;

            // Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen
            // https://mmikk.github.io/papers3d/mm_sfgrad_bump.pdf

            // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

            vec2 dHdxy_fwd() {

                vec3 dSTdx = dFdx( vWorldPosition );
                vec3 dSTdy = dFdy( vWorldPosition );

                vec3 normal_ = normalize(vWorldNormal);
                float Hll = bumpScale * textureTriplanar( bumpMap, vWorldPosition, normal_ ).x;
                float dBx = bumpScale * textureTriplanar( bumpMap, vWorldPosition + dSTdx, normal_ ).x - Hll;
                float dBy = bumpScale * textureTriplanar( bumpMap, vWorldPosition + dSTdy, normal_ ).x - Hll;

                return vec2( dBx, dBy );

            }

            vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {

                vec3 vSigmaX = dFdx( surf_pos.xyz );
                vec3 vSigmaY = dFdy( surf_pos.xyz );
                vec3 vN = surf_norm; // normalized

                vec3 R1 = cross( vSigmaY, vN );
                vec3 R2 = cross( vN, vSigmaX );

                float fDet = dot( vSigmaX, R1 ) * faceDirection;

                vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
                return normalize( abs( fDet ) * surf_norm - vGrad );

            }

        #endif
            `;
        e2.fragmentShader = ot(e2.fragmentShader, "#include <bumpmap_pars_fragment>", u2);
        let p2 = ot(n.WdD.map_fragment, "texture2D( map, vMapUv );", "textureTriplanar( map, vWorldPosition, normalize(vWorldNormal) );");
        e2.fragmentShader = ot(e2.fragmentShader, "#include <map_fragment>", p2), p2 = ot(n.WdD.roughnessmap_fragment, "texture2D( roughnessMap, vRoughnessMapUv );", "textureTriplanar( roughnessMap, vWorldPosition, normalize(vWorldNormal));"), e2.fragmentShader = ot(e2.fragmentShader, "#include <roughnessmap_fragment>", p2), p2 = ot(n.WdD.metalnessmap_fragment, "texture2D( metalnessMap, vMetalnessMapUv );", "textureTriplanar( metalnessMap, vWorldPosition, normalize(vWorldNormal));"), e2.fragmentShader = ot(e2.fragmentShader, "#include <metalnessmap_fragment>", p2), p2 = ot(n.WdD.normal_fragment_maps, "vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;", "vec3 mapN = textureTriplanar( normalMap, vWorldPosition, normalize(vWorldNormal) ).xyz * 2.0 - 1.0;"), e2.fragmentShader = ot(e2.fragmentShader, "#include <normal_fragment_maps>", p2), e2.defines.USE_UV = "";
      }, onObjectRender: (e2, t2) => {
        var n2, r2, i2, s2;
        const o2 = t2.materialObject.userData;
        if (!(null === (n2 = null == o2 ? void 0 : o2._triplanarMapping) || void 0 === n2 ? void 0 : n2.enable))
          return;
        const a2 = e2;
        a2.isMesh && a2.geometry && (this._uniforms.triplanarScale.value = null === (r2 = o2._triplanarMapping) || void 0 === r2 ? void 0 : r2.scaleFactor, this._uniforms.triplanarBlend.value = null === (i2 = o2._triplanarMapping) || void 0 === i2 ? void 0 : i2.blendFactor, this._uniforms.triplanarOffset.value = null === (s2 = o2._triplanarMapping) || void 0 === s2 ? void 0 : s2.offsetFactor);
      }, extraUniforms: { ...this._uniforms }, computeCacheKey: (e2) => {
        var t2, n2;
        return (this.enabled ? "1" : "0") + ((null === (n2 = null === (t2 = e2.materialObject.userData) || void 0 === t2 ? void 0 : t2._triplanarMapping) || void 0 === n2 ? void 0 : n2.enable) ? "1" : "0");
      }, isCompatible: (e2) => e2.isMeshStandardMaterial2, updaters: () => {
        var e2;
        return [null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.renderer];
      }, getUiConfig: (e2) => {
        const t2 = this._viewer, n2 = this.addTriplanarMapping, r2 = { type: "folder", label: "Triplanar", children: [{ type: "checkbox", label: "Enabled", get value() {
          var t3;
          return (null === (t3 = e2.materialObject.userData._triplanarMapping) || void 0 === t3 ? void 0 : t3.enable) || false;
        }, set value(i2) {
          var s2, o2;
          i2 !== (null === (s2 = e2.materialObject.userData._triplanarMapping) || void 0 === s2 ? void 0 : s2.enable) && (i2 ? n2(e2) || t2.alert("Cannot add Triplanar mapping.") : e2.materialObject.userData._triplanarMapping && (e2.materialObject.userData._triplanarMapping.enable = false, e2.materialObject.needsUpdate = true), null === (o2 = r2.uiRefresh) || void 0 === o2 || o2.call(r2, "postFrame", true));
        }, onChange: this.setDirty }, () => ({ type: "slider", bounds: [0.1, 10], label: "Scale", hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._triplanarMapping) || void 0 === t3 ? void 0 : t3.enable);
        }, property: [e2.materialObject.userData._triplanarMapping, "scaleFactor"], onChange: this.setDirty }), () => ({ type: "slider", bounds: [1, 10], label: "Blend", hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._triplanarMapping) || void 0 === t3 ? void 0 : t3.enable);
        }, property: [e2.materialObject.userData._triplanarMapping, "blendFactor"], onChange: this.setDirty }), () => ({ type: "slider", bounds: [0, 0.5], stepSize: 0.01, label: "Offset", hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._triplanarMapping) || void 0 === t3 ? void 0 : t3.enable);
        }, property: [e2.materialObject.userData._triplanarMapping, "offsetFactor"], onChange: this.setDirty })] };
        return r2;
      } }, this.setDirty = () => {
        var e2, t2, n2;
        null === (t2 = (e2 = this.materialExtension).setDirty) || void 0 === t2 || t2.call(e2), null === (n2 = this._viewer) || void 0 === n2 || n2.setDirty();
      }, this._loaderCreate = this._loaderCreate.bind(this);
    }
    async onAdded(e2) {
      var t2, n2, r2, i2, s2;
      await super.onAdded(e2);
      const o2 = e2.getPlugin(Ls);
      null === (t2 = null == o2 ? void 0 : o2.materials) || void 0 === t2 || t2.registerMaterialExtension(this.materialExtension), null === (n2 = null == o2 ? void 0 : o2.importer) || void 0 === n2 || n2.addEventListener("loaderCreate", this._loaderCreate), null === (s2 = null === (i2 = null === (r2 = null == o2 ? void 0 : o2.exporter) || void 0 === r2 ? void 0 : r2.getExporter("gltf", "glb")) || void 0 === i2 ? void 0 : i2.extensions) || void 0 === s2 || s2.push(jd);
    }
    async onRemove(e2) {
      var t2, n2, r2, i2;
      return null === (n2 = null === (t2 = e2.getPlugin(Ls)) || void 0 === t2 ? void 0 : t2.materials) || void 0 === n2 || n2.unregisterMaterialExtension(this.materialExtension), null === (i2 = null === (r2 = e2.getPlugin(Ls)) || void 0 === r2 ? void 0 : r2.importer) || void 0 === i2 || i2.removeEventListener("loaderCreate", this._loaderCreate), super.onRemove(e2);
    }
  };
  Fd.PluginType = "TriplanarUVMappingPlugin", Fd.TRIPLANAR_GLTF_EXTENSION = "WEBGI_materials_triplanar", Ud([Oe("Enabled", (e2) => ({ onChange: e2.setDirty })), ie()], Fd.prototype, "enabled", void 0), Fd = Ud([We("Triplanar Mapping")], Fd);
  class Nd {
    constructor(e2) {
      this.parser = e2, this.name = Fd.TRIPLANAR_GLTF_EXTENSION;
    }
    async extendMaterialParams(e2, t2) {
      const n2 = this.parser.json.materials[e2];
      if (!n2.extensions || !n2.extensions[this.name])
        return Promise.resolve();
      const r2 = n2.extensions[this.name];
      t2.userData || (t2.userData = {});
      const i2 = t2.userData;
      return i2._triplanarMapping || (i2._triplanarMapping = {}), i2._triplanarMapping.enable = true, void 0 === i2._triplanarMapping.scaleFactor && (i2._triplanarMapping.scaleFactor = 1), void 0 === i2._triplanarMapping.blendFactor && (i2._triplanarMapping.blendFactor = 1), void 0 === i2._triplanarMapping.offsetFactor && (i2._triplanarMapping.offsetFactor = 0), t2.userData._triplanarMapping = ce(r2, t2.userData._triplanarMapping, false, {}), Promise.resolve();
    }
  }
  const jd = (e2) => ({ writeMaterial: (t2, n2) => {
    var r2;
    if (!t2.isMeshStandardMaterial || !(null === (r2 = t2.userData._triplanarMapping) || void 0 === r2 ? void 0 : r2.enable))
      return;
    n2.extensions = n2.extensions || {};
    const i2 = le(t2.userData._triplanarMapping, false);
    n2.extensions[Fd.TRIPLANAR_GLTF_EXTENSION] = i2, e2.extensionsUsed[Fd.TRIPLANAR_GLTF_EXTENSION] = true;
  } });
  var zd = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let Gd = class extends gt {
    addLayeredMaterial(e2) {
      var t2;
      const r2 = null === (t2 = e2.materialObject) || void 0 === t2 ? void 0 : t2.userData;
      return !!r2 && (r2._layeredMaterial || (r2._layeredMaterial = {}), r2._layeredMaterial.enable = true, void 0 === r2._layeredMaterial.cutoff && (r2._layeredMaterial.cutoff = -0.65), void 0 === r2._layeredMaterial.cavityColor && (r2._layeredMaterial.cavityColor = new n.Ilk(5789527)), void 0 === r2._layeredMaterial.cavityRoughness && (r2._layeredMaterial.cavityRoughness = 0.5), void 0 === r2._layeredMaterial.cavityMetalness && (r2._layeredMaterial.cavityMetalness = 0.5), void 0 === r2._layeredMaterial.cavityScale && (r2._layeredMaterial.cavityScale = 1), void 0 === r2._layeredMaterial.stepSize && (r2._layeredMaterial.stepSize = 5), e2.materialObject.needsUpdate = true, true);
    }
    _loaderCreate({ loader: e2 }) {
      e2.isGLTFLoader2 && e2.register((e3) => new Vd(e3));
    }
    constructor() {
      super(), this.enabled = true, this.dependencies = [Ls], this._uniforms = { cutoff: { value: 0 }, cavityColor: { value: new n.Ilk() }, cavityRoughness: { value: 0 }, cavityMetalness: { value: 0 }, cavityScale: { value: 1 }, stepSize: { value: 1 } }, this.materialExtension = { shaderExtender: (e2, r2, i2) => {
        var s2, o2;
        if (!this.enabled || !(null === (o2 = null === (s2 = r2.materialObject.userData) || void 0 === s2 ? void 0 : s2._layeredMaterial) || void 0 === o2 ? void 0 : o2.enable))
          return;
        const a2 = t.glsl`
                ${"uniform float cutoff;uniform vec3 cavityColor;uniform float cavityRoughness;uniform float cavityMetalness;uniform float cavityScale;uniform float stepSize;uniform sampler2D cavityMap;float getSSCurvature(in vec3 position,in vec3 normal){vec3 n=normalize(normal);vec3 dx=dFdx(n);vec3 dy=dFdy(n);vec3 xneg=n-stepSize*dx;vec3 xpos=n+stepSize*dx;vec3 yneg=n-stepSize*dy;vec3 ypos=n+stepSize*dy;float depth=length(position);float curvature=(cross(xneg,xpos).y-cross(yneg,ypos).x)*4./depth;return curvature;}"}
            `;
        e2.fragmentShader = ot(e2.fragmentShader, "#include <common>", a2, { prepend: true });
        const l2 = t.glsl`
                material.roughness = min( material.roughness, 1.0 );
                float curvature = getSSCurvature(vViewPosition, normal);
                float smoothCurvature = smoothstep(0., 1., curvature - cutoff);
                material.roughness = min( material.roughness, 1.0 );
                curvature = curvature * cavityScale;
                smoothCurvature = smoothCurvature * cavityScale;
                smoothCurvature = min(smoothCurvature, 1.);
                vec3 finalCavityColor = mix(cavityColor, cavityColor*0.5, vec3(smoothCurvature));
                material.roughness = mix(cavityRoughness, material.roughness, smoothCurvature);
                material.diffuseColor = mix(finalCavityColor, material.diffuseColor, smoothCurvature);
            `, c2 = t.glsl`
                material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
                material.specularColor = mix(material.specularColor, finalCavityColor, (1. - smoothCurvature) * cavityMetalness);
            `;
        let u2 = n.WdD.lights_physical_fragment.replace("material.roughness = min( material.roughness, 1.0 );", l2);
        u2 = u2.replace("material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );", c2), e2.fragmentShader = ot(e2.fragmentShader, "#include <lights_physical_fragment>", u2);
        const p2 = t.glsl`
                vec3 debugCurvatureColor = vec3(0., 0., 1.);
                float _epsilon = 1e-4;
                vec3 green = vec3(0., 0., 0.);
                vec3 red = vec3(1., 1., 1.);
                //if(curvature > cutoff)debugCurvatureColor = green;
                //if(curvature < cutoff)debugCurvatureColor = red;
                // curvature /= 2.;
                // curvature = curvature * 0.5 + 0.5;
                debugCurvatureColor = smoothstep(green, red, vec3(curvature - cutoff));
                //debugCurvatureColor = step(red, vec3(curvature - cutoff));
                //debugCurvatureColor = step(green, vec3(curvature - cutoff));
                //gl_FragColor = vec4(vec3(curvature), 1./16.);
            `;
        e2.fragmentShader = ot(e2.fragmentShader, "#include <dithering_fragment>", p2), e2.vertexUvs = true;
      }, onObjectRender: (e2, t2) => {
        var n2, r2, i2, s2, o2, a2, l2;
        const c2 = t2.materialObject.userData;
        if (!(null === (n2 = null == c2 ? void 0 : c2._layeredMaterial) || void 0 === n2 ? void 0 : n2.enable))
          return;
        const u2 = e2;
        u2.isMesh && u2.geometry && (this._uniforms.cutoff.value = null === (r2 = c2._layeredMaterial) || void 0 === r2 ? void 0 : r2.cutoff, this._uniforms.cavityRoughness.value = null === (i2 = c2._layeredMaterial) || void 0 === i2 ? void 0 : i2.cavityRoughness, this._uniforms.cavityMetalness.value = null === (s2 = c2._layeredMaterial) || void 0 === s2 ? void 0 : s2.cavityMetalness, this._uniforms.cavityScale.value = null === (o2 = c2._layeredMaterial) || void 0 === o2 ? void 0 : o2.cavityScale, this._uniforms.stepSize.value = null === (a2 = c2._layeredMaterial) || void 0 === a2 ? void 0 : a2.stepSize, this._uniforms.cavityColor.value.copy(null === (l2 = c2._layeredMaterial) || void 0 === l2 ? void 0 : l2.cavityColor));
      }, extraUniforms: { ...this._uniforms }, computeCacheKey: (e2) => {
        var t2, n2;
        return (this.enabled ? "1" : "0") + ((null === (n2 = null === (t2 = e2.materialObject.userData) || void 0 === t2 ? void 0 : t2._layeredMaterial) || void 0 === n2 ? void 0 : n2.enable) ? "1" : "0");
      }, isCompatible: (e2) => e2.isMeshStandardMaterial2, updaters: () => {
        var e2;
        return [null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.renderer];
      }, getUiConfig: (e2) => {
        const t2 = this._viewer, n2 = this.addLayeredMaterial, r2 = { type: "folder", label: "LayeredMaterial", children: [{ type: "checkbox", label: "Enabled", get value() {
          var t3;
          return (null === (t3 = e2.materialObject.userData._layeredMaterial) || void 0 === t3 ? void 0 : t3.enable) || false;
        }, set value(i2) {
          var s2, o2;
          i2 !== (null === (s2 = e2.materialObject.userData._layeredMaterial) || void 0 === s2 ? void 0 : s2.enable) && (i2 ? n2(e2) || t2.alert("Cannot add Triplanar mapping.") : (e2.materialObject.userData._layeredMaterial.enable = false, e2.materialObject.needsUpdate = true), null === (o2 = r2.uiRefresh) || void 0 === o2 || o2.call(r2, "postFrame", true));
        }, onChange: this.setDirty }, () => ({ type: "slider", bounds: [-1, 1], stepSize: 1e-3, label: "cutoff", hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._layeredMaterial) || void 0 === t3 ? void 0 : t3.enable);
        }, property: [e2.materialObject.userData._layeredMaterial, "cutoff"], onChange: this.setDirty }), () => ({ type: "color", label: "color", hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._layeredMaterial) || void 0 === t3 ? void 0 : t3.enable);
        }, property: [e2.materialObject.userData._layeredMaterial, "cavityColor"], onChange: this.setDirty }), () => ({ type: "slider", bounds: [0, 1], stepSize: 0.01, label: "roughness", hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._layeredMaterial) || void 0 === t3 ? void 0 : t3.enable);
        }, property: [e2.materialObject.userData._layeredMaterial, "cavityRoughness"], onChange: this.setDirty }), () => ({ type: "slider", bounds: [0.1, 20], stepSize: 0.01, label: "Scale", hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._layeredMaterial) || void 0 === t3 ? void 0 : t3.enable);
        }, property: [e2.materialObject.userData._layeredMaterial, "cavityScale"], onChange: this.setDirty }), () => ({ type: "slider", bounds: [0.1, 100], stepSize: 0.01, label: "StepSize", hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._layeredMaterial) || void 0 === t3 ? void 0 : t3.enable);
        }, property: [e2.materialObject.userData._layeredMaterial, "stepSize"], onChange: this.setDirty }), () => ({ type: "slider", bounds: [0, 1], stepSize: 0.01, label: "metalness", hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._layeredMaterial) || void 0 === t3 ? void 0 : t3.enable);
        }, property: [e2.materialObject.userData._layeredMaterial, "cavityMetalness"], onChange: this.setDirty })] };
        return r2;
      } }, this.setDirty = () => {
        var e2;
        null === (e2 = this._viewer) || void 0 === e2 || e2.setDirty();
      }, this._loaderCreate = this._loaderCreate.bind(this);
    }
    async onAdded(e2) {
      var t2, n2, r2, i2, s2;
      await super.onAdded(e2);
      const o2 = e2.getPlugin(Ls);
      null === (t2 = null == o2 ? void 0 : o2.materials) || void 0 === t2 || t2.registerMaterialExtension(this.materialExtension), null === (n2 = null == o2 ? void 0 : o2.importer) || void 0 === n2 || n2.addEventListener("loaderCreate", this._loaderCreate), null === (s2 = null === (i2 = null === (r2 = null == o2 ? void 0 : o2.exporter) || void 0 === r2 ? void 0 : r2.getExporter("gltf", "glb")) || void 0 === i2 ? void 0 : i2.extensions) || void 0 === s2 || s2.push(Hd);
    }
    async onRemove(e2) {
      var t2, n2, r2, i2;
      return null === (n2 = null === (t2 = e2.getPlugin(Ls)) || void 0 === t2 ? void 0 : t2.materials) || void 0 === n2 || n2.unregisterMaterialExtension(this.materialExtension), null === (i2 = null === (r2 = e2.getPlugin(Ls)) || void 0 === r2 ? void 0 : r2.importer) || void 0 === i2 || i2.removeEventListener("loaderCreate", this._loaderCreate), super.onRemove(e2);
    }
  };
  Gd.PluginType = "LayeredMaterialPlugin", Gd.LAYERED_MATERIAL_GLTF_EXTENSION = "WEBGI_materials_layered", zd([Oe("Enabled", (e2) => ({ onChange: e2.setDirty })), ie()], Gd.prototype, "enabled", void 0), Gd = zd([We("Layered Metal")], Gd);
  class Vd {
    constructor(e2) {
      this.parser = e2, this.name = Gd.LAYERED_MATERIAL_GLTF_EXTENSION;
    }
    async extendMaterialParams(e2, t2) {
      const n2 = this.parser.json.materials[e2];
      if (!n2.extensions || !n2.extensions[this.name])
        return Promise.resolve();
      const r2 = n2.extensions[this.name];
      t2.userData || (t2.userData = {});
      const i2 = t2.userData;
      return i2._layeredMaterial || (i2._layeredMaterial = {}), i2._layeredMaterial.enable = true, t2.userData._layeredMaterial = ce(r2, t2.userData._layeredMaterial, false, {}), Promise.resolve();
    }
  }
  const Hd = (e2) => ({ writeMaterial: (t2, n2) => {
    var r2;
    if (!t2.isMeshStandardMaterial || !(null === (r2 = t2.userData._layeredMaterial) || void 0 === r2 ? void 0 : r2.enable))
      return;
    n2.extensions = n2.extensions || {};
    const i2 = le(t2.userData._layeredMaterial, false);
    n2.extensions[Gd.LAYERED_MATERIAL_GLTF_EXTENSION] = i2, e2.extensionsUsed[Gd.LAYERED_MATERIAL_GLTF_EXTENSION] = true;
  } });
  var Qd = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let Wd = class extends gt {
    addClearcoatTint(e2) {
      return qd(e2.materialObject);
    }
    _loaderCreate({ loader: e2 }) {
      e2.isGLTFLoader2 && e2.register((e3) => new Xd(e3));
    }
    constructor() {
      super(), this.enabled = true, this.dependencies = [Ls], this._defines = {}, this._uniforms = { ccTintColor: { value: new n.Ilk() }, ccThickness: { value: 0 }, ccIor: { value: 0 } }, this.materialExtension = { parsFragmentSnippet: (e2, t2) => {
        var n2;
        return this.enabled && (null === (n2 = null == t2 ? void 0 : t2.materialObject.userData._clearcoatTint) || void 0 === n2 ? void 0 : n2.enableTint) && t2.materialObject.clearcoat > 0 ? "\nuniform vec3 ccTintColor;\nuniform float ccThickness;\nuniform float ccIor;\nvec3 clearcoatTint(const in float dotNV, const in float dotNL, const in float clearcoat) {\n    vec3 tint = ( ccThickness > 0. ? 1. - ccTintColor : ccTintColor); // Set thickness < 0 for glow.\n    tint = exp(tint * -(ccThickness * ((dotNL + dotNV) / max(dotNL * dotNV, 1e-3)))); // beer's law\n    return mix(vec3(1.0), tint, clearcoat);\n}\n        " : "";
      }, shaderExtender: (e2, t2, n2) => {
        var r2;
        if (!(this.enabled && (null === (r2 = null == t2 ? void 0 : t2.materialObject.userData._clearcoatTint) || void 0 === r2 ? void 0 : r2.enableTint) && t2.materialObject.clearcoat > 0))
          return;
        const i2 = "outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;", s2 = "float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );";
        e2.fragmentShader.includes(s2) && e2.fragmentShader.includes(i2) || console.error("ClearcoatTintPlugin: shaderExtender cannot patch shader, version changed?"), e2.fragmentShader = e2.fragmentShader.replace(s2, "\n            float dotNVcc = saturate( dot( geometry.clearcoatNormal, -refract(geometry.viewDir, geometry.clearcoatNormal, 1./ccIor) ) );\n            "), e2.fragmentShader = e2.fragmentShader.replace(i2, "\n            outgoingLight *= clearcoatTint(dotNVcc, dotNVcc, material.clearcoat);\n            " + i2), e2.defines.USE_UV = "";
      }, onObjectRender: (e2, t2) => {
        var n2;
        const r2 = null === (n2 = t2.materialObject.userData) || void 0 === n2 ? void 0 : n2._clearcoatTint;
        if (!(null == r2 ? void 0 : r2.enableTint))
          return;
        this._uniforms.ccTintColor.value.set(r2.tintColor), this._uniforms.ccThickness.value = r2.thickness, this._uniforms.ccIor.value = r2.ior;
        const i2 = this.enabled ? 1 : 0;
        t2.materialObject.defines.CLEARCOAT_TINT_ENABLED !== i2 && (t2.materialObject.defines.CLEARCOAT_TINT_ENABLED = i2, t2.materialObject.needsUpdate = true);
      }, extraUniforms: { ...this._uniforms }, computeCacheKey: (e2) => {
        var t2, n2;
        return (this.enabled ? "1" : "0") + ((null === (n2 = null === (t2 = e2.materialObject.userData) || void 0 === t2 ? void 0 : t2._clearcoatTint) || void 0 === n2 ? void 0 : n2.enableTint) ? "1" : "0") + (e2.materialObject.clearcoat > 0 ? "1" : "0");
      }, isCompatible: (e2) => e2.isMeshStandardMaterial2, updaters: () => [], getUiConfig: (e2) => {
        const t2 = this._viewer, n2 = { type: "folder", label: "ClearcoatTint", children: [{ type: "checkbox", label: "Enabled", get value() {
          var t3;
          return (null === (t3 = e2.materialObject.userData._clearcoatTint) || void 0 === t3 ? void 0 : t3.enableTint) || false;
        }, set value(r2) {
          var i2, s2;
          r2 !== (null === (i2 = e2.materialObject.userData._clearcoatTint) || void 0 === i2 ? void 0 : i2.enableTint) && (r2 ? qd(e2.materialObject) || t2.alert("Cannot add clearcoat tint.") : e2.materialObject.userData._clearcoatTint && (e2.materialObject.userData._clearcoatTint.enableTint = false, e2.materialObject.needsUpdate = true), null === (s2 = n2.uiRefresh) || void 0 === s2 || s2.call(n2, "postFrame", true));
        }, onChange: this.setDirty }, () => ({ type: "color", label: "Tint color", hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._clearcoatTint) || void 0 === t3 ? void 0 : t3.enableTint);
        }, property: [e2.materialObject.userData._clearcoatTint, "tintColor"], onChange: this.setDirty }), () => ({ type: "input", label: "Thickness", hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._clearcoatTint) || void 0 === t3 ? void 0 : t3.enableTint);
        }, property: [e2.materialObject.userData._clearcoatTint, "thickness"], onChange: this.setDirty }), () => ({ type: "slider", bounds: [0.8, 2.5], label: "IOR", hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._clearcoatTint) || void 0 === t3 ? void 0 : t3.enableTint);
        }, property: [e2.materialObject.userData._clearcoatTint, "ior"], onChange: this.setDirty })] };
        return n2;
      } }, this.setDirty = () => {
        var e2, t2, n2;
        null === (t2 = (e2 = this.materialExtension).setDirty) || void 0 === t2 || t2.call(e2), null === (n2 = this._viewer) || void 0 === n2 || n2.setDirty();
      }, this._loaderCreate = this._loaderCreate.bind(this);
    }
    async onAdded(e2) {
      var t2, n2, r2, i2, s2;
      await super.onAdded(e2);
      const o2 = e2.getPlugin(Ls);
      null === (t2 = null == o2 ? void 0 : o2.materials) || void 0 === t2 || t2.registerMaterialExtension(this.materialExtension), null === (n2 = null == o2 ? void 0 : o2.importer) || void 0 === n2 || n2.addEventListener("loaderCreate", this._loaderCreate), null === (s2 = null === (i2 = null === (r2 = null == o2 ? void 0 : o2.exporter) || void 0 === r2 ? void 0 : r2.getExporter("gltf", "glb")) || void 0 === i2 ? void 0 : i2.extensions) || void 0 === s2 || s2.push(Yd);
    }
    async onRemove(e2) {
      var t2, n2, r2, i2;
      return null === (n2 = null === (t2 = e2.getPlugin(Ls)) || void 0 === t2 ? void 0 : t2.materials) || void 0 === n2 || n2.unregisterMaterialExtension(this.materialExtension), null === (i2 = null === (r2 = e2.getPlugin(Ls)) || void 0 === r2 ? void 0 : r2.importer) || void 0 === i2 || i2.removeEventListener("loaderCreate", this._loaderCreate), super.onRemove(e2);
    }
  };
  function qd(e2) {
    const t2 = null == e2 ? void 0 : e2.userData;
    if (!t2)
      return false;
    t2._clearcoatTint || (t2._clearcoatTint = {});
    const n2 = t2._clearcoatTint;
    return n2.enableTint = true, void 0 === n2.tintColor && (n2.tintColor = 16777215), void 0 === n2.thickness && (n2.thickness = 0.1), void 0 === n2.ior && (n2.ior = 1.5), e2.isMaterial && (e2.needsUpdate = true), true;
  }
  Wd.PluginType = "ClearcoatTintPlugin", Wd.CLEARCOAT_TINT_GLTF_EXTENSION = "WEBGI_materials_clearcoat_tint", Qd([Oe("Enabled", (e2) => ({ onChange: e2.setDirty })), ie()], Wd.prototype, "enabled", void 0), Wd = Qd([We("ClearcoatTint Materials")], Wd);
  class Xd {
    constructor(e2) {
      this.parser = e2, this.name = Wd.CLEARCOAT_TINT_GLTF_EXTENSION;
    }
    async extendMaterialParams(e2, t2) {
      const n2 = this.parser.json.materials[e2];
      if (!n2.extensions || !n2.extensions[this.name])
        return Promise.resolve();
      const r2 = n2.extensions[this.name];
      return t2.userData || (t2.userData = {}), qd(t2), ce(r2, t2.userData._clearcoatTint, false, {}), Promise.resolve();
    }
  }
  const Yd = (e2) => ({ writeMaterial: (t2, n2) => {
    if (!t2.isMeshStandardMaterial || !t2.userData._clearcoatTint)
      return;
    if (!t2.userData._clearcoatTint.enableTint)
      return;
    n2.extensions = n2.extensions || {};
    const r2 = le(t2.userData._clearcoatTint, false);
    n2.extensions[Wd.CLEARCOAT_TINT_GLTF_EXTENSION] = r2, e2.extensionsUsed[Wd.CLEARCOAT_TINT_GLTF_EXTENSION] = true;
  } });
  class Kd {
    constructor(e2 = 4) {
      this.pool = e2, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0;
    }
    _initWorker(e2) {
      if (!this.workers[e2]) {
        const t2 = this.workerCreator();
        t2.addEventListener("message", this._onMessage.bind(this, e2)), this.workers[e2] = t2;
      }
    }
    _getIdleWorker() {
      for (let e2 = 0; e2 < this.pool; e2++)
        if (!(this.workerStatus & 1 << e2))
          return e2;
      return -1;
    }
    _onMessage(e2, t2) {
      const n2 = this.workersResolve[e2];
      if (n2 && n2(t2), this.queue.length) {
        const { resolve: t3, msg: n3, transfer: r2 } = this.queue.shift();
        this.workersResolve[e2] = t3, this.workers[e2].postMessage(n3, r2);
      } else
        this.workerStatus ^= 1 << e2;
    }
    setWorkerCreator(e2) {
      this.workerCreator = e2;
    }
    setWorkerLimit(e2) {
      this.pool = e2;
    }
    postMessage(e2, t2) {
      return new Promise((n2) => {
        const r2 = this._getIdleWorker();
        -1 !== r2 ? (this._initWorker(r2), this.workerStatus |= 1 << r2, this.workersResolve[r2] = n2, this.workers[r2].postMessage(e2, t2)) : this.queue.push({ resolve: n2, msg: e2, transfer: t2 });
      });
    }
    dispose() {
      this.workers.forEach((e2) => e2.terminate()), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0;
    }
  }
  const Jd = 0, Zd = 2;
  class $d {
    constructor() {
      this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{ vendorId: 0, descriptorType: 0, descriptorBlockSize: 0, versionNumber: 2, colorModel: 0, colorPrimaries: 1, transferFunction: 2, flags: 0, texelBlockDimension: [0, 0, 0, 0], bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0], samples: [] }], this.keyValue = {}, this.globalData = null;
    }
  }
  class eh {
    constructor(e2, t2, n2, r2) {
      this._dataView = new DataView(e2.buffer, e2.byteOffset + t2, n2), this._littleEndian = r2, this._offset = 0;
    }
    _nextUint8() {
      const e2 = this._dataView.getUint8(this._offset);
      return this._offset += 1, e2;
    }
    _nextUint16() {
      const e2 = this._dataView.getUint16(this._offset, this._littleEndian);
      return this._offset += 2, e2;
    }
    _nextUint32() {
      const e2 = this._dataView.getUint32(this._offset, this._littleEndian);
      return this._offset += 4, e2;
    }
    _nextUint64() {
      const e2 = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
      return this._offset += 8, e2;
    }
    _nextInt32() {
      const e2 = this._dataView.getInt32(this._offset, this._littleEndian);
      return this._offset += 4, e2;
    }
    _skip(e2) {
      return this._offset += e2, this;
    }
    _scan(e2, t2 = 0) {
      const n2 = this._offset;
      let r2 = 0;
      for (; this._dataView.getUint8(this._offset) !== t2 && r2 < e2; )
        r2++, this._offset++;
      return r2 < e2 && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n2, r2);
    }
  }
  new Uint8Array([0]);
  const th = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
  function nh(e2) {
    return "undefined" != typeof TextDecoder ? new TextDecoder().decode(e2) : Buffer.from(e2).toString("utf8");
  }
  let rh, ih, sh;
  const oh = { env: { emscripten_notify_memory_growth: function(e2) {
    sh = new Uint8Array(ih.exports.memory.buffer);
  } } };
  class ah {
    init() {
      return rh || (rh = "undefined" != typeof fetch ? fetch("data:application/wasm;base64," + lh).then((e2) => e2.arrayBuffer()).then((e2) => WebAssembly.instantiate(e2, oh)).then(this._init) : WebAssembly.instantiate(Buffer.from(lh, "base64"), oh).then(this._init), rh);
    }
    _init(e2) {
      ih = e2.instance, oh.env.emscripten_notify_memory_growth(0);
    }
    decode(e2, t2 = 0) {
      if (!ih)
        throw new Error("ZSTDDecoder: Await .init() before decoding.");
      const n2 = e2.byteLength, r2 = ih.exports.malloc(n2);
      sh.set(e2, r2), t2 = t2 || Number(ih.exports.ZSTD_findDecompressedSize(r2, n2));
      const i2 = ih.exports.malloc(t2), s2 = ih.exports.ZSTD_decompress(i2, t2, r2, n2), o2 = sh.slice(i2, i2 + s2);
      return ih.exports.free(r2), ih.exports.free(i2), o2;
    }
  }
  const lh = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ", ch = /* @__PURE__ */ new WeakMap();
  let uh, ph = 0;
  class dh extends n.aNw {
    constructor(e2) {
      super(e2), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new Kd(), this.workerSourceURL = "", this.workerConfig = null, "undefined" != typeof MSC_TRANSCODER && console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.');
    }
    setTranscoderPath(e2) {
      return this.transcoderPath = e2, this;
    }
    setWorkerLimit(e2) {
      return this.workerPool.setWorkerLimit(e2), this;
    }
    detectSupport(e2) {
      return true === e2.isWebGPURenderer ? this.workerConfig = { astcSupported: e2.hasFeature("texture-compression-astc"), etc1Supported: false, etc2Supported: e2.hasFeature("texture-compression-etc2"), dxtSupported: e2.hasFeature("texture-compression-bc"), bptcSupported: false, pvrtcSupported: false } : (this.workerConfig = { astcSupported: e2.extensions.has("WEBGL_compressed_texture_astc"), etc1Supported: e2.extensions.has("WEBGL_compressed_texture_etc1"), etc2Supported: e2.extensions.has("WEBGL_compressed_texture_etc"), dxtSupported: e2.extensions.has("WEBGL_compressed_texture_s3tc"), bptcSupported: e2.extensions.has("EXT_texture_compression_bptc"), pvrtcSupported: e2.extensions.has("WEBGL_compressed_texture_pvrtc") || e2.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc") }, e2.capabilities.isWebGL2 && (this.workerConfig.etc1Supported = false)), this;
    }
    init() {
      if (!this.transcoderPending) {
        const e2 = new n.hH6(this.manager);
        e2.setPath(this.transcoderPath), e2.setWithCredentials(this.withCredentials);
        const t2 = e2.loadAsync("basis_transcoder.js"), r2 = new n.hH6(this.manager);
        r2.setPath(this.transcoderPath), r2.setResponseType("arraybuffer"), r2.setWithCredentials(this.withCredentials);
        const i2 = r2.loadAsync("basis_transcoder.wasm");
        this.transcoderPending = Promise.all([t2, i2]).then(([e3, t3]) => {
          const n2 = dh.BasisWorker, r3 = ["/* constants */", "let _EngineFormat = " + JSON.stringify(dh.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(dh.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(dh.BasisFormat), "/* basis_transcoder.js */", e3, "/* worker */", n2.substring(n2.indexOf("{") + 1, n2.lastIndexOf("}"))].join("\n");
          this.workerSourceURL = URL.createObjectURL(new Blob([r3])), this.transcoderBinary = t3, this.workerPool.setWorkerCreator(() => {
            const e4 = new Worker(this.workerSourceURL), t4 = this.transcoderBinary.slice(0);
            return e4.postMessage({ type: "init", config: this.workerConfig, transcoderBinary: t4 }, [t4]), e4;
          });
        }), ph > 0 && console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."), ph++;
      }
      return this.transcoderPending;
    }
    load(e2, t2, r2, i2) {
      if (null === this.workerConfig)
        throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
      const s2 = new n.hH6(this.manager);
      s2.setResponseType("arraybuffer"), s2.setWithCredentials(this.withCredentials), s2.load(e2, (e3) => {
        if (ch.has(e3))
          return ch.get(e3).promise.then(t2).catch(i2);
        this.createTexture(e3).then((e4) => t2 ? t2(e4) : null).catch(i2);
      }, r2, i2);
    }
    _createTextureFrom(e2, t2) {
      const { faces: r2, width: i2, height: s2, format: o2, type: a2, error: l2, dfdTransferFn: c2, dfdFlags: u2 } = e2;
      if ("error" === a2)
        return Promise.reject(l2);
      let p2;
      if (6 === t2.faceCount)
        p2 = new n.EB7(), p2.image = r2, p2.format = o2, p2.type = n.ywz;
      else {
        const e3 = r2[0].mipmaps;
        p2 = t2.layerCount > 1 ? new n.Z_g(e3, i2, s2, t2.layerCount, o2, n.ywz) : new n.EB7(e3, i2, s2, o2, n.ywz);
      }
      return p2.minFilter = 1 === r2[0].mipmaps.length ? n.wem : n.D1R, p2.magFilter = n.wem, p2.generateMipmaps = false, p2.needsUpdate = true, p2.colorSpace = 2 === c2 ? n.KI_ : n.aCh, p2.premultiplyAlpha = !!(1 & u2), p2;
    }
    async createTexture(e2, t2 = {}) {
      const n2 = function(e3) {
        const t3 = new Uint8Array(e3.buffer, e3.byteOffset, th.length);
        if (t3[0] !== th[0] || t3[1] !== th[1] || t3[2] !== th[2] || t3[3] !== th[3] || t3[4] !== th[4] || t3[5] !== th[5] || t3[6] !== th[6] || t3[7] !== th[7] || t3[8] !== th[8] || t3[9] !== th[9] || t3[10] !== th[10] || t3[11] !== th[11])
          throw new Error("Missing KTX 2.0 identifier.");
        const n3 = new $d(), r3 = 17 * Uint32Array.BYTES_PER_ELEMENT, i3 = new eh(e3, th.length, r3, true);
        n3.vkFormat = i3._nextUint32(), n3.typeSize = i3._nextUint32(), n3.pixelWidth = i3._nextUint32(), n3.pixelHeight = i3._nextUint32(), n3.pixelDepth = i3._nextUint32(), n3.layerCount = i3._nextUint32(), n3.faceCount = i3._nextUint32();
        const s2 = i3._nextUint32();
        n3.supercompressionScheme = i3._nextUint32();
        const o2 = i3._nextUint32(), a2 = i3._nextUint32(), l2 = i3._nextUint32(), c2 = i3._nextUint32(), u2 = i3._nextUint64(), p2 = i3._nextUint64(), d2 = new eh(e3, th.length + r3, 3 * s2 * 8, true);
        for (let t4 = 0; t4 < s2; t4++)
          n3.levels.push({ levelData: new Uint8Array(e3.buffer, e3.byteOffset + d2._nextUint64(), d2._nextUint64()), uncompressedByteLength: d2._nextUint64() });
        const h2 = new eh(e3, o2, a2, true), f2 = { vendorId: h2._skip(4)._nextUint16(), descriptorType: h2._nextUint16(), versionNumber: h2._nextUint16(), descriptorBlockSize: h2._nextUint16(), colorModel: h2._nextUint8(), colorPrimaries: h2._nextUint8(), transferFunction: h2._nextUint8(), flags: h2._nextUint8(), texelBlockDimension: [h2._nextUint8(), h2._nextUint8(), h2._nextUint8(), h2._nextUint8()], bytesPlane: [h2._nextUint8(), h2._nextUint8(), h2._nextUint8(), h2._nextUint8(), h2._nextUint8(), h2._nextUint8(), h2._nextUint8(), h2._nextUint8()], samples: [] }, m2 = (f2.descriptorBlockSize / 4 - 6) / 4;
        for (let e4 = 0; e4 < m2; e4++) {
          const t4 = { bitOffset: h2._nextUint16(), bitLength: h2._nextUint8(), channelType: h2._nextUint8(), samplePosition: [h2._nextUint8(), h2._nextUint8(), h2._nextUint8(), h2._nextUint8()], sampleLower: -1 / 0, sampleUpper: 1 / 0 };
          64 & t4.channelType ? (t4.sampleLower = h2._nextInt32(), t4.sampleUpper = h2._nextInt32()) : (t4.sampleLower = h2._nextUint32(), t4.sampleUpper = h2._nextUint32()), f2.samples[e4] = t4;
        }
        n3.dataFormatDescriptor.length = 0, n3.dataFormatDescriptor.push(f2);
        const _2 = new eh(e3, l2, c2, true);
        for (; _2._offset < c2; ) {
          const e4 = _2._nextUint32(), t4 = _2._scan(e4), r4 = nh(t4), i4 = _2._scan(e4 - t4.byteLength);
          n3.keyValue[r4] = r4.match(/^ktx/i) ? nh(i4) : i4, _2._offset % 4 && _2._skip(4 - _2._offset % 4);
        }
        if (p2 <= 0)
          return n3;
        const g2 = new eh(e3, u2, p2, true), v2 = g2._nextUint16(), y2 = g2._nextUint16(), b2 = g2._nextUint32(), w2 = g2._nextUint32(), A2 = g2._nextUint32(), x2 = g2._nextUint32(), E2 = [];
        for (let e4 = 0; e4 < s2; e4++)
          E2.push({ imageFlags: g2._nextUint32(), rgbSliceByteOffset: g2._nextUint32(), rgbSliceByteLength: g2._nextUint32(), alphaSliceByteOffset: g2._nextUint32(), alphaSliceByteLength: g2._nextUint32() });
        const C2 = u2 + g2._offset, S2 = C2 + b2, M2 = S2 + w2, T2 = M2 + A2, P2 = new Uint8Array(e3.buffer, e3.byteOffset + C2, b2), I2 = new Uint8Array(e3.buffer, e3.byteOffset + S2, w2), R2 = new Uint8Array(e3.buffer, e3.byteOffset + M2, A2), k2 = new Uint8Array(e3.buffer, e3.byteOffset + T2, x2);
        return n3.globalData = { endpointCount: v2, selectorCount: y2, imageDescs: E2, endpointsData: P2, selectorsData: I2, tablesData: R2, extendedData: k2 }, n3;
      }(new Uint8Array(e2));
      if (0 !== n2.vkFormat) {
        const e3 = [], t3 = [];
        for (let r4 = 0; r4 < n2.levels.length; r4++)
          t3.push(_h(n2, r4).then(function(t4) {
            e3[r4] = t4;
          }));
        await Promise.all(t3);
        const r3 = e3[0];
        return r3.mipmaps = e3.map((e4) => ({ data: e4.source.data, width: e4.source.data.width, height: e4.source.data.height, depth: e4.source.data.depth })), r3;
      }
      const r2 = t2, i2 = this.init().then(() => this.workerPool.postMessage({ type: "transcode", buffer: e2, taskConfig: r2 }, [e2])).then((e3) => this._createTextureFrom(e3.data, n2));
      return ch.set(e2, { promise: i2 }), i2;
    }
    dispose() {
      return this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), ph--, this;
    }
  }
  dh.BasisFormat = { ETC1S: 0, UASTC_4x4: 1 }, dh.TranscoderFormat = { ETC1: 0, ETC2: 1, BC1: 2, BC3: 3, BC4: 4, BC5: 5, BC7_M6_OPAQUE_ONLY: 6, BC7_M5: 7, PVRTC1_4_RGB: 8, PVRTC1_4_RGBA: 9, ASTC_4x4: 10, ATC_RGB: 11, ATC_RGBA_INTERPOLATED_ALPHA: 12, RGBA32: 13, RGB565: 14, BGR565: 15, RGBA4444: 16 }, dh.EngineFormat = { RGBAFormat: n.wk1, RGBA_ASTC_4x4_Format: n.ptH, RGBA_BPTC_Format: n.bsb, RGBA_ETC2_EAC_Format: n.ekQ, RGBA_PVRTC_4BPPV1_Format: n.eaV, RGBA_S3TC_DXT5_Format: n.ILR, RGB_ETC1_Format: n.fto, RGB_ETC2_Format: n.l0P, RGB_PVRTC_4BPPV1_Format: n._AM, RGB_S3TC_DXT1_Format: n.wuA }, dh.BasisWorker = "function () {\n\n	let config;\n	let transcoderPending;\n	let BasisModule;\n\n	const EngineFormat = _EngineFormat; // eslint-disable-line no-undef\n	const TranscoderFormat = _TranscoderFormat; // eslint-disable-line no-undef\n	const BasisFormat = _BasisFormat; // eslint-disable-line no-undef\n\n	self.addEventListener( 'message', function ( e ) {\n\n		const message = e.data;\n\n		switch ( message.type ) {\n\n			case 'init':\n				config = message.config;\n				init( message.transcoderBinary );\n				break;\n\n			case 'transcode':\n				transcoderPending.then( () => {\n\n					try {\n\n						const { faces, buffers, width, height, hasAlpha, format, dfdTransferFn, dfdFlags } = transcode( message.buffer );\n\n						self.postMessage( { type: 'transcode', id: message.id, faces, width, height, hasAlpha, format, dfdTransferFn, dfdFlags }, buffers );\n\n					} catch ( error ) {\n\n						console.error( error );\n\n						self.postMessage( { type: 'error', id: message.id, error: error.message } );\n\n					}\n\n				} );\n				break;\n\n		}\n\n	} );\n\n	function init( wasmBinary ) {\n\n		transcoderPending = new Promise( ( resolve ) => {\n\n			BasisModule = { wasmBinary, onRuntimeInitialized: resolve };\n			BASIS( BasisModule ); // eslint-disable-line no-undef\n\n		} ).then( () => {\n\n			BasisModule.initializeBasis();\n\n			if ( BasisModule.KTX2File === undefined ) {\n\n				console.warn( 'THREE.KTX2Loader: Please update Basis Universal transcoder.' );\n\n			}\n\n		} );\n\n	}\n\n	function transcode( buffer ) {\n\n		const ktx2File = new BasisModule.KTX2File( new Uint8Array( buffer ) );\n\n		function cleanup() {\n\n			ktx2File.close();\n			ktx2File.delete();\n\n		}\n\n		if ( ! ktx2File.isValid() ) {\n\n			cleanup();\n			throw new Error( 'THREE.KTX2Loader:	Invalid or unsupported .ktx2 file' );\n\n		}\n\n		const basisFormat = ktx2File.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;\n		const width = ktx2File.getWidth();\n		const height = ktx2File.getHeight();\n		const layerCount = ktx2File.getLayers() || 1;\n		const levelCount = ktx2File.getLevels();\n		const faceCount = ktx2File.getFaces();\n		const hasAlpha = ktx2File.getHasAlpha();\n		const dfdTransferFn = ktx2File.getDFDTransferFunc();\n		const dfdFlags = ktx2File.getDFDFlags();\n\n		const { transcoderFormat, engineFormat } = getTranscoderFormat( basisFormat, width, height, hasAlpha );\n\n		if ( ! width || ! height || ! levelCount ) {\n\n			cleanup();\n			throw new Error( 'THREE.KTX2Loader:	Invalid texture' );\n\n		}\n\n		if ( ! ktx2File.startTranscoding() ) {\n\n			cleanup();\n			throw new Error( 'THREE.KTX2Loader: .startTranscoding failed' );\n\n		}\n\n		const faces = [];\n		const buffers = [];\n\n		for ( let face = 0; face < faceCount; face ++ ) {\n\n			const mipmaps = [];\n\n			for ( let mip = 0; mip < levelCount; mip ++ ) {\n\n				const layerMips = [];\n\n				let mipWidth, mipHeight;\n\n				for ( let layer = 0; layer < layerCount; layer ++ ) {\n\n					const levelInfo = ktx2File.getImageLevelInfo( mip, layer, face );\n\n					if ( face === 0 && mip === 0 && layer === 0 && ( levelInfo.origWidth % 4 !== 0 || levelInfo.origHeight % 4 !== 0 ) ) {\n\n						console.warn( 'THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions.' );\n\n					}\n\n					if ( levelCount > 1 ) {\n\n						mipWidth = levelInfo.origWidth;\n						mipHeight = levelInfo.origHeight;\n\n					} else {\n\n						// Handles non-multiple-of-four dimensions in textures without mipmaps. Textures with\n						// mipmaps must use multiple-of-four dimensions, for some texture formats and APIs.\n						// See mrdoob/three.js#25908.\n						mipWidth = levelInfo.width;\n						mipHeight = levelInfo.height;\n\n					}\n\n					const dst = new Uint8Array( ktx2File.getImageTranscodedSizeInBytes( mip, layer, 0, transcoderFormat ) );\n					const status = ktx2File.transcodeImage( dst, mip, layer, face, transcoderFormat, 0, - 1, - 1 );\n\n					if ( ! status ) {\n\n						cleanup();\n						throw new Error( 'THREE.KTX2Loader: .transcodeImage failed.' );\n\n					}\n\n					layerMips.push( dst );\n\n				}\n\n				const mipData = concat( layerMips );\n\n				mipmaps.push( { data: mipData, width: mipWidth, height: mipHeight } );\n				buffers.push( mipData.buffer );\n\n			}\n\n			faces.push( { mipmaps, width, height, format: engineFormat } );\n\n		}\n\n		cleanup();\n\n		return { faces, buffers, width, height, hasAlpha, format: engineFormat, dfdTransferFn, dfdFlags };\n\n	}\n\n	//\n\n	// Optimal choice of a transcoder target format depends on the Basis format (ETC1S or UASTC),\n	// device capabilities, and texture dimensions. The list below ranks the formats separately\n	// for ETC1S and UASTC.\n	//\n	// In some cases, transcoding UASTC to RGBA32 might be preferred for higher quality (at\n	// significant memory cost) compared to ETC1/2, BC1/3, and PVRTC. The transcoder currently\n	// chooses RGBA32 only as a last resort and does not expose that option to the caller.\n	const FORMAT_OPTIONS = [\n		{\n			if: 'astcSupported',\n			basisFormat: [ BasisFormat.UASTC_4x4 ],\n			transcoderFormat: [ TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4 ],\n			engineFormat: [ EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format ],\n			priorityETC1S: Infinity,\n			priorityUASTC: 1,\n			needsPowerOfTwo: false,\n		},\n		{\n			if: 'bptcSupported',\n			basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC_4x4 ],\n			transcoderFormat: [ TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5 ],\n			engineFormat: [ EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format ],\n			priorityETC1S: 3,\n			priorityUASTC: 2,\n			needsPowerOfTwo: false,\n		},\n		{\n			if: 'dxtSupported',\n			basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC_4x4 ],\n			transcoderFormat: [ TranscoderFormat.BC1, TranscoderFormat.BC3 ],\n			engineFormat: [ EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format ],\n			priorityETC1S: 4,\n			priorityUASTC: 5,\n			needsPowerOfTwo: false,\n		},\n		{\n			if: 'etc2Supported',\n			basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC_4x4 ],\n			transcoderFormat: [ TranscoderFormat.ETC1, TranscoderFormat.ETC2 ],\n			engineFormat: [ EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format ],\n			priorityETC1S: 1,\n			priorityUASTC: 3,\n			needsPowerOfTwo: false,\n		},\n		{\n			if: 'etc1Supported',\n			basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC_4x4 ],\n			transcoderFormat: [ TranscoderFormat.ETC1 ],\n			engineFormat: [ EngineFormat.RGB_ETC1_Format ],\n			priorityETC1S: 2,\n			priorityUASTC: 4,\n			needsPowerOfTwo: false,\n		},\n		{\n			if: 'pvrtcSupported',\n			basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC_4x4 ],\n			transcoderFormat: [ TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA ],\n			engineFormat: [ EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format ],\n			priorityETC1S: 5,\n			priorityUASTC: 6,\n			needsPowerOfTwo: true,\n		},\n	];\n\n	const ETC1S_OPTIONS = FORMAT_OPTIONS.sort( function ( a, b ) {\n\n		return a.priorityETC1S - b.priorityETC1S;\n\n	} );\n	const UASTC_OPTIONS = FORMAT_OPTIONS.sort( function ( a, b ) {\n\n		return a.priorityUASTC - b.priorityUASTC;\n\n	} );\n\n	function getTranscoderFormat( basisFormat, width, height, hasAlpha ) {\n\n		let transcoderFormat;\n		let engineFormat;\n\n		const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;\n\n		for ( let i = 0; i < options.length; i ++ ) {\n\n			const opt = options[ i ];\n\n			if ( ! config[ opt.if ] ) continue;\n			if ( ! opt.basisFormat.includes( basisFormat ) ) continue;\n			if ( hasAlpha && opt.transcoderFormat.length < 2 ) continue;\n			if ( opt.needsPowerOfTwo && ! ( isPowerOfTwo( width ) && isPowerOfTwo( height ) ) ) continue;\n\n			transcoderFormat = opt.transcoderFormat[ hasAlpha ? 1 : 0 ];\n			engineFormat = opt.engineFormat[ hasAlpha ? 1 : 0 ];\n\n			return { transcoderFormat, engineFormat };\n\n		}\n\n		console.warn( 'THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32.' );\n\n		transcoderFormat = TranscoderFormat.RGBA32;\n		engineFormat = EngineFormat.RGBAFormat;\n\n		return { transcoderFormat, engineFormat };\n\n	}\n\n	function isPowerOfTwo( value ) {\n\n		if ( value <= 2 ) return true;\n\n		return ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n	}\n\n	/** Concatenates N byte arrays. */\n	function concat( arrays ) {\n\n		if ( arrays.length === 1 ) return arrays[ 0 ];\n\n		let totalByteLength = 0;\n\n		for ( let i = 0; i < arrays.length; i ++ ) {\n\n			const array = arrays[ i ];\n			totalByteLength += array.byteLength;\n\n		}\n\n		const result = new Uint8Array( totalByteLength );\n\n		let byteOffset = 0;\n\n		for ( let i = 0; i < arrays.length; i ++ ) {\n\n			const array = arrays[ i ];\n			result.set( array, byteOffset );\n\n			byteOffset += array.byteLength;\n\n		}\n\n		return result;\n\n	}\n\n}";
  const hh = { 109: n.wk1, 97: n.wk1, 37: n.wk1, 43: n.wk1, 103: n.av9, 83: n.av9, 16: n.av9, 22: n.av9, 100: n.hEm, 76: n.hEm, 15: n.hEm, 9: n.hEm }, fh = { 109: n.VzW, 97: n.cLu, 37: n.ywz, 43: n.ywz, 103: n.VzW, 83: n.cLu, 16: n.ywz, 22: n.ywz, 100: n.VzW, 76: n.cLu, 15: n.ywz, 9: n.ywz }, mh = { 43: n.KI_, 22: n.KI_, 15: n.KI_ };
  async function _h(e2, t2 = 0) {
    const { vkFormat: r2 } = e2, i2 = Math.max(1, e2.pixelWidth >> t2), s2 = Math.max(1, e2.pixelHeight >> t2), o2 = Math.max(1, e2.pixelDepth >> t2);
    if (void 0 === hh[r2])
      throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
    const a2 = e2.levels[t2];
    let l2, c2;
    if (e2.supercompressionScheme === Jd)
      l2 = a2.levelData;
    else {
      if (e2.supercompressionScheme !== Zd)
        throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
      uh || (uh = new Promise(async (e3) => {
        const t3 = new ah();
        await t3.init(), e3(t3);
      })), l2 = (await uh).decode(a2.levelData, a2.uncompressedByteLength);
    }
    c2 = fh[r2] === n.VzW ? new Float32Array(l2.buffer, l2.byteOffset, l2.byteLength / Float32Array.BYTES_PER_ELEMENT) : fh[r2] === n.cLu ? new Uint16Array(l2.buffer, l2.byteOffset, l2.byteLength / Uint16Array.BYTES_PER_ELEMENT) : l2;
    const u2 = 0 === o2 ? new n.IEO(c2, i2, s2) : new n.JUT(c2, i2, s2, o2);
    return u2.type = fh[r2], u2.format = hh[r2], u2.colorSpace = mh[r2] || n.aCh, u2.needsUpdate = true, Promise.resolve(u2);
  }
  const gh = "KHR_texture_basisu";
  class vh extends t.SimpleEventDispatcher {
    constructor() {
      super(...arguments), this.dependencies = [Ls];
    }
    async onAdded(e2) {
      var t2, n2, r2, i2, s2, o2;
      this._importer || (this._importer = new Ft(class extends dh {
        constructor(t3) {
          super(t3), this.setTranscoderPath(vh.TRANSCODER_LIBRARY_PATH).detectSupport(e2.renderer.rendererObject);
        }
        async createTexture(e3, t3) {
          const n3 = new Uint8Array(e3.slice(0)), r3 = await super.createTexture(e3, t3);
          return r3.source._sourceImgBuffer = n3, r3.userData.mimeType = "image/ktx2", r3.toJSON = (e4) => de(r3, e4, r3.name, "image/ktx2"), r3.clone = () => {
            throw new Error("ktx2 texture cloning not supported");
          }, r3;
        }
      }, ["ktx2"], false)), null === (n2 = null === (t2 = e2.getManager()) || void 0 === t2 ? void 0 : t2.importer) || void 0 === n2 || n2.Importers.push(this._importer), null === (o2 = null === (s2 = null === (i2 = null === (r2 = e2.getManager()) || void 0 === r2 ? void 0 : r2.exporter) || void 0 === i2 ? void 0 : i2.getExporter("gltf", "glb")) || void 0 === s2 ? void 0 : s2.extensions) || void 0 === o2 || o2.push(yh);
    }
    async onDispose(e2) {
      this._importer = void 0;
    }
    async onRemove(e2) {
      var t2, n2;
      this._importer && (null === (n2 = null === (t2 = e2.getManager()) || void 0 === t2 ? void 0 : t2.importer) || void 0 === n2 ? void 0 : n2.Importers) && e2.getManager().importer.Importers.splice(e2.getManager().importer.Importers.indexOf(this._importer), 1), this._importer = void 0;
    }
  }
  vh.PluginType = "KTX2LoadPlugin", vh.TRANSCODER_LIBRARY_PATH = "https://cdn.jsdelivr.net/gh/BinomialLLC/basis_universal@master/webgl/transcoder/build/";
  const yh = (e2) => ({ writeTexture: (t2, n2) => {
    if ("image/ktx2" !== t2.userData.mimeType)
      return;
    if (void 0 !== n2.source && null !== n2.source)
      return void console.warn("ktx2 export: source already set");
    const r2 = t2.source._sourceImgBuffer || t2.userData.__sourceBuffer;
    if (!r2)
      return void console.warn("ktx2 export: no source buffer for ktx2");
    n2.extensions = n2.extensions || {};
    const i2 = {}, s2 = new Blob([r2], { type: "image/ktx2" });
    i2.source = e2.processImageBlob(s2, t2), n2.extensions[gh] = i2, e2.extensionsUsed[gh] = true;
  } });
  class bh extends t.SimpleEventDispatcher {
    constructor() {
      super(...arguments), this.dirty = false, this.counters = {}, this._generators = /* @__PURE__ */ new Map(), this._preRender = () => this._showDebug("preRender"), this._postRender = () => this._showDebug("postRender");
    }
    async onAdded(e2) {
      this._viewer = e2, e2.addEventListener("preRender", this._preRender), e2.addEventListener("postFrame", this._postRender);
    }
    addTexture(e2, t2, i2, s2, o2, a2 = "postRender", l2 = false) {
      var c2;
      this._generators.has(a2) || this._generators.set(a2, []), null === (c2 = this._generators.get(a2)) || void 0 === c2 || c2.push({ key: e2, fn: t2, rect: i2 ? [...i2] : void 0, frag: o2 || s2 || l2 ? new n.jyz({ vertexShader: r.vertexShader, uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } }, fragmentShader: null != o2 ? o2 : `
        #include <common>
        #include <packing>
        uniform float opacity;
		uniform ${l2 ? "samplerCube" : "sampler2D"} tDiffuse;
		varying vec2 vUv;
		void main() {
			vec4 texel = ${l2 ? "textureCube( tDiffuse, vec3(cos(vUv.y * PI2) * cos(vUv.x * PI2), sin(vUv.y * PI2), cos(vUv.y * PI2) * sin(vUv.x * PI2)) )" : "texture2D( tDiffuse, vUv )"};
			${null != s2 ? s2 : ""}
			gl_FragColor = opacity * texel;
		}
            ` }) : void 0 });
    }
    removeTexture(e2, t2 = "postRender") {
      var n2, r2;
      this._generators.set(t2, null !== (r2 = null === (n2 = this._generators.get(t2)) || void 0 === n2 ? void 0 : n2.filter((t3) => t3.key !== e2)) && void 0 !== r2 ? r2 : []);
    }
    async onDispose(e2) {
      return Promise.resolve(void 0);
    }
    async onRemove(e2) {
      return e2.removeEventListener("preRender", this._preRender), e2.removeEventListener("postRender", this._postRender), this._viewer = void 0, Promise.resolve(void 0);
    }
    _showDebug(e2) {
      var t2;
      const n2 = this._viewer, r2 = null == n2 ? void 0 : n2.renderer;
      r2 && n2 && (null === (t2 = this._generators.get(e2)) || void 0 === t2 || t2.forEach(({ key: e3, fn: t3, rect: i2, frag: s2 }) => {
        const o2 = t3(n2);
        if (o2) {
          if (o2.image && i2) {
            const e4 = o2.image.width / o2.image.height;
            i2[2] < 1 && i2[3] < 1 && (i2[2] = 200), i2[2] < 1 && (i2[2] = i2[3] * e4), i2[3] < 1 && (i2[3] = i2[2] / e4);
          }
          r2.blit(o2, void 0, { viewport: i2, clear: false, material: s2 });
        }
      }));
    }
  }
  bh.PluginType = "debug";
  class wh extends n.aNw {
    constructor(e2) {
      super(e2);
    }
    load(e2, t2, r2, i2) {
      const s2 = this, o2 = "" === this.path ? n.Zp0.extractUrlBase(e2) : this.path, a2 = new n.hH6(this.manager);
      a2.setPath(this.path), a2.setRequestHeader(this.requestHeader), a2.setWithCredentials(this.withCredentials), a2.load(e2, function(n2) {
        try {
          t2(s2.parse(n2, o2));
        } catch (t3) {
          i2 ? i2(t3) : console.error(t3), s2.manager.itemError(e2);
        }
      }, r2, i2);
    }
    setMaterialOptions(e2) {
      return this.materialOptions = e2, this;
    }
    parse(e2, t2) {
      const n2 = e2.split("\n");
      let r2 = {};
      const i2 = /\s+/, s2 = {};
      for (let e3 = 0; e3 < n2.length; e3++) {
        let t3 = n2[e3];
        if (t3 = t3.trim(), 0 === t3.length || "#" === t3.charAt(0))
          continue;
        const o3 = t3.indexOf(" ");
        let a2 = o3 >= 0 ? t3.substring(0, o3) : t3;
        a2 = a2.toLowerCase();
        let l2 = o3 >= 0 ? t3.substring(o3 + 1) : "";
        if (l2 = l2.trim(), "newmtl" === a2)
          r2 = { name: l2 }, s2[l2] = r2;
        else if ("ka" === a2 || "kd" === a2 || "ks" === a2 || "ke" === a2) {
          const e4 = l2.split(i2, 3);
          r2[a2] = [parseFloat(e4[0]), parseFloat(e4[1]), parseFloat(e4[2])];
        } else
          r2[a2] = l2;
      }
      const o2 = new Ah(this.resourcePath || t2, this.materialOptions);
      return o2.setCrossOrigin(this.crossOrigin), o2.setManager(this.manager), o2.setMaterials(s2), o2;
    }
  }
  class Ah {
    constructor(e2 = "", t2 = {}) {
      this.baseUrl = e2, this.options = t2, this.materialsInfo = {}, this.materials = {}, this.materialsArray = [], this.nameLookup = {}, this.crossOrigin = "anonymous", this.side = void 0 !== this.options.side ? this.options.side : n.Wl3, this.wrap = void 0 !== this.options.wrap ? this.options.wrap : n.rpg;
    }
    setCrossOrigin(e2) {
      return this.crossOrigin = e2, this;
    }
    setManager(e2) {
      this.manager = e2;
    }
    setMaterials(e2) {
      this.materialsInfo = this.convert(e2), this.materials = {}, this.materialsArray = [], this.nameLookup = {};
    }
    convert(e2) {
      if (!this.options)
        return e2;
      const t2 = {};
      for (const n2 in e2) {
        const r2 = e2[n2], i2 = {};
        t2[n2] = i2;
        for (const e3 in r2) {
          let t3 = true, n3 = r2[e3];
          const s2 = e3.toLowerCase();
          switch (s2) {
            case "kd":
            case "ka":
            case "ks":
              this.options && this.options.normalizeRGB && (n3 = [n3[0] / 255, n3[1] / 255, n3[2] / 255]), this.options && this.options.ignoreZeroRGBs && 0 === n3[0] && 0 === n3[1] && 0 === n3[2] && (t3 = false);
          }
          t3 && (i2[s2] = n3);
        }
      }
      return t2;
    }
    async preload() {
      for (const e2 in this.materialsInfo)
        await this.create(e2);
    }
    getIndex(e2) {
      return this.nameLookup[e2];
    }
    async getAsArray() {
      let e2 = 0;
      for (const t2 in this.materialsInfo)
        this.materialsArray[e2] = await this.create(t2), this.nameLookup[t2] = e2, e2++;
      return this.materialsArray;
    }
    async create(e2) {
      return void 0 === this.materials[e2] && await this.createMaterial_(e2), this.materials[e2];
    }
    async createMaterial_(e2) {
      const t2 = this, r2 = this.materialsInfo[e2], i2 = { name: e2, side: this.side };
      async function s2(e3, r3) {
        if (i2[e3])
          return;
        const s3 = t2.getTextureParams(r3, i2);
        return new Promise((r4, o3) => {
          let a3 = false, l2 = () => !a3 && (a3 = true) && r4();
          const c2 = t2.loadTexture((u2 = t2.baseUrl, "string" != typeof (p2 = s3.url) || "" === p2 ? "" : /^https?:\/\//i.test(p2) ? p2 : u2 + p2), void 0, (t3) => {
            i2[e3] = t3, l2();
          }, void 0, l2);
          var u2, p2;
          setTimeout(l2, 50), c2.repeat.copy(s3.scale), c2.offset.copy(s3.offset), c2.wrapS = t2.wrap, c2.wrapT = t2.wrap, "map" !== e3 && "emissiveMap" !== e3 || (c2.colorSpace = n.KI_);
        });
      }
      const o2 = Array.from(Object.keys(r2 || {}));
      let a2 = o2.includes("d") || o2.includes("D");
      for (const e3 of o2) {
        const t3 = r2[e3];
        let o3;
        if ("" !== t3)
          switch (e3.toLowerCase()) {
            case "kd":
              i2.color = new n.Ilk().fromArray(t3).convertSRGBToLinear();
              break;
            case "ks":
              i2.specular = new n.Ilk().fromArray(t3).convertSRGBToLinear();
              break;
            case "ke":
              i2.emissive = new n.Ilk().fromArray(t3).convertSRGBToLinear();
              break;
            case "map_kd":
              await s2("map", t3);
              break;
            case "map_ks":
              await s2("specularMap", t3);
              break;
            case "map_ke":
              await s2("emissiveMap", t3);
              break;
            case "norm":
              await s2("normalMap", t3);
              break;
            case "map_bump":
            case "bump":
              await s2("bumpMap", t3);
              break;
            case "map_d":
              await s2("alphaMap", t3), i2.transparent = true;
              break;
            case "ns":
              i2.shininess = parseFloat(t3);
              break;
            case "d":
              o3 = parseFloat(t3), o3 < 1 && (i2.opacity = o3, i2.transparent = true);
              break;
            case "tr":
              if (a2)
                break;
              o3 = parseFloat(t3), this.options && this.options.invertTrProperty && (o3 = 1 - o3), o3 > 0 && (i2.opacity = 1 - o3, i2.transparent = true);
          }
      }
      return this.materials[e2] = new n.xoR(i2), this.materials[e2];
    }
    getTextureParams(e2, t2) {
      const r2 = { scale: new n.FM8(1, 1), offset: new n.FM8(0, 0) }, i2 = e2.split(/\s+/);
      let s2;
      return s2 = i2.indexOf("-bm"), s2 >= 0 && (t2.bumpScale = parseFloat(i2[s2 + 1]), i2.splice(s2, 2)), s2 = i2.indexOf("-s"), s2 >= 0 && (r2.scale.set(parseFloat(i2[s2 + 1]), parseFloat(i2[s2 + 2])), i2.splice(s2, 4)), s2 = i2.indexOf("-o"), s2 >= 0 && (r2.offset.set(parseFloat(i2[s2 + 1]), parseFloat(i2[s2 + 2])), i2.splice(s2, 4)), r2.url = i2.join(" ").trim(), r2;
    }
    loadTexture(e2, t2, r2, i2, s2) {
      const o2 = void 0 !== this.manager ? this.manager : n.tEQ;
      let a2 = o2.getHandler(e2);
      null === a2 && (a2 = new n.dpR(o2)), a2.setCrossOrigin && a2.setCrossOrigin(this.crossOrigin);
      const l2 = a2.load(e2, r2, i2, s2);
      return void 0 !== t2 && (l2.mapping = t2), l2;
    }
  }
  const xh = /^[og]\s*(.+)?/, Eh = /^mtllib /, Ch = /^usemtl /, Sh = /^usemap /, Mh = /\s+/, Th = new n.Pa4(), Ph = new n.Pa4(), Ih = new n.Pa4(), Rh = new n.Pa4(), kh = new n.Pa4(), Dh = new n.Ilk();
  function Bh() {
    const e2 = { objects: [], object: {}, vertices: [], normals: [], colors: [], uvs: [], materials: {}, materialLibraries: [], startObject: function(e3, t2) {
      if (this.object && false === this.object.fromDeclaration)
        return this.object.name = e3, void (this.object.fromDeclaration = false !== t2);
      const n2 = this.object && "function" == typeof this.object.currentMaterial ? this.object.currentMaterial() : void 0;
      if (this.object && "function" == typeof this.object._finalize && this.object._finalize(true), this.object = { name: e3 || "", fromDeclaration: false !== t2, geometry: { vertices: [], normals: [], colors: [], uvs: [], hasUVIndices: false }, materials: [], smooth: true, startMaterial: function(e4, t3) {
        const n3 = this._finalize(false);
        n3 && (n3.inherited || n3.groupCount <= 0) && this.materials.splice(n3.index, 1);
        const r2 = { index: this.materials.length, name: e4 || "", mtllib: Array.isArray(t3) && t3.length > 0 ? t3[t3.length - 1] : "", smooth: void 0 !== n3 ? n3.smooth : this.smooth, groupStart: void 0 !== n3 ? n3.groupEnd : 0, groupEnd: -1, groupCount: -1, inherited: false, clone: function(e5) {
          const t4 = { index: "number" == typeof e5 ? e5 : this.index, name: this.name, mtllib: this.mtllib, smooth: this.smooth, groupStart: 0, groupEnd: -1, groupCount: -1, inherited: false };
          return t4.clone = this.clone.bind(t4), t4;
        } };
        return this.materials.push(r2), r2;
      }, currentMaterial: function() {
        if (this.materials.length > 0)
          return this.materials[this.materials.length - 1];
      }, _finalize: function(e4) {
        const t3 = this.currentMaterial();
        if (t3 && -1 === t3.groupEnd && (t3.groupEnd = this.geometry.vertices.length / 3, t3.groupCount = t3.groupEnd - t3.groupStart, t3.inherited = false), e4 && this.materials.length > 1)
          for (let e5 = this.materials.length - 1; e5 >= 0; e5--)
            this.materials[e5].groupCount <= 0 && this.materials.splice(e5, 1);
        return e4 && 0 === this.materials.length && this.materials.push({ name: "", smooth: this.smooth }), t3;
      } }, n2 && n2.name && "function" == typeof n2.clone) {
        const e4 = n2.clone(0);
        e4.inherited = true, this.object.materials.push(e4);
      }
      this.objects.push(this.object);
    }, finalize: function() {
      this.object && "function" == typeof this.object._finalize && this.object._finalize(true);
    }, parseVertexIndex: function(e3, t2) {
      const n2 = parseInt(e3, 10);
      return 3 * (n2 >= 0 ? n2 - 1 : n2 + t2 / 3);
    }, parseNormalIndex: function(e3, t2) {
      const n2 = parseInt(e3, 10);
      return 3 * (n2 >= 0 ? n2 - 1 : n2 + t2 / 3);
    }, parseUVIndex: function(e3, t2) {
      const n2 = parseInt(e3, 10);
      return 2 * (n2 >= 0 ? n2 - 1 : n2 + t2 / 2);
    }, addVertex: function(e3, t2, n2) {
      const r2 = this.vertices, i2 = this.object.geometry.vertices;
      i2.push(r2[e3 + 0], r2[e3 + 1], r2[e3 + 2]), i2.push(r2[t2 + 0], r2[t2 + 1], r2[t2 + 2]), i2.push(r2[n2 + 0], r2[n2 + 1], r2[n2 + 2]);
    }, addVertexPoint: function(e3) {
      const t2 = this.vertices;
      this.object.geometry.vertices.push(t2[e3 + 0], t2[e3 + 1], t2[e3 + 2]);
    }, addVertexLine: function(e3) {
      const t2 = this.vertices;
      this.object.geometry.vertices.push(t2[e3 + 0], t2[e3 + 1], t2[e3 + 2]);
    }, addNormal: function(e3, t2, n2) {
      const r2 = this.normals, i2 = this.object.geometry.normals;
      i2.push(r2[e3 + 0], r2[e3 + 1], r2[e3 + 2]), i2.push(r2[t2 + 0], r2[t2 + 1], r2[t2 + 2]), i2.push(r2[n2 + 0], r2[n2 + 1], r2[n2 + 2]);
    }, addFaceNormal: function(e3, t2, n2) {
      const r2 = this.vertices, i2 = this.object.geometry.normals;
      Th.fromArray(r2, e3), Ph.fromArray(r2, t2), Ih.fromArray(r2, n2), kh.subVectors(Ih, Ph), Rh.subVectors(Th, Ph), kh.cross(Rh), kh.normalize(), i2.push(kh.x, kh.y, kh.z), i2.push(kh.x, kh.y, kh.z), i2.push(kh.x, kh.y, kh.z);
    }, addColor: function(e3, t2, n2) {
      const r2 = this.colors, i2 = this.object.geometry.colors;
      void 0 !== r2[e3] && i2.push(r2[e3 + 0], r2[e3 + 1], r2[e3 + 2]), void 0 !== r2[t2] && i2.push(r2[t2 + 0], r2[t2 + 1], r2[t2 + 2]), void 0 !== r2[n2] && i2.push(r2[n2 + 0], r2[n2 + 1], r2[n2 + 2]);
    }, addUV: function(e3, t2, n2) {
      const r2 = this.uvs, i2 = this.object.geometry.uvs;
      i2.push(r2[e3 + 0], r2[e3 + 1]), i2.push(r2[t2 + 0], r2[t2 + 1]), i2.push(r2[n2 + 0], r2[n2 + 1]);
    }, addDefaultUV: function() {
      const e3 = this.object.geometry.uvs;
      e3.push(0, 0), e3.push(0, 0), e3.push(0, 0);
    }, addUVLine: function(e3) {
      const t2 = this.uvs;
      this.object.geometry.uvs.push(t2[e3 + 0], t2[e3 + 1]);
    }, addFace: function(e3, t2, n2, r2, i2, s2, o2, a2, l2) {
      const c2 = this.vertices.length;
      let u2 = this.parseVertexIndex(e3, c2), p2 = this.parseVertexIndex(t2, c2), d2 = this.parseVertexIndex(n2, c2);
      if (this.addVertex(u2, p2, d2), this.addColor(u2, p2, d2), void 0 !== o2 && "" !== o2) {
        const e4 = this.normals.length;
        u2 = this.parseNormalIndex(o2, e4), p2 = this.parseNormalIndex(a2, e4), d2 = this.parseNormalIndex(l2, e4), this.addNormal(u2, p2, d2);
      } else
        this.addFaceNormal(u2, p2, d2);
      if (void 0 !== r2 && "" !== r2) {
        const e4 = this.uvs.length;
        u2 = this.parseUVIndex(r2, e4), p2 = this.parseUVIndex(i2, e4), d2 = this.parseUVIndex(s2, e4), this.addUV(u2, p2, d2), this.object.geometry.hasUVIndices = true;
      } else
        this.addDefaultUV();
    }, addPointGeometry: function(e3) {
      this.object.geometry.type = "Points";
      const t2 = this.vertices.length;
      for (let n2 = 0, r2 = e3.length; n2 < r2; n2++) {
        const r3 = this.parseVertexIndex(e3[n2], t2);
        this.addVertexPoint(r3), this.addColor(r3);
      }
    }, addLineGeometry: function(e3, t2) {
      this.object.geometry.type = "Line";
      const n2 = this.vertices.length, r2 = this.uvs.length;
      for (let t3 = 0, r3 = e3.length; t3 < r3; t3++)
        this.addVertexLine(this.parseVertexIndex(e3[t3], n2));
      for (let e4 = 0, n3 = t2.length; e4 < n3; e4++)
        this.addUVLine(this.parseUVIndex(t2[e4], r2));
    } };
    return e2.startObject("", false), e2;
  }
  class Oh extends n.aNw {
    constructor(e2) {
      super(e2), this.materials = null;
    }
    load(e2, t2, r2, i2) {
      const s2 = this, o2 = new n.hH6(this.manager);
      o2.setPath(this.path), o2.setRequestHeader(this.requestHeader), o2.setWithCredentials(this.withCredentials), o2.load(e2, async function(n2) {
        try {
          t2(await s2.parse(n2));
        } catch (t3) {
          i2 ? i2(t3) : console.error(t3), s2.manager.itemError(e2);
        }
      }, r2, i2);
    }
    setMaterials(e2) {
      return this.materials = e2, this;
    }
    async parse(e2) {
      const t2 = new Bh();
      -1 !== e2.indexOf("\r\n") && (e2 = e2.replace(/\r\n/g, "\n")), -1 !== e2.indexOf("\\\n") && (e2 = e2.replace(/\\\n/g, ""));
      const r2 = e2.split("\n");
      let i2 = [];
      for (let e3 = 0, n2 = r2.length; e3 < n2; e3++) {
        const n3 = r2[e3].trimStart();
        if (0 === n3.length)
          continue;
        const s3 = n3.charAt(0);
        if ("#" !== s3)
          if ("v" === s3) {
            const e4 = n3.split(Mh);
            switch (e4[0]) {
              case "v":
                t2.vertices.push(parseFloat(e4[1]), parseFloat(e4[2]), parseFloat(e4[3])), e4.length >= 7 ? (Dh.setRGB(parseFloat(e4[4]), parseFloat(e4[5]), parseFloat(e4[6])).convertSRGBToLinear(), t2.colors.push(Dh.r, Dh.g, Dh.b)) : t2.colors.push(void 0, void 0, void 0);
                break;
              case "vn":
                t2.normals.push(parseFloat(e4[1]), parseFloat(e4[2]), parseFloat(e4[3]));
                break;
              case "vt":
                t2.uvs.push(parseFloat(e4[1]), parseFloat(e4[2]));
            }
          } else if ("f" === s3) {
            const e4 = n3.slice(1).trim().split(Mh), r3 = [];
            for (let t3 = 0, n4 = e4.length; t3 < n4; t3++) {
              const n5 = e4[t3];
              if (n5.length > 0) {
                const e5 = n5.split("/");
                r3.push(e5);
              }
            }
            const i3 = r3[0];
            for (let e5 = 1, n4 = r3.length - 1; e5 < n4; e5++) {
              const n5 = r3[e5], s4 = r3[e5 + 1];
              t2.addFace(i3[0], n5[0], s4[0], i3[1], n5[1], s4[1], i3[2], n5[2], s4[2]);
            }
          } else if ("l" === s3) {
            const e4 = n3.substring(1).trim().split(" ");
            let r3 = [];
            const i3 = [];
            if (-1 === n3.indexOf("/"))
              r3 = e4;
            else
              for (let t3 = 0, n4 = e4.length; t3 < n4; t3++) {
                const n5 = e4[t3].split("/");
                "" !== n5[0] && r3.push(n5[0]), "" !== n5[1] && i3.push(n5[1]);
              }
            t2.addLineGeometry(r3, i3);
          } else if ("p" === s3) {
            const e4 = n3.slice(1).trim().split(" ");
            t2.addPointGeometry(e4);
          } else if (null !== (i2 = xh.exec(n3))) {
            const e4 = (" " + i2[0].slice(1).trim()).slice(1);
            t2.startObject(e4);
          } else if (Ch.test(n3))
            t2.object.startMaterial(n3.substring(7).trim(), t2.materialLibraries);
          else if (Eh.test(n3)) {
            t2.materialLibraries.push(n3.substring(7).trim());
            const e4 = n3.substring(7).trim(), r3 = this.manager.getHandler(e4);
            if (r3) {
              const t3 = await r3.loadAsync(e4).catch((e5) => {
                console.warn(e5);
              });
              t3 && this.setMaterials(t3);
            } else
              console.warn("OBJLoader2: Set MTLLoader to loading manager to load materials.");
          } else if (Sh.test(n3))
            console.warn('OBJLoader2: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
          else if ("s" === s3) {
            if (i2 = n3.split(" "), i2.length > 1) {
              const e5 = i2[1].trim().toLowerCase();
              t2.object.smooth = "0" !== e5 && "off" !== e5;
            } else
              t2.object.smooth = true;
            const e4 = t2.object.currentMaterial();
            e4 && (e4.smooth = t2.object.smooth);
          } else {
            if ("\0" === n3)
              continue;
            console.warn('THREE.OBJLoader: Unexpected line: "' + n3 + '"');
          }
      }
      t2.finalize();
      const s2 = new n.ZAu();
      if (s2.materialLibraries = [].concat(t2.materialLibraries), true == !(1 === t2.objects.length && 0 === t2.objects[0].geometry.vertices.length))
        for (let e3 = 0, r3 = t2.objects.length; e3 < r3; e3++) {
          const r4 = t2.objects[e3], i3 = r4.geometry, o2 = r4.materials, a2 = "Line" === i3.type, l2 = "Points" === i3.type;
          let c2 = false;
          if (0 === i3.vertices.length)
            continue;
          const u2 = new n.u9r();
          u2.setAttribute("position", new n.a$l(i3.vertices, 3)), i3.normals.length > 0 && u2.setAttribute("normal", new n.a$l(i3.normals, 3)), i3.colors.length > 0 && (c2 = true, u2.setAttribute("color", new n.a$l(i3.colors, 3))), true === i3.hasUVIndices && u2.setAttribute("uv", new n.a$l(i3.uvs, 2));
          const p2 = [];
          for (let e4 = 0, r5 = o2.length; e4 < r5; e4++) {
            const r6 = o2[e4], i4 = r6.name + "_" + r6.smooth + "_" + c2;
            let s3 = t2.materials[i4];
            if (null !== this.materials)
              if (s3 = await this.materials.create(r6.name), !a2 || !s3 || s3 instanceof n.nls) {
                if (l2 && s3 && !(s3 instanceof n.UY4)) {
                  const e5 = new n.UY4({ size: 10, sizeAttenuation: false });
                  n.F5T.prototype.copy.call(e5, s3), e5.color.copy(s3.color), e5.map = s3.map, s3 = e5;
                }
              } else {
                const e5 = new n.nls();
                n.F5T.prototype.copy.call(e5, s3), e5.color.copy(s3.color), s3 = e5;
              }
            void 0 === s3 && (s3 = a2 ? new n.nls() : l2 ? new n.UY4({ size: 1, sizeAttenuation: false }) : new n.xoR(), s3.name = r6.name, s3.flatShading = !r6.smooth, s3.vertexColors = c2, t2.materials[i4] = s3), p2.push(s3);
          }
          let d2;
          if (p2.length > 1) {
            for (let e4 = 0, t3 = o2.length; e4 < t3; e4++) {
              const t4 = o2[e4];
              u2.addGroup(t4.groupStart, t4.groupCount, e4);
            }
            d2 = a2 ? new n.ejS(u2, p2) : l2 ? new n.woe(u2, p2) : new n.Kj0(u2, p2);
          } else
            d2 = a2 ? new n.ejS(u2, p2[0]) : l2 ? new n.woe(u2, p2[0]) : new n.Kj0(u2, p2[0]);
          d2.name = r4.name, s2.add(d2);
        }
      else if (t2.vertices.length > 0) {
        const e3 = new n.UY4({ size: 1, sizeAttenuation: false }), r3 = new n.u9r();
        r3.setAttribute("position", new n.a$l(t2.vertices, 3)), t2.colors.length > 0 && void 0 !== t2.colors[0] && (r3.setAttribute("color", new n.a$l(t2.colors, 3)), e3.vertexColors = true);
        const i3 = new n.woe(r3, e3);
        s2.add(i3);
      }
      return s2;
    }
  }
  class Lh extends t.SimpleEventDispatcher {
    constructor() {
      super(...arguments), this.dependencies = [Ls], this._importer1 = new Ft(Oh, ["obj"], true), this._importer2 = new Ft(wh, ["mtl"], false);
    }
    async onAdded(e2) {
      var t2, n2, r2, i2;
      null === (n2 = null === (t2 = e2.getManager()) || void 0 === t2 ? void 0 : t2.importer) || void 0 === n2 || n2.Importers.push(this._importer1), null === (i2 = null === (r2 = e2.getManager()) || void 0 === r2 ? void 0 : r2.importer) || void 0 === i2 || i2.Importers.push(this._importer2);
    }
    async onDispose(e2) {
    }
    async onRemove(e2) {
      var t2, n2;
      (null === (n2 = null === (t2 = e2.getManager()) || void 0 === t2 ? void 0 : t2.importer) || void 0 === n2 ? void 0 : n2.Importers) && (e2.getManager().importer.Importers.splice(e2.getManager().importer.Importers.indexOf(this._importer1), 1), e2.getManager().importer.Importers.splice(e2.getManager().importer.Importers.indexOf(this._importer2), 1));
    }
  }
  Lh.PluginType = "ObjMtlLoadPlugin";
  var Uh = function(e2) {
    return URL.createObjectURL(new Blob([e2], { type: "text/javascript" }));
  };
  try {
    URL.revokeObjectURL(Uh(""));
  } catch (fl2) {
    Uh = function(e2) {
      return "data:application/javascript;charset=UTF-8," + encodeURI(e2);
    };
  }
  var Fh = Uint8Array, Nh = Uint16Array, jh = Uint32Array, zh = new Fh([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), Gh = new Fh([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), Vh = new Fh([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Hh = function(e2, t2) {
    for (var n2 = new Nh(31), r2 = 0; r2 < 31; ++r2)
      n2[r2] = t2 += 1 << e2[r2 - 1];
    var i2 = new jh(n2[30]);
    for (r2 = 1; r2 < 30; ++r2)
      for (var s2 = n2[r2]; s2 < n2[r2 + 1]; ++s2)
        i2[s2] = s2 - n2[r2] << 5 | r2;
    return [n2, i2];
  }, Qh = Hh(zh, 2), Wh = Qh[0], qh = Qh[1];
  Wh[28] = 258, qh[258] = 28;
  for (var Xh = Hh(Gh, 0), Yh = Xh[0], Kh = Xh[1], Jh = new Nh(32768), Zh = 0; Zh < 32768; ++Zh) {
    var $h = (43690 & Zh) >>> 1 | (21845 & Zh) << 1;
    $h = (61680 & ($h = (52428 & $h) >>> 2 | (13107 & $h) << 2)) >>> 4 | (3855 & $h) << 4, Jh[Zh] = ((65280 & $h) >>> 8 | (255 & $h) << 8) >>> 1;
  }
  var ef = function(e2, t2, n2) {
    for (var r2 = e2.length, i2 = 0, s2 = new Nh(t2); i2 < r2; ++i2)
      ++s2[e2[i2] - 1];
    var o2, a2 = new Nh(t2);
    for (i2 = 0; i2 < t2; ++i2)
      a2[i2] = a2[i2 - 1] + s2[i2 - 1] << 1;
    if (n2) {
      o2 = new Nh(1 << t2);
      var l2 = 15 - t2;
      for (i2 = 0; i2 < r2; ++i2)
        if (e2[i2])
          for (var c2 = i2 << 4 | e2[i2], u2 = t2 - e2[i2], p2 = a2[e2[i2] - 1]++ << u2, d2 = p2 | (1 << u2) - 1; p2 <= d2; ++p2)
            o2[Jh[p2] >>> l2] = c2;
    } else
      for (o2 = new Nh(r2), i2 = 0; i2 < r2; ++i2)
        e2[i2] && (o2[i2] = Jh[a2[e2[i2] - 1]++] >>> 15 - e2[i2]);
    return o2;
  }, tf = new Fh(288);
  for (Zh = 0; Zh < 144; ++Zh)
    tf[Zh] = 8;
  for (Zh = 144; Zh < 256; ++Zh)
    tf[Zh] = 9;
  for (Zh = 256; Zh < 280; ++Zh)
    tf[Zh] = 7;
  for (Zh = 280; Zh < 288; ++Zh)
    tf[Zh] = 8;
  var nf = new Fh(32);
  for (Zh = 0; Zh < 32; ++Zh)
    nf[Zh] = 5;
  var rf = ef(tf, 9, 0), sf = ef(tf, 9, 1), of = ef(nf, 5, 0), af = ef(nf, 5, 1), lf = function(e2) {
    for (var t2 = e2[0], n2 = 1; n2 < e2.length; ++n2)
      e2[n2] > t2 && (t2 = e2[n2]);
    return t2;
  }, cf = function(e2, t2, n2) {
    var r2 = t2 / 8 | 0;
    return (e2[r2] | e2[r2 + 1] << 8) >> (7 & t2) & n2;
  }, uf = function(e2, t2) {
    var n2 = t2 / 8 | 0;
    return (e2[n2] | e2[n2 + 1] << 8 | e2[n2 + 2] << 16) >> (7 & t2);
  }, pf = function(e2) {
    return (e2 / 8 | 0) + (7 & e2 && 1);
  }, df = function(e2, t2, n2) {
    (null == t2 || t2 < 0) && (t2 = 0), (null == n2 || n2 > e2.length) && (n2 = e2.length);
    var r2 = new (e2 instanceof Nh ? Nh : e2 instanceof jh ? jh : Fh)(n2 - t2);
    return r2.set(e2.subarray(t2, n2)), r2;
  }, hf = function(e2, t2, n2) {
    var r2 = e2.length;
    if (!r2 || n2 && !n2.l && r2 < 5)
      return t2 || new Fh(0);
    var i2 = !t2 || n2, s2 = !n2 || n2.i;
    n2 || (n2 = {}), t2 || (t2 = new Fh(3 * r2));
    var o2 = function(e3) {
      var n3 = t2.length;
      if (e3 > n3) {
        var r3 = new Fh(Math.max(2 * n3, e3));
        r3.set(t2), t2 = r3;
      }
    }, a2 = n2.f || 0, l2 = n2.p || 0, c2 = n2.b || 0, u2 = n2.l, p2 = n2.d, d2 = n2.m, h2 = n2.n, f2 = 8 * r2;
    do {
      if (!u2) {
        n2.f = a2 = cf(e2, l2, 1);
        var m2 = cf(e2, l2 + 1, 3);
        if (l2 += 3, !m2) {
          var _2 = e2[(M2 = pf(l2) + 4) - 4] | e2[M2 - 3] << 8, g2 = M2 + _2;
          if (g2 > r2) {
            if (s2)
              throw "unexpected EOF";
            break;
          }
          i2 && o2(c2 + _2), t2.set(e2.subarray(M2, g2), c2), n2.b = c2 += _2, n2.p = l2 = 8 * g2;
          continue;
        }
        if (1 == m2)
          u2 = sf, p2 = af, d2 = 9, h2 = 5;
        else {
          if (2 != m2)
            throw "invalid block type";
          var v2 = cf(e2, l2, 31) + 257, y2 = cf(e2, l2 + 10, 15) + 4, b2 = v2 + cf(e2, l2 + 5, 31) + 1;
          l2 += 14;
          for (var w2 = new Fh(b2), A2 = new Fh(19), x2 = 0; x2 < y2; ++x2)
            A2[Vh[x2]] = cf(e2, l2 + 3 * x2, 7);
          l2 += 3 * y2;
          var E2 = lf(A2), C2 = (1 << E2) - 1, S2 = ef(A2, E2, 1);
          for (x2 = 0; x2 < b2; ) {
            var M2, T2 = S2[cf(e2, l2, C2)];
            if (l2 += 15 & T2, (M2 = T2 >>> 4) < 16)
              w2[x2++] = M2;
            else {
              var P2 = 0, I2 = 0;
              for (16 == M2 ? (I2 = 3 + cf(e2, l2, 3), l2 += 2, P2 = w2[x2 - 1]) : 17 == M2 ? (I2 = 3 + cf(e2, l2, 7), l2 += 3) : 18 == M2 && (I2 = 11 + cf(e2, l2, 127), l2 += 7); I2--; )
                w2[x2++] = P2;
            }
          }
          var R2 = w2.subarray(0, v2), k2 = w2.subarray(v2);
          d2 = lf(R2), h2 = lf(k2), u2 = ef(R2, d2, 1), p2 = ef(k2, h2, 1);
        }
        if (l2 > f2) {
          if (s2)
            throw "unexpected EOF";
          break;
        }
      }
      i2 && o2(c2 + 131072);
      for (var D2 = (1 << d2) - 1, B2 = (1 << h2) - 1, O2 = l2; ; O2 = l2) {
        var L2 = (P2 = u2[uf(e2, l2) & D2]) >>> 4;
        if ((l2 += 15 & P2) > f2) {
          if (s2)
            throw "unexpected EOF";
          break;
        }
        if (!P2)
          throw "invalid length/literal";
        if (L2 < 256)
          t2[c2++] = L2;
        else {
          if (256 == L2) {
            O2 = l2, u2 = null;
            break;
          }
          var U2 = L2 - 254;
          if (L2 > 264) {
            var F2 = zh[x2 = L2 - 257];
            U2 = cf(e2, l2, (1 << F2) - 1) + Wh[x2], l2 += F2;
          }
          var N2 = p2[uf(e2, l2) & B2], j2 = N2 >>> 4;
          if (!N2)
            throw "invalid distance";
          if (l2 += 15 & N2, k2 = Yh[j2], j2 > 3 && (F2 = Gh[j2], k2 += uf(e2, l2) & (1 << F2) - 1, l2 += F2), l2 > f2) {
            if (s2)
              throw "unexpected EOF";
            break;
          }
          i2 && o2(c2 + 131072);
          for (var z2 = c2 + U2; c2 < z2; c2 += 4)
            t2[c2] = t2[c2 - k2], t2[c2 + 1] = t2[c2 + 1 - k2], t2[c2 + 2] = t2[c2 + 2 - k2], t2[c2 + 3] = t2[c2 + 3 - k2];
          c2 = z2;
        }
      }
      n2.l = u2, n2.p = O2, n2.b = c2, u2 && (a2 = 1, n2.m = d2, n2.d = p2, n2.n = h2);
    } while (!a2);
    return c2 == t2.length ? t2 : df(t2, 0, c2);
  }, ff = function(e2, t2, n2) {
    n2 <<= 7 & t2;
    var r2 = t2 / 8 | 0;
    e2[r2] |= n2, e2[r2 + 1] |= n2 >>> 8;
  }, mf = function(e2, t2, n2) {
    n2 <<= 7 & t2;
    var r2 = t2 / 8 | 0;
    e2[r2] |= n2, e2[r2 + 1] |= n2 >>> 8, e2[r2 + 2] |= n2 >>> 16;
  }, _f = function(e2, t2) {
    for (var n2 = [], r2 = 0; r2 < e2.length; ++r2)
      e2[r2] && n2.push({ s: r2, f: e2[r2] });
    var i2 = n2.length, s2 = n2.slice();
    if (!i2)
      return [xf, 0];
    if (1 == i2) {
      var o2 = new Fh(n2[0].s + 1);
      return o2[n2[0].s] = 1, [o2, 1];
    }
    n2.sort(function(e3, t3) {
      return e3.f - t3.f;
    }), n2.push({ s: -1, f: 25001 });
    var a2 = n2[0], l2 = n2[1], c2 = 0, u2 = 1, p2 = 2;
    for (n2[0] = { s: -1, f: a2.f + l2.f, l: a2, r: l2 }; u2 != i2 - 1; )
      a2 = n2[n2[c2].f < n2[p2].f ? c2++ : p2++], l2 = n2[c2 != u2 && n2[c2].f < n2[p2].f ? c2++ : p2++], n2[u2++] = { s: -1, f: a2.f + l2.f, l: a2, r: l2 };
    var d2 = s2[0].s;
    for (r2 = 1; r2 < i2; ++r2)
      s2[r2].s > d2 && (d2 = s2[r2].s);
    var h2 = new Nh(d2 + 1), f2 = gf(n2[u2 - 1], h2, 0);
    if (f2 > t2) {
      r2 = 0;
      var m2 = 0, _2 = f2 - t2, g2 = 1 << _2;
      for (s2.sort(function(e3, t3) {
        return h2[t3.s] - h2[e3.s] || e3.f - t3.f;
      }); r2 < i2; ++r2) {
        var v2 = s2[r2].s;
        if (!(h2[v2] > t2))
          break;
        m2 += g2 - (1 << f2 - h2[v2]), h2[v2] = t2;
      }
      for (m2 >>>= _2; m2 > 0; ) {
        var y2 = s2[r2].s;
        h2[y2] < t2 ? m2 -= 1 << t2 - h2[y2]++ - 1 : ++r2;
      }
      for (; r2 >= 0 && m2; --r2) {
        var b2 = s2[r2].s;
        h2[b2] == t2 && (--h2[b2], ++m2);
      }
      f2 = t2;
    }
    return [new Fh(h2), f2];
  }, gf = function(e2, t2, n2) {
    return -1 == e2.s ? Math.max(gf(e2.l, t2, n2 + 1), gf(e2.r, t2, n2 + 1)) : t2[e2.s] = n2;
  }, vf = function(e2) {
    for (var t2 = e2.length; t2 && !e2[--t2]; )
      ;
    for (var n2 = new Nh(++t2), r2 = 0, i2 = e2[0], s2 = 1, o2 = function(e3) {
      n2[r2++] = e3;
    }, a2 = 1; a2 <= t2; ++a2)
      if (e2[a2] == i2 && a2 != t2)
        ++s2;
      else {
        if (!i2 && s2 > 2) {
          for (; s2 > 138; s2 -= 138)
            o2(32754);
          s2 > 2 && (o2(s2 > 10 ? s2 - 11 << 5 | 28690 : s2 - 3 << 5 | 12305), s2 = 0);
        } else if (s2 > 3) {
          for (o2(i2), --s2; s2 > 6; s2 -= 6)
            o2(8304);
          s2 > 2 && (o2(s2 - 3 << 5 | 8208), s2 = 0);
        }
        for (; s2--; )
          o2(i2);
        s2 = 1, i2 = e2[a2];
      }
    return [n2.subarray(0, r2), t2];
  }, yf = function(e2, t2) {
    for (var n2 = 0, r2 = 0; r2 < t2.length; ++r2)
      n2 += e2[r2] * t2[r2];
    return n2;
  }, bf = function(e2, t2, n2) {
    var r2 = n2.length, i2 = pf(t2 + 2);
    e2[i2] = 255 & r2, e2[i2 + 1] = r2 >>> 8, e2[i2 + 2] = 255 ^ e2[i2], e2[i2 + 3] = 255 ^ e2[i2 + 1];
    for (var s2 = 0; s2 < r2; ++s2)
      e2[i2 + s2 + 4] = n2[s2];
    return 8 * (i2 + 4 + r2);
  }, wf = function(e2, t2, n2, r2, i2, s2, o2, a2, l2, c2, u2) {
    ff(t2, u2++, n2), ++i2[256];
    for (var p2 = _f(i2, 15), d2 = p2[0], h2 = p2[1], f2 = _f(s2, 15), m2 = f2[0], _2 = f2[1], g2 = vf(d2), v2 = g2[0], y2 = g2[1], b2 = vf(m2), w2 = b2[0], A2 = b2[1], x2 = new Nh(19), E2 = 0; E2 < v2.length; ++E2)
      x2[31 & v2[E2]]++;
    for (E2 = 0; E2 < w2.length; ++E2)
      x2[31 & w2[E2]]++;
    for (var C2 = _f(x2, 7), S2 = C2[0], M2 = C2[1], T2 = 19; T2 > 4 && !S2[Vh[T2 - 1]]; --T2)
      ;
    var P2, I2, R2, k2, D2 = c2 + 5 << 3, B2 = yf(i2, tf) + yf(s2, nf) + o2, O2 = yf(i2, d2) + yf(s2, m2) + o2 + 14 + 3 * T2 + yf(x2, S2) + (2 * x2[16] + 3 * x2[17] + 7 * x2[18]);
    if (D2 <= B2 && D2 <= O2)
      return bf(t2, u2, e2.subarray(l2, l2 + c2));
    if (ff(t2, u2, 1 + (O2 < B2)), u2 += 2, O2 < B2) {
      P2 = ef(d2, h2, 0), I2 = d2, R2 = ef(m2, _2, 0), k2 = m2;
      var L2 = ef(S2, M2, 0);
      for (ff(t2, u2, y2 - 257), ff(t2, u2 + 5, A2 - 1), ff(t2, u2 + 10, T2 - 4), u2 += 14, E2 = 0; E2 < T2; ++E2)
        ff(t2, u2 + 3 * E2, S2[Vh[E2]]);
      u2 += 3 * T2;
      for (var U2 = [v2, w2], F2 = 0; F2 < 2; ++F2) {
        var N2 = U2[F2];
        for (E2 = 0; E2 < N2.length; ++E2) {
          var j2 = 31 & N2[E2];
          ff(t2, u2, L2[j2]), u2 += S2[j2], j2 > 15 && (ff(t2, u2, N2[E2] >>> 5 & 127), u2 += N2[E2] >>> 12);
        }
      }
    } else
      P2 = rf, I2 = tf, R2 = of, k2 = nf;
    for (E2 = 0; E2 < a2; ++E2)
      if (r2[E2] > 255) {
        j2 = r2[E2] >>> 18 & 31, mf(t2, u2, P2[j2 + 257]), u2 += I2[j2 + 257], j2 > 7 && (ff(t2, u2, r2[E2] >>> 23 & 31), u2 += zh[j2]);
        var z2 = 31 & r2[E2];
        mf(t2, u2, R2[z2]), u2 += k2[z2], z2 > 3 && (mf(t2, u2, r2[E2] >>> 5 & 8191), u2 += Gh[z2]);
      } else
        mf(t2, u2, P2[r2[E2]]), u2 += I2[r2[E2]];
    return mf(t2, u2, P2[256]), u2 + I2[256];
  }, Af = new jh([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), xf = new Fh(0), Ef = function() {
    var e2 = 1, t2 = 0;
    return { p: function(n2) {
      for (var r2 = e2, i2 = t2, s2 = n2.length, o2 = 0; o2 != s2; ) {
        for (var a2 = Math.min(o2 + 2655, s2); o2 < a2; ++o2)
          i2 += r2 += n2[o2];
        r2 = (65535 & r2) + 15 * (r2 >> 16), i2 = (65535 & i2) + 15 * (i2 >> 16);
      }
      e2 = r2, t2 = i2;
    }, d: function() {
      return (255 & (e2 %= 65521)) << 24 | e2 >>> 8 << 16 | (255 & (t2 %= 65521)) << 8 | t2 >>> 8;
    } };
  }, Cf = function(e2, t2, n2, r2, i2) {
    return function(e3, t3, n3, r3, i3, s2) {
      var o2 = e3.length, a2 = new Fh(r3 + o2 + 5 * (1 + Math.ceil(o2 / 7e3)) + i3), l2 = a2.subarray(r3, a2.length - i3), c2 = 0;
      if (!t3 || o2 < 8)
        for (var u2 = 0; u2 <= o2; u2 += 65535) {
          var p2 = u2 + 65535;
          p2 < o2 ? c2 = bf(l2, c2, e3.subarray(u2, p2)) : (l2[u2] = s2, c2 = bf(l2, c2, e3.subarray(u2, o2)));
        }
      else {
        for (var d2 = Af[t3 - 1], h2 = d2 >>> 13, f2 = 8191 & d2, m2 = (1 << n3) - 1, _2 = new Nh(32768), g2 = new Nh(m2 + 1), v2 = Math.ceil(n3 / 3), y2 = 2 * v2, b2 = function(t4) {
          return (e3[t4] ^ e3[t4 + 1] << v2 ^ e3[t4 + 2] << y2) & m2;
        }, w2 = new jh(25e3), A2 = new Nh(288), x2 = new Nh(32), E2 = 0, C2 = 0, S2 = (u2 = 0, 0), M2 = 0, T2 = 0; u2 < o2; ++u2) {
          var P2 = b2(u2), I2 = 32767 & u2, R2 = g2[P2];
          if (_2[I2] = R2, g2[P2] = I2, M2 <= u2) {
            var k2 = o2 - u2;
            if ((E2 > 7e3 || S2 > 24576) && k2 > 423) {
              c2 = wf(e3, l2, 0, w2, A2, x2, C2, S2, T2, u2 - T2, c2), S2 = E2 = C2 = 0, T2 = u2;
              for (var D2 = 0; D2 < 286; ++D2)
                A2[D2] = 0;
              for (D2 = 0; D2 < 30; ++D2)
                x2[D2] = 0;
            }
            var B2 = 2, O2 = 0, L2 = f2, U2 = I2 - R2 & 32767;
            if (k2 > 2 && P2 == b2(u2 - U2))
              for (var F2 = Math.min(h2, k2) - 1, N2 = Math.min(32767, u2), j2 = Math.min(258, k2); U2 <= N2 && --L2 && I2 != R2; ) {
                if (e3[u2 + B2] == e3[u2 + B2 - U2]) {
                  for (var z2 = 0; z2 < j2 && e3[u2 + z2] == e3[u2 + z2 - U2]; ++z2)
                    ;
                  if (z2 > B2) {
                    if (B2 = z2, O2 = U2, z2 > F2)
                      break;
                    var G2 = Math.min(U2, z2 - 2), V2 = 0;
                    for (D2 = 0; D2 < G2; ++D2) {
                      var H2 = u2 - U2 + D2 + 32768 & 32767, Q2 = H2 - _2[H2] + 32768 & 32767;
                      Q2 > V2 && (V2 = Q2, R2 = H2);
                    }
                  }
                }
                U2 += (I2 = R2) - (R2 = _2[I2]) + 32768 & 32767;
              }
            if (O2) {
              w2[S2++] = 268435456 | qh[B2] << 18 | Kh[O2];
              var W2 = 31 & qh[B2], q2 = 31 & Kh[O2];
              C2 += zh[W2] + Gh[q2], ++A2[257 + W2], ++x2[q2], M2 = u2 + B2, ++E2;
            } else
              w2[S2++] = e3[u2], ++A2[e3[u2]];
          }
        }
        c2 = wf(e3, l2, s2, w2, A2, x2, C2, S2, T2, u2 - T2, c2), !s2 && 7 & c2 && (c2 = bf(l2, c2 + 1, xf));
      }
      return df(a2, 0, r3 + pf(c2) + i3);
    }(e2, null == t2.level ? 6 : t2.level, null == t2.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(e2.length)))) : 12 + t2.mem, n2, r2, !i2);
  }, Sf = function(e2, t2, n2) {
    for (; n2; ++t2)
      e2[t2] = n2, n2 >>>= 8;
  }, Mf = function(e2, t2) {
    var n2 = t2.level, r2 = 0 == n2 ? 0 : n2 < 6 ? 1 : 9 == n2 ? 3 : 2;
    e2[0] = 120, e2[1] = r2 << 6 | (r2 ? 32 - 2 * r2 : 1);
  }, Tf = function(e2) {
    if (8 != (15 & e2[0]) || e2[0] >>> 4 > 7 || (e2[0] << 8 | e2[1]) % 31)
      throw "invalid zlib data";
    if (32 & e2[1])
      throw "invalid zlib data: preset dictionaries not supported";
  };
  function Pf(e2, t2) {
    return hf((Tf(e2), e2.subarray(2, -4)), t2);
  }
  var If = "undefined" != typeof TextDecoder && new TextDecoder();
  try {
    If.decode(xf, { stream: true });
  } catch (fl2) {
  }
  function Rf(e2, t2, n2) {
    const r2 = n2.length - e2 - 1;
    if (t2 >= n2[r2])
      return r2 - 1;
    if (t2 <= n2[e2])
      return e2;
    let i2 = e2, s2 = r2, o2 = Math.floor((i2 + s2) / 2);
    for (; t2 < n2[o2] || t2 >= n2[o2 + 1]; )
      t2 < n2[o2] ? s2 = o2 : i2 = o2, o2 = Math.floor((i2 + s2) / 2);
    return o2;
  }
  function kf(e2, t2) {
    let n2 = 1;
    for (let t3 = 2; t3 <= e2; ++t3)
      n2 *= t3;
    let r2 = 1;
    for (let e3 = 2; e3 <= t2; ++e3)
      r2 *= e3;
    for (let n3 = 2; n3 <= e2 - t2; ++n3)
      r2 *= n3;
    return n2 / r2;
  }
  class Df extends n.Hyl {
    constructor(e2, t2, r2, i2, s2) {
      super(), this.degree = e2, this.knots = t2, this.controlPoints = [], this.startKnot = i2 || 0, this.endKnot = s2 || this.knots.length - 1;
      for (let e3 = 0; e3 < r2.length; ++e3) {
        const t3 = r2[e3];
        this.controlPoints[e3] = new n.Ltg(t3.x, t3.y, t3.z, t3.w);
      }
    }
    getPoint(e2, t2 = new n.Pa4()) {
      const r2 = t2, i2 = this.knots[this.startKnot] + e2 * (this.knots[this.endKnot] - this.knots[this.startKnot]), s2 = function(e3, t3, r3, i3) {
        const s3 = Rf(e3, i3, t3), o2 = function(e4, t4, n2, r4) {
          const i4 = [], s4 = [], o3 = [];
          i4[0] = 1;
          for (let a3 = 1; a3 <= n2; ++a3) {
            s4[a3] = t4 - r4[e4 + 1 - a3], o3[a3] = r4[e4 + a3] - t4;
            let n3 = 0;
            for (let e5 = 0; e5 < a3; ++e5) {
              const t5 = o3[e5 + 1], r5 = s4[a3 - e5], l2 = i4[e5] / (t5 + r5);
              i4[e5] = n3 + t5 * l2, n3 = r5 * l2;
            }
            i4[a3] = n3;
          }
          return i4;
        }(s3, i3, e3, t3), a2 = new n.Ltg(0, 0, 0, 0);
        for (let t4 = 0; t4 <= e3; ++t4) {
          const n2 = r3[s3 - e3 + t4], i4 = o2[t4], l2 = n2.w * i4;
          a2.x += n2.x * l2, a2.y += n2.y * l2, a2.z += n2.z * l2, a2.w += n2.w * i4;
        }
        return a2;
      }(this.degree, this.knots, this.controlPoints, i2);
      return 1 !== s2.w && s2.divideScalar(s2.w), r2.set(s2.x, s2.y, s2.z);
    }
    getTangent(e2, t2 = new n.Pa4()) {
      const r2 = t2, i2 = this.knots[0] + e2 * (this.knots[this.knots.length - 1] - this.knots[0]), s2 = function(e3, t3, r3, i3, s3) {
        const o2 = function(e4, t4, r4, i4, s4) {
          const o3 = s4 < e4 ? s4 : e4, a2 = [], l2 = Rf(e4, i4, t4), c2 = function(e5, t5, n2, r5, i5) {
            const s5 = [];
            for (let e6 = 0; e6 <= n2; ++e6)
              s5[e6] = 0;
            const o4 = [];
            for (let e6 = 0; e6 <= r5; ++e6)
              o4[e6] = s5.slice(0);
            const a3 = [];
            for (let e6 = 0; e6 <= n2; ++e6)
              a3[e6] = s5.slice(0);
            a3[0][0] = 1;
            const l3 = s5.slice(0), c3 = s5.slice(0);
            for (let r6 = 1; r6 <= n2; ++r6) {
              l3[r6] = t5 - i5[e5 + 1 - r6], c3[r6] = i5[e5 + r6] - t5;
              let n3 = 0;
              for (let e6 = 0; e6 < r6; ++e6) {
                const t6 = c3[e6 + 1], i6 = l3[r6 - e6];
                a3[r6][e6] = t6 + i6;
                const s6 = a3[e6][r6 - 1] / a3[r6][e6];
                a3[e6][r6] = n3 + t6 * s6, n3 = i6 * s6;
              }
              a3[r6][r6] = n3;
            }
            for (let e6 = 0; e6 <= n2; ++e6)
              o4[0][e6] = a3[e6][n2];
            for (let e6 = 0; e6 <= n2; ++e6) {
              let t6 = 0, i6 = 1;
              const l4 = [];
              for (let e7 = 0; e7 <= n2; ++e7)
                l4[e7] = s5.slice(0);
              l4[0][0] = 1;
              for (let s6 = 1; s6 <= r5; ++s6) {
                let r6 = 0;
                const c4 = e6 - s6, u4 = n2 - s6;
                e6 >= s6 && (l4[i6][0] = l4[t6][0] / a3[u4 + 1][c4], r6 = l4[i6][0] * a3[c4][u4]);
                const p2 = e6 - 1 <= u4 ? s6 - 1 : n2 - e6;
                for (let e7 = c4 >= -1 ? 1 : -c4; e7 <= p2; ++e7)
                  l4[i6][e7] = (l4[t6][e7] - l4[t6][e7 - 1]) / a3[u4 + 1][c4 + e7], r6 += l4[i6][e7] * a3[c4 + e7][u4];
                e6 <= u4 && (l4[i6][s6] = -l4[t6][s6 - 1] / a3[u4 + 1][e6], r6 += l4[i6][s6] * a3[e6][u4]), o4[s6][e6] = r6;
                const d2 = t6;
                t6 = i6, i6 = d2;
              }
            }
            let u3 = n2;
            for (let e6 = 1; e6 <= r5; ++e6) {
              for (let t6 = 0; t6 <= n2; ++t6)
                o4[e6][t6] *= u3;
              u3 *= n2 - e6;
            }
            return o4;
          }(l2, i4, e4, o3, t4), u2 = [];
          for (let e5 = 0; e5 < r4.length; ++e5) {
            const t5 = r4[e5].clone(), n2 = t5.w;
            t5.x *= n2, t5.y *= n2, t5.z *= n2, u2[e5] = t5;
          }
          for (let t5 = 0; t5 <= o3; ++t5) {
            const n2 = u2[l2 - e4].clone().multiplyScalar(c2[t5][0]);
            for (let r5 = 1; r5 <= e4; ++r5)
              n2.add(u2[l2 - e4 + r5].clone().multiplyScalar(c2[t5][r5]));
            a2[t5] = n2;
          }
          for (let e5 = o3 + 1; e5 <= s4 + 1; ++e5)
            a2[e5] = new n.Ltg(0, 0, 0);
          return a2;
        }(e3, t3, r3, i3, s3);
        return function(e4) {
          const t4 = e4.length, r4 = [], i4 = [];
          for (let s5 = 0; s5 < t4; ++s5) {
            const t5 = e4[s5];
            r4[s5] = new n.Pa4(t5.x, t5.y, t5.z), i4[s5] = t5.w;
          }
          const s4 = [];
          for (let e5 = 0; e5 < t4; ++e5) {
            const t5 = r4[e5].clone();
            for (let n2 = 1; n2 <= e5; ++n2)
              t5.sub(s4[e5 - n2].clone().multiplyScalar(kf(e5, n2) * i4[n2]));
            s4[e5] = t5.divideScalar(i4[0]);
          }
          return s4;
        }(o2);
      }(this.degree, this.knots, this.controlPoints, i2, 1);
      return r2.copy(s2[1]).normalize(), r2;
    }
  }
  let Bf, Of, Lf;
  class Uf extends n.aNw {
    constructor(e2) {
      super(e2);
    }
    load(e2, t2, r2, i2) {
      const s2 = this, o2 = "" === s2.path ? n.Zp0.extractUrlBase(e2) : s2.path, a2 = new n.hH6(this.manager);
      a2.setPath(s2.path), a2.setResponseType("arraybuffer"), a2.setRequestHeader(s2.requestHeader), a2.setWithCredentials(s2.withCredentials), a2.load(e2, function(n2) {
        try {
          t2(s2.parse(n2, o2));
        } catch (t3) {
          i2 ? i2(t3) : console.error(t3), s2.manager.itemError(e2);
        }
      }, r2, i2);
    }
    parse(e2, t2) {
      if (function(e3) {
        const t3 = "Kaydara FBX Binary  \0";
        return e3.byteLength >= t3.length && t3 === em(e3, 0, t3.length);
      }(e2))
        Bf = new Gf().parse(e2);
      else {
        const t3 = em(e2);
        if (!function(e3) {
          const t4 = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
          let n2 = 0;
          function r3(t5) {
            const r4 = e3[t5 - 1];
            return e3 = e3.slice(n2 + t5), n2++, r4;
          }
          for (let e4 = 0; e4 < t4.length; ++e4)
            if (r3(1) === t4[e4])
              return false;
          return true;
        }(t3))
          throw new Error("THREE.FBXLoader: Unknown format.");
        if (Qf(t3) < 7e3)
          throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + Qf(t3));
        Bf = new zf().parse(t3);
      }
      const r2 = new n.dpR(this.manager).setPath(this.resourcePath || t2).setCrossOrigin(this.crossOrigin), i2 = new Ff(r2, this.manager).parse(Bf);
      return Bf = null, Of = null, Lf = null, i2;
    }
  }
  class Ff {
    constructor(e2, t2) {
      this.textureLoader = e2, this.manager = t2;
    }
    parse() {
      Of = this.parseConnections();
      const e2 = this.parseImages(), t2 = this.parseTextures(e2), n2 = this.parseMaterials(t2), r2 = this.parseDeformers(), i2 = new Nf().parse(r2);
      return this.parseScene(r2, i2, n2), Lf;
    }
    parseConnections() {
      const e2 = /* @__PURE__ */ new Map();
      return "Connections" in Bf && Bf.Connections.connections.forEach(function(t2) {
        const n2 = t2[0], r2 = t2[1], i2 = t2[2];
        e2.has(n2) || e2.set(n2, { parents: [], children: [] });
        const s2 = { ID: r2, relationship: i2 };
        e2.get(n2).parents.push(s2), e2.has(r2) || e2.set(r2, { parents: [], children: [] });
        const o2 = { ID: n2, relationship: i2 };
        e2.get(r2).children.push(o2);
      }), e2;
    }
    parseImages() {
      const e2 = {}, t2 = {};
      if ("Video" in Bf.Objects) {
        const n2 = Bf.Objects.Video;
        for (const r2 in n2) {
          const i2 = n2[r2];
          if (e2[parseInt(r2)] = i2.RelativeFilename || i2.Filename, "Content" in i2) {
            const e3 = i2.Content instanceof ArrayBuffer && i2.Content.byteLength > 0, s2 = "string" == typeof i2.Content && "" !== i2.Content;
            if (e3 || s2) {
              const e4 = this.parseImage(n2[r2]);
              t2[i2.RelativeFilename || i2.Filename] = e4;
            }
          }
        }
      }
      for (const n2 in e2) {
        const r2 = e2[n2];
        void 0 !== t2[r2] ? e2[n2] = t2[r2] : e2[n2] = e2[n2].split("\\").pop();
      }
      return e2;
    }
    parseImage(e2) {
      const t2 = e2.Content, n2 = e2.RelativeFilename || e2.Filename, r2 = n2.slice(n2.lastIndexOf(".") + 1).toLowerCase();
      let i2;
      switch (r2) {
        case "bmp":
          i2 = "image/bmp";
          break;
        case "jpg":
        case "jpeg":
          i2 = "image/jpeg";
          break;
        case "png":
          i2 = "image/png";
          break;
        case "tif":
          i2 = "image/tiff";
          break;
        case "tga":
          null === this.manager.getHandler(".tga") && console.warn("FBXLoader: TGA loader not found, skipping ", n2), i2 = "image/tga";
          break;
        default:
          return void console.warn('FBXLoader: Image type "' + r2 + '" is not supported.');
      }
      if ("string" == typeof t2)
        return "data:" + i2 + ";base64," + t2;
      {
        const e3 = new Uint8Array(t2);
        return window.URL.createObjectURL(new Blob([e3], { type: i2 }));
      }
    }
    parseTextures(e2) {
      const t2 = /* @__PURE__ */ new Map();
      if ("Texture" in Bf.Objects) {
        const n2 = Bf.Objects.Texture;
        for (const r2 in n2) {
          const i2 = this.parseTexture(n2[r2], e2);
          t2.set(parseInt(r2), i2);
        }
      }
      return t2;
    }
    parseTexture(e2, t2) {
      const r2 = this.loadTexture(e2, t2);
      r2.ID = e2.id, r2.name = e2.attrName;
      const i2 = e2.WrapModeU, s2 = e2.WrapModeV, o2 = void 0 !== i2 ? i2.value : 0, a2 = void 0 !== s2 ? s2.value : 0;
      if (r2.wrapS = 0 === o2 ? n.rpg : n.uWy, r2.wrapT = 0 === a2 ? n.rpg : n.uWy, "Scaling" in e2) {
        const t3 = e2.Scaling.value;
        r2.repeat.x = t3[0], r2.repeat.y = t3[1];
      }
      if ("Translation" in e2) {
        const t3 = e2.Translation.value;
        r2.offset.x = t3[0], r2.offset.y = t3[1];
      }
      return r2;
    }
    loadTexture(e2, t2) {
      let r2;
      const i2 = this.textureLoader.path, s2 = Of.get(e2.id).children;
      let o2;
      void 0 !== s2 && s2.length > 0 && void 0 !== t2[s2[0].ID] && (r2 = t2[s2[0].ID], 0 !== r2.indexOf("blob:") && 0 !== r2.indexOf("data:") || this.textureLoader.setPath(void 0));
      const a2 = e2.FileName.slice(-3).toLowerCase();
      if ("tga" === a2) {
        const t3 = this.manager.getHandler(".tga");
        null === t3 ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", e2.RelativeFilename), o2 = new n.xEZ()) : (t3.setPath(this.textureLoader.path), o2 = t3.load(r2));
      } else
        "psd" === a2 ? (console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", e2.RelativeFilename), o2 = new n.xEZ()) : o2 = this.textureLoader.load(r2);
      return this.textureLoader.setPath(i2), o2;
    }
    parseMaterials(e2) {
      const t2 = /* @__PURE__ */ new Map();
      if ("Material" in Bf.Objects) {
        const n2 = Bf.Objects.Material;
        for (const r2 in n2) {
          const i2 = this.parseMaterial(n2[r2], e2);
          null !== i2 && t2.set(parseInt(r2), i2);
        }
      }
      return t2;
    }
    parseMaterial(e2, t2) {
      const r2 = e2.id, i2 = e2.attrName;
      let s2 = e2.ShadingModel;
      if ("object" == typeof s2 && (s2 = s2.value), !Of.has(r2))
        return null;
      const o2 = this.parseParameters(e2, t2, r2);
      let a2;
      switch (s2.toLowerCase()) {
        case "phong":
          a2 = new n.xoR();
          break;
        case "lambert":
          a2 = new n.YBo();
          break;
        default:
          console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', s2), a2 = new n.xoR();
      }
      return a2.setValues(o2), a2.name = i2, a2;
    }
    parseParameters(e2, t2, r2) {
      const i2 = {};
      e2.BumpFactor && (i2.bumpScale = e2.BumpFactor.value), e2.Diffuse ? i2.color = new n.Ilk().fromArray(e2.Diffuse.value).convertSRGBToLinear() : !e2.DiffuseColor || "Color" !== e2.DiffuseColor.type && "ColorRGB" !== e2.DiffuseColor.type || (i2.color = new n.Ilk().fromArray(e2.DiffuseColor.value).convertSRGBToLinear()), e2.DisplacementFactor && (i2.displacementScale = e2.DisplacementFactor.value), e2.Emissive ? i2.emissive = new n.Ilk().fromArray(e2.Emissive.value).convertSRGBToLinear() : !e2.EmissiveColor || "Color" !== e2.EmissiveColor.type && "ColorRGB" !== e2.EmissiveColor.type || (i2.emissive = new n.Ilk().fromArray(e2.EmissiveColor.value).convertSRGBToLinear()), e2.EmissiveFactor && (i2.emissiveIntensity = parseFloat(e2.EmissiveFactor.value)), e2.Opacity && (i2.opacity = parseFloat(e2.Opacity.value)), i2.opacity < 1 && (i2.transparent = true), e2.ReflectionFactor && (i2.reflectivity = e2.ReflectionFactor.value), e2.Shininess && (i2.shininess = e2.Shininess.value), e2.Specular ? i2.specular = new n.Ilk().fromArray(e2.Specular.value).convertSRGBToLinear() : e2.SpecularColor && "Color" === e2.SpecularColor.type && (i2.specular = new n.Ilk().fromArray(e2.SpecularColor.value).convertSRGBToLinear());
      const s2 = this;
      return Of.get(r2).children.forEach(function(e3) {
        const r3 = e3.relationship;
        switch (r3) {
          case "Bump":
            i2.bumpMap = s2.getTexture(t2, e3.ID);
            break;
          case "Maya|TEX_ao_map":
            i2.aoMap = s2.getTexture(t2, e3.ID);
            break;
          case "DiffuseColor":
          case "Maya|TEX_color_map":
            i2.map = s2.getTexture(t2, e3.ID), void 0 !== i2.map && (i2.map.colorSpace = n.KI_);
            break;
          case "DisplacementColor":
            i2.displacementMap = s2.getTexture(t2, e3.ID);
            break;
          case "EmissiveColor":
            i2.emissiveMap = s2.getTexture(t2, e3.ID), void 0 !== i2.emissiveMap && (i2.emissiveMap.colorSpace = n.KI_);
            break;
          case "NormalMap":
          case "Maya|TEX_normal_map":
            i2.normalMap = s2.getTexture(t2, e3.ID);
            break;
          case "ReflectionColor":
            i2.envMap = s2.getTexture(t2, e3.ID), void 0 !== i2.envMap && (i2.envMap.mapping = n.dSO, i2.envMap.colorSpace = n.KI_);
            break;
          case "SpecularColor":
            i2.specularMap = s2.getTexture(t2, e3.ID), void 0 !== i2.specularMap && (i2.specularMap.colorSpace = n.KI_);
            break;
          case "TransparentColor":
          case "TransparencyFactor":
            i2.alphaMap = s2.getTexture(t2, e3.ID), i2.transparent = true;
            break;
          default:
            console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", r3);
        }
      }), i2;
    }
    getTexture(e2, t2) {
      return "LayeredTexture" in Bf.Objects && t2 in Bf.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), t2 = Of.get(t2).children[0].ID), e2.get(t2);
    }
    parseDeformers() {
      const e2 = {}, t2 = {};
      if ("Deformer" in Bf.Objects) {
        const n2 = Bf.Objects.Deformer;
        for (const r2 in n2) {
          const i2 = n2[r2], s2 = Of.get(parseInt(r2));
          if ("Skin" === i2.attrType) {
            const t3 = this.parseSkeleton(s2, n2);
            t3.ID = r2, s2.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), t3.geometryID = s2.parents[0].ID, e2[r2] = t3;
          } else if ("BlendShape" === i2.attrType) {
            const e3 = { id: r2 };
            e3.rawTargets = this.parseMorphTargets(s2, n2), e3.id = r2, s2.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), t2[r2] = e3;
          }
        }
      }
      return { skeletons: e2, morphTargets: t2 };
    }
    parseSkeleton(e2, t2) {
      const r2 = [];
      return e2.children.forEach(function(e3) {
        const i2 = t2[e3.ID];
        if ("Cluster" !== i2.attrType)
          return;
        const s2 = { ID: e3.ID, indices: [], weights: [], transformLink: new n.yGw().fromArray(i2.TransformLink.a) };
        "Indexes" in i2 && (s2.indices = i2.Indexes.a, s2.weights = i2.Weights.a), r2.push(s2);
      }), { rawBones: r2, bones: [] };
    }
    parseMorphTargets(e2, t2) {
      const n2 = [];
      for (let r2 = 0; r2 < e2.children.length; r2++) {
        const i2 = e2.children[r2], s2 = t2[i2.ID], o2 = { name: s2.attrName, initialWeight: s2.DeformPercent, id: s2.id, fullWeights: s2.FullWeights.a };
        if ("BlendShapeChannel" !== s2.attrType)
          return;
        o2.geoID = Of.get(parseInt(i2.ID)).children.filter(function(e3) {
          return void 0 === e3.relationship;
        })[0].ID, n2.push(o2);
      }
      return n2;
    }
    parseScene(e2, t2, r2) {
      Lf = new n.ZAu();
      const i2 = this.parseModels(e2.skeletons, t2, r2), s2 = Bf.Objects.Model, o2 = this;
      i2.forEach(function(e3) {
        const t3 = s2[e3.ID];
        o2.setLookAtProperties(e3, t3), Of.get(e3.ID).parents.forEach(function(t4) {
          const n2 = i2.get(t4.ID);
          void 0 !== n2 && n2.add(e3);
        }), null === e3.parent && Lf.add(e3);
      }), this.bindSkeleton(e2.skeletons, t2, i2), this.createAmbientLight(), Lf.traverse(function(e3) {
        if (e3.userData.transformData) {
          e3.parent && (e3.userData.transformData.parentMatrix = e3.parent.matrix, e3.userData.transformData.parentMatrixWorld = e3.parent.matrixWorld);
          const t3 = Jf(e3.userData.transformData);
          e3.applyMatrix4(t3), e3.updateWorldMatrix();
        }
      });
      const a2 = new jf().parse();
      1 === Lf.children.length && Lf.children[0].isGroup && (Lf.children[0].animations = a2, Lf = Lf.children[0]), Lf.animations = a2;
    }
    parseModels(e2, t2, r2) {
      const i2 = /* @__PURE__ */ new Map(), s2 = Bf.Objects.Model;
      for (const o2 in s2) {
        const a2 = parseInt(o2), l2 = s2[o2], c2 = Of.get(a2);
        let u2 = this.buildSkeleton(c2, e2, a2, l2.attrName);
        if (!u2) {
          switch (l2.attrType) {
            case "Camera":
              u2 = this.createCamera(c2);
              break;
            case "Light":
              u2 = this.createLight(c2);
              break;
            case "Mesh":
              u2 = this.createMesh(c2, t2, r2);
              break;
            case "NurbsCurve":
              u2 = this.createCurve(c2, t2);
              break;
            case "LimbNode":
            case "Root":
              u2 = new n.N$j();
              break;
            default:
              u2 = new n.ZAu();
          }
          u2.name = l2.attrName ? n.iUV.sanitizeNodeName(l2.attrName) : "", u2.ID = a2;
        }
        this.getTransformData(u2, l2), i2.set(a2, u2);
      }
      return i2;
    }
    buildSkeleton(e2, t2, r2, i2) {
      let s2 = null;
      return e2.parents.forEach(function(e3) {
        for (const o2 in t2) {
          const a2 = t2[o2];
          a2.rawBones.forEach(function(t3, o3) {
            if (t3.ID === e3.ID) {
              const e4 = s2;
              s2 = new n.N$j(), s2.matrixWorld.copy(t3.transformLink), s2.name = i2 ? n.iUV.sanitizeNodeName(i2) : "", s2.ID = r2, a2.bones[o3] = s2, null !== e4 && s2.add(e4);
            }
          });
        }
      }), s2;
    }
    createCamera(e2) {
      let t2, r2;
      if (e2.children.forEach(function(e3) {
        const t3 = Bf.Objects.NodeAttribute[e3.ID];
        void 0 !== t3 && (r2 = t3);
      }), void 0 === r2)
        t2 = new n.Tme();
      else {
        let e3 = 0;
        void 0 !== r2.CameraProjectionType && 1 === r2.CameraProjectionType.value && (e3 = 1);
        let i2 = 1;
        void 0 !== r2.NearPlane && (i2 = r2.NearPlane.value / 1e3);
        let s2 = 1e3;
        void 0 !== r2.FarPlane && (s2 = r2.FarPlane.value / 1e3);
        let o2 = window.innerWidth, a2 = window.innerHeight;
        void 0 !== r2.AspectWidth && void 0 !== r2.AspectHeight && (o2 = r2.AspectWidth.value, a2 = r2.AspectHeight.value);
        const l2 = o2 / a2;
        let c2 = 45;
        void 0 !== r2.FieldOfView && (c2 = r2.FieldOfView.value);
        const u2 = r2.FocalLength ? r2.FocalLength.value : null;
        switch (e3) {
          case 0:
            t2 = new n.cPb(c2, l2, i2, s2), null !== u2 && t2.setFocalLength(u2);
            break;
          case 1:
            t2 = new n.iKG(-o2 / 2, o2 / 2, a2 / 2, -a2 / 2, i2, s2);
            break;
          default:
            console.warn("THREE.FBXLoader: Unknown camera type " + e3 + "."), t2 = new n.Tme();
        }
      }
      return t2;
    }
    createLight(e2) {
      let t2, r2;
      if (e2.children.forEach(function(e3) {
        const t3 = Bf.Objects.NodeAttribute[e3.ID];
        void 0 !== t3 && (r2 = t3);
      }), void 0 === r2)
        t2 = new n.Tme();
      else {
        let e3;
        e3 = void 0 === r2.LightType ? 0 : r2.LightType.value;
        let i2 = 16777215;
        void 0 !== r2.Color && (i2 = new n.Ilk().fromArray(r2.Color.value).convertSRGBToLinear());
        let s2 = void 0 === r2.Intensity ? 1 : r2.Intensity.value / 100;
        void 0 !== r2.CastLightOnObject && 0 === r2.CastLightOnObject.value && (s2 = 0);
        let o2 = 0;
        void 0 !== r2.FarAttenuationEnd && (o2 = void 0 !== r2.EnableFarAttenuation && 0 === r2.EnableFarAttenuation.value ? 0 : r2.FarAttenuationEnd.value);
        const a2 = 1;
        switch (e3) {
          case 0:
            t2 = new n.cek(i2, s2, o2, a2);
            break;
          case 1:
            t2 = new n.Ox3(i2, s2);
            break;
          case 2:
            let e4 = Math.PI / 3;
            void 0 !== r2.InnerAngle && (e4 = n.M8C.degToRad(r2.InnerAngle.value));
            let l2 = 0;
            void 0 !== r2.OuterAngle && (l2 = n.M8C.degToRad(r2.OuterAngle.value), l2 = Math.max(l2, 1)), t2 = new n.PMe(i2, s2, o2, e4, l2, a2);
            break;
          default:
            console.warn("THREE.FBXLoader: Unknown light type " + r2.LightType.value + ", defaulting to a PointLight."), t2 = new n.cek(i2, s2);
        }
        void 0 !== r2.CastShadows && 1 === r2.CastShadows.value && (t2.castShadow = true);
      }
      return t2;
    }
    createMesh(e2, t2, r2) {
      let i2, s2 = null, o2 = null;
      const a2 = [];
      return e2.children.forEach(function(e3) {
        t2.has(e3.ID) && (s2 = t2.get(e3.ID)), r2.has(e3.ID) && a2.push(r2.get(e3.ID));
      }), a2.length > 1 ? o2 = a2 : a2.length > 0 ? o2 = a2[0] : (o2 = new n.xoR({ color: 13421772 }), a2.push(o2)), "color" in s2.attributes && a2.forEach(function(e3) {
        e3.vertexColors = true;
      }), s2.FBX_Deformer ? (i2 = new n.TUv(s2, o2), i2.normalizeSkinWeights()) : i2 = new n.Kj0(s2, o2), i2;
    }
    createCurve(e2, t2) {
      const r2 = e2.children.reduce(function(e3, n2) {
        return t2.has(n2.ID) && (e3 = t2.get(n2.ID)), e3;
      }, null), i2 = new n.nls({ color: 3342591, linewidth: 1 });
      return new n.x12(r2, i2);
    }
    getTransformData(e2, t2) {
      const n2 = {};
      "InheritType" in t2 && (n2.inheritType = parseInt(t2.InheritType.value)), n2.eulerOrder = "RotationOrder" in t2 ? Zf(t2.RotationOrder.value) : "ZYX", "Lcl_Translation" in t2 && (n2.translation = t2.Lcl_Translation.value), "PreRotation" in t2 && (n2.preRotation = t2.PreRotation.value), "Lcl_Rotation" in t2 && (n2.rotation = t2.Lcl_Rotation.value), "PostRotation" in t2 && (n2.postRotation = t2.PostRotation.value), "Lcl_Scaling" in t2 && (n2.scale = t2.Lcl_Scaling.value), "ScalingOffset" in t2 && (n2.scalingOffset = t2.ScalingOffset.value), "ScalingPivot" in t2 && (n2.scalingPivot = t2.ScalingPivot.value), "RotationOffset" in t2 && (n2.rotationOffset = t2.RotationOffset.value), "RotationPivot" in t2 && (n2.rotationPivot = t2.RotationPivot.value), e2.userData.transformData = n2;
    }
    setLookAtProperties(e2, t2) {
      "LookAtProperty" in t2 && Of.get(e2.ID).children.forEach(function(t3) {
        if ("LookAtProperty" === t3.relationship) {
          const r2 = Bf.Objects.Model[t3.ID];
          if ("Lcl_Translation" in r2) {
            const t4 = r2.Lcl_Translation.value;
            void 0 !== e2.target ? (e2.target.position.fromArray(t4), Lf.add(e2.target)) : e2.lookAt(new n.Pa4().fromArray(t4));
          }
        }
      });
    }
    bindSkeleton(e2, t2, r2) {
      const i2 = this.parsePoseNodes();
      for (const s2 in e2) {
        const o2 = e2[s2];
        Of.get(parseInt(o2.ID)).parents.forEach(function(e3) {
          if (t2.has(e3.ID)) {
            const t3 = e3.ID;
            Of.get(t3).parents.forEach(function(e4) {
              r2.has(e4.ID) && r2.get(e4.ID).bind(new n.OdW(o2.bones), i2[e4.ID]);
            });
          }
        });
      }
    }
    parsePoseNodes() {
      const e2 = {};
      if ("Pose" in Bf.Objects) {
        const t2 = Bf.Objects.Pose;
        for (const r2 in t2)
          if ("BindPose" === t2[r2].attrType && t2[r2].NbPoseNodes > 0) {
            const i2 = t2[r2].PoseNode;
            Array.isArray(i2) ? i2.forEach(function(t3) {
              e2[t3.Node] = new n.yGw().fromArray(t3.Matrix.a);
            }) : e2[i2.Node] = new n.yGw().fromArray(i2.Matrix.a);
          }
      }
      return e2;
    }
    createAmbientLight() {
      if ("GlobalSettings" in Bf && "AmbientColor" in Bf.GlobalSettings) {
        const e2 = Bf.GlobalSettings.AmbientColor.value, t2 = e2[0], r2 = e2[1], i2 = e2[2];
        if (0 !== t2 || 0 !== r2 || 0 !== i2) {
          const e3 = new n.Ilk(t2, r2, i2).convertSRGBToLinear();
          Lf.add(new n.Mig(e3, 1));
        }
      }
    }
  }
  class Nf {
    constructor() {
      this.negativeMaterialIndices = false;
    }
    parse(e2) {
      const t2 = /* @__PURE__ */ new Map();
      if ("Geometry" in Bf.Objects) {
        const n2 = Bf.Objects.Geometry;
        for (const r2 in n2) {
          const i2 = Of.get(parseInt(r2)), s2 = this.parseGeometry(i2, n2[r2], e2);
          t2.set(parseInt(r2), s2);
        }
      }
      return true === this.negativeMaterialIndices && console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."), t2;
    }
    parseGeometry(e2, t2, n2) {
      switch (t2.attrType) {
        case "Mesh":
          return this.parseMeshGeometry(e2, t2, n2);
        case "NurbsCurve":
          return this.parseNurbsGeometry(t2);
      }
    }
    parseMeshGeometry(e2, t2, n2) {
      const r2 = n2.skeletons, i2 = [], s2 = e2.parents.map(function(e3) {
        return Bf.Objects.Model[e3.ID];
      });
      if (0 === s2.length)
        return;
      const o2 = e2.children.reduce(function(e3, t3) {
        return void 0 !== r2[t3.ID] && (e3 = r2[t3.ID]), e3;
      }, null);
      e2.children.forEach(function(e3) {
        void 0 !== n2.morphTargets[e3.ID] && i2.push(n2.morphTargets[e3.ID]);
      });
      const a2 = s2[0], l2 = {};
      "RotationOrder" in a2 && (l2.eulerOrder = Zf(a2.RotationOrder.value)), "InheritType" in a2 && (l2.inheritType = parseInt(a2.InheritType.value)), "GeometricTranslation" in a2 && (l2.translation = a2.GeometricTranslation.value), "GeometricRotation" in a2 && (l2.rotation = a2.GeometricRotation.value), "GeometricScaling" in a2 && (l2.scale = a2.GeometricScaling.value);
      const c2 = Jf(l2);
      return this.genGeometry(t2, o2, i2, c2);
    }
    genGeometry(e2, t2, r2, i2) {
      const s2 = new n.u9r();
      e2.attrName && (s2.name = e2.attrName);
      const o2 = this.parseGeoNode(e2, t2), a2 = this.genBuffers(o2), l2 = new n.a$l(a2.vertex, 3);
      if (l2.applyMatrix4(i2), s2.setAttribute("position", l2), a2.colors.length > 0 && s2.setAttribute("color", new n.a$l(a2.colors, 3)), t2 && (s2.setAttribute("skinIndex", new n.qlB(a2.weightsIndices, 4)), s2.setAttribute("skinWeight", new n.a$l(a2.vertexWeights, 4)), s2.FBX_Deformer = t2), a2.normal.length > 0) {
        const e3 = new n.Vkp().getNormalMatrix(i2), t3 = new n.a$l(a2.normal, 3);
        t3.applyNormalMatrix(e3), s2.setAttribute("normal", t3);
      }
      if (a2.uvs.forEach(function(e3, t3) {
        const r3 = 0 === t3 ? "uv" : `uv${t3}`;
        s2.setAttribute(r3, new n.a$l(a2.uvs[t3], 2));
      }), o2.material && "AllSame" !== o2.material.mappingType) {
        let e3 = a2.materialIndex[0], t3 = 0;
        if (a2.materialIndex.forEach(function(n2, r3) {
          n2 !== e3 && (s2.addGroup(t3, r3 - t3, e3), e3 = n2, t3 = r3);
        }), s2.groups.length > 0) {
          const t4 = s2.groups[s2.groups.length - 1], n2 = t4.start + t4.count;
          n2 !== a2.materialIndex.length && s2.addGroup(n2, a2.materialIndex.length - n2, e3);
        }
        0 === s2.groups.length && s2.addGroup(0, a2.materialIndex.length, a2.materialIndex[0]);
      }
      return this.addMorphTargets(s2, e2, r2, i2), s2;
    }
    parseGeoNode(e2, t2) {
      const n2 = {};
      if (n2.vertexPositions = void 0 !== e2.Vertices ? e2.Vertices.a : [], n2.vertexIndices = void 0 !== e2.PolygonVertexIndex ? e2.PolygonVertexIndex.a : [], e2.LayerElementColor && (n2.color = this.parseVertexColors(e2.LayerElementColor[0])), e2.LayerElementMaterial && (n2.material = this.parseMaterialIndices(e2.LayerElementMaterial[0])), e2.LayerElementNormal && (n2.normal = this.parseNormals(e2.LayerElementNormal[0])), e2.LayerElementUV) {
        n2.uv = [];
        let t3 = 0;
        for (; e2.LayerElementUV[t3]; )
          e2.LayerElementUV[t3].UV && n2.uv.push(this.parseUVs(e2.LayerElementUV[t3])), t3++;
      }
      return n2.weightTable = {}, null !== t2 && (n2.skeleton = t2, t2.rawBones.forEach(function(e3, t3) {
        e3.indices.forEach(function(r2, i2) {
          void 0 === n2.weightTable[r2] && (n2.weightTable[r2] = []), n2.weightTable[r2].push({ id: t3, weight: e3.weights[i2] });
        });
      })), n2;
    }
    genBuffers(e2) {
      const t2 = { vertex: [], normal: [], colors: [], uvs: [], materialIndex: [], vertexWeights: [], weightsIndices: [] };
      let n2 = 0, r2 = 0, i2 = false, s2 = [], o2 = [], a2 = [], l2 = [], c2 = [], u2 = [];
      const p2 = this;
      return e2.vertexIndices.forEach(function(d2, h2) {
        let f2, m2 = false;
        d2 < 0 && (d2 ^= -1, m2 = true);
        let _2 = [], g2 = [];
        if (s2.push(3 * d2, 3 * d2 + 1, 3 * d2 + 2), e2.color) {
          const t3 = Xf(h2, n2, d2, e2.color);
          a2.push(t3[0], t3[1], t3[2]);
        }
        if (e2.skeleton) {
          if (void 0 !== e2.weightTable[d2] && e2.weightTable[d2].forEach(function(e3) {
            g2.push(e3.weight), _2.push(e3.id);
          }), g2.length > 4) {
            i2 || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), i2 = true);
            const e3 = [0, 0, 0, 0], t3 = [0, 0, 0, 0];
            g2.forEach(function(n3, r3) {
              let i3 = n3, s3 = _2[r3];
              t3.forEach(function(t4, n4, r4) {
                if (i3 > t4) {
                  r4[n4] = i3, i3 = t4;
                  const o3 = e3[n4];
                  e3[n4] = s3, s3 = o3;
                }
              });
            }), _2 = e3, g2 = t3;
          }
          for (; g2.length < 4; )
            g2.push(0), _2.push(0);
          for (let e3 = 0; e3 < 4; ++e3)
            c2.push(g2[e3]), u2.push(_2[e3]);
        }
        if (e2.normal) {
          const t3 = Xf(h2, n2, d2, e2.normal);
          o2.push(t3[0], t3[1], t3[2]);
        }
        e2.material && "AllSame" !== e2.material.mappingType && (f2 = Xf(h2, n2, d2, e2.material)[0], f2 < 0 && (p2.negativeMaterialIndices = true, f2 = 0)), e2.uv && e2.uv.forEach(function(e3, t3) {
          const r3 = Xf(h2, n2, d2, e3);
          void 0 === l2[t3] && (l2[t3] = []), l2[t3].push(r3[0]), l2[t3].push(r3[1]);
        }), r2++, m2 && (r2 > 4 && console.warn("THREE.FBXLoader: Polygons with more than four sides are not supported. Make sure to triangulate the geometry during export."), p2.genFace(t2, e2, s2, f2, o2, a2, l2, c2, u2, r2), n2++, r2 = 0, s2 = [], o2 = [], a2 = [], l2 = [], c2 = [], u2 = []);
      }), t2;
    }
    genFace(e2, t2, n2, r2, i2, s2, o2, a2, l2, c2) {
      for (let u2 = 2; u2 < c2; u2++)
        e2.vertex.push(t2.vertexPositions[n2[0]]), e2.vertex.push(t2.vertexPositions[n2[1]]), e2.vertex.push(t2.vertexPositions[n2[2]]), e2.vertex.push(t2.vertexPositions[n2[3 * (u2 - 1)]]), e2.vertex.push(t2.vertexPositions[n2[3 * (u2 - 1) + 1]]), e2.vertex.push(t2.vertexPositions[n2[3 * (u2 - 1) + 2]]), e2.vertex.push(t2.vertexPositions[n2[3 * u2]]), e2.vertex.push(t2.vertexPositions[n2[3 * u2 + 1]]), e2.vertex.push(t2.vertexPositions[n2[3 * u2 + 2]]), t2.skeleton && (e2.vertexWeights.push(a2[0]), e2.vertexWeights.push(a2[1]), e2.vertexWeights.push(a2[2]), e2.vertexWeights.push(a2[3]), e2.vertexWeights.push(a2[4 * (u2 - 1)]), e2.vertexWeights.push(a2[4 * (u2 - 1) + 1]), e2.vertexWeights.push(a2[4 * (u2 - 1) + 2]), e2.vertexWeights.push(a2[4 * (u2 - 1) + 3]), e2.vertexWeights.push(a2[4 * u2]), e2.vertexWeights.push(a2[4 * u2 + 1]), e2.vertexWeights.push(a2[4 * u2 + 2]), e2.vertexWeights.push(a2[4 * u2 + 3]), e2.weightsIndices.push(l2[0]), e2.weightsIndices.push(l2[1]), e2.weightsIndices.push(l2[2]), e2.weightsIndices.push(l2[3]), e2.weightsIndices.push(l2[4 * (u2 - 1)]), e2.weightsIndices.push(l2[4 * (u2 - 1) + 1]), e2.weightsIndices.push(l2[4 * (u2 - 1) + 2]), e2.weightsIndices.push(l2[4 * (u2 - 1) + 3]), e2.weightsIndices.push(l2[4 * u2]), e2.weightsIndices.push(l2[4 * u2 + 1]), e2.weightsIndices.push(l2[4 * u2 + 2]), e2.weightsIndices.push(l2[4 * u2 + 3])), t2.color && (e2.colors.push(s2[0]), e2.colors.push(s2[1]), e2.colors.push(s2[2]), e2.colors.push(s2[3 * (u2 - 1)]), e2.colors.push(s2[3 * (u2 - 1) + 1]), e2.colors.push(s2[3 * (u2 - 1) + 2]), e2.colors.push(s2[3 * u2]), e2.colors.push(s2[3 * u2 + 1]), e2.colors.push(s2[3 * u2 + 2])), t2.material && "AllSame" !== t2.material.mappingType && (e2.materialIndex.push(r2), e2.materialIndex.push(r2), e2.materialIndex.push(r2)), t2.normal && (e2.normal.push(i2[0]), e2.normal.push(i2[1]), e2.normal.push(i2[2]), e2.normal.push(i2[3 * (u2 - 1)]), e2.normal.push(i2[3 * (u2 - 1) + 1]), e2.normal.push(i2[3 * (u2 - 1) + 2]), e2.normal.push(i2[3 * u2]), e2.normal.push(i2[3 * u2 + 1]), e2.normal.push(i2[3 * u2 + 2])), t2.uv && t2.uv.forEach(function(t3, n3) {
          void 0 === e2.uvs[n3] && (e2.uvs[n3] = []), e2.uvs[n3].push(o2[n3][0]), e2.uvs[n3].push(o2[n3][1]), e2.uvs[n3].push(o2[n3][2 * (u2 - 1)]), e2.uvs[n3].push(o2[n3][2 * (u2 - 1) + 1]), e2.uvs[n3].push(o2[n3][2 * u2]), e2.uvs[n3].push(o2[n3][2 * u2 + 1]);
        });
    }
    addMorphTargets(e2, t2, n2, r2) {
      if (0 === n2.length)
        return;
      e2.morphTargetsRelative = true, e2.morphAttributes.position = [];
      const i2 = this;
      n2.forEach(function(n3) {
        n3.rawTargets.forEach(function(n4) {
          const s2 = Bf.Objects.Geometry[n4.geoID];
          void 0 !== s2 && i2.genMorphGeometry(e2, t2, s2, r2, n4.name);
        });
      });
    }
    genMorphGeometry(e2, t2, r2, i2, s2) {
      const o2 = void 0 !== t2.PolygonVertexIndex ? t2.PolygonVertexIndex.a : [], a2 = void 0 !== r2.Vertices ? r2.Vertices.a : [], l2 = void 0 !== r2.Indexes ? r2.Indexes.a : [], c2 = 3 * e2.attributes.position.count, u2 = new Float32Array(c2);
      for (let e3 = 0; e3 < l2.length; e3++) {
        const t3 = 3 * l2[e3];
        u2[t3] = a2[3 * e3], u2[t3 + 1] = a2[3 * e3 + 1], u2[t3 + 2] = a2[3 * e3 + 2];
      }
      const p2 = { vertexIndices: o2, vertexPositions: u2 }, d2 = this.genBuffers(p2), h2 = new n.a$l(d2.vertex, 3);
      h2.name = s2 || r2.attrName, h2.applyMatrix4(i2), e2.morphAttributes.position.push(h2);
    }
    parseNormals(e2) {
      const t2 = e2.MappingInformationType, n2 = e2.ReferenceInformationType, r2 = e2.Normals.a;
      let i2 = [];
      return "IndexToDirect" === n2 && ("NormalIndex" in e2 ? i2 = e2.NormalIndex.a : "NormalsIndex" in e2 && (i2 = e2.NormalsIndex.a)), { dataSize: 3, buffer: r2, indices: i2, mappingType: t2, referenceType: n2 };
    }
    parseUVs(e2) {
      const t2 = e2.MappingInformationType, n2 = e2.ReferenceInformationType, r2 = e2.UV.a;
      let i2 = [];
      return "IndexToDirect" === n2 && (i2 = e2.UVIndex.a), { dataSize: 2, buffer: r2, indices: i2, mappingType: t2, referenceType: n2 };
    }
    parseVertexColors(e2) {
      const t2 = e2.MappingInformationType, r2 = e2.ReferenceInformationType, i2 = e2.Colors.a;
      let s2 = [];
      "IndexToDirect" === r2 && (s2 = e2.ColorIndex.a);
      for (let e3 = 0, t3 = new n.Ilk(); e3 < i2.length; e3 += 4)
        t3.fromArray(i2, e3).convertSRGBToLinear().toArray(i2, e3);
      return { dataSize: 4, buffer: i2, indices: s2, mappingType: t2, referenceType: r2 };
    }
    parseMaterialIndices(e2) {
      const t2 = e2.MappingInformationType, n2 = e2.ReferenceInformationType;
      if ("NoMappingInformation" === t2)
        return { dataSize: 1, buffer: [0], indices: [0], mappingType: "AllSame", referenceType: n2 };
      const r2 = e2.Materials.a, i2 = [];
      for (let e3 = 0; e3 < r2.length; ++e3)
        i2.push(e3);
      return { dataSize: 1, buffer: r2, indices: i2, mappingType: t2, referenceType: n2 };
    }
    parseNurbsGeometry(e2) {
      const t2 = parseInt(e2.Order);
      if (isNaN(t2))
        return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e2.Order, e2.id), new n.u9r();
      const r2 = t2 - 1, i2 = e2.KnotVector.a, s2 = [], o2 = e2.Points.a;
      for (let e3 = 0, t3 = o2.length; e3 < t3; e3 += 4)
        s2.push(new n.Ltg().fromArray(o2, e3));
      let a2, l2;
      if ("Closed" === e2.Form)
        s2.push(s2[0]);
      else if ("Periodic" === e2.Form) {
        a2 = r2, l2 = i2.length - 1 - a2;
        for (let e3 = 0; e3 < r2; ++e3)
          s2.push(s2[e3]);
      }
      const c2 = new Df(r2, i2, s2, a2, l2).getPoints(12 * s2.length);
      return new n.u9r().setFromPoints(c2);
    }
  }
  class jf {
    parse() {
      const e2 = [], t2 = this.parseClips();
      if (void 0 !== t2)
        for (const n2 in t2) {
          const r2 = t2[n2], i2 = this.addClip(r2);
          e2.push(i2);
        }
      return e2;
    }
    parseClips() {
      if (void 0 === Bf.Objects.AnimationCurve)
        return;
      const e2 = this.parseAnimationCurveNodes();
      this.parseAnimationCurves(e2);
      const t2 = this.parseAnimationLayers(e2);
      return this.parseAnimStacks(t2);
    }
    parseAnimationCurveNodes() {
      const e2 = Bf.Objects.AnimationCurveNode, t2 = /* @__PURE__ */ new Map();
      for (const n2 in e2) {
        const r2 = e2[n2];
        if (null !== r2.attrName.match(/S|R|T|DeformPercent/)) {
          const e3 = { id: r2.id, attr: r2.attrName, curves: {} };
          t2.set(e3.id, e3);
        }
      }
      return t2;
    }
    parseAnimationCurves(e2) {
      const t2 = Bf.Objects.AnimationCurve;
      for (const n2 in t2) {
        const r2 = { id: t2[n2].id, times: t2[n2].KeyTime.a.map(Wf), values: t2[n2].KeyValueFloat.a }, i2 = Of.get(r2.id);
        if (void 0 !== i2) {
          const t3 = i2.parents[0].ID, n3 = i2.parents[0].relationship;
          n3.match(/X/) ? e2.get(t3).curves.x = r2 : n3.match(/Y/) ? e2.get(t3).curves.y = r2 : n3.match(/Z/) ? e2.get(t3).curves.z = r2 : n3.match(/DeformPercent/) && e2.has(t3) && (e2.get(t3).curves.morph = r2);
        }
      }
    }
    parseAnimationLayers(e2) {
      const t2 = Bf.Objects.AnimationLayer, r2 = /* @__PURE__ */ new Map();
      for (const i2 in t2) {
        const t3 = [], s2 = Of.get(parseInt(i2));
        void 0 !== s2 && (s2.children.forEach(function(r3, i3) {
          if (e2.has(r3.ID)) {
            const s3 = e2.get(r3.ID);
            if (void 0 !== s3.curves.x || void 0 !== s3.curves.y || void 0 !== s3.curves.z) {
              if (void 0 === t3[i3]) {
                const e3 = Of.get(r3.ID).parents.filter(function(e4) {
                  return void 0 !== e4.relationship;
                })[0].ID;
                if (void 0 !== e3) {
                  const s4 = Bf.Objects.Model[e3.toString()];
                  if (void 0 === s4)
                    return void console.warn("THREE.FBXLoader: Encountered a unused curve.", r3);
                  const o2 = { modelName: s4.attrName ? n.iUV.sanitizeNodeName(s4.attrName) : "", ID: s4.id, initialPosition: [0, 0, 0], initialRotation: [0, 0, 0], initialScale: [1, 1, 1] };
                  Lf.traverse(function(e4) {
                    e4.ID === s4.id && (o2.transform = e4.matrix, e4.userData.transformData && (o2.eulerOrder = e4.userData.transformData.eulerOrder));
                  }), o2.transform || (o2.transform = new n.yGw()), "PreRotation" in s4 && (o2.preRotation = s4.PreRotation.value), "PostRotation" in s4 && (o2.postRotation = s4.PostRotation.value), t3[i3] = o2;
                }
              }
              t3[i3] && (t3[i3][s3.attr] = s3);
            } else if (void 0 !== s3.curves.morph) {
              if (void 0 === t3[i3]) {
                const e3 = Of.get(r3.ID).parents.filter(function(e4) {
                  return void 0 !== e4.relationship;
                })[0].ID, s4 = Of.get(e3).parents[0].ID, o2 = Of.get(s4).parents[0].ID, a2 = Of.get(o2).parents[0].ID, l2 = Bf.Objects.Model[a2], c2 = { modelName: l2.attrName ? n.iUV.sanitizeNodeName(l2.attrName) : "", morphName: Bf.Objects.Deformer[e3].attrName };
                t3[i3] = c2;
              }
              t3[i3][s3.attr] = s3;
            }
          }
        }), r2.set(parseInt(i2), t3));
      }
      return r2;
    }
    parseAnimStacks(e2) {
      const t2 = Bf.Objects.AnimationStack, n2 = {};
      for (const r2 in t2) {
        const i2 = Of.get(parseInt(r2)).children;
        i2.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
        const s2 = e2.get(i2[0].ID);
        n2[r2] = { name: t2[r2].attrName, layer: s2 };
      }
      return n2;
    }
    addClip(e2) {
      let t2 = [];
      const r2 = this;
      return e2.layer.forEach(function(e3) {
        t2 = t2.concat(r2.generateTracks(e3));
      }), new n.m7l(e2.name, -1, t2);
    }
    generateTracks(e2) {
      const t2 = [];
      let r2 = new n.Pa4(), i2 = new n._fP(), s2 = new n.Pa4();
      if (e2.transform && e2.transform.decompose(r2, i2, s2), r2 = r2.toArray(), i2 = new n.USm().setFromQuaternion(i2, e2.eulerOrder).toArray(), s2 = s2.toArray(), void 0 !== e2.T && Object.keys(e2.T.curves).length > 0) {
        const n2 = this.generateVectorTrack(e2.modelName, e2.T.curves, r2, "position");
        void 0 !== n2 && t2.push(n2);
      }
      if (void 0 !== e2.R && Object.keys(e2.R.curves).length > 0) {
        const n2 = this.generateRotationTrack(e2.modelName, e2.R.curves, i2, e2.preRotation, e2.postRotation, e2.eulerOrder);
        void 0 !== n2 && t2.push(n2);
      }
      if (void 0 !== e2.S && Object.keys(e2.S.curves).length > 0) {
        const n2 = this.generateVectorTrack(e2.modelName, e2.S.curves, s2, "scale");
        void 0 !== n2 && t2.push(n2);
      }
      if (void 0 !== e2.DeformPercent) {
        const n2 = this.generateMorphTrack(e2);
        void 0 !== n2 && t2.push(n2);
      }
      return t2;
    }
    generateVectorTrack(e2, t2, r2, i2) {
      const s2 = this.getTimesForAllAxes(t2), o2 = this.getKeyframeTrackValues(s2, t2, r2);
      return new n.yC1(e2 + "." + i2, s2, o2);
    }
    generateRotationTrack(e2, t2, r2, i2, s2, o2) {
      void 0 !== t2.x && (this.interpolateRotations(t2.x), t2.x.values = t2.x.values.map(n.M8C.degToRad)), void 0 !== t2.y && (this.interpolateRotations(t2.y), t2.y.values = t2.y.values.map(n.M8C.degToRad)), void 0 !== t2.z && (this.interpolateRotations(t2.z), t2.z.values = t2.z.values.map(n.M8C.degToRad));
      const a2 = this.getTimesForAllAxes(t2), l2 = this.getKeyframeTrackValues(a2, t2, r2);
      void 0 !== i2 && ((i2 = i2.map(n.M8C.degToRad)).push(o2), i2 = new n.USm().fromArray(i2), i2 = new n._fP().setFromEuler(i2)), void 0 !== s2 && ((s2 = s2.map(n.M8C.degToRad)).push(o2), s2 = new n.USm().fromArray(s2), s2 = new n._fP().setFromEuler(s2).invert());
      const c2 = new n._fP(), u2 = new n.USm(), p2 = [];
      for (let e3 = 0; e3 < l2.length; e3 += 3)
        u2.set(l2[e3], l2[e3 + 1], l2[e3 + 2], o2), c2.setFromEuler(u2), void 0 !== i2 && c2.premultiply(i2), void 0 !== s2 && c2.multiply(s2), c2.toArray(p2, e3 / 3 * 4);
      return new n.iLg(e2 + ".quaternion", a2, p2);
    }
    generateMorphTrack(e2) {
      const t2 = e2.DeformPercent.curves.morph, r2 = t2.values.map(function(e3) {
        return e3 / 100;
      }), i2 = Lf.getObjectByName(e2.modelName).morphTargetDictionary[e2.morphName];
      return new n.dUE(e2.modelName + ".morphTargetInfluences[" + i2 + "]", t2.times, r2);
    }
    getTimesForAllAxes(e2) {
      let t2 = [];
      if (void 0 !== e2.x && (t2 = t2.concat(e2.x.times)), void 0 !== e2.y && (t2 = t2.concat(e2.y.times)), void 0 !== e2.z && (t2 = t2.concat(e2.z.times)), t2 = t2.sort(function(e3, t3) {
        return e3 - t3;
      }), t2.length > 1) {
        let e3 = 1, n2 = t2[0];
        for (let r2 = 1; r2 < t2.length; r2++) {
          const i2 = t2[r2];
          i2 !== n2 && (t2[e3] = i2, n2 = i2, e3++);
        }
        t2 = t2.slice(0, e3);
      }
      return t2;
    }
    getKeyframeTrackValues(e2, t2, n2) {
      const r2 = n2, i2 = [];
      let s2 = -1, o2 = -1, a2 = -1;
      return e2.forEach(function(e3) {
        if (t2.x && (s2 = t2.x.times.indexOf(e3)), t2.y && (o2 = t2.y.times.indexOf(e3)), t2.z && (a2 = t2.z.times.indexOf(e3)), -1 !== s2) {
          const e4 = t2.x.values[s2];
          i2.push(e4), r2[0] = e4;
        } else
          i2.push(r2[0]);
        if (-1 !== o2) {
          const e4 = t2.y.values[o2];
          i2.push(e4), r2[1] = e4;
        } else
          i2.push(r2[1]);
        if (-1 !== a2) {
          const e4 = t2.z.values[a2];
          i2.push(e4), r2[2] = e4;
        } else
          i2.push(r2[2]);
      }), i2;
    }
    interpolateRotations(e2) {
      for (let t2 = 1; t2 < e2.values.length; t2++) {
        const n2 = e2.values[t2 - 1], r2 = e2.values[t2] - n2, i2 = Math.abs(r2);
        if (i2 >= 180) {
          const s2 = i2 / 180, o2 = r2 / s2;
          let a2 = n2 + o2;
          const l2 = e2.times[t2 - 1], c2 = (e2.times[t2] - l2) / s2;
          let u2 = l2 + c2;
          const p2 = [], d2 = [];
          for (; u2 < e2.times[t2]; )
            p2.push(u2), u2 += c2, d2.push(a2), a2 += o2;
          e2.times = tm(e2.times, t2, p2), e2.values = tm(e2.values, t2, d2);
        }
      }
    }
  }
  class zf {
    getPrevNode() {
      return this.nodeStack[this.currentIndent - 2];
    }
    getCurrentNode() {
      return this.nodeStack[this.currentIndent - 1];
    }
    getCurrentProp() {
      return this.currentProp;
    }
    pushStack(e2) {
      this.nodeStack.push(e2), this.currentIndent += 1;
    }
    popStack() {
      this.nodeStack.pop(), this.currentIndent -= 1;
    }
    setCurrentProp(e2, t2) {
      this.currentProp = e2, this.currentPropName = t2;
    }
    parse(e2) {
      this.currentIndent = 0, this.allNodes = new Hf(), this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
      const t2 = this, n2 = e2.split(/[\r\n]+/);
      return n2.forEach(function(e3, r2) {
        const i2 = e3.match(/^[\s\t]*;/), s2 = e3.match(/^[\s\t]*$/);
        if (i2 || s2)
          return;
        const o2 = e3.match("^\\t{" + t2.currentIndent + "}(\\w+):(.*){", ""), a2 = e3.match("^\\t{" + t2.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"), l2 = e3.match("^\\t{" + (t2.currentIndent - 1) + "}}");
        o2 ? t2.parseNodeBegin(e3, o2) : a2 ? t2.parseNodeProperty(e3, a2, n2[++r2]) : l2 ? t2.popStack() : e3.match(/^[^\s\t}]/) && t2.parseNodePropertyContinued(e3);
      }), this.allNodes;
    }
    parseNodeBegin(e2, t2) {
      const n2 = t2[1].trim().replace(/^"/, "").replace(/"$/, ""), r2 = t2[2].split(",").map(function(e3) {
        return e3.trim().replace(/^"/, "").replace(/"$/, "");
      }), i2 = { name: n2 }, s2 = this.parseNodeAttr(r2), o2 = this.getCurrentNode();
      0 === this.currentIndent ? this.allNodes.add(n2, i2) : n2 in o2 ? ("PoseNode" === n2 ? o2.PoseNode.push(i2) : void 0 !== o2[n2].id && (o2[n2] = {}, o2[n2][o2[n2].id] = o2[n2]), "" !== s2.id && (o2[n2][s2.id] = i2)) : "number" == typeof s2.id ? (o2[n2] = {}, o2[n2][s2.id] = i2) : "Properties70" !== n2 && (o2[n2] = "PoseNode" === n2 ? [i2] : i2), "number" == typeof s2.id && (i2.id = s2.id), "" !== s2.name && (i2.attrName = s2.name), "" !== s2.type && (i2.attrType = s2.type), this.pushStack(i2);
    }
    parseNodeAttr(e2) {
      let t2 = e2[0];
      "" !== e2[0] && (t2 = parseInt(e2[0]), isNaN(t2) && (t2 = e2[0]));
      let n2 = "", r2 = "";
      return e2.length > 1 && (n2 = e2[1].replace(/^(\w+)::/, ""), r2 = e2[2]), { id: t2, name: n2, type: r2 };
    }
    parseNodeProperty(e2, t2, n2) {
      let r2 = t2[1].replace(/^"/, "").replace(/"$/, "").trim(), i2 = t2[2].replace(/^"/, "").replace(/"$/, "").trim();
      "Content" === r2 && "," === i2 && (i2 = n2.replace(/"/g, "").replace(/,$/, "").trim());
      const s2 = this.getCurrentNode();
      if ("Properties70" !== s2.name) {
        if ("C" === r2) {
          const e3 = i2.split(",").slice(1), t3 = parseInt(e3[0]), n3 = parseInt(e3[1]);
          let o2 = i2.split(",").slice(3);
          o2 = o2.map(function(e4) {
            return e4.trim().replace(/^"/, "");
          }), r2 = "connections", i2 = [t3, n3], function(e4, t4) {
            for (let n4 = 0, r3 = e4.length, i3 = t4.length; n4 < i3; n4++, r3++)
              e4[r3] = t4[n4];
          }(i2, o2), void 0 === s2[r2] && (s2[r2] = []);
        }
        "Node" === r2 && (s2.id = i2), r2 in s2 && Array.isArray(s2[r2]) ? s2[r2].push(i2) : "a" !== r2 ? s2[r2] = i2 : s2.a = i2, this.setCurrentProp(s2, r2), "a" === r2 && "," !== i2.slice(-1) && (s2.a = $f(i2));
      } else
        this.parseNodeSpecialProperty(e2, r2, i2);
    }
    parseNodePropertyContinued(e2) {
      const t2 = this.getCurrentNode();
      t2.a += e2, "," !== e2.slice(-1) && (t2.a = $f(t2.a));
    }
    parseNodeSpecialProperty(e2, t2, n2) {
      const r2 = n2.split('",').map(function(e3) {
        return e3.trim().replace(/^\"/, "").replace(/\s/, "_");
      }), i2 = r2[0], s2 = r2[1], o2 = r2[2], a2 = r2[3];
      let l2 = r2[4];
      switch (s2) {
        case "int":
        case "enum":
        case "bool":
        case "ULongLong":
        case "double":
        case "Number":
        case "FieldOfView":
          l2 = parseFloat(l2);
          break;
        case "Color":
        case "ColorRGB":
        case "Vector3D":
        case "Lcl_Translation":
        case "Lcl_Rotation":
        case "Lcl_Scaling":
          l2 = $f(l2);
      }
      this.getPrevNode()[i2] = { type: s2, type2: o2, flag: a2, value: l2 }, this.setCurrentProp(this.getPrevNode(), i2);
    }
  }
  class Gf {
    parse(e2) {
      const t2 = new Vf(e2);
      t2.skip(23);
      const n2 = t2.getUint32();
      if (n2 < 6400)
        throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + n2);
      const r2 = new Hf();
      for (; !this.endOfContent(t2); ) {
        const e3 = this.parseNode(t2, n2);
        null !== e3 && r2.add(e3.name, e3);
      }
      return r2;
    }
    endOfContent(e2) {
      return e2.size() % 16 == 0 ? (e2.getOffset() + 160 + 16 & -16) >= e2.size() : e2.getOffset() + 160 + 16 >= e2.size();
    }
    parseNode(e2, t2) {
      const n2 = {}, r2 = t2 >= 7500 ? e2.getUint64() : e2.getUint32(), i2 = t2 >= 7500 ? e2.getUint64() : e2.getUint32();
      t2 >= 7500 ? e2.getUint64() : e2.getUint32();
      const s2 = e2.getUint8(), o2 = e2.getString(s2);
      if (0 === r2)
        return null;
      const a2 = [];
      for (let t3 = 0; t3 < i2; t3++)
        a2.push(this.parseProperty(e2));
      const l2 = a2.length > 0 ? a2[0] : "", c2 = a2.length > 1 ? a2[1] : "", u2 = a2.length > 2 ? a2[2] : "";
      for (n2.singleProperty = 1 === i2 && e2.getOffset() === r2; r2 > e2.getOffset(); ) {
        const r3 = this.parseNode(e2, t2);
        null !== r3 && this.parseSubNode(o2, n2, r3);
      }
      return n2.propertyList = a2, "number" == typeof l2 && (n2.id = l2), "" !== c2 && (n2.attrName = c2), "" !== u2 && (n2.attrType = u2), "" !== o2 && (n2.name = o2), n2;
    }
    parseSubNode(e2, t2, n2) {
      if (true === n2.singleProperty) {
        const e3 = n2.propertyList[0];
        Array.isArray(e3) ? (t2[n2.name] = n2, n2.a = e3) : t2[n2.name] = e3;
      } else if ("Connections" === e2 && "C" === n2.name) {
        const e3 = [];
        n2.propertyList.forEach(function(t3, n3) {
          0 !== n3 && e3.push(t3);
        }), void 0 === t2.connections && (t2.connections = []), t2.connections.push(e3);
      } else if ("Properties70" === n2.name)
        Object.keys(n2).forEach(function(e3) {
          t2[e3] = n2[e3];
        });
      else if ("Properties70" === e2 && "P" === n2.name) {
        let e3 = n2.propertyList[0], r2 = n2.propertyList[1];
        const i2 = n2.propertyList[2], s2 = n2.propertyList[3];
        let o2;
        0 === e3.indexOf("Lcl ") && (e3 = e3.replace("Lcl ", "Lcl_")), 0 === r2.indexOf("Lcl ") && (r2 = r2.replace("Lcl ", "Lcl_")), o2 = "Color" === r2 || "ColorRGB" === r2 || "Vector" === r2 || "Vector3D" === r2 || 0 === r2.indexOf("Lcl_") ? [n2.propertyList[4], n2.propertyList[5], n2.propertyList[6]] : n2.propertyList[4], t2[e3] = { type: r2, type2: i2, flag: s2, value: o2 };
      } else
        void 0 === t2[n2.name] ? "number" == typeof n2.id ? (t2[n2.name] = {}, t2[n2.name][n2.id] = n2) : t2[n2.name] = n2 : "PoseNode" === n2.name ? (Array.isArray(t2[n2.name]) || (t2[n2.name] = [t2[n2.name]]), t2[n2.name].push(n2)) : void 0 === t2[n2.name][n2.id] && (t2[n2.name][n2.id] = n2);
    }
    parseProperty(e2) {
      const t2 = e2.getString(1);
      let n2;
      switch (t2) {
        case "C":
          return e2.getBoolean();
        case "D":
          return e2.getFloat64();
        case "F":
          return e2.getFloat32();
        case "I":
          return e2.getInt32();
        case "L":
          return e2.getInt64();
        case "R":
          return n2 = e2.getUint32(), e2.getArrayBuffer(n2);
        case "S":
          return n2 = e2.getUint32(), e2.getString(n2);
        case "Y":
          return e2.getInt16();
        case "b":
        case "c":
        case "d":
        case "f":
        case "i":
        case "l":
          const r2 = e2.getUint32(), i2 = e2.getUint32(), s2 = e2.getUint32();
          if (0 === i2)
            switch (t2) {
              case "b":
              case "c":
                return e2.getBooleanArray(r2);
              case "d":
                return e2.getFloat64Array(r2);
              case "f":
                return e2.getFloat32Array(r2);
              case "i":
                return e2.getInt32Array(r2);
              case "l":
                return e2.getInt64Array(r2);
            }
          const o2 = Pf(new Uint8Array(e2.getArrayBuffer(s2))), a2 = new Vf(o2.buffer);
          switch (t2) {
            case "b":
            case "c":
              return a2.getBooleanArray(r2);
            case "d":
              return a2.getFloat64Array(r2);
            case "f":
              return a2.getFloat32Array(r2);
            case "i":
              return a2.getInt32Array(r2);
            case "l":
              return a2.getInt64Array(r2);
          }
          break;
        default:
          throw new Error("THREE.FBXLoader: Unknown property type " + t2);
      }
    }
  }
  class Vf {
    constructor(e2, t2) {
      this.dv = new DataView(e2), this.offset = 0, this.littleEndian = void 0 === t2 || t2, this._textDecoder = new TextDecoder();
    }
    getOffset() {
      return this.offset;
    }
    size() {
      return this.dv.buffer.byteLength;
    }
    skip(e2) {
      this.offset += e2;
    }
    getBoolean() {
      return 1 == (1 & this.getUint8());
    }
    getBooleanArray(e2) {
      const t2 = [];
      for (let n2 = 0; n2 < e2; n2++)
        t2.push(this.getBoolean());
      return t2;
    }
    getUint8() {
      const e2 = this.dv.getUint8(this.offset);
      return this.offset += 1, e2;
    }
    getInt16() {
      const e2 = this.dv.getInt16(this.offset, this.littleEndian);
      return this.offset += 2, e2;
    }
    getInt32() {
      const e2 = this.dv.getInt32(this.offset, this.littleEndian);
      return this.offset += 4, e2;
    }
    getInt32Array(e2) {
      const t2 = [];
      for (let n2 = 0; n2 < e2; n2++)
        t2.push(this.getInt32());
      return t2;
    }
    getUint32() {
      const e2 = this.dv.getUint32(this.offset, this.littleEndian);
      return this.offset += 4, e2;
    }
    getInt64() {
      let e2, t2;
      return this.littleEndian ? (e2 = this.getUint32(), t2 = this.getUint32()) : (t2 = this.getUint32(), e2 = this.getUint32()), 2147483648 & t2 ? (t2 = 4294967295 & ~t2, e2 = 4294967295 & ~e2, 4294967295 === e2 && (t2 = t2 + 1 & 4294967295), e2 = e2 + 1 & 4294967295, -(4294967296 * t2 + e2)) : 4294967296 * t2 + e2;
    }
    getInt64Array(e2) {
      const t2 = [];
      for (let n2 = 0; n2 < e2; n2++)
        t2.push(this.getInt64());
      return t2;
    }
    getUint64() {
      let e2, t2;
      return this.littleEndian ? (e2 = this.getUint32(), t2 = this.getUint32()) : (t2 = this.getUint32(), e2 = this.getUint32()), 4294967296 * t2 + e2;
    }
    getFloat32() {
      const e2 = this.dv.getFloat32(this.offset, this.littleEndian);
      return this.offset += 4, e2;
    }
    getFloat32Array(e2) {
      const t2 = [];
      for (let n2 = 0; n2 < e2; n2++)
        t2.push(this.getFloat32());
      return t2;
    }
    getFloat64() {
      const e2 = this.dv.getFloat64(this.offset, this.littleEndian);
      return this.offset += 8, e2;
    }
    getFloat64Array(e2) {
      const t2 = [];
      for (let n2 = 0; n2 < e2; n2++)
        t2.push(this.getFloat64());
      return t2;
    }
    getArrayBuffer(e2) {
      const t2 = this.dv.buffer.slice(this.offset, this.offset + e2);
      return this.offset += e2, t2;
    }
    getString(e2) {
      const t2 = this.offset;
      let n2 = new Uint8Array(this.dv.buffer, t2, e2);
      this.skip(e2);
      const r2 = n2.indexOf(0);
      return r2 >= 0 && (n2 = new Uint8Array(this.dv.buffer, t2, r2)), this._textDecoder.decode(n2);
    }
  }
  class Hf {
    add(e2, t2) {
      this[e2] = t2;
    }
  }
  function Qf(e2) {
    const t2 = e2.match(/FBXVersion: (\d+)/);
    if (t2)
      return parseInt(t2[1]);
    throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
  }
  function Wf(e2) {
    return e2 / 46186158e3;
  }
  const qf = [];
  function Xf(e2, t2, n2, r2) {
    let i2;
    switch (r2.mappingType) {
      case "ByPolygonVertex":
        i2 = e2;
        break;
      case "ByPolygon":
        i2 = t2;
        break;
      case "ByVertice":
        i2 = n2;
        break;
      case "AllSame":
        i2 = r2.indices[0];
        break;
      default:
        console.warn("THREE.FBXLoader: unknown attribute mapping type " + r2.mappingType);
    }
    "IndexToDirect" === r2.referenceType && (i2 = r2.indices[i2]);
    const s2 = i2 * r2.dataSize, o2 = s2 + r2.dataSize;
    return function(e3, t3, n3, r3) {
      for (let i3 = n3, s3 = 0; i3 < r3; i3++, s3++)
        e3[s3] = t3[i3];
      return e3;
    }(qf, r2.buffer, s2, o2);
  }
  const Yf = new n.USm(), Kf = new n.Pa4();
  function Jf(e2) {
    const t2 = new n.yGw(), r2 = new n.yGw(), i2 = new n.yGw(), s2 = new n.yGw(), o2 = new n.yGw(), a2 = new n.yGw(), l2 = new n.yGw(), c2 = new n.yGw(), u2 = new n.yGw(), p2 = new n.yGw(), d2 = new n.yGw(), h2 = new n.yGw(), f2 = e2.inheritType ? e2.inheritType : 0;
    if (e2.translation && t2.setPosition(Kf.fromArray(e2.translation)), e2.preRotation) {
      const t3 = e2.preRotation.map(n.M8C.degToRad);
      t3.push(e2.eulerOrder || n.USm.DEFAULT_ORDER), r2.makeRotationFromEuler(Yf.fromArray(t3));
    }
    if (e2.rotation) {
      const t3 = e2.rotation.map(n.M8C.degToRad);
      t3.push(e2.eulerOrder || n.USm.DEFAULT_ORDER), i2.makeRotationFromEuler(Yf.fromArray(t3));
    }
    if (e2.postRotation) {
      const t3 = e2.postRotation.map(n.M8C.degToRad);
      t3.push(e2.eulerOrder || n.USm.DEFAULT_ORDER), s2.makeRotationFromEuler(Yf.fromArray(t3)), s2.invert();
    }
    e2.scale && o2.scale(Kf.fromArray(e2.scale)), e2.scalingOffset && l2.setPosition(Kf.fromArray(e2.scalingOffset)), e2.scalingPivot && a2.setPosition(Kf.fromArray(e2.scalingPivot)), e2.rotationOffset && c2.setPosition(Kf.fromArray(e2.rotationOffset)), e2.rotationPivot && u2.setPosition(Kf.fromArray(e2.rotationPivot)), e2.parentMatrixWorld && (d2.copy(e2.parentMatrix), p2.copy(e2.parentMatrixWorld));
    const m2 = r2.clone().multiply(i2).multiply(s2), _2 = new n.yGw();
    _2.extractRotation(p2);
    const g2 = new n.yGw();
    g2.copyPosition(p2);
    const v2 = g2.clone().invert().multiply(p2), y2 = _2.clone().invert().multiply(v2), b2 = o2, w2 = new n.yGw();
    if (0 === f2)
      w2.copy(_2).multiply(m2).multiply(y2).multiply(b2);
    else if (1 === f2)
      w2.copy(_2).multiply(y2).multiply(m2).multiply(b2);
    else {
      const e3 = new n.yGw().scale(new n.Pa4().setFromMatrixScale(d2)).clone().invert(), t3 = y2.clone().multiply(e3);
      w2.copy(_2).multiply(m2).multiply(t3).multiply(b2);
    }
    const A2 = u2.clone().invert(), x2 = a2.clone().invert();
    let E2 = t2.clone().multiply(c2).multiply(u2).multiply(r2).multiply(i2).multiply(s2).multiply(A2).multiply(l2).multiply(a2).multiply(o2).multiply(x2);
    const C2 = new n.yGw().copyPosition(E2), S2 = p2.clone().multiply(C2);
    return h2.copyPosition(S2), E2 = h2.clone().multiply(w2), E2.premultiply(p2.invert()), E2;
  }
  function Zf(e2) {
    const t2 = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"];
    return 6 === (e2 = e2 || 0) ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), t2[0]) : t2[e2];
  }
  function $f(e2) {
    return e2.split(",").map(function(e3) {
      return parseFloat(e3);
    });
  }
  function em(e2, t2, n2) {
    return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = e2.byteLength), new TextDecoder().decode(new Uint8Array(e2, t2, n2));
  }
  function tm(e2, t2, n2) {
    return e2.slice(0, t2).concat(n2).concat(e2.slice(t2));
  }
  class nm extends t.SimpleEventDispatcher {
    constructor() {
      super(...arguments), this.dependencies = [Ls], this._importer = new Ft(Uf, ["fbx"], true);
    }
    async onAdded(e2) {
      var t2, n2;
      null === (n2 = null === (t2 = e2.getManager()) || void 0 === t2 ? void 0 : t2.importer) || void 0 === n2 || n2.Importers.push(this._importer);
    }
    async onDispose(e2) {
    }
    async onRemove(e2) {
      var t2, n2, r2, i2;
      (null === (n2 = null === (t2 = e2.getManager()) || void 0 === t2 ? void 0 : t2.importer) || void 0 === n2 ? void 0 : n2.Importers) && (null === (i2 = null === (r2 = e2.getManager()) || void 0 === r2 ? void 0 : r2.importer) || void 0 === i2 || i2.Importers.splice(e2.getManager().importer.Importers.indexOf(this._importer), 1));
    }
  }
  nm.PluginType = "FBXLoadPlugin";
  const rm = new n.cPb(45, 1, 0.1, 1e3);
  function im(e2, t2, r2, i2 = 7, s2 = new n.Pa4(0, 0, 1.5)) {
    r2 = null != r2 ? r2 : e2.scene.modelObject;
    const o2 = new h().expandByObject(null != r2 ? r2 : t2, true, true), a2 = o2.getCenter(new n.Pa4()), l2 = o2.getSize(new n.Pa4());
    rm.position.copy(a2).add(s2.clone().multiplyScalar(Math.max(l2.x, l2.y, l2.z))), rm.lookAt(a2), t2 && t2.traverseVisible((e3) => {
      e3.layers.enable(i2);
    }), i2 > 0 ? rm.layers.set(i2) : rm.layers.enableAll();
    const c2 = null == t2 ? void 0 : t2.visible;
    t2 && (t2.visible = true), e2.renderer.rendererObject.setRenderTarget(null), e2.renderer.rendererObject.render(r2, rm);
    const u2 = e2.renderer.rendererObject.domElement.toDataURL("image/png");
    return t2 && (t2.visible = c2, t2.traverseVisible((e3) => {
      e3.layers.disable(i2);
    }), rm.layers.enableAll()), e2.setDirty(), u2;
  }
  class sm {
    constructor(e2) {
      this.viewer = e2, this._lights = [], this.shapes = { sphere: new n.Kj0(new n.xo$(1)), cube: new n.Kj0(new n.DvJ(1, 1, 1)), cylinder: new n.Kj0(new n.fHI(0.5, 0.5, 1)) };
      const t2 = new n.xsS();
      this._channel = 7;
      const r2 = new n.vmT(16777215, 4473924, 1);
      r2.position.set(0, 10, 0), r2.layers.set(this._channel), t2.add(r2), this._lights.push(r2), this._scene = t2;
    }
    dispose() {
      [...this._lights].forEach((e2) => e2.dispose()), Object.values(this.shapes).forEach((e2) => {
        e2.geometry && e2.geometry.dispose();
      });
    }
    generate(e2, t2 = "sphere") {
      const r2 = this.shapes[t2] || new n.Kj0(new n.xo$(1));
      r2.material = e2.materialObject, r2.geometry.attributes.tangent || r2.geometry.computeTangents(), this._scene.add(r2), this._scene.environment = this.viewer.scene.environment;
      const i2 = r2.material.envMapIntensity;
      "number" == typeof i2 && (r2.material.envMapIntensity = Math.max(i2, 2));
      const s2 = im(this.viewer, r2, this._scene, this._channel, new n.Pa4(0, 0, 1.5));
      return "number" == typeof i2 && (r2.material.envMapIntensity = i2), this._scene.remove(r2), r2.material = void 0, s2;
    }
  }
  class om extends gt {
    constructor() {
      super(), this.enabled = true, this._uiNeedRefresh = false, this.applyOnLoad = true, this._refreshUiConfig = () => {
        var e2, t2;
        this.enabled && (null === (t2 = (e2 = this.uiConfig).uiRefresh) || void 0 === t2 || t2.call(e2));
      }, this.dependencies = [Ls], this.variations = [], this._selectedMaterial = () => {
        var e2, t2;
        return (null === (t2 = null === (e2 = this._picking) || void 0 === e2 ? void 0 : e2.getSelectedObject()) || void 0 === t2 ? void 0 : t2.material) || void 0;
      }, this.uiConfig = { label: "Material Configurator", type: "folder", children: [() => {
        var e2;
        return [{ type: "input", label: "uuid", property: [this._selectedMaterial(), "uuid"], hidden: () => !this._selectedMaterial(), disabled: true }, { type: "input", label: "mapping", hidden: () => !this._selectedMaterial(), property: () => [this.getSelectedVariation(), "uuid"], onChange: async () => this.refreshUi() }, { type: "input", label: "title", hidden: () => !this._selectedMaterial(), property: () => [this.getSelectedVariation(), "title"], onChange: async () => this.refreshUi() }, { type: "dropdown", label: "Preview Type", hidden: () => !this._selectedMaterial(), property: () => [this.getSelectedVariation(), "preview"], onChange: async () => this.refreshUi(), children: ["generate:sphere", "generate:cube", "color", "map", "emissive", ...Object.keys(Tt).filter((e3) => e3.endsWith("Map"))].map((e3) => ({ label: e3, value: e3 })) }, ...(null === (e2 = this.getSelectedVariation()) || void 0 === e2 ? void 0 : e2.materials.map((e3) => e3.uiConfig ? Object.assign(e3.uiConfig, { expanded: false }) : {})) || [], { type: "button", label: "Remove variations", hidden: () => !this._selectedMaterial(), value: async () => {
          const e3 = this.getSelectedVariation();
          e3 && await this._viewer.confirm("Material configurator: Remove all variations for this material?") && (e3.materials = []), this.refreshUi();
        } }, { type: "button", label: "Remove completely", hidden: () => !this._selectedMaterial(), value: async () => {
          const e3 = this.getSelectedVariation();
          e3 && await this._viewer.confirm("Material configurator: Remove this variation?") && this.removeVariation(e3);
        } }, { type: "button", label: "Add Variation", hidden: () => !this._selectedMaterial(), value: () => this.addVariation(this._selectedMaterial()) }, { type: "button", label: "Refresh Ui", value: () => this.refreshUi() }, { type: "button", label: "Apply All", value: () => {
          this.variations.forEach((e3) => this.applyVariation(e3, e3.materials[0].uuid));
        } }];
      }] }, this.addEventListener("deserialize", this.refreshUi), this.refreshUi = this.refreshUi.bind(this), this._refreshUi = this._refreshUi.bind(this);
    }
    async onAdded(e2) {
      var t2, n2;
      await super.onAdded(e2), this._picking = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPluginByType("Picking"), this._previewGenerator = new sm(this._viewer), null === (n2 = this._picking) || void 0 === n2 || n2.addEventListener("selectedObjectChanged", this._refreshUiConfig), e2.addEventListener("preFrame", this._refreshUi);
    }
    reapplyAll() {
      this.variations.forEach((e2) => {
        var t2;
        return this.applyVariation(e2, e2.materials[null !== (t2 = e2.selectedIndex) && void 0 !== t2 ? t2 : 0].uuid);
      });
    }
    fromJSON(e2, t2) {
      return this.variations = [], super.fromJSON(e2, t2) ? (void 0 === e2.applyOnLoad && (this.applyOnLoad = false), this.applyOnLoad && this.reapplyAll(), this) : null;
    }
    async onRemove(e2) {
      var t2, n2;
      return null === (t2 = this._previewGenerator) || void 0 === t2 || t2.dispose(), this._previewGenerator = void 0, null === (n2 = this._picking) || void 0 === n2 || n2.removeEventListener("selectedObjectChanged", this._refreshUiConfig), this.removeEventListener("deserialize", this.refreshUi), e2.removeEventListener("preFrame", this._refreshUi), this._picking = void 0, super.onRemove(e2);
    }
    findVariation(e2) {
      return e2 ? this.variations.find((t2) => t2.uuid === e2) : void 0;
    }
    getSelectedVariation() {
      var e2, t2;
      return this.findVariation(null === (e2 = this._selectedMaterial()) || void 0 === e2 ? void 0 : e2.uuid) || this.findVariation(null === (t2 = this._selectedMaterial()) || void 0 === t2 ? void 0 : t2.name);
    }
    applyVariation(e2, t2) {
      var n2, r2;
      const i2 = e2.materials.find((e3) => e3.uuid === t2), s2 = null === (r2 = null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.getManager()) || void 0 === r2 ? void 0 : r2.materials;
      return !!s2 && !!i2 && (e2.selectedIndex = e2.materials.indexOf(i2), s2.applyMaterial(i2, e2.uuid));
    }
    refreshUi() {
      this.enabled && (this._uiNeedRefresh = true);
    }
    async _refreshUi() {
      return !(!this.enabled || !this._viewer || !this._uiNeedRefresh || (this._uiNeedRefresh = false, this._refreshUiConfig(), 0));
    }
    removeVariationForMaterial(e2) {
      let t2 = this.findVariation(e2.uuid);
      !t2 && e2.name.length > 0 && (t2 = this.findVariation(e2.name)), t2 && this.removeVariation(t2);
    }
    removeVariation(e2) {
      e2 && (this.variations.splice(this.variations.indexOf(e2), 1), this.refreshUi());
    }
    addVariation(e2) {
      var t2;
      const n2 = null === (t2 = null == e2 ? void 0 : e2.clone) || void 0 === t2 ? void 0 : t2.call(e2);
      if (e2 && n2) {
        let t3 = this.findVariation(e2.uuid);
        !t3 && e2.name.length > 0 && (t3 = this.findVariation(e2.name)), t3 || this.variations.push(t3 = { uuid: e2.name.length > 0 ? e2.name : e2.uuid, title: e2.name.length > 0 ? e2.name : "No Name", preview: "generate:sphere", materials: [] }), t3.materials.push(n2), this.refreshUi();
      }
    }
  }
  om.PluginType = "MaterialConfiguratorPlugin", function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    s2 > 3 && o2 && Object.defineProperty(t2, n2, o2);
  }([ie()], om.prototype, "variations", void 0);
  class am {
    static _initializeStyles() {
      (0, t.createStyles)(t.css`
  .customContextGrid {
    background: #eeeeee55;
    border: 0.5px solid rgba(220, 220, 220, 0.2);
    width: auto;
    height: auto;
    position: absolute;
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    z-index: 200;
    padding: 0.35rem 0.35rem;
    border-radius: 0.375rem;
    min-width: 5rem;
    pointer-events: auto;
    box-shadow: 0px 2px 6px rgba(12, 12, 12, 0.2);

    color: #111111;
    font-size: 0.65rem;
    font-family: Inter, "Roboto Mono", "Source Code Pro", Menlo, Courier, monospace;
    backdrop-filter: blur(20px);
  }
  .customContextGridItems {
    background-color: transparent;
    cursor: pointer;
    border-radius: 0.25rem;
    line-height: 1rem;
    font-weight: 500;
    overflow: hidden;
    margin: 0.12rem;
  }

  .customContextGridItems:hover {
    color: white;
    //background-color: #017AFF;
    box-shadow: 0 0 7px 0px rgba(64, 64, 64, 0.3);
  }
  .customContextGridItemImage{
    width: 100%;
    height: 100%;
  }
  .customContextGridHeading{
    width: 100%;
    padding: 5px;
    font-size: 0.85rem;
  }
  .customContextGridParent{
    position: absolute;
    top: 0;
    left: 0;
    width: 270px;
    height: calc(100% - 100px);
    overflow-y: scroll;
    z-index: 100;
    display: flex;
    flex-direction: column;
    margin-bottom: 50px;
    margin-top: 50px;
  }
  /* Hide scrollbar for Chrome, Safari and Opera */
  .customContextGridParent::-webkit-scrollbar {
    display: none;
  }
  /* Hide scrollbar for IE, Edge and Firefox */
  .customContextGridParent {
    -ms-overflow-style: none;  /* IE and Edge */
    scrollbar-width: none;  /* Firefox */
  }

        `, this._container), this._container.style.position = "absolute", this._container.style.top = "0", this._container.style.left = "0", this._container.style.width = "270px", this._container.style.height = "100%", this._container.style.pointerEvents = "none", this._container.style.zIndex = "100", this._container.style.overflowY = "auto";
    }
    static Create(e2, n2, r2, i2, s2, o2, a2) {
      var l2;
      const c2 = (0, t.mobileAndTabletCheck)(), u2 = c2 ? 0.15 : 0.25, p2 = c2 ? 1.5 : 2.5, d2 = (0, t.createDiv)({ classList: ["customContextGrid"], addToBody: false, innerHTML: `
            <div class="customContextGridHeading"> ${n2} </div>
            ` });
      d2.style.top = s2 + "px", d2.style.left = i2 + "px", d2.style.gap = u2 + "rem", d2.style.width = (p2 + u2) * r2 - u2 + "rem", d2.dataset.tag = e2;
      for (const e3 of o2) {
        const n3 = (0, t.createDiv)({ classList: ["customContextGridItems"], addToBody: false, innerHTML: `
            <img src="${e3.image}" class="customContextGridItemImage">
            ` });
        n3.style.width = p2 + "rem", n3.style.height = p2 + "rem", d2.appendChild(n3), n3.onclick = () => {
          var t2;
          return null === (t2 = e3.onClick) || void 0 === t2 ? void 0 : t2.call(e3, e3.id);
        }, a2(n3, e3, d2);
      }
      return null === (l2 = this.Elements) || void 0 === l2 || l2.push(d2), d2;
    }
    static RemoveAll(e2) {
      if (e2) {
        const t2 = this.Elements.filter((t3) => t3.dataset.tag === e2);
        for (const e3 of t2)
          e3.remove();
        this.Elements = this.Elements.filter((t3) => t3.dataset.tag !== e2);
      } else {
        for (const e3 of this.Elements)
          e3.remove();
        this.Elements = [];
      }
    }
    static RebuildUi(e2) {
      if (0 === this.Elements.length)
        return;
      e2 || (e2 = (0, t.createDiv)({ addToBody: true, classList: ["customContextGridParent"] }));
      for (const e3 of this.Elements)
        e3.remove();
      this._container.innerHTML = "", this._initializeStyles();
      let n2 = 20;
      e2.appendChild(this._container);
      for (const e3 of this.Elements)
        e3.style.top = n2 + "px", this._container.appendChild(e3), n2 += e3.clientHeight + 20;
    }
  }
  function lm(e2) {
    if (null == e2)
      return window;
    if ("[object Window]" !== e2.toString()) {
      var t2 = e2.ownerDocument;
      return t2 && t2.defaultView || window;
    }
    return e2;
  }
  function cm(e2) {
    return e2 instanceof lm(e2).Element || e2 instanceof Element;
  }
  function um(e2) {
    return e2 instanceof lm(e2).HTMLElement || e2 instanceof HTMLElement;
  }
  function pm(e2) {
    return "undefined" != typeof ShadowRoot && (e2 instanceof lm(e2).ShadowRoot || e2 instanceof ShadowRoot);
  }
  am.Elements = [], am._container = document.createElement("div");
  var dm = Math.max, hm = Math.min, fm = Math.round;
  function mm() {
    var e2 = navigator.userAgentData;
    return null != e2 && e2.brands ? e2.brands.map(function(e3) {
      return e3.brand + "/" + e3.version;
    }).join(" ") : navigator.userAgent;
  }
  function _m() {
    return !/^((?!chrome|android).)*safari/i.test(mm());
  }
  function gm(e2, t2, n2) {
    void 0 === t2 && (t2 = false), void 0 === n2 && (n2 = false);
    var r2 = e2.getBoundingClientRect(), i2 = 1, s2 = 1;
    t2 && um(e2) && (i2 = e2.offsetWidth > 0 && fm(r2.width) / e2.offsetWidth || 1, s2 = e2.offsetHeight > 0 && fm(r2.height) / e2.offsetHeight || 1);
    var o2 = (cm(e2) ? lm(e2) : window).visualViewport, a2 = !_m() && n2, l2 = (r2.left + (a2 && o2 ? o2.offsetLeft : 0)) / i2, c2 = (r2.top + (a2 && o2 ? o2.offsetTop : 0)) / s2, u2 = r2.width / i2, p2 = r2.height / s2;
    return { width: u2, height: p2, top: c2, right: l2 + u2, bottom: c2 + p2, left: l2, x: l2, y: c2 };
  }
  function vm(e2) {
    var t2 = lm(e2);
    return { scrollLeft: t2.pageXOffset, scrollTop: t2.pageYOffset };
  }
  function ym(e2) {
    return e2 ? (e2.nodeName || "").toLowerCase() : null;
  }
  function bm(e2) {
    return ((cm(e2) ? e2.ownerDocument : e2.document) || window.document).documentElement;
  }
  function wm(e2) {
    return gm(bm(e2)).left + vm(e2).scrollLeft;
  }
  function Am(e2) {
    return lm(e2).getComputedStyle(e2);
  }
  function xm(e2) {
    var t2 = Am(e2), n2 = t2.overflow, r2 = t2.overflowX, i2 = t2.overflowY;
    return /auto|scroll|overlay|hidden/.test(n2 + i2 + r2);
  }
  function Em(e2, t2, n2) {
    void 0 === n2 && (n2 = false);
    var r2, i2, s2 = um(t2), o2 = um(t2) && function(e3) {
      var t3 = e3.getBoundingClientRect(), n3 = fm(t3.width) / e3.offsetWidth || 1, r3 = fm(t3.height) / e3.offsetHeight || 1;
      return 1 !== n3 || 1 !== r3;
    }(t2), a2 = bm(t2), l2 = gm(e2, o2, n2), c2 = { scrollLeft: 0, scrollTop: 0 }, u2 = { x: 0, y: 0 };
    return (s2 || !s2 && !n2) && (("body" !== ym(t2) || xm(a2)) && (c2 = (r2 = t2) !== lm(r2) && um(r2) ? { scrollLeft: (i2 = r2).scrollLeft, scrollTop: i2.scrollTop } : vm(r2)), um(t2) ? ((u2 = gm(t2, true)).x += t2.clientLeft, u2.y += t2.clientTop) : a2 && (u2.x = wm(a2))), { x: l2.left + c2.scrollLeft - u2.x, y: l2.top + c2.scrollTop - u2.y, width: l2.width, height: l2.height };
  }
  function Cm(e2) {
    var t2 = gm(e2), n2 = e2.offsetWidth, r2 = e2.offsetHeight;
    return Math.abs(t2.width - n2) <= 1 && (n2 = t2.width), Math.abs(t2.height - r2) <= 1 && (r2 = t2.height), { x: e2.offsetLeft, y: e2.offsetTop, width: n2, height: r2 };
  }
  function Sm(e2) {
    return "html" === ym(e2) ? e2 : e2.assignedSlot || e2.parentNode || (pm(e2) ? e2.host : null) || bm(e2);
  }
  function Mm(e2) {
    return ["html", "body", "#document"].indexOf(ym(e2)) >= 0 ? e2.ownerDocument.body : um(e2) && xm(e2) ? e2 : Mm(Sm(e2));
  }
  function Tm(e2, t2) {
    var n2;
    void 0 === t2 && (t2 = []);
    var r2 = Mm(e2), i2 = r2 === (null == (n2 = e2.ownerDocument) ? void 0 : n2.body), s2 = lm(r2), o2 = i2 ? [s2].concat(s2.visualViewport || [], xm(r2) ? r2 : []) : r2, a2 = t2.concat(o2);
    return i2 ? a2 : a2.concat(Tm(Sm(o2)));
  }
  function Pm(e2) {
    return ["table", "td", "th"].indexOf(ym(e2)) >= 0;
  }
  function Im(e2) {
    return um(e2) && "fixed" !== Am(e2).position ? e2.offsetParent : null;
  }
  function Rm(e2) {
    for (var t2 = lm(e2), n2 = Im(e2); n2 && Pm(n2) && "static" === Am(n2).position; )
      n2 = Im(n2);
    return n2 && ("html" === ym(n2) || "body" === ym(n2) && "static" === Am(n2).position) ? t2 : n2 || function(e3) {
      var t3 = /firefox/i.test(mm());
      if (/Trident/i.test(mm()) && um(e3) && "fixed" === Am(e3).position)
        return null;
      var n3 = Sm(e3);
      for (pm(n3) && (n3 = n3.host); um(n3) && ["html", "body"].indexOf(ym(n3)) < 0; ) {
        var r2 = Am(n3);
        if ("none" !== r2.transform || "none" !== r2.perspective || "paint" === r2.contain || -1 !== ["transform", "perspective"].indexOf(r2.willChange) || t3 && "filter" === r2.willChange || t3 && r2.filter && "none" !== r2.filter)
          return n3;
        n3 = n3.parentNode;
      }
      return null;
    }(e2) || t2;
  }
  var km = "top", Dm = "bottom", Bm = "right", Om = "left", Lm = "auto", Um = [km, Dm, Bm, Om], Fm = "start", Nm = "end", jm = "clippingParents", zm = "viewport", Gm = "popper", Vm = "reference", Hm = Um.reduce(function(e2, t2) {
    return e2.concat([t2 + "-" + Fm, t2 + "-" + Nm]);
  }, []), Qm = [].concat(Um, [Lm]).reduce(function(e2, t2) {
    return e2.concat([t2, t2 + "-" + Fm, t2 + "-" + Nm]);
  }, []), Wm = "beforeRead", qm = "read", Xm = "afterRead", Ym = "beforeMain", Km = "main", Jm = "afterMain", Zm = "beforeWrite", $m = "write", e_ = "afterWrite", t_ = [Wm, qm, Xm, Ym, Km, Jm, Zm, $m, e_];
  function n_(e2) {
    var t2 = /* @__PURE__ */ new Map(), n2 = /* @__PURE__ */ new Set(), r2 = [];
    function i2(e3) {
      n2.add(e3.name), [].concat(e3.requires || [], e3.requiresIfExists || []).forEach(function(e4) {
        if (!n2.has(e4)) {
          var r3 = t2.get(e4);
          r3 && i2(r3);
        }
      }), r2.push(e3);
    }
    return e2.forEach(function(e3) {
      t2.set(e3.name, e3);
    }), e2.forEach(function(e3) {
      n2.has(e3.name) || i2(e3);
    }), r2;
  }
  var r_ = { placement: "bottom", modifiers: [], strategy: "absolute" };
  function i_() {
    for (var e2 = arguments.length, t2 = new Array(e2), n2 = 0; n2 < e2; n2++)
      t2[n2] = arguments[n2];
    return !t2.some(function(e3) {
      return !(e3 && "function" == typeof e3.getBoundingClientRect);
    });
  }
  function s_(e2) {
    void 0 === e2 && (e2 = {});
    var t2 = e2, n2 = t2.defaultModifiers, r2 = void 0 === n2 ? [] : n2, i2 = t2.defaultOptions, s2 = void 0 === i2 ? r_ : i2;
    return function(e3, t3, n3) {
      void 0 === n3 && (n3 = s2);
      var i3, o2, a2 = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, r_, s2), modifiersData: {}, elements: { reference: e3, popper: t3 }, attributes: {}, styles: {} }, l2 = [], c2 = false, u2 = { state: a2, setOptions: function(n4) {
        var i4 = "function" == typeof n4 ? n4(a2.options) : n4;
        p2(), a2.options = Object.assign({}, s2, a2.options, i4), a2.scrollParents = { reference: cm(e3) ? Tm(e3) : e3.contextElement ? Tm(e3.contextElement) : [], popper: Tm(t3) };
        var o3, c3, d2 = function(e4) {
          var t4 = n_(e4);
          return t_.reduce(function(e5, n5) {
            return e5.concat(t4.filter(function(e6) {
              return e6.phase === n5;
            }));
          }, []);
        }((o3 = [].concat(r2, a2.options.modifiers), c3 = o3.reduce(function(e4, t4) {
          var n5 = e4[t4.name];
          return e4[t4.name] = n5 ? Object.assign({}, n5, t4, { options: Object.assign({}, n5.options, t4.options), data: Object.assign({}, n5.data, t4.data) }) : t4, e4;
        }, {}), Object.keys(c3).map(function(e4) {
          return c3[e4];
        })));
        return a2.orderedModifiers = d2.filter(function(e4) {
          return e4.enabled;
        }), a2.orderedModifiers.forEach(function(e4) {
          var t4 = e4.name, n5 = e4.options, r3 = void 0 === n5 ? {} : n5, i5 = e4.effect;
          if ("function" == typeof i5) {
            var s3 = i5({ state: a2, name: t4, instance: u2, options: r3 });
            l2.push(s3 || function() {
            });
          }
        }), u2.update();
      }, forceUpdate: function() {
        if (!c2) {
          var e4 = a2.elements, t4 = e4.reference, n4 = e4.popper;
          if (i_(t4, n4)) {
            a2.rects = { reference: Em(t4, Rm(n4), "fixed" === a2.options.strategy), popper: Cm(n4) }, a2.reset = false, a2.placement = a2.options.placement, a2.orderedModifiers.forEach(function(e5) {
              return a2.modifiersData[e5.name] = Object.assign({}, e5.data);
            });
            for (var r3 = 0; r3 < a2.orderedModifiers.length; r3++)
              if (true !== a2.reset) {
                var i4 = a2.orderedModifiers[r3], s3 = i4.fn, o3 = i4.options, l3 = void 0 === o3 ? {} : o3, p3 = i4.name;
                "function" == typeof s3 && (a2 = s3({ state: a2, options: l3, name: p3, instance: u2 }) || a2);
              } else
                a2.reset = false, r3 = -1;
          }
        }
      }, update: (i3 = function() {
        return new Promise(function(e4) {
          u2.forceUpdate(), e4(a2);
        });
      }, function() {
        return o2 || (o2 = new Promise(function(e4) {
          Promise.resolve().then(function() {
            o2 = void 0, e4(i3());
          });
        })), o2;
      }), destroy: function() {
        p2(), c2 = true;
      } };
      if (!i_(e3, t3))
        return u2;
      function p2() {
        l2.forEach(function(e4) {
          return e4();
        }), l2 = [];
      }
      return u2.setOptions(n3).then(function(e4) {
        !c2 && n3.onFirstUpdate && n3.onFirstUpdate(e4);
      }), u2;
    };
  }
  var o_ = s_(), a_ = { passive: true }, l_ = { name: "eventListeners", enabled: true, phase: "write", fn: function() {
  }, effect: function(e2) {
    var t2 = e2.state, n2 = e2.instance, r2 = e2.options, i2 = r2.scroll, s2 = void 0 === i2 || i2, o2 = r2.resize, a2 = void 0 === o2 || o2, l2 = lm(t2.elements.popper), c2 = [].concat(t2.scrollParents.reference, t2.scrollParents.popper);
    return s2 && c2.forEach(function(e3) {
      e3.addEventListener("scroll", n2.update, a_);
    }), a2 && l2.addEventListener("resize", n2.update, a_), function() {
      s2 && c2.forEach(function(e3) {
        e3.removeEventListener("scroll", n2.update, a_);
      }), a2 && l2.removeEventListener("resize", n2.update, a_);
    };
  }, data: {} };
  function c_(e2) {
    return e2.split("-")[0];
  }
  function u_(e2) {
    return e2.split("-")[1];
  }
  function p_(e2) {
    return ["top", "bottom"].indexOf(e2) >= 0 ? "x" : "y";
  }
  function d_(e2) {
    var t2, n2 = e2.reference, r2 = e2.element, i2 = e2.placement, s2 = i2 ? c_(i2) : null, o2 = i2 ? u_(i2) : null, a2 = n2.x + n2.width / 2 - r2.width / 2, l2 = n2.y + n2.height / 2 - r2.height / 2;
    switch (s2) {
      case km:
        t2 = { x: a2, y: n2.y - r2.height };
        break;
      case Dm:
        t2 = { x: a2, y: n2.y + n2.height };
        break;
      case Bm:
        t2 = { x: n2.x + n2.width, y: l2 };
        break;
      case Om:
        t2 = { x: n2.x - r2.width, y: l2 };
        break;
      default:
        t2 = { x: n2.x, y: n2.y };
    }
    var c2 = s2 ? p_(s2) : null;
    if (null != c2) {
      var u2 = "y" === c2 ? "height" : "width";
      switch (o2) {
        case Fm:
          t2[c2] = t2[c2] - (n2[u2] / 2 - r2[u2] / 2);
          break;
        case Nm:
          t2[c2] = t2[c2] + (n2[u2] / 2 - r2[u2] / 2);
      }
    }
    return t2;
  }
  var h_ = { name: "popperOffsets", enabled: true, phase: "read", fn: function(e2) {
    var t2 = e2.state, n2 = e2.name;
    t2.modifiersData[n2] = d_({ reference: t2.rects.reference, element: t2.rects.popper, strategy: "absolute", placement: t2.placement });
  }, data: {} }, f_ = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
  function m_(e2) {
    var t2, n2 = e2.popper, r2 = e2.popperRect, i2 = e2.placement, s2 = e2.variation, o2 = e2.offsets, a2 = e2.position, l2 = e2.gpuAcceleration, c2 = e2.adaptive, u2 = e2.roundOffsets, p2 = e2.isFixed, d2 = o2.x, h2 = void 0 === d2 ? 0 : d2, f2 = o2.y, m2 = void 0 === f2 ? 0 : f2, _2 = "function" == typeof u2 ? u2({ x: h2, y: m2 }) : { x: h2, y: m2 };
    h2 = _2.x, m2 = _2.y;
    var g2 = o2.hasOwnProperty("x"), v2 = o2.hasOwnProperty("y"), y2 = Om, b2 = km, w2 = window;
    if (c2) {
      var A2 = Rm(n2), x2 = "clientHeight", E2 = "clientWidth";
      A2 === lm(n2) && "static" !== Am(A2 = bm(n2)).position && "absolute" === a2 && (x2 = "scrollHeight", E2 = "scrollWidth"), (i2 === km || (i2 === Om || i2 === Bm) && s2 === Nm) && (b2 = Dm, m2 -= (p2 && A2 === w2 && w2.visualViewport ? w2.visualViewport.height : A2[x2]) - r2.height, m2 *= l2 ? 1 : -1), i2 !== Om && (i2 !== km && i2 !== Dm || s2 !== Nm) || (y2 = Bm, h2 -= (p2 && A2 === w2 && w2.visualViewport ? w2.visualViewport.width : A2[E2]) - r2.width, h2 *= l2 ? 1 : -1);
    }
    var C2, S2 = Object.assign({ position: a2 }, c2 && f_), M2 = true === u2 ? function(e3) {
      var t3 = e3.x, n3 = e3.y, r3 = window.devicePixelRatio || 1;
      return { x: fm(t3 * r3) / r3 || 0, y: fm(n3 * r3) / r3 || 0 };
    }({ x: h2, y: m2 }) : { x: h2, y: m2 };
    return h2 = M2.x, m2 = M2.y, l2 ? Object.assign({}, S2, ((C2 = {})[b2] = v2 ? "0" : "", C2[y2] = g2 ? "0" : "", C2.transform = (w2.devicePixelRatio || 1) <= 1 ? "translate(" + h2 + "px, " + m2 + "px)" : "translate3d(" + h2 + "px, " + m2 + "px, 0)", C2)) : Object.assign({}, S2, ((t2 = {})[b2] = v2 ? m2 + "px" : "", t2[y2] = g2 ? h2 + "px" : "", t2.transform = "", t2));
  }
  var __ = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: function(e2) {
    var t2 = e2.state, n2 = e2.options, r2 = n2.gpuAcceleration, i2 = void 0 === r2 || r2, s2 = n2.adaptive, o2 = void 0 === s2 || s2, a2 = n2.roundOffsets, l2 = void 0 === a2 || a2, c2 = { placement: c_(t2.placement), variation: u_(t2.placement), popper: t2.elements.popper, popperRect: t2.rects.popper, gpuAcceleration: i2, isFixed: "fixed" === t2.options.strategy };
    null != t2.modifiersData.popperOffsets && (t2.styles.popper = Object.assign({}, t2.styles.popper, m_(Object.assign({}, c2, { offsets: t2.modifiersData.popperOffsets, position: t2.options.strategy, adaptive: o2, roundOffsets: l2 })))), null != t2.modifiersData.arrow && (t2.styles.arrow = Object.assign({}, t2.styles.arrow, m_(Object.assign({}, c2, { offsets: t2.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets: l2 })))), t2.attributes.popper = Object.assign({}, t2.attributes.popper, { "data-popper-placement": t2.placement });
  }, data: {} }, g_ = { name: "applyStyles", enabled: true, phase: "write", fn: function(e2) {
    var t2 = e2.state;
    Object.keys(t2.elements).forEach(function(e3) {
      var n2 = t2.styles[e3] || {}, r2 = t2.attributes[e3] || {}, i2 = t2.elements[e3];
      um(i2) && ym(i2) && (Object.assign(i2.style, n2), Object.keys(r2).forEach(function(e4) {
        var t3 = r2[e4];
        false === t3 ? i2.removeAttribute(e4) : i2.setAttribute(e4, true === t3 ? "" : t3);
      }));
    });
  }, effect: function(e2) {
    var t2 = e2.state, n2 = { popper: { position: t2.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
    return Object.assign(t2.elements.popper.style, n2.popper), t2.styles = n2, t2.elements.arrow && Object.assign(t2.elements.arrow.style, n2.arrow), function() {
      Object.keys(t2.elements).forEach(function(e3) {
        var r2 = t2.elements[e3], i2 = t2.attributes[e3] || {}, s2 = Object.keys(t2.styles.hasOwnProperty(e3) ? t2.styles[e3] : n2[e3]).reduce(function(e4, t3) {
          return e4[t3] = "", e4;
        }, {});
        um(r2) && ym(r2) && (Object.assign(r2.style, s2), Object.keys(i2).forEach(function(e4) {
          r2.removeAttribute(e4);
        }));
      });
    };
  }, requires: ["computeStyles"] }, v_ = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: function(e2) {
    var t2 = e2.state, n2 = e2.options, r2 = e2.name, i2 = n2.offset, s2 = void 0 === i2 ? [0, 0] : i2, o2 = Qm.reduce(function(e3, n3) {
      return e3[n3] = function(e4, t3, n4) {
        var r3 = c_(e4), i3 = [Om, km].indexOf(r3) >= 0 ? -1 : 1, s3 = "function" == typeof n4 ? n4(Object.assign({}, t3, { placement: e4 })) : n4, o3 = s3[0], a3 = s3[1];
        return o3 = o3 || 0, a3 = (a3 || 0) * i3, [Om, Bm].indexOf(r3) >= 0 ? { x: a3, y: o3 } : { x: o3, y: a3 };
      }(n3, t2.rects, s2), e3;
    }, {}), a2 = o2[t2.placement], l2 = a2.x, c2 = a2.y;
    null != t2.modifiersData.popperOffsets && (t2.modifiersData.popperOffsets.x += l2, t2.modifiersData.popperOffsets.y += c2), t2.modifiersData[r2] = o2;
  } }, y_ = { left: "right", right: "left", bottom: "top", top: "bottom" };
  function b_(e2) {
    return e2.replace(/left|right|bottom|top/g, function(e3) {
      return y_[e3];
    });
  }
  var w_ = { start: "end", end: "start" };
  function A_(e2) {
    return e2.replace(/start|end/g, function(e3) {
      return w_[e3];
    });
  }
  function x_(e2, t2) {
    var n2 = t2.getRootNode && t2.getRootNode();
    if (e2.contains(t2))
      return true;
    if (n2 && pm(n2)) {
      var r2 = t2;
      do {
        if (r2 && e2.isSameNode(r2))
          return true;
        r2 = r2.parentNode || r2.host;
      } while (r2);
    }
    return false;
  }
  function E_(e2) {
    return Object.assign({}, e2, { left: e2.x, top: e2.y, right: e2.x + e2.width, bottom: e2.y + e2.height });
  }
  function C_(e2, t2, n2) {
    return t2 === zm ? E_(function(e3, t3) {
      var n3 = lm(e3), r2 = bm(e3), i2 = n3.visualViewport, s2 = r2.clientWidth, o2 = r2.clientHeight, a2 = 0, l2 = 0;
      if (i2) {
        s2 = i2.width, o2 = i2.height;
        var c2 = _m();
        (c2 || !c2 && "fixed" === t3) && (a2 = i2.offsetLeft, l2 = i2.offsetTop);
      }
      return { width: s2, height: o2, x: a2 + wm(e3), y: l2 };
    }(e2, n2)) : cm(t2) ? function(e3, t3) {
      var n3 = gm(e3, false, "fixed" === t3);
      return n3.top = n3.top + e3.clientTop, n3.left = n3.left + e3.clientLeft, n3.bottom = n3.top + e3.clientHeight, n3.right = n3.left + e3.clientWidth, n3.width = e3.clientWidth, n3.height = e3.clientHeight, n3.x = n3.left, n3.y = n3.top, n3;
    }(t2, n2) : E_(function(e3) {
      var t3, n3 = bm(e3), r2 = vm(e3), i2 = null == (t3 = e3.ownerDocument) ? void 0 : t3.body, s2 = dm(n3.scrollWidth, n3.clientWidth, i2 ? i2.scrollWidth : 0, i2 ? i2.clientWidth : 0), o2 = dm(n3.scrollHeight, n3.clientHeight, i2 ? i2.scrollHeight : 0, i2 ? i2.clientHeight : 0), a2 = -r2.scrollLeft + wm(e3), l2 = -r2.scrollTop;
      return "rtl" === Am(i2 || n3).direction && (a2 += dm(n3.clientWidth, i2 ? i2.clientWidth : 0) - s2), { width: s2, height: o2, x: a2, y: l2 };
    }(bm(e2)));
  }
  function S_(e2) {
    return Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }, e2);
  }
  function M_(e2, t2) {
    return t2.reduce(function(t3, n2) {
      return t3[n2] = e2, t3;
    }, {});
  }
  function T_(e2, t2) {
    void 0 === t2 && (t2 = {});
    var n2 = t2, r2 = n2.placement, i2 = void 0 === r2 ? e2.placement : r2, s2 = n2.strategy, o2 = void 0 === s2 ? e2.strategy : s2, a2 = n2.boundary, l2 = void 0 === a2 ? jm : a2, c2 = n2.rootBoundary, u2 = void 0 === c2 ? zm : c2, p2 = n2.elementContext, d2 = void 0 === p2 ? Gm : p2, h2 = n2.altBoundary, f2 = void 0 !== h2 && h2, m2 = n2.padding, _2 = void 0 === m2 ? 0 : m2, g2 = S_("number" != typeof _2 ? _2 : M_(_2, Um)), v2 = d2 === Gm ? Vm : Gm, y2 = e2.rects.popper, b2 = e2.elements[f2 ? v2 : d2], w2 = function(e3, t3, n3, r3) {
      var i3 = "clippingParents" === t3 ? function(e4) {
        var t4 = Tm(Sm(e4)), n4 = ["absolute", "fixed"].indexOf(Am(e4).position) >= 0 && um(e4) ? Rm(e4) : e4;
        return cm(n4) ? t4.filter(function(e5) {
          return cm(e5) && x_(e5, n4) && "body" !== ym(e5);
        }) : [];
      }(e3) : [].concat(t3), s3 = [].concat(i3, [n3]), o3 = s3[0], a3 = s3.reduce(function(t4, n4) {
        var i4 = C_(e3, n4, r3);
        return t4.top = dm(i4.top, t4.top), t4.right = hm(i4.right, t4.right), t4.bottom = hm(i4.bottom, t4.bottom), t4.left = dm(i4.left, t4.left), t4;
      }, C_(e3, o3, r3));
      return a3.width = a3.right - a3.left, a3.height = a3.bottom - a3.top, a3.x = a3.left, a3.y = a3.top, a3;
    }(cm(b2) ? b2 : b2.contextElement || bm(e2.elements.popper), l2, u2, o2), A2 = gm(e2.elements.reference), x2 = d_({ reference: A2, element: y2, strategy: "absolute", placement: i2 }), E2 = E_(Object.assign({}, y2, x2)), C2 = d2 === Gm ? E2 : A2, S2 = { top: w2.top - C2.top + g2.top, bottom: C2.bottom - w2.bottom + g2.bottom, left: w2.left - C2.left + g2.left, right: C2.right - w2.right + g2.right }, M2 = e2.modifiersData.offset;
    if (d2 === Gm && M2) {
      var T2 = M2[i2];
      Object.keys(S2).forEach(function(e3) {
        var t3 = [Bm, Dm].indexOf(e3) >= 0 ? 1 : -1, n3 = [km, Dm].indexOf(e3) >= 0 ? "y" : "x";
        S2[e3] += T2[n3] * t3;
      });
    }
    return S2;
  }
  var P_ = { name: "flip", enabled: true, phase: "main", fn: function(e2) {
    var t2 = e2.state, n2 = e2.options, r2 = e2.name;
    if (!t2.modifiersData[r2]._skip) {
      for (var i2 = n2.mainAxis, s2 = void 0 === i2 || i2, o2 = n2.altAxis, a2 = void 0 === o2 || o2, l2 = n2.fallbackPlacements, c2 = n2.padding, u2 = n2.boundary, p2 = n2.rootBoundary, d2 = n2.altBoundary, h2 = n2.flipVariations, f2 = void 0 === h2 || h2, m2 = n2.allowedAutoPlacements, _2 = t2.options.placement, g2 = c_(_2), v2 = l2 || (g2 !== _2 && f2 ? function(e3) {
        if (c_(e3) === Lm)
          return [];
        var t3 = b_(e3);
        return [A_(e3), t3, A_(t3)];
      }(_2) : [b_(_2)]), y2 = [_2].concat(v2).reduce(function(e3, n3) {
        return e3.concat(c_(n3) === Lm ? function(e4, t3) {
          void 0 === t3 && (t3 = {});
          var n4 = t3, r3 = n4.placement, i3 = n4.boundary, s3 = n4.rootBoundary, o3 = n4.padding, a3 = n4.flipVariations, l3 = n4.allowedAutoPlacements, c3 = void 0 === l3 ? Qm : l3, u3 = u_(r3), p3 = u3 ? a3 ? Hm : Hm.filter(function(e5) {
            return u_(e5) === u3;
          }) : Um, d3 = p3.filter(function(e5) {
            return c3.indexOf(e5) >= 0;
          });
          0 === d3.length && (d3 = p3);
          var h3 = d3.reduce(function(t4, n5) {
            return t4[n5] = T_(e4, { placement: n5, boundary: i3, rootBoundary: s3, padding: o3 })[c_(n5)], t4;
          }, {});
          return Object.keys(h3).sort(function(e5, t4) {
            return h3[e5] - h3[t4];
          });
        }(t2, { placement: n3, boundary: u2, rootBoundary: p2, padding: c2, flipVariations: f2, allowedAutoPlacements: m2 }) : n3);
      }, []), b2 = t2.rects.reference, w2 = t2.rects.popper, A2 = /* @__PURE__ */ new Map(), x2 = true, E2 = y2[0], C2 = 0; C2 < y2.length; C2++) {
        var S2 = y2[C2], M2 = c_(S2), T2 = u_(S2) === Fm, P2 = [km, Dm].indexOf(M2) >= 0, I2 = P2 ? "width" : "height", R2 = T_(t2, { placement: S2, boundary: u2, rootBoundary: p2, altBoundary: d2, padding: c2 }), k2 = P2 ? T2 ? Bm : Om : T2 ? Dm : km;
        b2[I2] > w2[I2] && (k2 = b_(k2));
        var D2 = b_(k2), B2 = [];
        if (s2 && B2.push(R2[M2] <= 0), a2 && B2.push(R2[k2] <= 0, R2[D2] <= 0), B2.every(function(e3) {
          return e3;
        })) {
          E2 = S2, x2 = false;
          break;
        }
        A2.set(S2, B2);
      }
      if (x2)
        for (var O2 = function(e3) {
          var t3 = y2.find(function(t4) {
            var n3 = A2.get(t4);
            if (n3)
              return n3.slice(0, e3).every(function(e4) {
                return e4;
              });
          });
          if (t3)
            return E2 = t3, "break";
        }, L2 = f2 ? 3 : 1; L2 > 0 && "break" !== O2(L2); L2--)
          ;
      t2.placement !== E2 && (t2.modifiersData[r2]._skip = true, t2.placement = E2, t2.reset = true);
    }
  }, requiresIfExists: ["offset"], data: { _skip: false } };
  function I_(e2, t2, n2) {
    return dm(e2, hm(t2, n2));
  }
  var R_ = { name: "preventOverflow", enabled: true, phase: "main", fn: function(e2) {
    var t2 = e2.state, n2 = e2.options, r2 = e2.name, i2 = n2.mainAxis, s2 = void 0 === i2 || i2, o2 = n2.altAxis, a2 = void 0 !== o2 && o2, l2 = n2.boundary, c2 = n2.rootBoundary, u2 = n2.altBoundary, p2 = n2.padding, d2 = n2.tether, h2 = void 0 === d2 || d2, f2 = n2.tetherOffset, m2 = void 0 === f2 ? 0 : f2, _2 = T_(t2, { boundary: l2, rootBoundary: c2, padding: p2, altBoundary: u2 }), g2 = c_(t2.placement), v2 = u_(t2.placement), y2 = !v2, b2 = p_(g2), w2 = "x" === b2 ? "y" : "x", A2 = t2.modifiersData.popperOffsets, x2 = t2.rects.reference, E2 = t2.rects.popper, C2 = "function" == typeof m2 ? m2(Object.assign({}, t2.rects, { placement: t2.placement })) : m2, S2 = "number" == typeof C2 ? { mainAxis: C2, altAxis: C2 } : Object.assign({ mainAxis: 0, altAxis: 0 }, C2), M2 = t2.modifiersData.offset ? t2.modifiersData.offset[t2.placement] : null, T2 = { x: 0, y: 0 };
    if (A2) {
      if (s2) {
        var P2, I2 = "y" === b2 ? km : Om, R2 = "y" === b2 ? Dm : Bm, k2 = "y" === b2 ? "height" : "width", D2 = A2[b2], B2 = D2 + _2[I2], O2 = D2 - _2[R2], L2 = h2 ? -E2[k2] / 2 : 0, U2 = v2 === Fm ? x2[k2] : E2[k2], F2 = v2 === Fm ? -E2[k2] : -x2[k2], N2 = t2.elements.arrow, j2 = h2 && N2 ? Cm(N2) : { width: 0, height: 0 }, z2 = t2.modifiersData["arrow#persistent"] ? t2.modifiersData["arrow#persistent"].padding : { top: 0, right: 0, bottom: 0, left: 0 }, G2 = z2[I2], V2 = z2[R2], H2 = I_(0, x2[k2], j2[k2]), Q2 = y2 ? x2[k2] / 2 - L2 - H2 - G2 - S2.mainAxis : U2 - H2 - G2 - S2.mainAxis, W2 = y2 ? -x2[k2] / 2 + L2 + H2 + V2 + S2.mainAxis : F2 + H2 + V2 + S2.mainAxis, q2 = t2.elements.arrow && Rm(t2.elements.arrow), X2 = q2 ? "y" === b2 ? q2.clientTop || 0 : q2.clientLeft || 0 : 0, Y2 = null != (P2 = null == M2 ? void 0 : M2[b2]) ? P2 : 0, K2 = D2 + W2 - Y2, J2 = I_(h2 ? hm(B2, D2 + Q2 - Y2 - X2) : B2, D2, h2 ? dm(O2, K2) : O2);
        A2[b2] = J2, T2[b2] = J2 - D2;
      }
      if (a2) {
        var Z2, $2 = "x" === b2 ? km : Om, ee2 = "x" === b2 ? Dm : Bm, te2 = A2[w2], ne2 = "y" === w2 ? "height" : "width", re2 = te2 + _2[$2], ie2 = te2 - _2[ee2], se2 = -1 !== [km, Om].indexOf(g2), oe2 = null != (Z2 = null == M2 ? void 0 : M2[w2]) ? Z2 : 0, ae2 = se2 ? re2 : te2 - x2[ne2] - E2[ne2] - oe2 + S2.altAxis, le2 = se2 ? te2 + x2[ne2] + E2[ne2] - oe2 - S2.altAxis : ie2, ce2 = h2 && se2 ? function(e3, t3, n3) {
          var r3 = I_(e3, t3, n3);
          return r3 > n3 ? n3 : r3;
        }(ae2, te2, le2) : I_(h2 ? ae2 : re2, te2, h2 ? le2 : ie2);
        A2[w2] = ce2, T2[w2] = ce2 - te2;
      }
      t2.modifiersData[r2] = T2;
    }
  }, requiresIfExists: ["offset"] }, k_ = { name: "arrow", enabled: true, phase: "main", fn: function(e2) {
    var t2, n2 = e2.state, r2 = e2.name, i2 = e2.options, s2 = n2.elements.arrow, o2 = n2.modifiersData.popperOffsets, a2 = c_(n2.placement), l2 = p_(a2), c2 = [Om, Bm].indexOf(a2) >= 0 ? "height" : "width";
    if (s2 && o2) {
      var u2 = function(e3, t3) {
        return S_("number" != typeof (e3 = "function" == typeof e3 ? e3(Object.assign({}, t3.rects, { placement: t3.placement })) : e3) ? e3 : M_(e3, Um));
      }(i2.padding, n2), p2 = Cm(s2), d2 = "y" === l2 ? km : Om, h2 = "y" === l2 ? Dm : Bm, f2 = n2.rects.reference[c2] + n2.rects.reference[l2] - o2[l2] - n2.rects.popper[c2], m2 = o2[l2] - n2.rects.reference[l2], _2 = Rm(s2), g2 = _2 ? "y" === l2 ? _2.clientHeight || 0 : _2.clientWidth || 0 : 0, v2 = f2 / 2 - m2 / 2, y2 = u2[d2], b2 = g2 - p2[c2] - u2[h2], w2 = g2 / 2 - p2[c2] / 2 + v2, A2 = I_(y2, w2, b2), x2 = l2;
      n2.modifiersData[r2] = ((t2 = {})[x2] = A2, t2.centerOffset = A2 - w2, t2);
    }
  }, effect: function(e2) {
    var t2 = e2.state, n2 = e2.options.element, r2 = void 0 === n2 ? "[data-popper-arrow]" : n2;
    null != r2 && ("string" != typeof r2 || (r2 = t2.elements.popper.querySelector(r2))) && x_(t2.elements.popper, r2) && (t2.elements.arrow = r2);
  }, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
  function D_(e2, t2, n2) {
    return void 0 === n2 && (n2 = { x: 0, y: 0 }), { top: e2.top - t2.height - n2.y, right: e2.right - t2.width + n2.x, bottom: e2.bottom - t2.height + n2.y, left: e2.left - t2.width - n2.x };
  }
  function B_(e2) {
    return [km, Bm, Dm, Om].some(function(t2) {
      return e2[t2] >= 0;
    });
  }
  var O_ = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: function(e2) {
    var t2 = e2.state, n2 = e2.name, r2 = t2.rects.reference, i2 = t2.rects.popper, s2 = t2.modifiersData.preventOverflow, o2 = T_(t2, { elementContext: "reference" }), a2 = T_(t2, { altBoundary: true }), l2 = D_(o2, r2), c2 = D_(a2, i2, s2), u2 = B_(l2), p2 = B_(c2);
    t2.modifiersData[n2] = { referenceClippingOffsets: l2, popperEscapeOffsets: c2, isReferenceHidden: u2, hasPopperEscaped: p2 }, t2.attributes.popper = Object.assign({}, t2.attributes.popper, { "data-popper-reference-hidden": u2, "data-popper-escaped": p2 });
  } }, L_ = s_({ defaultModifiers: [l_, h_, __, g_, v_, P_, R_, k_, O_] }), U_ = "tippy-box", F_ = "tippy-content", N_ = "tippy-backdrop", j_ = "tippy-arrow", z_ = "tippy-svg-arrow", G_ = { passive: true, capture: true }, V_ = function() {
    return document.body;
  };
  function H_(e2, t2, n2) {
    if (Array.isArray(e2)) {
      var r2 = e2[t2];
      return null == r2 ? Array.isArray(n2) ? n2[t2] : n2 : r2;
    }
    return e2;
  }
  function Q_(e2, t2) {
    var n2 = {}.toString.call(e2);
    return 0 === n2.indexOf("[object") && n2.indexOf(t2 + "]") > -1;
  }
  function W_(e2, t2) {
    return "function" == typeof e2 ? e2.apply(void 0, t2) : e2;
  }
  function q_(e2, t2) {
    return 0 === t2 ? e2 : function(r2) {
      clearTimeout(n2), n2 = setTimeout(function() {
        e2(r2);
      }, t2);
    };
    var n2;
  }
  function X_(e2) {
    return [].concat(e2);
  }
  function Y_(e2, t2) {
    -1 === e2.indexOf(t2) && e2.push(t2);
  }
  function K_(e2) {
    return [].slice.call(e2);
  }
  function J_(e2) {
    return Object.keys(e2).reduce(function(t2, n2) {
      return void 0 !== e2[n2] && (t2[n2] = e2[n2]), t2;
    }, {});
  }
  function Z_() {
    return document.createElement("div");
  }
  function $_(e2) {
    return ["Element", "Fragment"].some(function(t2) {
      return Q_(e2, t2);
    });
  }
  function eg(e2, t2) {
    e2.forEach(function(e3) {
      e3 && (e3.style.transitionDuration = t2 + "ms");
    });
  }
  function tg(e2, t2) {
    e2.forEach(function(e3) {
      e3 && e3.setAttribute("data-state", t2);
    });
  }
  function ng(e2, t2, n2) {
    var r2 = t2 + "EventListener";
    ["transitionend", "webkitTransitionEnd"].forEach(function(t3) {
      e2[r2](t3, n2);
    });
  }
  function rg(e2, t2) {
    for (var n2 = t2; n2; ) {
      var r2;
      if (e2.contains(n2))
        return true;
      n2 = null == n2.getRootNode || null == (r2 = n2.getRootNode()) ? void 0 : r2.host;
    }
    return false;
  }
  var ig = { isTouch: false }, sg = 0;
  function og() {
    ig.isTouch || (ig.isTouch = true, window.performance && document.addEventListener("mousemove", ag));
  }
  function ag() {
    var e2 = performance.now();
    e2 - sg < 20 && (ig.isTouch = false, document.removeEventListener("mousemove", ag)), sg = e2;
  }
  function lg() {
    var e2, t2 = document.activeElement;
    if ((e2 = t2) && e2._tippy && e2._tippy.reference === e2) {
      var n2 = t2._tippy;
      t2.blur && !n2.state.isVisible && t2.blur();
    }
  }
  var cg = !("undefined" == typeof window || "undefined" == typeof document || !window.msCrypto), ug = Object.assign({ appendTo: V_, aria: { content: "auto", expanded: "auto" }, delay: 0, duration: [300, 250], getReferenceClientRect: null, hideOnClick: true, ignoreAttributes: false, interactive: false, interactiveBorder: 2, interactiveDebounce: 0, moveTransition: "", offset: [0, 10], onAfterUpdate: function() {
  }, onBeforeUpdate: function() {
  }, onCreate: function() {
  }, onDestroy: function() {
  }, onHidden: function() {
  }, onHide: function() {
  }, onMount: function() {
  }, onShow: function() {
  }, onShown: function() {
  }, onTrigger: function() {
  }, onUntrigger: function() {
  }, onClickOutside: function() {
  }, placement: "top", plugins: [], popperOptions: {}, render: null, showOnCreate: false, touch: true, trigger: "mouseenter focus", triggerTarget: null }, { animateFill: false, followCursor: false, inlinePositioning: false, sticky: false }, { allowHTML: false, animation: "fade", arrow: true, content: "", inertia: false, maxWidth: 350, role: "tooltip", theme: "", zIndex: 9999 }), pg = Object.keys(ug);
  function dg(e2) {
    var t2 = (e2.plugins || []).reduce(function(t3, n2) {
      var r2, i2 = n2.name, s2 = n2.defaultValue;
      return i2 && (t3[i2] = void 0 !== e2[i2] ? e2[i2] : null != (r2 = ug[i2]) ? r2 : s2), t3;
    }, {});
    return Object.assign({}, e2, t2);
  }
  function hg(e2, t2) {
    var n2 = Object.assign({}, t2, { content: W_(t2.content, [e2]) }, t2.ignoreAttributes ? {} : function(e3, t3) {
      return (t3 ? Object.keys(dg(Object.assign({}, ug, { plugins: t3 }))) : pg).reduce(function(t4, n3) {
        var r2 = (e3.getAttribute("data-tippy-" + n3) || "").trim();
        if (!r2)
          return t4;
        if ("content" === n3)
          t4[n3] = r2;
        else
          try {
            t4[n3] = JSON.parse(r2);
          } catch (e4) {
            t4[n3] = r2;
          }
        return t4;
      }, {});
    }(e2, t2.plugins));
    return n2.aria = Object.assign({}, ug.aria, n2.aria), n2.aria = { expanded: "auto" === n2.aria.expanded ? t2.interactive : n2.aria.expanded, content: "auto" === n2.aria.content ? t2.interactive ? null : "describedby" : n2.aria.content }, n2;
  }
  var fg = function() {
    return "innerHTML";
  };
  function mg(e2, t2) {
    e2[fg()] = t2;
  }
  function _g(e2) {
    var t2 = Z_();
    return true === e2 ? t2.className = j_ : (t2.className = z_, $_(e2) ? t2.appendChild(e2) : mg(t2, e2)), t2;
  }
  function gg(e2, t2) {
    $_(t2.content) ? (mg(e2, ""), e2.appendChild(t2.content)) : "function" != typeof t2.content && (t2.allowHTML ? mg(e2, t2.content) : e2.textContent = t2.content);
  }
  function vg(e2) {
    var t2 = e2.firstElementChild, n2 = K_(t2.children);
    return { box: t2, content: n2.find(function(e3) {
      return e3.classList.contains(F_);
    }), arrow: n2.find(function(e3) {
      return e3.classList.contains(j_) || e3.classList.contains(z_);
    }), backdrop: n2.find(function(e3) {
      return e3.classList.contains(N_);
    }) };
  }
  function yg(e2) {
    var t2 = Z_(), n2 = Z_();
    n2.className = U_, n2.setAttribute("data-state", "hidden"), n2.setAttribute("tabindex", "-1");
    var r2 = Z_();
    function i2(n3, r3) {
      var i3 = vg(t2), s2 = i3.box, o2 = i3.content, a2 = i3.arrow;
      r3.theme ? s2.setAttribute("data-theme", r3.theme) : s2.removeAttribute("data-theme"), "string" == typeof r3.animation ? s2.setAttribute("data-animation", r3.animation) : s2.removeAttribute("data-animation"), r3.inertia ? s2.setAttribute("data-inertia", "") : s2.removeAttribute("data-inertia"), s2.style.maxWidth = "number" == typeof r3.maxWidth ? r3.maxWidth + "px" : r3.maxWidth, r3.role ? s2.setAttribute("role", r3.role) : s2.removeAttribute("role"), n3.content === r3.content && n3.allowHTML === r3.allowHTML || gg(o2, e2.props), r3.arrow ? a2 ? n3.arrow !== r3.arrow && (s2.removeChild(a2), s2.appendChild(_g(r3.arrow))) : s2.appendChild(_g(r3.arrow)) : a2 && s2.removeChild(a2);
    }
    return r2.className = F_, r2.setAttribute("data-state", "hidden"), gg(r2, e2.props), t2.appendChild(n2), n2.appendChild(r2), i2(e2.props, e2.props), { popper: t2, onUpdate: i2 };
  }
  yg.$$tippy = true;
  var bg = 1, wg = [], Ag = [];
  function xg(e2, t2) {
    var n2, r2, i2, s2, o2, a2, l2, c2, u2 = hg(e2, Object.assign({}, ug, dg(J_(t2)))), p2 = false, d2 = false, h2 = false, f2 = false, m2 = [], _2 = q_(q2, u2.interactiveDebounce), g2 = bg++, v2 = (c2 = u2.plugins).filter(function(e3, t3) {
      return c2.indexOf(e3) === t3;
    }), y2 = { id: g2, reference: e2, popper: Z_(), popperInstance: null, props: u2, state: { isEnabled: true, isVisible: false, isDestroyed: false, isMounted: false, isShown: false }, plugins: v2, clearDelayTimeouts: function() {
      clearTimeout(n2), clearTimeout(r2), cancelAnimationFrame(i2);
    }, setProps: function(t3) {
      if (!y2.state.isDestroyed) {
        D2("onBeforeUpdate", [y2, t3]), Q2();
        var n3 = y2.props, r3 = hg(e2, Object.assign({}, n3, J_(t3), { ignoreAttributes: true }));
        y2.props = r3, H2(), n3.interactiveDebounce !== r3.interactiveDebounce && (L2(), _2 = q_(q2, r3.interactiveDebounce)), n3.triggerTarget && !r3.triggerTarget ? X_(n3.triggerTarget).forEach(function(e3) {
          e3.removeAttribute("aria-expanded");
        }) : r3.triggerTarget && e2.removeAttribute("aria-expanded"), O2(), k2(), A2 && A2(n3, r3), y2.popperInstance && (J2(), $2().forEach(function(e3) {
          requestAnimationFrame(e3._tippy.popperInstance.forceUpdate);
        })), D2("onAfterUpdate", [y2, t3]);
      }
    }, setContent: function(e3) {
      y2.setProps({ content: e3 });
    }, show: function() {
      var e3 = y2.state.isVisible, t3 = y2.state.isDestroyed, n3 = !y2.state.isEnabled, r3 = ig.isTouch && !y2.props.touch, i3 = H_(y2.props.duration, 0, ug.duration);
      if (!(e3 || t3 || n3 || r3 || T2().hasAttribute("disabled") || (D2("onShow", [y2], false), false === y2.props.onShow(y2)))) {
        if (y2.state.isVisible = true, M2() && (w2.style.visibility = "visible"), k2(), j2(), y2.state.isMounted || (w2.style.transition = "none"), M2()) {
          var s3 = I2();
          eg([s3.box, s3.content], 0);
        }
        var o3, l3, c3;
        a2 = function() {
          var e4;
          if (y2.state.isVisible && !f2) {
            if (f2 = true, w2.offsetHeight, w2.style.transition = y2.props.moveTransition, M2() && y2.props.animation) {
              var t4 = I2(), n4 = t4.box, r4 = t4.content;
              eg([n4, r4], i3), tg([n4, r4], "visible");
            }
            B2(), O2(), Y_(Ag, y2), null == (e4 = y2.popperInstance) || e4.forceUpdate(), D2("onMount", [y2]), y2.props.animation && M2() && function(e5, t5) {
              G2(e5, function() {
                y2.state.isShown = true, D2("onShown", [y2]);
              });
            }(i3);
          }
        }, l3 = y2.props.appendTo, c3 = T2(), (o3 = y2.props.interactive && l3 === V_ || "parent" === l3 ? c3.parentNode : W_(l3, [c3])).contains(w2) || o3.appendChild(w2), y2.state.isMounted = true, J2();
      }
    }, hide: function() {
      var e3 = !y2.state.isVisible, t3 = y2.state.isDestroyed, n3 = !y2.state.isEnabled, r3 = H_(y2.props.duration, 1, ug.duration);
      if (!(e3 || t3 || n3) && (D2("onHide", [y2], false), false !== y2.props.onHide(y2))) {
        if (y2.state.isVisible = false, y2.state.isShown = false, f2 = false, p2 = false, M2() && (w2.style.visibility = "hidden"), L2(), z2(), k2(true), M2()) {
          var i3 = I2(), s3 = i3.box, o3 = i3.content;
          y2.props.animation && (eg([s3, o3], r3), tg([s3, o3], "hidden"));
        }
        B2(), O2(), y2.props.animation ? M2() && function(e4, t4) {
          G2(e4, function() {
            !y2.state.isVisible && w2.parentNode && w2.parentNode.contains(w2) && t4();
          });
        }(r3, y2.unmount) : y2.unmount();
      }
    }, hideWithInteractivity: function(e3) {
      P2().addEventListener("mousemove", _2), Y_(wg, _2), _2(e3);
    }, enable: function() {
      y2.state.isEnabled = true;
    }, disable: function() {
      y2.hide(), y2.state.isEnabled = false;
    }, unmount: function() {
      y2.state.isVisible && y2.hide(), y2.state.isMounted && (Z2(), $2().forEach(function(e3) {
        e3._tippy.unmount();
      }), w2.parentNode && w2.parentNode.removeChild(w2), Ag = Ag.filter(function(e3) {
        return e3 !== y2;
      }), y2.state.isMounted = false, D2("onHidden", [y2]));
    }, destroy: function() {
      y2.state.isDestroyed || (y2.clearDelayTimeouts(), y2.unmount(), Q2(), delete e2._tippy, y2.state.isDestroyed = true, D2("onDestroy", [y2]));
    } };
    if (!u2.render)
      return y2;
    var b2 = u2.render(y2), w2 = b2.popper, A2 = b2.onUpdate;
    w2.setAttribute("data-tippy-root", ""), w2.id = "tippy-" + y2.id, y2.popper = w2, e2._tippy = y2, w2._tippy = y2;
    var x2 = v2.map(function(e3) {
      return e3.fn(y2);
    }), E2 = e2.hasAttribute("aria-expanded");
    return H2(), O2(), k2(), D2("onCreate", [y2]), u2.showOnCreate && ee2(), w2.addEventListener("mouseenter", function() {
      y2.props.interactive && y2.state.isVisible && y2.clearDelayTimeouts();
    }), w2.addEventListener("mouseleave", function() {
      y2.props.interactive && y2.props.trigger.indexOf("mouseenter") >= 0 && P2().addEventListener("mousemove", _2);
    }), y2;
    function C2() {
      var e3 = y2.props.touch;
      return Array.isArray(e3) ? e3 : [e3, 0];
    }
    function S2() {
      return "hold" === C2()[0];
    }
    function M2() {
      var e3;
      return !(null == (e3 = y2.props.render) || !e3.$$tippy);
    }
    function T2() {
      return l2 || e2;
    }
    function P2() {
      var e3, t3, n3 = T2().parentNode;
      return n3 ? null != (t3 = X_(n3)[0]) && null != (e3 = t3.ownerDocument) && e3.body ? t3.ownerDocument : document : document;
    }
    function I2() {
      return vg(w2);
    }
    function R2(e3) {
      return y2.state.isMounted && !y2.state.isVisible || ig.isTouch || s2 && "focus" === s2.type ? 0 : H_(y2.props.delay, e3 ? 0 : 1, ug.delay);
    }
    function k2(e3) {
      void 0 === e3 && (e3 = false), w2.style.pointerEvents = y2.props.interactive && !e3 ? "" : "none", w2.style.zIndex = "" + y2.props.zIndex;
    }
    function D2(e3, t3, n3) {
      var r3;
      void 0 === n3 && (n3 = true), x2.forEach(function(n4) {
        n4[e3] && n4[e3].apply(n4, t3);
      }), n3 && (r3 = y2.props)[e3].apply(r3, t3);
    }
    function B2() {
      var t3 = y2.props.aria;
      if (t3.content) {
        var n3 = "aria-" + t3.content, r3 = w2.id;
        X_(y2.props.triggerTarget || e2).forEach(function(e3) {
          var t4 = e3.getAttribute(n3);
          if (y2.state.isVisible)
            e3.setAttribute(n3, t4 ? t4 + " " + r3 : r3);
          else {
            var i3 = t4 && t4.replace(r3, "").trim();
            i3 ? e3.setAttribute(n3, i3) : e3.removeAttribute(n3);
          }
        });
      }
    }
    function O2() {
      !E2 && y2.props.aria.expanded && X_(y2.props.triggerTarget || e2).forEach(function(e3) {
        y2.props.interactive ? e3.setAttribute("aria-expanded", y2.state.isVisible && e3 === T2() ? "true" : "false") : e3.removeAttribute("aria-expanded");
      });
    }
    function L2() {
      P2().removeEventListener("mousemove", _2), wg = wg.filter(function(e3) {
        return e3 !== _2;
      });
    }
    function U2(t3) {
      if (!ig.isTouch || !h2 && "mousedown" !== t3.type) {
        var n3 = t3.composedPath && t3.composedPath()[0] || t3.target;
        if (!y2.props.interactive || !rg(w2, n3)) {
          if (X_(y2.props.triggerTarget || e2).some(function(e3) {
            return rg(e3, n3);
          })) {
            if (ig.isTouch)
              return;
            if (y2.state.isVisible && y2.props.trigger.indexOf("click") >= 0)
              return;
          } else
            D2("onClickOutside", [y2, t3]);
          true === y2.props.hideOnClick && (y2.clearDelayTimeouts(), y2.hide(), d2 = true, setTimeout(function() {
            d2 = false;
          }), y2.state.isMounted || z2());
        }
      }
    }
    function F2() {
      h2 = true;
    }
    function N2() {
      h2 = false;
    }
    function j2() {
      var e3 = P2();
      e3.addEventListener("mousedown", U2, true), e3.addEventListener("touchend", U2, G_), e3.addEventListener("touchstart", N2, G_), e3.addEventListener("touchmove", F2, G_);
    }
    function z2() {
      var e3 = P2();
      e3.removeEventListener("mousedown", U2, true), e3.removeEventListener("touchend", U2, G_), e3.removeEventListener("touchstart", N2, G_), e3.removeEventListener("touchmove", F2, G_);
    }
    function G2(e3, t3) {
      var n3 = I2().box;
      function r3(e4) {
        e4.target === n3 && (ng(n3, "remove", r3), t3());
      }
      if (0 === e3)
        return t3();
      ng(n3, "remove", o2), ng(n3, "add", r3), o2 = r3;
    }
    function V2(t3, n3, r3) {
      void 0 === r3 && (r3 = false), X_(y2.props.triggerTarget || e2).forEach(function(e3) {
        e3.addEventListener(t3, n3, r3), m2.push({ node: e3, eventType: t3, handler: n3, options: r3 });
      });
    }
    function H2() {
      var e3;
      S2() && (V2("touchstart", W2, { passive: true }), V2("touchend", X2, { passive: true })), (e3 = y2.props.trigger, e3.split(/\s+/).filter(Boolean)).forEach(function(e4) {
        if ("manual" !== e4)
          switch (V2(e4, W2), e4) {
            case "mouseenter":
              V2("mouseleave", X2);
              break;
            case "focus":
              V2(cg ? "focusout" : "blur", Y2);
              break;
            case "focusin":
              V2("focusout", Y2);
          }
      });
    }
    function Q2() {
      m2.forEach(function(e3) {
        var t3 = e3.node, n3 = e3.eventType, r3 = e3.handler, i3 = e3.options;
        t3.removeEventListener(n3, r3, i3);
      }), m2 = [];
    }
    function W2(e3) {
      var t3, n3 = false;
      if (y2.state.isEnabled && !K2(e3) && !d2) {
        var r3 = "focus" === (null == (t3 = s2) ? void 0 : t3.type);
        s2 = e3, l2 = e3.currentTarget, O2(), !y2.state.isVisible && Q_(e3, "MouseEvent") && wg.forEach(function(t4) {
          return t4(e3);
        }), "click" === e3.type && (y2.props.trigger.indexOf("mouseenter") < 0 || p2) && false !== y2.props.hideOnClick && y2.state.isVisible ? n3 = true : ee2(e3), "click" === e3.type && (p2 = !n3), n3 && !r3 && te2(e3);
      }
    }
    function q2(e3) {
      var t3 = e3.target, n3 = T2().contains(t3) || w2.contains(t3);
      if ("mousemove" !== e3.type || !n3) {
        var r3 = $2().concat(w2).map(function(e4) {
          var t4, n4 = null == (t4 = e4._tippy.popperInstance) ? void 0 : t4.state;
          return n4 ? { popperRect: e4.getBoundingClientRect(), popperState: n4, props: u2 } : null;
        }).filter(Boolean);
        (function(e4, t4) {
          var n4 = t4.clientX, r4 = t4.clientY;
          return e4.every(function(e5) {
            var t5 = e5.popperRect, i3 = e5.popperState, s3 = e5.props.interactiveBorder, o3 = i3.placement.split("-")[0], a3 = i3.modifiersData.offset;
            if (!a3)
              return true;
            var l3 = "bottom" === o3 ? a3.top.y : 0, c3 = "top" === o3 ? a3.bottom.y : 0, u3 = "right" === o3 ? a3.left.x : 0, p3 = "left" === o3 ? a3.right.x : 0, d3 = t5.top - r4 + l3 > s3, h3 = r4 - t5.bottom - c3 > s3, f3 = t5.left - n4 + u3 > s3, m3 = n4 - t5.right - p3 > s3;
            return d3 || h3 || f3 || m3;
          });
        })(r3, e3) && (L2(), te2(e3));
      }
    }
    function X2(e3) {
      K2(e3) || y2.props.trigger.indexOf("click") >= 0 && p2 || (y2.props.interactive ? y2.hideWithInteractivity(e3) : te2(e3));
    }
    function Y2(e3) {
      y2.props.trigger.indexOf("focusin") < 0 && e3.target !== T2() || y2.props.interactive && e3.relatedTarget && w2.contains(e3.relatedTarget) || te2(e3);
    }
    function K2(e3) {
      return !!ig.isTouch && S2() !== e3.type.indexOf("touch") >= 0;
    }
    function J2() {
      Z2();
      var t3 = y2.props, n3 = t3.popperOptions, r3 = t3.placement, i3 = t3.offset, s3 = t3.getReferenceClientRect, o3 = t3.moveTransition, l3 = M2() ? vg(w2).arrow : null, c3 = s3 ? { getBoundingClientRect: s3, contextElement: s3.contextElement || T2() } : e2, u3 = [{ name: "offset", options: { offset: i3 } }, { name: "preventOverflow", options: { padding: { top: 2, bottom: 2, left: 5, right: 5 } } }, { name: "flip", options: { padding: 5 } }, { name: "computeStyles", options: { adaptive: !o3 } }, { name: "$$tippy", enabled: true, phase: "beforeWrite", requires: ["computeStyles"], fn: function(e3) {
        var t4 = e3.state;
        if (M2()) {
          var n4 = I2().box;
          ["placement", "reference-hidden", "escaped"].forEach(function(e4) {
            "placement" === e4 ? n4.setAttribute("data-placement", t4.placement) : t4.attributes.popper["data-popper-" + e4] ? n4.setAttribute("data-" + e4, "") : n4.removeAttribute("data-" + e4);
          }), t4.attributes.popper = {};
        }
      } }];
      M2() && l3 && u3.push({ name: "arrow", options: { element: l3, padding: 3 } }), u3.push.apply(u3, (null == n3 ? void 0 : n3.modifiers) || []), y2.popperInstance = L_(c3, w2, Object.assign({}, n3, { placement: r3, onFirstUpdate: a2, modifiers: u3 }));
    }
    function Z2() {
      y2.popperInstance && (y2.popperInstance.destroy(), y2.popperInstance = null);
    }
    function $2() {
      return K_(w2.querySelectorAll("[data-tippy-root]"));
    }
    function ee2(e3) {
      y2.clearDelayTimeouts(), e3 && D2("onTrigger", [y2, e3]), j2();
      var t3 = R2(true), r3 = C2(), i3 = r3[0], s3 = r3[1];
      ig.isTouch && "hold" === i3 && s3 && (t3 = s3), t3 ? n2 = setTimeout(function() {
        y2.show();
      }, t3) : y2.show();
    }
    function te2(e3) {
      if (y2.clearDelayTimeouts(), D2("onUntrigger", [y2, e3]), y2.state.isVisible) {
        if (!(y2.props.trigger.indexOf("mouseenter") >= 0 && y2.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(e3.type) >= 0 && p2)) {
          var t3 = R2(false);
          t3 ? r2 = setTimeout(function() {
            y2.state.isVisible && y2.hide();
          }, t3) : i2 = requestAnimationFrame(function() {
            y2.hide();
          });
        }
      } else
        z2();
    }
  }
  function Eg(e2, t2) {
    void 0 === t2 && (t2 = {});
    var n2 = ug.plugins.concat(t2.plugins || []);
    document.addEventListener("touchstart", og, G_), window.addEventListener("blur", lg);
    var r2, i2 = Object.assign({}, t2, { plugins: n2 }), s2 = (r2 = e2, $_(r2) ? [r2] : function(e3) {
      return Q_(e3, "NodeList");
    }(r2) ? K_(r2) : Array.isArray(r2) ? r2 : K_(document.querySelectorAll(r2))).reduce(function(e3, t3) {
      var n3 = t3 && xg(t3, i2);
      return n3 && e3.push(n3), e3;
    }, []);
    return $_(e2) ? s2[0] : s2;
  }
  Eg.defaultProps = ug, Eg.setDefaultProps = function(e2) {
    Object.keys(e2).forEach(function(t2) {
      ug[t2] = e2[t2];
    });
  }, Eg.currentInput = ig;
  var Cg = Object.assign({}, g_, { effect: function(e2) {
    var t2 = e2.state, n2 = { popper: { position: t2.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
    Object.assign(t2.elements.popper.style, n2.popper), t2.styles = n2, t2.elements.arrow && Object.assign(t2.elements.arrow.style, n2.arrow);
  } }), Sg = function(e2, t2) {
    var n2;
    void 0 === t2 && (t2 = {});
    var r2, i2 = e2, s2 = [], o2 = [], a2 = t2.overrides, l2 = [], c2 = false;
    function u2() {
      o2 = i2.map(function(e3) {
        return X_(e3.props.triggerTarget || e3.reference);
      }).reduce(function(e3, t3) {
        return e3.concat(t3);
      }, []);
    }
    function p2() {
      s2 = i2.map(function(e3) {
        return e3.reference;
      });
    }
    function d2(e3) {
      i2.forEach(function(t3) {
        e3 ? t3.enable() : t3.disable();
      });
    }
    function h2(e3) {
      return i2.map(function(t3) {
        var n3 = t3.setProps;
        return t3.setProps = function(i3) {
          n3(i3), t3.reference === r2 && e3.setProps(i3);
        }, function() {
          t3.setProps = n3;
        };
      });
    }
    function f2(e3, t3) {
      var n3 = o2.indexOf(t3);
      if (t3 !== r2) {
        r2 = t3;
        var l3 = (a2 || []).concat("content").reduce(function(e4, t4) {
          return e4[t4] = i2[n3].props[t4], e4;
        }, {});
        e3.setProps(Object.assign({}, l3, { getReferenceClientRect: "function" == typeof l3.getReferenceClientRect ? l3.getReferenceClientRect : function() {
          var e4;
          return null == (e4 = s2[n3]) ? void 0 : e4.getBoundingClientRect();
        } }));
      }
    }
    d2(false), p2(), u2();
    var m2, _2, g2, v2 = { fn: function() {
      return { onDestroy: function() {
        d2(true);
      }, onHidden: function() {
        r2 = null;
      }, onClickOutside: function(e3) {
        e3.props.showOnCreate && !c2 && (c2 = true, r2 = null);
      }, onShow: function(e3) {
        e3.props.showOnCreate && !c2 && (c2 = true, f2(e3, s2[0]));
      }, onTrigger: function(e3, t3) {
        f2(e3, t3.currentTarget);
      } };
    } }, y2 = Eg(Z_(), Object.assign({}, (m2 = t2, _2 = ["overrides"], g2 = Object.assign({}, m2), _2.forEach(function(e3) {
      delete g2[e3];
    }), g2), { plugins: [v2].concat(t2.plugins || []), triggerTarget: o2, popperOptions: Object.assign({}, t2.popperOptions, { modifiers: [].concat((null == (n2 = t2.popperOptions) ? void 0 : n2.modifiers) || [], [Cg]) }) })), b2 = y2.show;
    y2.show = function(e3) {
      if (b2(), !r2 && null == e3)
        return f2(y2, s2[0]);
      if (!r2 || null != e3) {
        if ("number" == typeof e3)
          return s2[e3] && f2(y2, s2[e3]);
        if (i2.indexOf(e3) >= 0) {
          var t3 = e3.reference;
          return f2(y2, t3);
        }
        return s2.indexOf(e3) >= 0 ? f2(y2, e3) : void 0;
      }
    }, y2.showNext = function() {
      var e3 = s2[0];
      if (!r2)
        return y2.show(0);
      var t3 = s2.indexOf(r2);
      y2.show(s2[t3 + 1] || e3);
    }, y2.showPrevious = function() {
      var e3 = s2[s2.length - 1];
      if (!r2)
        return y2.show(e3);
      var t3 = s2.indexOf(r2), n3 = s2[t3 - 1] || e3;
      y2.show(n3);
    };
    var w2 = y2.setProps;
    return y2.setProps = function(e3) {
      a2 = e3.overrides || a2, w2(e3);
    }, y2.setInstances = function(e3) {
      d2(true), l2.forEach(function(e4) {
        return e4();
      }), i2 = e3, d2(false), p2(), u2(), l2 = h2(y2), y2.setProps({ triggerTarget: o2 });
    }, l2 = h2(y2), y2;
  };
  Eg.setDefaultProps({ render: yg });
  var Mg = Eg;
  class Tg {
    static _initialize() {
      this._inited = true, (0, t.createStyles)(t.css`
          #customContextMenu {
            background: #2c2c2e99;
            backdrop-filter: blur(8px);
            border: 0.5px solid rgba(20, 20, 20, 0.3);
            width: auto;
            height: auto;
            position: absolute;
            display: flex;
            flex-direction: column;
            z-index: 9999;
            padding: 0.35rem 0.20rem;
            border-radius: 0.375rem;
            min-width: 6rem;
            pointer-events: auto;
            box-shadow: 0px 2px 10px rgba(12, 12, 12, 0.2);
          }

          .customContextMenuItems {
            color: white;
            font-size: 0.65rem;
            font-family: "Roboto Mono", "Source Code Pro", Menlo, Courier, monospace;
            background-color: transparent;
            cursor: pointer;
            padding: 0.12rem 0.35rem;
            border-radius: 0.25rem;
            line-height: 1rem;
            font-weight: 500;
          }

          .customContextMenuItems:hover {
            color: white;
            background-color: #017AFF;
          }
        `), document.addEventListener("mouseup", (e2) => {
        this.Element && !this.Element.contains(e2.target) && 0 === e2.button && this.Remove();
      });
    }
    static Create(e2, n2, r2) {
      this._inited || this._initialize(), this.Element && this.Remove();
      const i2 = (0, t.createDiv)({ id: "customContextMenu", addToBody: false });
      i2.style.top = r2 + "px", i2.style.left = n2 + "px";
      for (const [n3, r3] of Object.entries(e2)) {
        const e3 = (0, t.createDiv)({ classList: ["customContextMenuItems"], addToBody: false, innerHTML: n3 });
        i2.appendChild(e3), e3.onclick = r3;
      }
      return this.Element = i2, i2;
    }
    static Remove() {
      var e2;
      null === (e2 = this.Element) || void 0 === e2 || e2.remove(), this.Element = void 0;
    }
  }
  Tg.Element = void 0, Tg._inited = false;
  class Pg extends om {
    constructor() {
      super(...arguments), this.enableEditContextMenus = false;
    }
    async _refreshUi() {
      var e2;
      if (!await super._refreshUi())
        return false;
      am.RemoveAll(Pg.PluginType);
      for (const e3 of this.variations)
        am.Create(Pg.PluginType, e3.title + (this.enableEditContextMenus ? " (" + e3.uuid + ")" : ""), 5, 20, 0, e3.materials.map((n2) => {
          let r2;
          if (e3.preview.startsWith("generate:"))
            r2 = this._previewGenerator.generate(n2, e3.preview.split(":")[1]);
          else {
            const i2 = n2[e3.preview] || "#ff00ff";
            r2 = i2.image ? (0, t.imageBitmapToBase64)(i2.image, 100) : void 0, r2 || (r2 = (0, t.makeColorSvgCircle)((null == i2 ? void 0 : i2.isColor) ? i2.getHexString() : i2));
          }
          return { id: n2.uuid, image: r2, onClick: (t2) => this.applyVariation(e3, t2), tooltip: n2.name || n2.uuid };
        }), (t2, n2, r2) => {
          Mg(t2, { placement: "bottom", content: n2.tooltip }), t2.oncontextmenu = (t3) => {
            if (!this.enableEditContextMenus)
              return;
            t3.preventDefault(), t3.stopPropagation();
            const r3 = Tg.Create({ Remove: async () => {
              var t4;
              await (null === (t4 = this._viewer) || void 0 === t4 ? void 0 : t4.confirm("Remove material: Remove material from this variation list?")) && (e3.materials = e3.materials.filter((e4) => e4.uuid !== n2.id), this.refreshUi(), Tg.Remove());
            }, "Remove All": async () => {
              var t4;
              await (null === (t4 = this._viewer) || void 0 === t4 ? void 0 : t4.confirm("Remove all: Remove all materials from this variation list?")) && (e3.materials = [], this.refreshUi(), Tg.Remove());
            } }, t3.clientX, t3.clientY);
            document.body.appendChild(r3);
          }, r2.oncontextmenu = (t3) => {
            if (!this.enableEditContextMenus)
              return;
            t3.preventDefault(), t3.stopPropagation();
            const n3 = Tg.Create({ "Rename mapping": async () => {
              var t4;
              const n4 = await (null === (t4 = this._viewer) || void 0 === t4 ? void 0 : t4.prompt("Change name: New material name to map to", e3.uuid, true));
              n4 && (e3.uuid = n4, this.refreshUi());
            }, "Rename title": async () => {
              var t4;
              const n4 = await (null === (t4 = this._viewer) || void 0 === t4 ? void 0 : t4.prompt("Change name: New material name to map to", e3.title, true));
              n4 && (e3.title = n4, this.refreshUi());
            }, "Remove Section": async () => {
              var t4;
              await (null === (t4 = this._viewer) || void 0 === t4 ? void 0 : t4.confirm("Remove variations: Remove this category of variations?")) && (this.removeVariation(e3), Tg.Remove());
            } }, t3.clientX, t3.clientY);
            document.body.appendChild(n3);
          };
        });
      return am.RebuildUi(null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.container), true;
    }
  }
  Pg.PluginType = "MaterialConfiguratorPlugin";
  class Ig extends gt {
    constructor() {
      super(...arguments), this.enabled = true, this._uiNeedRefresh = false, this._isVisibleChanged = false, this.dependencies = [Ls], this.variations = [], this._selectedSwitchNode = () => {
        var e2;
        const t2 = null === (e2 = this._picking) || void 0 === e2 ? void 0 : e2.getSelectedObject();
        if (!t2)
          return;
        const n2 = this.variations.map((e3) => e3.name);
        let r2;
        return t2.traverseAncestors((e3) => {
          r2 || e3.name && n2.includes(e3.name) && (r2 = e3);
        }), r2;
      }, this.uiConfig = { label: "Switch Node", type: "folder", children: [{ type: "checkbox", label: "Enabled", property: [this, "enabled"] }, () => [{ type: "folder", label: "All nodes", expanded: true, children: [this.variations.map((e2) => ({ type: "input", label: e2.title, property: [e2, "name"], onChange: () => this.refreshUi() }))] }, { type: "button", label: "Add Node", value: () => {
        this.variations.push({ name: "switch_node", selected: "", title: "Switch Node", camView: "front", camDistance: 1 }), this.refreshUi();
      } }, { type: "button", label: "Refresh UI", value: () => this.refreshUi() }, { type: "input", label: "Selected node title", hidden: () => !this._selectedSwitchNode(), property: () => {
        const e2 = this._selectedSwitchNode();
        return e2 ? [this.variations.find((t2) => t2.name === e2.name), "title"] : [];
      }, onChange: () => this.refreshUi() }, { type: "slider", bounds: [0.01, 2], stepSize: 0.01, label: "Cam Distance", hidden: () => !this._selectedSwitchNode(), property: () => {
        const e2 = this._selectedSwitchNode();
        return e2 ? [this.variations.find((t2) => t2.name === e2.name), "camDistance"] : [];
      } }, { type: "dropdown", label: "Cam View", hidden: () => !this._selectedSwitchNode(), property: () => {
        const e2 = this._selectedSwitchNode();
        return e2 ? [this.variations.find((t2) => t2.name === e2.name), "camView"] : [];
      }, onChange: () => this.refreshUi(), children: ["top", "bottom", "front", "back", "left", "right"].map((e2) => ({ label: e2, value: e2 })) }]] };
    }
    async onAdded(e2) {
      var t2, n2;
      await super.onAdded(e2), this._picking = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPluginByType("Picking"), null === (n2 = this._picking) || void 0 === n2 || n2.addEventListener("selectedObjectChanged", () => {
        var e3, t3;
        null === (t3 = (e3 = this.uiConfig).uiRefresh) || void 0 === t3 || t3.call(e3);
      }), e2.addEventListener("postFrame", () => {
        this._uiNeedRefresh && this._refreshUi();
      }), e2.addEventListener("preRender", () => {
        if (this._viewer && this.enabled) {
          for (const e3 of this.variations) {
            if (!e3.name)
              continue;
            const t3 = this._viewer.scene.getObjectByName(e3.name);
            if (!t3 || t3.children.length < 1)
              return;
            e3.selected || (e3.selected = t3.children[0].name || t3.children[0].uuid);
            for (const n3 of t3.children)
              n3.userData.__oldVisible = n3.visible, n3.visible = (n3.name || n3.uuid) === e3.selected;
          }
          this._isVisibleChanged = true;
        }
      }), e2.addEventListener("postRender", () => {
        if (this._viewer && this._isVisibleChanged) {
          for (const e3 of this.variations) {
            if (!e3.name)
              continue;
            const t3 = this._viewer.scene.getObjectByName(e3.name);
            if (!t3 || t3.children.length < 1)
              return;
            for (const e4 of t3.children) {
              if (void 0 === e4.userData.__oldVisible)
                return;
              e4.visible = e4.userData.__oldVisible, delete e4.userData.__oldVisible;
            }
          }
          this._isVisibleChanged = false;
        }
      }), this.addEventListener("deserialize", async () => {
        this.refreshUi();
      });
    }
    refreshUi() {
      this.enabled && (this._uiNeedRefresh = true);
    }
    _refreshUi() {
      var e2, t2;
      return !!this.enabled && !!this._viewer && (this._uiNeedRefresh = false, null === (t2 = (e2 = this.uiConfig).uiRefresh) || void 0 === t2 || t2.call(e2), true);
    }
  }
  !function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    s2 > 3 && o2 && Object.defineProperty(t2, n2, o2);
  }([ie()], Ig.prototype, "variations", void 0);
  class Rg extends Ig {
    _refreshUi() {
      var e2;
      if (!super._refreshUi())
        return false;
      am.RemoveAll(Rg.PluginType);
      for (const e3 of this.variations) {
        const t2 = this._viewer.scene.getObjectByName(e3.name);
        t2 ? (t2.children.length < 1 && console.warn("SwitchNode does not have enough children", e3), am.Create(Rg.PluginType, e3.title, Math.min(5, t2.children.length), 20, 0, t2.children.map((t3) => {
          const r2 = e3.camView, i2 = new n.Pa4((r2.includes("right") ? 1 : 0) - (r2.includes("left") ? 1 : 0), (r2.includes("top") ? 1 : 0) - (r2.includes("bottom") ? 1 : 0), (r2.includes("front") ? 1 : 0) - (r2.includes("back") ? 1 : 0));
          e3.camDistance || (e3.camDistance = 1);
          const s2 = im(this._viewer, t3, void 0, 7, i2.multiplyScalar(0.5 * e3.camDistance));
          return { id: t3.uuid, image: s2, onClick: () => {
            var n2;
            e3.selected = t3.name || t3.uuid, null === (n2 = this._viewer) || void 0 === n2 || n2.scene.setDirty({ sceneUpdate: true, frameFade: true });
          }, tooltip: t3.name || t3.uuid };
        }), (e4, t3) => Mg(e4, { placement: "bottom", content: t3.tooltip }))) : console.warn("no object found for variation, skipping", e3);
      }
      return am.RebuildUi(null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.container), true;
    }
  }
  Rg.PluginType = "SwitchNodePlugin";
  class kg extends gt {
    constructor() {
      super(...arguments), this.enabled = true, this._uiNeedRefresh = false, this._refreshUiConfig = () => {
        var e2, t2;
        this.enabled && (null === (t2 = null === (e2 = this.uiConfig) || void 0 === e2 ? void 0 : e2.uiRefresh) || void 0 === t2 || t2.call(e2, "postFrame", true));
      }, this.dependencies = [Ls], this._selectedObject = () => {
        var e2;
        return (null === (e2 = this._picking) || void 0 === e2 ? void 0 : e2.getSelectedObject()) || void 0;
      }, this._selectedMaterial = () => {
        var e2;
        return (null === (e2 = this._selectedObject()) || void 0 === e2 ? void 0 : e2.material) || void 0;
      };
    }
    async onAdded(e2) {
      var t2, n2;
      await super.onAdded(e2), this.refreshUi = this.refreshUi.bind(this), this._refreshUi = this._refreshUi.bind(this), this._picking = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPluginByType("Picking"), this._previewGenerator = new sm(this._viewer), null === (n2 = this._picking) || void 0 === n2 || n2.addEventListener("selectedObjectChanged", this._refreshUiConfig), e2.addEventListener("preFrame", this._refreshUi), this.addEventListener("deserialize", this.refreshUi);
    }
    async onRemove(e2) {
      var t2, n2;
      return null === (t2 = this._previewGenerator) || void 0 === t2 || t2.dispose(), this._previewGenerator = void 0, null === (n2 = this._picking) || void 0 === n2 || n2.removeEventListener("selectedObjectChanged", this._refreshUiConfig), this.removeEventListener("deserialize", this.refreshUi), e2.removeEventListener("preFrame", this._refreshUi), this._picking = void 0, super.onRemove(e2);
    }
    refreshUi() {
      this.enabled && (this._uiNeedRefresh = true);
    }
    async _refreshUi() {
      return this._uiNeedRefresh && this.enabled && this._refreshUiConfig(), this._uiNeedRefresh = false, false;
    }
  }
  kg.PluginType = "MaterialLibraryBasePlugin", function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    s2 > 3 && o2 && Object.defineProperty(t2, n2, o2);
  }([Oe("Enabled")], kg.prototype, "enabled", void 0);
  class Dg extends kg {
    constructor() {
      super(...arguments), this.replaceMaterial = false, this.uiConfig = { type: "folder", label: "Material Library", uuid: ke(), children: [...He(this), () => ({ type: "dropdown", label: "Apply Material", limitedUi: true, hidden: () => !this._selectedObject(), children: [{ label: "select one", value: "" }, [...this._viewer.getPlugin(Ls).materials.getAllMaterials().map((e2) => ({ label: e2.name || e2.uuid, value: e2.uuid })) || []]], getValue: () => {
        var e2;
        return null === (e2 = this._selectedMaterial()) || void 0 === e2 ? void 0 : e2.uuid;
      }, setValue: (e2) => {
        var t2, n2, r2, i2, s2;
        const o2 = null === (r2 = null === (n2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(Ls)) || void 0 === n2 ? void 0 : n2.materials) || void 0 === r2 ? void 0 : r2.findMaterial(e2);
        if (o2)
          if (this.replaceMaterial)
            null === (s2 = null === (i2 = this._selectedObject()) || void 0 === i2 ? void 0 : i2.setMaterial) || void 0 === s2 || s2.call(i2, o2);
          else {
            const e3 = this._selectedMaterial();
            if (e3) {
              const t3 = e3.name, n3 = e3.uuid;
              e3.copyProps(o2), e3.name = t3, e3.uuid = n3, e3.userData.uuid && (e3.userData.uuid = n3);
            }
          }
        this._refreshUi();
      } })] };
    }
    async _refreshUi() {
      var e2, n2, r2;
      if (!await super._refreshUi())
        return false;
      const i2 = [It.TypeSlug, Kl.TypeSlug], s2 = null === (n2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPlugin(Ls)) || void 0 === n2 ? void 0 : n2.materials, o2 = i2.map((e3) => [e3, null == s2 ? void 0 : s2.getMaterialsOfType(e3)]);
      am.RemoveAll(Dg.PluginType);
      for (const [e3, n3] of o2)
        am.Create(Dg.PluginType, e3, 5, 20, 0, null == n3 ? void 0 : n3.filter((e4) => !e4.userData.runtimeMaterial).map((e4) => {
          let n4;
          const r3 = "generate:sphere";
          if (r3.startsWith("generate:"))
            n4 = this._previewGenerator.generate(e4, r3.split(":")[1]);
          else {
            const i3 = e4[r3] || "#ff00ff";
            n4 = i3.image ? (0, t.imageBitmapToBase64)(i3.image, 100) : void 0, n4 || (n4 = (0, t.makeColorSvg)(i3));
          }
          return { id: e4.uuid, image: n4, onClick: (e5) => {
            const t2 = null == s2 ? void 0 : s2.findMaterial(e5);
            if (t2) {
              const e6 = t2.userData.__appliedMeshes;
              if (null == e6 ? void 0 : e6.size) {
                const t3 = e6.keys().next().value;
                t3.dispatchEvent({ type: "select", value: t3 });
              }
            }
          }, tooltip: e4.name || e4.uuid };
        }), (e4, t2) => Mg(e4, { placement: "bottom", content: t2.tooltip }));
      return am.RebuildUi(null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.container), true;
    }
  }
  Dg.PluginType = "MaterialLibraryPlugin", function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    s2 > 3 && o2 && Object.defineProperty(t2, n2, o2);
  }([Oe("Replace Material")], Dg.prototype, "replaceMaterial", void 0);
  class Bg extends n.Tn7 {
    constructor() {
      super(...arguments), this.typeSlug = "fsShadow", this.assetType = "material", this._uniforms = {}, this.lastFrameTexture = null;
    }
    get materialObject() {
      return this;
    }
    onBeforeCompile(e2, n2) {
      e2.vertexShader = e2.vertexShader.replace("#include <project_vertex>", "\n#include <project_vertex>\ngl_Position = vec4(uv*2.-1., 0, 1.); \n        "), e2.vertexShader = e2.vertexShader.replace("void main() {", "\nvarying vec2 vUv;\nvoid main() {\n    vUv = uv;\n        "), e2.fragmentShader = e2.fragmentShader.replace("void main() {", "\nvarying vec2 vUv;\nuniform sampler2D tLastThis;\nvoid main() {\n        "), e2.fragmentShader = e2.fragmentShader.replace("gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );", t.glsl`
float shadow = getShadowMask();

//shift the color by dither_shift
shadow = clamp(shadow + mix(-1./512., 1./512., rand( gl_FragCoord.xy )), 0., 1.);

float last = unpackRGBAToDepth(texture2D(tLastThis, vUv));
gl_FragColor = packDepthToRGBA(mix(last, shadow, opacity));
//if not useMovingAverage:
//gl_FragColor = packDepthToRGBA(shadow * opacity + last);
        `), Object.assign(e2.uniforms, this._uniforms), super.onBeforeCompile(e2, n2);
    }
    customProgramCacheKey() {
      return super.customProgramCacheKey();
    }
    toJSON(e2) {
      throw new Error("Method not supported for this material.");
    }
    fromJSON(e2, t2) {
      throw new Error("Method not supported for this material.");
    }
    copyProps(e2) {
      throw new Error("Method not supported for this material.");
    }
    setDirty(e2) {
      this.needsUpdate = true, this.dispatchEvent({ ...e2, type: "materialUpdate" });
    }
  }
  !function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    s2 > 3 && o2 && Object.defineProperty(t2, n2, o2);
  }([j({ propKey: "tLastThis" })], Bg.prototype, "lastFrameTexture", void 0);
  var Og = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  class Lg extends t.SimpleEventDispatcher {
    get attachedMesh() {
      return this._attachedMesh;
    }
    set attachedMesh(e2) {
      this._attachedMesh !== e2 && (this._attachedMesh && this.cleanupMaterial(), this._attachedMesh = e2, this._attachedMesh && this._updateMaterial());
    }
    get target() {
      return this._target;
    }
    get light() {
      return this._light;
    }
    constructor(e2) {
      super(), this.enabled = true, this._lightLayer = 5, this._frameNumber = 0, this.maxFrameNumber = 400, this.smoothShadow = false, this.shadowMapType = n._MY, this.groundMapMode = "aoMap", this.alphaVignette = true, this.alphaVignetteAxis = "xy", this.shadowAutoUpdate = true, this._bakeCounter = 0, this.maxBakeCount = 1 / 0, this.materialExtension = { parsFragmentSnippet: (e3, n2) => t.glsl`
            uniform float transitionOpacity;
            `, extraUniforms: { transitionOpacity: { value: 1 } }, shaderExtender: (e3, r3, i2) => {
        "aoMap" === this.groundMapMode ? e3.fragmentShader = ot(e3.fragmentShader, "#include <aomap_fragment>", ot(n.WdD.aomap_fragment, "float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;", "float ambientOcclusion = ( mix(1., unpackRGBAToDepth(texture2D( aoMap, vAoMapUv ) ), transitionOpacity) - 1.0) * aoMapIntensity + 1.0;")) : "map" === this.groundMapMode ? e3.fragmentShader = ot(e3.fragmentShader, "#include <map_fragment>", ot(n.WdD.map_fragment, "diffuseColor *= texture2D( map, vMapUv );", "float groundShadow = mix(1., unpackRGBAToDepth(texture2D( map, vMapUv )), transitionOpacity); diffuseColor.rgb *= groundShadow; diffuseColor.a *= max(0., 1.-groundShadow) * transitionOpacity;")) : "alphaMap" === this.groundMapMode && (e3.fragmentShader = ot(e3.fragmentShader, "#include <alphamap_fragment>", ot(n.WdD.alphamap_fragment, "texture2D( alphaMap, vAlphaMapUv ).g", "1. - unpackRGBAToDepth( texture2D( alphaMap, vAlphaMapUv ) )", { replaceAll: true }))), e3.fragmentShader = ot(e3.fragmentShader, "#include <output_fragment>", t.glsl`#include <output_fragment>
                #ifndef OPAQUE
                    #ifdef USE_AOMAP
                        #if NUM_DIR_LIGHT_SHADOWS > 0
                            // TODO find a better solution
                            float alphaMod = length(reflectedLight.directDiffuse)*4./float(NUM_DIR_LIGHT_SHADOWS);
                        #else
                            float alphaMod = 1.;
                        #endif
                        float t1 = 1. - ambientOcclusion;
                        float t2 = max(1. - alphaMod, 0.);
                        float t = t1 + t2;
                        gl_FragColor.a *= max(t, 0.);
                    #endif
                #endif
            `), this.alphaVignette && i2.capabilities.isWebGL2 && (e3.defines.USE_UV = "", e3.fragmentShader = ot(e3.fragmentShader, "#include <output_fragment>", t.glsl`#include <output_fragment>
                    #ifndef OPAQUE
                    float weight = 0.;
                    #ifdef USE_UV // why are we checking for this? this is always supposed to be true
                    weight = 2.*abs(length(0.5 - vUv.${this.alphaVignetteAxis}));
                    #endif
                    #if defined(USE_LIGHTMAP) || defined(USE_AOMAP)
                    weight = 2.*abs(length(0.5 - vAoMapUv.${this.alphaVignetteAxis}));
                    #endif
                    weight = min(1., max(0., weight))-0.5;
                    weight = min(1., max(0., 1.0-2.*weight));
                    weight = pow(weight, 1.5);
                    gl_FragColor.a *= weight;
                    //gl_FragColor.rgb /= max(0.01, weight);
                    gl_FragColor = saturate(gl_FragColor);
                    //gl_FragColor.a = 0.5;
                    #endif
                    `));
      }, computeCacheKey: () => this.groundMapMode + "." + this.alphaVignette + "." + this.alphaVignetteAxis, onObjectRender: (e3, t2) => {
        t2.materialObject.userData.gMapMode !== this.groundMapMode && (t2.materialObject.userData.gMapMode = this.groundMapMode, t2.materialObject.needsUpdate = true);
      }, isCompatible: (e3) => e3.isMeshStandardMaterial2 }, this._viewer = e2;
      const r2 = new gl(16777215, 10, { near: 1.5, far: 20, bias: 0, frustumSize: 4, width: 1024, height: 1024, enabled: true, radius: 10, normalBias: 0 }, { direction: new n.Pa4(0.2, 1, 0.2).normalize(), spread: 0.9, focus: 1, distanceScale: 20, minDistanceScale: new n.Pa4(10, 10, 10), normalDirection: new n.Pa4(0, 1, 0) });
      r2.shadow.camera.updateProjectionMatrix(), r2.layers.disableAll(), r2.layers.set(this._lightLayer), this._light = r2, e2.scene.addLight(this._light, { addToRoot: true }), this._shadowMat = new Bg({ color: "#ffffff", toneMapped: false, depthWrite: false, depthTest: false, premultipliedAlpha: false, opacity: 1, transparent: false, blending: n.jFi }), this._shadowBlurMat = new ct({ uniforms: { colorTexture: { value: null }, step: { value: 0.1 }, size: { value: new n.FM8(0.5, 0.5) }, direction: { value: new n.FM8(0.5, 0.5) } }, vertexShader: lo, fragmentShader: "#include <packing>\nuniform sampler2D colorTexture;uniform vec2 size;uniform vec2 direction;uniform float step;varying vec2 vUv;void main(){float sum=0.;vec2 uvDelta=step*direction/size;sum+=unpackRGBAToDepth(texture2D(colorTexture,vUv-1.*uvDelta))*0.3333;sum+=unpackRGBAToDepth(texture2D(colorTexture,vec2(vUv.x,vUv.y)))*0.3333;sum+=unpackRGBAToDepth(texture2D(colorTexture,vUv+1.*uvDelta))*0.3333;gl_FragColor=packDepthToRGBA(sum);}" });
    }
    dispose() {
      this._shadowMat.dispose(), this._target = void 0, this.reset();
    }
    cleanupMaterial() {
      this._updateMaterial(true);
    }
    _groundMapModeChanged() {
      this._attachedMesh && (this.cleanupMaterial(), this._updateMaterial(), "alphaMap" === this.groundMapMode ? this._attachedMesh.material.transparent = true : this._attachedMesh.material.transparent = false), this.reset();
    }
    _alphaVignetteChanged() {
      var e2, t2, n2;
      null === (t2 = null === (e2 = this.materialExtension) || void 0 === e2 ? void 0 : e2.setDirty) || void 0 === t2 || t2.call(e2), null === (n2 = this._viewer) || void 0 === n2 || n2.setDirty();
    }
    fromJSON(e2, t2) {
      return ce(e2, this, true, t2), this.reset(), this;
    }
    reset() {
      this._frameNumber = 0;
    }
    get frameNumber() {
      return this._frameNumber;
    }
    autoUpdateShadow() {
      return !(!this.shadowAutoUpdate || this._bakeCounter >= this.maxBakeCount || !this.updateShadow() || (this._frameNumber === this.maxFrameNumber ? this.dispatchEvent({ type: "shadowBaked", bakeCount: ++this._bakeCounter }) : this._frameNumber > 0 && this._frameNumber < this.maxFrameNumber && this.dispatchEvent({ type: "shadowBaking", progress: this._frameNumber / this.maxFrameNumber, bakeCount: this._bakeCounter }), 0));
    }
    updateShadow() {
      if (!this.enabled)
        return false;
      const e2 = this._attachedMesh;
      if (!e2)
        return false;
      if (++this._frameNumber > this.maxFrameNumber)
        return false;
      const t2 = 1024;
      this._target || (this._target = this._viewer.renderer.createTarget({ type: n.ywz, depthBuffer: false, size: new n.FM8(t2, t2), sizeMultiplier: void 0, colorSpace: n.aCh, format: n.wk1 })), this._frameNumber < 3 ? this._light.randomizePosition(0, 1, 0) : this._light.randomizePosition(this._frameNumber), e2.castShadow = false;
      const r2 = this._viewer.renderer.rendererObject, i2 = r2.shadowMap, s2 = i2.type, o2 = i2.needsUpdate, a2 = i2.autoUpdate;
      i2.type = this.shadowMapType, i2.needsUpdate = true, i2.autoUpdate = false;
      const l2 = this._viewer.scene, c2 = new n.S9g();
      c2.disableAll(), l2.modelObject.traverse((e3) => {
        e3.isLight && e3 !== this._light.lightObject && (e3.userData.__gp_layers = e3.layers, e3.layers = c2);
      });
      const u2 = l2.activeCamera.cameraObject;
      if (0 != (u2.layers.mask & 1 << this._lightLayer))
        throw "Camera can render pseudo directional light, check layers";
      u2.layers.enable(this._lightLayer), e2.layers.disable(this._lightLayer), H(r2, { shadowMapRender: true, backgroundRender: false, sceneRender: false }, () => this._viewer.renderer.renderScene(l2)), u2.layers.disable(this._lightLayer);
      const p2 = u2.layers.mask;
      u2.layers.set(this._lightLayer), e2.layers.enable(this._lightLayer);
      const d2 = this._viewer.renderer.getTempTarget({ type: n.ywz, depthBuffer: false, size: new n.FM8(t2, t2), colorSpace: n.aCh, format: n.wk1 }), h2 = d2.texture.colorSpace;
      d2.texture.colorSpace = n.aCh, this._viewer.renderer.blit(this._target.texture, d2, { clear: true });
      {
        const t3 = e2.material, n2 = e2.frustumCulled, i3 = r2.getRenderTarget(), s3 = r2.getActiveCubeFace(), o3 = r2.getActiveMipmapLevel();
        e2.material = this._shadowMat, e2.frustumCulled = false, r2.setRenderTarget(this._target);
        const a3 = false;
        this._shadowMat.opacity = a3 ? 1 / this.maxFrameNumber : Math.max(1 / this.maxFrameNumber, 1 / this._frameNumber), this._shadowMat.lastFrameTexture = d2.texture, this._shadowMat.needsUpdate = true, H(r2, { shadowMapRender: false, backgroundRender: false, opaqueRender: true, transparentRender: false, transmissionRender: false }, () => this._viewer.renderer.renderScene(l2)), r2.setRenderTarget(i3, s3, o3), e2.frustumCulled = n2, e2.material = t3, this.smoothShadow && this._applySmoothFilter(this._target, d2);
      }
      return d2.texture.colorSpace = h2, this._viewer.renderer.releaseTempTarget(d2), e2.layers.disable(this._lightLayer), u2.layers.mask = p2, l2.modelObject.traverse((e3) => {
        e3.isLight && e3 !== this._light.lightObject && (e3.layers = e3.userData.__gp_layers, delete e3.userData.__gp_layers);
      }), i2.type = s2, i2.needsUpdate = o2, i2.autoUpdate = a2, e2.castShadow = true, (this._frameNumber < 3 || this._frameNumber > Math.min(100, this.maxFrameNumber) && this._frameNumber % 4 == 0) && (this._updateMaterial(), this._viewer.setDirty(), e2.dispatchEvent({ type: "materialUpdate" })), true;
    }
    _updateMaterial(e2 = false) {
      var t2, n2, r2;
      this._attachedMesh && (e2 ? (this._attachedMesh.material.alphaMap === (null === (t2 = this._target) || void 0 === t2 ? void 0 : t2.texture) && (this._attachedMesh.material.alphaMap = null), this._attachedMesh.material.aoMap === (null === (n2 = this._target) || void 0 === n2 ? void 0 : n2.texture) && (this._attachedMesh.material.aoMap = null), this._attachedMesh.material.map === (null === (r2 = this._target) || void 0 === r2 ? void 0 : r2.texture) && (this._attachedMesh.material.map = null)) : this._target && ("alphaMap" === this.groundMapMode && (this._attachedMesh.material.alphaMap = this._target.texture), "aoMap" === this.groundMapMode && (this._attachedMesh.material.aoMap = this._target.texture), "map" === this.groundMapMode && (this._attachedMesh.material.map = this._target.texture)), this._attachedMesh.material && (this._attachedMesh.material.userData.ALPHA_I_RGBA_PACKING = !e2 && "alphaMap" === this.groundMapMode, this._attachedMesh.material.alphaTest = e2 || "alphaMap" !== this.groundMapMode ? 0 : 0.01, this._attachedMesh.material.needsUpdate = true));
    }
    _applySmoothFilter(e2, t2) {
      this._shadowBlurMat.uniforms.colorTexture.value = e2.texture, this._shadowBlurMat.uniforms.direction.value.set(1, 0), this._shadowBlurMat.uniforms.size.value.set(e2.width, e2.height), this._viewer.renderer.blit(void 0, t2, { material: this._shadowBlurMat }), this._shadowBlurMat.uniforms.colorTexture.value = t2.texture, this._shadowBlurMat.uniforms.direction.value.set(0, 1), this._shadowBlurMat.uniforms.size.value.set(t2.width, t2.height), this._viewer.renderer.blit(void 0, e2, { material: this._shadowBlurMat });
    }
  }
  Og([ie("randomizedLight")], Lg.prototype, "_light", void 0), Og([(0, t.onChange)(Lg.prototype.reset), ie()], Lg.prototype, "maxFrameNumber", void 0), Og([(0, t.onChange)(Lg.prototype.reset), ie()], Lg.prototype, "smoothShadow", void 0), Og([ie(), (0, t.onChange)(Lg.prototype.reset)], Lg.prototype, "shadowMapType", void 0), Og([(0, t.onChange)(Lg.prototype._groundMapModeChanged), ie()], Lg.prototype, "groundMapMode", void 0), Og([ie(), (0, t.onChange)(Lg.prototype._alphaVignetteChanged)], Lg.prototype, "alphaVignette", void 0), Og([ie(), (0, t.onChange)(Lg.prototype._alphaVignetteChanged)], Lg.prototype, "alphaVignetteAxis", void 0), Og([ie()], Lg.prototype, "maxBakeCount", void 0);
  var Ug = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  class Fg extends n.Kj0 {
    _updateExtension() {
      var e2, t2;
      this.transparentReflectionBackground = this.reflectorModePhysical, null === (t2 = null === (e2 = this.materialExtension) || void 0 === e2 ? void 0 : e2.setDirty) || void 0 === t2 || t2.call(e2);
    }
    constructor(e2, t2, r2 = 0) {
      super(e2), this.type = "Reflector", this.isReflector2 = true, this.enabled = true, this.reflectorModePhysical = true, this.reflectionTargetNeedsUpdate = true, this.transparentReflectionBackground = true, this.materialExtension = { extraUniforms: { tRefDiffuse: { value: null }, tRefDiffuseSize: { value: new n.FM8() }, refTextureMatrix: { value: null }, frameCount: { value: 0 }, sceneBoundingRadius: { value: 0 } }, extraDefines: { USE_UV: "" }, updaters: [], shaderExtender: (e3, t3, n2) => {
        if (this.enabled) {
          e3.vertexShader = ot(e3.vertexShader, "void main() {", "void main() {\nvRefUv = refTextureMatrix * vec4( position, 1.0 );");
          const t4 = "#glMarker beforeModulation";
          e3.fragmentShader = ot(e3.fragmentShader, t4, "\n                    if(roughnessFactor < 0.95) {\n                        float d = 0.;//textureProj(tRefDepth, vRefUv).r;\n                        // d = min(2., max(0., (d-0.06) * ((7./3.-ior)) * sceneBoundingRadius));\n                        vec4 refBaseColor = getReflectionColor(material.roughness, material.roughness * d);\n                        // refBaseColor.rgb = vec3(refBaseColor.a);\n                        // refBaseColor.a *= 1.0 - clamp(material.roughness * .3, 0., 1.);\n                        " + (this.reflectorModePhysical ? "\n                        #if !defined(SSR_ENABLED) || SSR_ENABLED < 1 \n                        vec3 specularColor = EnvironmentBRDF(geometry.normal, geometry.viewDir, material.specularColor.rgb, material.specularF90, material.roughness);\n                        #endif\n                        reflectedLight.indirectSpecular = mix(vec3(reflectedLight.indirectSpecular), saturate(specularColor.rgb * refBaseColor.rgb), refBaseColor.a);\n                        " : "\n                        reflectedLight.indirectSpecular = saturate(diffuseColor.rgb * refBaseColor.rgb);\n                        diffuseColor.a *= refBaseColor.a;\n                        ") + "}\n" + t4);
        }
      }, parsVertexSnippet: () => this.enabled ? "\n		uniform mat4 refTextureMatrix;\n		varying vec4 vRefUv;\n" : "", parsFragmentSnippet: () => this.enabled ? bo + "\n" + co + "\n#ifndef D_sceneBoundingRadius\n#define D_sceneBoundingRadius \nuniform float sceneBoundingRadius;\n#endif\nvarying vec4 vRefUv;uniform sampler2D tRefDiffuse;uniform vec2 tRefDiffuseSize;float getSpecularMIPLevel(const in float roughness,const in float maxMIPLevel){float sigma=PI*roughness*roughness/(1.+roughness);float desiredMIPLevel=maxMIPLevel+log2(sigma);return clamp(desiredMIPLevel,0.,maxMIPLevel);}vec4 getReflectionColor(const in float roughness,const in float depthModifier){float mip=getSpecularMIPLevel(roughness+depthModifier,5.);vec4 color=texture2D(tRefDiffuse,vRefUv.xy/vRefUv.w,mip);float blurDist=saturate(2./(1.+pow(abs(vViewPosition.z),0.25)))*mip*32.*color.a;float rnd=PI2*interleavedGradientNoise(vUv.xy,frameCount);vec4 rotationMatrix=vec4(cos(rnd),-sin(rnd),0.,0.);rotationMatrix.z=-rotationMatrix.y;rotationMatrix.w=rotationMatrix.x;vec3 colorSum=color.rgb*color.a;float weightSum=0.001+color.a;vec2 ofs;setPds();\n#pragma unroll_loop_start\nfor(int i=0;i<16;i++){ofs=poisson_disk_samples[UNROLLED_LOOP_INDEX];ofs=vec2(dot(ofs,rotationMatrix.xy),dot(ofs,rotationMatrix.zw));ofs=vRefUv.xy+vRefUv.w*blurDist*ofs/tRefDiffuseSize.xy;color=texture2D(tRefDiffuse,ofs/vRefUv.w,mip);colorSum+=color.rgb*color.a;weightSum+=color.a;}\n#pragma unroll_loop_end\nreturn vec4(colorSum/weightSum,1.);}" : "", computeCacheKey: (e3) => this.enabled + " " + e3.materialObject.transparent + " " + this.reflectorModePhysical + " ", onObjectRender: (e3, { materialObject: t3 }) => {
        t3.userData.__lastTransparent !== t3.transparent && (t3.needsUpdate = true, t3.userData.__lastTransparent = t3.transparent);
      }, isCompatible: (e3) => e3.isMeshStandardMaterial2 }, this.material = void 0, this._renderTarget = t2;
      const i2 = new n.JOQ(), s2 = new n.Pa4(), o2 = new n.Pa4(), a2 = new n.Pa4(), l2 = new n.yGw(), c2 = new n.Pa4(0, 0, -1), u2 = new n.Ltg(), p2 = new n.Pa4(), d2 = new n.Pa4(), h2 = new n.Ltg(), f2 = new n.yGw(), m2 = new n.cPb();
      n.M8C.isPowerOfTwo(t2.texture.image.width) && n.M8C.isPowerOfTwo(t2.texture.image.height) || (this._renderTarget.texture.generateMipmaps = false), this.onBeforeRender = (e3, t3, n2) => {
        if (!this.enabled || !e3.userData.mainRenderPass)
          return;
        if (!this.reflectionTargetNeedsUpdate)
          return;
        const _2 = n2.view ? Object.assign({}, n2.view) : null;
        if (_2 && n2.clearViewOffset && n2.clearViewOffset(), o2.setFromMatrixPosition(this.matrixWorld), a2.setFromMatrixPosition(n2.matrixWorld), l2.extractRotation(this.matrixWorld), s2.set(0, 0, 1), s2.applyMatrix4(l2), p2.subVectors(o2, a2), p2.dot(s2) > 0)
          return;
        p2.reflect(s2).negate(), p2.add(o2), l2.extractRotation(n2.matrixWorld), c2.set(0, 0, -1), c2.applyMatrix4(l2), c2.add(a2), d2.subVectors(o2, c2), d2.reflect(s2).negate(), d2.add(o2), m2.position.copy(p2), m2.up.set(0, 1, 0), m2.up.applyMatrix4(l2), m2.up.reflect(s2), m2.lookAt(d2), m2.far = 2, m2.near = 0, m2.updateMatrixWorld(), m2.projectionMatrix.copy(n2.projectionMatrix), f2.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), f2.multiply(m2.projectionMatrix), f2.multiply(m2.matrixWorldInverse), f2.multiply(this.matrixWorld), i2.setFromNormalAndCoplanarPoint(s2, o2), i2.applyMatrix4(m2.matrixWorldInverse), u2.set(i2.normal.x, i2.normal.y, i2.normal.z, i2.constant);
        const g2 = m2.projectionMatrix;
        h2.x = (Math.sign(u2.x) + g2.elements[8]) / g2.elements[0], h2.y = (Math.sign(u2.y) + g2.elements[9]) / g2.elements[5], h2.z = -1, h2.w = (1 + g2.elements[10]) / g2.elements[14], u2.multiplyScalar(2 / u2.dot(h2)), g2.elements[2] = u2.x, g2.elements[6] = u2.y, g2.elements[10] = u2.z + 1 - r2, g2.elements[14] = u2.w, this.visible = false;
        const v2 = e3.getRenderTarget(), y2 = e3.xr.enabled, b2 = e3.shadowMap.autoUpdate;
        e3.xr.enabled = false, e3.shadowMap.autoUpdate = false, e3.setRenderTarget(this._renderTarget), e3.state.buffers.depth.setMask(true), false === e3.autoClear && e3.clear();
        const w2 = t3.background;
        this.transparentReflectionBackground && (t3.background = null);
        const A2 = !this.transparentReflectionBackground;
        (null == w2 ? void 0 : w2.isTexture) && A2 && (w2.userData || (w2.userData = {}), w2.userData.flipX = !w2.userData.flipX), H(e3, { shadowMapRender: false, backgroundRender: A2, opaqueRender: true, transparentRender: true, transmissionRender: false, screenSpaceRendering: false }, () => e3.render(t3, m2)), (null == w2 ? void 0 : w2.isTexture) && A2 && (w2.userData.flipX = !w2.userData.flipX || void 0), this.transparentReflectionBackground && (t3.background = w2), e3.xr.enabled = y2, e3.shadowMap.autoUpdate = b2, e3.setRenderTarget(v2), (null == _2 ? void 0 : _2.enabled) && n2.setViewOffset && n2.setViewOffset(_2.fullWidth, _2.fullHeight, _2.offsetX, _2.offsetY, _2.width, _2.height);
        const x2 = n2.viewport;
        void 0 !== x2 && e3.state.viewport(x2), this.visible = true, this.reflectionTargetNeedsUpdate = false;
      }, this.textureMatrix = f2, this.materialExtension.extraUniforms.tRefDiffuse.value = this._renderTarget.texture, this.materialExtension.extraUniforms.tRefDiffuseSize.value = new n.FM8(this._renderTarget.width, this._renderTarget.height), this.materialExtension.extraUniforms.refTextureMatrix.value = f2;
    }
    getRenderTarget() {
      return this._renderTarget;
    }
  }
  Ug([(0, t.onChange)(Fg.prototype._updateExtension)], Fg.prototype, "enabled", void 0), Ug([(0, t.onChange)(Fg.prototype._updateExtension)], Fg.prototype, "reflectorModePhysical", void 0), Fg.prototype.isReflector = true;
  var Ng = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  class jg extends gt {
    get enabled() {
      return this.visible;
    }
    set enabled(e2) {
      this.visible = e2;
    }
    get material() {
      return this._material;
    }
    get mesh() {
      return this._iMesh;
    }
    constructor(e2 = {}) {
      super(), this._transformNeedRefresh = true, this.dependencies = [Ls], this.visible = true, this.size = 8, this.yOffset = 0, this.renderToDepth = true, this.tonemapGround = true, this.limitCameraAboveGround = false, this.enableRefreshTransform = true, this._cameraLimitsSet = false, this._cameraLastMaxPolarAngle = Math.PI, this._refreshMaterial = this._refreshMaterial.bind(this), this._refreshTransform = this._refreshTransform.bind(this), this._refreshCameraLimits = this._refreshCameraLimits.bind(this), this.refreshOptions = this.refreshOptions.bind(this), this._refreshOptions2 = this._refreshOptions2.bind(this), this._onSceneUpdate = this._onSceneUpdate.bind(this), this._preRender = this._preRender.bind(this), this._postFrame = this._postFrame.bind(this), this._geometry = new n._12(1, 1, 1, 1), this._geometry.attributes.uv2 = this._geometry.attributes.uv.clone(), this._geometry.attributes.uv2.needsUpdate = true, this._options = { shape: "", up: [0, 100, 0], autoAdjustTransform: true }, this.setOptions(e2);
    }
    get autoAdjustTransform() {
      return this._options.autoAdjustTransform;
    }
    set autoAdjustTransform(e2) {
      this._options.autoAdjustTransform = e2, this.refreshTransform();
    }
    _createMesh() {
      return new n.Kj0(this._geometry);
    }
    async onAdded(e2) {
      var t2, n2;
      await super.onAdded(e2), e2.getPluginByType("TweakpaneUi") && console.error("TweakpaneUiPlugin must be added after Ground Plugin"), this._manager = e2.getPlugin(Ls);
      const r2 = this._createMesh();
      r2.userData.physicsMass = 0, this._iMesh = await (null === (t2 = this._manager) || void 0 === t2 ? void 0 : t2.addImportedSingle(r2, { pseudoCenter: false, autoScale: false, addToRoot: true })), this._mesh = null === (n2 = this._iMesh) || void 0 === n2 ? void 0 : n2.modelObject, this._mesh && (this._mesh.userData.userSelectable = false, this._mesh.castShadow = true, this._mesh.receiveShadow = true, this._mesh.name = "Ground Plane"), e2.scene.addEventListener("sceneUpdate", this._onSceneUpdate), e2.scene.addEventListener("addSceneObject", this._onSceneUpdate), e2.addEventListener("preRender", this._preRender), e2.addEventListener("postFrame", this._postFrame), this.refreshOptions();
    }
    _postFrame() {
      this._transformNeedRefresh && this._refreshTransform(), this._viewer;
    }
    _preRender() {
      this._viewer;
    }
    async onDispose(e2) {
      var t2, n2, r2;
      return this._removeMaterial(), this._geometry.dispose(), null === (t2 = this._material) || void 0 === t2 || t2.dispose(), null === (r2 = null === (n2 = this._iMesh) || void 0 === n2 ? void 0 : n2.dispose) || void 0 === r2 || r2.call(n2), super.onDispose(e2);
    }
    async onRemove(e2) {
      return this._removeMaterial(), e2.scene.removeEventListener("sceneUpdate", this._onSceneUpdate), e2.scene.removeEventListener("addSceneObject", this._onSceneUpdate), e2.removeEventListener("postFrame", this._postFrame), e2.removeEventListener("preRender", this._preRender), this._manager = void 0, super.onRemove(e2);
    }
    _removeMaterial() {
      this._material && (this._material.userData.renderToDepth = this._material.userData.__renderToDepth, this._material.userData.__renderToDepth = void 0, this._material = void 0);
    }
    _onSceneUpdate(e2) {
      false !== (null == e2 ? void 0 : e2.geometryChanged) && false !== (null == e2 ? void 0 : e2.updateGround) && this.refreshTransform();
    }
    refreshTransform() {
      this.enableRefreshTransform && (this._transformNeedRefresh = true);
    }
    _refreshOptions2() {
      this.refreshOptions();
    }
    refreshOptions() {
      this._viewer && (this._refreshMaterial(), this.refreshTransform(), this._refreshCameraLimits());
    }
    _refreshCameraLimits() {
      var e2;
      const t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.scene.activeCamera.controls;
      t2 && (void 0 !== t2.maxPolarAngle ? this.limitCameraAboveGround ? (this._cameraLimitsSet || (this._cameraLastMaxPolarAngle = t2.maxPolarAngle), t2.maxPolarAngle = Math.PI / 2, this._cameraLimitsSet = true) : this._cameraLimitsSet && (t2.maxPolarAngle = this._cameraLastMaxPolarAngle, this._cameraLimitsSet = false) : console.warn("refreshCameraLimits only available with orbit controls."));
    }
    _refreshTransform() {
      var e2, t2, r2;
      if (!this._mesh)
        return;
      if (!this._viewer)
        return;
      let i2 = false;
      if (this.visible !== this._mesh.visible && (this._mesh.visible = this.visible, i2 = true), this.enabled) {
        if (this._options.autoAdjustTransform) {
          this._mesh.userData.bboxVisible = false;
          const e3 = this._viewer.scene.getBounds(true);
          this._mesh.userData.bboxVisible = true;
          const t3 = e3.getCenter(new n.Pa4()).sub(new n.Pa4(0, e3.getSize(new n.Pa4()).y / 2 + this.yOffset, 0));
          i2 = i2 || t3.clone().sub(this._mesh.position).length() > 1e-4, i2 && this._mesh.position.copy(t3);
        }
        i2 = i2 || Math.abs(this._mesh.scale.x - this.size) > 1e-4, i2 && (this._mesh.scale.setScalar(this.size), this._mesh.setRotationFromEuler(new n.USm(-Math.PI / 2, 0, this._mesh.rotation.z)), this._mesh.matrixWorldNeedsUpdate = true, null === (r2 = (t2 = this._mesh).setDirty) || void 0 === r2 || r2.call(t2)), this._transformNeedRefresh = false;
      } else
        i2 && (null === (e2 = this._viewer) || void 0 === e2 || e2.scene.setDirty());
    }
    _refreshMaterial() {
      var e2, t2, n2, r2, i2, s2;
      if (!this._viewer)
        return false;
      if (!this.enabled)
        return false;
      this._manager || console.error("GroundPlugin requires asset manager");
      const o2 = null !== (e2 = this._material) && void 0 !== e2 ? e2 : null === (n2 = null === (t2 = this._manager) || void 0 === t2 ? void 0 : t2.materials) || void 0 === n2 ? void 0 : n2.findOrCreate("standard", { name: "BaseGroundMaterial", runtimeMaterial: true, color: 16777215 });
      o2 && o2.userData.runtimeMaterial;
      let a2 = false;
      if (o2 !== this._material) {
        if (this._removeMaterial(), o2 && (this._material = o2), (null === (r2 = this._material) || void 0 === r2 ? void 0 : r2.uuid) || console.warn("No material found for ground"), this._viewer.scene.setDirty(), this._mesh && this._material) {
          this._material.roughness = 0.2, this._material.metalness = 0.5;
          (null !== (s2 = null === (i2 = this._mesh) || void 0 === i2 ? void 0 : i2.setMaterial) && void 0 !== s2 ? s2 : (e3) => {
            this._mesh && (this._mesh.material = e3.materialObject);
          })(this._material);
        }
        a2 = true;
      }
      return this._material && (void 0 === this._material.userData.__renderToDepth && (this._material.userData.__renderToDepth = this._material.userData.renderToDepth), this._material.userData.renderToDepth !== this.renderToDepth && (this._material.userData.renderToDepth = this.renderToDepth), void 0 === this._material.userData.__postTonemap && (this._material.userData.__postTonemap = this._material.userData.postTonemap), this._material.userData.postTonemap !== this.tonemapGround && (this._material.userData.postTonemap = this.tonemapGround), this._material.materialObject.userData.ssaoDisabled = true, this._material.materialObject.userData.sscsDisabled = true), this._viewer.setDirty(this), a2;
    }
    setOptions(e2) {
      Object.assign(this._options, e2), this.refreshOptions();
    }
    fromJSON(e2, t2) {
      return super.fromJSON(e2, t2) ? (this.refreshOptions(), this) : null;
    }
    _extraUiConfig() {
      return [() => {
        var e2;
        return null === (e2 = this._material) || void 0 === e2 ? void 0 : e2.uiConfig;
      }];
    }
    get uiConfig() {
      return this._uiConfig ? this._uiConfig : this._uiConfig = { type: "folder", label: "Ground", children: [{ label: "Visible", type: "checkbox", property: [this, "visible"], limitedUi: true }, { label: "Size", type: "input", property: [this, "size"], limitedUi: true }, { label: "Render to Depth", type: "checkbox", property: [this, "renderToDepth"] }, { label: "Limit Camera", type: "checkbox", property: [this, "limitCameraAboveGround"] }, { label: "Tonemap", type: "checkbox", property: [this, "tonemapGround"] }, { label: "Height", type: "slider", bounds: [-2, 2], property: [this, "yOffset"] }, { label: "Auto adjust transform", type: "checkbox", property: [this, "autoAdjustTransform"] }, ...this._extraUiConfig()] };
    }
  }
  Ng([ie("material")], jg.prototype, "_material", void 0), Ng([(0, t.onChange)(jg.prototype.refreshTransform), ie()], jg.prototype, "visible", void 0), Ng([(0, t.onChange2)(jg.prototype._onSceneUpdate), ie()], jg.prototype, "size", void 0), Ng([(0, t.onChange2)(jg.prototype._onSceneUpdate), ie()], jg.prototype, "yOffset", void 0), Ng([(0, t.onChange)(jg.prototype._refreshOptions2), ie()], jg.prototype, "renderToDepth", void 0), Ng([(0, t.onChange)(jg.prototype._refreshOptions2), ie()], jg.prototype, "tonemapGround", void 0), Ng([(0, t.onChange)(jg.prototype._refreshCameraLimits), ie()], jg.prototype, "limitCameraAboveGround", void 0);
  var zg = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  class Gg extends jg {
    get shadowBaker() {
      return this._shadowBaker;
    }
    bakeShadows() {
      var e2;
      null === (e2 = this._shadowBaker) || void 0 === e2 || e2.reset();
    }
    constructor(e2 = {}, t2 = false) {
      super(e2), this.bakedShadows = true, this.groundReflection = false, this.physicalReflections = false, this.autoBakeShadows = true, this._showDebug = t2, t2 && this.dependencies.push(bh), this._onSceneUpdate = this._onSceneUpdate.bind(this);
    }
    _createMesh() {
      const e2 = new Fg(this._geometry, this._viewer.renderer.createTarget({ type: n.ywz, format: n.wk1, colorSpace: n.aCh, size: { width: 1024, height: 1024 }, generateMipmaps: true, depthBuffer: true, minFilter: n.D1R, magFilter: n.wem })), t2 = e2.onBeforeRender;
      return e2.onBeforeRender = (...e3) => {
        var n2, r2, i2, s2, o2;
        let a2 = null === (r2 = null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.getPluginByType("SSReflection")) || void 0 === r2 ? void 0 : r2.passes.ssr.passObject;
        a2 && !a2.enabled && (a2 = void 0), a2 && (a2.enabled = false);
        let l2 = null === (o2 = null === (s2 = null === (i2 = this._viewer) || void 0 === i2 ? void 0 : i2.getPluginByType("SSBevelPlugin")) || void 0 === s2 ? void 0 : s2.pass) || void 0 === o2 ? void 0 : o2.passObject;
        l2 && !l2.enabled && (l2 = void 0), l2 && (l2.enabled = false), t2(...e3), a2 && (a2.enabled = true), l2 && (l2.enabled = true);
      }, e2;
    }
    async onAdded(e2) {
      var t2, n2;
      await super.onAdded(e2), this._showDebug && (null === (t2 = e2.getPlugin(bh)) || void 0 === t2 || t2.addTexture("bake_ground_1", () => {
        var e3, t3;
        return null === (t3 = null === (e3 = this._shadowBaker) || void 0 === e3 ? void 0 : e3.light.shadow.map) || void 0 === t3 ? void 0 : t3.texture;
      }, [100, 100, 200, 200]), null === (n2 = e2.getPlugin(bh)) || void 0 === n2 || n2.addTexture("bake_ground_2", () => {
        var e3, t3;
        return null === (t3 = null === (e3 = this._shadowBaker) || void 0 === e3 ? void 0 : e3.target) || void 0 === t3 ? void 0 : t3.texture;
      }, [100, 400, 400, 400], "texel = vec4(vec3(unpackRGBAToDepth(texel)), 1.0);"));
    }
    _postFrame() {
      super._postFrame(), this._viewer && this.enabled && this._shadowBaker && this.bakedShadows && this._shadowBaker.autoUpdateShadow();
    }
    _preRender() {
      super._preRender(), this._viewer && (this._mesh.reflectionTargetNeedsUpdate = this._viewer.renderer.frameCount < 1);
    }
    async onDispose(e2) {
      return super.onDispose(e2);
    }
    async onRemove(e2) {
      return super.onRemove(e2);
    }
    _removeMaterial() {
      var e2, t2, n2, r2;
      if (this._material) {
        if (this._shadowBaker && this._material.groundMatExtension && (null === (t2 = (e2 = this._material).unregisterMaterialExtensions) || void 0 === t2 || t2.call(e2, [this._shadowBaker.materialExtension]), delete this._material.groundMatExtension), this._material.reflectorMatExtension) {
          const e3 = this._mesh.materialExtension;
          e3 || console.warn("WebGi GroundPlugin: unable to find the extension to unregister"), null === (r2 = (n2 = this._material).unregisterMaterialExtensions) || void 0 === r2 || r2.call(n2, [e3]), delete this._material.reflectorMatExtension;
        }
        super._removeMaterial();
      }
    }
    _onSceneUpdate(e2) {
      var t2;
      super._onSceneUpdate(e2), false !== e2.geometryChanged && this.autoBakeShadows && (null === (t2 = this._shadowBaker) || void 0 === t2 || t2.reset());
    }
    refreshOptions() {
      if (!this._viewer)
        return;
      this.bakedShadows && !this._shadowBaker ? (this._shadowBaker = new Lg(this._viewer), this._shadowBaker.attachedMesh = this._mesh) : !this.bakedShadows && this._shadowBaker && (this._shadowBaker.reset(), this._shadowBaker.cleanupMaterial());
      const e2 = this._mesh;
      e2.isReflector2 && (e2.enabled = this.groundReflection, e2.reflectorModePhysical = this.physicalReflections), super.refreshOptions(), this._viewer.setDirty(this);
    }
    _refreshMaterial() {
      var e2, t2, n2, r2;
      if (!this._viewer)
        return false;
      const i2 = super._refreshMaterial();
      if (!this._material)
        return i2;
      if (this.groundReflection && this._mesh.isReflector2 && !this._material.reflectorMatExtension) {
        const n3 = this._mesh.materialExtension;
        n3.updaters = [this._viewer.scene, this._viewer.renderer], null === (t2 = (e2 = this._material).registerMaterialExtensions) || void 0 === t2 || t2.call(e2, [n3]), this._material.reflectorMatExtension = true;
      }
      return this.bakedShadows && this._shadowBaker && !this._material.groundMatExtension && (null === (r2 = (n2 = this._material).registerMaterialExtensions) || void 0 === r2 || r2.call(n2, [this._shadowBaker.materialExtension]), this._material.groundMatExtension = true), this._material.materialObject.userData.ssreflDisabled = this.groundReflection, this._material.materialObject.userData.ssreflNonPhysical = !this.physicalReflections, this._viewer.setDirty(this), i2;
    }
    _extraUiConfig() {
      var e2, t2, r2, i2, s2, o2, a2, l2, c2, u2, p2, d2, h2, f2, m2, _2, g2, v2, y2, b2, w2, A2, x2, E2, C2, S2, M2, T2, P2, I2;
      return [{ label: "Baked Shadows", type: "checkbox", property: [this, "bakedShadows"] }, { label: "Shadow Frames", type: "input", hidden: () => !this._shadowBaker, stepSize: 1, bounds: [1, 1e3], property: [this._shadowBaker, "maxFrameNumber"] }, { label: "Alpha Vignette", type: "checkbox", hidden: () => !this._material || this._material.transmission < 1e-4 && !this._material.transparent, property: [this._shadowBaker, "alphaVignette"], limitedUi: true, onChange: () => {
        var e3, t3;
        return null === (t3 = null === (e3 = this._uiConfig) || void 0 === e3 ? void 0 : e3.uiRefresh) || void 0 === t3 ? void 0 : t3.call(e3, "postFrame", true);
      } }, { label: "Alpha Vignette Axis", type: "dropdown", hidden: () => {
        var e3;
        return !(null === (e3 = this._shadowBaker) || void 0 === e3 ? void 0 : e3.alphaVignette) || !this._material || this._material.transmission < 1e-4 && !this._material.transparent;
      }, property: [this._shadowBaker, "alphaVignetteAxis"], children: ["x", "y", "xy"].map((e3) => ({ label: e3, value: e3 })), limitedUi: true }, { label: "Planar Reflections", type: "checkbox", property: [this, "groundReflection"], limitedUi: true }, { label: "Physical Reflections", type: "checkbox", property: [this, "physicalReflections"], limitedUi: true }, { label: "Shadow type", type: "dropdown", hidden: () => !this._shadowBaker, property: [this._shadowBaker, "groundMapMode"], children: [{ label: "aoMap" }, { label: "map" }, { label: "alphaMap" }], limitedUi: true }, { label: "Smooth Shadow", type: "checkbox", property: [this._shadowBaker, "smoothShadow"] }, { label: "Baked shadow type", type: "dropdown", children: [["Basic", n._MY], ["PCF", n._iA], ["PCFSoft", n.ntZ], ["VSM", n.dwk]].map((e3) => ({ label: e3[0].toString(), value: e3[1] })), property: [this._shadowBaker, "shadowMapType"] }, { type: "folder", label: "Randomized Light", hidden: () => !this._shadowBaker, limitedUi: true, children: [{ type: "color", label: "Color", property: [null === (e2 = this._shadowBaker) || void 0 === e2 ? void 0 : e2.light, "color"] }, { type: "slider", label: "Intensity", bounds: [0, 100], property: [null === (t2 = this._shadowBaker) || void 0 === t2 ? void 0 : t2.light, "intensity"] }, { type: "checkbox", label: "Shadow Enabled", property: [null === (i2 = null === (r2 = this._shadowBaker) || void 0 === r2 ? void 0 : r2.light) || void 0 === i2 ? void 0 : i2.shadowParams, "enabled"], onChange: [null === (o2 = null === (s2 = this._shadowBaker) || void 0 === s2 ? void 0 : s2.light) || void 0 === o2 ? void 0 : o2.updateShadowParams, this._onSceneUpdate] }, { type: "slider", bounds: [0, 1], property: [null === (l2 = null === (a2 = this._shadowBaker) || void 0 === a2 ? void 0 : a2.light) || void 0 === l2 ? void 0 : l2.randomParams, "focus"], onChange: [this._onSceneUpdate] }, { type: "slider", bounds: [0, 1], property: [null === (u2 = null === (c2 = this._shadowBaker) || void 0 === c2 ? void 0 : c2.light) || void 0 === u2 ? void 0 : u2.randomParams, "spread"], onChange: [this._onSceneUpdate], limitedUi: true }, { type: "slider", bounds: [0.01, 60], property: [null === (d2 = null === (p2 = this._shadowBaker) || void 0 === p2 ? void 0 : p2.light) || void 0 === d2 ? void 0 : d2.randomParams, "distanceScale"], onChange: [null === (f2 = null === (h2 = this._shadowBaker) || void 0 === h2 ? void 0 : h2.light) || void 0 === f2 ? void 0 : f2.updateShadowParams, this._onSceneUpdate] }, { type: "vec3", bounds: [-1, 1], property: [null === (_2 = null === (m2 = this._shadowBaker) || void 0 === m2 ? void 0 : m2.light) || void 0 === _2 ? void 0 : _2.randomParams, "direction"], onChange: [this._onSceneUpdate], limitedUi: true }, { type: "vec3", bounds: [-1, 1], property: [null === (v2 = null === (g2 = this._shadowBaker) || void 0 === g2 ? void 0 : g2.light) || void 0 === v2 ? void 0 : v2.randomParams, "normalDirection"], onChange: [this._onSceneUpdate], limitedUi: true }, { type: "slider", bounds: [0.01, 10], property: [null === (b2 = null === (y2 = this._shadowBaker) || void 0 === y2 ? void 0 : y2.light) || void 0 === b2 ? void 0 : b2.shadowParams, "radius"], onChange: [null === (A2 = null === (w2 = this._shadowBaker) || void 0 === w2 ? void 0 : w2.light) || void 0 === A2 ? void 0 : A2.updateShadowParams, this._onSceneUpdate] }, { type: "input", property: [null === (E2 = null === (x2 = this._shadowBaker) || void 0 === x2 ? void 0 : x2.light) || void 0 === E2 ? void 0 : E2.shadowParams, "frustumSize"], onChange: [null === (S2 = null === (C2 = this._shadowBaker) || void 0 === C2 ? void 0 : C2.light) || void 0 === S2 ? void 0 : S2.updateShadowParams, this._onSceneUpdate] }, { type: "slider", bounds: [-0.1, 0.1], property: [null === (T2 = null === (M2 = this._shadowBaker) || void 0 === M2 ? void 0 : M2.light) || void 0 === T2 ? void 0 : T2.shadowParams, "bias"], onChange: [null === (I2 = null === (P2 = this._shadowBaker) || void 0 === P2 ? void 0 : P2.light) || void 0 === I2 ? void 0 : I2.updateShadowParams, this._onSceneUpdate] }] }, ...super._extraUiConfig()];
    }
  }
  Gg.PluginType = "Ground", zg([(0, t.onChange)(Gg.prototype.refreshOptions), ie()], Gg.prototype, "bakedShadows", void 0), zg([(0, t.onChange)(Gg.prototype.refreshOptions), ie()], Gg.prototype, "groundReflection", void 0), zg([(0, t.onChange)(Gg.prototype.refreshOptions), ie()], Gg.prototype, "physicalReflections", void 0), zg([ie("shadowBaker")], Gg.prototype, "_shadowBaker", void 0);
  class Vg extends n.yxD {
    constructor(e2) {
      super(e2), this.type = n.cLu;
    }
    parse(e2) {
      const t2 = 65536, r2 = t2 >> 3, i2 = 14, s2 = 65537, o2 = 1 << i2, a2 = o2 - 1, l2 = 32768, c2 = 65535, u2 = 59, p2 = 63, d2 = 2 + p2 - u2, h2 = 4, f2 = 4, m2 = 2, _2 = 1, g2 = 0, v2 = 1, y2 = 0, b2 = 2, w2 = Math.pow(2.7182818, 2.2), A2 = { l: 0, c: 0, lc: 0 };
      function x2(e3, t3, n2, r3, i3) {
        for (; n2 < e3; )
          t3 = t3 << 8 | ee2(r3, i3), n2 += 8;
        n2 -= e3, A2.l = t3 >> n2 & (1 << e3) - 1, A2.c = t3, A2.lc = n2;
      }
      const E2 = new Array(59);
      function C2(e3) {
        return 63 & e3;
      }
      function S2(e3) {
        return e3 >> 6;
      }
      const M2 = { c: 0, lc: 0 };
      function T2(e3, t3, n2, r3) {
        e3 = e3 << 8 | ee2(n2, r3), t3 += 8, M2.c = e3, M2.lc = t3;
      }
      const P2 = { c: 0, lc: 0 };
      function I2(e3, t3, n2, r3, i3, s3, o3, a3, l3) {
        if (e3 == t3) {
          r3 < 8 && (T2(n2, r3, i3, s3), n2 = M2.c, r3 = M2.lc);
          let e4 = n2 >> (r3 -= 8);
          if (e4 = new Uint8Array([e4])[0], a3.value + e4 > l3)
            return false;
          const t4 = o3[a3.value - 1];
          for (; e4-- > 0; )
            o3[a3.value++] = t4;
        } else {
          if (!(a3.value < l3))
            return false;
          o3[a3.value++] = e3;
        }
        P2.c = n2, P2.lc = r3;
      }
      function R2(e3) {
        return 65535 & e3;
      }
      function k2(e3) {
        const t3 = R2(e3);
        return t3 > 32767 ? t3 - 65536 : t3;
      }
      const D2 = { a: 0, b: 0 };
      function B2(e3, t3) {
        const n2 = k2(e3), r3 = k2(t3), i3 = n2 + (1 & r3) + (r3 >> 1), s3 = i3, o3 = i3 - r3;
        D2.a = s3, D2.b = o3;
      }
      function O2(e3, t3) {
        const n2 = R2(e3), r3 = R2(t3), i3 = n2 - (r3 >> 1) & c2, s3 = r3 + i3 - l2 & c2;
        D2.a = s3, D2.b = i3;
      }
      function L2(e3, t3, n2, r3, i3, s3, o3) {
        const a3 = o3 < 16384, l3 = n2 > i3 ? i3 : n2;
        let c3, u3, p3 = 1;
        for (; p3 <= l3; )
          p3 <<= 1;
        for (p3 >>= 1, c3 = p3, p3 >>= 1; p3 >= 1; ) {
          u3 = 0;
          const o4 = u3 + s3 * (i3 - c3), l4 = s3 * p3, d3 = s3 * c3, h3 = r3 * p3, f3 = r3 * c3;
          let m3, _3, g3, v3;
          for (; u3 <= o4; u3 += d3) {
            let i4 = u3;
            const s4 = u3 + r3 * (n2 - c3);
            for (; i4 <= s4; i4 += f3) {
              const n3 = i4 + h3, r4 = i4 + l4, s5 = r4 + h3;
              a3 ? (B2(e3[i4 + t3], e3[r4 + t3]), m3 = D2.a, g3 = D2.b, B2(e3[n3 + t3], e3[s5 + t3]), _3 = D2.a, v3 = D2.b, B2(m3, _3), e3[i4 + t3] = D2.a, e3[n3 + t3] = D2.b, B2(g3, v3), e3[r4 + t3] = D2.a, e3[s5 + t3] = D2.b) : (O2(e3[i4 + t3], e3[r4 + t3]), m3 = D2.a, g3 = D2.b, O2(e3[n3 + t3], e3[s5 + t3]), _3 = D2.a, v3 = D2.b, O2(m3, _3), e3[i4 + t3] = D2.a, e3[n3 + t3] = D2.b, O2(g3, v3), e3[r4 + t3] = D2.a, e3[s5 + t3] = D2.b);
            }
            if (n2 & p3) {
              const n3 = i4 + l4;
              a3 ? B2(e3[i4 + t3], e3[n3 + t3]) : O2(e3[i4 + t3], e3[n3 + t3]), m3 = D2.a, e3[n3 + t3] = D2.b, e3[i4 + t3] = m3;
            }
          }
          if (i3 & p3) {
            let i4 = u3;
            const s4 = u3 + r3 * (n2 - c3);
            for (; i4 <= s4; i4 += f3) {
              const n3 = i4 + h3;
              a3 ? B2(e3[i4 + t3], e3[n3 + t3]) : O2(e3[i4 + t3], e3[n3 + t3]), m3 = D2.a, e3[n3 + t3] = D2.b, e3[i4 + t3] = m3;
            }
          }
          c3 = p3, p3 >>= 1;
        }
        return u3;
      }
      function U2(e3, t3, n2, r3, l3, c3) {
        const h3 = n2.value, f3 = $2(t3, n2), m3 = $2(t3, n2);
        n2.value += 4;
        const _3 = $2(t3, n2);
        if (n2.value += 4, f3 < 0 || f3 >= s2 || m3 < 0 || m3 >= s2)
          throw new Error("Something wrong with HUF_ENCSIZE");
        const g3 = new Array(s2), v3 = new Array(o2);
        if (function(e4) {
          for (let t4 = 0; t4 < o2; t4++)
            e4[t4] = {}, e4[t4].len = 0, e4[t4].lit = 0, e4[t4].p = null;
        }(v3), function(e4, t4, n3, r4, i3, o3) {
          const a3 = t4;
          let l4 = 0, c4 = 0;
          for (; r4 <= i3; r4++) {
            if (a3.value - t4.value > n3)
              return false;
            x2(6, l4, c4, e4, a3);
            const s3 = A2.l;
            if (l4 = A2.c, c4 = A2.lc, o3[r4] = s3, s3 == p2) {
              if (a3.value - t4.value > n3)
                throw new Error("Something wrong with hufUnpackEncTable");
              x2(8, l4, c4, e4, a3);
              let s4 = A2.l + d2;
              if (l4 = A2.c, c4 = A2.lc, r4 + s4 > i3 + 1)
                throw new Error("Something wrong with hufUnpackEncTable");
              for (; s4--; )
                o3[r4++] = 0;
              r4--;
            } else if (s3 >= u2) {
              let e5 = s3 - u2 + 2;
              if (r4 + e5 > i3 + 1)
                throw new Error("Something wrong with hufUnpackEncTable");
              for (; e5--; )
                o3[r4++] = 0;
              r4--;
            }
          }
          !function(e5) {
            for (let e6 = 0; e6 <= 58; ++e6)
              E2[e6] = 0;
            for (let t6 = 0; t6 < s2; ++t6)
              E2[e5[t6]] += 1;
            let t5 = 0;
            for (let e6 = 58; e6 > 0; --e6) {
              const n4 = t5 + E2[e6] >> 1;
              E2[e6] = t5, t5 = n4;
            }
            for (let t6 = 0; t6 < s2; ++t6) {
              const n4 = e5[t6];
              n4 > 0 && (e5[t6] = n4 | E2[n4]++ << 6);
            }
          }(o3);
        }(e3, n2, r3 - (n2.value - h3), f3, m3, g3), _3 > 8 * (r3 - (n2.value - h3)))
          throw new Error("Something wrong with hufUncompress");
        !function(e4, t4, n3, r4) {
          for (; t4 <= n3; t4++) {
            const n4 = S2(e4[t4]), s3 = C2(e4[t4]);
            if (n4 >> s3)
              throw new Error("Invalid table entry");
            if (s3 > i2) {
              const e5 = r4[n4 >> s3 - i2];
              if (e5.len)
                throw new Error("Invalid table entry");
              if (e5.lit++, e5.p) {
                const t5 = e5.p;
                e5.p = new Array(e5.lit);
                for (let n5 = 0; n5 < e5.lit - 1; ++n5)
                  e5.p[n5] = t5[n5];
              } else
                e5.p = new Array(1);
              e5.p[e5.lit - 1] = t4;
            } else if (s3) {
              let e5 = 0;
              for (let o3 = 1 << i2 - s3; o3 > 0; o3--) {
                const o4 = r4[(n4 << i2 - s3) + e5];
                if (o4.len || o4.p)
                  throw new Error("Invalid table entry");
                o4.len = s3, o4.lit = t4, e5++;
              }
            }
          }
        }(g3, f3, m3, v3), function(e4, t4, n3, r4, s3, o3, l4, c4, u3) {
          let p3 = 0, d3 = 0;
          const h4 = l4, f4 = Math.trunc(r4.value + (s3 + 7) / 8);
          for (; r4.value < f4; )
            for (T2(p3, d3, n3, r4), p3 = M2.c, d3 = M2.lc; d3 >= i2; ) {
              const s4 = t4[p3 >> d3 - i2 & a2];
              if (s4.len)
                d3 -= s4.len, I2(s4.lit, o3, p3, d3, n3, r4, c4, u3, h4), p3 = P2.c, d3 = P2.lc;
              else {
                if (!s4.p)
                  throw new Error("hufDecode issues");
                let t5;
                for (t5 = 0; t5 < s4.lit; t5++) {
                  const i3 = C2(e4[s4.p[t5]]);
                  for (; d3 < i3 && r4.value < f4; )
                    T2(p3, d3, n3, r4), p3 = M2.c, d3 = M2.lc;
                  if (d3 >= i3 && S2(e4[s4.p[t5]]) == (p3 >> d3 - i3 & (1 << i3) - 1)) {
                    d3 -= i3, I2(s4.p[t5], o3, p3, d3, n3, r4, c4, u3, h4), p3 = P2.c, d3 = P2.lc;
                    break;
                  }
                }
                if (t5 == s4.lit)
                  throw new Error("hufDecode issues");
              }
            }
          const m4 = 8 - s3 & 7;
          for (p3 >>= m4, d3 -= m4; d3 > 0; ) {
            const e5 = t4[p3 << i2 - d3 & a2];
            if (!e5.len)
              throw new Error("hufDecode issues");
            d3 -= e5.len, I2(e5.lit, o3, p3, d3, n3, r4, c4, u3, h4), p3 = P2.c, d3 = P2.lc;
          }
        }(g3, v3, e3, n2, _3, m3, c3, l3, { value: 0 });
      }
      function F2(e3) {
        for (let t3 = 1; t3 < e3.length; t3++) {
          const n2 = e3[t3 - 1] + e3[t3] - 128;
          e3[t3] = n2;
        }
      }
      function N2(e3, t3) {
        let n2 = 0, r3 = Math.floor((e3.length + 1) / 2), i3 = 0;
        const s3 = e3.length - 1;
        for (; !(i3 > s3 || (t3[i3++] = e3[n2++], i3 > s3)); )
          t3[i3++] = e3[r3++];
      }
      function j2(e3) {
        let t3 = e3.byteLength;
        const n2 = new Array();
        let r3 = 0;
        const i3 = new DataView(e3);
        for (; t3 > 0; ) {
          const e4 = i3.getInt8(r3++);
          if (e4 < 0) {
            const s3 = -e4;
            t3 -= s3 + 1;
            for (let e5 = 0; e5 < s3; e5++)
              n2.push(i3.getUint8(r3++));
          } else {
            const s3 = e4;
            t3 -= 2;
            const o3 = i3.getUint8(r3++);
            for (let e5 = 0; e5 < s3 + 1; e5++)
              n2.push(o3);
          }
        }
        return n2;
      }
      function z2(e3, t3, n2) {
        let r3, i3 = 1;
        for (; i3 < 64; )
          r3 = t3[e3.value], 65280 == r3 ? i3 = 64 : r3 >> 8 == 255 ? i3 += 255 & r3 : (n2[i3] = r3, i3++), e3.value++;
      }
      function G2(e3) {
        const t3 = 0.5 * Math.cos(0.7853975), n2 = 0.5 * Math.cos(3.14159 / 16), r3 = 0.5 * Math.cos(3.14159 / 8), i3 = 0.5 * Math.cos(3 * 3.14159 / 16), s3 = 0.5 * Math.cos(0.981746875), o3 = 0.5 * Math.cos(3 * 3.14159 / 8), a3 = 0.5 * Math.cos(1.374445625), l3 = new Array(4), c3 = new Array(4), u3 = new Array(4), p3 = new Array(4);
        for (let d3 = 0; d3 < 8; ++d3) {
          const h3 = 8 * d3;
          l3[0] = r3 * e3[h3 + 2], l3[1] = o3 * e3[h3 + 2], l3[2] = r3 * e3[h3 + 6], l3[3] = o3 * e3[h3 + 6], c3[0] = n2 * e3[h3 + 1] + i3 * e3[h3 + 3] + s3 * e3[h3 + 5] + a3 * e3[h3 + 7], c3[1] = i3 * e3[h3 + 1] - a3 * e3[h3 + 3] - n2 * e3[h3 + 5] - s3 * e3[h3 + 7], c3[2] = s3 * e3[h3 + 1] - n2 * e3[h3 + 3] + a3 * e3[h3 + 5] + i3 * e3[h3 + 7], c3[3] = a3 * e3[h3 + 1] - s3 * e3[h3 + 3] + i3 * e3[h3 + 5] - n2 * e3[h3 + 7], u3[0] = t3 * (e3[h3 + 0] + e3[h3 + 4]), u3[3] = t3 * (e3[h3 + 0] - e3[h3 + 4]), u3[1] = l3[0] + l3[3], u3[2] = l3[1] - l3[2], p3[0] = u3[0] + u3[1], p3[1] = u3[3] + u3[2], p3[2] = u3[3] - u3[2], p3[3] = u3[0] - u3[1], e3[h3 + 0] = p3[0] + c3[0], e3[h3 + 1] = p3[1] + c3[1], e3[h3 + 2] = p3[2] + c3[2], e3[h3 + 3] = p3[3] + c3[3], e3[h3 + 4] = p3[3] - c3[3], e3[h3 + 5] = p3[2] - c3[2], e3[h3 + 6] = p3[1] - c3[1], e3[h3 + 7] = p3[0] - c3[0];
        }
        for (let d3 = 0; d3 < 8; ++d3)
          l3[0] = r3 * e3[16 + d3], l3[1] = o3 * e3[16 + d3], l3[2] = r3 * e3[48 + d3], l3[3] = o3 * e3[48 + d3], c3[0] = n2 * e3[8 + d3] + i3 * e3[24 + d3] + s3 * e3[40 + d3] + a3 * e3[56 + d3], c3[1] = i3 * e3[8 + d3] - a3 * e3[24 + d3] - n2 * e3[40 + d3] - s3 * e3[56 + d3], c3[2] = s3 * e3[8 + d3] - n2 * e3[24 + d3] + a3 * e3[40 + d3] + i3 * e3[56 + d3], c3[3] = a3 * e3[8 + d3] - s3 * e3[24 + d3] + i3 * e3[40 + d3] - n2 * e3[56 + d3], u3[0] = t3 * (e3[d3] + e3[32 + d3]), u3[3] = t3 * (e3[d3] - e3[32 + d3]), u3[1] = l3[0] + l3[3], u3[2] = l3[1] - l3[2], p3[0] = u3[0] + u3[1], p3[1] = u3[3] + u3[2], p3[2] = u3[3] - u3[2], p3[3] = u3[0] - u3[1], e3[0 + d3] = p3[0] + c3[0], e3[8 + d3] = p3[1] + c3[1], e3[16 + d3] = p3[2] + c3[2], e3[24 + d3] = p3[3] + c3[3], e3[32 + d3] = p3[3] - c3[3], e3[40 + d3] = p3[2] - c3[2], e3[48 + d3] = p3[1] - c3[1], e3[56 + d3] = p3[0] - c3[0];
      }
      function V2(e3) {
        for (let t3 = 0; t3 < 64; ++t3) {
          const n2 = e3[0][t3], r3 = e3[1][t3], i3 = e3[2][t3];
          e3[0][t3] = n2 + 1.5747 * i3, e3[1][t3] = n2 - 0.1873 * r3 - 0.4682 * i3, e3[2][t3] = n2 + 1.8556 * r3;
        }
      }
      function H2(e3, t3, r3) {
        for (let s3 = 0; s3 < 64; ++s3)
          t3[r3 + s3] = n.A5E.toHalfFloat((i3 = e3[s3]) <= 1 ? Math.sign(i3) * Math.pow(Math.abs(i3), 2.2) : Math.sign(i3) * Math.pow(w2, Math.abs(i3) - 1));
        var i3;
      }
      function Q2(e3) {
        return new DataView(e3.array.buffer, e3.offset.value, e3.size);
      }
      function W2(e3) {
        const t3 = e3.viewer.buffer.slice(e3.offset.value, e3.offset.value + e3.size), n2 = new Uint8Array(j2(t3)), r3 = new Uint8Array(n2.length);
        return F2(n2), N2(n2, r3), new DataView(r3.buffer);
      }
      function q2(e3) {
        const t3 = Pf(e3.array.slice(e3.offset.value, e3.offset.value + e3.size)), n2 = new Uint8Array(t3.length);
        return F2(t3), N2(t3, n2), new DataView(n2.buffer);
      }
      function X2(e3) {
        const n2 = e3.viewer, i3 = { value: e3.offset.value }, s3 = new Uint16Array(e3.width * e3.scanlineBlockSize * (e3.channels * e3.type)), o3 = new Uint8Array(r2);
        let a3 = 0;
        const l3 = new Array(e3.channels);
        for (let t3 = 0; t3 < e3.channels; t3++)
          l3[t3] = {}, l3[t3].start = a3, l3[t3].end = l3[t3].start, l3[t3].nx = e3.width, l3[t3].ny = e3.lines, l3[t3].size = e3.type, a3 += l3[t3].nx * l3[t3].ny * l3[t3].size;
        const c3 = oe2(n2, i3), u3 = oe2(n2, i3);
        if (u3 >= r2)
          throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");
        if (c3 <= u3)
          for (let e4 = 0; e4 < u3 - c3 + 1; e4++)
            o3[e4 + c3] = te2(n2, i3);
        const p3 = new Uint16Array(t2), d3 = function(e4, n3) {
          let r3 = 0;
          for (let i5 = 0; i5 < t2; ++i5)
            (0 == i5 || e4[i5 >> 3] & 1 << (7 & i5)) && (n3[r3++] = i5);
          const i4 = r3 - 1;
          for (; r3 < t2; )
            n3[r3++] = 0;
          return i4;
        }(o3, p3), h3 = $2(n2, i3);
        U2(e3.array, n2, i3, h3, s3, a3);
        for (let t3 = 0; t3 < e3.channels; ++t3) {
          const e4 = l3[t3];
          for (let n3 = 0; n3 < l3[t3].size; ++n3)
            L2(s3, e4.start + n3, e4.nx, e4.size, e4.ny, e4.nx * e4.size, d3);
        }
        !function(e4, t3, n3) {
          for (let r3 = 0; r3 < n3; ++r3)
            t3[r3] = e4[t3[r3]];
        }(p3, s3, a3);
        let f3 = 0;
        const _3 = new Uint8Array(s3.buffer.byteLength);
        for (let t3 = 0; t3 < e3.lines; t3++)
          for (let t4 = 0; t4 < e3.channels; t4++) {
            const e4 = l3[t4], n3 = e4.nx * e4.size, r3 = new Uint8Array(s3.buffer, e4.end * m2, n3 * m2);
            _3.set(r3, f3), f3 += n3 * m2, e4.end += n3;
          }
        return new DataView(_3.buffer);
      }
      function Y2(e3) {
        const t3 = Pf(e3.array.slice(e3.offset.value, e3.offset.value + e3.size)), n2 = e3.lines * e3.channels * e3.width, r3 = 1 == e3.type ? new Uint16Array(n2) : new Uint32Array(n2);
        let i3 = 0, s3 = 0;
        const o3 = new Array(4);
        for (let n3 = 0; n3 < e3.lines; n3++)
          for (let n4 = 0; n4 < e3.channels; n4++) {
            let n5 = 0;
            switch (e3.type) {
              case 1:
                o3[0] = i3, o3[1] = o3[0] + e3.width, i3 = o3[1] + e3.width;
                for (let i4 = 0; i4 < e3.width; ++i4)
                  n5 += t3[o3[0]++] << 8 | t3[o3[1]++], r3[s3] = n5, s3++;
                break;
              case 2:
                o3[0] = i3, o3[1] = o3[0] + e3.width, o3[2] = o3[1] + e3.width, i3 = o3[2] + e3.width;
                for (let i4 = 0; i4 < e3.width; ++i4)
                  n5 += t3[o3[0]++] << 24 | t3[o3[1]++] << 16 | t3[o3[2]++] << 8, r3[s3] = n5, s3++;
            }
          }
        return new DataView(r3.buffer);
      }
      function K2(e3) {
        const t3 = e3.viewer, n2 = { value: e3.offset.value }, r3 = new Uint8Array(e3.width * e3.lines * (e3.channels * e3.type * m2)), i3 = { version: ne2(t3, n2), unknownUncompressedSize: ne2(t3, n2), unknownCompressedSize: ne2(t3, n2), acCompressedSize: ne2(t3, n2), dcCompressedSize: ne2(t3, n2), rleCompressedSize: ne2(t3, n2), rleUncompressedSize: ne2(t3, n2), rleRawSize: ne2(t3, n2), totalAcUncompressedCount: ne2(t3, n2), totalDcUncompressedCount: ne2(t3, n2), acCompression: ne2(t3, n2) };
        if (i3.version < 2)
          throw new Error("EXRLoader.parse: " + de2.compression + " version " + i3.version + " is unsupported");
        const s3 = new Array();
        let o3 = oe2(t3, n2) - m2;
        for (; o3 > 0; ) {
          const e4 = J2(t3.buffer, n2), r4 = te2(t3, n2), i4 = r4 >> 2 & 3, a4 = new Int8Array([(r4 >> 4) - 1])[0], l4 = te2(t3, n2);
          s3.push({ name: e4, index: a4, type: l4, compression: i4 }), o3 -= e4.length + 3;
        }
        const a3 = de2.channels, l3 = new Array(e3.channels);
        for (let t4 = 0; t4 < e3.channels; ++t4) {
          const n3 = l3[t4] = {}, r4 = a3[t4];
          n3.name = r4.name, n3.compression = y2, n3.decoded = false, n3.type = r4.pixelType, n3.pLinear = r4.pLinear, n3.width = e3.width, n3.height = e3.lines;
        }
        const c3 = { idx: new Array(3) };
        for (let t4 = 0; t4 < e3.channels; ++t4) {
          const e4 = l3[t4];
          for (let n3 = 0; n3 < s3.length; ++n3) {
            const r4 = s3[n3];
            e4.name == r4.name && (e4.compression = r4.compression, r4.index >= 0 && (c3.idx[r4.index] = t4), e4.offset = t4);
          }
        }
        let u3, p3, d3;
        if (i3.acCompressedSize > 0)
          switch (i3.acCompression) {
            case g2:
              u3 = new Uint16Array(i3.totalAcUncompressedCount), U2(e3.array, t3, n2, i3.acCompressedSize, u3, i3.totalAcUncompressedCount);
              break;
            case v2:
              const r4 = Pf(e3.array.slice(n2.value, n2.value + i3.totalAcUncompressedCount));
              u3 = new Uint16Array(r4.buffer), n2.value += i3.totalAcUncompressedCount;
          }
        if (i3.dcCompressedSize > 0) {
          const t4 = { array: e3.array, offset: n2, size: i3.dcCompressedSize };
          p3 = new Uint16Array(q2(t4).buffer), n2.value += i3.dcCompressedSize;
        }
        i3.rleRawSize > 0 && (d3 = j2(Pf(e3.array.slice(n2.value, n2.value + i3.rleCompressedSize)).buffer), n2.value += i3.rleCompressedSize);
        let h3 = 0;
        const f3 = new Array(l3.length);
        for (let e4 = 0; e4 < f3.length; ++e4)
          f3[e4] = new Array();
        for (let t4 = 0; t4 < e3.lines; ++t4)
          for (let t5 = 0; t5 < l3.length; ++t5)
            f3[t5].push(h3), h3 += l3[t5].width * e3.type * m2;
        !function(e4, t4, n3, r4, i4, s4) {
          let o4 = new DataView(s4.buffer);
          const a4 = n3[e4.idx[0]].width, l4 = n3[e4.idx[0]].height, c4 = Math.floor(a4 / 8), u4 = Math.ceil(a4 / 8), p4 = Math.ceil(l4 / 8), d4 = a4 - 8 * (u4 - 1), h4 = l4 - 8 * (p4 - 1), f4 = { value: 0 }, _3 = new Array(3), g3 = new Array(3), v3 = new Array(3), y3 = new Array(3), b3 = new Array(3);
          for (let n4 = 0; n4 < 3; ++n4)
            b3[n4] = t4[e4.idx[n4]], _3[n4] = n4 < 1 ? 0 : _3[n4 - 1] + u4 * p4, g3[n4] = new Float32Array(64), v3[n4] = new Uint16Array(64), y3[n4] = new Uint16Array(64 * u4);
          for (let t5 = 0; t5 < p4; ++t5) {
            let s5 = 8;
            t5 == p4 - 1 && (s5 = h4);
            let a5 = 8;
            for (let e5 = 0; e5 < u4; ++e5) {
              e5 == u4 - 1 && (a5 = d4);
              for (let e6 = 0; e6 < 3; ++e6)
                v3[e6].fill(0), v3[e6][0] = i4[_3[e6]++], z2(f4, r4, v3[e6]), w3 = v3[e6], (A3 = g3[e6])[0] = se2(w3[0]), A3[1] = se2(w3[1]), A3[2] = se2(w3[5]), A3[3] = se2(w3[6]), A3[4] = se2(w3[14]), A3[5] = se2(w3[15]), A3[6] = se2(w3[27]), A3[7] = se2(w3[28]), A3[8] = se2(w3[2]), A3[9] = se2(w3[4]), A3[10] = se2(w3[7]), A3[11] = se2(w3[13]), A3[12] = se2(w3[16]), A3[13] = se2(w3[26]), A3[14] = se2(w3[29]), A3[15] = se2(w3[42]), A3[16] = se2(w3[3]), A3[17] = se2(w3[8]), A3[18] = se2(w3[12]), A3[19] = se2(w3[17]), A3[20] = se2(w3[25]), A3[21] = se2(w3[30]), A3[22] = se2(w3[41]), A3[23] = se2(w3[43]), A3[24] = se2(w3[9]), A3[25] = se2(w3[11]), A3[26] = se2(w3[18]), A3[27] = se2(w3[24]), A3[28] = se2(w3[31]), A3[29] = se2(w3[40]), A3[30] = se2(w3[44]), A3[31] = se2(w3[53]), A3[32] = se2(w3[10]), A3[33] = se2(w3[19]), A3[34] = se2(w3[23]), A3[35] = se2(w3[32]), A3[36] = se2(w3[39]), A3[37] = se2(w3[45]), A3[38] = se2(w3[52]), A3[39] = se2(w3[54]), A3[40] = se2(w3[20]), A3[41] = se2(w3[22]), A3[42] = se2(w3[33]), A3[43] = se2(w3[38]), A3[44] = se2(w3[46]), A3[45] = se2(w3[51]), A3[46] = se2(w3[55]), A3[47] = se2(w3[60]), A3[48] = se2(w3[21]), A3[49] = se2(w3[34]), A3[50] = se2(w3[37]), A3[51] = se2(w3[47]), A3[52] = se2(w3[50]), A3[53] = se2(w3[56]), A3[54] = se2(w3[59]), A3[55] = se2(w3[61]), A3[56] = se2(w3[35]), A3[57] = se2(w3[36]), A3[58] = se2(w3[48]), A3[59] = se2(w3[49]), A3[60] = se2(w3[57]), A3[61] = se2(w3[58]), A3[62] = se2(w3[62]), A3[63] = se2(w3[63]), G2(g3[e6]);
              V2(g3);
              for (let t6 = 0; t6 < 3; ++t6)
                H2(g3[t6], y3[t6], 64 * e5);
            }
            let l5 = 0;
            for (let r5 = 0; r5 < 3; ++r5) {
              const i5 = n3[e4.idx[r5]].type;
              for (let e5 = 8 * t5; e5 < 8 * t5 + s5; ++e5) {
                l5 = b3[r5][e5];
                for (let t6 = 0; t6 < c4; ++t6) {
                  const n4 = 64 * t6 + 8 * (7 & e5);
                  o4.setUint16(l5 + 0 * m2 * i5, y3[r5][n4 + 0], true), o4.setUint16(l5 + 1 * m2 * i5, y3[r5][n4 + 1], true), o4.setUint16(l5 + 2 * m2 * i5, y3[r5][n4 + 2], true), o4.setUint16(l5 + 3 * m2 * i5, y3[r5][n4 + 3], true), o4.setUint16(l5 + 4 * m2 * i5, y3[r5][n4 + 4], true), o4.setUint16(l5 + 5 * m2 * i5, y3[r5][n4 + 5], true), o4.setUint16(l5 + 6 * m2 * i5, y3[r5][n4 + 6], true), o4.setUint16(l5 + 7 * m2 * i5, y3[r5][n4 + 7], true), l5 += 8 * m2 * i5;
                }
              }
              if (c4 != u4)
                for (let e5 = 8 * t5; e5 < 8 * t5 + s5; ++e5) {
                  const t6 = b3[r5][e5] + 8 * c4 * m2 * i5, n4 = 64 * c4 + 8 * (7 & e5);
                  for (let e6 = 0; e6 < a5; ++e6)
                    o4.setUint16(t6 + e6 * m2 * i5, y3[r5][n4 + e6], true);
                }
            }
          }
          var w3, A3;
          const x3 = new Uint16Array(a4);
          o4 = new DataView(s4.buffer);
          for (let t5 = 0; t5 < 3; ++t5) {
            n3[e4.idx[t5]].decoded = true;
            const r5 = n3[e4.idx[t5]].type;
            if (2 == n3[t5].type)
              for (let e5 = 0; e5 < l4; ++e5) {
                const n4 = b3[t5][e5];
                for (let e6 = 0; e6 < a4; ++e6)
                  x3[e6] = o4.getUint16(n4 + e6 * m2 * r5, true);
                for (let e6 = 0; e6 < a4; ++e6)
                  o4.setFloat32(n4 + e6 * m2 * r5, se2(x3[e6]), true);
              }
          }
        }(c3, f3, l3, u3, p3, r3);
        for (let t4 = 0; t4 < l3.length; ++t4) {
          const n3 = l3[t4];
          if (!n3.decoded) {
            if (n3.compression !== b2)
              throw new Error("EXRLoader.parse: unsupported channel compression");
            {
              let i4 = 0, s4 = 0;
              for (let o4 = 0; o4 < e3.lines; ++o4) {
                let e4 = f3[t4][i4];
                for (let t5 = 0; t5 < n3.width; ++t5) {
                  for (let t6 = 0; t6 < m2 * n3.type; ++t6)
                    r3[e4++] = d3[s4 + t6 * n3.width * n3.height];
                  s4++;
                }
                i4++;
              }
            }
          }
        }
        return new DataView(r3.buffer);
      }
      function J2(e3, t3) {
        const n2 = new Uint8Array(e3);
        let r3 = 0;
        for (; 0 != n2[t3.value + r3]; )
          r3 += 1;
        const i3 = new TextDecoder().decode(n2.slice(t3.value, t3.value + r3));
        return t3.value = t3.value + r3 + 1, i3;
      }
      function Z2(e3, t3) {
        const n2 = e3.getInt32(t3.value, true);
        return t3.value = t3.value + f2, n2;
      }
      function $2(e3, t3) {
        const n2 = e3.getUint32(t3.value, true);
        return t3.value = t3.value + f2, n2;
      }
      function ee2(e3, t3) {
        const n2 = e3[t3.value];
        return t3.value = t3.value + _2, n2;
      }
      function te2(e3, t3) {
        const n2 = e3.getUint8(t3.value);
        return t3.value = t3.value + _2, n2;
      }
      const ne2 = function(e3, t3) {
        let n2;
        return n2 = "getBigInt64" in DataView.prototype ? Number(e3.getBigInt64(t3.value, true)) : e3.getUint32(t3.value + 4, true) + Number(e3.getUint32(t3.value, true) << 32), t3.value += 8, n2;
      };
      function re2(e3, t3) {
        const n2 = e3.getFloat32(t3.value, true);
        return t3.value += h2, n2;
      }
      function ie2(e3, t3) {
        return n.A5E.toHalfFloat(re2(e3, t3));
      }
      function se2(e3) {
        const t3 = (31744 & e3) >> 10, n2 = 1023 & e3;
        return (e3 >> 15 ? -1 : 1) * (t3 ? 31 === t3 ? n2 ? NaN : 1 / 0 : Math.pow(2, t3 - 15) * (1 + n2 / 1024) : n2 / 1024 * 6103515625e-14);
      }
      function oe2(e3, t3) {
        const n2 = e3.getUint16(t3.value, true);
        return t3.value += m2, n2;
      }
      function ae2(e3, t3) {
        return se2(oe2(e3, t3));
      }
      function le2(e3, t3, n2, r3, i3) {
        return "string" === r3 || "stringvector" === r3 || "iccProfile" === r3 ? function(e4, t4, n3) {
          const r4 = new TextDecoder().decode(new Uint8Array(e4).slice(t4.value, t4.value + n3));
          return t4.value = t4.value + n3, r4;
        }(t3, n2, i3) : "chlist" === r3 ? function(e4, t4, n3, r4) {
          const i4 = n3.value, s3 = [];
          for (; n3.value < i4 + r4 - 1; ) {
            const r5 = J2(t4, n3), i5 = Z2(e4, n3), o3 = te2(e4, n3);
            n3.value += 3;
            const a3 = Z2(e4, n3), l3 = Z2(e4, n3);
            s3.push({ name: r5, pixelType: i5, pLinear: o3, xSampling: a3, ySampling: l3 });
          }
          return n3.value += 1, s3;
        }(e3, t3, n2, i3) : "chromaticities" === r3 ? function(e4, t4) {
          return { redX: re2(e4, t4), redY: re2(e4, t4), greenX: re2(e4, t4), greenY: re2(e4, t4), blueX: re2(e4, t4), blueY: re2(e4, t4), whiteX: re2(e4, t4), whiteY: re2(e4, t4) };
        }(e3, n2) : "compression" === r3 ? function(e4, t4) {
          return ["NO_COMPRESSION", "RLE_COMPRESSION", "ZIPS_COMPRESSION", "ZIP_COMPRESSION", "PIZ_COMPRESSION", "PXR24_COMPRESSION", "B44_COMPRESSION", "B44A_COMPRESSION", "DWAA_COMPRESSION", "DWAB_COMPRESSION"][te2(e4, t4)];
        }(e3, n2) : "box2i" === r3 ? function(e4, t4) {
          return { xMin: $2(e4, t4), yMin: $2(e4, t4), xMax: $2(e4, t4), yMax: $2(e4, t4) };
        }(e3, n2) : "lineOrder" === r3 ? function(e4, t4) {
          return ["INCREASING_Y"][te2(e4, t4)];
        }(e3, n2) : "float" === r3 ? re2(e3, n2) : "v2f" === r3 ? function(e4, t4) {
          return [re2(e4, t4), re2(e4, t4)];
        }(e3, n2) : "v3f" === r3 ? function(e4, t4) {
          return [re2(e4, t4), re2(e4, t4), re2(e4, t4)];
        }(e3, n2) : "int" === r3 ? Z2(e3, n2) : "rational" === r3 ? function(e4, t4) {
          return [Z2(e4, t4), $2(e4, t4)];
        }(e3, n2) : "timecode" === r3 ? function(e4, t4) {
          return [$2(e4, t4), $2(e4, t4)];
        }(e3, n2) : "preview" === r3 ? (n2.value += i3, "skipped") : void (n2.value += i3);
      }
      const ce2 = new DataView(e2), ue2 = new Uint8Array(e2), pe2 = { value: 0 }, de2 = function(e3, t3, n2) {
        const r3 = {};
        if (20000630 != e3.getUint32(0, true))
          throw new Error("THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.");
        r3.version = e3.getUint8(4);
        const i3 = e3.getUint8(5);
        r3.spec = { singleTile: !!(2 & i3), longName: !!(4 & i3), deepFormat: !!(8 & i3), multiPart: !!(16 & i3) }, n2.value = 8;
        let s3 = true;
        for (; s3; ) {
          const i4 = J2(t3, n2);
          if (0 == i4)
            s3 = false;
          else {
            const s4 = J2(t3, n2), o3 = le2(e3, t3, n2, s4, $2(e3, n2));
            void 0 === o3 ? console.warn(`EXRLoader.parse: skipped unknown header attribute type '${s4}'.`) : r3[i4] = o3;
          }
        }
        if (0 != (-5 & i3))
          throw console.error("EXRHeader:", r3), new Error("THREE.EXRLoader: provided file is currently unsupported.");
        return r3;
      }(ce2, e2, pe2), he2 = function(e3, t3, r3, i3, s3) {
        const o3 = { size: 0, viewer: t3, array: r3, offset: i3, width: e3.dataWindow.xMax - e3.dataWindow.xMin + 1, height: e3.dataWindow.yMax - e3.dataWindow.yMin + 1, channels: e3.channels.length, bytesPerLine: null, lines: null, inputSize: null, type: e3.channels[0].pixelType, uncompress: null, getter: null, format: null, colorSpace: n.GUF };
        switch (e3.compression) {
          case "NO_COMPRESSION":
            o3.lines = 1, o3.uncompress = Q2;
            break;
          case "RLE_COMPRESSION":
            o3.lines = 1, o3.uncompress = W2;
            break;
          case "ZIPS_COMPRESSION":
            o3.lines = 1, o3.uncompress = q2;
            break;
          case "ZIP_COMPRESSION":
            o3.lines = 16, o3.uncompress = q2;
            break;
          case "PIZ_COMPRESSION":
            o3.lines = 32, o3.uncompress = X2;
            break;
          case "PXR24_COMPRESSION":
            o3.lines = 16, o3.uncompress = Y2;
            break;
          case "DWAA_COMPRESSION":
            o3.lines = 32, o3.uncompress = K2;
            break;
          case "DWAB_COMPRESSION":
            o3.lines = 256, o3.uncompress = K2;
            break;
          default:
            throw new Error("EXRLoader.parse: " + e3.compression + " is unsupported");
        }
        if (o3.scanlineBlockSize = o3.lines, 1 == o3.type)
          switch (s3) {
            case n.VzW:
              o3.getter = ae2, o3.inputSize = m2;
              break;
            case n.cLu:
              o3.getter = oe2, o3.inputSize = m2;
          }
        else {
          if (2 != o3.type)
            throw new Error("EXRLoader.parse: unsupported pixelType " + o3.type + " for " + e3.compression + ".");
          switch (s3) {
            case n.VzW:
              o3.getter = re2, o3.inputSize = h2;
              break;
            case n.cLu:
              o3.getter = ie2, o3.inputSize = h2;
          }
        }
        o3.blockCount = (e3.dataWindow.yMax + 1) / o3.scanlineBlockSize;
        for (let e4 = 0; e4 < o3.blockCount; e4++)
          ne2(t3, i3);
        o3.outputChannels = 3 == o3.channels ? 4 : o3.channels;
        const a3 = o3.width * o3.height * o3.outputChannels;
        switch (s3) {
          case n.VzW:
            o3.byteArray = new Float32Array(a3), o3.channels < o3.outputChannels && o3.byteArray.fill(1, 0, a3);
            break;
          case n.cLu:
            o3.byteArray = new Uint16Array(a3), o3.channels < o3.outputChannels && o3.byteArray.fill(15360, 0, a3);
            break;
          default:
            console.error("THREE.EXRLoader: unsupported type: ", s3);
        }
        return o3.bytesPerLine = o3.width * o3.inputSize * o3.channels, 4 == o3.outputChannels ? (o3.format = n.wk1, o3.colorSpace = n.GUF) : (o3.format = n.hEm, o3.colorSpace = n.aCh), o3;
      }(de2, ce2, ue2, pe2, this.type), fe2 = { value: 0 }, me2 = { R: 0, G: 1, B: 2, A: 3, Y: 0 };
      for (let e3 = 0; e3 < he2.height / he2.scanlineBlockSize; e3++) {
        const t3 = $2(ce2, pe2);
        he2.size = $2(ce2, pe2), he2.lines = t3 + he2.scanlineBlockSize > he2.height ? he2.height - t3 : he2.scanlineBlockSize;
        const n2 = he2.size < he2.lines * he2.bytesPerLine ? he2.uncompress(he2) : Q2(he2);
        pe2.value += he2.size;
        for (let t4 = 0; t4 < he2.scanlineBlockSize; t4++) {
          const r3 = t4 + e3 * he2.scanlineBlockSize;
          if (r3 >= he2.height)
            break;
          for (let e4 = 0; e4 < he2.channels; e4++) {
            const i3 = me2[de2.channels[e4].name];
            for (let s3 = 0; s3 < he2.width; s3++) {
              fe2.value = (t4 * (he2.channels * he2.width) + e4 * he2.width + s3) * he2.inputSize;
              const o3 = (he2.height - 1 - r3) * (he2.width * he2.outputChannels) + s3 * he2.outputChannels + i3;
              he2.byteArray[o3] = he2.getter(n2, fe2);
            }
          }
        }
      }
      return { header: de2, width: he2.width, height: he2.height, data: he2.byteArray, format: he2.format, colorSpace: he2.colorSpace, type: this.type };
    }
    setDataType(e2) {
      return this.type = e2, this;
    }
    load(e2, t2, r2, i2) {
      return super.load(e2, function(e3, r3) {
        e3.colorSpace = r3.colorSpace, e3.minFilter = n.wem, e3.magFilter = n.wem, e3.generateMipmaps = false, e3.flipY = false, t2 && t2(e3, r3);
      }, r2, i2);
    }
  }
  class Hg extends t.SimpleEventDispatcher {
    constructor() {
      super(...arguments), this.dependencies = [Ls];
    }
    async onAdded(e2) {
      var t2, n2;
      this._importer || (this._importer = new Ft(class extends Vg {
        constructor(t3) {
          super(t3), this.setDataType(Ds(e2.renderer.rendererObject));
        }
      }, ["exr"], false)), null === (n2 = null === (t2 = e2.getManager()) || void 0 === t2 ? void 0 : t2.importer) || void 0 === n2 || n2.Importers.push(this._importer);
    }
    async onDispose(e2) {
      this._importer = void 0;
    }
    async onRemove(e2) {
      var t2, n2;
      this._importer && (null === (n2 = null === (t2 = e2.getManager()) || void 0 === t2 ? void 0 : t2.importer) || void 0 === n2 ? void 0 : n2.Importers) && e2.getManager().importer.Importers.splice(e2.getManager().importer.Importers.indexOf(this._importer), 1), this._importer = void 0;
    }
  }
  Hg.PluginType = "EXRLoadPlugin";
  const Qg = /* @__PURE__ */ new WeakMap();
  class Wg extends n.aNw {
    constructor(e2) {
      super(e2), this.libraryPath = "", this.libraryPending = null, this.libraryBinary = null, this.libraryConfig = {}, this.url = "", this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.workerConfig = {}, this.materials = [], this.warnings = [];
    }
    setLibraryPath(e2) {
      return this.libraryPath = e2, this;
    }
    setWorkerLimit(e2) {
      return this.workerLimit = e2, this;
    }
    load(e2, t2, r2, i2) {
      const s2 = new n.hH6(this.manager);
      s2.setPath(this.path), s2.setResponseType("arraybuffer"), s2.setRequestHeader(this.requestHeader), this.url = e2, s2.load(e2, (n2) => {
        if (Qg.has(n2))
          return Qg.get(n2).promise.then(t2).catch(i2);
        this.decodeObjects(n2, e2).then((e3) => {
          e3.userData.warnings = this.warnings, this.warnings = [], t2(e3);
        }).catch((e3) => i2(e3));
      }, r2, i2);
    }
    debug() {
      console.log("Task load: ", this.workerPool.map((e2) => e2._taskLoad));
    }
    decodeObjects(e2, t2) {
      let n2, r2;
      const i2 = e2.byteLength, s2 = this._getWorker(i2).then((t3) => (n2 = t3, r2 = this.workerNextTaskID++, new Promise((t4, i3) => {
        n2._callbacks[r2] = { resolve: t4, reject: i3 }, n2.postMessage({ type: "decode", id: r2, buffer: e2 }, [e2]);
      }))).then((e3) => this._createGeometry(e3.data)).catch((e3) => {
        throw e3;
      });
      return s2.catch(() => true).then(() => {
        n2 && r2 && this._releaseTask(n2, r2);
      }), Qg.set(e2, { url: t2, promise: s2 }), s2;
    }
    parse(e2, t2, n2) {
      this.decodeObjects(e2, "").then((e3) => {
        e3.userData.warnings = this.warnings, t2(e3);
      }).catch((e3) => n2(e3));
    }
    _compareMaterials(e2) {
      if (this.materials.includes(e2))
        return e2;
      const t2 = {};
      t2.name = e2.name, t2.color = {}, t2.color.r = e2.color.r, t2.color.g = e2.color.g, t2.color.b = e2.color.b, t2.type = e2.type;
      const n2 = JSON.stringify(t2);
      for (let e3 = 0; e3 < this.materials.length; e3++) {
        const t3 = this.materials[e3], r2 = {};
        if (r2.name = t3.name, r2.color = {}, r2.color.r = t3.color.r, r2.color.g = t3.color.g, r2.color.b = t3.color.b, r2.type = t3.type, JSON.stringify(r2) === n2)
          return t3;
      }
      return this.materials.push(e2), e2;
    }
    _createMaterial(e2) {
      if (void 0 === e2)
        return new n.Wid({ color: new n.Ilk(1, 1, 1), metalness: 0.8, name: "default", side: n.ehD });
      const t2 = e2.diffuseColor, r2 = new n.Ilk(t2.r / 255, t2.g / 255, t2.b / 255);
      0 === t2.r && 0 === t2.g && 0 === t2.b && (r2.r = 1, r2.g = 1, r2.b = 1);
      const i2 = new n.Wid({ color: r2, name: e2.name, side: n.ehD, transparent: e2.transparency > 0, opacity: 1 - e2.transparency }), s2 = new n.dpR();
      for (let t3 = 0; t3 < e2.textures.length; t3++) {
        const r3 = e2.textures[t3];
        if (null !== r3.image) {
          const e3 = s2.load(r3.image);
          switch (r3.type) {
            case "Diffuse":
              i2.map = e3;
              break;
            case "Bump":
              i2.bumpMap = e3;
              break;
            case "Transparency":
              i2.alphaMap = e3, i2.transparent = true;
              break;
            case "Emap":
              i2.envMap = e3;
          }
          e3.wrapS = 0 === r3.wrapU ? n.rpg : n.uWy, e3.wrapT = 0 === r3.wrapV ? n.rpg : n.uWy, e3.repeat.set(r3.repeat[0], r3.repeat[1]);
        }
      }
      return i2;
    }
    _createGeometry(e2) {
      const t2 = new n.Tme(), r2 = [], i2 = [], s2 = [];
      t2.userData.layers = e2.layers, t2.userData.groups = e2.groups, t2.userData.settings = e2.settings, t2.userData.strings = e2.strings, t2.userData.objectType = "File3dm", t2.userData.materials = null, t2.name = this.url;
      let o2 = e2.objects;
      const a2 = e2.materials;
      for (let n2 = 0; n2 < o2.length; n2++) {
        const l2 = o2[n2], c2 = l2.attributes;
        switch (l2.objectType) {
          case "InstanceDefinition":
            i2.push(l2);
            break;
          case "InstanceReference":
            s2.push(l2);
            break;
          default:
            let n3;
            if (c2.materialIndex >= 0) {
              const e3 = a2[c2.materialIndex];
              let t3 = this._createMaterial(e3);
              t3 = this._compareMaterials(t3), n3 = this._createObject(l2, t3);
            } else {
              const e3 = this._createMaterial();
              n3 = this._createObject(l2, e3);
            }
            if (void 0 === n3)
              continue;
            const o3 = e2.layers[c2.layerIndex];
            n3.visible = !o3 || o3.visible, c2.isInstanceDefinitionObject ? r2.push(n3) : t2.add(n3);
        }
      }
      for (let l2 = 0; l2 < i2.length; l2++) {
        const c2 = i2[l2];
        o2 = [];
        for (let e3 = 0; e3 < c2.attributes.objectIds.length; e3++) {
          const t3 = c2.attributes.objectIds[e3];
          for (let e4 = 0; e4 < r2.length; e4++)
            t3 === r2[e4].userData.attributes.id && o2.push(r2[e4]);
        }
        for (let r3 = 0; r3 < s2.length; r3++) {
          const i3 = s2[r3];
          if (i3.geometry.parentIdefId === c2.attributes.id) {
            const r4 = i3.geometry.xform.array, s3 = new n.yGw();
            if (s3.set(...r4), 1 === o2.length) {
              const n2 = o2[0].clone(true);
              if (n2.name = i3.attributes.name || n2.name, n2.applyMatrix4(s3), i3.attributes.materialIndex >= 0 && i3.attributes.materialIndex !== o2[0].userData.attributes.materialIndex) {
                const e3 = a2[i3.attributes.materialIndex], t3 = this._createMaterial(e3);
                n2.material = this._compareMaterials(t3);
              }
              if (n2.userData.defAttributes = n2.userData.attributes, n2.userData.defObjectType = n2.userData.objectType, n2.userData.attributes = { ...n2.userData.attributes, ...i3.attributes }, n2.userData.objectType = i3.objectType, void 0 !== i3.attributes.layerIndex) {
                const t3 = e2.layers[i3.attributes.layerIndex];
                n2.visible = t3 ? t3.visible : n2.visible;
              }
              t2.add(n2);
            } else {
              console.warn("THREE.Rhino3dmLoader: InstanceReference with multiple/no objects, not all properties will be copied.");
              const e3 = new n.Tme();
              e3.applyMatrix4(s3);
              for (let t3 = 0; t3 < o2.length; t3++)
                e3.add(o2[t3].clone(true));
              t2.add(e3);
            }
          }
        }
      }
      return t2.userData.materials = this.materials, t2;
    }
    _createObject(e2, t2) {
      const r2 = new n.s4_(), i2 = e2.attributes;
      let s2, o2, a2, l2;
      switch (e2.objectType) {
        case "Point":
        case "PointSet":
          s2 = r2.parse(e2.geometry), s2.attributes.hasOwnProperty("color") ? o2 = new n.UY4({ vertexColors: true, sizeAttenuation: false, size: 2 }) : (a2 = i2.drawColor, l2 = new n.Ilk(a2.r / 255, a2.g / 255, a2.b / 255), o2 = new n.UY4({ color: l2, sizeAttenuation: false, size: 2 })), o2 = this._compareMaterials(o2);
          const c2 = new n.woe(s2, o2);
          return c2.userData.attributes = i2, c2.userData.objectType = e2.objectType, i2.name && (c2.name = i2.name), c2;
        case "Mesh":
        case "Extrusion":
        case "SubD":
        case "Brep":
          if (null === e2.geometry)
            return;
          s2 = r2.parse(e2.geometry), s2.attributes.hasOwnProperty("color") && (t2.vertexColors = true), null === t2 && (t2 = this._createMaterial(), t2 = this._compareMaterials(t2));
          const u2 = new n.Kj0(s2, t2);
          return u2.castShadow = i2.castsShadows, u2.receiveShadow = i2.receivesShadows, u2.userData.attributes = i2, u2.userData.objectType = e2.objectType, i2.name && (u2.name = i2.name, s2.name = i2.name), u2;
        case "Curve":
          s2 = r2.parse(e2.geometry), a2 = i2.drawColor, l2 = new n.Ilk(a2.r / 255, a2.g / 255, a2.b / 255), o2 = new n.nls({ color: l2 }), o2 = this._compareMaterials(o2);
          const p2 = new n.x12(s2, o2);
          return p2.userData.attributes = i2, p2.userData.objectType = e2.objectType, i2.name && (p2.name = i2.name), p2;
        case "TextDot":
          s2 = e2.geometry;
          const d2 = document.createElement("canvas").getContext("2d"), h2 = `${s2.fontHeight}px ${s2.fontFace}`;
          d2.font = h2;
          const f2 = d2.measureText(s2.text).width + 10, m2 = s2.fontHeight + 10, _2 = window.devicePixelRatio;
          d2.canvas.width = f2 * _2, d2.canvas.height = m2 * _2, d2.canvas.style.width = f2 + "px", d2.canvas.style.height = m2 + "px", d2.setTransform(_2, 0, 0, _2, 0, 0), d2.font = h2, d2.textBaseline = "middle", d2.textAlign = "center", l2 = i2.drawColor, d2.fillStyle = `rgba(${l2.r},${l2.g},${l2.b},${l2.a})`, d2.fillRect(0, 0, f2, m2), d2.fillStyle = "white", d2.fillText(s2.text, f2 / 2, m2 / 2);
          const g2 = new n.ROQ(d2.canvas);
          g2.minFilter = n.wem, g2.wrapS = n.uWy, g2.wrapT = n.uWy, o2 = new n.xeV({ map: g2, depthTest: false });
          const v2 = new n.jyi(o2);
          return v2.position.set(s2.point[0], s2.point[1], s2.point[2]), v2.scale.set(f2 / 10, m2 / 10, 1), v2.userData.attributes = i2, v2.userData.objectType = e2.objectType, i2.name && (v2.name = i2.name), v2;
        case "Light":
          let y2;
          switch (s2 = e2.geometry, s2.lightStyle.name) {
            case "LightStyle_WorldPoint":
              y2 = new n.cek(), y2.castShadow = i2.castsShadows, y2.position.set(s2.location[0], s2.location[1], s2.location[2]), y2.shadow.normalBias = 0.1;
              break;
            case "LightStyle_WorldSpot":
              y2 = new n.PMe(), y2.castShadow = i2.castsShadows, y2.position.set(s2.location[0], s2.location[1], s2.location[2]), y2.target.position.set(s2.direction[0], s2.direction[1], s2.direction[2]), y2.angle = s2.spotAngleRadians, y2.shadow.normalBias = 0.1;
              break;
            case "LightStyle_WorldRectangular":
              y2 = new n.T_f();
              const e3 = Math.abs(s2.width[2]), t3 = Math.abs(s2.length[0]);
              y2.position.set(s2.location[0] - t3 / 2, s2.location[1], s2.location[2] - e3 / 2), y2.height = t3, y2.width = e3, y2.lookAt(s2.direction[0], s2.direction[1], s2.direction[2]);
              break;
            case "LightStyle_WorldDirectional":
              y2 = new n.Ox3(), y2.castShadow = i2.castsShadows, y2.position.set(s2.location[0], s2.location[1], s2.location[2]), y2.target.position.set(s2.direction[0], s2.direction[1], s2.direction[2]), y2.shadow.normalBias = 0.1;
          }
          return y2 && (y2.intensity = s2.intensity, a2 = s2.diffuse, l2 = new n.Ilk(a2.r / 255, a2.g / 255, a2.b / 255), y2.color = l2, y2.userData.attributes = i2, y2.userData.objectType = e2.objectType), y2;
      }
    }
    _initLibrary() {
      if (!this.libraryPending) {
        const e2 = new n.hH6(this.manager);
        e2.setPath(this.libraryPath);
        const t2 = new Promise((t3, n2) => {
          e2.load("rhino3dm.js", t3, void 0, n2);
        }), r2 = new n.hH6(this.manager);
        r2.setPath(this.libraryPath), r2.setResponseType("arraybuffer");
        const i2 = new Promise((e3, t3) => {
          r2.load("rhino3dm.wasm", e3, void 0, t3);
        });
        this.libraryPending = Promise.all([t2, i2]).then(([e3, t3]) => {
          this.libraryConfig.wasmBinary = t3;
          const n2 = qg, r3 = ["/* rhino3dm.js */", e3, "/* worker */", n2.substring(n2.indexOf("{") + 1, n2.lastIndexOf("}"))].join("\n");
          this.workerSourceURL = URL.createObjectURL(new Blob([r3]));
        });
      }
      return this.libraryPending;
    }
    _getWorker(e2) {
      return this._initLibrary().then(() => {
        if (this.workerPool.length < this.workerLimit) {
          const e3 = new Worker(this.workerSourceURL);
          e3._callbacks = {}, e3._taskCosts = {}, e3._taskLoad = 0, e3.postMessage({ type: "init", libraryConfig: this.libraryConfig }), e3.onmessage = (t3) => {
            const n2 = t3.data;
            switch (n2.type) {
              case "warning":
                this.warnings.push(n2.data), console.warn(n2.data);
                break;
              case "decode":
                e3._callbacks[n2.id].resolve(n2);
                break;
              case "error":
                e3._callbacks[n2.id].reject(n2);
                break;
              default:
                console.error('THREE.Rhino3dmLoader: Unexpected message, "' + n2.type + '"');
            }
          }, this.workerPool.push(e3);
        } else
          this.workerPool.sort(function(e3, t3) {
            return e3._taskLoad > t3._taskLoad ? -1 : 1;
          });
        const t2 = this.workerPool[this.workerPool.length - 1];
        return t2._taskLoad += e2, t2;
      });
    }
    _releaseTask(e2, t2) {
      e2._taskLoad -= e2._taskCosts[t2], delete e2._callbacks[t2], delete e2._taskCosts[t2];
    }
    dispose() {
      for (let e2 = 0; e2 < this.workerPool.length; ++e2)
        this.workerPool[e2].terminate();
      return this.workerPool.length = 0, this;
    }
  }
  const qg = "\nfunction Rhino3dmWorker() {\n\n	let libraryPending;\n	let libraryConfig;\n	let rhino;\n	let taskID;\n\n	onmessage = function ( e ) {\n\n		const message = e.data;\n\n		switch ( message.type ) {\n\n			case 'init':\n\n				// console.log(message)\n				libraryConfig = message.libraryConfig;\n				const wasmBinary = libraryConfig.wasmBinary;\n				let RhinoModule;\n				libraryPending = new Promise( function ( resolve ) {\n\n					/* Like Basis Loader */\n					RhinoModule = { wasmBinary, onRuntimeInitialized: resolve };\n\n					rhino3dm( RhinoModule ); // eslint-disable-line no-undef\n\n				 } ).then( () => {\n\n					rhino = RhinoModule;\n\n				 } );\n\n				break;\n\n			case 'decode':\n\n				taskID = message.id;\n				const buffer = message.buffer;\n				libraryPending.then( () => {\n\n					try {\n\n						const data = decodeObjects( rhino, buffer );\n						self.postMessage( { type: 'decode', id: message.id, data } );\n\n					} catch ( error ) {\n\n						self.postMessage( { type: 'error', id: message.id, error } );\n\n					}\n\n				} );\n\n				break;\n\n		}\n\n	};\n\n	function decodeObjects( rhino, buffer ) {\n\n		const arr = new Uint8Array( buffer );\n		const doc = rhino.File3dm.fromByteArray( arr );\n\n		const objects = [];\n		const materials = [];\n		const layers = [];\n		const views = [];\n		const namedViews = [];\n		const groups = [];\n		const strings = [];\n\n		//Handle objects\n\n		const objs = doc.objects();\n		const cnt = objs.count;\n\n		for ( let i = 0; i < cnt; i ++ ) {\n\n			const _object = objs.get( i );\n\n			const object = extractObjectData( _object, doc );\n\n			_object.delete();\n\n			if ( object ) {\n\n				objects.push( object );\n\n			}\n\n		}\n\n		// Handle instance definitions\n		// console.log( `Instance Definitions Count: ${doc.instanceDefinitions().count()}` );\n\n		for ( let i = 0; i < doc.instanceDefinitions().count(); i ++ ) {\n\n			const idef = doc.instanceDefinitions().get( i );\n			const idefAttributes = extractProperties( idef );\n			idefAttributes.objectIds = idef.getObjectIds();\n\n			objects.push( { geometry: null, attributes: idefAttributes, objectType: 'InstanceDefinition' } );\n\n		}\n\n		// Handle materials\n\n		const textureTypes = [\n			// rhino.TextureType.Bitmap,\n			rhino.TextureType.Diffuse,\n			rhino.TextureType.Bump,\n			rhino.TextureType.Transparency,\n			rhino.TextureType.Opacity,\n			rhino.TextureType.Emap\n		];\n\n		const pbrTextureTypes = [\n			rhino.TextureType.PBR_BaseColor,\n			rhino.TextureType.PBR_Subsurface,\n			rhino.TextureType.PBR_SubsurfaceScattering,\n			rhino.TextureType.PBR_SubsurfaceScatteringRadius,\n			rhino.TextureType.PBR_Metallic,\n			rhino.TextureType.PBR_Specular,\n			rhino.TextureType.PBR_SpecularTint,\n			rhino.TextureType.PBR_Roughness,\n			rhino.TextureType.PBR_Anisotropic,\n			rhino.TextureType.PBR_Anisotropic_Rotation,\n			rhino.TextureType.PBR_Sheen,\n			rhino.TextureType.PBR_SheenTint,\n			rhino.TextureType.PBR_Clearcoat,\n			rhino.TextureType.PBR_ClearcoatBump,\n			rhino.TextureType.PBR_ClearcoatRoughness,\n			rhino.TextureType.PBR_OpacityIor,\n			rhino.TextureType.PBR_OpacityRoughness,\n			rhino.TextureType.PBR_Emission,\n			rhino.TextureType.PBR_AmbientOcclusion,\n			rhino.TextureType.PBR_Displacement\n		];\n\n		for ( let i = 0; i < doc.materials().count(); i ++ ) {\n\n			const _material = doc.materials().get( i );\n			const _pbrMaterial = _material.physicallyBased();\n\n			let material = extractProperties( _material );\n\n			const textures = [];\n\n			for ( let j = 0; j < textureTypes.length; j ++ ) {\n\n				const _texture = _material.getTexture( textureTypes[ j ] );\n				if ( _texture ) {\n\n					let textureType = textureTypes[ j ].constructor.name;\n					textureType = textureType.substring( 12, textureType.length );\n					const texture = { type: textureType };\n\n					const image = doc.getEmbeddedFileAsBase64( _texture.fileName );\n\n					texture.wrapU = _texture.wrapU;\n					texture.wrapV = _texture.wrapV;\n					texture.wrapW = _texture.wrapW;\n					const uvw = _texture.uvwTransform.toFloatArray( true );\n					texture.repeat = [ uvw[ 0 ], uvw[ 5 ] ];\n\n					if ( image ) {\n\n						texture.image = 'data:image/png;base64,' + image;\n\n					} else {\n\n						self.postMessage( { type: 'warning', id: taskID, data: {\n							message: `THREE.3DMLoader: Image for ${textureType} texture not embedded in file.`,\n							type: 'missing resource'\n						}\n\n						} );\n\n						texture.image = null;\n\n					}\n\n					textures.push( texture );\n\n					_texture.delete();\n\n				}\n\n			}\n\n			material.textures = textures;\n\n			if ( _pbrMaterial.supported ) {\n\n				for ( let j = 0; j < pbrTextureTypes.length; j ++ ) {\n\n					const _texture = _material.getTexture( pbrTextureTypes[ j ] );\n					if ( _texture ) {\n\n						const image = doc.getEmbeddedFileAsBase64( _texture.fileName );\n						let textureType = pbrTextureTypes[ j ].constructor.name;\n						textureType = textureType.substring( 12, textureType.length );\n						const texture = { type: textureType, image: 'data:image/png;base64,' + image };\n						textures.push( texture );\n\n						_texture.delete();\n\n					}\n\n				}\n\n				const pbMaterialProperties = extractProperties( _material.physicallyBased() );\n\n				material = Object.assign( pbMaterialProperties, material );\n\n			}\n\n			materials.push( material );\n\n			_material.delete();\n			_pbrMaterial.delete();\n\n		}\n\n		// Handle layers\n\n		for ( let i = 0; i < doc.layers().count(); i ++ ) {\n\n			const _layer = doc.layers().get( i );\n			const layer = extractProperties( _layer );\n\n			layers.push( layer );\n\n			_layer.delete();\n\n		}\n\n		// Handle views\n\n		for ( let i = 0; i < doc.views().count(); i ++ ) {\n\n			const _view = doc.views().get( i );\n			const view = extractProperties( _view );\n\n			views.push( view );\n\n			_view.delete();\n\n		}\n\n		// Handle named views\n\n		for ( let i = 0; i < doc.namedViews().count(); i ++ ) {\n\n			const _namedView = doc.namedViews().get( i );\n			const namedView = extractProperties( _namedView );\n\n			namedViews.push( namedView );\n\n			_namedView.delete();\n\n		}\n\n		// Handle groups\n\n		for ( let i = 0; i < doc.groups().count(); i ++ ) {\n\n			const _group = doc.groups().get( i );\n			const group = extractProperties( _group );\n\n			groups.push( group );\n\n			_group.delete();\n\n		}\n\n		// Handle settings\n\n		const settings = extractProperties( doc.settings() );\n\n		//TODO: Handle other document stuff like dimstyles, instance definitions, bitmaps etc.\n\n		// Handle dimstyles\n		// console.log( `Dimstyle Count: ${doc.dimstyles().count()}` );\n\n		// Handle bitmaps\n		// console.log( `Bitmap Count: ${doc.bitmaps().count()}` );\n\n		// Handle strings\n		// console.log( `Document Strings Count: ${doc.strings().count()}` );\n		// Note: doc.strings().documentUserTextCount() counts any doc.strings defined in a section\n		//console.log( `Document User Text Count: ${doc.strings().documentUserTextCount()}` );\n\n		const strings_count = doc.strings().count();\n\n		for ( let i = 0; i < strings_count; i ++ ) {\n\n			strings.push( doc.strings().get( i ) );\n\n		}\n\n		doc.delete();\n\n		return { objects, materials, layers, views, namedViews, groups, strings, settings };\n\n	}\n\n	function extractObjectData( object, doc ) {\n\n		const _geometry = object.geometry();\n		const _attributes = object.attributes();\n		let objectType = _geometry.objectType;\n		let geometry, attributes, position, data, mesh;\n\n		// skip instance definition objects\n		//if( _attributes.isInstanceDefinitionObject ) { continue; }\n\n		// TODO: handle other geometry types\n		switch ( objectType ) {\n\n			case rhino.ObjectType.Curve:\n\n				const pts = curveToPoints( _geometry, 100 );\n\n				position = {};\n				attributes = {};\n				data = {};\n\n				position.itemSize = 3;\n				position.type = 'Float32Array';\n				position.array = [];\n\n				for ( let j = 0; j < pts.length; j ++ ) {\n\n					position.array.push( pts[ j ][ 0 ] );\n					position.array.push( pts[ j ][ 1 ] );\n					position.array.push( pts[ j ][ 2 ] );\n\n				}\n\n				attributes.position = position;\n				data.attributes = attributes;\n\n				geometry = { data };\n\n				break;\n\n			case rhino.ObjectType.Point:\n\n				const pt = _geometry.location;\n\n				position = {};\n				const color = {};\n				attributes = {};\n				data = {};\n\n				position.itemSize = 3;\n				position.type = 'Float32Array';\n				position.array = [ pt[ 0 ], pt[ 1 ], pt[ 2 ] ];\n\n				const _color = _attributes.drawColor( doc );\n\n				color.itemSize = 3;\n				color.type = 'Float32Array';\n				color.array = [ _color.r / 255.0, _color.g / 255.0, _color.b / 255.0 ];\n\n				attributes.position = position;\n				attributes.color = color;\n				data.attributes = attributes;\n\n				geometry = { data };\n\n				break;\n\n			case rhino.ObjectType.PointSet:\n			case rhino.ObjectType.Mesh:\n\n				geometry = _geometry.toThreejsJSON();\n\n				break;\n\n			case rhino.ObjectType.Brep:\n\n				const faces = _geometry.faces();\n				mesh = new rhino.Mesh();\n\n				for ( let faceIndex = 0; faceIndex < faces.count; faceIndex ++ ) {\n\n					const face = faces.get( faceIndex );\n					const _mesh = face.getMesh( rhino.MeshType.Any );\n\n					if ( _mesh ) {\n\n						mesh.append( _mesh );\n						_mesh.delete();\n\n					}\n\n					face.delete();\n\n				}\n\n				if ( mesh.faces().count > 0 ) {\n\n					mesh.compact();\n					geometry = mesh.toThreejsJSON();\n					faces.delete();\n\n				}\n\n				mesh.delete();\n\n				break;\n\n			case rhino.ObjectType.Extrusion:\n\n				mesh = _geometry.getMesh( rhino.MeshType.Any );\n\n				if ( mesh ) {\n\n					geometry = mesh.toThreejsJSON();\n					mesh.delete();\n\n				}\n\n				break;\n\n			case rhino.ObjectType.TextDot:\n\n				geometry = extractProperties( _geometry );\n\n				break;\n\n			case rhino.ObjectType.Light:\n\n				geometry = extractProperties( _geometry );\n\n				if ( geometry.lightStyle.name === 'LightStyle_WorldLinear' ) {\n\n					self.postMessage( { type: 'warning', id: taskID, data: {\n						message: `THREE.3DMLoader: No conversion exists for ${objectType.constructor.name} ${geometry.lightStyle.name}`,\n						type: 'no conversion',\n						guid: _attributes.id\n					}\n\n					} );\n\n				}\n\n				break;\n\n			case rhino.ObjectType.InstanceReference:\n\n				geometry = extractProperties( _geometry );\n				geometry.xform = extractProperties( _geometry.xform );\n				geometry.xform.array = _geometry.xform.toFloatArray( true );\n\n				break;\n\n			case rhino.ObjectType.SubD:\n\n				// TODO: precalculate resulting vertices and faces and warn on excessive results\n				_geometry.subdivide( 3 );\n				mesh = rhino.Mesh.createFromSubDControlNet( _geometry );\n				if ( mesh ) {\n\n					geometry = mesh.toThreejsJSON();\n					mesh.delete();\n\n				}\n\n				break;\n\n				/*\n				case rhino.ObjectType.Annotation:\n				case rhino.ObjectType.Hatch:\n				case rhino.ObjectType.ClipPlane:\n				*/\n\n			default:\n\n				self.postMessage( { type: 'warning', id: taskID, data: {\n					message: `THREE.3DMLoader: Conversion not implemented for ${objectType.constructor.name}`,\n					type: 'not implemented',\n					guid: _attributes.id\n				}\n\n				} );\n\n				break;\n\n		}\n\n		if ( geometry ) {\n\n			attributes = extractProperties( _attributes );\n			attributes.geometry = extractProperties( _geometry );\n\n			if ( _attributes.groupCount > 0 ) {\n\n				attributes.groupIds = _attributes.getGroupList();\n\n			}\n\n			if ( _attributes.userStringCount > 0 ) {\n\n				attributes.userStrings = _attributes.getUserStrings();\n\n			}\n\n			if ( _geometry.userStringCount > 0 ) {\n\n				attributes.geometry.userStrings = _geometry.getUserStrings();\n\n			}\n\n			attributes.drawColor = _attributes.drawColor( doc );\n\n			objectType = objectType.constructor.name;\n			objectType = objectType.substring( 11, objectType.length );\n\n			return { geometry, attributes, objectType };\n\n		} else {\n\n			self.postMessage( { type: 'warning', id: taskID, data: {\n				message: `THREE.3DMLoader: ${objectType.constructor.name} has no associated mesh geometry.`,\n				type: 'missing mesh',\n				guid: _attributes.id\n			}\n\n			} );\n\n		}\n\n	}\n\n	function extractProperties( object ) {\n\n		const result = {};\n\n		for ( const property in object ) {\n\n			const value = object[ property ];\n\n			if ( typeof value !== 'function' ) {\n\n				if ( typeof value === 'object' && value !== null && value.hasOwnProperty( 'constructor' ) ) {\n\n					result[ property ] = { name: value.constructor.name, value: value.value };\n\n				} else {\n\n					result[ property ] = value;\n\n				}\n\n			} else {\n\n				// these are functions that could be called to extract more data.\n				//console.log( `${property}: ${object[ property ].constructor.name}` );\n\n			}\n\n		}\n\n		return result;\n\n	}\n\n	function curveToPoints( curve, pointLimit ) {\n\n		let pointCount = pointLimit;\n		let rc = [];\n		const ts = [];\n\n		if ( curve instanceof rhino.LineCurve ) {\n\n			return [ curve.pointAtStart, curve.pointAtEnd ];\n\n		}\n\n		if ( curve instanceof rhino.PolylineCurve ) {\n\n			pointCount = curve.pointCount;\n			for ( let i = 0; i < pointCount; i ++ ) {\n\n				rc.push( curve.point( i ) );\n\n			}\n\n			return rc;\n\n		}\n\n		if ( curve instanceof rhino.PolyCurve ) {\n\n			const segmentCount = curve.segmentCount;\n\n			for ( let i = 0; i < segmentCount; i ++ ) {\n\n				const segment = curve.segmentCurve( i );\n				const segmentArray = curveToPoints( segment, pointCount );\n				rc = rc.concat( segmentArray );\n				segment.delete();\n\n			}\n\n			return rc;\n\n		}\n\n		if ( curve instanceof rhino.ArcCurve ) {\n\n			pointCount = Math.floor( curve.angleDegrees / 5 );\n			pointCount = pointCount < 2 ? 2 : pointCount;\n			// alternative to this hardcoded version: https://stackoverflow.com/a/18499923/2179399\n\n		}\n\n		if ( curve instanceof rhino.NurbsCurve && curve.degree === 1 ) {\n\n			const pLine = curve.tryGetPolyline();\n\n			for ( let i = 0; i < pLine.count; i ++ ) {\n\n				rc.push( pLine.get( i ) );\n\n			}\n\n			pLine.delete();\n\n			return rc;\n\n		}\n\n		const domain = curve.domain;\n		const divisions = pointCount - 1.0;\n\n		for ( let j = 0; j < pointCount; j ++ ) {\n\n			const t = domain[ 0 ] + ( j / divisions ) * ( domain[ 1 ] - domain[ 0 ] );\n\n			if ( t === domain[ 0 ] || t === domain[ 1 ] ) {\n\n				ts.push( t );\n				continue;\n\n			}\n\n			const tan = curve.tangentAt( t );\n			const prevTan = curve.tangentAt( ts.slice( - 1 )[ 0 ] );\n\n			// Duplicated from THREE.Vector3\n			// How to pass imports to worker?\n\n			const tS = tan[ 0 ] * tan[ 0 ] + tan[ 1 ] * tan[ 1 ] + tan[ 2 ] * tan[ 2 ];\n			const ptS = prevTan[ 0 ] * prevTan[ 0 ] + prevTan[ 1 ] * prevTan[ 1 ] + prevTan[ 2 ] * prevTan[ 2 ];\n\n			const denominator = Math.sqrt( tS * ptS );\n\n			let angle;\n\n			if ( denominator === 0 ) {\n\n				angle = Math.PI / 2;\n\n			} else {\n\n				const theta = ( tan.x * prevTan.x + tan.y * prevTan.y + tan.z * prevTan.z ) / denominator;\n				angle = Math.acos( Math.max( - 1, Math.min( 1, theta ) ) );\n\n			}\n\n			if ( angle < 0.1 ) continue;\n\n			ts.push( t );\n\n		}\n\n		rc = ts.map( t => curve.pointAt( t ) );\n		return rc;\n\n	}\n\n}\n";
  var Xg, Yg = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  class Kg extends Wg {
    constructor(e2) {
      super(e2), this.materials = [], this.setLibraryPath(Kg.LIBRARY_PATH);
    }
    _createMaterial(e2) {
      return Kg.ImportMaterials ? super._createMaterial(e2) : this.materials[0] || new n.Wid({ color: new n.Ilk(1, 1, 1), metalness: 0.8, name: "default", side: n.ehD });
    }
    async loadAsync(e2, t2) {
      const n2 = await super.loadAsync(e2, t2);
      n2.rotateX(-Math.PI / 2), n2.userData.materials && delete n2.userData.materials;
      const r2 = n2.userData.layers;
      return n2.traverse((e3) => {
        var t3, i2, s2, o2, a2;
        const l2 = null === (t3 = e3.userData.attributes) || void 0 === t3 ? void 0 : t3.castsShadows, c2 = null === (i2 = e3.userData.attributes) || void 0 === i2 ? void 0 : i2.receivesShadows;
        e3.castShadow = l2, e3.receiveShadow = c2;
        const u2 = null !== (o2 = null === (s2 = e3.userData.attributes) || void 0 === s2 ? void 0 : s2.layerIndex) && void 0 !== o2 ? o2 : null === (a2 = e3.userData.defAttributes) || void 0 === a2 ? void 0 : a2.layerIndex, p2 = r2[u2];
        p2 && (e3.userData.rhinoLayer = p2), e3.userData.rhino3dmRoot = n2.uuid, this._hideLineMesh(e3), this._useInstancedMesh(e3), this._useMaterialSource(e3, p2);
      }), this.materials = [], n2;
    }
    _useMaterialSource(e2, t2) {
      var n2, r2, i2, s2, o2;
      if (!Kg.ImportMaterials)
        return;
      const a2 = e2;
      if ("default" === (null === (n2 = a2.material) || void 0 === n2 ? void 0 : n2.name) || Kg.ForceLayerMaterials) {
        const e3 = (null === (r2 = a2.userData.attributes) || void 0 === r2 ? void 0 : r2.materialSource) || (null === (i2 = a2.userData.defAttributes) || void 0 === i2 ? void 0 : i2.materialSource), n3 = (null === (s2 = a2.userData.attributes) || void 0 === s2 ? void 0 : s2.colorSource) || (null === (o2 = a2.userData.defAttributes) || void 0 === o2 ? void 0 : o2.colorSource);
        if (!Kg.ForceLayerMaterials && !e3 && !n3)
          return;
        Kg.ForceLayerMaterials || 0 === (null == e3 ? void 0 : e3.value) || 1 === (null == e3 ? void 0 : e3.value) && 0 === (null == n3 ? void 0 : n3.value) ? t2 && (a2.material = this._compareMaterials(this._createMaterial({ diffuseColor: t2.color, name: t2.name, transparency: 0, textures: [] }))) : 3 === (null == e3 ? void 0 : e3.value) || 1 === (null == e3 ? void 0 : e3.value) && 3 === (null == n3 ? void 0 : n3.value) ? a2.traverseAncestors((e4) => {
          (null == e4 ? void 0 : e4.material) && (a2.material = e4.material);
        }) : e3 && 1 !== e3.value && console.warn("Unknown material source", e3, a2, a2.userData.attributes);
      }
    }
    _useInstancedMesh(e2) {
      if (!Kg.ReplaceWithInstancedMesh)
        return;
      if (e2.children.length <= 0)
        return;
      const t2 = e2.children, r2 = t2.map((e3) => e3.geometry), i2 = r2.filter((e3, t3) => r2.indexOf(e3) === t3);
      i2.forEach((r3) => {
        var i3;
        const s2 = t2.filter((e3) => e3.geometry === r3), o2 = s2.length > 0 ? s2.filter((e3) => e3.material === s2[0].material) : [];
        if (o2.length > 1) {
          const t3 = new n.SPe(r3, o2[0].material, o2.length);
          t3.userData = { ...o2[0].userData }, t3.userData.instanceUserData = [], t3.userData.attributes = t3.userData.defAttributes || t3.userData.attributes, t3.userData.defAttributes && delete t3.userData.defAttributes, t3.name = (null === (i3 = t3.userData.attributes) || void 0 === i3 ? void 0 : i3.name) || o2[0].name, o2.forEach((n2, r4) => {
            t3.setMatrixAt(r4, n2.matrix), e2.remove(n2), t3.userData.instanceUserData.push(n2.userData);
          }), e2.add(t3);
        }
      });
    }
    _hideLineMesh(e2) {
      if (!Kg.HideLineMesh)
        return;
      if (e2.children.length <= 0)
        return;
      const t2 = [];
      e2.traverse((e3) => {
        e3 && (e3.isLine || e3.isLineSegments || e3.isPoints) && t2.push(e3);
      }), t2.forEach((e3) => {
        e3.userData.visible_3dm = e3.visible, e3.visible = false;
      });
    }
  }
  Kg.LIBRARY_PATH = "https://cdn.jsdelivr.net/npm/rhino3dm@7.15.0/", Kg.ImportMaterials = true, Kg.ForceLayerMaterials = false, Kg.ReplaceWithInstancedMesh = false, Kg.HideLineMesh = false;
  let Jg = Xg = class extends t.SimpleEventDispatcher {
    constructor() {
      super(...arguments), this.dependencies = [Ls], this._importer = new Ft(Kg, ["3dm"], true), this.importMaterials = true, this.forceLayerMaterials = false, this.replaceWithInstancedMesh = false, this.hideLineMesh = false;
    }
    _refresh() {
      Kg.ImportMaterials = this.importMaterials, Kg.ForceLayerMaterials = this.forceLayerMaterials, Kg.ReplaceWithInstancedMesh = this.replaceWithInstancedMesh, Kg.HideLineMesh = this.hideLineMesh;
    }
    async onAdded(e2) {
      var t2, n2;
      null === (n2 = null === (t2 = e2.getManager()) || void 0 === t2 ? void 0 : t2.importer) || void 0 === n2 || n2.Importers.push(this._importer), this._refresh();
    }
    async onDispose(e2) {
    }
    async onRemove(e2) {
      var t2, n2;
      (null === (n2 = null === (t2 = e2.getManager()) || void 0 === t2 ? void 0 : t2.importer) || void 0 === n2 ? void 0 : n2.Importers) && e2.getManager().importer.Importers.splice(e2.getManager().importer.Importers.indexOf(this._importer), 1);
    }
  };
  Jg.PluginType = "Rhino3dmLoadPlugin", Yg([(0, t.onChange)(Xg.prototype._refresh), Oe()], Jg.prototype, "importMaterials", void 0), Yg([(0, t.onChange)(Xg.prototype._refresh), Oe()], Jg.prototype, "forceLayerMaterials", void 0), Yg([(0, t.onChange)(Xg.prototype._refresh), Oe()], Jg.prototype, "replaceWithInstancedMesh", void 0), Yg([(0, t.onChange)(Xg.prototype._refresh), Oe()], Jg.prototype, "hideLineMesh", void 0), Jg = Xg = Yg([We("Rhino 3dm loader")], Jg);
  class Zg extends n.aNw {
    constructor(e2) {
      super(e2);
    }
    load(e2, t2, r2, i2) {
      const s2 = this, o2 = new n.hH6(this.manager);
      o2.setPath(this.path), o2.setResponseType("arraybuffer"), o2.setRequestHeader(this.requestHeader), o2.setWithCredentials(this.withCredentials), o2.load(e2, function(n2) {
        try {
          t2(s2.parse(n2));
        } catch (t3) {
          i2 ? i2(t3) : console.error(t3), s2.manager.itemError(e2);
        }
      }, r2, i2);
    }
    parse(e2) {
      function t2(e3, t3, n2) {
        for (let r3 = 0, i3 = e3.length; r3 < i3; r3++)
          if (e3[r3] !== t3.getUint8(n2 + r3))
            return false;
        return true;
      }
      const r2 = function(e3) {
        if ("string" == typeof e3) {
          const t3 = new Uint8Array(e3.length);
          for (let n2 = 0; n2 < e3.length; n2++)
            t3[n2] = 255 & e3.charCodeAt(n2);
          return t3.buffer || t3;
        }
        return e3;
      }(e2);
      return function(e3) {
        const n2 = new DataView(e3);
        if (84 + 50 * n2.getUint32(80, true) === n2.byteLength)
          return true;
        const r3 = [115, 111, 108, 105, 100];
        for (let e4 = 0; e4 < 5; e4++)
          if (t2(r3, n2, e4))
            return false;
        return true;
      }(r2) ? function(e3) {
        const t3 = new DataView(e3), r3 = t3.getUint32(80, true);
        let i3, s2, o2, a2, l2, c2, u2, p2, d2 = false;
        for (let e4 = 0; e4 < 70; e4++)
          1129270351 == t3.getUint32(e4, false) && 82 == t3.getUint8(e4 + 4) && 61 == t3.getUint8(e4 + 5) && (d2 = true, a2 = new Float32Array(3 * r3 * 3), l2 = t3.getUint8(e4 + 6) / 255, c2 = t3.getUint8(e4 + 7) / 255, u2 = t3.getUint8(e4 + 8) / 255, p2 = t3.getUint8(e4 + 9) / 255);
        const h2 = new n.u9r(), f2 = new Float32Array(3 * r3 * 3), m2 = new Float32Array(3 * r3 * 3), _2 = new n.Ilk();
        for (let e4 = 0; e4 < r3; e4++) {
          const n2 = 84 + 50 * e4, r4 = t3.getFloat32(n2, true), p3 = t3.getFloat32(n2 + 4, true), h3 = t3.getFloat32(n2 + 8, true);
          if (d2) {
            const e5 = t3.getUint16(n2 + 48, true);
            0 == (32768 & e5) ? (i3 = (31 & e5) / 31, s2 = (e5 >> 5 & 31) / 31, o2 = (e5 >> 10 & 31) / 31) : (i3 = l2, s2 = c2, o2 = u2);
          }
          for (let l3 = 1; l3 <= 3; l3++) {
            const c3 = n2 + 12 * l3, u3 = 3 * e4 * 3 + 3 * (l3 - 1);
            f2[u3] = t3.getFloat32(c3, true), f2[u3 + 1] = t3.getFloat32(c3 + 4, true), f2[u3 + 2] = t3.getFloat32(c3 + 8, true), m2[u3] = r4, m2[u3 + 1] = p3, m2[u3 + 2] = h3, d2 && (_2.set(i3, s2, o2).convertSRGBToLinear(), a2[u3] = _2.r, a2[u3 + 1] = _2.g, a2[u3 + 2] = _2.b);
          }
        }
        return h2.setAttribute("position", new n.TlE(f2, 3)), h2.setAttribute("normal", new n.TlE(m2, 3)), d2 && (h2.setAttribute("color", new n.TlE(a2, 3)), h2.hasColors = true, h2.alpha = p2), h2;
      }(r2) : function(e3) {
        const t3 = new n.u9r(), r3 = /solid([\s\S]*?)endsolid/g, i3 = /facet([\s\S]*?)endfacet/g;
        let s2 = 0;
        const o2 = /[\s]+([+-]?(?:\d*)(?:\.\d*)?(?:[eE][+-]?\d+)?)/.source, a2 = new RegExp("vertex" + o2 + o2 + o2, "g"), l2 = new RegExp("normal" + o2 + o2 + o2, "g"), c2 = [], u2 = [], p2 = new n.Pa4();
        let d2, h2 = 0, f2 = 0, m2 = 0;
        for (; null !== (d2 = r3.exec(e3)); ) {
          f2 = m2;
          const e4 = d2[0];
          for (; null !== (d2 = i3.exec(e4)); ) {
            let e5 = 0, t4 = 0;
            const n3 = d2[0];
            for (; null !== (d2 = l2.exec(n3)); )
              p2.x = parseFloat(d2[1]), p2.y = parseFloat(d2[2]), p2.z = parseFloat(d2[3]), t4++;
            for (; null !== (d2 = a2.exec(n3)); )
              c2.push(parseFloat(d2[1]), parseFloat(d2[2]), parseFloat(d2[3])), u2.push(p2.x, p2.y, p2.z), e5++, m2++;
            1 !== t4 && console.error("THREE.STLLoader: Something isn't right with the normal of face number " + s2), 3 !== e5 && console.error("THREE.STLLoader: Something isn't right with the vertices of face number " + s2), s2++;
          }
          const n2 = f2, r4 = m2 - f2;
          t3.addGroup(n2, r4, h2), h2++;
        }
        return t3.setAttribute("position", new n.a$l(c2, 3)), t3.setAttribute("normal", new n.a$l(u2, 3)), t3;
      }("string" != typeof (i2 = e2) ? new TextDecoder().decode(i2) : i2);
      var i2;
    }
  }
  class $g extends t.SimpleEventDispatcher {
    constructor() {
      super(...arguments), this.dependencies = [Ls];
    }
    async onAdded(e2) {
      var t2, n2;
      this._importer || (this._importer = new Ft(Zg, ["stl"], true)), null === (n2 = null === (t2 = e2.getManager()) || void 0 === t2 ? void 0 : t2.importer) || void 0 === n2 || n2.Importers.push(this._importer);
    }
    async onDispose(e2) {
      this._importer = void 0;
    }
    async onRemove(e2) {
      var t2, n2;
      this._importer && (null === (n2 = null === (t2 = e2.getManager()) || void 0 === t2 ? void 0 : t2.importer) || void 0 === n2 ? void 0 : n2.Importers) && e2.getManager().importer.Importers.splice(e2.getManager().importer.Importers.indexOf(this._importer), 1), this._importer = void 0;
    }
  }
  $g.PluginType = "STLLoadPlugin";
  class ev extends t.SimpleEventDispatcher {
    constructor() {
      super(...arguments), this.dependencies = [Ls];
    }
    async onAdded(e2) {
      const t2 = document.createElement("script");
      t2.type = "module", t2.innerHTML = `
import { MeshoptDecoder } from '${ev.DECODER_URL}';
window.MeshoptDecoder = MeshoptDecoder
`, document.head.appendChild(t2), this._script = t2;
    }
    async onDispose(e2) {
    }
    async onRemove(e2) {
      this._script && (document.head.removeChild(this._script), this._script = void 0);
    }
  }
  ev.PluginType = "GLTFMeshOptPlugin", ev.DECODER_URL = "https://unpkg.com/meshoptimizer@0.20.0/meshopt_decoder.module.js";
  var tv, nv = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let rv = tv = class extends gt {
    constructor(e2 = true) {
      super(), this.animationRunning = false, this.interactionsDisabled = false, this.animationDuration = 2e3, this.animationDistance = 80, this.animationPauseDuration = 6e3, this.rotationDistance = 0.3, this.yOffset = 0, this.autoStart = true, this.autoStartDelay = 3e4, this.autoStop = true, this.autoStartOnObjectLoad = true, this.autoStartOnObjectLoadDelay = 3e3, this.currentTime = 0, this.lastActionTime = 1 / 0, this._xDamper = new t.Damper(50), this.pointerIcon = '<svg xmlns="http://www.w3.org/2000/svg" style="transform: translate(-50%, -25%);" width="25" height="36">\n    <defs>\n        <path id="A" d="M.001.232h24.997V36H.001z"></path>\n    </defs>\n    <g transform="translate(-11 -4)" fill="none" fill-rule="evenodd">\n        <path fill-opacity="0" fill="#fff" d="M0 0h44v44H0z"></path>\n        <g transform="translate(11 3)">\n            <path d="M8.733 11.165c.04-1.108.766-2.027 1.743-2.307a2.54 2.54 0 0 1 .628-.089c.16 0 .314.017.463.044 1.088.2 1.9 1.092 1.9 2.16v8.88h1.26c2.943-1.39 5-4.45 5-8.025a9.01 9.01 0 0 0-1.9-5.56l-.43-.5c-.765-.838-1.683-1.522-2.712-2-1.057-.49-2.226-.77-3.46-.77s-2.4.278-3.46.77c-1.03.478-1.947 1.162-2.71 2l-.43.5a9.01 9.01 0 0 0-1.9 5.56 9.04 9.04 0 0 0 .094 1.305c.03.21.088.41.13.617l.136.624c.083.286.196.56.305.832l.124.333a8.78 8.78 0 0 0 .509.953l.065.122a8.69 8.69 0 0 0 3.521 3.191l1.11.537v-9.178z" fill-opacity=".5" fill="#e4e4e4"></path>\n            <path d="M22.94 26.218l-2.76 7.74c-.172.485-.676.8-1.253.8H12.24c-1.606 0-3.092-.68-3.98-1.82-1.592-2.048-3.647-3.822-6.11-5.27-.095-.055-.15-.137-.152-.23-.004-.1.046-.196.193-.297.56-.393 1.234-.6 1.926-.6a3.43 3.43 0 0 1 .691.069l4.922.994V10.972c0-.663.615-1.203 1.37-1.203s1.373.54 1.373 1.203v9.882h2.953c.273 0 .533.073.757.21l6.257 3.874c.027.017.045.042.07.06.41.296.586.77.426 1.22M4.1 16.614c-.024-.04-.042-.083-.065-.122a8.69 8.69 0 0 1-.509-.953c-.048-.107-.08-.223-.124-.333l-.305-.832c-.058-.202-.09-.416-.136-.624l-.13-.617a9.03 9.03 0 0 1-.094-1.305c0-2.107.714-4.04 1.9-5.56l.43-.5c.764-.84 1.682-1.523 2.71-2 1.058-.49 2.226-.77 3.46-.77s2.402.28 3.46.77c1.03.477 1.947 1.16 2.712 2l.428.5a9 9 0 0 1 1.901 5.559c0 3.577-2.056 6.636-5 8.026h-1.26v-8.882c0-1.067-.822-1.96-1.9-2.16-.15-.028-.304-.044-.463-.044-.22 0-.427.037-.628.09-.977.28-1.703 1.198-1.743 2.306v9.178l-1.11-.537C6.18 19.098 4.96 18 4.1 16.614M22.97 24.09l-6.256-3.874c-.102-.063-.218-.098-.33-.144 2.683-1.8 4.354-4.855 4.354-8.243 0-.486-.037-.964-.104-1.43a9.97 9.97 0 0 0-1.57-4.128l-.295-.408-.066-.092a10.05 10.05 0 0 0-.949-1.078c-.342-.334-.708-.643-1.094-.922-1.155-.834-2.492-1.412-3.94-1.65l-.732-.088-.748-.03a9.29 9.29 0 0 0-1.482.119c-1.447.238-2.786.816-3.94 1.65a9.33 9.33 0 0 0-.813.686 9.59 9.59 0 0 0-.845.877l-.385.437-.36.5-.288.468-.418.778-.04.09c-.593 1.28-.93 2.71-.93 4.222 0 3.832 2.182 7.342 5.56 8.938l1.437.68v4.946L5 25.64a4.44 4.44 0 0 0-.888-.086c-.017 0-.034.003-.05.003-.252.004-.503.033-.75.08a5.08 5.08 0 0 0-.237.056c-.193.046-.382.107-.568.18-.075.03-.15.057-.225.1-.25.114-.494.244-.723.405a1.31 1.31 0 0 0-.566 1.122 1.28 1.28 0 0 0 .645 1.051C4 29.925 5.96 31.614 7.473 33.563a5.06 5.06 0 0 0 .434.491c1.086 1.082 2.656 1.713 4.326 1.715h6.697c.748-.001 1.43-.333 1.858-.872.142-.18.256-.38.336-.602l2.757-7.74c.094-.26.13-.53.112-.794s-.088-.52-.203-.76a2.19 2.19 0 0 0-.821-.91" fill-opacity=".6" fill="#000"></path>\n            <path d="M22.444 24.94l-6.257-3.874a1.45 1.45 0 0 0-.757-.211h-2.953v-9.88c0-.663-.616-1.203-1.373-1.203s-1.37.54-1.37 1.203v16.643l-4.922-.994a3.44 3.44 0 0 0-.692-.069 3.35 3.35 0 0 0-1.925.598c-.147.102-.198.198-.194.298.004.094.058.176.153.23 2.462 1.448 4.517 3.22 6.11 5.27.887 1.14 2.373 1.82 3.98 1.82h6.686c.577 0 1.08-.326 1.253-.8l2.76-7.74c.16-.448-.017-.923-.426-1.22-.025-.02-.043-.043-.07-.06z" fill="#fff"></path>\n            <g transform="translate(0 .769)">\n                <mask id="B" fill="#fff">\n                    <use xlink:href="#A"></use>\n                </mask>\n                <path d="M23.993 24.992a1.96 1.96 0 0 1-.111.794l-2.758 7.74c-.08.22-.194.423-.336.602-.427.54-1.11.87-1.857.872h-6.698c-1.67-.002-3.24-.633-4.326-1.715-.154-.154-.3-.318-.434-.49C5.96 30.846 4 29.157 1.646 27.773c-.385-.225-.626-.618-.645-1.05a1.31 1.31 0 0 1 .566-1.122 4.56 4.56 0 0 1 .723-.405l.225-.1a4.3 4.3 0 0 1 .568-.18l.237-.056c.248-.046.5-.075.75-.08.018 0 .034-.003.05-.003.303-.001.597.027.89.086l3.722.752V20.68l-1.436-.68c-3.377-1.596-5.56-5.106-5.56-8.938 0-1.51.336-2.94.93-4.222.015-.03.025-.06.04-.09.127-.267.268-.525.418-.778.093-.16.186-.316.288-.468.063-.095.133-.186.2-.277L3.773 5c.118-.155.26-.29.385-.437.266-.3.544-.604.845-.877a9.33 9.33 0 0 1 .813-.686C6.97 2.167 8.31 1.59 9.757 1.35a9.27 9.27 0 0 1 1.481-.119 8.82 8.82 0 0 1 .748.031c.247.02.49.05.733.088 1.448.238 2.786.816 3.94 1.65.387.28.752.588 1.094.922a9.94 9.94 0 0 1 .949 1.078l.066.092c.102.133.203.268.295.408a9.97 9.97 0 0 1 1.571 4.128c.066.467.103.945.103 1.43 0 3.388-1.67 6.453-4.353 8.243.11.046.227.08.33.144l6.256 3.874c.37.23.645.55.82.9.115.24.185.498.203.76m.697-1.195c-.265-.55-.677-1.007-1.194-1.326l-5.323-3.297c2.255-2.037 3.564-4.97 3.564-8.114 0-2.19-.637-4.304-1.84-6.114-.126-.188-.26-.37-.4-.552-.645-.848-1.402-1.6-2.252-2.204C15.472.91 13.393.232 11.238.232A10.21 10.21 0 0 0 5.23 2.19c-.848.614-1.606 1.356-2.253 2.205-.136.18-.272.363-.398.55C1.374 6.756.737 8.87.737 11.06c0 4.218 2.407 8.08 6.133 9.842l.863.41v3.092l-2.525-.51c-.356-.07-.717-.106-1.076-.106a5.45 5.45 0 0 0-3.14.996c-.653.46-1.022 1.202-.99 1.983a2.28 2.28 0 0 0 1.138 1.872c2.24 1.318 4.106 2.923 5.543 4.772 1.26 1.62 3.333 2.59 5.55 2.592h6.698c1.42-.001 2.68-.86 3.134-2.138l2.76-7.74c.272-.757.224-1.584-.134-2.325" fill-opacity=".05" fill="#000" mask="url(#B)"></path>\n            </g>\n        </g>\n    </g>\n</svg>', this._activeCameraUpdate = (e3) => {
        this.isDisabled() || ("deserialize" === e3.change ? (this.stopAnimation(), this.startAnimation()) : this.lastActionTime = (0, t.now)());
      }, this._addSceneObject = () => {
        this.autoStartOnObjectLoad && (this.lastActionTime = (0, t.now)() - this.autoStartDelay + this.autoStartOnObjectLoadDelay);
      }, this.onlyOnOrbitControls = true, this._orbitWarning = false, this.startAnimation = () => {
        var e3;
        if (this._viewer && this.cursorEl && !this.isDisabled())
          return "OrbitControls" !== (null === (e3 = this._viewer.scene.activeCamera.controls) || void 0 === e3 ? void 0 : e3.type) && this.onlyOnOrbitControls ? (this._orbitWarning || console.warn("WebGi InteractionPromptPlugin requires OrbitControls, to run anyway, set onlyOnOrbitControls to false"), void (this._orbitWarning = true)) : void (0 !== this._viewer.scene.modelRoot.children.length && (this.currentSphericalPosition = new n.$V().setFromVector3(new n.Pa4().subVectors(this._viewer.scene.activeCamera.position, this._viewer.scene.activeCamera.target)), this.cursorEl.style.opacity = "1", this.currentTime = 0, this.animationRunning = true, this.interactionsDisabled = true, this._viewer.scene.activeCamera.setInteractions(false, tv.PluginType)));
      }, this.stopAnimation = () => {
        this._viewer && this.cursorEl && (this.animationRunning = false, this.cursorEl.style.opacity = "0", this._viewer.scene.activeCamera.setInteractions(true, tv.PluginType), this.interactionsDisabled && (this.interactionsDisabled = false));
      }, this._pointerDown = () => {
        this.isDisabled() || (this.autoStop && this.stopAnimation(), this.lastActionTime = (0, t.now)());
      }, this._x = 0, this._preFrame = async (e3) => {
        if (!this._viewer || !this.cursorEl)
          return;
        if (this.isDisabled() && this.animationRunning && this.stopAnimation(), this.isDisabled())
          return;
        if (!this.animationRunning && this.autoStart && this.lastActionTime + this.autoStartDelay < (0, t.now)() && this.startAnimation(), !this.animationRunning)
          return;
        if (this.currentTime <= this.animationDuration) {
          this.cursorEl.style.opacity = "1";
          const e4 = this.currentTime / this.animationDuration;
          this._x = Math.sin(2 * Math.PI * e4), (e4 < 0.25 || e4 > 0.75) && (this._x *= this._x * Math.sign(this._x));
        } else
          this.cursorEl.style.opacity = "0", this._x = 0;
        if (this.currentTime <= this.animationDuration + 50) {
          const e4 = this.currentSphericalPosition.clone();
          e4.theta += this._x * this.rotationDistance, this._viewer.scene.activeCamera.position.setFromSpherical(e4).add(this._viewer.scene.activeCamera.target), this._viewer.scene.activeCamera.positionUpdated();
        }
        const n2 = this._viewer.container.getBoundingClientRect(), r2 = n2.width / 2 + -this._x * Math.min(this.animationDistance, n2.width / 4), i2 = n2.height / 2 + this.yOffset * n2.height / 2;
        this.cursorEl.style.transform = `translate(${Math.floor(r2)}px, ${Math.floor(i2)}px)`, this.currentTime += e3.deltaTime, this.currentTime > this.animationDuration + this.animationPauseDuration && (this.currentTime = 0);
      }, this._disabledBy = /* @__PURE__ */ new Set(), this.disable = (e3) => {
        this._disabledBy.size, this._disabledBy.add(e3);
      }, this.enable = (e3) => {
        this._disabledBy.size, this._disabledBy.delete(e3);
      }, this.isDisabled = () => this._disabledBy.size > 0 || !this.enabled, this.enabled = e2;
    }
    async onAdded(e2) {
      await super.onAdded(e2);
      {
        e2.plugins.hasOwnProperty("InteractionPointerPlugin") && delete e2.plugins.InteractionPointerPlugin;
        const t2 = this;
        Object.defineProperty(e2.plugins, "InteractionPointerPlugin", { get() {
          return console.warn("WebGi InteractionPromptPlugin: PluginType renamed from InteractionPointerPlugin to InteractionPromptPlugin. Please update your code/vjson."), t2;
        }, configurable: true });
      }
      this.lastActionTime = 1 / 0, e2.addEventListener("preFrame", this._preFrame), e2.container.addEventListener("pointerdown", this._pointerDown, true), e2.container.addEventListener("wheel", this._pointerDown, true), e2.scene.addEventListener("addSceneObject", this._addSceneObject), e2.scene.addEventListener("activeCameraUpdate", this._activeCameraUpdate), this._initializeCursor();
    }
    async onRemove(e2) {
      return this.stopAnimation(), e2.removeEventListener("preFrame", this._preFrame), e2.container.removeEventListener("pointerdown", this._pointerDown, true), e2.container.removeEventListener("wheel", this._pointerDown, true), e2.scene.removeEventListener("addSceneObject", this._addSceneObject), e2.scene.removeEventListener("activeCameraUpdate", this._activeCameraUpdate), this.cursorEl && this.cursorEl.remove(), super.onRemove(e2);
    }
    _initializeCursor() {
      this.cursorEl = document.createElement("div"), this.cursorEl.style.position = "absolute", this.cursorEl.style.top = "0", this.cursorEl.style.left = "0", this.cursorEl.style.width = "10px", this.cursorEl.style.height = "10px", this.cursorEl.style.opacity = "0", this.cursorEl.innerHTML = this.pointerIcon, this._viewer.container.appendChild(this.cursorEl);
    }
  };
  rv.PluginType = "InteractionPromptPlugin", nv([ie(), Oe()], rv.prototype, "enabled", void 0), nv([ie(), ze()], rv.prototype, "animationDuration", void 0), nv([ie(), ze()], rv.prototype, "animationDistance", void 0), nv([ie(), ze()], rv.prototype, "animationPauseDuration", void 0), nv([ie(), ze()], rv.prototype, "rotationDistance", void 0), nv([ie(), ze()], rv.prototype, "yOffset", void 0), nv([ie(), Oe()], rv.prototype, "autoStart", void 0), nv([ie(), ze()], rv.prototype, "autoStartDelay", void 0), nv([ie(), Oe()], rv.prototype, "autoStop", void 0), nv([ie(), Oe()], rv.prototype, "autoStartOnObjectLoad", void 0), nv([ie(), Oe()], rv.prototype, "autoStartOnObjectLoadDelay", void 0), nv([Le()], rv.prototype, "currentTime", void 0), nv([Le()], rv.prototype, "lastActionTime", void 0), nv([ie()], rv.prototype, "onlyOnOrbitControls", void 0), nv([je()], rv.prototype, "startAnimation", void 0), nv([je()], rv.prototype, "stopAnimation", void 0), rv = tv = nv([We("Interaction Prompt")], rv);
  class iv extends zs {
    constructor(e2) {
      super(e2), this.licenseKey = e2.licenseKey;
    }
    async initialize({ caching: e2 = true, ground: t2 = true, bloom: n2 = true, depthTonemap: r2 = true, enableDrop: i2 = false, importPopup: s2 = true, debug: o2 = false, interactionPrompt: a2 = true } = {}) {
      o2 && await this.addPlugin(bh), this.getPlugin(Ls) || this.addPluginSync(Ls, void 0, void 0, { storage: e2 && window.caches ? await caches.open("webgi-cache-storage") : void 0 }), await sv(this, { ground: t2, bloom: n2, depthTonemap: r2, enableDrop: i2, importPopup: s2, interactionPrompt: a2 }), await this.getOrAddPlugin(Ho);
      const l2 = await this.getOrAddPlugin(Bc);
      return this.licenseKey && l2.setKey(this.licenseKey), await this.addPlugin(Pg), await this.addPlugin(Rg), await this.addPlugin(Dg), this;
    }
  }
  async function sv(e2, { ground: t2 = true, bloom: n2 = true, depthTonemap: r2 = true, enableDrop: i2 = false, importPopup: s2 = false, interactionPrompt: o2 = true } = {}) {
    await e2.getOrAddPlugin(Ls), s2 && await e2.getOrAddPlugin(Sc), await e2.getOrAddPlugin(wt), await e2.getOrAddPlugin(wd), i2 && await e2.getOrAddPlugin(Fs), await e2.addPlugin(new To(32)), await e2.getOrAddPlugin(Qs), await e2.getOrAddPlugin(io), await e2.addPlugin(new eo(r2 || !e2.useRgbm)), await e2.getOrAddPlugin(ad), await e2.getOrAddPlugin(Kp), await e2.getOrAddPlugin(Yo), await e2.getOrAddPlugin(Ld), await e2.getOrAddPlugin(El), await e2.getOrAddPlugin(fo), await e2.getOrAddPlugin(Po), await e2.getOrAddPlugin(Ya), await e2.getOrAddPlugin(Sl), await e2.getOrAddPlugin(Fd), await e2.getOrAddPlugin(Do), await e2.getOrAddPlugin(Rl), await e2.getOrAddPlugin(fd), await e2.getOrAddPlugin(Ha), await e2.getOrAddPlugin(Wd), await e2.getOrAddPlugin(Pd), await e2.getOrAddPlugin(nd, false), await e2.getOrAddPlugin(yd), await e2.getOrAddPlugin(zp), await e2.getOrAddPlugin(bl, false), await e2.getOrAddPlugin(Ul, false), await e2.getOrAddPlugin(Ro, false), await e2.getOrAddPlugin(jl, false), await e2.getOrAddPlugin(il, false), await e2.getOrAddPlugin(al, false), await e2.getOrAddPlugin(kd, false), await e2.getOrAddPlugin(vh), await e2.getOrAddPlugin(Lh), await e2.getOrAddPlugin(nm), await e2.getOrAddPlugin(Jg), await e2.getOrAddPlugin($g), await e2.getOrAddPlugin(Hg), await e2.getOrAddPlugin(ev), await e2.getOrAddPlugin(Zp), await e2.getOrAddPlugin(dd), n2 && await e2.getOrAddPlugin(yo), t2 && await e2.getOrAddPlugin(Gg), o2 && await e2.getOrAddPlugin(rv), await e2.getOrAddPlugin(Gd), e2.renderer.refreshPipeline();
  }
  var ov = __webpackgi_require__2(109), av = {};
  ov.Z && ov.Z.locals && (av.locals = ov.Z.locals);
  var lv, cv = 0, uv = {};
  uv.styleTagTransform = uc(), uv.setAttributes = oc(), uv.insert = function(e2, t2) {
    (t2.target || document.head).appendChild(e2);
  }, uv.domAPI = ic(), uv.insertStyleElement = lc(), av.use = function(e2) {
    return uv.options = e2 || {}, cv++ || (lv = nc()(ov.Z, uv)), av;
  }, av.unuse = function() {
    cv > 0 && !--cv && (lv(), lv = null);
  };
  var pv = av;
  let dv = 0;
  class hv extends HTMLElement {
    constructor() {
      super(), this._initialized = false, this._state = { src: "", environment: "" }, this._models = {}, this._refreshingModels = false, this._refreshingEnvironment = false, this._environmentFromSource = null, this.viewerIndex = dv++, this.canvasId = "webgi-viewer-" + this.viewerIndex, window.freeViewers || (window.freeViewers = []), this.attachShadow({ mode: "open" }), this.wrapper = document.createElement("div"), this.wrapper.style.width = "100%", this.wrapper.style.height = "100%", this.wrapper.style.display = "block";
      const e2 = window.freeViewers.pop(), n2 = document.createElement("style");
      n2.textContent = t.css`
            #${this.canvasId}{
              width: 100%; height: 100%; z-index: 1;
              display: block;
            }
            //.tippy-box[data-theme~='editor']{
            //    margin: 0.25rem !important;
            //    background-color: hsla(230, 10%, 30%, 1.00) !important;
            //    font-size: 0.9rem !important;
            //    color: hsla(230, 5%, 90%, 1.00) !important;
            //}
        `, pv.use({ target: this.wrapper }), Mg.setDefaultProps({ duration: 300, arrow: true, appendTo: () => this.wrapper }), this.shadowRoot.append(n2, this.wrapper), this._initialized = true, this._initialize(e2).then(async () => this.refreshAll());
    }
    async refreshAll() {
      this.viewer && (this.viewer.renderer.displayCanvasScaling = parseFloat(this.getAttribute("renderScale") || this.getAttribute("renderscale") || this.viewer.renderer.displayCanvasScaling.toString())), await Promise.all([this.refreshModelSource(), this.refreshEnvironment()]);
    }
    async _initialize(e2) {
      (null == e2 ? void 0 : e2._lastState) && (this._state.src = e2._lastState.src || this._state.src, this._state.environment = e2._lastState.environment || this._state.environment, delete e2._lastState), (null == e2 ? void 0 : e2.__models) && (this._models = { ...this._models, ...e2.__models }, delete e2.__models), this.canvas = (null == e2 ? void 0 : e2.canvas) || (0, t.createCanvasElement)(), this.canvas.setAttribute("id", this.canvasId), this.wrapper.append(this.canvas), this.viewer = null != e2 ? e2 : new iv({ canvas: this.canvas, useRgbm: "true" === this._getAttr("rgbm", "true"), useGBufferDepth: "true" === this._getAttr("depth-prepass", "true"), assetManager: { storage: window.caches ? await caches.open("webgi-cache-storage") : void 0 } }), this.viewer && (this.viewer.renderer.displayCanvasScaling = parseFloat(this.getAttribute("renderScale") || this.getAttribute("renderscale") || this.viewer.renderer.displayCanvasScaling.toString())), e2 || await this.viewer.initialize({ debug: "true" === this._getAttr("debug", "false"), ground: "baked" === this._getAttr("ground", "baked"), bloom: "true" === this._getAttr("bloom", "true"), depthTonemap: true }), this.dispatchEvent(new Event("initialized"));
    }
    connectedCallback() {
      this._initialized && this.viewer && (this.viewer.resize(), this.viewer.enabled = true, this.dispatchEvent(new Event("connected")));
    }
    disconnectedCallback() {
      var e2, t2;
      this.viewer && ("true" === this.getAttribute("disposeOnRemove") || "true" === this.getAttribute("disposeonremove") ? (null === (e2 = this.canvas) || void 0 === e2 || e2.remove(), this.clearViewer(), this.viewer.dispose(), this.viewer = void 0, this.canvas = void 0, this._initialized = false) : "true" === this.getAttribute("autoManageViewers") || "true" === this.getAttribute("automanageviewers") ? (null === (t2 = this.canvas) || void 0 === t2 || t2.remove(), this.viewer._lastState = { ...this._state }, this.viewer._lastState.src = "", this.clearViewer(), window.freeViewers.push(this.viewer), this.viewer = void 0, this.canvas = void 0, this._initialized = false) : this.viewer.enabled = false, this.dispatchEvent(new Event("disconnected")));
    }
    adoptedCallback() {
      this.viewer && (this.viewer.resize(), this.viewer.enabled = true);
    }
    static get observedAttributes() {
      return ["src", "environment", "renderScale"];
    }
    attributeChangedCallback(e2, t2, n2) {
      this.refreshAll();
    }
    clearViewer() {
      var e2, t2;
      null === (e2 = this.viewer) || void 0 === e2 || e2.scene.disposeSceneModels(), null === (t2 = this.viewer) || void 0 === t2 || t2.scene.setEnvironment(null), Object.values(this._models).forEach(async (e3) => e3.then((e4) => e4.forEach((e5) => e5.dispose && e5.dispose()))), this._models = {};
    }
    async refreshModelSource() {
      if (!this.viewer)
        return;
      const e2 = this._getAttr("src", "");
      if (e2 === this._state.src)
        return;
      if (this._refreshingModels)
        return;
      this._refreshingModels = true;
      const t2 = [e2], n2 = [], r2 = [], i2 = this.viewer.scene.environment;
      this.viewer.scene.environment = null, this._environmentFromSource = null;
      for (const e3 of t2)
        !this._models[e3] && e3 && (this._models[e3] = this.viewer.getManager().importer.importPath(e3, { autoScale: "true" === this._getAttr("auto-scale", "true"), autoCenter: "true" === this._getAttr("auto-center", "true"), processImported: true, pathOverride: this._getAttr("filename", "") || void 0 }));
      const s2 = this.viewer.scene.environment;
      s2 ? this._environmentFromSource = s2 : this.viewer.scene.environment = i2;
      for (const [e3, i3] of Object.entries(this._models))
        t2.includes(e3) ? n2.push(i3.then((t3) => [e3, t3])) : r2.push(i3);
      await Promise.all([Promise.all(n2).then(async (e3) => Promise.all(e3.map(async (e4) => (this._models[e4[0]] = this.viewer.getManager().importer.processImported(e4[1]), this._models[e4[0]])))).then((e3) => {
        for (const t3 of e3)
          for (const e4 of t3)
            e4 && "model" === e4.assetType && this.viewer.scene.addSceneObject(e4);
      }), Promise.all(r2).then((e3) => {
        for (const t3 of e3)
          for (const e4 of t3)
            e4 && "model" === e4.assetType && e4.modelObject.removeFromParent();
      })]), this._state.src = e2, this._refreshingModels = false;
    }
    async refreshEnvironment() {
      if (!this.viewer)
        return;
      if (!this.hasAttribute("environment"))
        return void (this._state.environment = null);
      if (this._environmentFromSource)
        return void this.viewer.console.warn("Environment is already set by model source, ignoring environment attribute.");
      const e2 = this._getAttr("environment", "");
      if (e2 === this._state.src)
        return;
      if (this._refreshingEnvironment)
        return;
      this._refreshingEnvironment = true;
      const t2 = this.viewer.scene.getEnvironment(), n2 = e2 ? await this.viewer.getManager().importer.importSinglePath(e2) : void 0;
      this._environmentFromSource ? this.viewer.console.warn("Environment is already set by model source, ignoring environment attribute.") : (n2 && "texture" !== n2.assetType || await this.viewer.scene.setEnvironment(n2), null == t2 || t2.dispose(), this.dispatchEvent(new CustomEvent("environment-loaded", { detail: { src: e2 } })), this._state.environment = e2, this._refreshingEnvironment = false);
    }
    _getAttr(e2, t2) {
      return this.hasAttribute(e2) ? this.getAttribute(e2) : t2;
    }
    addEventListener(e2, t2, n2) {
      super.addEventListener(e2, t2, n2), "initialized" === e2 && this._initialized && this.dispatchEvent(new Event("initialized"));
    }
  }
  window && window.customElements && !window.customElements.get("webgi-viewer") && window.customElements.define("webgi-viewer", hv);
  var fv = __webpackgi_require__2(798), mv = {};
  fv.Z && fv.Z.locals && (mv.locals = fv.Z.locals);
  var _v, gv = 0, vv = {};
  vv.styleTagTransform = uc(), vv.setAttributes = oc(), vv.insert = function(e2, t2) {
    (t2.target || document.head).appendChild(e2);
  }, vv.domAPI = ic(), vv.insertStyleElement = lc(), mv.use = function(e2) {
    return vv.options = e2 || {}, gv++ || (_v = nc()(fv.Z, vv)), mv;
  }, mv.unuse = function() {
    gv > 0 && !--gv && (_v(), _v = null);
  };
  var yv = mv;
  let bv = class extends xc {
    constructor() {
      super("Popup");
      const e2 = (0, t.createDiv)({ id: "assetManagerPopupClose", addToBody: false, innerHTML: "&#10005" });
      e2.addEventListener("click", () => {
        this._mainDiv.style.display = "none";
      }), this._mainDiv.appendChild(e2);
    }
    _updateMainDiv(e2) {
      if (!this._contentDiv)
        return;
      if (!this.enabled)
        return void (this._mainDiv.style.display = "none");
      let t2 = "";
      e2.forEach((e3, n2) => {
        t2 += `<span class="processState">${e3.state}</span>: ${(n2 || "").split("/").pop()} ${e3.progress ? " - " + e3.progress.toFixed(0) + "%" : ""}<br>`;
      }), this._contentDiv.innerHTML = t2, 0 === e2.size ? this._mainDiv.style.display = "none" : this._mainDiv.style.display = "block";
    }
    async onAdded(e2) {
      yv.use({ target: e2.container }), await super.onAdded(e2);
    }
  };
  bv.PluginType = "AssetManagerBasicPopupPlugin", bv = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  }([We("Asset manager popup")], bv);
  var wv = __webpackgi_require__2(44), Av = {};
  wv.Z && wv.Z.locals && (Av.locals = wv.Z.locals);
  var xv, Ev = 0, Cv = {};
  Cv.styleTagTransform = uc(), Cv.setAttributes = oc(), Cv.insert = function(e2, t2) {
    (t2.target || document.head).appendChild(e2);
  }, Cv.domAPI = ic(), Cv.insertStyleElement = lc(), Av.use = function(e2) {
    return Cv.options = e2 || {}, Ev++ || (xv = nc()(wv.Z, Cv)), Av;
  }, Av.unuse = function() {
    Ev > 0 && !--Ev && (xv(), xv = null);
  };
  var Sv = Av, Mv = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let Tv = class extends xc {
    constructor(e2 = true) {
      super("LoadingBar"), this.showText = e2, this.hideOnOnlyErrors = true;
    }
    _updateMainDiv(e2) {
      if (!this._contentDiv)
        return;
      if (!this.enabled)
        return void (this._mainDiv.style.display = "none");
      let t2 = 1, n2 = 1;
      e2.forEach((e3, r3) => {
        var i2;
        t2 += null !== (i2 = e3.progress) && void 0 !== i2 ? i2 : 99, n2 += 100;
      }), this._contentDiv.innerHTML = this.showText ? (100 * t2 / n2).toFixed(0) + "%" : "&nbsp;", this._contentDiv.style.width = (100 * t2 / n2).toFixed(0) + "%";
      const r2 = [...e2.values()].filter((e3) => "error" === e3.state);
      r2.length > 0 && r2.length === e2.size && this.hideOnOnlyErrors || 0 === e2.size ? this._mainDiv.style.display = "none" : this._mainDiv.style.display = "block";
    }
    async onAdded(e2) {
      Sv.use({ target: e2.container }), await super.onAdded(e2);
    }
  };
  Tv.PluginType = "AssetManagerLoadingBarPlugin", Mv([Oe("Hide on only errors"), ie()], Tv.prototype, "hideOnOnlyErrors", void 0), Tv = Mv([We("Asset manager loading bar")], Tv);
  class Pv {
    get basePath() {
      return this._basePath;
    }
    get assets() {
      return this._assets;
    }
    constructor(e2) {
      var t2, n2, r2;
      this._basePath = null !== (t2 = null == e2 ? void 0 : e2.basePath) && void 0 !== t2 ? t2 : "", this._assets = null !== (r2 = null === (n2 = null == e2 ? void 0 : e2.assets) || void 0 === n2 ? void 0 : n2.map((e3) => this._resolveAsset(e3))) && void 0 !== r2 ? r2 : [];
    }
    find(e2) {
      const t2 = this._assets.find(e2);
      return null != t2 ? t2 : void 0;
    }
    _resolveAsset(e2) {
      return { ...e2, path: (0, t.pathJoin)([this._basePath, e2.path]) };
    }
  }
  class Iv extends t.SimpleEventDispatcher {
    constructor(...e2) {
      super(), this._assets = e2;
    }
    addAssetList(e2) {
      this._assets.push(e2);
    }
    removeAssetList(e2) {
      const t2 = this._assets.indexOf(e2);
      t2 >= 0 && this._assets.splice(t2, 1);
    }
    async findAssetRegex(e2) {
      for (const t2 of this._assets) {
        const n2 = t2.find((t3) => {
          var n3, r2;
          return t3 && (e2.test(t3.path) || e2.test(null !== (r2 = null === (n3 = t3.file) || void 0 === n3 ? void 0 : n3.name) && void 0 !== r2 ? r2 : ""));
        });
        if (n2)
          return n2;
      }
      console.warn("Asset not found:", e2);
    }
    async findAsset(e2) {
      return this.findAssetRegex(e2.query);
    }
    async findAssetSimple(e2, t2 = false) {
      return this.findAssetRegex(new RegExp(e2, t2 ? "i" : ""));
    }
  }
  const Rv = new n.Pa4(), kv = new n.Pa4(), Dv = new n.Ltg(), Bv = new n.Ltg(), Ov = new n.Ltg(), Lv = new n.Pa4(), Uv = new n.yGw(), Fv = new n.Zzh(), Nv = new n.Pa4(), jv = new n.ZzF(), zv = new n.aLr(), Gv = new n.Ltg();
  let Vv, Hv, Qv, Wv, qv, Xv;
  function Yv(e2, t2, n2) {
    return Gv.set(0, 0, -t2, 1).applyMatrix4(e2.projectionMatrix), Gv.multiplyScalar(1 / Gv.w), Gv.x = Hv / n2.width, Gv.y = Hv / n2.height, Gv.applyMatrix4(e2.projectionMatrixInverse), Gv.multiplyScalar(1 / Gv.w), Math.abs(Math.max(Gv.x, Gv.y));
  }
  class Kv extends n.Kj0 {
    constructor(e2 = new $o(), t2 = new ta({ color: 16777215 * Math.random() })) {
      super(e2, t2), this.isLineSegments2 = true, this.type = "LineSegments2";
    }
    computeLineDistances() {
      const e2 = this.geometry, t2 = e2.attributes.instanceStart, r2 = e2.attributes.instanceEnd, i2 = new Float32Array(2 * t2.count);
      for (let e3 = 0, n2 = 0, s3 = t2.count; e3 < s3; e3++, n2 += 2)
        Rv.fromBufferAttribute(t2, e3), kv.fromBufferAttribute(r2, e3), i2[n2] = 0 === n2 ? 0 : i2[n2 - 1], i2[n2 + 1] = i2[n2] + Rv.distanceTo(kv);
      const s2 = new n.$TI(i2, 2, 1);
      return e2.setAttribute("instanceDistanceStart", new n.kB5(s2, 1, 0)), e2.setAttribute("instanceDistanceEnd", new n.kB5(s2, 1, 1)), this;
    }
    raycast(e2, t2) {
      const r2 = this.material.worldUnits, i2 = e2.camera;
      null !== i2 || r2 || console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
      const s2 = void 0 !== e2.params.Line2 && e2.params.Line2.threshold || 0;
      Vv = e2.ray;
      const o2 = this.matrixWorld, a2 = this.geometry, l2 = this.material;
      let c2, u2;
      Hv = l2.linewidth + s2, null === a2.boundingSphere && a2.computeBoundingSphere(), zv.copy(a2.boundingSphere).applyMatrix4(o2), c2 = r2 ? 0.5 * Hv : Yv(i2, Math.max(i2.near, zv.distanceToPoint(Vv.origin)), l2.resolution), zv.radius += c2, false !== Vv.intersectsSphere(zv) && (null === a2.boundingBox && a2.computeBoundingBox(), jv.copy(a2.boundingBox).applyMatrix4(o2), u2 = r2 ? 0.5 * Hv : Yv(i2, Math.max(i2.near, jv.distanceToPoint(Vv.origin)), l2.resolution), jv.expandByScalar(u2), false !== Vv.intersectsBox(jv) && (r2 ? function(e3, t3) {
        const r3 = e3.matrixWorld, i3 = e3.geometry, s3 = i3.attributes.instanceStart, o3 = i3.attributes.instanceEnd;
        for (let a3 = 0, l3 = Math.min(i3.instanceCount, s3.count); a3 < l3; a3++) {
          Fv.start.fromBufferAttribute(s3, a3), Fv.end.fromBufferAttribute(o3, a3), Fv.applyMatrix4(r3);
          const i4 = new n.Pa4(), l4 = new n.Pa4();
          Vv.distanceSqToSegment(Fv.start, Fv.end, l4, i4), l4.distanceTo(i4) < 0.5 * Hv && t3.push({ point: l4, pointOnLine: i4, distance: Vv.origin.distanceTo(l4), object: e3, face: null, faceIndex: a3, uv: null, uv1: null });
        }
      }(this, t2) : function(e3, t3, r3) {
        const i3 = t3.projectionMatrix, s3 = e3.material.resolution, o3 = e3.matrixWorld, a3 = e3.geometry, l3 = a3.attributes.instanceStart, c3 = a3.attributes.instanceEnd, u3 = Math.min(a3.instanceCount, l3.count), p2 = -t3.near;
        Vv.at(1, Ov), Ov.w = 1, Ov.applyMatrix4(t3.matrixWorldInverse), Ov.applyMatrix4(i3), Ov.multiplyScalar(1 / Ov.w), Ov.x *= s3.x / 2, Ov.y *= s3.y / 2, Ov.z = 0, Lv.copy(Ov), Uv.multiplyMatrices(t3.matrixWorldInverse, o3);
        for (let t4 = 0, a4 = u3; t4 < a4; t4++) {
          if (Dv.fromBufferAttribute(l3, t4), Bv.fromBufferAttribute(c3, t4), Dv.w = 1, Bv.w = 1, Dv.applyMatrix4(Uv), Bv.applyMatrix4(Uv), Dv.z > p2 && Bv.z > p2)
            continue;
          if (Dv.z > p2) {
            const e4 = Dv.z - Bv.z, t5 = (Dv.z - p2) / e4;
            Dv.lerp(Bv, t5);
          } else if (Bv.z > p2) {
            const e4 = Bv.z - Dv.z, t5 = (Bv.z - p2) / e4;
            Bv.lerp(Dv, t5);
          }
          Dv.applyMatrix4(i3), Bv.applyMatrix4(i3), Dv.multiplyScalar(1 / Dv.w), Bv.multiplyScalar(1 / Bv.w), Dv.x *= s3.x / 2, Dv.y *= s3.y / 2, Bv.x *= s3.x / 2, Bv.y *= s3.y / 2, Fv.start.copy(Dv), Fv.start.z = 0, Fv.end.copy(Bv), Fv.end.z = 0;
          const a5 = Fv.closestPointToPointParameter(Lv, true);
          Fv.at(a5, Nv);
          const u4 = n.M8C.lerp(Dv.z, Bv.z, a5), d2 = u4 >= -1 && u4 <= 1, h2 = Lv.distanceTo(Nv) < 0.5 * Hv;
          if (d2 && h2) {
            Fv.start.fromBufferAttribute(l3, t4), Fv.end.fromBufferAttribute(c3, t4), Fv.start.applyMatrix4(o3), Fv.end.applyMatrix4(o3);
            const i4 = new n.Pa4(), s4 = new n.Pa4();
            Vv.distanceSqToSegment(Fv.start, Fv.end, s4, i4), r3.push({ point: s4, pointOnLine: i4, distance: Vv.origin.distanceTo(s4), object: e3, face: null, faceIndex: t4, uv: null, uv1: null });
          }
        }
      }(this, i2, t2)));
    }
  }
  class Jv extends $o {
    constructor() {
      super(), this.isLineGeometry = true, this.type = "LineGeometry";
    }
    setPositions(e2) {
      const t2 = e2.length - 3, n2 = new Float32Array(2 * t2);
      for (let r2 = 0; r2 < t2; r2 += 3)
        n2[2 * r2] = e2[r2], n2[2 * r2 + 1] = e2[r2 + 1], n2[2 * r2 + 2] = e2[r2 + 2], n2[2 * r2 + 3] = e2[r2 + 3], n2[2 * r2 + 4] = e2[r2 + 4], n2[2 * r2 + 5] = e2[r2 + 5];
      return super.setPositions(n2), this;
    }
    setColors(e2) {
      const t2 = e2.length - 3, n2 = new Float32Array(2 * t2);
      for (let r2 = 0; r2 < t2; r2 += 3)
        n2[2 * r2] = e2[r2], n2[2 * r2 + 1] = e2[r2 + 1], n2[2 * r2 + 2] = e2[r2 + 2], n2[2 * r2 + 3] = e2[r2 + 3], n2[2 * r2 + 4] = e2[r2 + 4], n2[2 * r2 + 5] = e2[r2 + 5];
      return super.setColors(n2), this;
    }
    fromLine(e2) {
      const t2 = e2.geometry;
      return this.setPositions(t2.attributes.position.array), this;
    }
  }
  class Zv extends Kv {
    constructor(e2 = new Jv(), t2 = new ta({ color: 16777215 * Math.random() })) {
      super(e2, t2), this.isLine2 = true, this.type = "Line2";
    }
  }
  class $v extends n.DqL {
    constructor(e2) {
      super(e2);
    }
    parse(e2, t2) {
      const n2 = new ey(e2, 1);
      return { mipmaps: n2.mipmaps(t2), width: n2.pixelWidth, height: n2.pixelHeight, format: n2.glInternalFormat, isCubemap: 6 === n2.numberOfFaces, mipmapCount: n2.numberOfMipmapLevels };
    }
  }
  class ey {
    constructor(e2, t2) {
      this.arrayBuffer = e2;
      const n2 = new Uint8Array(this.arrayBuffer, 0, 12);
      if (171 !== n2[0] || 75 !== n2[1] || 84 !== n2[2] || 88 !== n2[3] || 32 !== n2[4] || 49 !== n2[5] || 49 !== n2[6] || 187 !== n2[7] || 13 !== n2[8] || 10 !== n2[9] || 26 !== n2[10] || 10 !== n2[11])
        return void console.error("texture missing KTX identifier");
      const r2 = Uint32Array.BYTES_PER_ELEMENT, i2 = new DataView(this.arrayBuffer, 12, 13 * r2), s2 = 67305985 === i2.getUint32(0, true);
      this.glType = i2.getUint32(1 * r2, s2), this.glTypeSize = i2.getUint32(2 * r2, s2), this.glFormat = i2.getUint32(3 * r2, s2), this.glInternalFormat = i2.getUint32(4 * r2, s2), this.glBaseInternalFormat = i2.getUint32(5 * r2, s2), this.pixelWidth = i2.getUint32(6 * r2, s2), this.pixelHeight = i2.getUint32(7 * r2, s2), this.pixelDepth = i2.getUint32(8 * r2, s2), this.numberOfArrayElements = i2.getUint32(9 * r2, s2), this.numberOfFaces = i2.getUint32(10 * r2, s2), this.numberOfMipmapLevels = i2.getUint32(11 * r2, s2), this.bytesOfKeyValueData = i2.getUint32(12 * r2, s2), 0 === this.glType ? (this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels), 0 !== this.pixelHeight && 0 === this.pixelDepth ? 0 === this.numberOfArrayElements ? this.numberOfFaces === t2 ? this.loadType = 0 : console.warn("number of faces expected" + t2 + ", but found " + this.numberOfFaces) : console.warn("texture arrays not currently supported") : console.warn("only 2D textures currently supported")) : console.warn("only compressed formats currently supported");
    }
    mipmaps(e2) {
      const t2 = [];
      let n2 = 64 + this.bytesOfKeyValueData, r2 = this.pixelWidth, i2 = this.pixelHeight;
      const s2 = e2 ? this.numberOfMipmapLevels : 1;
      for (let e3 = 0; e3 < s2; e3++) {
        const e4 = new Int32Array(this.arrayBuffer, n2, 1)[0];
        n2 += 4;
        for (let s3 = 0; s3 < this.numberOfFaces; s3++) {
          const s4 = new Uint8Array(this.arrayBuffer, n2, e4);
          t2.push({ data: s4, width: r2, height: i2 }), n2 += e4, n2 += 3 - (e4 + 3) % 4;
        }
        r2 = Math.max(1, 0.5 * r2), i2 = Math.max(1, 0.5 * i2);
      }
      return t2;
    }
  }
  class ty extends t.SimpleEventDispatcher {
    constructor() {
      super(...arguments), this.dependencies = [Ls];
    }
    async onAdded(e2) {
      var t2, n2;
      this._importer || (this._importer = new Ft($v, ["ktx"], false)), null === (n2 = null === (t2 = e2.getManager()) || void 0 === t2 ? void 0 : t2.importer) || void 0 === n2 || n2.Importers.push(this._importer);
    }
    async onDispose(e2) {
      this._importer = void 0;
    }
    async onRemove(e2) {
      var t2, n2;
      this._importer && (null === (n2 = null === (t2 = e2.getManager()) || void 0 === t2 ? void 0 : t2.importer) || void 0 === n2 ? void 0 : n2.Importers) && e2.getManager().importer.Importers.splice(e2.getManager().importer.Importers.indexOf(this._importer), 1), this._importer = void 0;
    }
  }
  ty.PluginType = "KTXLoadPlugin";
  class ny extends n.hH6 {
    constructor(e2) {
      super(e2), this.responseType = "blob";
    }
  }
  class ry extends n.hH6 {
    constructor(e2) {
      super(e2), this.responseType = "blob";
    }
    load(e2, n2, r2, i2) {
      return super.load(e2, (e3) => {
        try {
          null == n2 || n2((0, t.blobToDataURL)(e3));
        } catch (e4) {
          null == i2 || i2(e4);
        }
      }, r2, i2);
    }
  }
  class iy {
    async parseAsync(e2, t2) {
      var n2;
      return new Blob([JSON.stringify(e2, null, null !== (n2 = t2.jsonSpaces) && void 0 !== n2 ? n2 : 2)], { type: "application/json" });
    }
  }
  class sy {
    async parseAsync(e2, t2) {
      return new Blob([e2], { type: "text/plain" });
    }
  }
  function oy(e2, t2 = 1 / 0, r2 = null) {
    Wv || (Wv = new n._12(2, 2, 1, 1)), qv || (qv = new n.jyz({ uniforms: { blitTexture: new n.xWb(e2) }, vertexShader: "\n            varying vec2 vUv;\n            void main(){\n                vUv = uv;\n                gl_Position = vec4(position.xy * 1.0,0.,.999999);\n            }", fragmentShader: "\n            uniform sampler2D blitTexture; \n            varying vec2 vUv;\n\n            void main(){ \n                gl_FragColor = vec4(vUv.xy, 0, 1);\n                \n                #ifdef IS_SRGB\n                gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );\n                #else\n                gl_FragColor = texture2D( blitTexture, vUv);\n                #endif\n            }" })), qv.uniforms.blitTexture.value = e2, qv.defines.IS_SRGB = e2.colorSpace == n.KI_, qv.needsUpdate = true, Xv || (Xv = new n.Kj0(Wv, qv), Xv.frustrumCulled = false);
    const i2 = new n.cPb(), s2 = new n.xsS();
    s2.add(Xv), r2 || (r2 = Qv = new n.CP7({ antialias: false })), r2.setSize(Math.min(e2.image.width, t2), Math.min(e2.image.height, t2)), r2.clear(), r2.render(s2, i2);
    const o2 = new n.xEZ(r2.domElement);
    return o2.minFilter = e2.minFilter, o2.magFilter = e2.magFilter, o2.wrapS = e2.wrapS, o2.wrapT = e2.wrapT, o2.name = e2.name, Qv && (Qv.dispose(), Qv = null), o2;
  }
  const ay = { POSITION: ["byte", "byte normalized", "unsigned byte", "unsigned byte normalized", "short", "short normalized", "unsigned short", "unsigned short normalized"], NORMAL: ["byte normalized", "short normalized"], TANGENT: ["byte normalized", "short normalized"], TEXCOORD: ["byte", "byte normalized", "unsigned byte", "short", "short normalized", "unsigned short"] };
  class ly {
    constructor() {
      this.pluginCallbacks = [], this.register(function(e2) {
        return new xy(e2);
      }), this.register(function(e2) {
        return new Ey(e2);
      }), this.register(function(e2) {
        return new My(e2);
      }), this.register(function(e2) {
        return new Ty(e2);
      }), this.register(function(e2) {
        return new Py(e2);
      }), this.register(function(e2) {
        return new Iy(e2);
      }), this.register(function(e2) {
        return new Cy(e2);
      }), this.register(function(e2) {
        return new Sy(e2);
      }), this.register(function(e2) {
        return new Ry(e2);
      }), this.register(function(e2) {
        return new ky(e2);
      }), this.register(function(e2) {
        return new Dy(e2);
      });
    }
    register(e2) {
      return -1 === this.pluginCallbacks.indexOf(e2) && this.pluginCallbacks.push(e2), this;
    }
    unregister(e2) {
      return -1 !== this.pluginCallbacks.indexOf(e2) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e2), 1), this;
    }
    parse(e2, t2, n2, r2, i2) {
      const s2 = i2 || new Ay(), o2 = [];
      for (let e3 = 0, t3 = this.pluginCallbacks.length; e3 < t3; e3++)
        o2.push(this.pluginCallbacks[e3](s2));
      s2.setPlugins(o2), s2.write(e2, t2, r2).catch(n2);
    }
    parseAsync(e2, t2) {
      const n2 = this;
      return new Promise(function(r2, i2) {
        n2.parse(e2, r2, i2, t2);
      });
    }
  }
  const cy = 5120, uy = 5121, py = 5122, dy = 5123, hy = "KHR_mesh_quantization", fy = {};
  fy[n.TyD] = 9728, fy[n.YLQ] = 9984, fy[n.aH4] = 9986, fy[n.wem] = 9729, fy[n.qyh] = 9985, fy[n.D1R] = 9987, fy[n.uWy] = 33071, fy[n.rpg] = 10497, fy[n.OoA] = 33648;
  const my = { scale: "scale", position: "translation", quaternion: "rotation", morphTargetInfluences: "weights" }, _y = new n.Ilk();
  function gy(e2, t2) {
    return e2.length === t2.length && e2.every(function(e3, n2) {
      return e3 === t2[n2];
    });
  }
  function vy(e2) {
    return 4 * Math.ceil(e2 / 4);
  }
  function yy(e2, t2 = 0) {
    const n2 = vy(e2.byteLength);
    if (n2 !== e2.byteLength) {
      const r2 = new Uint8Array(n2);
      if (r2.set(new Uint8Array(e2)), 0 !== t2)
        for (let i2 = e2.byteLength; i2 < n2; i2++)
          r2[i2] = t2;
      return r2.buffer;
    }
    return e2;
  }
  function by() {
    return "undefined" == typeof document && "undefined" != typeof OffscreenCanvas ? new OffscreenCanvas(1, 1) : document.createElement("canvas");
  }
  function wy(e2, t2) {
    if (void 0 !== e2.toBlob)
      return new Promise((n3) => e2.toBlob(n3, t2));
    let n2;
    return "image/jpeg" === t2 ? n2 = 0.92 : "image/webp" === t2 && (n2 = 0.8), e2.convertToBlob({ type: t2, quality: n2 });
  }
  class Ay {
    constructor() {
      this.plugins = [], this.options = {}, this.pending = [], this.buffers = [], this.byteOffset = 0, this.buffers = [], this.nodeMap = /* @__PURE__ */ new Map(), this.skins = [], this.extensionsUsed = {}, this.extensionsRequired = {}, this.uids = /* @__PURE__ */ new Map(), this.uid = 0, this.json = { asset: { version: "2.0", generator: "THREE.GLTFExporter" } }, this.cache = { meshes: /* @__PURE__ */ new Map(), attributes: /* @__PURE__ */ new Map(), attributesNormalized: /* @__PURE__ */ new Map(), materials: /* @__PURE__ */ new Map(), textures: /* @__PURE__ */ new Map(), images: /* @__PURE__ */ new Map() };
    }
    setPlugins(e2) {
      this.plugins = e2;
    }
    async write(e2, t2, n2 = {}) {
      this.options = Object.assign({ binary: false, trs: false, onlyVisible: true, maxTextureSize: 1 / 0, animations: [], includeCustomExtensions: false }, n2), this.options.animations.length > 0 && (this.options.trs = true), this.processInput(e2), await Promise.all(this.pending);
      const r2 = this, i2 = r2.buffers, s2 = r2.json;
      n2 = r2.options;
      const o2 = r2.extensionsUsed, a2 = r2.extensionsRequired, l2 = new Blob(i2, { type: "application/octet-stream" }), c2 = Object.keys(o2), u2 = Object.keys(a2);
      if (c2.length > 0 && (s2.extensionsUsed = c2), u2.length > 0 && (s2.extensionsRequired = u2), s2.buffers && s2.buffers.length > 0 && (s2.buffers[0].byteLength = l2.size), true === n2.binary) {
        const e3 = new FileReader();
        e3.readAsArrayBuffer(l2), e3.onloadend = function() {
          const n3 = yy(e3.result), r3 = new DataView(new ArrayBuffer(8));
          r3.setUint32(0, n3.byteLength, true), r3.setUint32(4, 5130562, true);
          const i3 = yy((o3 = JSON.stringify(s2), new TextEncoder().encode(o3).buffer), 32);
          var o3;
          const a3 = new DataView(new ArrayBuffer(8));
          a3.setUint32(0, i3.byteLength, true), a3.setUint32(4, 1313821514, true);
          const l3 = new ArrayBuffer(12), c3 = new DataView(l3);
          c3.setUint32(0, 1179937895, true), c3.setUint32(4, 2, true);
          const u3 = 12 + a3.byteLength + i3.byteLength + r3.byteLength + n3.byteLength;
          c3.setUint32(8, u3, true);
          const p2 = new Blob([l3, a3, i3, r3, n3], { type: "application/octet-stream" }), d2 = new FileReader();
          d2.readAsArrayBuffer(p2), d2.onloadend = function() {
            t2(d2.result);
          };
        };
      } else if (s2.buffers && s2.buffers.length > 0) {
        const e3 = new FileReader();
        e3.readAsDataURL(l2), e3.onloadend = function() {
          const n3 = e3.result;
          s2.buffers[0].uri = n3, t2(s2);
        };
      } else
        t2(s2);
    }
    serializeUserData(e2, t2) {
      if (0 === Object.keys(e2.userData).length)
        return;
      const n2 = this.options, r2 = this.extensionsUsed;
      try {
        const i2 = JSON.parse(JSON.stringify(e2.userData));
        if (n2.includeCustomExtensions && i2.gltfExtensions) {
          void 0 === t2.extensions && (t2.extensions = {});
          for (const e3 in i2.gltfExtensions)
            t2.extensions[e3] = i2.gltfExtensions[e3], r2[e3] = true;
          delete i2.gltfExtensions;
        }
        Object.keys(i2).length > 0 && (t2.extras = i2);
      } catch (t3) {
        console.warn("THREE.GLTFExporter: userData of '" + e2.name + "' won't be serialized because of JSON.stringify error - " + t3.message), console.warn({ ...e2.userData });
      }
    }
    getUID(e2, t2 = false) {
      if (false === this.uids.has(e2)) {
        const t3 = /* @__PURE__ */ new Map();
        t3.set(true, this.uid++), t3.set(false, this.uid++), this.uids.set(e2, t3);
      }
      return this.uids.get(e2).get(t2);
    }
    isNormalizedNormalAttribute(e2) {
      if (this.cache.attributesNormalized.has(e2))
        return false;
      const t2 = new n.Pa4();
      for (let n2 = 0, r2 = e2.count; n2 < r2; n2++)
        if (Math.abs(t2.fromBufferAttribute(e2, n2).length() - 1) > 5e-4)
          return false;
      return true;
    }
    createNormalizedNormalAttribute(e2) {
      const t2 = this.cache;
      if (t2.attributesNormalized.has(e2))
        return t2.attributesNormalized.get(e2);
      const r2 = e2.clone(), i2 = new n.Pa4();
      for (let e3 = 0, t3 = r2.count; e3 < t3; e3++)
        i2.fromBufferAttribute(r2, e3), 0 === i2.x && 0 === i2.y && 0 === i2.z ? i2.setX(1) : i2.normalize(), r2.setXYZ(e3, i2.x, i2.y, i2.z);
      return t2.attributesNormalized.set(e2, r2), r2;
    }
    applyTextureTransform(e2, t2) {
      let n2 = false;
      const r2 = {};
      0 === t2.offset.x && 0 === t2.offset.y || (r2.offset = t2.offset.toArray(), n2 = true), 0 !== t2.rotation && (r2.rotation = t2.rotation, n2 = true), 1 === t2.repeat.x && 1 === t2.repeat.y || (r2.scale = t2.repeat.toArray(), n2 = true), n2 && (e2.extensions = e2.extensions || {}, e2.extensions.KHR_texture_transform = r2, this.extensionsUsed.KHR_texture_transform = true);
    }
    buildMetalRoughTexture(e2, t2) {
      if (e2 === t2)
        return e2;
      function r2(e3) {
        return e3.colorSpace === n.KI_ ? function(e4) {
          return e4 < 0.04045 ? 0.0773993808 * e4 : Math.pow(0.9478672986 * e4 + 0.0521327014, 2.4);
        } : function(e4) {
          return e4;
        };
      }
      console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures."), e2 instanceof n.EB7 && (e2 = oy(e2)), t2 instanceof n.EB7 && (t2 = oy(t2));
      const i2 = e2 ? e2.image : null, s2 = t2 ? t2.image : null, o2 = Math.max(i2 ? i2.width : 0, s2 ? s2.width : 0), a2 = Math.max(i2 ? i2.height : 0, s2 ? s2.height : 0), l2 = by();
      l2.width = o2, l2.height = a2;
      const c2 = l2.getContext("2d");
      c2.fillStyle = "#00ffff", c2.fillRect(0, 0, o2, a2);
      const u2 = c2.getImageData(0, 0, o2, a2);
      if (i2) {
        c2.drawImage(i2, 0, 0, o2, a2);
        const t3 = r2(e2), n2 = c2.getImageData(0, 0, o2, a2).data;
        for (let e3 = 2; e3 < n2.length; e3 += 4)
          u2.data[e3] = 256 * t3(n2[e3] / 256);
      }
      if (s2) {
        c2.drawImage(s2, 0, 0, o2, a2);
        const e3 = r2(t2), n2 = c2.getImageData(0, 0, o2, a2).data;
        for (let t3 = 1; t3 < n2.length; t3 += 4)
          u2.data[t3] = 256 * e3(n2[t3] / 256);
      }
      c2.putImageData(u2, 0, 0);
      const p2 = (e2 || t2).clone();
      return p2.source = new n.Hw6(l2), p2.colorSpace = n.aCh, p2.channel = (e2 || t2).channel, e2 && t2 && e2.channel !== t2.channel && console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match."), p2;
    }
    processBuffer(e2) {
      const t2 = this.json, n2 = this.buffers;
      return t2.buffers || (t2.buffers = [{ byteLength: 0 }]), n2.push(e2), 0;
    }
    processBufferView(e2, t2, r2, i2, s2) {
      const o2 = this.json;
      let a2;
      switch (o2.bufferViews || (o2.bufferViews = []), t2) {
        case cy:
        case uy:
          a2 = 1;
          break;
        case py:
        case dy:
          a2 = 2;
          break;
        default:
          a2 = 4;
      }
      const l2 = vy(i2 * e2.itemSize * a2), c2 = new DataView(new ArrayBuffer(l2));
      let u2 = 0;
      for (let s3 = r2; s3 < r2 + i2; s3++)
        for (let r3 = 0; r3 < e2.itemSize; r3++) {
          let i3;
          e2.itemSize > 4 ? i3 = e2.array[s3 * e2.itemSize + r3] : (0 === r3 ? i3 = e2.getX(s3) : 1 === r3 ? i3 = e2.getY(s3) : 2 === r3 ? i3 = e2.getZ(s3) : 3 === r3 && (i3 = e2.getW(s3)), true === e2.normalized && (i3 = n.M8C.normalize(i3, e2.array))), 5126 === t2 ? c2.setFloat32(u2, i3, true) : 5124 === t2 ? c2.setInt32(u2, i3, true) : 5125 === t2 ? c2.setUint32(u2, i3, true) : t2 === py ? c2.setInt16(u2, i3, true) : t2 === dy ? c2.setUint16(u2, i3, true) : t2 === cy ? c2.setInt8(u2, i3) : t2 === uy && c2.setUint8(u2, i3), u2 += a2;
        }
      const p2 = { buffer: this.processBuffer(c2.buffer), byteOffset: this.byteOffset, byteLength: l2 };
      return void 0 !== s2 && (p2.target = s2), 34962 === s2 && (p2.byteStride = e2.itemSize * a2), this.byteOffset += l2, o2.bufferViews.push(p2), { id: o2.bufferViews.length - 1, byteLength: 0 };
    }
    processBufferViewImage(e2) {
      const t2 = this, n2 = t2.json;
      return n2.bufferViews || (n2.bufferViews = []), new Promise(function(r2) {
        const i2 = new FileReader();
        i2.readAsArrayBuffer(e2), i2.onloadend = function() {
          const e3 = yy(i2.result), s2 = { buffer: t2.processBuffer(e3), byteOffset: t2.byteOffset, byteLength: e3.byteLength };
          t2.byteOffset += e3.byteLength, r2(n2.bufferViews.push(s2) - 1);
        };
      });
    }
    processBufferViewImageBuffer(e2) {
      const t2 = this, n2 = t2.json;
      n2.bufferViews || (n2.bufferViews = []), e2 = yy(e2);
      const r2 = { buffer: t2.processBuffer(e2), byteOffset: t2.byteOffset, byteLength: e2.byteLength };
      return t2.byteOffset += e2.byteLength, n2.bufferViews.push(r2) - 1;
    }
    processAccessor(e2, t2, r2, i2) {
      const s2 = this.json;
      let o2;
      if (e2.array.constructor === Float32Array)
        o2 = 5126;
      else if (e2.array.constructor === Int32Array)
        o2 = 5124;
      else if (e2.array.constructor === Uint32Array)
        o2 = 5125;
      else if (e2.array.constructor === Int16Array)
        o2 = py;
      else if (e2.array.constructor === Uint16Array)
        o2 = dy;
      else if (e2.array.constructor === Int8Array)
        o2 = cy;
      else {
        if (e2.array.constructor !== Uint8Array)
          throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type: " + e2.array.constructor.name);
        o2 = uy;
      }
      if (void 0 === r2 && (r2 = 0), void 0 === i2 && (i2 = e2.count), 0 === i2)
        return null;
      const a2 = function(e3, t3, r3) {
        const i3 = { min: new Array(e3.itemSize).fill(Number.POSITIVE_INFINITY), max: new Array(e3.itemSize).fill(Number.NEGATIVE_INFINITY) };
        for (let s3 = t3; s3 < t3 + r3; s3++)
          for (let t4 = 0; t4 < e3.itemSize; t4++) {
            let r4;
            e3.itemSize > 4 ? r4 = e3.array[s3 * e3.itemSize + t4] : (0 === t4 ? r4 = e3.getX(s3) : 1 === t4 ? r4 = e3.getY(s3) : 2 === t4 ? r4 = e3.getZ(s3) : 3 === t4 && (r4 = e3.getW(s3)), true === e3.normalized && (r4 = n.M8C.normalize(r4, e3.array))), i3.min[t4] = Math.min(i3.min[t4], r4), i3.max[t4] = Math.max(i3.max[t4], r4);
          }
        return i3;
      }(e2, r2, i2);
      let l2;
      void 0 !== t2 && (l2 = e2 === t2.index ? 34963 : 34962);
      const c2 = this.processBufferView(e2, o2, r2, i2, l2), u2 = { bufferView: c2.id, byteOffset: c2.byteOffset, componentType: o2, count: i2, max: a2.max, min: a2.min, type: { 1: "SCALAR", 2: "VEC2", 3: "VEC3", 4: "VEC4", 9: "MAT3", 16: "MAT4" }[e2.itemSize] };
      return true === e2.normalized && (u2.normalized = true), s2.accessors || (s2.accessors = []), s2.accessors.push(u2) - 1;
    }
    processImage(e2, t2, r2, i2 = "image/png", s2 = void 0, o2 = void 0) {
      if (null !== e2) {
        const a2 = this, l2 = a2.cache, c2 = a2.json, u2 = a2.options, p2 = a2.pending;
        l2.images.has(e2) || l2.images.set(e2, {});
        const d2 = l2.images.get(e2), h2 = i2 + ":flipY/" + r2.toString() + (s2 || o2 ? ";" + s2 + ";" + o2 : "");
        if (void 0 !== d2[h2])
          return d2[h2];
        c2.images || (c2.images = []);
        const f2 = { mimeType: i2 }, m2 = by();
        m2.width = Math.min(s2 || e2.width, u2.maxTextureSize), m2.height = Math.min(o2 || e2.height, u2.maxTextureSize);
        const _2 = m2.getContext("2d");
        if (true === r2 && (_2.translate(0, m2.height), _2.scale(1, -1)), void 0 !== e2.data) {
          t2 !== n.wk1 && console.error("GLTFExporter: Only RGBAFormat is supported.", t2), (e2.width > u2.maxTextureSize || e2.height > u2.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", e2);
          const r3 = new Uint8ClampedArray(e2.height * e2.width * 4);
          for (let t3 = 0; t3 < r3.length; t3 += 4)
            r3[t3 + 0] = e2.data[t3 + 0], r3[t3 + 1] = e2.data[t3 + 1], r3[t3 + 2] = e2.data[t3 + 2], r3[t3 + 3] = e2.data[t3 + 3];
          _2.putImageData(new ImageData(r3, e2.width, e2.height), 0, 0);
        } else
          _2.drawImage(e2, 0, 0, m2.width, m2.height);
        true === u2.binary ? p2.push(wy(m2, i2).then((e3) => a2.processBufferViewImage(e3)).then((e3) => {
          f2.bufferView = e3;
        })) : void 0 !== m2.toDataURL ? f2.uri = m2.toDataURL(i2) : p2.push(wy(m2, i2).then((e3) => new FileReader().readAsDataURL(e3)).then((e3) => {
          f2.uri = e3;
        }));
        const g2 = c2.images.push(f2) - 1;
        return d2[h2] = g2, g2;
      }
      throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.");
    }
    processSampler(e2) {
      const t2 = this.json;
      t2.samplers || (t2.samplers = []);
      const n2 = { magFilter: fy[e2.magFilter], minFilter: fy[e2.minFilter], wrapS: fy[e2.wrapS], wrapT: fy[e2.wrapT] };
      return t2.samplers.push(n2) - 1;
    }
    processTexture(e2) {
      const t2 = this.options, r2 = this.cache, i2 = this.json;
      if (r2.textures.has(e2))
        return r2.textures.get(e2);
      i2.textures || (i2.textures = []), e2 instanceof n.EB7 && (e2 = oy(e2, t2.maxTextureSize));
      let s2 = e2.userData.mimeType;
      "image/webp" === s2 && (s2 = "image/png"), "image/jpg" === s2 && (s2 = "image/jpeg");
      const o2 = { sampler: this.processSampler(e2), source: !s2 || ["image/jpeg", "image/png"].includes(s2) ? this.processImage(e2.image, e2.format, e2.flipY, s2) : null };
      e2.name && (o2.name = e2.name), this._invokeAll(function(t3) {
        t3.writeTexture && t3.writeTexture(e2, o2);
      }), null === o2.source && console.error("GLTFExporter: Unsupported mime type: " + s2 + ". Cannot export texture.", e2);
      const a2 = i2.textures.push(o2) - 1;
      return r2.textures.set(e2, a2), a2;
    }
    processMaterial(e2) {
      const t2 = this.cache, r2 = this.json;
      if (t2.materials.has(e2))
        return t2.materials.get(e2);
      if (e2.isShaderMaterial)
        return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."), null;
      r2.materials || (r2.materials = []);
      const i2 = { pbrMetallicRoughness: {} };
      true !== e2.isMeshStandardMaterial && true !== e2.isMeshBasicMaterial && console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
      const s2 = e2.color.toArray().concat([e2.opacity]);
      if (gy(s2, [1, 1, 1, 1]) || (i2.pbrMetallicRoughness.baseColorFactor = s2), e2.isMeshStandardMaterial ? (i2.pbrMetallicRoughness.metallicFactor = e2.metalness, i2.pbrMetallicRoughness.roughnessFactor = e2.roughness) : (i2.pbrMetallicRoughness.metallicFactor = 0.5, i2.pbrMetallicRoughness.roughnessFactor = 0.5), e2.metalnessMap || e2.roughnessMap) {
        const t3 = this.buildMetalRoughTexture(e2.metalnessMap, e2.roughnessMap), n2 = { index: this.processTexture(t3), channel: t3.channel };
        this.applyTextureTransform(n2, t3), i2.pbrMetallicRoughness.metallicRoughnessTexture = n2;
      }
      if (e2.map) {
        const t3 = { index: this.processTexture(e2.map), texCoord: e2.map.channel };
        this.applyTextureTransform(t3, e2.map), i2.pbrMetallicRoughness.baseColorTexture = t3;
      }
      if (e2.emissive) {
        const t3 = e2.emissive;
        if (Math.max(t3.r, t3.g, t3.b) > 0 && (i2.emissiveFactor = e2.emissive.toArray()), e2.emissiveMap) {
          const t4 = { index: this.processTexture(e2.emissiveMap), texCoord: e2.emissiveMap.channel };
          this.applyTextureTransform(t4, e2.emissiveMap), i2.emissiveTexture = t4;
        }
      }
      if (e2.normalMap) {
        const t3 = { index: this.processTexture(e2.normalMap), texCoord: e2.normalMap.channel };
        e2.normalScale && 1 !== e2.normalScale.x && (t3.scale = e2.normalScale.x), this.applyTextureTransform(t3, e2.normalMap), i2.normalTexture = t3;
      }
      if (e2.aoMap) {
        const t3 = { index: this.processTexture(e2.aoMap), texCoord: e2.aoMap.channel };
        1 !== e2.aoMapIntensity && (t3.strength = e2.aoMapIntensity), this.applyTextureTransform(t3, e2.aoMap), i2.occlusionTexture = t3;
      }
      e2.transparent ? i2.alphaMode = "BLEND" : e2.alphaTest > 0 && (i2.alphaMode = "MASK", i2.alphaCutoff = e2.alphaTest), e2.side === n.ehD && (i2.doubleSided = true), "" !== e2.name && (i2.name = e2.name), this.serializeUserData(e2, i2), this._invokeAll(function(t3) {
        t3.writeMaterial && t3.writeMaterial(e2, i2);
      });
      const o2 = r2.materials.push(i2) - 1;
      return t2.materials.set(e2, o2), o2;
    }
    processMesh(e2) {
      const t2 = this.cache, r2 = this.json, i2 = [e2.geometry.uuid];
      if (Array.isArray(e2.material))
        for (let t3 = 0, n2 = e2.material.length; t3 < n2; t3++)
          i2.push(e2.material[t3].uuid);
      else
        i2.push(e2.material.uuid);
      const s2 = i2.join(":");
      if (t2.meshes.has(s2))
        return t2.meshes.get(s2);
      const o2 = e2.geometry;
      let a2;
      a2 = e2.isLineSegments ? 1 : e2.isLineLoop ? 2 : e2.isLine ? 3 : e2.isPoints ? 0 : e2.material.wireframe ? 1 : 4;
      const l2 = {}, c2 = {}, u2 = [], p2 = [], d2 = { uv: "TEXCOORD_0", uv1: "TEXCOORD_1", color: "COLOR_0", skinWeight: "WEIGHTS_0", skinIndex: "JOINTS_0" }, h2 = o2.getAttribute("normal");
      void 0 === h2 || this.isNormalizedNormalAttribute(h2) || (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), o2.setAttribute("normal", this.createNormalizedNormalAttribute(h2)));
      let f2 = null;
      for (let e3 in o2.attributes) {
        if ("morph" === e3.slice(0, 5))
          continue;
        const r3 = o2.attributes[e3];
        if (e3 = d2[e3] || e3.toUpperCase(), /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(e3) || (e3 = "_" + e3), t2.attributes.has(this.getUID(r3))) {
          c2[e3] = t2.attributes.get(this.getUID(r3));
          continue;
        }
        f2 = null;
        const i3 = r3.array;
        "JOINTS_0" !== e3 || i3 instanceof Uint16Array || i3 instanceof Uint8Array || (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), f2 = new n.TlE(new Uint16Array(i3), r3.itemSize, r3.normalized));
        const s3 = this.processAccessor(f2 || r3, o2);
        null !== s3 && (e3.startsWith("_") || this.detectMeshQuantization(e3, r3), c2[e3] = s3, t2.attributes.set(this.getUID(r3), s3));
      }
      if (void 0 !== h2 && o2.setAttribute("normal", h2), 0 === Object.keys(c2).length)
        return null;
      if (void 0 !== e2.morphTargetInfluences && e2.morphTargetInfluences.length > 0) {
        const n2 = [], r3 = [], i3 = {};
        if (void 0 !== e2.morphTargetDictionary)
          for (const t3 in e2.morphTargetDictionary)
            i3[e2.morphTargetDictionary[t3]] = t3;
        for (let s3 = 0; s3 < e2.morphTargetInfluences.length; ++s3) {
          const a3 = {};
          let l3 = false;
          for (const e3 in o2.morphAttributes) {
            if ("position" !== e3 && "normal" !== e3) {
              l3 || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), l3 = true);
              continue;
            }
            const n3 = o2.morphAttributes[e3][s3], r4 = e3.toUpperCase(), i4 = o2.attributes[e3];
            if (t2.attributes.has(this.getUID(n3, true))) {
              a3[r4] = t2.attributes.get(this.getUID(n3, true));
              continue;
            }
            const c3 = n3.clone();
            if (!o2.morphTargetsRelative)
              for (let e4 = 0, t3 = n3.count; e4 < t3; e4++)
                for (let t4 = 0; t4 < n3.itemSize; t4++)
                  0 === t4 && c3.setX(e4, n3.getX(e4) - i4.getX(e4)), 1 === t4 && c3.setY(e4, n3.getY(e4) - i4.getY(e4)), 2 === t4 && c3.setZ(e4, n3.getZ(e4) - i4.getZ(e4)), 3 === t4 && c3.setW(e4, n3.getW(e4) - i4.getW(e4));
            a3[r4] = this.processAccessor(c3, o2), t2.attributes.set(this.getUID(i4, true), a3[r4]);
          }
          p2.push(a3), n2.push(e2.morphTargetInfluences[s3]), void 0 !== e2.morphTargetDictionary && r3.push(i3[s3]);
        }
        l2.weights = n2, r3.length > 0 && (l2.extras = {}, l2.extras.targetNames = r3);
      }
      const m2 = Array.isArray(e2.material);
      if (m2 && 0 === o2.groups.length)
        return null;
      const _2 = m2 ? e2.material : [e2.material], g2 = m2 ? o2.groups : [{ materialIndex: 0, start: void 0, count: void 0 }];
      for (let e3 = 0, n2 = g2.length; e3 < n2; e3++) {
        const n3 = { mode: a2, attributes: c2 };
        if (this.serializeUserData(o2, n3), p2.length > 0 && (n3.targets = p2), null !== o2.index) {
          let r4 = this.getUID(o2.index);
          void 0 === g2[e3].start && void 0 === g2[e3].count || (r4 += ":" + g2[e3].start + ":" + g2[e3].count), t2.attributes.has(r4) ? n3.indices = t2.attributes.get(r4) : (n3.indices = this.processAccessor(o2.index, o2, g2[e3].start, g2[e3].count), t2.attributes.set(r4, n3.indices)), null === n3.indices && delete n3.indices;
        }
        const r3 = this.processMaterial(_2[g2[e3].materialIndex]);
        null !== r3 && (n3.material = r3), u2.push(n3);
      }
      l2.primitives = u2, r2.meshes || (r2.meshes = []), this._invokeAll(function(t3) {
        t3.writeMesh && t3.writeMesh(e2, l2);
      });
      const v2 = r2.meshes.push(l2) - 1;
      return t2.meshes.set(s2, v2), v2;
    }
    detectMeshQuantization(e2, t2) {
      if (this.extensionsUsed[hy])
        return;
      let n2;
      switch (t2.array.constructor) {
        case Int8Array:
          n2 = "byte";
          break;
        case Uint8Array:
          n2 = "unsigned byte";
          break;
        case Int16Array:
          n2 = "short";
          break;
        case Uint16Array:
          n2 = "unsigned short";
          break;
        default:
          return;
      }
      t2.normalized && (n2 += " normalized");
      const r2 = e2.split("_", 1)[0];
      ay[r2] && ay[r2].includes(n2) && (this.extensionsUsed[hy] = true, this.extensionsRequired[hy] = true);
    }
    processCamera(e2) {
      const t2 = this.json;
      t2.cameras || (t2.cameras = []);
      const r2 = e2.isOrthographicCamera, i2 = { type: r2 ? "orthographic" : "perspective" };
      return r2 ? i2.orthographic = { xmag: 2 * e2.right, ymag: 2 * e2.top, zfar: e2.far <= 0 ? 1e-3 : e2.far, znear: e2.near < 0 ? 0 : e2.near } : i2.perspective = { aspectRatio: e2.aspect, yfov: n.M8C.degToRad(e2.fov), zfar: e2.far <= 0 ? 1e-3 : e2.far, znear: e2.near < 0 ? 0 : e2.near }, "" !== e2.name && (i2.name = e2.type), t2.cameras.push(i2) - 1;
    }
    processAnimation(e2, t2) {
      const r2 = this.json, i2 = this.nodeMap;
      r2.animations || (r2.animations = []);
      const s2 = (e2 = ly.Utils.mergeMorphTargetTracks(e2.clone(), t2)).tracks, o2 = [], a2 = [];
      for (let e3 = 0; e3 < s2.length; ++e3) {
        const r3 = s2[e3], l2 = n.iUV.parseTrackName(r3.name);
        let c2 = n.iUV.findNode(t2, l2.nodeName);
        const u2 = my[l2.propertyName];
        if ("bones" === l2.objectName && (c2 = true === c2.isSkinnedMesh ? c2.skeleton.getBoneByName(l2.objectIndex) : void 0), !c2 || !u2)
          return console.warn('THREE.GLTFExporter: Could not export animation track "%s".', r3.name), null;
        const p2 = 1;
        let d2, h2 = r3.values.length / r3.times.length;
        u2 === my.morphTargetInfluences && (h2 /= c2.morphTargetInfluences.length), true === r3.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ? (d2 = "CUBICSPLINE", h2 /= 3) : d2 = r3.getInterpolation() === n.Syv ? "STEP" : "LINEAR", a2.push({ input: this.processAccessor(new n.TlE(r3.times, p2)), output: this.processAccessor(new n.TlE(r3.values, h2)), interpolation: d2 }), o2.push({ sampler: a2.length - 1, target: { node: i2.get(c2), path: u2 } });
      }
      return r2.animations.push({ name: e2.name || "clip_" + r2.animations.length, samplers: a2, channels: o2 }), r2.animations.length - 1;
    }
    processSkin(e2) {
      const t2 = this.json, r2 = this.nodeMap, i2 = t2.nodes[r2.get(e2)], s2 = e2.skeleton;
      if (void 0 === s2)
        return null;
      const o2 = e2.skeleton.bones[0];
      if (void 0 === o2)
        return null;
      const a2 = [], l2 = new Float32Array(16 * s2.bones.length), c2 = new n.yGw();
      for (let t3 = 0; t3 < s2.bones.length; ++t3)
        a2.push(r2.get(s2.bones[t3])), c2.copy(s2.boneInverses[t3]), c2.multiply(e2.bindMatrix).toArray(l2, 16 * t3);
      return void 0 === t2.skins && (t2.skins = []), t2.skins.push({ inverseBindMatrices: this.processAccessor(new n.TlE(l2, 16)), joints: a2, skeleton: r2.get(o2) }), i2.skin = t2.skins.length - 1;
    }
    processNode(e2) {
      const t2 = this.json, n2 = this.options, r2 = this.nodeMap;
      t2.nodes || (t2.nodes = []);
      const i2 = {};
      if (n2.trs) {
        const t3 = e2.quaternion.toArray(), n3 = e2.position.toArray(), r3 = e2.scale.toArray();
        gy(t3, [0, 0, 0, 1]) || (i2.rotation = t3), gy(n3, [0, 0, 0]) || (i2.translation = n3), gy(r3, [1, 1, 1]) || (i2.scale = r3);
      } else
        e2.matrixAutoUpdate && e2.updateMatrix(), false === gy(e2.matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) && (i2.matrix = e2.matrix.elements);
      if ("" !== e2.name && (i2.name = String(e2.name)), this.serializeUserData(e2, i2), e2.isMesh || e2.isLine || e2.isPoints) {
        const t3 = this.processMesh(e2);
        null !== t3 && (i2.mesh = t3);
      } else
        e2.isCamera && (i2.camera = this.processCamera(e2));
      if (e2.isSkinnedMesh && this.skins.push(e2), e2.children.length > 0) {
        const t3 = [];
        for (let r3 = 0, i3 = e2.children.length; r3 < i3; r3++) {
          const i4 = e2.children[r3];
          if (i4.visible || false === n2.onlyVisible) {
            const e3 = this.processNode(i4);
            null !== e3 && t3.push(e3);
          }
        }
        t3.length > 0 && (i2.children = t3);
      }
      this._invokeAll(function(t3) {
        t3.writeNode && t3.writeNode(e2, i2);
      });
      const s2 = t2.nodes.push(i2) - 1;
      return r2.set(e2, s2), s2;
    }
    processScene(e2) {
      const t2 = this.json, n2 = this.options;
      t2.scenes || (t2.scenes = [], t2.scene = 0);
      const r2 = {};
      "" !== e2.name && (r2.name = e2.name), t2.scenes.push(r2);
      const i2 = [];
      for (let t3 = 0, r3 = e2.children.length; t3 < r3; t3++) {
        const r4 = e2.children[t3];
        if (r4.visible || false === n2.onlyVisible) {
          const e3 = this.processNode(r4);
          null !== e3 && i2.push(e3);
        }
      }
      i2.length > 0 && (r2.nodes = i2), this.serializeUserData(e2, r2);
    }
    processObjects(e2) {
      const t2 = new n.xsS();
      t2.name = "AuxScene";
      for (let n2 = 0; n2 < e2.length; n2++)
        t2.children.push(e2[n2]);
      this.processScene(t2);
    }
    processInput(e2) {
      const t2 = this.options;
      e2 = e2 instanceof Array ? e2 : [e2], this._invokeAll(function(t3) {
        t3.beforeParse && t3.beforeParse(e2);
      });
      const r2 = [];
      for (let t3 = 0; t3 < e2.length; t3++)
        e2[t3] instanceof n.xsS ? this.processScene(e2[t3]) : r2.push(e2[t3]);
      r2.length > 0 && this.processObjects(r2);
      for (let e3 = 0; e3 < this.skins.length; ++e3)
        this.processSkin(this.skins[e3]);
      for (let n2 = 0; n2 < t2.animations.length; ++n2)
        this.processAnimation(t2.animations[n2], e2[0]);
      this._invokeAll(function(t3) {
        t3.afterParse && t3.afterParse(e2);
      });
    }
    _invokeAll(e2) {
      for (let t2 = 0, n2 = this.plugins.length; t2 < n2; t2++)
        e2(this.plugins[t2]);
    }
  }
  class xy {
    constructor(e2) {
      this.writer = e2, this.name = "KHR_lights_punctual";
    }
    writeNode(e2, t2) {
      if (!e2.isLight)
        return;
      if (!e2.isDirectionalLight && !e2.isPointLight && !e2.isSpotLight)
        return void console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", e2);
      const n2 = this.writer, r2 = n2.json, i2 = n2.extensionsUsed, s2 = {};
      e2.name && (s2.name = e2.name), s2.color = e2.color.toArray(), s2.intensity = e2.intensity, e2.isDirectionalLight ? s2.type = "directional" : e2.isPointLight ? (s2.type = "point", e2.distance > 0 && (s2.range = e2.distance)) : e2.isSpotLight && (s2.type = "spot", e2.distance > 0 && (s2.range = e2.distance), s2.spot = {}, s2.spot.innerConeAngle = (e2.penumbra - 1) * e2.angle * -1, s2.spot.outerConeAngle = e2.angle), void 0 !== e2.decay && 2 !== e2.decay && console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."), !e2.target || e2.target.parent === e2 && 0 === e2.target.position.x && 0 === e2.target.position.y && -1 === e2.target.position.z || console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."), i2[this.name] || (r2.extensions = r2.extensions || {}, r2.extensions[this.name] = { lights: [] }, i2[this.name] = true);
      const o2 = r2.extensions[this.name].lights;
      o2.push(s2), t2.extensions = t2.extensions || {}, t2.extensions[this.name] = { light: o2.length - 1 };
    }
  }
  class Ey {
    constructor(e2) {
      this.writer = e2, this.name = "KHR_materials_unlit";
    }
    writeMaterial(e2, t2) {
      if (!e2.isMeshBasicMaterial)
        return;
      const n2 = this.writer.extensionsUsed;
      t2.extensions = t2.extensions || {}, t2.extensions[this.name] = {}, n2[this.name] = true, t2.pbrMetallicRoughness.metallicFactor = 0, t2.pbrMetallicRoughness.roughnessFactor = 0.9;
    }
  }
  class Cy {
    constructor(e2) {
      this.writer = e2, this.name = "KHR_materials_clearcoat";
    }
    writeMaterial(e2, t2) {
      if (!e2.isMeshPhysicalMaterial || 0 === e2.clearcoat)
        return;
      const n2 = this.writer, r2 = n2.extensionsUsed, i2 = {};
      if (i2.clearcoatFactor = e2.clearcoat, e2.clearcoatMap) {
        const t3 = { index: n2.processTexture(e2.clearcoatMap), texCoord: e2.clearcoatMap.channel };
        n2.applyTextureTransform(t3, e2.clearcoatMap), i2.clearcoatTexture = t3;
      }
      if (i2.clearcoatRoughnessFactor = e2.clearcoatRoughness, e2.clearcoatRoughnessMap) {
        const t3 = { index: n2.processTexture(e2.clearcoatRoughnessMap), texCoord: e2.clearcoatRoughnessMap.channel };
        n2.applyTextureTransform(t3, e2.clearcoatRoughnessMap), i2.clearcoatRoughnessTexture = t3;
      }
      if (e2.clearcoatNormalMap) {
        const t3 = { index: n2.processTexture(e2.clearcoatNormalMap), texCoord: e2.clearcoatNormalMap.channel };
        n2.applyTextureTransform(t3, e2.clearcoatNormalMap), i2.clearcoatNormalTexture = t3;
      }
      t2.extensions = t2.extensions || {}, t2.extensions[this.name] = i2, r2[this.name] = true;
    }
  }
  class Sy {
    constructor(e2) {
      this.writer = e2, this.name = "KHR_materials_iridescence";
    }
    writeMaterial(e2, t2) {
      if (!e2.isMeshPhysicalMaterial || 0 === e2.iridescence)
        return;
      const n2 = this.writer, r2 = n2.extensionsUsed, i2 = {};
      if (i2.iridescenceFactor = e2.iridescence, e2.iridescenceMap) {
        const t3 = { index: n2.processTexture(e2.iridescenceMap), texCoord: e2.iridescenceMap.channel };
        n2.applyTextureTransform(t3, e2.iridescenceMap), i2.iridescenceTexture = t3;
      }
      if (i2.iridescenceIor = e2.iridescenceIOR, i2.iridescenceThicknessMinimum = e2.iridescenceThicknessRange[0], i2.iridescenceThicknessMaximum = e2.iridescenceThicknessRange[1], e2.iridescenceThicknessMap) {
        const t3 = { index: n2.processTexture(e2.iridescenceThicknessMap), texCoord: e2.iridescenceThicknessMap.channel };
        n2.applyTextureTransform(t3, e2.iridescenceThicknessMap), i2.iridescenceThicknessTexture = t3;
      }
      t2.extensions = t2.extensions || {}, t2.extensions[this.name] = i2, r2[this.name] = true;
    }
  }
  class My {
    constructor(e2) {
      this.writer = e2, this.name = "KHR_materials_transmission";
    }
    writeMaterial(e2, t2) {
      if (!e2.isMeshPhysicalMaterial || 0 === e2.transmission)
        return;
      const n2 = this.writer, r2 = n2.extensionsUsed, i2 = {};
      if (i2.transmissionFactor = e2.transmission, e2.transmissionMap) {
        const t3 = { index: n2.processTexture(e2.transmissionMap), texCoord: e2.transmissionMap.channel };
        n2.applyTextureTransform(t3, e2.transmissionMap), i2.transmissionTexture = t3;
      }
      t2.extensions = t2.extensions || {}, t2.extensions[this.name] = i2, r2[this.name] = true;
    }
  }
  class Ty {
    constructor(e2) {
      this.writer = e2, this.name = "KHR_materials_volume";
    }
    writeMaterial(e2, t2) {
      if (!e2.isMeshPhysicalMaterial || 0 === e2.transmission)
        return;
      const n2 = this.writer, r2 = n2.extensionsUsed, i2 = {};
      if (i2.thicknessFactor = e2.thickness, e2.thicknessMap) {
        const t3 = { index: n2.processTexture(e2.thicknessMap), texCoord: e2.thicknessMap.channel };
        n2.applyTextureTransform(t3, e2.thicknessMap), i2.thicknessTexture = t3;
      }
      i2.attenuationDistance = e2.attenuationDistance, i2.attenuationColor = e2.attenuationColor.toArray(), t2.extensions = t2.extensions || {}, t2.extensions[this.name] = i2, r2[this.name] = true;
    }
  }
  class Py {
    constructor(e2) {
      this.writer = e2, this.name = "KHR_materials_ior";
    }
    writeMaterial(e2, t2) {
      if (!e2.isMeshPhysicalMaterial || 1.5 === e2.ior)
        return;
      const n2 = this.writer.extensionsUsed, r2 = {};
      r2.ior = e2.ior, t2.extensions = t2.extensions || {}, t2.extensions[this.name] = r2, n2[this.name] = true;
    }
  }
  class Iy {
    constructor(e2) {
      this.writer = e2, this.name = "KHR_materials_specular";
    }
    writeMaterial(e2, t2) {
      if (!e2.isMeshPhysicalMaterial || 1 === e2.specularIntensity && e2.specularColor.equals(_y) && !e2.specularIntensityMap && !e2.specularColorTexture)
        return;
      const n2 = this.writer, r2 = n2.extensionsUsed, i2 = {};
      if (e2.specularIntensityMap) {
        const t3 = { index: n2.processTexture(e2.specularIntensityMap), texCoord: e2.specularIntensityMap.channel };
        n2.applyTextureTransform(t3, e2.specularIntensityMap), i2.specularTexture = t3;
      }
      if (e2.specularColorMap) {
        const t3 = { index: n2.processTexture(e2.specularColorMap), texCoord: e2.specularColorMap.channel };
        n2.applyTextureTransform(t3, e2.specularColorMap), i2.specularColorTexture = t3;
      }
      i2.specularFactor = e2.specularIntensity, i2.specularColorFactor = e2.specularColor.toArray(), t2.extensions = t2.extensions || {}, t2.extensions[this.name] = i2, r2[this.name] = true;
    }
  }
  class Ry {
    constructor(e2) {
      this.writer = e2, this.name = "KHR_materials_sheen";
    }
    writeMaterial(e2, t2) {
      if (!e2.isMeshPhysicalMaterial || e2.sheen < 1e-3)
        return;
      const n2 = this.writer, r2 = n2.extensionsUsed, i2 = {};
      if (e2.sheenRoughnessMap) {
        const t3 = { index: n2.processTexture(e2.sheenRoughnessMap), texCoord: e2.sheenRoughnessMap.channel };
        n2.applyTextureTransform(t3, e2.sheenRoughnessMap), i2.sheenRoughnessTexture = t3;
      }
      if (e2.sheenColorMap) {
        const t3 = { index: n2.processTexture(e2.sheenColorMap), texCoord: e2.sheenColorMap.channel };
        n2.applyTextureTransform(t3, e2.sheenColorMap), i2.sheenColorTexture = t3;
      }
      i2.sheenRoughnessFactor = e2.sheenRoughness, i2.sheenColorFactor = e2.sheenColor.toArray(), t2.extensions = t2.extensions || {}, t2.extensions[this.name] = i2, t2.extras = t2.extras || {}, t2.extras.sheenFactor = e2.sheen, r2[this.name] = true;
    }
  }
  class ky {
    constructor(e2) {
      this.writer = e2, this.name = "KHR_materials_anisotropy";
    }
    writeMaterial(e2, t2) {
      if (!e2.isMeshPhysicalMaterial || 0 == e2.anisotropy)
        return;
      const n2 = this.writer, r2 = n2.extensionsUsed, i2 = {};
      if (e2.anisotropyMap) {
        const t3 = { index: n2.processTexture(e2.anisotropyMap) };
        n2.applyTextureTransform(t3, e2.anisotropyMap), i2.anisotropyTexture = t3;
      }
      i2.anisotropyStrength = e2.anisotropy, i2.anisotropyRotation = e2.anisotropyRotation, t2.extensions = t2.extensions || {}, t2.extensions[this.name] = i2, r2[this.name] = true;
    }
  }
  class Dy {
    constructor(e2) {
      this.writer = e2, this.name = "KHR_materials_emissive_strength";
    }
    writeMaterial(e2, t2) {
      if (!e2.isMeshStandardMaterial || 1 === e2.emissiveIntensity)
        return;
      const n2 = this.writer.extensionsUsed, r2 = {};
      r2.emissiveStrength = e2.emissiveIntensity, t2.extensions = t2.extensions || {}, t2.extensions[this.name] = r2, n2[this.name] = true;
    }
  }
  ly.Utils = { GLTFWriter: Ay, insertKeyframe: function(e2, t2) {
    const n2 = 1e-3, r2 = e2.getValueSize(), i2 = new e2.TimeBufferType(e2.times.length + 1), s2 = new e2.ValueBufferType(e2.values.length + r2), o2 = e2.createInterpolant(new e2.ValueBufferType(r2));
    let a2;
    if (0 === e2.times.length) {
      i2[0] = t2;
      for (let e3 = 0; e3 < r2; e3++)
        s2[e3] = 0;
      a2 = 0;
    } else if (t2 < e2.times[0]) {
      if (Math.abs(e2.times[0] - t2) < n2)
        return 0;
      i2[0] = t2, i2.set(e2.times, 1), s2.set(o2.evaluate(t2), 0), s2.set(e2.values, r2), a2 = 0;
    } else if (t2 > e2.times[e2.times.length - 1]) {
      if (Math.abs(e2.times[e2.times.length - 1] - t2) < n2)
        return e2.times.length - 1;
      i2[i2.length - 1] = t2, i2.set(e2.times, 0), s2.set(e2.values, 0), s2.set(o2.evaluate(t2), e2.values.length), a2 = i2.length - 1;
    } else
      for (let l2 = 0; l2 < e2.times.length; l2++) {
        if (Math.abs(e2.times[l2] - t2) < n2)
          return l2;
        if (e2.times[l2] < t2 && e2.times[l2 + 1] > t2) {
          i2.set(e2.times.slice(0, l2 + 1), 0), i2[l2 + 1] = t2, i2.set(e2.times.slice(l2 + 1), l2 + 2), s2.set(e2.values.slice(0, (l2 + 1) * r2), 0), s2.set(o2.evaluate(t2), (l2 + 1) * r2), s2.set(e2.values.slice((l2 + 1) * r2), (l2 + 2) * r2), a2 = l2 + 1;
          break;
        }
      }
    return e2.times = i2, e2.values = s2, a2;
  }, mergeMorphTargetTracks: function(e2, t2) {
    const r2 = [], i2 = {}, s2 = e2.tracks;
    for (let e3 = 0; e3 < s2.length; ++e3) {
      let o2 = s2[e3];
      const a2 = n.iUV.parseTrackName(o2.name), l2 = n.iUV.findNode(t2, a2.nodeName);
      if ("morphTargetInfluences" !== a2.propertyName || void 0 === a2.propertyIndex) {
        r2.push(o2);
        continue;
      }
      if (o2.createInterpolant !== o2.InterpolantFactoryMethodDiscrete && o2.createInterpolant !== o2.InterpolantFactoryMethodLinear) {
        if (o2.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)
          throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
        console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), o2 = o2.clone(), o2.setInterpolation(n.NMF);
      }
      const c2 = l2.morphTargetInfluences.length, u2 = l2.morphTargetDictionary[a2.propertyIndex];
      if (void 0 === u2)
        throw new Error("THREE.GLTFExporter: Morph target name not found: " + a2.propertyIndex);
      let p2;
      if (void 0 === i2[l2.uuid]) {
        p2 = o2.clone();
        const e4 = new p2.ValueBufferType(c2 * p2.times.length);
        for (let t3 = 0; t3 < p2.times.length; t3++)
          e4[t3 * c2 + u2] = p2.values[t3];
        p2.name = (a2.nodeName || "") + ".morphTargetInfluences", p2.values = e4, i2[l2.uuid] = p2, r2.push(p2);
        continue;
      }
      const d2 = o2.createInterpolant(new o2.ValueBufferType(1));
      p2 = i2[l2.uuid];
      for (let e4 = 0; e4 < p2.times.length; e4++)
        p2.values[e4 * c2 + u2] = d2.evaluate(p2.times[e4]);
      for (let e4 = 0; e4 < o2.times.length; e4++) {
        const t3 = this.insertKeyframe(p2, o2.times[e4]);
        p2.values[t3 * c2 + u2] = o2.values[e4];
      }
    }
    return e2.tracks = r2, e2;
  } };
  class By extends ly.Utils.GLTFWriter {
    constructor() {
      super(...arguments), this._defaultMaterial = new n.Wid();
    }
    serializeUserData(e2, t2) {
      const n2 = e2.userData, r2 = {};
      n2.__disposed && console.error("Serializing a disposed object", e2), Object.entries(n2).forEach(([e3, t3]) => {
        (!t3 || "function" == typeof t3 || t3.isObject3D || t3.isTexture || t3.isMaterial || null != t3.assetType || e3.startsWith("_") || "uuid" !== e3 && (Ae.includes(e3) || xe.includes(e3) || Y.includes(e3))) && (r2[e3] = t3, delete n2[e3]);
      });
      const i2 = le(n2, false);
      Object.entries(r2).forEach(([e3, t3]) => {
        n2[e3] = t3, delete r2[e3];
      }), e2.userData = i2, super.serializeUserData(e2, t2), e2.userData = n2;
    }
    processObjects(e2) {
      var t2;
      1 === e2.length && (null === (t2 = e2[0]) || void 0 === t2 ? void 0 : t2.userData.rootSceneModelRoot) ? this.processScene(e2[0]) : super.processObjects(e2);
    }
    processMaterial(e2) {
      if (this.cache.materials.has(e2))
        return this.cache.materials.get(e2);
      let t2 = e2;
      t2 && !t2.isShaderMaterial || (t2 = this._defaultMaterial);
      const n2 = super.processMaterial(t2);
      if (null === n2)
        return console.error("GLTFWriter2: Unexpected error: Failed to process material", e2), null;
      if (!e2 || t2 === e2)
        return n2;
      const r2 = JSON.stringify(this.json.materials[n2]), i2 = JSON.parse(r2);
      this.serializeUserData(e2, i2), this._invokeAll((t3) => {
        t3.writeMaterial && t3.writeMaterial(e2, i2);
      });
      const s2 = this.json.materials.push(i2) - 1;
      return this.cache.materials.set(e2, s2), s2;
    }
    processImageBlob(e2, n2) {
      if (!e2)
        return -1;
      const r2 = this.cache, i2 = this.options, s2 = this.pending, o2 = this.json, a2 = n2.image;
      r2.images.has(a2) || r2.images.set(a2, {});
      const l2 = r2.images.get(a2), c2 = e2.type + ":flipY/" + n2.flipY.toString();
      if (void 0 !== l2[c2])
        return l2[c2];
      o2.images || (o2.images = []);
      const u2 = { mimeType: e2.type };
      true === i2.binary ? s2.push(new Promise((t2) => {
        this.processBufferViewImage(e2).then((e3) => {
          u2.bufferView = e3, t2();
        });
      })) : s2.push((0, t.blobToDataURL)(e2).then((e3) => {
        u2.uri = e3;
      }));
      const p2 = o2.images.push(u2) - 1;
      return l2[c2] = p2, p2;
    }
    processSampler(e2) {
      return super.processSampler(e2);
    }
    processTexture(e2) {
      const t2 = this.cache, n2 = this.json;
      if (t2.textures.has(e2))
        return t2.textures.get(e2);
      const r2 = e2.source.data, i2 = e2.userData.mimeType;
      e2.userData.rootPath && !this.options.embedUrlImages && (e2.userData.rootPath.startsWith("http") || e2.userData.rootPath.startsWith("data:")) && (e2.source.data && (!this.options.exporterOptions.embedUrlImagePreviews || e2.isDataTexture ? e2.source.data = null : e2.source.data._savePreview = true), delete e2.userData.mimeType);
      const s2 = super.processTexture(e2), o2 = n2.textures[s2];
      if (!o2)
        return console.error("No texture def", s2, e2), s2;
      const a2 = n2.images ? n2.images[o2.source] : null;
      if (a2 && (a2.extras || (a2.extras = {}), e2.source && (a2.extras.uuid = e2.source.uuid), a2.extras.t_uuid = e2.uuid), e2.userData.rootPath && !this.options.embedUrlImages && (e2.userData.rootPath.startsWith("http") || e2.userData.rootPath.startsWith("data:"))) {
        if (e2.source.data ? delete e2.source.data._savePreview : e2.source.data = r2, e2.userData.mimeType = i2, !o2)
          return console.error("textureDef is null", s2, e2), s2;
        if (o2.source >= 0) {
          const t3 = this.json.images[o2.source];
          t3.uri ? console.warn("GLTFWriter2: uri already set", t3.uri) : (t3.uri = e2.userData.rootPath, t3.mimeType = i2, t3.extras || (t3.extras = {}), t3.extras.flipY = e2.flipY, t3.extras.uri = e2.userData.rootPath);
        } else
          o2.source = this.processImageUri(e2.image, e2.userData.rootPath, e2.flipY, i2);
      }
      return o2.source < 0 && console.error("textureDef.source cannot be saved", o2, e2), s2;
    }
    processImage(e2, t2, n2, r2 = "image/png") {
      return e2 ? super.processImage(e2, t2, n2, r2, e2._savePreview ? 32 : void 0, e2._savePreview ? 32 : void 0) : -1;
    }
    processImageUri(e2, t2, n2, r2 = "image/png") {
      const i2 = this.cache, s2 = this.json;
      i2.images.has(e2) || i2.images.set(e2, {});
      const o2 = i2.images.get(e2), a2 = r2 + ":flipY/" + n2.toString();
      if (void 0 !== o2[a2])
        return o2[a2];
      s2.images || (s2.images = []);
      const l2 = { mimeType: r2, uri: t2, extras: { flipY: n2 } }, c2 = s2.images.push(l2) - 1;
      return o2[a2] = c2, c2;
    }
  }
  function Oy(e2, t2) {
    (t2 = null != t2 ? t2 : document.createElement("script")).type = e2.type || "text/javascript", t2.text = e2.text;
    for (let n2 = 0; n2 < e2.attributes.length; n2++) {
      const r2 = e2.attributes[n2];
      t2.setAttribute(r2.name, r2.value);
    }
    return t2;
  }
  function Ly(e2, t2 = 0) {
    const n2 = (r2 = e2.byteLength, 4 * Math.ceil(r2 / 4));
    var r2;
    if (n2 !== e2.byteLength) {
      const r3 = new Uint8Array(n2);
      if (r3.set(new Uint8Array(e2)), 0 !== t2)
        for (let i2 = e2.byteLength; i2 < n2; i2++)
          r3[i2] = t2;
      return r3.buffer;
    }
    return e2;
  }
  ArrayBuffer.prototype.slice || (ArrayBuffer.prototype.slice = function(e2, t2) {
    const n2 = new Uint8Array(this);
    null == t2 && (t2 = n2.length);
    const r2 = new ArrayBuffer(t2 - e2), i2 = new Uint8Array(r2);
    for (let t3 = 0; t3 < i2.length; t3++)
      i2[t3] = n2[t3 + e2];
    return r2;
  });
  class Uy extends ly {
    register(e2) {
      return super.register(e2);
    }
    async parseAsync(e2, n2) {
      var r2;
      if (!e2)
        throw new Error("No object to export");
      const i2 = e2.__isGLTFOutput || !Array.isArray(e2) && !e2.isObject3D ? e2 : await new Promise((t2, r3) => this.parse(e2, t2, r3, n2));
      if (i2 && "object" == typeof i2 && !i2.byteLength)
        return new Blob([JSON.stringify(i2, (e3, t2) => e3.startsWith("__") ? void 0 : t2, null !== (r2 = n2.jsonSpaces) && void 0 !== r2 ? r2 : 2)], { type: "model/gltf+json" });
      if (i2) {
        let e3 = null;
        return n2.encrypt && (!n2.encryptKey && window.prompt && (n2.encryptKey = window.prompt("GLTFEncryption: Enter encryption key") || ""), n2.encryptKey ? e3 = function(e4, t2) {
          const n3 = Ly(e4), r3 = new DataView(new ArrayBuffer(8));
          r3.setUint32(0, n3.byteLength, true), r3.setUint32(4, 5130562, true);
          const i3 = Ly(new TextEncoder().encode(JSON.stringify({ asset: { version: "2.0", generator: "WebGiGLBWrapper", encryption: { type: "aesgcm", version: 1 } } })).buffer, 32), s2 = new DataView(new ArrayBuffer(8));
          s2.setUint32(0, i3.byteLength, true), s2.setUint32(4, 1313821514, true);
          const o2 = new ArrayBuffer(12), a2 = new DataView(o2);
          a2.setUint32(0, 1179937895, true), a2.setUint32(4, 2, true);
          const l2 = 12 + s2.byteLength + i3.byteLength + r3.byteLength + n3.byteLength;
          a2.setUint32(8, l2, true);
          const c2 = new Blob([o2, s2, i3, r3, n3], { type: "application/octet-stream" });
          return c2.ext = "glb", c2;
        }(await (0, t.aesGcmEncrypt)(new Uint8Array(i2), n2.encryptKey)) : console.warn("WebGi GLTF Export: encryption key not provided, skipping encryption")), e3 || (e3 = new Blob([i2], { type: "model/gltf+binary" })), e3;
      }
      throw new Error("GLTFExporter2.parse() failed");
    }
    parse(e2, t2, n2, r2 = {}) {
      var i2;
      const s2 = { binary: false, trs: false, onlyVisible: true, truncateDrawRange: true, externalImagesInExtras: !r2.embedUrlImages && r2.externalImagesInExtras || false, embedUrlImages: null !== (i2 = r2.embedUrlImages) && void 0 !== i2 && i2, maxTextureSize: 1 / 0, animations: [], includeCustomExtensions: true, exporterOptions: r2 };
      return "glb" === r2.exportExt && (s2.binary = true), false !== r2.preserveUUIDs && (Array.isArray(e2) ? e2 : [e2]).forEach((e3) => e3.traverse((e4) => {
        e4.uuid && (e4.userData.gltfUUID = e4.uuid);
      })), (Array.isArray(e2) ? e2 : [e2]).forEach((e3) => e3.traverse((e4) => {
        if (e4.animations)
          for (const t3 of e4.animations)
            false === t3.__gltfExport || s2.animations.includes(t3) || s2.animations.push(...e4.animations);
      })), super.parse(e2, (n3) => {
        false !== r2.preserveUUIDs && (Array.isArray(e2) ? e2 : [e2]).forEach((e3) => e3.traverse((e4) => {
          delete e4.userData.gltfUUID;
        })), t2(Object.assign(n3, { __isGLTFOutput: true }));
      }, n2, s2, new By());
    }
  }
  function Fy(e2, t2) {
    const r2 = e2.getPlugin(Ls).exportViewerConfig();
    t2.json.textures && t2.json.samplers && t2.json.images && r2.resources.textures && [...Object.entries(r2.resources.textures)].forEach(([e3, n2]) => {
      const i3 = t2.json.textures.find((n3) => {
        var r3, i4, s2, o2, a2;
        return (null === (r3 = n3.extras) || void 0 === r3 ? void 0 : r3.uuid) === e3 || (null === (s2 = null === (i4 = t2.json.samplers[n3.sampler]) || void 0 === i4 ? void 0 : i4.extras) || void 0 === s2 ? void 0 : s2.uuid) === e3 || (null === (a2 = null === (o2 = t2.json.images[n3.source]) || void 0 === o2 ? void 0 : o2.extras) || void 0 === a2 ? void 0 : a2.t_uuid) === e3;
      });
      i3 && (n2.image && r2.resources.images && r2.resources.images[n2.image] && delete r2.resources.images[n2.image], r2.resources.textures[e3] = {});
    }), t2.json.materials && r2.resources.materials && [...Object.entries(r2.resources.materials)].forEach(([e3, n2]) => {
      const i3 = t2.json.materials.find((t3) => {
        var n3;
        return (null === (n3 = t3.extras) || void 0 === n3 ? void 0 : n3.uuid) === e3;
      });
      i3 && (r2.resources.materials[e3] = {});
    });
    const i2 = [];
    Object.values(r2.resources).forEach((e3) => {
      e3 && Object.values(e3).forEach((e4) => {
        e4.url && ("Uint16Array" === e4.url.type && e4.url.data ? (e4.url.data instanceof Uint16Array || (e4.url.data = new Uint16Array(e4.url.data)), i2.push(e4.url)) : "Uint8Array" === e4.url.type && e4.url.data && (e4.url.data instanceof Uint8Array || (e4.url.data = new Uint8Array(e4.url.data)), i2.push(e4.url)));
      });
    });
    for (const e3 of i2) {
      let r3 = "application/octet-stream";
      if (e3.mimeType && (r3 = e3.mimeType), t2.options.exporterOptions.encodeUint16Rgbe && "Uint16Array" === e3.type && e3.width > 0 && e3.height > 0) {
        const t3 = Ny(e3.data, 4), i4 = new ImageData(t3, e3.width, e3.height), s3 = n.PpQ.getDataURL(i4, true).split(",")[1], o3 = 2;
        if (r3 = "image/png", 1 === o3)
          e3.data = atob(s3);
        else {
          if (2 !== o3)
            throw new Error("Invalid encoding version");
          e3.data = Uint8Array.from(atob(s3), (e4) => e4.charCodeAt(0));
        }
        e3.encoding = "rgbe", e3.encodingVersion = o3;
      }
      t2.json.images || (t2.json.images = []);
      const i3 = { mimeType: r3 }, s2 = t2.json.images.push(i3) - 1, o2 = e3.data;
      i3.bufferView = t2.processBufferViewImageBuffer(o2), e3.data = { image: s2 };
    }
    return r2;
  }
  function Ny(e2, t2 = 3, n2) {
    let r2, i2, s2, o2, a2;
    const l2 = e2.byteLength / (2 * t2) | 0;
    n2 = n2 || new Uint8ClampedArray(4 * l2);
    for (let c2 = 0; c2 < l2; c2++) {
      r2 = e2[c2 * t2], i2 = e2[c2 * t2 + 1], s2 = e2[c2 * t2 + 2], o2 = Math.max(Math.max(r2, i2), s2);
      const l3 = Math.ceil(Math.log2(o2));
      a2 = Math.pow(2, l3 - 8), n2[4 * c2] = r2 / a2 | 0, n2[4 * c2 + 1] = i2 / a2 | 0, n2[4 * c2 + 2] = s2 / a2 | 0, n2[4 * c2 + 3] = l3 + 128;
    }
    return n2;
  }
  function jy(e2, t2, n2 = Uy, r2) {
    var i2;
    if (!t2)
      return;
    const s2 = e2.Exporters.findIndex((e3) => e3.ext.includes("gltf") || e3.ext.includes("glb")), o2 = [];
    s2 >= 0 ? (o2.push(...null !== (i2 = e2.Exporters[s2].extensions) && void 0 !== i2 ? i2 : []), e2.Exporters.splice(s2, 1)) : (o2.push(Vy), o2.push(Gy), o2.push(zy), o2.push((e3) => new ge(e3)), o2.push((e3) => new Hy(e3)), o2.push((e3) => new Qy(e3)), o2.push((e3) => new Wy(e3)), o2.push((e3) => new qy(e3))), e2.Exporters.push({ ctor: () => {
      const e3 = new n2();
      return o2.forEach((t3) => e3.register(t3)), e3.register((e4) => ({ afterParse: (n3) => {
        var r3, i3;
        if (!(null === (r3 = null == (n3 = Array.isArray(n3) ? n3[0] : n3) ? void 0 : n3.userData) || void 0 === r3 ? void 0 : r3.rootSceneModelRoot) || false === (null === (i3 = null == n3 ? void 0 : n3.userData) || void 0 === i3 ? void 0 : i3.__exportViewerConfig))
          return;
        const s3 = e4.json.scenes[e4.json.scene || 0];
        s3.extensions || (s3.extensions = {}), s3.extensions[jn] = Fy(t2, e4), e4.extensionsUsed[jn] = true;
      } })), null == r2 || r2(e3), e3;
    }, ext: ["gltf", "glb"], extensions: o2 });
  }
  const zy = (e2) => ({ writeNode: (t2, n2) => {
    if (!(null == t2 ? void 0 : t2.isLight))
      return;
    n2.extensions || (n2.extensions = {});
    const r2 = {};
    t2.shadow && (r2.shadow = t2.shadow.toJSON()), Object.keys(r2).length > 0 && (n2.extensions[Gn] = r2, e2.extensionsUsed[Gn] = true);
  } }), Gy = (e2) => ({ writeNode: (t2, n2) => {
    if (!(null == t2 ? void 0 : t2.isObject3D))
      return;
    n2.extensions || (n2.extensions = {});
    const r2 = {};
    void 0 !== t2.castShadow && (r2.castShadow = t2.castShadow), void 0 !== t2.receiveShadow && (r2.receiveShadow = t2.receiveShadow), false === t2.visible && (r2.visible = false), false === t2.frustumCulled && (r2.frustumCulled = false), 0 !== t2.renderOrder && (r2.renderOrder = t2.renderOrder), 1 !== t2.layers.mask && (r2.layers = t2.layers.mask), false === t2.matrixAutoUpdate && (r2.matrixAutoUpdate = false), Object.keys(r2).length > 0 && (n2.extensions[Vn] = r2, e2.extensionsUsed[Vn] = true);
  } }), Vy = (e2) => ({ writeMaterial(t2, r2) {
    if (!(null == t2 ? void 0 : t2.isMaterial))
      return;
    r2.extensions || (r2.extensions = {});
    const i2 = {};
    void 0 !== t2.fog && (i2.fog = t2.fog), void 0 !== t2.flatShading && (i2.flatShading = t2.flatShading), void 0 !== t2.blending && (i2.blending = t2.blending), void 0 !== t2.side && t2.side !== n.ehD && (i2.side = t2.side), void 0 !== t2.shadowSide && (i2.shadowSide = t2.shadowSide), void 0 !== t2.depthFunc && (i2.depthFunc = t2.depthFunc), void 0 !== t2.depthTest && (i2.depthTest = t2.depthTest), void 0 !== t2.depthWrite && (i2.depthWrite = t2.depthWrite), void 0 !== t2.colorWrite && (i2.colorWrite = t2.colorWrite), void 0 !== t2.vertexColors && (i2.vertexColors = t2.vertexColors), void 0 !== t2.alphaTest && (i2.alphaTest = t2.alphaTest), void 0 !== t2.envMapIntensity && (i2.envMapIntensity = t2.envMapIntensity), void 0 !== t2.wireframe && (i2.wireframe = t2.wireframe), void 0 !== t2.wireframeLinewidth && (i2.wireframeLinewidth = t2.wireframeLinewidth), void 0 !== t2.wireframeLinecap && (i2.wireframeLinecap = t2.wireframeLinecap), void 0 !== t2.wireframeLinejoin && (i2.wireframeLinejoin = t2.wireframeLinejoin), void 0 !== t2.rotation && (i2.rotation = t2.rotation), void 0 !== t2.polygonOffset && (i2.polygonOffset = t2.polygonOffset), void 0 !== t2.polygonOffsetFactor && (i2.polygonOffsetFactor = t2.polygonOffsetFactor), void 0 !== t2.polygonOffsetUnits && (i2.polygonOffsetUnits = t2.polygonOffsetUnits), void 0 !== t2.dithering && (i2.dithering = t2.dithering), void 0 !== t2.alphaToCoverage && (i2.alphaToCoverage = t2.alphaToCoverage), void 0 !== t2.premultipliedAlpha && (i2.premultipliedAlpha = t2.premultipliedAlpha), void 0 !== t2.toneMapped && (i2.toneMapped = t2.toneMapped), void 0 !== t2.normalScale && (i2.normalScale = [t2.normalScale.x, t2.normalScale.y]);
    const s2 = this.materialExternalResources[t2.uuid];
    s2 && Object.entries(s2).forEach(([t3, n2]) => {
      var r3;
      t3.startsWith("_") || ((null == n2 ? void 0 : n2.userData) && (n2.userData.__embedUrlImagePreviews = null === (r3 = e2.options.exporterOptions) || void 0 === r3 ? void 0 : r3.embedUrlImagePreviews), i2[t3] = le(n2, false, this.serializedMeta), (null == n2 ? void 0 : n2.userData) && delete n2.userData.__embedUrlImagePreviews);
    }), Object.keys(i2).length > 0 && (r2.extensions[Hn] = i2, e2.extensionsUsed[Hn] = true);
  }, materialExternalResources: {}, serializedMeta: { images: {}, textures: {} }, beforeParse(t2) {
    if (this.materialExternalResources = {}, !e2.options.externalImagesInExtras)
      return;
    const n2 = [];
    (Array.isArray(t2) ? t2 : [t2]).forEach((e3) => {
      null == e3 || e3.traverse((e4) => {
        var t3;
        e4 && (null === (t3 = e4.material) || void 0 === t3 ? void 0 : t3.isMaterial) && n2.push(e4.material);
      });
    }), n2.forEach((e3) => {
      e3 && (this.materialExternalResources[e3.uuid] || (this.materialExternalResources[e3.uuid] = {}), this.materialExternalResources[e3.uuid].__materialRef = e3, Object.entries(e3).forEach(([t3, n3]) => {
        t3.startsWith("_") || n3 && n3.isTexture && n3.userData.rootPath && (n3.userData.rootPath.startsWith("http") || n3.userData.rootPath.startsWith("data:")) && (e3[t3] = null, this.materialExternalResources[e3.uuid][t3] = n3);
      }));
    });
  }, afterParse(t2) {
    const n2 = Object.values(this.materialExternalResources);
    if (n2.length < 1)
      return;
    n2.forEach((e3) => {
      const t3 = e3.__materialRef;
      t3 && (Object.entries(e3).forEach(([e4, n3]) => {
        e4.startsWith("_") || n3 && (t3[e4] = n3);
      }), delete this.materialExternalResources[t3.uuid]);
    });
    const r2 = e2.json.scenes[e2.json.scene || 0];
    r2.extensions || (r2.extensions = {}), r2.extensions[Hn] = { resources: this.serializedMeta }, e2.extensionsUsed[Hn] = true;
  } });
  class Hy {
    constructor(e2) {
      this.writer = e2, this.name = Yn;
    }
    writeMaterial(e2, t2) {
      if (!e2.isMeshStandardMaterial || 0 === e2.bumpScale)
        return;
      const n2 = this.writer, r2 = n2.extensionsUsed, i2 = {};
      if (i2.bumpScale = e2.bumpScale, e2.bumpMap) {
        const t3 = { index: n2.processTexture(e2.bumpMap) };
        n2.applyTextureTransform(t3, e2.bumpMap), i2.bumpTexture = t3;
      }
      t2.extensions = t2.extensions || {}, t2.extensions[this.name] = i2, r2[this.name] = true;
    }
  }
  class Qy {
    constructor(e2) {
      this.writer = e2, this.name = Kn;
    }
    writeMaterial(e2, t2) {
      if (!e2.isMeshStandardMaterial || 0 === e2.displacementScale)
        return;
      const n2 = this.writer, r2 = n2.extensionsUsed, i2 = {};
      if (i2.displacementScale = e2.displacementScale, i2.displacementBias = e2.displacementBias, e2.displacementMap) {
        const t3 = { index: n2.processTexture(e2.displacementMap) };
        n2.applyTextureTransform(t3, e2.displacementMap), i2.displacementTexture = t3;
      }
      t2.extensions = t2.extensions || {}, t2.extensions[this.name] = i2, r2[this.name] = true;
    }
  }
  class Wy {
    constructor(e2) {
      this.writer = e2, this.name = Zn;
    }
    writeMaterial(e2, t2) {
      if (!e2.isMeshStandardMaterial || 0 === e2.lightMapIntensity)
        return;
      const n2 = this.writer, r2 = n2.extensionsUsed, i2 = {};
      if (i2.lightMapIntensity = e2.lightMapIntensity, e2.lightMap) {
        const t3 = { index: n2.processTexture(e2.lightMap) };
        n2.applyTextureTransform(t3, e2.lightMap), i2.lightMapTexture = t3;
      }
      t2.extensions = t2.extensions || {}, t2.extensions[this.name] = i2, r2[this.name] = true;
    }
  }
  class qy {
    constructor(e2) {
      this.writer = e2, this.name = Jn;
    }
    writeMaterial(e2, t2) {
      if (!e2.isMeshStandardMaterial || !e2.alphaMap)
        return;
      const n2 = this.writer, r2 = n2.extensionsUsed, i2 = {};
      if (e2.alphaMap) {
        const t3 = { index: n2.processTexture(e2.alphaMap) };
        n2.applyTextureTransform(t3, e2.alphaMap), i2.alphaTexture = t3;
      }
      t2.extensions = t2.extensions || {}, t2.extensions[this.name] = i2, r2[this.name] = true;
    }
  }
  const Xy = new TextEncoder();
  class Yy {
    parse(e2, t2, r2) {
      if (!function(e3, t3) {
        if (t3.isWebGLRenderTarget && (!e3 || !e3.isWebGLRenderer))
          return console.error("EXRExporter.parse: Unsupported first parameter, expected instance of WebGLRenderer."), false;
        if (!t3 || !t3.isWebGLRenderTarget && !t3.isDataTexture)
          return console.error("EXRExporter.parse: Unsupported second parameter, expected instance of WebGLRenderTarget or DataTexture."), false;
        const r3 = t3.isWebGLRenderTarget ? t3.texture : t3;
        return r3.type !== n.VzW && r3.type !== n.cLu ? (console.error("EXRExporter.parse: Unsupported WebGLRenderTarget or DataTexture texture type."), false) : r3.format === n.wk1 || (console.error("EXRExporter.parse: Unsupported WebGLRenderTarget or DataTexture texture format, expected RGBAFormat."), false);
      }(e2, t2))
        return;
      const i2 = function(e3, t3 = {}) {
        const r3 = e3.isTexture ? e3 : e3.texture, i3 = e3.isWebGLRenderTarget ? e3.width : e3.image.width, s3 = e3.isWebGLRenderTarget ? e3.height : e3.image.height, o3 = r3.type, a3 = r3.format, l2 = r3.colorSpace, c2 = void 0 !== t3.compression ? t3.compression : 3, u2 = (void 0 !== t3.type ? t3.type : n.cLu) === n.VzW ? 2 : 1, p2 = { 0: 1, 2: 1, 3: 16 }[c2];
        return { width: i3, height: s3, type: o3, format: a3, colorSpace: l2, compression: c2, blockLines: p2, dataType: u2, dataSize: 2 * u2, numBlocks: Math.ceil(s3 / p2), numInputChannels: 4, numOutputChannels: 4, flipY: e3.isDataTexture && e3.flipY, textureIndex: t3.textureIndex || 0 };
      }(t2, r2), s2 = function(e3, t3, r3) {
        if (t3.isDataTexture)
          return t3.image.data;
        let i3;
        return i3 = r3.type === n.VzW ? new Float32Array(r3.width * r3.height * r3.numInputChannels) : new Uint16Array(r3.width * r3.height * r3.numInputChannels), e3.readRenderTargetPixels(t3, 0, 0, r3.width, r3.height, i3, void 0, r3.textureIndex), i3;
      }(e2, t2, i2), o2 = function(e3, t3) {
        const r3 = t3.width, i3 = t3.height, s3 = { r: 0, g: 0, b: 0, a: 0 }, o3 = { value: 0 }, a3 = 4 == t3.numOutputChannels ? 1 : 0, l2 = t3.type == n.VzW ? ob : sb, c2 = 1 == t3.dataType ? tb : nb, u2 = new Uint8Array(t3.width * t3.height * t3.numOutputChannels * t3.dataSize), p2 = new DataView(u2.buffer);
        for (let n2 = 0; n2 < i3; ++n2)
          for (let u3 = 0; u3 < r3; ++u3) {
            const d2 = n2 * r3 * 4 + 4 * u3, h2 = l2(e3, d2), f2 = l2(e3, d2 + 1), m2 = l2(e3, d2 + 2), _2 = l2(e3, d2 + 3), g2 = (t3.flipY ? n2 : i3 - n2 - 1) * r3 * (3 + a3) * t3.dataSize;
            Zy(s3, h2, f2, m2, _2), o3.value = g2 + u3 * t3.dataSize, c2(p2, s3.a, o3), o3.value = g2 + a3 * r3 * t3.dataSize + u3 * t3.dataSize, c2(p2, s3.b, o3), o3.value = g2 + (1 + a3) * r3 * t3.dataSize + u3 * t3.dataSize, c2(p2, s3.g, o3), o3.value = g2 + (2 + a3) * r3 * t3.dataSize + u3 * t3.dataSize, c2(p2, s3.r, o3);
          }
        return u2;
      }(s2, i2), a2 = function(e3, t3) {
        let n2, r3, i3 = 0;
        const s3 = { data: new Array(), totalSize: 0 }, o3 = t3.width * t3.numOutputChannels * t3.blockLines * t3.dataSize;
        switch (t3.compression) {
          case 0:
            n2 = Ky;
            break;
          case 2:
          case 3:
            n2 = Jy;
        }
        0 !== t3.compression && (r3 = new Uint8Array(o3));
        for (let a3 = 0; a3 < t3.numBlocks; ++a3) {
          const t4 = n2(e3.subarray(o3 * a3, o3 * (a3 + 1)), r3);
          i3 += t4.length, s3.data.push({ dataChunk: t4, size: t4.length });
        }
        return s3.totalSize = i3, s3;
      }(o2, i2);
      return function(e3, t3) {
        const n2 = 8 * t3.numBlocks, r3 = 259 + 18 * t3.numOutputChannels, i3 = { value: r3 + n2 }, s3 = new Uint8Array(r3 + n2 + e3.totalSize + 8 * t3.numBlocks), o3 = new DataView(s3.buffer);
        !function(e4, t4, n3) {
          const r4 = { value: 0 }, i4 = new DataView(e4.buffer);
          eb(i4, 20000630, r4), eb(i4, 2, r4), ib(i4, "compression", r4), ib(i4, "compression", r4), eb(i4, 1, r4), $y(i4, n3.compression, r4), ib(i4, "screenWindowCenter", r4), ib(i4, "v2f", r4), eb(i4, 8, r4), eb(i4, 0, r4), eb(i4, 0, r4), ib(i4, "screenWindowWidth", r4), ib(i4, "float", r4), eb(i4, 4, r4), nb(i4, 1, r4), ib(i4, "pixelAspectRatio", r4), ib(i4, "float", r4), eb(i4, 4, r4), nb(i4, 1, r4), ib(i4, "lineOrder", r4), ib(i4, "lineOrder", r4), eb(i4, 1, r4), $y(i4, 0, r4), ib(i4, "dataWindow", r4), ib(i4, "box2i", r4), eb(i4, 16, r4), eb(i4, 0, r4), eb(i4, 0, r4), eb(i4, n3.width - 1, r4), eb(i4, n3.height - 1, r4), ib(i4, "displayWindow", r4), ib(i4, "box2i", r4), eb(i4, 16, r4), eb(i4, 0, r4), eb(i4, 0, r4), eb(i4, n3.width - 1, r4), eb(i4, n3.height - 1, r4), ib(i4, "channels", r4), ib(i4, "chlist", r4), eb(i4, 18 * n3.numOutputChannels + 1, r4), ib(i4, "A", r4), eb(i4, n3.dataType, r4), r4.value += 4, eb(i4, 1, r4), eb(i4, 1, r4), ib(i4, "B", r4), eb(i4, n3.dataType, r4), r4.value += 4, eb(i4, 1, r4), eb(i4, 1, r4), ib(i4, "G", r4), eb(i4, n3.dataType, r4), r4.value += 4, eb(i4, 1, r4), eb(i4, 1, r4), ib(i4, "R", r4), eb(i4, n3.dataType, r4), r4.value += 4, eb(i4, 1, r4), eb(i4, 1, r4), $y(i4, 0, r4), $y(i4, 0, r4);
          let s4 = r4.value + 8 * n3.numBlocks;
          for (let e5 = 0; e5 < t4.data.length; ++e5)
            rb(i4, s4, r4), s4 += t4.data[e5].size + 8;
        }(s3, e3, t3);
        for (let n3 = 0; n3 < e3.data.length; ++n3) {
          const r4 = e3.data[n3].dataChunk, a3 = e3.data[n3].size;
          eb(o3, n3 * t3.blockLines, i3), eb(o3, a3, i3), s3.set(r4, i3.value), i3.value += a3;
        }
        return s3;
      }(a2, i2);
    }
  }
  function Ky(e2) {
    return e2;
  }
  function Jy(e2, t2) {
    let n2 = 0, r2 = Math.floor((e2.length + 1) / 2), i2 = 0;
    const s2 = e2.length - 1;
    for (; !(i2 > s2 || (t2[n2++] = e2[i2++], i2 > s2)); )
      t2[r2++] = e2[i2++];
    let o2 = t2[0];
    for (let e3 = 1; e3 < t2.length; e3++) {
      const n3 = t2[e3] - o2 + 384;
      o2 = t2[e3], t2[e3] = n3;
    }
    return function(e3, t3) {
      t3 || (t3 = {});
      var n3 = Ef();
      n3.p(e3);
      var r3 = Cf(e3, t3, 2, 4);
      return Mf(r3, t3), Sf(r3, r3.length - 4, n3.d()), r3;
    }(t2);
  }
  function Zy(e2, t2, n2, r2, i2) {
    e2.r = t2, e2.g = n2, e2.b = r2, e2.a = i2;
  }
  function $y(e2, t2, n2) {
    e2.setUint8(n2.value, t2), n2.value += 1;
  }
  function eb(e2, t2, n2) {
    e2.setUint32(n2.value, t2, true), n2.value += 4;
  }
  function tb(e2, t2, r2) {
    e2.setUint16(r2.value, n.A5E.toHalfFloat(t2), true), r2.value += 2;
  }
  function nb(e2, t2, n2) {
    e2.setFloat32(n2.value, t2, true), n2.value += 4;
  }
  function rb(e2, t2, n2) {
    e2.setBigUint64(n2.value, BigInt(t2), true), n2.value += 8;
  }
  function ib(e2, t2, n2) {
    const r2 = Xy.encode(t2 + "\0");
    for (let t3 = 0; t3 < r2.length; ++t3)
      $y(e2, r2[t3], n2);
  }
  function sb(e2, t2) {
    return function(e3) {
      const t3 = (31744 & e3) >> 10, n2 = 1023 & e3;
      return (e3 >> 15 ? -1 : 1) * (t3 ? 31 === t3 ? n2 ? NaN : 1 / 0 : Math.pow(2, t3 - 15) * (1 + n2 / 1024) : n2 / 1024 * 6103515625e-14);
    }(e2[t2]);
  }
  function ob(e2, t2) {
    return e2[t2];
  }
  class ab extends Yy {
    async parseAsync(e2, t2) {
      const n2 = this.parse(e2.renderer.rendererObject, e2, t2);
      return new Blob([n2], { type: "image/x-exr" });
    }
  }
  class lb extends t.SimpleEventDispatcher {
    get processors() {
      return this._processors;
    }
    getExporter(...e2) {
      return this.Exporters.find((t2) => t2.ext.some((t3) => e2.includes(t3)));
    }
    constructor(e2, t2 = {}) {
      super(), this._processors = new zt(), this.Exporters = [{ ctor: () => new iy(), ext: ["json"] }, { ctor: () => new sy(), ext: ["txt", "text"] }, { ctor: () => new ab(), ext: ["exr"] }], this._cachedParsers = [], jy(this, e2);
    }
    async exportObject(e2, t2 = {}) {
      var n2, r2;
      if (!(null == e2 ? void 0 : e2.assetType))
        return void console.error("Object has no asset type");
      (null === (n2 = null == e2 ? void 0 : e2.userData) || void 0 === n2 ? void 0 : n2.rootSceneModelRoot) && false === t2.viewerConfig && (e2.userData.__exportViewerConfig = false);
      const i2 = [];
      "model" === e2.assetType && e2.modelObject.traverse((e3) => {
        e3.userData.excludeFromExport && e3.visible && (e3.visible = false, i2.push(e3));
      });
      const s2 = await this._exportFile(e2, t2);
      return "model" === e2.assetType && i2.forEach((e3) => e3.visible = true), (null === (r2 = null == e2 ? void 0 : e2.userData) || void 0 === r2 ? void 0 : r2.rootSceneModelRoot) && false === t2.viewerConfig && delete e2.userData.__exportViewerConfig, s2;
    }
    async _exportFile(e2, t2 = {}) {
      var n2, r2, i2;
      let s2;
      this.dispatchEvent({ type: "exportFile", obj: e2, state: "processing" });
      try {
        const o2 = await this.processBeforeExport(e2, t2), a2 = null !== (r2 = null !== (n2 = t2.exportExt) && void 0 !== n2 ? n2 : null == o2 ? void 0 : o2.typeExt) && void 0 !== r2 ? r2 : null == o2 ? void 0 : o2.ext;
        if (!o2 || !a2)
          throw new Error(`Unable to preprocess before export ${a2}`);
        const l2 = this._getParser(a2);
        this.dispatchEvent({ type: "exportFile", obj: e2, state: "exporting" });
        const c2 = await l2.parseAsync(o2.obj, { exportExt: null !== (i2 = o2.ext) && void 0 !== i2 ? i2 : a2, ...t2 });
        c2.ext = o2.ext, s2 = c2;
      } catch (t3) {
        return console.error("AssetExporter: Unable to Export file", e2), console.error(t3), void this.dispatchEvent({ type: "exportFile", obj: e2, state: "error", error: t3 });
      }
      return this.dispatchEvent({ type: "exportFile", obj: e2, state: "done" }), s2;
    }
    _createParser(e2) {
      const t2 = this.Exporters.find((t3) => t3.ext.includes(e2));
      if (!t2)
        throw new Error(`No exporter found for extension ${e2}`);
      const n2 = null == t2 ? void 0 : t2.ctor(this);
      if (!n2)
        throw new Error(`Unable to create parser for extension ${e2}`);
      return this._cachedParsers.push({ ext: t2.ext, parser: n2 }), this.dispatchEvent({ type: "exporterCreate", exporter: t2, parser: n2 }), n2;
    }
    _getParser(e2) {
      var t2, n2;
      return null !== (n2 = null === (t2 = this._cachedParsers.find((t3) => t3.ext.includes(e2))) || void 0 === t2 ? void 0 : t2.parser) && void 0 !== n2 ? n2 : this._createParser(e2);
    }
    async processBeforeExport(e2, t2 = {}) {
      if (null != e2.assetType && "renderTarget" !== e2.assetType && (e2 = await this._processors.process(e2.assetType, e2, t2)), e2.isWebGLRenderTarget)
        return { obj: e2, ext: "exr" };
      switch (e2.assetType) {
        case "light":
          return void console.error("AssetExporter: light export not implemented");
        case "model":
          return { obj: e2, ext: "glb" };
        case "material":
          return { obj: e2.toJSON(), ext: e2.typeSlug || "json", typeExt: "json" };
        case "texture":
          return { obj: e2.toJSON(), ext: "json" };
        case "renderTarget":
          return { obj: e2, ext: "exr" };
        default:
          console.error("AssetExporter: unknown asset type", e2.assetType);
      }
    }
    dispose() {
      var e2;
      null === (e2 = this._processors) || void 0 === e2 || e2.dispose();
    }
  }
  var cb;
  !function(e2) {
    e2[e2.EDGEBREAKER = 1] = "EDGEBREAKER", e2[e2.SEQUENTIAL = 0] = "SEQUENTIAL";
  }(cb || (cb = {}));
  class ub extends gt {
    constructor(e2) {
      super(), this.enabled = true, this.exportOptions = { compress: false, name: "scene", viewerConfig: true, encodeUint16Rgbe: false, convertMeshToIndexed: false, embedUrlImagePreviews: false, embedUrlImages: false, dracoOptions: { encodeSpeed: 5, method: cb.EDGEBREAKER, quantizationVolume: "mesh", quantizationBits: { POSITION: 14, NORMAL: 10, COLOR: 8, TEX_COORD: 12, GENERIC: 12 } }, encrypt: false, encryptKey: "" }, this.exporter = e2, this.exportScene = this.exportScene.bind(this);
    }
    async onAdded(e2) {
      await super.onAdded(e2), this.exporter || (this.exporter = new lb(e2)), this.exporter.processors.add("model", { forAssetType: "model", processAsync: async (e3, t2) => {
        var n2;
        return t2.convertMeshToIndexed && (null === (n2 = e3.modelObject) || void 0 === n2 || n2.traverse((e4) => {
          var t3;
          e4.geometry && (e4.geometry.attributes.index || null === (t3 = e4.setGeometry) || void 0 === t3 || t3.call(e4, q(e4.geometry)));
        })), e3;
      } });
    }
    async onRemove(e2) {
      return super.onRemove(e2);
    }
    async exportScene(e2) {
      var t2, n2;
      return null === (t2 = this.exporter) || void 0 === t2 ? void 0 : t2.exportObject(null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.scene.modelRoot, e2 || { ...this.exportOptions });
    }
    async downloadSceneGlb() {
      const e2 = await this.exportScene(this.exportOptions);
      e2 && await this._downloadBlob(e2, this.exportOptions.name + "." + e2.ext);
    }
    async _downloadBlob(e2, t2) {
      var n2, r2;
      const i2 = null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.getPluginByType("FileTransferPlugin");
      i2 ? await i2.exportFile(e2, t2) : null === (r2 = this._viewer) || void 0 === r2 || r2.console.error("FileTransferPlugin required to export/download file");
    }
    get uiConfig() {
      if (this._uiConfig)
        return this._uiConfig;
      const e2 = this._viewer;
      e2.addEventListener("addPlugin", (e3) => {
        var t2;
        "function" == typeof (null === (t2 = e3.plugin) || void 0 === t2 ? void 0 : t2.toJSON) && console.error("Add all plugins before setting up the export UI, or use `toJSON: any = null` in the plugin ");
      });
      const n2 = Object.entries(e2.plugins).filter(([e3, t2]) => "function" == typeof (null == t2 ? void 0 : t2.toJSON) && false !== (null == t2 ? void 0 : t2.serializeWithViewer)).map(([e3, t2]) => ({ label: e3, type: "checkbox", value: true }));
      return this._uiConfig = { type: "folder", label: "Asset Export", limitedUi: true, children: [{ type: "input", property: [this.exportOptions, "name"], limitedUi: true }, { type: "folder", label: "GLB Export", limitedUi: true, children: [{ type: "checkbox", label: "DRACO Compress", property: [this.exportOptions, "compress"], limitedUi: true, onChange: () => {
        var e3, t2;
        return null === (t2 = null === (e3 = this._uiConfig) || void 0 === e3 ? void 0 : e3.uiRefresh) || void 0 === t2 ? void 0 : t2.call(e3, "postFrame", true);
      } }, this.exportOptions.dracoOptions ? { type: "folder", hidden: () => !this.exportOptions.compress, label: "DRACO Options", children: [{ type: "slider", label: "Encode Speed", bounds: [1, 10], property: [this.exportOptions.dracoOptions, "encodeSpeed"] }, { type: "dropdown", label: "Encoder Method", property: [this.exportOptions.dracoOptions, "method"], children: Object.entries(cb).map(([e3, t2]) => ({ label: e3, value: t2 })) }, { type: "dropdown", label: "Quantization Volume", property: [this.exportOptions.dracoOptions, "quantizationVolume"], children: ["mesh", "scene", "bbox"].map((e3) => ({ label: e3 })) }, { type: "folder", label: "Quantization Bits", children: Object.keys(this.exportOptions.dracoOptions.quantizationBits).map((e3) => ({ type: "slider", label: e3, bounds: [1, 16], stepSize: 1, property: [this.exportOptions.dracoOptions.quantizationBits, e3] })) }] } : {}, { type: "checkbox", label: "Scene Settings", property: [this.exportOptions, "viewerConfig"], limitedUi: true, onChange: () => {
        var e3, t2;
        return null === (t2 = null === (e3 = this._uiConfig) || void 0 === e3 ? void 0 : e3.uiRefresh) || void 0 === t2 ? void 0 : t2.call(e3, "postFrame", true);
      } }, { type: "checkbox", label: "Embed Image Previews", property: [this.exportOptions, "embedUrlImagePreviews"] }, { type: "checkbox", label: "Encrypt", property: [this.exportOptions, "encrypt"], onChange: () => {
        var e3, t2;
        return null === (t2 = null === (e3 = this._uiConfig) || void 0 === e3 ? void 0 : e3.uiRefresh) || void 0 === t2 ? void 0 : t2.call(e3, "postFrame", true);
      } }, { type: "checkbox", label: "Encrypt Password", hidden: () => !this.exportOptions.encrypt, property: [this.exportOptions, "encryptKey"] }, { type: "checkbox", label: "Compress hdr env maps", hidden: () => !this.exportOptions.viewerConfig, property: [this.exportOptions, "encodeUint16Rgbe"] }, { type: "checkbox", label: "Convert to indexed", property: [this.exportOptions, "convertMeshToIndexed"] }, { type: "button", label: "Export GLB", limitedUi: true, value: async () => this.downloadSceneGlb() }] }, { type: "folder", label: "Preset/Config export", children: [{ type: "folder", label: "Plugins", children: n2 }, { type: "button", label: "Select none", value: () => {
        n2.forEach((e3) => {
          var t2;
          e3.value = false, null === (t2 = e3.uiRefresh) || void 0 === t2 || t2.call(e3);
        });
      } }, { type: "button", label: "Select all", value: () => {
        n2.forEach((e3) => {
          var t2;
          e3.value = true, null === (t2 = e3.uiRefresh) || void 0 === t2 || t2.call(e3);
        });
      } }, { type: "button", label: "Export Plugins", limitedUi: true, value: async () => {
        const r2 = new Blob([JSON.stringify(e2.getPlugin(Ls).exportPluginPresets(n2.filter((e3) => !!e3.value).map((e3) => (0, t.getOrCall)(e3.label) || "")), null, 2)], { type: "application/json" });
        r2 && await this._downloadBlob(r2, this.exportOptions.name + "." + Ls.ViewerTypeSlug);
      } }, { type: "button", label: "Export All Viewer Config", limitedUi: true, value: async () => {
        const t2 = new Blob([JSON.stringify(e2.getPlugin(Ls).exportViewerConfig(false), null, 2)], { type: "application/json" });
        t2 && await this._downloadBlob(t2, this.exportOptions.name + "." + Ls.ViewerTypeSlug);
      } }] }] };
    }
  }
  ub.PluginType = "AssetExporterPlugin", function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    s2 > 3 && o2 && Object.defineProperty(t2, n2, o2);
  }([ie()], ub.prototype, "exportOptions", void 0);
  class pb {
    constructor() {
      this._listeners = {};
    }
    addEventListener(e2, t2) {
      const n2 = this._listeners;
      return void 0 === n2[e2] && (n2[e2] = []), -1 === n2[e2].indexOf(t2) && n2[e2].push(t2), this;
    }
    removeEventListener(e2, t2) {
      if (void 0 === this._listeners)
        return this;
      const n2 = this._listeners[e2];
      if (void 0 !== n2) {
        const e3 = n2.indexOf(t2);
        -1 !== e3 && n2.splice(e3, 1);
      }
      return this;
    }
    dispatchEvent(e2) {
      if (void 0 === this._listeners)
        return this;
      const t2 = this._listeners[e2.type];
      if (void 0 !== t2) {
        const n2 = t2.slice(0);
        for (let t3 = 0, r2 = n2.length; t3 < r2; t3++)
          n2[t3].call(this, e2);
      }
      return this;
    }
    dispose() {
      for (const e2 in this._listeners)
        delete this._listeners[e2];
    }
  }
  class db extends pb {
    constructor(e2, t2, n2, r2 = {}) {
      if (super(), this._name = void 0, this._parent = void 0, this._child = void 0, this._attributes = void 0, this._disposed = false, this._name = e2, this._parent = t2, this._child = n2, this._attributes = r2, !t2.isOnGraph(n2))
        throw new Error("Cannot connect disconnected graphs.");
    }
    getName() {
      return this._name;
    }
    getParent() {
      return this._parent;
    }
    getChild() {
      return this._child;
    }
    setChild(e2) {
      return this._child = e2, this;
    }
    getAttributes() {
      return this._attributes;
    }
    dispose() {
      this._disposed || (this._disposed = true, this.dispatchEvent({ type: "dispose", target: this }), super.dispose());
    }
    isDisposed() {
      return this._disposed;
    }
  }
  class hb extends pb {
    constructor(...e2) {
      super(...e2), this._emptySet = /* @__PURE__ */ new Set(), this._edges = /* @__PURE__ */ new Set(), this._parentEdges = /* @__PURE__ */ new Map(), this._childEdges = /* @__PURE__ */ new Map();
    }
    listEdges() {
      return Array.from(this._edges);
    }
    listParentEdges(e2) {
      return Array.from(this._childEdges.get(e2) || this._emptySet);
    }
    listParents(e2) {
      return this.listParentEdges(e2).map((e3) => e3.getParent());
    }
    listChildEdges(e2) {
      return Array.from(this._parentEdges.get(e2) || this._emptySet);
    }
    listChildren(e2) {
      return this.listChildEdges(e2).map((e3) => e3.getChild());
    }
    disconnectParents(e2, t2) {
      let n2 = this.listParentEdges(e2);
      return t2 && (n2 = n2.filter((e3) => t2(e3.getParent()))), n2.forEach((e3) => e3.dispose()), this;
    }
    createEdge(e2, t2, n2, r2) {
      return this._registerEdge(new db(e2, t2, n2, r2));
    }
    _registerEdge(e2) {
      this._edges.add(e2);
      const t2 = e2.getParent();
      this._parentEdges.has(t2) || this._parentEdges.set(t2, /* @__PURE__ */ new Set()), this._parentEdges.get(t2).add(e2);
      const n2 = e2.getChild();
      return this._childEdges.has(n2) || this._childEdges.set(n2, /* @__PURE__ */ new Set()), this._childEdges.get(n2).add(e2), e2.addEventListener("dispose", () => this._removeEdge(e2)), e2;
    }
    _removeEdge(e2) {
      return this._edges.delete(e2), this._parentEdges.get(e2.getParent()).delete(e2), this._childEdges.get(e2.getChild()).delete(e2), this;
    }
  }
  function fb() {
    return fb = Object.assign || function(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var n2 = arguments[t2];
        for (var r2 in n2)
          Object.prototype.hasOwnProperty.call(n2, r2) && (e2[r2] = n2[r2]);
      }
      return e2;
    }, fb.apply(this, arguments);
  }
  function mb(e2) {
    return e2 instanceof db;
  }
  function _b(e2) {
    return Array.isArray(e2) && e2[0] instanceof db;
  }
  function gb(e2) {
    return !!(function(e3) {
      return Boolean(e3) && Object.getPrototypeOf(e3) === Object.prototype;
    }(e2) && function(e3) {
      for (const t2 in e3)
        return e3[t2];
    }(e2) instanceof db);
  }
  const vb = Symbol("attributes"), yb = Symbol("immutableKeys");
  class bb extends pb {
    constructor(e2) {
      super(), this._disposed = false, this.graph = void 0, this[vb] = void 0, this[yb] = void 0, this.graph = e2, this[yb] = /* @__PURE__ */ new Set(), this[vb] = this._createAttributes();
    }
    getDefaults() {
      return {};
    }
    _createAttributes() {
      const e2 = this.getDefaults(), t2 = {};
      for (const n2 in e2) {
        const r2 = e2[n2];
        if (r2 instanceof bb) {
          const e3 = this.graph.createEdge(n2, this, r2);
          e3.addEventListener("dispose", () => r2.dispose()), this[yb].add(n2), t2[n2] = e3;
        } else
          t2[n2] = r2;
      }
      return t2;
    }
    isOnGraph(e2) {
      return this.graph === e2.graph;
    }
    isDisposed() {
      return this._disposed;
    }
    dispose() {
      this._disposed || (this.graph.listChildEdges(this).forEach((e2) => e2.dispose()), this.graph.disconnectParents(this), this._disposed = true, this.dispatchEvent({ type: "dispose" }));
    }
    detach() {
      return this.graph.disconnectParents(this), this;
    }
    swap(e2, t2) {
      for (const n2 in this[vb]) {
        const r2 = this[vb][n2];
        if (mb(r2)) {
          const i2 = r2;
          i2.getChild() === e2 && this.setRef(n2, t2, i2.getAttributes());
        } else if (_b(r2)) {
          const i2 = r2.find((t3) => t3.getChild() === e2);
          if (i2) {
            const r3 = i2.getAttributes();
            this.removeRef(n2, e2).addRef(n2, t2, r3);
          }
        } else if (gb(r2)) {
          const i2 = r2;
          for (const r3 in i2) {
            const s2 = i2[r3];
            s2.getChild() === e2 && this.setRefMap(n2, r3, t2, s2.getAttributes());
          }
        }
      }
      return this;
    }
    get(e2) {
      return this[vb][e2];
    }
    set(e2, t2) {
      return this[vb][e2] = t2, this.dispatchEvent({ type: "change", attribute: e2 });
    }
    getRef(e2) {
      const t2 = this[vb][e2];
      return t2 ? t2.getChild() : null;
    }
    setRef(e2, t2, n2) {
      if (this[yb].has(e2))
        throw new Error(`Cannot overwrite immutable attribute, "${e2}".`);
      const r2 = this[vb][e2];
      if (r2 && r2.dispose(), !t2)
        return this;
      const i2 = this.graph.createEdge(e2, this, t2, n2);
      return i2.addEventListener("dispose", () => {
        delete this[vb][e2], this.dispatchEvent({ type: "change", attribute: e2 });
      }), this[vb][e2] = i2, this.dispatchEvent({ type: "change", attribute: e2 });
    }
    listRefs(e2) {
      return this[vb][e2].map((e3) => e3.getChild());
    }
    addRef(e2, t2, n2) {
      const r2 = this.graph.createEdge(e2, this, t2, n2), i2 = this[vb][e2];
      return i2.push(r2), r2.addEventListener("dispose", () => {
        const t3 = i2.filter((e3) => e3 !== r2);
        i2.length = 0;
        for (const e3 of t3)
          i2.push(e3);
        this.dispatchEvent({ type: "change", attribute: e2 });
      }), this.dispatchEvent({ type: "change", attribute: e2 });
    }
    removeRef(e2, t2) {
      return this[vb][e2].filter((e3) => e3.getChild() === t2).forEach((e3) => e3.dispose()), this;
    }
    listRefMapKeys(e2) {
      return Object.keys(this[vb][e2]);
    }
    listRefMapValues(e2) {
      return Object.values(this[vb][e2]).map((e3) => e3.getChild());
    }
    getRefMap(e2, t2) {
      const n2 = this[vb][e2];
      return n2[t2] ? n2[t2].getChild() : null;
    }
    setRefMap(e2, t2, n2, r2) {
      const i2 = this[vb][e2], s2 = i2[t2];
      if (s2 && s2.dispose(), !n2)
        return this;
      r2 = Object.assign(r2 || {}, { key: t2 });
      const o2 = this.graph.createEdge(e2, this, n2, fb({}, r2, { key: t2 }));
      return o2.addEventListener("dispose", () => {
        delete i2[t2], this.dispatchEvent({ type: "change", attribute: e2, key: t2 });
      }), i2[t2] = o2, this.dispatchEvent({ type: "change", attribute: e2, key: t2 });
    }
    dispatchEvent(e2) {
      return super.dispatchEvent(fb({}, e2, { target: this })), this.graph.dispatchEvent(fb({}, e2, { target: this, type: `node:${e2.type}` })), this;
    }
  }
  const wb = "@glb.bin";
  var Ab, xb, Eb, Cb, Sb;
  !function(e2) {
    e2.ACCESSOR = "Accessor", e2.ANIMATION = "Animation", e2.ANIMATION_CHANNEL = "AnimationChannel", e2.ANIMATION_SAMPLER = "AnimationSampler", e2.BUFFER = "Buffer", e2.CAMERA = "Camera", e2.MATERIAL = "Material", e2.MESH = "Mesh", e2.PRIMITIVE = "Primitive", e2.PRIMITIVE_TARGET = "PrimitiveTarget", e2.NODE = "Node", e2.ROOT = "Root", e2.SCENE = "Scene", e2.SKIN = "Skin", e2.TEXTURE = "Texture", e2.TEXTURE_INFO = "TextureInfo";
  }(Ab || (Ab = {})), function(e2) {
    e2.INTERLEAVED = "interleaved", e2.SEPARATE = "separate";
  }(xb || (xb = {})), function(e2) {
    e2.ARRAY_BUFFER = "ARRAY_BUFFER", e2.ELEMENT_ARRAY_BUFFER = "ELEMENT_ARRAY_BUFFER", e2.INVERSE_BIND_MATRICES = "INVERSE_BIND_MATRICES", e2.OTHER = "OTHER", e2.SPARSE = "SPARSE";
  }(Eb || (Eb = {})), function(e2) {
    e2[e2.R = 4096] = "R", e2[e2.G = 256] = "G", e2[e2.B = 16] = "B", e2[e2.A = 1] = "A";
  }(Cb || (Cb = {})), function(e2) {
    e2.GLTF = "GLTF", e2.GLB = "GLB";
  }(Sb || (Sb = {}));
  const Mb = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array };
  var Tb, Pb, Ib = "undefined" != typeof Float32Array ? Float32Array : Array;
  function Rb(e2) {
    return Math.hypot(e2[0], e2[1], e2[2]);
  }
  function kb(e2, t2, n2) {
    var r2 = t2[0], i2 = t2[1], s2 = t2[2], o2 = n2[3] * r2 + n2[7] * i2 + n2[11] * s2 + n2[15];
    return e2[0] = (n2[0] * r2 + n2[4] * i2 + n2[8] * s2 + n2[12]) / (o2 = o2 || 1), e2[1] = (n2[1] * r2 + n2[5] * i2 + n2[9] * s2 + n2[13]) / o2, e2[2] = (n2[2] * r2 + n2[6] * i2 + n2[10] * s2 + n2[14]) / o2, e2;
  }
  function Db(e2, t2) {
    const n2 = { min: [1 / 0, 1 / 0, 1 / 0], max: [-1 / 0, -1 / 0, -1 / 0] };
    for (const r2 of e2.listPrimitives()) {
      const e3 = r2.getAttribute("POSITION");
      if (!e3)
        continue;
      let i2 = [0, 0, 0], s2 = [0, 0, 0];
      for (let r3 = 0; r3 < e3.getCount(); r3++)
        i2 = e3.getElement(r3, i2), s2 = kb(s2, i2, t2), Bb(s2, n2);
    }
    return n2;
  }
  function Bb(e2, t2) {
    for (let n2 = 0; n2 < 3; n2++)
      t2.min[n2] = Math.min(e2[n2], t2.min[n2]), t2.max[n2] = Math.max(e2[n2], t2.max[n2]);
  }
  Math.hypot || (Math.hypot = function() {
    for (var e2 = 0, t2 = arguments.length; t2--; )
      e2 += arguments[t2] * arguments[t2];
    return Math.sqrt(e2);
  }), Tb = new Ib(3), Ib != Float32Array && (Tb[0] = 0, Tb[1] = 0, Tb[2] = 0);
  class Ob {
    static createBufferFromDataURI(e2) {
      if ("undefined" == typeof Buffer) {
        const t2 = atob(e2.split(",")[1]), n2 = new Uint8Array(t2.length);
        for (let e3 = 0; e3 < t2.length; e3++)
          n2[e3] = t2.charCodeAt(e3);
        return n2;
      }
      {
        const t2 = e2.split(",")[1], n2 = e2.indexOf("base64") >= 0;
        return Buffer.from(t2, n2 ? "base64" : "utf8");
      }
    }
    static encodeText(e2) {
      return "undefined" != typeof TextEncoder ? new TextEncoder().encode(e2) : Buffer.from(e2);
    }
    static decodeText(e2) {
      return "undefined" != typeof TextDecoder ? new TextDecoder().decode(e2) : Buffer.from(e2).toString("utf8");
    }
    static concat(e2) {
      let t2 = 0;
      for (const n3 of e2)
        t2 += n3.byteLength;
      const n2 = new Uint8Array(t2);
      let r2 = 0;
      for (const t3 of e2)
        n2.set(t3, r2), r2 += t3.byteLength;
      return n2;
    }
    static pad(e2, t2 = 0) {
      const n2 = this.padNumber(e2.byteLength);
      if (n2 === e2.byteLength)
        return e2;
      const r2 = new Uint8Array(n2);
      if (r2.set(e2), 0 !== t2)
        for (let i2 = e2.byteLength; i2 < n2; i2++)
          r2[i2] = t2;
      return r2;
    }
    static padNumber(e2) {
      return 4 * Math.ceil(e2 / 4);
    }
    static equals(e2, t2) {
      if (e2 === t2)
        return true;
      if (e2.byteLength !== t2.byteLength)
        return false;
      let n2 = e2.byteLength;
      for (; n2--; )
        if (e2[n2] !== t2[n2])
          return false;
      return true;
    }
    static toView(e2, t2 = 0, n2 = 1 / 0) {
      return new Uint8Array(e2.buffer, e2.byteOffset + t2, Math.min(e2.byteLength, n2));
    }
    static assertView(e2) {
      if (e2 && !ArrayBuffer.isView(e2))
        throw new Error(`Method requires Uint8Array parameter; received "${typeof e2}".`);
      return e2;
    }
  }
  class Lb {
    static hexToFactor(e2, t2) {
      e2 = Math.floor(e2);
      const n2 = t2;
      return n2[0] = (e2 >> 16 & 255) / 255, n2[1] = (e2 >> 8 & 255) / 255, n2[2] = (255 & e2) / 255, this.convertSRGBToLinear(t2, t2);
    }
    static factorToHex(e2) {
      const t2 = [...e2], [n2, r2, i2] = this.convertLinearToSRGB(e2, t2);
      return 255 * n2 << 16 ^ 255 * r2 << 8 ^ 255 * i2 << 0;
    }
    static convertSRGBToLinear(e2, t2) {
      const n2 = e2, r2 = t2;
      for (let e3 = 0; e3 < 3; e3++)
        r2[e3] = n2[e3] < 0.04045 ? 0.0773993808 * n2[e3] : Math.pow(0.9478672986 * n2[e3] + 0.0521327014, 2.4);
      return t2;
    }
    static convertLinearToSRGB(e2, t2) {
      const n2 = e2, r2 = t2;
      for (let e3 = 0; e3 < 3; e3++)
        r2[e3] = n2[e3] < 31308e-7 ? 12.92 * n2[e3] : 1.055 * Math.pow(n2[e3], 0.41666) - 0.055;
      return t2;
    }
  }
  class Ub {
    match(e2) {
      return e2.length >= 8 && 137 === e2[0] && 80 === e2[1] && 78 === e2[2] && 71 === e2[3] && 13 === e2[4] && 10 === e2[5] && 26 === e2[6] && 10 === e2[7];
    }
    getSize(e2) {
      const t2 = new DataView(e2.buffer, e2.byteOffset);
      return Ob.decodeText(e2.slice(12, 16)) === Ub.PNG_FRIED_CHUNK_NAME ? [t2.getUint32(32, false), t2.getUint32(36, false)] : [t2.getUint32(16, false), t2.getUint32(20, false)];
    }
    getChannels(e2) {
      return 4;
    }
  }
  Ub.PNG_FRIED_CHUNK_NAME = "CgBI";
  class Fb {
    static registerFormat(e2, t2) {
      this.impls[e2] = t2;
    }
    static getMimeType(e2) {
      for (const t2 in this.impls)
        if (this.impls[t2].match(e2))
          return t2;
      return null;
    }
    static getSize(e2, t2) {
      return this.impls[t2] ? this.impls[t2].getSize(e2) : null;
    }
    static getChannels(e2, t2) {
      return this.impls[t2] ? this.impls[t2].getChannels(e2) : null;
    }
    static getVRAMByteLength(e2, t2) {
      if (!this.impls[t2])
        return null;
      if (this.impls[t2].getVRAMByteLength)
        return this.impls[t2].getVRAMByteLength(e2);
      let n2 = 0;
      const r2 = this.getSize(e2, t2);
      if (!r2)
        return null;
      for (; r2[0] > 1 || r2[1] > 1; )
        n2 += r2[0] * r2[1] * 4, r2[0] = Math.max(Math.floor(r2[0] / 2), 1), r2[1] = Math.max(Math.floor(r2[1] / 2), 1);
      return n2 += 4, n2;
    }
    static mimeTypeToExtension(e2) {
      return "image/jpeg" === e2 ? "jpg" : e2.split("/").pop();
    }
    static extensionToMimeType(e2) {
      return "jpg" === e2 ? "image/jpeg" : e2 ? `image/${e2}` : "";
    }
  }
  function Nb(e2, t2) {
    if (t2 > e2.byteLength)
      throw new TypeError("Corrupt JPG, exceeded buffer limits");
    if (255 !== e2.getUint8(t2))
      throw new TypeError("Invalid JPG, marker table corrupted");
    return e2;
  }
  Fb.impls = { "image/jpeg": new class {
    match(e2) {
      return e2.length >= 3 && 255 === e2[0] && 216 === e2[1] && 255 === e2[2];
    }
    getSize(e2) {
      let t2, n2, r2 = new DataView(e2.buffer, e2.byteOffset + 4);
      for (; r2.byteLength; ) {
        if (t2 = r2.getUint16(0, false), Nb(r2, t2), n2 = r2.getUint8(t2 + 1), 192 === n2 || 193 === n2 || 194 === n2)
          return [r2.getUint16(t2 + 7, false), r2.getUint16(t2 + 5, false)];
        r2 = new DataView(e2.buffer, r2.byteOffset + t2 + 2);
      }
      throw new TypeError("Invalid JPG, no size found");
    }
    getChannels(e2) {
      return 3;
    }
  }(), "image/png": new Ub() };
  class jb {
    static basename(e2) {
      const t2 = e2.split(/[\\/]/).pop();
      return t2.substring(0, t2.lastIndexOf("."));
    }
    static extension(e2) {
      if (e2.startsWith("data:image/")) {
        const t2 = e2.match(/data:(image\/\w+)/)[1];
        return Fb.mimeTypeToExtension(t2);
      }
      return e2.startsWith("data:model/gltf+json") ? "gltf" : e2.startsWith("data:model/gltf-binary") ? "glb" : e2.startsWith("data:application/") ? "bin" : e2.split(/[\\/]/).pop().split(/[.]/).pop();
    }
  }
  function zb(e2) {
    return "[object Object]" === Object.prototype.toString.call(e2);
  }
  function Gb(e2) {
    if (false === zb(e2))
      return false;
    const t2 = e2.constructor;
    if (void 0 === t2)
      return true;
    const n2 = t2.prototype;
    return false !== zb(n2) && false !== Object.prototype.hasOwnProperty.call(n2, "isPrototypeOf");
  }
  !function(e2) {
    e2[e2.SILENT = 4] = "SILENT", e2[e2.ERROR = 3] = "ERROR", e2[e2.WARN = 2] = "WARN", e2[e2.INFO = 1] = "INFO", e2[e2.DEBUG = 0] = "DEBUG";
  }(Pb || (Pb = {}));
  class Vb {
    constructor(e2) {
      this.verbosity = void 0, this.verbosity = e2;
    }
    debug(e2) {
      this.verbosity <= Vb.Verbosity.DEBUG && console.debug(e2);
    }
    info(e2) {
      this.verbosity <= Vb.Verbosity.INFO && console.info(e2);
    }
    warn(e2) {
      this.verbosity <= Vb.Verbosity.WARN && console.warn(e2);
    }
    error(e2) {
      this.verbosity <= Vb.Verbosity.ERROR && console.error(e2);
    }
  }
  function Hb(e2, t2, n2) {
    var r2 = t2[0], i2 = t2[1], s2 = t2[2], o2 = t2[3], a2 = t2[4], l2 = t2[5], c2 = t2[6], u2 = t2[7], p2 = t2[8], d2 = t2[9], h2 = t2[10], f2 = t2[11], m2 = t2[12], _2 = t2[13], g2 = t2[14], v2 = t2[15], y2 = n2[0], b2 = n2[1], w2 = n2[2], A2 = n2[3];
    return e2[0] = y2 * r2 + b2 * a2 + w2 * p2 + A2 * m2, e2[1] = y2 * i2 + b2 * l2 + w2 * d2 + A2 * _2, e2[2] = y2 * s2 + b2 * c2 + w2 * h2 + A2 * g2, e2[3] = y2 * o2 + b2 * u2 + w2 * f2 + A2 * v2, e2[4] = (y2 = n2[4]) * r2 + (b2 = n2[5]) * a2 + (w2 = n2[6]) * p2 + (A2 = n2[7]) * m2, e2[5] = y2 * i2 + b2 * l2 + w2 * d2 + A2 * _2, e2[6] = y2 * s2 + b2 * c2 + w2 * h2 + A2 * g2, e2[7] = y2 * o2 + b2 * u2 + w2 * f2 + A2 * v2, e2[8] = (y2 = n2[8]) * r2 + (b2 = n2[9]) * a2 + (w2 = n2[10]) * p2 + (A2 = n2[11]) * m2, e2[9] = y2 * i2 + b2 * l2 + w2 * d2 + A2 * _2, e2[10] = y2 * s2 + b2 * c2 + w2 * h2 + A2 * g2, e2[11] = y2 * o2 + b2 * u2 + w2 * f2 + A2 * v2, e2[12] = (y2 = n2[12]) * r2 + (b2 = n2[13]) * a2 + (w2 = n2[14]) * p2 + (A2 = n2[15]) * m2, e2[13] = y2 * i2 + b2 * l2 + w2 * d2 + A2 * _2, e2[14] = y2 * s2 + b2 * c2 + w2 * h2 + A2 * g2, e2[15] = y2 * o2 + b2 * u2 + w2 * f2 + A2 * v2, e2;
  }
  Vb.Verbosity = Pb, Vb.DEFAULT_INSTANCE = new Vb(Vb.Verbosity.INFO);
  class Qb {
    static identity(e2) {
      return e2;
    }
    static eq(e2, t2, n2 = 1e-5) {
      if (e2.length !== t2.length)
        return false;
      for (let r2 = 0; r2 < e2.length; r2++)
        if (Math.abs(e2[r2] - t2[r2]) > n2)
          return false;
      return true;
    }
    static decodeNormalizedInt(e2, t2) {
      switch (t2) {
        case 5126:
          return e2;
        case 5123:
          return e2 / 65535;
        case 5121:
          return e2 / 255;
        case 5122:
          return Math.max(e2 / 32767, -1);
        case 5120:
          return Math.max(e2 / 127, -1);
        default:
          throw new Error("Invalid component type.");
      }
    }
    static denormalize(e2, t2) {
      return Qb.decodeNormalizedInt(e2, t2);
    }
    static encodeNormalizedInt(e2, t2) {
      switch (t2) {
        case 5126:
          return e2;
        case 5123:
          return Math.round(65535 * e2);
        case 5121:
          return Math.round(255 * e2);
        case 5122:
          return Math.round(32767 * e2);
        case 5120:
          return Math.round(127 * e2);
        default:
          throw new Error("Invalid component type.");
      }
    }
    static normalize(e2, t2) {
      return Qb.encodeNormalizedInt(e2, t2);
    }
    static decompose(e2, t2, n2, r2) {
      let i2 = Rb([e2[0], e2[1], e2[2]]);
      const s2 = Rb([e2[4], e2[5], e2[6]]), o2 = Rb([e2[8], e2[9], e2[10]]);
      var a2, l2, c2, u2, p2, d2, h2, f2, m2, _2, g2, v2, y2, b2, w2, A2, x2;
      ((l2 = (a2 = e2)[0]) * (h2 = a2[5]) - (c2 = a2[1]) * (d2 = a2[4])) * ((v2 = a2[10]) * (x2 = a2[15]) - (y2 = a2[11]) * (A2 = a2[14])) - (l2 * (f2 = a2[6]) - (u2 = a2[2]) * d2) * ((g2 = a2[9]) * x2 - y2 * (w2 = a2[13])) + (l2 * (m2 = a2[7]) - (p2 = a2[3]) * d2) * (g2 * A2 - v2 * w2) + (c2 * f2 - u2 * h2) * ((_2 = a2[8]) * x2 - y2 * (b2 = a2[12])) - (c2 * m2 - p2 * h2) * (_2 * A2 - v2 * b2) + (u2 * m2 - p2 * f2) * (_2 * w2 - g2 * b2) < 0 && (i2 = -i2), t2[0] = e2[12], t2[1] = e2[13], t2[2] = e2[14];
      const E2 = e2.slice(), C2 = 1 / i2, S2 = 1 / s2, M2 = 1 / o2;
      E2[0] *= C2, E2[1] *= C2, E2[2] *= C2, E2[4] *= S2, E2[5] *= S2, E2[6] *= S2, E2[8] *= M2, E2[9] *= M2, E2[10] *= M2, function(e3, t3) {
        var n3 = new Ib(3);
        !function(e4, t4) {
          var n4 = t4[4], r4 = t4[5], i4 = t4[6], s4 = t4[8], o4 = t4[9], a4 = t4[10];
          e4[0] = Math.hypot(t4[0], t4[1], t4[2]), e4[1] = Math.hypot(n4, r4, i4), e4[2] = Math.hypot(s4, o4, a4);
        }(n3, t3);
        var r3 = 1 / n3[0], i3 = 1 / n3[1], s3 = 1 / n3[2], o3 = t3[0] * r3, a3 = t3[1] * i3, l3 = t3[2] * s3, c3 = t3[4] * r3, u3 = t3[5] * i3, p3 = t3[6] * s3, d3 = t3[8] * r3, h3 = t3[9] * i3, f3 = t3[10] * s3, m3 = o3 + u3 + f3, _3 = 0;
        m3 > 0 ? (_3 = 2 * Math.sqrt(m3 + 1), e3[3] = 0.25 * _3, e3[0] = (p3 - h3) / _3, e3[1] = (d3 - l3) / _3, e3[2] = (a3 - c3) / _3) : o3 > u3 && o3 > f3 ? (_3 = 2 * Math.sqrt(1 + o3 - u3 - f3), e3[3] = (p3 - h3) / _3, e3[0] = 0.25 * _3, e3[1] = (a3 + c3) / _3, e3[2] = (d3 + l3) / _3) : u3 > f3 ? (_3 = 2 * Math.sqrt(1 + u3 - o3 - f3), e3[3] = (d3 - l3) / _3, e3[0] = (a3 + c3) / _3, e3[1] = 0.25 * _3, e3[2] = (p3 + h3) / _3) : (_3 = 2 * Math.sqrt(1 + f3 - o3 - u3), e3[3] = (a3 - c3) / _3, e3[0] = (d3 + l3) / _3, e3[1] = (p3 + h3) / _3, e3[2] = 0.25 * _3);
      }(n2, E2), r2[0] = i2, r2[1] = s2, r2[2] = o2;
    }
    static compose(e2, t2, n2, r2) {
      const i2 = r2, s2 = t2[0], o2 = t2[1], a2 = t2[2], l2 = t2[3], c2 = s2 + s2, u2 = o2 + o2, p2 = a2 + a2, d2 = s2 * c2, h2 = s2 * u2, f2 = s2 * p2, m2 = o2 * u2, _2 = o2 * p2, g2 = a2 * p2, v2 = l2 * c2, y2 = l2 * u2, b2 = l2 * p2, w2 = n2[0], A2 = n2[1], x2 = n2[2];
      return i2[0] = (1 - (m2 + g2)) * w2, i2[1] = (h2 + b2) * w2, i2[2] = (f2 - y2) * w2, i2[3] = 0, i2[4] = (h2 - b2) * A2, i2[5] = (1 - (d2 + g2)) * A2, i2[6] = (_2 + v2) * A2, i2[7] = 0, i2[8] = (f2 + y2) * x2, i2[9] = (_2 - v2) * x2, i2[10] = (1 - (d2 + m2)) * x2, i2[11] = 0, i2[12] = e2[0], i2[13] = e2[1], i2[14] = e2[2], i2[15] = 1, i2;
    }
  }
  function Wb(e2, t2) {
    if (!!e2 != !!t2)
      return false;
    const n2 = e2.getChild(), r2 = t2.getChild();
    return n2 === r2 || n2.equals(r2);
  }
  function qb(e2, t2) {
    if (!!e2 != !!t2)
      return false;
    if (e2.length !== t2.length)
      return false;
    for (let n2 = 0; n2 < e2.length; n2++) {
      const r2 = e2[n2], i2 = t2[n2];
      if (r2.getChild() !== i2.getChild() && !r2.getChild().equals(i2.getChild()))
        return false;
    }
    return true;
  }
  function Xb(e2, t2) {
    if (!!e2 != !!t2)
      return false;
    const n2 = Object.keys(e2), r2 = Object.keys(t2);
    if (n2.length !== r2.length)
      return false;
    for (const n3 in e2) {
      const r3 = e2[n3], i2 = t2[n3];
      if (!!r3 != !!i2)
        return false;
      const s2 = r3.getChild(), o2 = i2.getChild();
      if (s2 !== o2 && !s2.equals(o2))
        return false;
    }
    return true;
  }
  function Yb(e2, t2) {
    if (e2 === t2)
      return true;
    if (!!e2 != !!t2 || !e2 || !t2)
      return false;
    if (e2.length !== t2.length)
      return false;
    for (let n2 = 0; n2 < e2.length; n2++)
      if (e2[n2] !== t2[n2])
        return false;
    return true;
  }
  function Kb(e2, t2) {
    if (e2 === t2)
      return true;
    if (!!e2 != !!t2)
      return false;
    if (!Gb(e2) || !Gb(t2))
      return e2 === t2;
    const n2 = e2, r2 = t2;
    let i2, s2 = 0, o2 = 0;
    for (i2 in n2)
      s2++;
    for (i2 in r2)
      o2++;
    if (s2 !== o2)
      return false;
    for (i2 in n2) {
      const e3 = n2[i2], t3 = r2[i2];
      if (Jb(e3) && Jb(t3)) {
        if (!Yb(e3, t3))
          return false;
      } else if (Gb(e3) && Gb(t3)) {
        if (!Kb(e3, t3))
          return false;
      } else if (e3 !== t3)
        return false;
    }
    return true;
  }
  function Jb(e2) {
    return Array.isArray(e2) || ArrayBuffer.isView(e2);
  }
  const Zb = "23456789abdegjkmnpqrvwxyzABDEGJKMNPQRVWXYZ", $b = /* @__PURE__ */ new Set(), ew = function() {
    let e2 = "";
    for (let t2 = 0; t2 < 6; t2++)
      e2 += Zb.charAt(Math.floor(Math.random() * Zb.length));
    return e2;
  };
  class tw {
    static dirname(e2) {
      const t2 = e2.lastIndexOf("/");
      return -1 === t2 ? "./" : e2.substring(0, t2 + 1);
    }
    static basename(e2) {
      return jb.basename(new URL(e2, "https://null.example").pathname);
    }
    static extension(e2) {
      return jb.extension(new URL(e2, "https://null.example").pathname);
    }
    static resolve(e2, t2) {
      if (!this.isRelativePath(t2))
        return t2;
      const n2 = e2.split("/"), r2 = t2.split("/");
      n2.pop();
      for (let e3 = 0; e3 < r2.length; e3++)
        "." !== r2[e3] && (".." === r2[e3] ? n2.pop() : n2.push(r2[e3]));
      return n2.join("/");
    }
    static isAbsoluteURL(e2) {
      return this.PROTOCOL_REGEXP.test(e2);
    }
    static isRelativePath(e2) {
      return !/^(?:[a-zA-Z]+:)?\//.test(e2);
    }
  }
  tw.DEFAULT_INIT = {}, tw.PROTOCOL_REGEXP = /^[a-zA-Z]+:\/\//;
  const nw = (e2) => e2, rw = /* @__PURE__ */ new Set();
  class iw extends bb {
    constructor(e2, t2 = "") {
      super(e2), this[vb].name = t2, this.init(), this.dispatchEvent({ type: "create" });
    }
    getGraph() {
      return this.graph;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { name: "", extras: {} });
    }
    set(e2, t2) {
      return Array.isArray(t2) && (t2 = t2.slice()), super.set(e2, t2);
    }
    getName() {
      return this.get("name");
    }
    setName(e2) {
      return this.set("name", e2);
    }
    getExtras() {
      return this.get("extras");
    }
    setExtras(e2) {
      return this.set("extras", e2);
    }
    clone() {
      return new (0, this.constructor)(this.graph).copy(this, nw);
    }
    copy(e2, t2 = nw) {
      for (const e3 in this[vb]) {
        const t3 = this[vb][e3];
        if (t3 instanceof db)
          this[yb].has(e3) || t3.dispose();
        else if (_b(t3))
          for (const e4 of t3)
            e4.dispose();
        else if (gb(t3))
          for (const e4 in t3)
            t3[e4].dispose();
      }
      for (const n2 in e2[vb]) {
        const r2 = this[vb][n2], i2 = e2[vb][n2];
        if (i2 instanceof db)
          this[yb].has(n2) ? r2.getChild().copy(t2(i2.getChild()), t2) : this.setRef(n2, t2(i2.getChild()), i2.getAttributes());
        else if (_b(i2))
          for (const e3 of i2)
            this.addRef(n2, t2(e3.getChild()), e3.getAttributes());
        else if (gb(i2))
          for (const e3 in i2) {
            const r3 = i2[e3];
            this.setRefMap(n2, e3, t2(r3.getChild()), r3.getAttributes());
          }
        else
          this[vb][n2] = Gb(i2) ? JSON.parse(JSON.stringify(i2)) : Array.isArray(i2) || i2 instanceof ArrayBuffer || ArrayBuffer.isView(i2) ? i2.slice() : i2;
      }
      return this;
    }
    equals(e2, t2 = rw) {
      if (this === e2)
        return true;
      if (this.propertyType !== e2.propertyType)
        return false;
      for (const n2 in this[vb]) {
        if (t2.has(n2))
          continue;
        const r2 = this[vb][n2], i2 = e2[vb][n2];
        if (mb(r2) || mb(i2)) {
          if (!Wb(r2, i2))
            return false;
        } else if (_b(r2) || _b(i2)) {
          if (!qb(r2, i2))
            return false;
        } else if (gb(r2) || gb(i2)) {
          if (!Xb(r2, i2))
            return false;
        } else if (Gb(r2) || Gb(i2)) {
          if (!Kb(r2, i2))
            return false;
        } else if (Jb(r2) || Jb(i2)) {
          if (!Yb(r2, i2))
            return false;
        } else if (r2 !== i2)
          return false;
      }
      return true;
    }
    detach() {
      return this.graph.disconnectParents(this, (e2) => "Root" !== e2.propertyType), this;
    }
    listParents() {
      return this.graph.listParents(this);
    }
  }
  class sw extends iw {
    getDefaults() {
      return Object.assign(super.getDefaults(), { extensions: {} });
    }
    getExtension(e2) {
      return this.getRefMap("extensions", e2);
    }
    setExtension(e2, t2) {
      return t2 && t2.t(this), this.setRefMap("extensions", e2, t2);
    }
    listExtensions() {
      return this.listRefMapValues("extensions");
    }
  }
  class ow extends sw {
    constructor(...e2) {
      super(...e2), this.i = Qb.identity, this.o = Qb.identity;
    }
    init() {
      this.propertyType = Ab.ACCESSOR;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { array: null, type: ow.Type.SCALAR, componentType: ow.ComponentType.FLOAT, normalized: false, sparse: false, buffer: null });
    }
    copy(e2, t2 = nw) {
      return super.copy(e2, t2), this.i = e2.i, this.o = e2.o, this;
    }
    static getElementSize(e2) {
      switch (e2) {
        case ow.Type.SCALAR:
          return 1;
        case ow.Type.VEC2:
          return 2;
        case ow.Type.VEC3:
          return 3;
        case ow.Type.VEC4:
        case ow.Type.MAT2:
          return 4;
        case ow.Type.MAT3:
          return 9;
        case ow.Type.MAT4:
          return 16;
        default:
          throw new Error("Unexpected type: " + e2);
      }
    }
    static getComponentSize(e2) {
      switch (e2) {
        case ow.ComponentType.BYTE:
        case ow.ComponentType.UNSIGNED_BYTE:
          return 1;
        case ow.ComponentType.SHORT:
        case ow.ComponentType.UNSIGNED_SHORT:
          return 2;
        case ow.ComponentType.UNSIGNED_INT:
        case ow.ComponentType.FLOAT:
          return 4;
        default:
          throw new Error("Unexpected component type: " + e2);
      }
    }
    getMinNormalized(e2) {
      const t2 = this.getElementSize();
      this.getMin(e2);
      for (let n2 = 0; n2 < t2; n2++)
        e2[n2] = this.o(e2[n2]);
      return e2;
    }
    getMin(e2) {
      const t2 = this.get("array"), n2 = this.getCount(), r2 = this.getElementSize();
      for (let t3 = 0; t3 < r2; t3++)
        e2[t3] = 1 / 0;
      for (let i2 = 0; i2 < n2 * r2; i2 += r2)
        for (let n3 = 0; n3 < r2; n3++) {
          const r3 = t2[i2 + n3];
          Number.isFinite(r3) && (e2[n3] = Math.min(e2[n3], r3));
        }
      return e2;
    }
    getMaxNormalized(e2) {
      const t2 = this.getElementSize();
      this.getMax(e2);
      for (let n2 = 0; n2 < t2; n2++)
        e2[n2] = this.o(e2[n2]);
      return e2;
    }
    getMax(e2) {
      const t2 = this.get("array"), n2 = this.getCount(), r2 = this.getElementSize();
      for (let t3 = 0; t3 < r2; t3++)
        e2[t3] = -1 / 0;
      for (let i2 = 0; i2 < n2 * r2; i2 += r2)
        for (let n3 = 0; n3 < r2; n3++) {
          const r3 = t2[i2 + n3];
          Number.isFinite(r3) && (e2[n3] = Math.max(e2[n3], r3));
        }
      return e2;
    }
    getCount() {
      const e2 = this.get("array");
      return e2 ? e2.length / this.getElementSize() : 0;
    }
    getType() {
      return this.get("type");
    }
    setType(e2) {
      return this.set("type", e2);
    }
    getElementSize() {
      return ow.getElementSize(this.get("type"));
    }
    getComponentSize() {
      return this.get("array").BYTES_PER_ELEMENT;
    }
    getComponentType() {
      return this.get("componentType");
    }
    getNormalized() {
      return this.get("normalized");
    }
    setNormalized(e2) {
      return this.set("normalized", e2), e2 ? (this.o = (e3) => Qb.decodeNormalizedInt(e3, this.get("componentType")), this.i = (e3) => Qb.encodeNormalizedInt(e3, this.get("componentType"))) : (this.o = Qb.identity, this.i = Qb.identity), this;
    }
    getScalar(e2) {
      const t2 = this.getElementSize();
      return this.o(this.get("array")[e2 * t2]);
    }
    setScalar(e2, t2) {
      return this.get("array")[e2 * this.getElementSize()] = this.i(t2), this;
    }
    getElement(e2, t2) {
      const n2 = this.getElementSize(), r2 = this.get("array");
      for (let i2 = 0; i2 < n2; i2++)
        t2[i2] = this.o(r2[e2 * n2 + i2]);
      return t2;
    }
    setElement(e2, t2) {
      const n2 = this.getElementSize(), r2 = this.get("array");
      for (let i2 = 0; i2 < n2; i2++)
        r2[e2 * n2 + i2] = this.i(t2[i2]);
      return this;
    }
    getSparse() {
      return this.get("sparse");
    }
    setSparse(e2) {
      return this.set("sparse", e2);
    }
    getBuffer() {
      return this.getRef("buffer");
    }
    setBuffer(e2) {
      return this.setRef("buffer", e2);
    }
    getArray() {
      return this.get("array");
    }
    setArray(e2) {
      return this.set("componentType", e2 ? function(e3) {
        switch (e3.constructor) {
          case Float32Array:
            return ow.ComponentType.FLOAT;
          case Uint32Array:
            return ow.ComponentType.UNSIGNED_INT;
          case Uint16Array:
            return ow.ComponentType.UNSIGNED_SHORT;
          case Uint8Array:
            return ow.ComponentType.UNSIGNED_BYTE;
          case Int16Array:
            return ow.ComponentType.SHORT;
          case Int8Array:
            return ow.ComponentType.BYTE;
          default:
            throw new Error("Unknown accessor componentType.");
        }
      }(e2) : ow.ComponentType.FLOAT), this.set("array", e2), this;
    }
    getByteLength() {
      const e2 = this.get("array");
      return e2 ? e2.byteLength : 0;
    }
  }
  ow.Type = { SCALAR: "SCALAR", VEC2: "VEC2", VEC3: "VEC3", VEC4: "VEC4", MAT2: "MAT2", MAT3: "MAT3", MAT4: "MAT4" }, ow.ComponentType = { BYTE: 5120, UNSIGNED_BYTE: 5121, SHORT: 5122, UNSIGNED_SHORT: 5123, UNSIGNED_INT: 5125, FLOAT: 5126 };
  class aw extends sw {
    init() {
      this.propertyType = Ab.ANIMATION;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { channels: [], samplers: [] });
    }
    addChannel(e2) {
      return this.addRef("channels", e2);
    }
    removeChannel(e2) {
      return this.removeRef("channels", e2);
    }
    listChannels() {
      return this.listRefs("channels");
    }
    addSampler(e2) {
      return this.addRef("samplers", e2);
    }
    removeSampler(e2) {
      return this.removeRef("samplers", e2);
    }
    listSamplers() {
      return this.listRefs("samplers");
    }
  }
  class lw extends sw {
    init() {
      this.propertyType = Ab.ANIMATION_CHANNEL;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { targetPath: null, targetNode: null, sampler: null });
    }
    getTargetPath() {
      return this.get("targetPath");
    }
    setTargetPath(e2) {
      return this.set("targetPath", e2);
    }
    getTargetNode() {
      return this.getRef("targetNode");
    }
    setTargetNode(e2) {
      return this.setRef("targetNode", e2);
    }
    getSampler() {
      return this.getRef("sampler");
    }
    setSampler(e2) {
      return this.setRef("sampler", e2);
    }
  }
  lw.TargetPath = { TRANSLATION: "translation", ROTATION: "rotation", SCALE: "scale", WEIGHTS: "weights" };
  class cw extends sw {
    init() {
      this.propertyType = Ab.ANIMATION_SAMPLER;
    }
    getDefaultAttributes() {
      return Object.assign(super.getDefaults(), { interpolation: cw.Interpolation.LINEAR, input: null, output: null });
    }
    getInterpolation() {
      return this.get("interpolation");
    }
    setInterpolation(e2) {
      return this.set("interpolation", e2);
    }
    getInput() {
      return this.getRef("input");
    }
    setInput(e2) {
      return this.setRef("input", e2, { usage: Eb.OTHER });
    }
    getOutput() {
      return this.getRef("output");
    }
    setOutput(e2) {
      return this.setRef("output", e2, { usage: Eb.OTHER });
    }
  }
  cw.Interpolation = { LINEAR: "LINEAR", STEP: "STEP", CUBICSPLINE: "CUBICSPLINE" };
  class uw extends sw {
    init() {
      this.propertyType = Ab.BUFFER;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { uri: "" });
    }
    getURI() {
      return this.get("uri");
    }
    setURI(e2) {
      return this.set("uri", e2);
    }
  }
  class pw extends sw {
    init() {
      this.propertyType = Ab.CAMERA;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { type: pw.Type.PERSPECTIVE, znear: 0.1, zfar: 100, aspectRatio: null, yfov: 2 * Math.PI * 50 / 360, xmag: 1, ymag: 1 });
    }
    getType() {
      return this.get("type");
    }
    setType(e2) {
      return this.set("type", e2);
    }
    getZNear() {
      return this.get("znear");
    }
    setZNear(e2) {
      return this.set("znear", e2);
    }
    getZFar() {
      return this.get("zfar");
    }
    setZFar(e2) {
      return this.set("zfar", e2);
    }
    getAspectRatio() {
      return this.get("aspectRatio");
    }
    setAspectRatio(e2) {
      return this.set("aspectRatio", e2);
    }
    getYFov() {
      return this.get("yfov");
    }
    setYFov(e2) {
      return this.set("yfov", e2);
    }
    getXMag() {
      return this.get("xmag");
    }
    setXMag(e2) {
      return this.set("xmag", e2);
    }
    getYMag() {
      return this.get("ymag");
    }
    setYMag(e2) {
      return this.set("ymag", e2);
    }
  }
  pw.Type = { PERSPECTIVE: "perspective", ORTHOGRAPHIC: "orthographic" };
  class dw extends iw {
    t(e2) {
      if (!this.parentTypes.includes(e2.propertyType))
        throw new Error(`Parent "${e2.propertyType}" invalid for child "${this.propertyType}".`);
    }
  }
  dw.EXTENSION_NAME = void 0;
  class hw extends sw {
    init() {
      this.propertyType = Ab.TEXTURE_INFO;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { texCoord: 0, magFilter: null, minFilter: null, wrapS: hw.WrapMode.REPEAT, wrapT: hw.WrapMode.REPEAT });
    }
    getTexCoord() {
      return this.get("texCoord");
    }
    setTexCoord(e2) {
      return this.set("texCoord", e2);
    }
    getMagFilter() {
      return this.get("magFilter");
    }
    setMagFilter(e2) {
      return this.set("magFilter", e2);
    }
    getMinFilter() {
      return this.get("minFilter");
    }
    setMinFilter(e2) {
      return this.set("minFilter", e2);
    }
    getWrapS() {
      return this.get("wrapS");
    }
    setWrapS(e2) {
      return this.set("wrapS", e2);
    }
    getWrapT() {
      return this.get("wrapT");
    }
    setWrapT(e2) {
      return this.set("wrapT", e2);
    }
  }
  hw.WrapMode = { CLAMP_TO_EDGE: 33071, MIRRORED_REPEAT: 33648, REPEAT: 10497 }, hw.MagFilter = { NEAREST: 9728, LINEAR: 9729 }, hw.MinFilter = { NEAREST: 9728, LINEAR: 9729, NEAREST_MIPMAP_NEAREST: 9984, LINEAR_MIPMAP_NEAREST: 9985, NEAREST_MIPMAP_LINEAR: 9986, LINEAR_MIPMAP_LINEAR: 9987 };
  const { R: fw, G: mw, B: _w, A: gw } = Cb;
  class vw extends sw {
    init() {
      this.propertyType = Ab.MATERIAL;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { alphaMode: vw.AlphaMode.OPAQUE, alphaCutoff: 0.5, doubleSided: false, baseColorFactor: [1, 1, 1, 1], baseColorTexture: null, baseColorTextureInfo: new hw(this.graph, "baseColorTextureInfo"), emissiveFactor: [0, 0, 0], emissiveTexture: null, emissiveTextureInfo: new hw(this.graph, "emissiveTextureInfo"), normalScale: 1, normalTexture: null, normalTextureInfo: new hw(this.graph, "normalTextureInfo"), occlusionStrength: 1, occlusionTexture: null, occlusionTextureInfo: new hw(this.graph, "occlusionTextureInfo"), roughnessFactor: 1, metallicFactor: 1, metallicRoughnessTexture: null, metallicRoughnessTextureInfo: new hw(this.graph, "metallicRoughnessTextureInfo") });
    }
    getDoubleSided() {
      return this.get("doubleSided");
    }
    setDoubleSided(e2) {
      return this.set("doubleSided", e2);
    }
    getAlpha() {
      return this.get("baseColorFactor")[3];
    }
    setAlpha(e2) {
      const t2 = this.get("baseColorFactor").slice();
      return t2[3] = e2, this.set("baseColorFactor", t2);
    }
    getAlphaMode() {
      return this.get("alphaMode");
    }
    setAlphaMode(e2) {
      return this.set("alphaMode", e2);
    }
    getAlphaCutoff() {
      return this.get("alphaCutoff");
    }
    setAlphaCutoff(e2) {
      return this.set("alphaCutoff", e2);
    }
    getBaseColorFactor() {
      return this.get("baseColorFactor");
    }
    setBaseColorFactor(e2) {
      return this.set("baseColorFactor", e2);
    }
    getBaseColorHex() {
      return Lb.factorToHex(this.get("baseColorFactor"));
    }
    setBaseColorHex(e2) {
      const t2 = this.get("baseColorFactor").slice();
      return this.set("baseColorFactor", Lb.hexToFactor(e2, t2));
    }
    getBaseColorTexture() {
      return this.getRef("baseColorTexture");
    }
    getBaseColorTextureInfo() {
      return this.getRef("baseColorTexture") ? this.getRef("baseColorTextureInfo") : null;
    }
    setBaseColorTexture(e2) {
      return this.setRef("baseColorTexture", e2, { channels: fw | mw | _w | gw });
    }
    getEmissiveFactor() {
      return this.get("emissiveFactor");
    }
    setEmissiveFactor(e2) {
      return this.set("emissiveFactor", e2);
    }
    getEmissiveHex() {
      return Lb.factorToHex(this.get("emissiveFactor"));
    }
    setEmissiveHex(e2) {
      const t2 = this.get("emissiveFactor").slice();
      return this.set("emissiveFactor", Lb.hexToFactor(e2, t2));
    }
    getEmissiveTexture() {
      return this.getRef("emissiveTexture");
    }
    getEmissiveTextureInfo() {
      return this.getRef("emissiveTexture") ? this.getRef("emissiveTextureInfo") : null;
    }
    setEmissiveTexture(e2) {
      return this.setRef("emissiveTexture", e2, { channels: fw | mw | _w });
    }
    getNormalScale() {
      return this.get("normalScale");
    }
    setNormalScale(e2) {
      return this.set("normalScale", e2);
    }
    getNormalTexture() {
      return this.getRef("normalTexture");
    }
    getNormalTextureInfo() {
      return this.getRef("normalTexture") ? this.getRef("normalTextureInfo") : null;
    }
    setNormalTexture(e2) {
      return this.setRef("normalTexture", e2, { channels: fw | mw | _w });
    }
    getOcclusionStrength() {
      return this.get("occlusionStrength");
    }
    setOcclusionStrength(e2) {
      return this.set("occlusionStrength", e2);
    }
    getOcclusionTexture() {
      return this.getRef("occlusionTexture");
    }
    getOcclusionTextureInfo() {
      return this.getRef("occlusionTexture") ? this.getRef("occlusionTextureInfo") : null;
    }
    setOcclusionTexture(e2) {
      return this.setRef("occlusionTexture", e2, { channels: fw });
    }
    getRoughnessFactor() {
      return this.get("roughnessFactor");
    }
    setRoughnessFactor(e2) {
      return this.set("roughnessFactor", e2);
    }
    getMetallicFactor() {
      return this.get("metallicFactor");
    }
    setMetallicFactor(e2) {
      return this.set("metallicFactor", e2);
    }
    getMetallicRoughnessTexture() {
      return this.getRef("metallicRoughnessTexture");
    }
    getMetallicRoughnessTextureInfo() {
      return this.getRef("metallicRoughnessTexture") ? this.getRef("metallicRoughnessTextureInfo") : null;
    }
    setMetallicRoughnessTexture(e2) {
      return this.setRef("metallicRoughnessTexture", e2, { channels: mw | _w });
    }
  }
  vw.AlphaMode = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
  class yw extends sw {
    init() {
      this.propertyType = Ab.MESH;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { weights: [], primitives: [] });
    }
    addPrimitive(e2) {
      return this.addRef("primitives", e2);
    }
    removePrimitive(e2) {
      return this.removeRef("primitives", e2);
    }
    listPrimitives() {
      return this.listRefs("primitives");
    }
    getWeights() {
      return this.get("weights");
    }
    setWeights(e2) {
      return this.set("weights", e2);
    }
  }
  class bw extends sw {
    constructor(...e2) {
      super(...e2), this.u = null;
    }
    init() {
      this.propertyType = Ab.NODE;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { translation: [0, 0, 0], rotation: [0, 0, 0, 1], scale: [1, 1, 1], weights: [], camera: null, mesh: null, skin: null, children: [] });
    }
    copy(e2, t2 = nw) {
      if (t2 === nw)
        throw new Error("Node cannot be copied.");
      return super.copy(e2, t2);
    }
    getTranslation() {
      return this.get("translation");
    }
    getRotation() {
      return this.get("rotation");
    }
    getScale() {
      return this.get("scale");
    }
    setTranslation(e2) {
      return this.set("translation", e2);
    }
    setRotation(e2) {
      return this.set("rotation", e2);
    }
    setScale(e2) {
      return this.set("scale", e2);
    }
    getMatrix() {
      return Qb.compose(this.get("translation"), this.get("rotation"), this.get("scale"), []);
    }
    setMatrix(e2) {
      const t2 = this.get("translation").slice(), n2 = this.get("rotation").slice(), r2 = this.get("scale").slice();
      return Qb.decompose(e2, t2, n2, r2), this.set("translation", t2).set("rotation", n2).set("scale", r2);
    }
    getWorldTranslation() {
      const e2 = [0, 0, 0];
      return Qb.decompose(this.getWorldMatrix(), e2, [0, 0, 0, 1], [1, 1, 1]), e2;
    }
    getWorldRotation() {
      const e2 = [0, 0, 0, 1];
      return Qb.decompose(this.getWorldMatrix(), [0, 0, 0], e2, [1, 1, 1]), e2;
    }
    getWorldScale() {
      const e2 = [1, 1, 1];
      return Qb.decompose(this.getWorldMatrix(), [0, 0, 0], [0, 0, 0, 1], e2), e2;
    }
    getWorldMatrix() {
      const e2 = [];
      for (let t3 = this; null != t3; t3 = t3.u)
        e2.push(t3);
      let t2;
      const n2 = e2.pop().getMatrix();
      for (; t2 = e2.pop(); )
        Hb(n2, n2, t2.getMatrix());
      return n2;
    }
    addChild(e2) {
      e2.u && e2.u.removeChild(e2), this.addRef("children", e2), e2.u = this;
      const t2 = this[vb].children;
      return t2[t2.length - 1].addEventListener("dispose", () => e2.u = null), this;
    }
    removeChild(e2) {
      return this.removeRef("children", e2);
    }
    listChildren() {
      return this.listRefs("children");
    }
    getParent() {
      return this.u ? this.u : this.listParents().find((e2) => e2.propertyType === Ab.SCENE) || null;
    }
    getParentNode() {
      return this.u;
    }
    getMesh() {
      return this.getRef("mesh");
    }
    setMesh(e2) {
      return this.setRef("mesh", e2);
    }
    getCamera() {
      return this.getRef("camera");
    }
    setCamera(e2) {
      return this.setRef("camera", e2);
    }
    getSkin() {
      return this.getRef("skin");
    }
    setSkin(e2) {
      return this.setRef("skin", e2);
    }
    getWeights() {
      return this.get("weights");
    }
    setWeights(e2) {
      return this.set("weights", e2);
    }
    traverse(e2) {
      e2(this);
      for (const t2 of this.listChildren())
        t2.traverse(e2);
      return this;
    }
  }
  class ww extends sw {
    init() {
      this.propertyType = Ab.PRIMITIVE;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { mode: ww.Mode.TRIANGLES, material: null, indices: null, attributes: {}, targets: [] });
    }
    getIndices() {
      return this.getRef("indices");
    }
    setIndices(e2) {
      return this.setRef("indices", e2, { usage: Eb.ELEMENT_ARRAY_BUFFER });
    }
    getAttribute(e2) {
      return this.getRefMap("attributes", e2);
    }
    setAttribute(e2, t2) {
      return this.setRefMap("attributes", e2, t2, { usage: Eb.ARRAY_BUFFER });
    }
    listAttributes() {
      return this.listRefMapValues("attributes");
    }
    listSemantics() {
      return this.listRefMapKeys("attributes");
    }
    getMaterial() {
      return this.getRef("material");
    }
    setMaterial(e2) {
      return this.setRef("material", e2);
    }
    getMode() {
      return this.get("mode");
    }
    setMode(e2) {
      return this.set("mode", e2);
    }
    listTargets() {
      return this.listRefs("targets");
    }
    addTarget(e2) {
      return this.addRef("targets", e2);
    }
    removeTarget(e2) {
      return this.removeRef("targets", e2);
    }
  }
  ww.Mode = { POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6 };
  class Aw extends iw {
    init() {
      this.propertyType = Ab.PRIMITIVE_TARGET;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { attributes: {} });
    }
    getAttribute(e2) {
      return this.getRefMap("attributes", e2);
    }
    setAttribute(e2, t2) {
      return this.setRefMap("attributes", e2, t2, { usage: Eb.ARRAY_BUFFER });
    }
    listAttributes() {
      return this.listRefMapValues("attributes");
    }
    listSemantics() {
      return this.listRefMapKeys("attributes");
    }
  }
  function xw() {
    return (xw = Object.assign || function(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var n2 = arguments[t2];
        for (var r2 in n2)
          Object.prototype.hasOwnProperty.call(n2, r2) && (e2[r2] = n2[r2]);
      }
      return e2;
    }).apply(this, arguments);
  }
  class Ew extends sw {
    init() {
      this.propertyType = Ab.SCENE;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { children: [] });
    }
    copy(e2, t2 = nw) {
      if (t2 === nw)
        throw new Error("Scene cannot be copied.");
      return super.copy(e2, t2);
    }
    addChild(e2) {
      return this.addRef("children", e2);
    }
    removeChild(e2) {
      return this.removeRef("children", e2);
    }
    listChildren() {
      return this.listRefs("children");
    }
    traverse(e2) {
      for (const t2 of this.listChildren())
        t2.traverse(e2);
      return this;
    }
  }
  class Cw extends sw {
    init() {
      this.propertyType = Ab.SKIN;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { skeleton: null, inverseBindMatrices: null, joints: [] });
    }
    getSkeleton() {
      return this.getRef("skeleton");
    }
    setSkeleton(e2) {
      return this.setRef("skeleton", e2);
    }
    getInverseBindMatrices() {
      return this.getRef("inverseBindMatrices");
    }
    setInverseBindMatrices(e2) {
      return this.setRef("inverseBindMatrices", e2, { usage: Eb.INVERSE_BIND_MATRICES });
    }
    addJoint(e2) {
      return this.addRef("joints", e2);
    }
    removeJoint(e2) {
      return this.removeRef("joints", e2);
    }
    listJoints() {
      return this.listRefs("joints");
    }
  }
  class Sw extends sw {
    init() {
      this.propertyType = Ab.TEXTURE;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { image: null, mimeType: "", uri: "" });
    }
    getMimeType() {
      return this.get("mimeType") || Fb.extensionToMimeType(jb.extension(this.get("uri")));
    }
    setMimeType(e2) {
      return this.set("mimeType", e2);
    }
    getURI() {
      return this.get("uri");
    }
    setURI(e2) {
      this.set("uri", e2);
      const t2 = Fb.extensionToMimeType(jb.extension(e2));
      return t2 && this.set("mimeType", t2), this;
    }
    getImage() {
      return this.get("image");
    }
    setImage(e2) {
      return this.set("image", Ob.assertView(e2));
    }
    getSize() {
      const e2 = this.get("image");
      return e2 ? Fb.getSize(e2, this.getMimeType()) : null;
    }
  }
  class Mw extends sw {
    init() {
      this.propertyType = Ab.ROOT;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { asset: { generator: "glTF-Transform v3.2.1", version: "2.0" }, defaultScene: null, accessors: [], animations: [], buffers: [], cameras: [], materials: [], meshes: [], nodes: [], scenes: [], skins: [], textures: [] });
    }
    constructor(e2) {
      super(e2), this.h = /* @__PURE__ */ new Set(), e2.addEventListener("node:create", (e3) => {
        this.l(e3.target);
      });
    }
    clone() {
      throw new Error("Root cannot be cloned.");
    }
    copy(e2, t2 = nw) {
      if (t2 === nw)
        throw new Error("Root cannot be copied.");
      this.set("asset", xw({}, e2.get("asset"))), this.setName(e2.getName()), this.setExtras(xw({}, e2.getExtras())), this.setDefaultScene(e2.getDefaultScene() ? t2(e2.getDefaultScene()) : null);
      for (const n2 of e2.listRefMapKeys("extensions")) {
        const r2 = e2.getExtension(n2);
        this.setExtension(n2, t2(r2));
      }
      return this;
    }
    l(e2) {
      return e2 instanceof Ew ? this.addRef("scenes", e2) : e2 instanceof bw ? this.addRef("nodes", e2) : e2 instanceof pw ? this.addRef("cameras", e2) : e2 instanceof Cw ? this.addRef("skins", e2) : e2 instanceof yw ? this.addRef("meshes", e2) : e2 instanceof vw ? this.addRef("materials", e2) : e2 instanceof Sw ? this.addRef("textures", e2) : e2 instanceof aw ? this.addRef("animations", e2) : e2 instanceof ow ? this.addRef("accessors", e2) : e2 instanceof uw && this.addRef("buffers", e2), this;
    }
    getAsset() {
      return this.get("asset");
    }
    listExtensionsUsed() {
      return Array.from(this.h);
    }
    listExtensionsRequired() {
      return this.listExtensionsUsed().filter((e2) => e2.isRequired());
    }
    g(e2) {
      return this.h.add(e2), this;
    }
    p(e2) {
      return this.h.delete(e2), this;
    }
    listScenes() {
      return this.listRefs("scenes");
    }
    setDefaultScene(e2) {
      return this.setRef("defaultScene", e2);
    }
    getDefaultScene() {
      return this.getRef("defaultScene");
    }
    listNodes() {
      return this.listRefs("nodes");
    }
    listCameras() {
      return this.listRefs("cameras");
    }
    listSkins() {
      return this.listRefs("skins");
    }
    listMeshes() {
      return this.listRefs("meshes");
    }
    listMaterials() {
      return this.listRefs("materials");
    }
    listTextures() {
      return this.listRefs("textures");
    }
    listAnimations() {
      return this.listRefs("animations");
    }
    listAccessors() {
      return this.listRefs("accessors");
    }
    listBuffers() {
      return this.listRefs("buffers");
    }
  }
  class Tw {
    static fromGraph(e2) {
      return Tw.m.get(e2) || null;
    }
    constructor() {
      this.v = new hb(), this.T = new Mw(this.v), this.M = Vb.DEFAULT_INSTANCE, Tw.m.set(this.v, this);
    }
    getRoot() {
      return this.T;
    }
    getGraph() {
      return this.v;
    }
    getLogger() {
      return this.M;
    }
    setLogger(e2) {
      return this.M = e2, this;
    }
    clone() {
      return new Tw().setLogger(this.M).merge(this);
    }
    merge(e2) {
      for (const t3 of e2.getRoot().listExtensionsUsed()) {
        const e3 = this.createExtension(t3.constructor);
        t3.isRequired() && e3.setRequired(true);
      }
      const t2 = /* @__PURE__ */ new Set(), n2 = /* @__PURE__ */ new Map();
      t2.add(e2.T), n2.set(e2.T, this.T);
      for (const r3 of e2.v.listEdges())
        for (const e3 of [r3.getParent(), r3.getChild()]) {
          if (t2.has(e3))
            continue;
          let r4;
          r4 = e3.propertyType === Ab.TEXTURE_INFO ? e3 : new (0, e3.constructor)(this.v), n2.set(e3, r4), t2.add(e3);
        }
      const r2 = (e3) => {
        const t3 = n2.get(e3);
        if (!t3)
          throw new Error("Could resolve property.");
        return t3;
      };
      for (const e3 of t2) {
        const t3 = n2.get(e3);
        if (!t3)
          throw new Error("Could resolve property.");
        t3.propertyType !== Ab.TEXTURE_INFO && t3.copy(e3, r2);
      }
      return this;
    }
    async transform(...e2) {
      const t2 = e2.map((e3) => e3.name);
      for (const n2 of e2)
        await n2(this, { stack: t2 });
      return this;
    }
    createExtension(e2) {
      const t2 = e2.EXTENSION_NAME;
      return this.getRoot().listExtensionsUsed().find((e3) => e3.extensionName === t2) || new e2(this);
    }
    createScene(e2 = "") {
      return new Ew(this.v, e2);
    }
    createNode(e2 = "") {
      return new bw(this.v, e2);
    }
    createCamera(e2 = "") {
      return new pw(this.v, e2);
    }
    createSkin(e2 = "") {
      return new Cw(this.v, e2);
    }
    createMesh(e2 = "") {
      return new yw(this.v, e2);
    }
    createPrimitive() {
      return new ww(this.v);
    }
    createPrimitiveTarget(e2 = "") {
      return new Aw(this.v, e2);
    }
    createMaterial(e2 = "") {
      return new vw(this.v, e2);
    }
    createTexture(e2 = "") {
      return new Sw(this.v, e2);
    }
    createAnimation(e2 = "") {
      return new aw(this.v, e2);
    }
    createAnimationChannel(e2 = "") {
      return new lw(this.v, e2);
    }
    createAnimationSampler(e2 = "") {
      return new cw(this.v, e2);
    }
    createAccessor(e2 = "", t2 = null) {
      return t2 || (t2 = this.getRoot().listBuffers()[0]), new ow(this.v, e2).setBuffer(t2);
    }
    createBuffer(e2 = "") {
      return new uw(this.v, e2);
    }
  }
  Tw.m = /* @__PURE__ */ new WeakMap();
  class Pw {
    constructor(e2) {
      this.extensionName = "", this.prereadTypes = [], this.prewriteTypes = [], this.readDependencies = [], this.writeDependencies = [], this.document = void 0, this.required = false, this.properties = /* @__PURE__ */ new Set(), this.S = void 0, this.document = e2, e2.getRoot().g(this), this.S = (e3) => {
        const t3 = e3, n2 = t3.target;
        n2 instanceof dw && n2.extensionName === this.extensionName && ("node:create" === t3.type && this.I(n2), "node:dispose" === t3.type && this.N(n2));
      };
      const t2 = e2.getGraph();
      t2.addEventListener("node:create", this.S), t2.addEventListener("node:dispose", this.S);
    }
    dispose() {
      this.document.getRoot().p(this);
      const e2 = this.document.getGraph();
      e2.removeEventListener("node:create", this.S), e2.removeEventListener("node:dispose", this.S);
      for (const e3 of this.properties)
        e3.dispose();
    }
    static register() {
    }
    isRequired() {
      return this.required;
    }
    setRequired(e2) {
      return this.required = e2, this;
    }
    listProperties() {
      return Array.from(this.properties);
    }
    I(e2) {
      return this.properties.add(e2), this;
    }
    N(e2) {
      return this.properties.delete(e2), this;
    }
    install(e2, t2) {
      return this;
    }
    preread(e2, t2) {
      return this;
    }
    prewrite(e2, t2) {
      return this;
    }
  }
  Pw.EXTENSION_NAME = void 0;
  class Iw {
    constructor(e2) {
      this.jsonDoc = void 0, this.buffers = [], this.bufferViews = [], this.bufferViewBuffers = [], this.accessors = [], this.textures = [], this.textureInfos = /* @__PURE__ */ new Map(), this.materials = [], this.meshes = [], this.cameras = [], this.nodes = [], this.skins = [], this.animations = [], this.scenes = [], this.jsonDoc = e2;
    }
    setTextureInfo(e2, t2) {
      this.textureInfos.set(e2, t2), void 0 !== t2.texCoord && e2.setTexCoord(t2.texCoord), void 0 !== t2.extras && e2.setExtras(t2.extras);
      const n2 = this.jsonDoc.json.textures[t2.index];
      if (void 0 === n2.sampler)
        return;
      const r2 = this.jsonDoc.json.samplers[n2.sampler];
      void 0 !== r2.magFilter && e2.setMagFilter(r2.magFilter), void 0 !== r2.minFilter && e2.setMinFilter(r2.minFilter), void 0 !== r2.wrapS && e2.setWrapS(r2.wrapS), void 0 !== r2.wrapT && e2.setWrapT(r2.wrapT);
    }
  }
  const Rw = { logger: Vb.DEFAULT_INSTANCE, extensions: [], dependencies: {} };
  function kw(e2, t2) {
    const n2 = t2.bufferViews[e2.bufferView], r2 = t2.jsonDoc.json.bufferViews[e2.bufferView], i2 = Mb[e2.componentType], s2 = ow.getElementSize(e2.type), o2 = i2.BYTES_PER_ELEMENT;
    if (void 0 !== r2.byteStride && r2.byteStride !== s2 * o2)
      return function(e3, t3) {
        const n3 = t3.bufferViews[e3.bufferView], r3 = t3.jsonDoc.json.bufferViews[e3.bufferView], i3 = Mb[e3.componentType], s3 = ow.getElementSize(e3.type), o3 = i3.BYTES_PER_ELEMENT, a3 = e3.byteOffset || 0, l2 = new i3(e3.count * s3), c2 = new DataView(n3.buffer, n3.byteOffset, n3.byteLength), u2 = r3.byteStride;
        for (let t4 = 0; t4 < e3.count; t4++)
          for (let n4 = 0; n4 < s3; n4++) {
            const r4 = a3 + t4 * u2 + n4 * o3;
            let i4;
            switch (e3.componentType) {
              case ow.ComponentType.FLOAT:
                i4 = c2.getFloat32(r4, true);
                break;
              case ow.ComponentType.UNSIGNED_INT:
                i4 = c2.getUint32(r4, true);
                break;
              case ow.ComponentType.UNSIGNED_SHORT:
                i4 = c2.getUint16(r4, true);
                break;
              case ow.ComponentType.UNSIGNED_BYTE:
                i4 = c2.getUint8(r4);
                break;
              case ow.ComponentType.SHORT:
                i4 = c2.getInt16(r4, true);
                break;
              case ow.ComponentType.BYTE:
                i4 = c2.getInt8(r4);
                break;
              default:
                throw new Error(`Unexpected componentType "${e3.componentType}".`);
            }
            l2[t4 * s3 + n4] = i4;
          }
        return l2;
      }(e2, t2);
    const a2 = n2.byteOffset + (e2.byteOffset || 0);
    return new i2(n2.buffer.slice(a2, a2 + e2.count * s2 * o2));
  }
  var Dw;
  !function(e2) {
    e2[e2.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", e2[e2.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER";
  }(Dw || (Dw = {}));
  class Bw {
    constructor(e2, t2, n2) {
      this.O = void 0, this.jsonDoc = void 0, this.options = void 0, this.accessorIndexMap = /* @__PURE__ */ new Map(), this.animationIndexMap = /* @__PURE__ */ new Map(), this.bufferIndexMap = /* @__PURE__ */ new Map(), this.cameraIndexMap = /* @__PURE__ */ new Map(), this.skinIndexMap = /* @__PURE__ */ new Map(), this.materialIndexMap = /* @__PURE__ */ new Map(), this.meshIndexMap = /* @__PURE__ */ new Map(), this.nodeIndexMap = /* @__PURE__ */ new Map(), this.imageIndexMap = /* @__PURE__ */ new Map(), this.textureDefIndexMap = /* @__PURE__ */ new Map(), this.textureInfoDefMap = /* @__PURE__ */ new Map(), this.samplerDefIndexMap = /* @__PURE__ */ new Map(), this.sceneIndexMap = /* @__PURE__ */ new Map(), this.imageBufferViews = [], this.otherBufferViews = /* @__PURE__ */ new Map(), this.otherBufferViewsIndexMap = /* @__PURE__ */ new Map(), this.extensionData = {}, this.bufferURIGenerator = void 0, this.imageURIGenerator = void 0, this.logger = void 0, this.C = /* @__PURE__ */ new Map(), this.accessorUsageGroupedByParent = /* @__PURE__ */ new Set(["ARRAY_BUFFER"]), this.accessorParents = /* @__PURE__ */ new Map(), this.O = e2, this.jsonDoc = t2, this.options = n2;
      const r2 = e2.getRoot(), i2 = r2.listBuffers().length, s2 = r2.listTextures().length;
      this.bufferURIGenerator = new Ow(i2 > 1, () => n2.basename || "buffer"), this.imageURIGenerator = new Ow(s2 > 1, (t3) => function(e3, t4) {
        const n3 = e3.getGraph().listParentEdges(t4).find((t5) => t5.getParent() !== e3.getRoot());
        return n3 ? n3.getName().replace(/texture$/i, "") : "";
      }(e2, t3) || n2.basename || "texture"), this.logger = e2.getLogger();
    }
    createTextureInfoDef(e2, t2) {
      const n2 = { magFilter: t2.getMagFilter() || void 0, minFilter: t2.getMinFilter() || void 0, wrapS: t2.getWrapS(), wrapT: t2.getWrapT() }, r2 = JSON.stringify(n2);
      this.samplerDefIndexMap.has(r2) || (this.samplerDefIndexMap.set(r2, this.jsonDoc.json.samplers.length), this.jsonDoc.json.samplers.push(n2));
      const i2 = { source: this.imageIndexMap.get(e2), sampler: this.samplerDefIndexMap.get(r2) }, s2 = JSON.stringify(i2);
      this.textureDefIndexMap.has(s2) || (this.textureDefIndexMap.set(s2, this.jsonDoc.json.textures.length), this.jsonDoc.json.textures.push(i2));
      const o2 = { index: this.textureDefIndexMap.get(s2) };
      return 0 !== t2.getTexCoord() && (o2.texCoord = t2.getTexCoord()), Object.keys(t2.getExtras()).length > 0 && (o2.extras = t2.getExtras()), this.textureInfoDefMap.set(t2, o2), o2;
    }
    createPropertyDef(e2) {
      const t2 = {};
      return e2.getName() && (t2.name = e2.getName()), Object.keys(e2.getExtras()).length > 0 && (t2.extras = e2.getExtras()), t2;
    }
    createAccessorDef(e2) {
      const t2 = this.createPropertyDef(e2);
      return t2.type = e2.getType(), t2.componentType = e2.getComponentType(), t2.count = e2.getCount(), this.O.getGraph().listParentEdges(e2).some((e3) => "attributes" === e3.getName() && "POSITION" === e3.getAttributes().key || "input" === e3.getName()) && (t2.max = e2.getMax([]).map(Math.fround), t2.min = e2.getMin([]).map(Math.fround)), e2.getNormalized() && (t2.normalized = e2.getNormalized()), t2;
    }
    createImageData(e2, t2, n2) {
      if (this.options.format === Sb.GLB)
        this.imageBufferViews.push(t2), e2.bufferView = this.jsonDoc.json.bufferViews.length, this.jsonDoc.json.bufferViews.push({ buffer: 0, byteOffset: -1, byteLength: t2.byteLength });
      else {
        const r2 = Fb.mimeTypeToExtension(n2.getMimeType());
        e2.uri = this.imageURIGenerator.createURI(n2, r2), this.jsonDoc.resources[e2.uri] = t2;
      }
    }
    getAccessorUsage(e2) {
      const t2 = this.C.get(e2);
      if (t2)
        return t2;
      if (e2.getSparse())
        return Eb.SPARSE;
      for (const t3 of this.O.getGraph().listParentEdges(e2)) {
        const { usage: e3 } = t3.getAttributes();
        if (e3)
          return e3;
        t3.getParent().propertyType !== Ab.ROOT && this.logger.warn(`Missing attribute ".usage" on edge, "${t3.getName()}".`);
      }
      return Eb.OTHER;
    }
    addAccessorToUsageGroup(e2, t2) {
      const n2 = this.C.get(e2);
      if (n2 && n2 !== t2)
        throw new Error(`Accessor with usage "${n2}" cannot be reused as "${t2}".`);
      return this.C.set(e2, t2), this;
    }
    listAccessorUsageGroups() {
      const e2 = {};
      for (const [t2, n2] of Array.from(this.C.entries()))
        e2[n2] = e2[n2] || [], e2[n2].push(t2);
      return e2;
    }
  }
  Bw.BufferViewTarget = Dw, Bw.BufferViewUsage = Eb, Bw.USAGE_TO_TARGET = { [Eb.ARRAY_BUFFER]: Dw.ARRAY_BUFFER, [Eb.ELEMENT_ARRAY_BUFFER]: Dw.ELEMENT_ARRAY_BUFFER };
  class Ow {
    constructor(e2, t2) {
      this.multiple = void 0, this.basename = void 0, this.counter = {}, this.multiple = e2, this.basename = t2;
    }
    createURI(e2, t2) {
      if (e2.getURI())
        return e2.getURI();
      if (this.multiple) {
        const n2 = this.basename(e2);
        return this.counter[n2] = this.counter[n2] || 1, `${n2}_${this.counter[n2]++}.${t2}`;
      }
      return `${this.basename(e2)}.${t2}`;
    }
  }
  const { BufferViewUsage: Lw } = Bw, { UNSIGNED_INT: Uw, UNSIGNED_SHORT: Fw, UNSIGNED_BYTE: Nw } = ow.ComponentType;
  var jw;
  !function(e2) {
    e2[e2.JSON = 1313821514] = "JSON", e2[e2.BIN = 5130562] = "BIN";
  }(jw || (jw = {}));
  class zw {
    constructor() {
      this.M = Vb.DEFAULT_INSTANCE, this.h = /* @__PURE__ */ new Set(), this.F = {}, this.U = xb.INTERLEAVED, this.lastReadBytes = 0, this.lastWriteBytes = 0;
    }
    setLogger(e2) {
      return this.M = e2, this;
    }
    registerExtensions(e2) {
      for (const t2 of e2)
        this.h.add(t2), t2.register();
      return this;
    }
    registerDependencies(e2) {
      return Object.assign(this.F, e2), this;
    }
    setVertexLayout(e2) {
      return this.U = e2, this;
    }
    async read(e2) {
      return await this.readJSON(await this.readAsJSON(e2));
    }
    async readAsJSON(e2) {
      const t2 = await this.readURI(e2, "view");
      this.lastReadBytes = t2.byteLength;
      const n2 = Gw(t2) ? this.P(t2) : { json: JSON.parse(Ob.decodeText(t2)), resources: {} };
      return await this.L(n2, this.dirname(e2)), this.j(n2), n2;
    }
    async readJSON(e2) {
      return e2 = this.D(e2), this.j(e2), (class {
        static read(e3, t2 = Rw) {
          const n2 = xw({}, Rw, t2), { json: r2 } = e3, i2 = new Tw().setLogger(n2.logger);
          this.validate(e3, n2);
          const s2 = new Iw(e3), o2 = r2.asset, a2 = i2.getRoot().getAsset();
          o2.copyright && (a2.copyright = o2.copyright), o2.extras && (a2.extras = o2.extras), void 0 !== r2.extras && i2.getRoot().setExtras(xw({}, r2.extras));
          const l2 = r2.extensionsUsed || [], c2 = r2.extensionsRequired || [];
          for (const e4 of n2.extensions)
            if (l2.includes(e4.EXTENSION_NAME)) {
              const t3 = i2.createExtension(e4).setRequired(c2.includes(e4.EXTENSION_NAME));
              for (const e5 of t3.readDependencies)
                t3.install(e5, n2.dependencies[e5]);
            }
          const u2 = r2.buffers || [];
          i2.getRoot().listExtensionsUsed().filter((e4) => e4.prereadTypes.includes(Ab.BUFFER)).forEach((e4) => e4.preread(s2, Ab.BUFFER)), s2.buffers = u2.map((e4) => {
            const t3 = i2.createBuffer(e4.name);
            return e4.extras && t3.setExtras(e4.extras), e4.uri && 0 !== e4.uri.indexOf("__") && t3.setURI(e4.uri), t3;
          }), s2.bufferViewBuffers = (r2.bufferViews || []).map((t3, n3) => {
            if (!s2.bufferViews[n3]) {
              const r3 = e3.json.buffers[t3.buffer];
              s2.bufferViews[n3] = Ob.toView(r3.uri ? e3.resources[r3.uri] : e3.resources["@glb.bin"], t3.byteOffset || 0, t3.byteLength);
            }
            return s2.buffers[t3.buffer];
          });
          const p2 = r2.accessors || [];
          s2.accessors = p2.map((e4) => {
            const t3 = i2.createAccessor(e4.name, s2.bufferViewBuffers[e4.bufferView]).setType(e4.type);
            return e4.extras && t3.setExtras(e4.extras), void 0 !== e4.normalized && t3.setNormalized(e4.normalized), void 0 === e4.bufferView || t3.setArray(kw(e4, s2)), t3;
          });
          const d2 = r2.images || [], h2 = r2.textures || [];
          i2.getRoot().listExtensionsUsed().filter((e4) => e4.prereadTypes.includes(Ab.TEXTURE)).forEach((e4) => e4.preread(s2, Ab.TEXTURE)), s2.textures = d2.map((t3) => {
            const n3 = i2.createTexture(t3.name);
            if (t3.extras && n3.setExtras(t3.extras), void 0 !== t3.bufferView) {
              const i3 = r2.bufferViews[t3.bufferView], s3 = e3.json.buffers[i3.buffer], o3 = i3.byteOffset || 0, a3 = (s3.uri ? e3.resources[s3.uri] : e3.resources["@glb.bin"]).slice(o3, o3 + i3.byteLength);
              n3.setImage(a3);
            } else
              void 0 !== t3.uri && (n3.setImage(e3.resources[t3.uri]), 0 !== t3.uri.indexOf("__") && n3.setURI(t3.uri));
            if (void 0 !== t3.mimeType)
              n3.setMimeType(t3.mimeType);
            else if (t3.uri) {
              const e4 = jb.extension(t3.uri);
              n3.setMimeType(Fb.extensionToMimeType(e4));
            }
            return n3;
          }), s2.materials = (r2.materials || []).map((e4) => {
            const t3 = i2.createMaterial(e4.name);
            e4.extras && t3.setExtras(e4.extras), void 0 !== e4.alphaMode && t3.setAlphaMode(e4.alphaMode), void 0 !== e4.alphaCutoff && t3.setAlphaCutoff(e4.alphaCutoff), void 0 !== e4.doubleSided && t3.setDoubleSided(e4.doubleSided);
            const n3 = e4.pbrMetallicRoughness || {};
            if (void 0 !== n3.baseColorFactor && t3.setBaseColorFactor(n3.baseColorFactor), void 0 !== e4.emissiveFactor && t3.setEmissiveFactor(e4.emissiveFactor), void 0 !== n3.metallicFactor && t3.setMetallicFactor(n3.metallicFactor), void 0 !== n3.roughnessFactor && t3.setRoughnessFactor(n3.roughnessFactor), void 0 !== n3.baseColorTexture) {
              const e5 = n3.baseColorTexture;
              t3.setBaseColorTexture(s2.textures[h2[e5.index].source]), s2.setTextureInfo(t3.getBaseColorTextureInfo(), e5);
            }
            if (void 0 !== e4.emissiveTexture) {
              const n4 = e4.emissiveTexture;
              t3.setEmissiveTexture(s2.textures[h2[n4.index].source]), s2.setTextureInfo(t3.getEmissiveTextureInfo(), n4);
            }
            if (void 0 !== e4.normalTexture) {
              const n4 = e4.normalTexture;
              t3.setNormalTexture(s2.textures[h2[n4.index].source]), s2.setTextureInfo(t3.getNormalTextureInfo(), n4), void 0 !== e4.normalTexture.scale && t3.setNormalScale(e4.normalTexture.scale);
            }
            if (void 0 !== e4.occlusionTexture) {
              const n4 = e4.occlusionTexture;
              t3.setOcclusionTexture(s2.textures[h2[n4.index].source]), s2.setTextureInfo(t3.getOcclusionTextureInfo(), n4), void 0 !== e4.occlusionTexture.strength && t3.setOcclusionStrength(e4.occlusionTexture.strength);
            }
            if (void 0 !== n3.metallicRoughnessTexture) {
              const e5 = n3.metallicRoughnessTexture;
              t3.setMetallicRoughnessTexture(s2.textures[h2[e5.index].source]), s2.setTextureInfo(t3.getMetallicRoughnessTextureInfo(), e5);
            }
            return t3;
          });
          const f2 = r2.meshes || [];
          i2.getRoot().listExtensionsUsed().filter((e4) => e4.prereadTypes.includes(Ab.PRIMITIVE)).forEach((e4) => e4.preread(s2, Ab.PRIMITIVE)), s2.meshes = f2.map((e4) => {
            const t3 = i2.createMesh(e4.name);
            return e4.extras && t3.setExtras(e4.extras), void 0 !== e4.weights && t3.setWeights(e4.weights), (e4.primitives || []).forEach((n3) => {
              const r3 = i2.createPrimitive();
              n3.extras && r3.setExtras(n3.extras), void 0 !== n3.material && r3.setMaterial(s2.materials[n3.material]), void 0 !== n3.mode && r3.setMode(n3.mode);
              for (const [e5, t4] of Object.entries(n3.attributes || {}))
                r3.setAttribute(e5, s2.accessors[t4]);
              void 0 !== n3.indices && r3.setIndices(s2.accessors[n3.indices]);
              const o3 = e4.extras && e4.extras.targetNames || [];
              (n3.targets || []).forEach((e5, t4) => {
                const n4 = o3[t4] || t4.toString(), a3 = i2.createPrimitiveTarget(n4);
                for (const [t5, n5] of Object.entries(e5))
                  a3.setAttribute(t5, s2.accessors[n5]);
                r3.addTarget(a3);
              }), t3.addPrimitive(r3);
            }), t3;
          }), s2.cameras = (r2.cameras || []).map((e4) => {
            const t3 = i2.createCamera(e4.name).setType(e4.type);
            if (e4.extras && t3.setExtras(e4.extras), e4.type === pw.Type.PERSPECTIVE) {
              const n3 = e4.perspective;
              t3.setYFov(n3.yfov), t3.setZNear(n3.znear), void 0 !== n3.zfar && t3.setZFar(n3.zfar), void 0 !== n3.aspectRatio && t3.setAspectRatio(n3.aspectRatio);
            } else {
              const n3 = e4.orthographic;
              t3.setZNear(n3.znear).setZFar(n3.zfar).setXMag(n3.xmag).setYMag(n3.ymag);
            }
            return t3;
          });
          const m2 = r2.nodes || [];
          i2.getRoot().listExtensionsUsed().filter((e4) => e4.prereadTypes.includes(Ab.NODE)).forEach((e4) => e4.preread(s2, Ab.NODE)), s2.nodes = m2.map((e4) => {
            const t3 = i2.createNode(e4.name);
            if (e4.extras && t3.setExtras(e4.extras), void 0 !== e4.translation && t3.setTranslation(e4.translation), void 0 !== e4.rotation && t3.setRotation(e4.rotation), void 0 !== e4.scale && t3.setScale(e4.scale), void 0 !== e4.matrix) {
              const n3 = [0, 0, 0], r3 = [0, 0, 0, 1], i3 = [1, 1, 1];
              Qb.decompose(e4.matrix, n3, r3, i3), t3.setTranslation(n3), t3.setRotation(r3), t3.setScale(i3);
            }
            return void 0 !== e4.weights && t3.setWeights(e4.weights), t3;
          }), s2.skins = (r2.skins || []).map((e4) => {
            const t3 = i2.createSkin(e4.name);
            e4.extras && t3.setExtras(e4.extras), void 0 !== e4.inverseBindMatrices && t3.setInverseBindMatrices(s2.accessors[e4.inverseBindMatrices]), void 0 !== e4.skeleton && t3.setSkeleton(s2.nodes[e4.skeleton]);
            for (const n3 of e4.joints)
              t3.addJoint(s2.nodes[n3]);
            return t3;
          }), m2.map((e4, t3) => {
            const n3 = s2.nodes[t3];
            (e4.children || []).forEach((e5) => n3.addChild(s2.nodes[e5])), void 0 !== e4.mesh && n3.setMesh(s2.meshes[e4.mesh]), void 0 !== e4.camera && n3.setCamera(s2.cameras[e4.camera]), void 0 !== e4.skin && n3.setSkin(s2.skins[e4.skin]);
          }), s2.animations = (r2.animations || []).map((e4) => {
            const t3 = i2.createAnimation(e4.name);
            e4.extras && t3.setExtras(e4.extras);
            const n3 = (e4.samplers || []).map((e5) => {
              const n4 = i2.createAnimationSampler().setInput(s2.accessors[e5.input]).setOutput(s2.accessors[e5.output]).setInterpolation(e5.interpolation || cw.Interpolation.LINEAR);
              return e5.extras && n4.setExtras(e5.extras), t3.addSampler(n4), n4;
            });
            return (e4.channels || []).forEach((e5) => {
              const r3 = i2.createAnimationChannel().setSampler(n3[e5.sampler]).setTargetPath(e5.target.path);
              void 0 !== e5.target.node && r3.setTargetNode(s2.nodes[e5.target.node]), e5.extras && r3.setExtras(e5.extras), t3.addChannel(r3);
            }), t3;
          });
          const _2 = r2.scenes || [];
          return i2.getRoot().listExtensionsUsed().filter((e4) => e4.prereadTypes.includes(Ab.SCENE)).forEach((e4) => e4.preread(s2, Ab.SCENE)), s2.scenes = _2.map((e4) => {
            const t3 = i2.createScene(e4.name);
            return e4.extras && t3.setExtras(e4.extras), (e4.nodes || []).map((e5) => s2.nodes[e5]).forEach((e5) => t3.addChild(e5)), t3;
          }), void 0 !== r2.scene && i2.getRoot().setDefaultScene(s2.scenes[r2.scene]), i2.getRoot().listExtensionsUsed().forEach((e4) => e4.read(s2)), p2.forEach((e4, t3) => {
            const n3 = s2.accessors[t3], r3 = !!e4.sparse, i3 = !e4.bufferView && !n3.getArray();
            (r3 || i3) && n3.setSparse(true).setArray(function(e5, t4) {
              const n4 = Mb[e5.componentType], r4 = ow.getElementSize(e5.type);
              let i4;
              i4 = void 0 !== e5.bufferView ? kw(e5, t4) : new n4(e5.count * r4);
              const s3 = e5.sparse;
              if (!s3)
                return i4;
              const o3 = s3.count, a3 = xw({}, e5, s3.indices, { count: o3, type: "SCALAR" }), l3 = xw({}, e5, s3.values, { count: o3 }), c3 = kw(a3, t4), u3 = kw(l3, t4);
              for (let e6 = 0; e6 < a3.count; e6++)
                for (let t5 = 0; t5 < r4; t5++)
                  i4[c3[e6] * r4 + t5] = u3[e6 * r4 + t5];
              return i4;
            }(e4, s2));
          }), i2;
        }
        static validate(e3, t2) {
          const n2 = e3.json;
          if ("2.0" !== n2.asset.version)
            throw new Error(`Unsupported glTF version, "${n2.asset.version}".`);
          if (n2.extensionsRequired) {
            for (const e4 of n2.extensionsRequired)
              if (!t2.extensions.find((t3) => t3.EXTENSION_NAME === e4))
                throw new Error(`Missing required extension, "${e4}".`);
          }
          if (n2.extensionsUsed)
            for (const e4 of n2.extensionsUsed)
              t2.extensions.find((t3) => t3.EXTENSION_NAME === e4) || t2.logger.warn(`Missing optional extension, "${e4}".`);
        }
      }).read(e2, { extensions: Array.from(this.h), dependencies: this.F, logger: this.M });
    }
    async binaryToJSON(e2) {
      const t2 = this.P(Ob.assertView(e2));
      this.j(t2);
      const n2 = t2.json;
      if (n2.buffers && n2.buffers.some((e3) => function(e4, t3) {
        return void 0 !== t3.uri && !(t3.uri in e4.resources);
      }(t2, e3)))
        throw new Error("Cannot resolve external buffers with binaryToJSON().");
      if (n2.images && n2.images.some((e3) => function(e4, t3) {
        return void 0 !== t3.uri && !(t3.uri in e4.resources) && void 0 === t3.bufferView;
      }(t2, e3)))
        throw new Error("Cannot resolve external images with binaryToJSON().");
      return t2;
    }
    async readBinary(e2) {
      return this.readJSON(await this.binaryToJSON(Ob.assertView(e2)));
    }
    async writeJSON(e2, t2 = {}) {
      if (t2.format === Sb.GLB && e2.getRoot().listBuffers().length > 1)
        throw new Error("GLB must have 0–1 buffers.");
      return (class {
        static write(e3, t3) {
          const n2 = e3.getRoot(), r2 = { asset: xw({ generator: "glTF-Transform v3.2.1" }, n2.getAsset()), extras: xw({}, n2.getExtras()) }, i2 = { json: r2, resources: {} }, s2 = new Bw(e3, i2, t3), o2 = t3.logger || Vb.DEFAULT_INSTANCE, a2 = new Set(t3.extensions.map((e4) => e4.EXTENSION_NAME)), l2 = e3.getRoot().listExtensionsUsed().filter((e4) => a2.has(e4.extensionName)), c2 = e3.getRoot().listExtensionsRequired().filter((e4) => a2.has(e4.extensionName));
          l2.length < e3.getRoot().listExtensionsUsed().length && o2.warn("Some extensions were not registered for I/O, and will not be written.");
          for (const e4 of l2)
            for (const n3 of e4.writeDependencies)
              e4.install(n3, t3.dependencies[n3]);
          function u2(e4, t4, n3, i3) {
            const o3 = [];
            let a3 = 0;
            for (const t5 of e4) {
              const e5 = s2.createAccessorDef(t5);
              e5.bufferView = r2.bufferViews.length;
              const n4 = t5.getArray(), i4 = Ob.pad(Ob.toView(n4));
              e5.byteOffset = a3, a3 += i4.byteLength, o3.push(i4), s2.accessorIndexMap.set(t5, r2.accessors.length), r2.accessors.push(e5);
            }
            const l3 = { buffer: t4, byteOffset: n3, byteLength: Ob.concat(o3).byteLength };
            return i3 && (l3.target = i3), r2.bufferViews.push(l3), { buffers: o3, byteLength: a3 };
          }
          function p2(e4, t4, n3) {
            const i3 = e4[0].getCount();
            let o3 = 0;
            for (const t5 of e4) {
              const e5 = s2.createAccessorDef(t5);
              e5.bufferView = r2.bufferViews.length, e5.byteOffset = o3;
              const n4 = t5.getElementSize(), i4 = t5.getComponentSize();
              o3 += Ob.padNumber(n4 * i4), s2.accessorIndexMap.set(t5, r2.accessors.length), r2.accessors.push(e5);
            }
            const a3 = i3 * o3, l3 = new ArrayBuffer(a3), c3 = new DataView(l3);
            for (let t5 = 0; t5 < i3; t5++) {
              let n4 = 0;
              for (const r3 of e4) {
                const e5 = r3.getElementSize(), i4 = r3.getComponentSize(), s3 = r3.getComponentType(), a4 = r3.getArray();
                for (let r4 = 0; r4 < e5; r4++) {
                  const l4 = t5 * o3 + n4 + r4 * i4, u3 = a4[t5 * e5 + r4];
                  switch (s3) {
                    case ow.ComponentType.FLOAT:
                      c3.setFloat32(l4, u3, true);
                      break;
                    case ow.ComponentType.BYTE:
                      c3.setInt8(l4, u3);
                      break;
                    case ow.ComponentType.SHORT:
                      c3.setInt16(l4, u3, true);
                      break;
                    case ow.ComponentType.UNSIGNED_BYTE:
                      c3.setUint8(l4, u3);
                      break;
                    case ow.ComponentType.UNSIGNED_SHORT:
                      c3.setUint16(l4, u3, true);
                      break;
                    case ow.ComponentType.UNSIGNED_INT:
                      c3.setUint32(l4, u3, true);
                      break;
                    default:
                      throw new Error("Unexpected component type: " + s3);
                  }
                }
                n4 += Ob.padNumber(e5 * i4);
              }
            }
            return r2.bufferViews.push({ buffer: t4, byteOffset: n3, byteLength: a3, byteStride: o3, target: Bw.BufferViewTarget.ARRAY_BUFFER }), { byteLength: a3, buffers: [new Uint8Array(l3)] };
          }
          function d2(e4, t4, n3) {
            const i3 = [];
            let a3 = 0;
            const l3 = /* @__PURE__ */ new Map();
            let c3 = -1 / 0;
            for (const t5 of e4) {
              const e5 = s2.createAccessorDef(t5);
              r2.accessors.push(e5), s2.accessorIndexMap.set(t5, r2.accessors.length - 1);
              const n4 = [], i4 = [], a4 = [], u4 = new Array(t5.getElementSize()).fill(0);
              for (let e6 = 0, r3 = t5.getCount(); e6 < r3; e6++)
                if (t5.getElement(e6, a4), !Qb.eq(a4, u4, 0)) {
                  c3 = Math.max(e6, c3), n4.push(e6);
                  for (let e7 = 0; e7 < a4.length; e7++)
                    i4.push(a4[e7]);
                }
              const p4 = n4.length, d4 = { accessorDef: e5, count: p4 };
              if (l3.set(t5, d4), 0 === p4)
                continue;
              if (p4 > t5.getCount() / 3) {
                const e6 = (100 * n4.length / t5.getCount()).toFixed(1);
                o2.warn(`Sparse accessor with many non-zero elements (${e6}%) may increase file size.`);
              }
              const h4 = Mb[t5.getComponentType()];
              d4.indices = n4, d4.values = new h4(i4);
            }
            if (!Number.isFinite(c3))
              return { buffers: i3, byteLength: a3 };
            const u3 = c3 < 255 ? Uint8Array : c3 < 65535 ? Uint16Array : Uint32Array, p3 = c3 < 255 ? Nw : c3 < 65535 ? Fw : Uw, d3 = { buffer: t4, byteOffset: n3 + a3, byteLength: 0 };
            for (const t5 of e4) {
              const e5 = l3.get(t5);
              if (0 === e5.count)
                continue;
              e5.indicesByteOffset = d3.byteLength;
              const n4 = Ob.pad(Ob.toView(new u3(e5.indices)));
              i3.push(n4), a3 += n4.byteLength, d3.byteLength += n4.byteLength;
            }
            r2.bufferViews.push(d3);
            const h3 = r2.bufferViews.length - 1, f3 = { buffer: t4, byteOffset: n3 + a3, byteLength: 0 };
            for (const t5 of e4) {
              const e5 = l3.get(t5);
              if (0 === e5.count)
                continue;
              e5.valuesByteOffset = f3.byteLength;
              const n4 = Ob.pad(Ob.toView(e5.values));
              i3.push(n4), a3 += n4.byteLength, f3.byteLength += n4.byteLength;
            }
            r2.bufferViews.push(f3);
            const m2 = r2.bufferViews.length - 1;
            for (const t5 of e4) {
              const e5 = l3.get(t5);
              0 !== e5.count && (e5.accessorDef.sparse = { count: e5.count, indices: { bufferView: h3, byteOffset: e5.indicesByteOffset, componentType: p3 }, values: { bufferView: m2, byteOffset: e5.valuesByteOffset } });
            }
            return { buffers: i3, byteLength: a3 };
          }
          const h2 = /* @__PURE__ */ new Map();
          for (const t4 of e3.getGraph().listEdges()) {
            if (t4.getParent() === n2)
              continue;
            const e4 = t4.getChild();
            if (e4 instanceof ow) {
              const n3 = h2.get(e4) || [];
              n3.push(t4), h2.set(e4, n3);
            }
          }
          if (r2.accessors = [], r2.bufferViews = [], r2.samplers = [], r2.textures = [], r2.images = n2.listTextures().map((e4, t4) => {
            const n3 = s2.createPropertyDef(e4);
            e4.getMimeType() && (n3.mimeType = e4.getMimeType());
            const r3 = e4.getImage();
            return r3 && s2.createImageData(n3, r3, e4), s2.imageIndexMap.set(e4, t4), n3;
          }), l2.filter((e4) => e4.prewriteTypes.includes(Ab.ACCESSOR)).forEach((e4) => e4.prewrite(s2, Ab.ACCESSOR)), n2.listAccessors().forEach((e4) => {
            const t4 = s2.accessorUsageGroupedByParent, n3 = s2.accessorParents;
            if (s2.accessorIndexMap.has(e4))
              return;
            const r3 = h2.get(e4) || [], i3 = s2.getAccessorUsage(e4);
            if (s2.addAccessorToUsageGroup(e4, i3), t4.has(i3)) {
              const t5 = r3[0].getParent(), i4 = n3.get(t5) || /* @__PURE__ */ new Set();
              i4.add(e4), n3.set(t5, i4);
            }
          }), l2.filter((e4) => e4.prewriteTypes.includes(Ab.BUFFER)).forEach((e4) => e4.prewrite(s2, Ab.BUFFER)), (n2.listAccessors().length > 0 || n2.listTextures().length > 0 || s2.otherBufferViews.size > 0) && 0 === n2.listBuffers().length)
            throw new Error("Buffer required for Document resources, but none was found.");
          r2.buffers = [], n2.listBuffers().forEach((e4, n3) => {
            const o3 = s2.createPropertyDef(e4), a3 = s2.accessorUsageGroupedByParent, l3 = s2.accessorParents, c3 = e4.listParents().filter((e5) => e5 instanceof ow), h3 = new Set(c3), f3 = [], m2 = r2.buffers.length;
            let _2 = 0;
            const g2 = s2.listAccessorUsageGroups();
            for (const e5 in g2)
              if (a3.has(e5))
                for (const n4 of Array.from(l3.values())) {
                  const r3 = Array.from(n4).filter((e6) => h3.has(e6)).filter((t4) => s2.getAccessorUsage(t4) === e5);
                  if (r3.length)
                    if (e5 !== Lw.ARRAY_BUFFER || t3.vertexLayout === xb.INTERLEAVED) {
                      const t4 = e5 === Lw.ARRAY_BUFFER ? p2(r3, m2, _2) : u2(r3, m2, _2);
                      _2 += t4.byteLength, f3.push(...t4.buffers);
                    } else
                      for (const e6 of r3) {
                        const t4 = p2([e6], m2, _2);
                        _2 += t4.byteLength, f3.push(...t4.buffers);
                      }
                }
              else {
                const t4 = g2[e5].filter((e6) => h3.has(e6));
                if (!t4.length)
                  continue;
                const n4 = e5 === Lw.ELEMENT_ARRAY_BUFFER ? Bw.BufferViewTarget.ELEMENT_ARRAY_BUFFER : void 0, r3 = e5 === Lw.SPARSE ? d2(t4, m2, _2) : u2(t4, m2, _2, n4);
                _2 += r3.byteLength, f3.push(...r3.buffers);
              }
            if (s2.imageBufferViews.length && 0 === n3) {
              for (let e5 = 0; e5 < s2.imageBufferViews.length; e5++)
                if (r2.bufferViews[r2.images[e5].bufferView].byteOffset = _2, _2 += s2.imageBufferViews[e5].byteLength, f3.push(s2.imageBufferViews[e5]), _2 % 8) {
                  const e6 = 8 - _2 % 8;
                  _2 += e6, f3.push(new Uint8Array(e6));
                }
            }
            if (s2.otherBufferViews.has(e4))
              for (const t4 of s2.otherBufferViews.get(e4))
                r2.bufferViews.push({ buffer: m2, byteOffset: _2, byteLength: t4.byteLength }), s2.otherBufferViewsIndexMap.set(t4, r2.bufferViews.length - 1), _2 += t4.byteLength, f3.push(t4);
            if (_2) {
              let n4;
              t3.format === Sb.GLB ? n4 = "@glb.bin" : (n4 = s2.bufferURIGenerator.createURI(e4, "bin"), o3.uri = n4), o3.byteLength = _2, i2.resources[n4] = Ob.concat(f3);
            }
            r2.buffers.push(o3), s2.bufferIndexMap.set(e4, n3);
          }), n2.listAccessors().find((e4) => !e4.getBuffer()) && o2.warn("Skipped writing one or more Accessors: no Buffer assigned."), r2.materials = n2.listMaterials().map((e4, t4) => {
            const n3 = s2.createPropertyDef(e4);
            if (e4.getAlphaMode() !== vw.AlphaMode.OPAQUE && (n3.alphaMode = e4.getAlphaMode()), e4.getAlphaMode() === vw.AlphaMode.MASK && (n3.alphaCutoff = e4.getAlphaCutoff()), e4.getDoubleSided() && (n3.doubleSided = true), n3.pbrMetallicRoughness = {}, Qb.eq(e4.getBaseColorFactor(), [1, 1, 1, 1]) || (n3.pbrMetallicRoughness.baseColorFactor = e4.getBaseColorFactor()), Qb.eq(e4.getEmissiveFactor(), [0, 0, 0]) || (n3.emissiveFactor = e4.getEmissiveFactor()), 1 !== e4.getRoughnessFactor() && (n3.pbrMetallicRoughness.roughnessFactor = e4.getRoughnessFactor()), 1 !== e4.getMetallicFactor() && (n3.pbrMetallicRoughness.metallicFactor = e4.getMetallicFactor()), e4.getBaseColorTexture()) {
              const t5 = e4.getBaseColorTexture(), r3 = e4.getBaseColorTextureInfo();
              n3.pbrMetallicRoughness.baseColorTexture = s2.createTextureInfoDef(t5, r3);
            }
            if (e4.getEmissiveTexture()) {
              const t5 = e4.getEmissiveTexture(), r3 = e4.getEmissiveTextureInfo();
              n3.emissiveTexture = s2.createTextureInfoDef(t5, r3);
            }
            if (e4.getNormalTexture()) {
              const t5 = e4.getNormalTexture(), r3 = e4.getNormalTextureInfo(), i3 = s2.createTextureInfoDef(t5, r3);
              1 !== e4.getNormalScale() && (i3.scale = e4.getNormalScale()), n3.normalTexture = i3;
            }
            if (e4.getOcclusionTexture()) {
              const t5 = e4.getOcclusionTexture(), r3 = e4.getOcclusionTextureInfo(), i3 = s2.createTextureInfoDef(t5, r3);
              1 !== e4.getOcclusionStrength() && (i3.strength = e4.getOcclusionStrength()), n3.occlusionTexture = i3;
            }
            if (e4.getMetallicRoughnessTexture()) {
              const t5 = e4.getMetallicRoughnessTexture(), r3 = e4.getMetallicRoughnessTextureInfo();
              n3.pbrMetallicRoughness.metallicRoughnessTexture = s2.createTextureInfoDef(t5, r3);
            }
            return s2.materialIndexMap.set(e4, t4), n3;
          }), r2.meshes = n2.listMeshes().map((e4, t4) => {
            const n3 = s2.createPropertyDef(e4);
            let r3 = null;
            return n3.primitives = e4.listPrimitives().map((e5) => {
              const t5 = { attributes: {} };
              t5.mode = e5.getMode();
              const n4 = e5.getMaterial();
              n4 && (t5.material = s2.materialIndexMap.get(n4)), Object.keys(e5.getExtras()).length && (t5.extras = e5.getExtras());
              const i3 = e5.getIndices();
              i3 && (t5.indices = s2.accessorIndexMap.get(i3));
              for (const n5 of e5.listSemantics())
                t5.attributes[n5] = s2.accessorIndexMap.get(e5.getAttribute(n5));
              for (const n5 of e5.listTargets()) {
                const e6 = {};
                for (const t6 of n5.listSemantics())
                  e6[t6] = s2.accessorIndexMap.get(n5.getAttribute(t6));
                t5.targets = t5.targets || [], t5.targets.push(e6);
              }
              return e5.listTargets().length && !r3 && (r3 = e5.listTargets().map((e6) => e6.getName())), t5;
            }), e4.getWeights().length && (n3.weights = e4.getWeights()), r3 && (n3.extras = n3.extras || {}, n3.extras.targetNames = r3), s2.meshIndexMap.set(e4, t4), n3;
          }), r2.cameras = n2.listCameras().map((e4, t4) => {
            const n3 = s2.createPropertyDef(e4);
            if (n3.type = e4.getType(), n3.type === pw.Type.PERSPECTIVE) {
              n3.perspective = { znear: e4.getZNear(), zfar: e4.getZFar(), yfov: e4.getYFov() };
              const t5 = e4.getAspectRatio();
              null !== t5 && (n3.perspective.aspectRatio = t5);
            } else
              n3.orthographic = { znear: e4.getZNear(), zfar: e4.getZFar(), xmag: e4.getXMag(), ymag: e4.getYMag() };
            return s2.cameraIndexMap.set(e4, t4), n3;
          }), r2.nodes = n2.listNodes().map((e4, t4) => {
            const n3 = s2.createPropertyDef(e4);
            return Qb.eq(e4.getTranslation(), [0, 0, 0]) || (n3.translation = e4.getTranslation()), Qb.eq(e4.getRotation(), [0, 0, 0, 1]) || (n3.rotation = e4.getRotation()), Qb.eq(e4.getScale(), [1, 1, 1]) || (n3.scale = e4.getScale()), e4.getWeights().length && (n3.weights = e4.getWeights()), s2.nodeIndexMap.set(e4, t4), n3;
          }), r2.skins = n2.listSkins().map((e4, t4) => {
            const n3 = s2.createPropertyDef(e4), r3 = e4.getInverseBindMatrices();
            r3 && (n3.inverseBindMatrices = s2.accessorIndexMap.get(r3));
            const i3 = e4.getSkeleton();
            return i3 && (n3.skeleton = s2.nodeIndexMap.get(i3)), n3.joints = e4.listJoints().map((e5) => s2.nodeIndexMap.get(e5)), s2.skinIndexMap.set(e4, t4), n3;
          }), n2.listNodes().forEach((e4, t4) => {
            const n3 = r2.nodes[t4], i3 = e4.getMesh();
            i3 && (n3.mesh = s2.meshIndexMap.get(i3));
            const o3 = e4.getCamera();
            o3 && (n3.camera = s2.cameraIndexMap.get(o3));
            const a3 = e4.getSkin();
            a3 && (n3.skin = s2.skinIndexMap.get(a3)), e4.listChildren().length > 0 && (n3.children = e4.listChildren().map((e5) => s2.nodeIndexMap.get(e5)));
          }), r2.animations = n2.listAnimations().map((e4, t4) => {
            const n3 = s2.createPropertyDef(e4), r3 = /* @__PURE__ */ new Map();
            return n3.samplers = e4.listSamplers().map((e5, t5) => {
              const n4 = s2.createPropertyDef(e5);
              return n4.input = s2.accessorIndexMap.get(e5.getInput()), n4.output = s2.accessorIndexMap.get(e5.getOutput()), n4.interpolation = e5.getInterpolation(), r3.set(e5, t5), n4;
            }), n3.channels = e4.listChannels().map((e5) => {
              const t5 = s2.createPropertyDef(e5);
              return t5.sampler = r3.get(e5.getSampler()), t5.target = { node: s2.nodeIndexMap.get(e5.getTargetNode()), path: e5.getTargetPath() }, t5;
            }), s2.animationIndexMap.set(e4, t4), n3;
          }), r2.scenes = n2.listScenes().map((e4, t4) => {
            const n3 = s2.createPropertyDef(e4);
            return n3.nodes = e4.listChildren().map((e5) => s2.nodeIndexMap.get(e5)), s2.sceneIndexMap.set(e4, t4), n3;
          });
          const f2 = n2.getDefaultScene();
          return f2 && (r2.scene = n2.listScenes().indexOf(f2)), r2.extensionsUsed = l2.map((e4) => e4.extensionName), r2.extensionsRequired = c2.map((e4) => e4.extensionName), l2.forEach((e4) => e4.write(s2)), function(e4) {
            const t4 = [];
            for (const n3 in e4) {
              const r3 = e4[n3];
              (Array.isArray(r3) && 0 === r3.length || null === r3 || "" === r3 || r3 && "object" == typeof r3 && 0 === Object.keys(r3).length) && t4.push(n3);
            }
            for (const n3 of t4)
              delete e4[n3];
          }(r2), i2;
        }
      }).write(e2, { format: t2.format || Sb.GLTF, basename: t2.basename || "", logger: this.M, vertexLayout: this.U, dependencies: xw({}, this.F), extensions: Array.from(this.h) });
    }
    async writeBinary(e2) {
      const { json: t2, resources: n2 } = await this.writeJSON(e2, { format: Sb.GLB }), r2 = new Uint32Array([1179937895, 2, 12]), i2 = JSON.stringify(t2), s2 = Ob.pad(Ob.encodeText(i2), 32), o2 = Ob.toView(new Uint32Array([s2.byteLength, 1313821514])), a2 = Ob.concat([o2, s2]);
      r2[r2.length - 1] += a2.byteLength;
      const l2 = Object.values(n2)[0];
      if (!l2 || !l2.byteLength)
        return Ob.concat([Ob.toView(r2), a2]);
      const c2 = Ob.pad(l2, 0), u2 = Ob.toView(new Uint32Array([c2.byteLength, 5130562])), p2 = Ob.concat([u2, c2]);
      return r2[r2.length - 1] += p2.byteLength, Ob.concat([Ob.toView(r2), a2, p2]);
    }
    async L(e2, t2) {
      var n2 = this;
      const r2 = [...e2.json.images || [], ...e2.json.buffers || []].map(async function(r3) {
        const i2 = r3.uri;
        if (!i2 || i2.match(/data:/))
          return Promise.resolve();
        e2.resources[i2] = await n2.readURI(n2.resolve(t2, i2), "view"), n2.lastReadBytes += e2.resources[i2].byteLength;
      });
      await Promise.all(r2);
    }
    j(e2) {
      function t2(t3) {
        if (t3.uri) {
          if (t3.uri in e2.resources)
            Ob.assertView(e2.resources[t3.uri]);
          else if (t3.uri.match(/data:/)) {
            const n2 = `__${function() {
              for (let e3 = 0; e3 < 999; e3++) {
                const e4 = ew();
                if (!$b.has(e4))
                  return $b.add(e4), e4;
              }
              return "";
            }()}.${jb.extension(t3.uri)}`;
            e2.resources[n2] = Ob.createBufferFromDataURI(t3.uri), t3.uri = n2;
          }
        }
      }
      (e2.json.images || []).forEach((e3) => {
        if (void 0 === e3.bufferView && void 0 === e3.uri)
          throw new Error("Missing resource URI or buffer view.");
        t2(e3);
      }), (e2.json.buffers || []).forEach(t2);
    }
    D(e2) {
      const { images: t2, buffers: n2 } = e2.json;
      return e2 = { json: xw({}, e2.json), resources: xw({}, e2.resources) }, t2 && (e2.json.images = t2.map((e3) => xw({}, e3))), n2 && (e2.json.buffers = n2.map((e3) => xw({}, e3))), e2;
    }
    P(e2) {
      if (!Gw(e2))
        throw new Error("Invalid glTF 2.0 binary.");
      const t2 = new Uint32Array(e2.buffer, e2.byteOffset + 12, 2);
      if (t2[1] !== jw.JSON)
        throw new Error("Missing required GLB JSON chunk.");
      const n2 = t2[0], r2 = Ob.decodeText(Ob.toView(e2, 20, n2)), i2 = JSON.parse(r2), s2 = 20 + n2;
      if (e2.byteLength <= s2)
        return { json: i2, resources: {} };
      const o2 = new Uint32Array(e2.buffer, e2.byteOffset + s2, 2);
      if (o2[1] !== jw.BIN)
        throw new Error("Expected GLB BIN in second chunk.");
      return { json: i2, resources: { "@glb.bin": Ob.toView(e2, s2 + 8, o2[0]) } };
    }
  }
  function Gw(e2) {
    if (e2.byteLength < 3 * Uint32Array.BYTES_PER_ELEMENT)
      return false;
    const t2 = new Uint32Array(e2.buffer, e2.byteOffset, 3);
    return 1179937895 === t2[0] && 2 === t2[1];
  }
  class Vw extends zw {
    constructor(e2 = tw.DEFAULT_INIT) {
      super(), this.k = void 0, this.k = e2;
    }
    async readURI(e2, t2) {
      const n2 = await fetch(e2, this.k);
      switch (t2) {
        case "view":
          return new Uint8Array(await n2.arrayBuffer());
        case "text":
          return n2.text();
      }
    }
    resolve(e2, t2) {
      return tw.resolve(e2, t2);
    }
    dirname(e2) {
      return tw.dirname(e2);
    }
  }
  const Hw = 64;
  class Qw {
    constructor() {
      this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{ vendorId: 0, descriptorType: 0, descriptorBlockSize: 0, versionNumber: 2, colorModel: 0, colorPrimaries: 1, transferFunction: 2, flags: 0, texelBlockDimension: [0, 0, 0, 0], bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0], samples: [] }], this.keyValue = {}, this.globalData = null;
    }
  }
  class Ww {
    constructor(e2, t2, n2, r2) {
      this._dataView = void 0, this._littleEndian = void 0, this._offset = void 0, this._dataView = new DataView(e2.buffer, e2.byteOffset + t2, n2), this._littleEndian = r2, this._offset = 0;
    }
    _nextUint8() {
      const e2 = this._dataView.getUint8(this._offset);
      return this._offset += 1, e2;
    }
    _nextUint16() {
      const e2 = this._dataView.getUint16(this._offset, this._littleEndian);
      return this._offset += 2, e2;
    }
    _nextUint32() {
      const e2 = this._dataView.getUint32(this._offset, this._littleEndian);
      return this._offset += 4, e2;
    }
    _nextUint64() {
      const e2 = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
      return this._offset += 8, e2;
    }
    _nextInt32() {
      const e2 = this._dataView.getInt32(this._offset, this._littleEndian);
      return this._offset += 4, e2;
    }
    _skip(e2) {
      return this._offset += e2, this;
    }
    _scan(e2, t2 = 0) {
      const n2 = this._offset;
      let r2 = 0;
      for (; this._dataView.getUint8(this._offset) !== t2 && r2 < e2; )
        r2++, this._offset++;
      return r2 < e2 && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n2, r2);
    }
  }
  new Uint8Array([0]);
  const qw = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
  function Xw(e2) {
    return "undefined" != typeof TextDecoder ? new TextDecoder().decode(e2) : Buffer.from(e2).toString("utf8");
  }
  function Yw(e2) {
    const t2 = new Uint8Array(e2.buffer, e2.byteOffset, qw.length);
    if (t2[0] !== qw[0] || t2[1] !== qw[1] || t2[2] !== qw[2] || t2[3] !== qw[3] || t2[4] !== qw[4] || t2[5] !== qw[5] || t2[6] !== qw[6] || t2[7] !== qw[7] || t2[8] !== qw[8] || t2[9] !== qw[9] || t2[10] !== qw[10] || t2[11] !== qw[11])
      throw new Error("Missing KTX 2.0 identifier.");
    const n2 = new Qw(), r2 = 17 * Uint32Array.BYTES_PER_ELEMENT, i2 = new Ww(e2, qw.length, r2, true);
    n2.vkFormat = i2._nextUint32(), n2.typeSize = i2._nextUint32(), n2.pixelWidth = i2._nextUint32(), n2.pixelHeight = i2._nextUint32(), n2.pixelDepth = i2._nextUint32(), n2.layerCount = i2._nextUint32(), n2.faceCount = i2._nextUint32();
    const s2 = i2._nextUint32();
    n2.supercompressionScheme = i2._nextUint32();
    const o2 = i2._nextUint32(), a2 = i2._nextUint32(), l2 = i2._nextUint32(), c2 = i2._nextUint32(), u2 = i2._nextUint64(), p2 = i2._nextUint64(), d2 = 3 * s2 * 8, h2 = new Ww(e2, qw.length + r2, d2, true);
    for (let t3 = 0; t3 < s2; t3++)
      n2.levels.push({ levelData: new Uint8Array(e2.buffer, e2.byteOffset + h2._nextUint64(), h2._nextUint64()), uncompressedByteLength: h2._nextUint64() });
    const f2 = new Ww(e2, o2, a2, true), m2 = { vendorId: f2._skip(4)._nextUint16(), descriptorType: f2._nextUint16(), versionNumber: f2._nextUint16(), descriptorBlockSize: f2._nextUint16(), colorModel: f2._nextUint8(), colorPrimaries: f2._nextUint8(), transferFunction: f2._nextUint8(), flags: f2._nextUint8(), texelBlockDimension: [f2._nextUint8(), f2._nextUint8(), f2._nextUint8(), f2._nextUint8()], bytesPlane: [f2._nextUint8(), f2._nextUint8(), f2._nextUint8(), f2._nextUint8(), f2._nextUint8(), f2._nextUint8(), f2._nextUint8(), f2._nextUint8()], samples: [] }, _2 = (m2.descriptorBlockSize / 4 - 6) / 4;
    for (let e3 = 0; e3 < _2; e3++) {
      const t3 = { bitOffset: f2._nextUint16(), bitLength: f2._nextUint8(), channelType: f2._nextUint8(), samplePosition: [f2._nextUint8(), f2._nextUint8(), f2._nextUint8(), f2._nextUint8()], sampleLower: -1 / 0, sampleUpper: 1 / 0 };
      t3.channelType & Hw ? (t3.sampleLower = f2._nextInt32(), t3.sampleUpper = f2._nextInt32()) : (t3.sampleLower = f2._nextUint32(), t3.sampleUpper = f2._nextUint32()), m2.samples[e3] = t3;
    }
    n2.dataFormatDescriptor.length = 0, n2.dataFormatDescriptor.push(m2);
    const g2 = new Ww(e2, l2, c2, true);
    for (; g2._offset < c2; ) {
      const e3 = g2._nextUint32(), t3 = g2._scan(e3), r3 = Xw(t3), i3 = g2._scan(e3 - t3.byteLength);
      n2.keyValue[r3] = r3.match(/^ktx/i) ? Xw(i3) : i3, g2._offset % 4 && g2._skip(4 - g2._offset % 4);
    }
    if (p2 <= 0)
      return n2;
    const v2 = new Ww(e2, u2, p2, true), y2 = v2._nextUint16(), b2 = v2._nextUint16(), w2 = v2._nextUint32(), A2 = v2._nextUint32(), x2 = v2._nextUint32(), E2 = v2._nextUint32(), C2 = [];
    for (let e3 = 0; e3 < s2; e3++)
      C2.push({ imageFlags: v2._nextUint32(), rgbSliceByteOffset: v2._nextUint32(), rgbSliceByteLength: v2._nextUint32(), alphaSliceByteOffset: v2._nextUint32(), alphaSliceByteLength: v2._nextUint32() });
    const S2 = u2 + v2._offset, M2 = S2 + w2, T2 = M2 + A2, P2 = T2 + x2, I2 = new Uint8Array(e2.buffer, e2.byteOffset + S2, w2), R2 = new Uint8Array(e2.buffer, e2.byteOffset + M2, A2), k2 = new Uint8Array(e2.buffer, e2.byteOffset + T2, x2), D2 = new Uint8Array(e2.buffer, e2.byteOffset + P2, E2);
    return n2.globalData = { endpointCount: y2, selectorCount: b2, imageDescs: C2, endpointsData: I2, selectorsData: R2, tablesData: k2, extendedData: D2 }, n2;
  }
  class Kw extends dw {
    init() {
      this.extensionName = "EXT_mesh_gpu_instancing", this.propertyType = "InstancedMesh", this.parentTypes = [Ab.NODE];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { attributes: {} });
    }
    getAttribute(e2) {
      return this.getRefMap("attributes", e2);
    }
    setAttribute(e2, t2) {
      return this.setRefMap("attributes", e2, t2, { usage: "INSTANCE_ATTRIBUTE" });
    }
    listAttributes() {
      return this.listRefMapValues("attributes");
    }
    listSemantics() {
      return this.listRefMapKeys("attributes");
    }
  }
  Kw.EXTENSION_NAME = "EXT_mesh_gpu_instancing";
  const Jw = "EXT_mesh_gpu_instancing";
  class Zw extends Pw {
    constructor(...e2) {
      super(...e2), this.extensionName = Jw, this.provideTypes = [Ab.NODE], this.prewriteTypes = [Ab.ACCESSOR];
    }
    createInstancedMesh() {
      return new Kw(this.document.getGraph());
    }
    read(e2) {
      return (e2.jsonDoc.json.nodes || []).forEach((t2, n2) => {
        if (!t2.extensions || !t2.extensions[Jw])
          return;
        const r2 = t2.extensions[Jw], i2 = this.createInstancedMesh();
        for (const t3 in r2.attributes)
          i2.setAttribute(t3, e2.accessors[r2.attributes[t3]]);
        e2.nodes[n2].setExtension(Jw, i2);
      }), this;
    }
    prewrite(e2) {
      e2.accessorUsageGroupedByParent.add("INSTANCE_ATTRIBUTE");
      for (const t2 of this.properties)
        for (const n2 of t2.listAttributes())
          e2.addAccessorToUsageGroup(n2, "INSTANCE_ATTRIBUTE");
      return this;
    }
    write(e2) {
      const t2 = e2.jsonDoc;
      return this.document.getRoot().listNodes().forEach((n2) => {
        const r2 = n2.getExtension(Jw);
        if (r2) {
          const i2 = e2.nodeIndexMap.get(n2), s2 = t2.json.nodes[i2], o2 = { attributes: {} };
          r2.listSemantics().forEach((t3) => {
            const n3 = r2.getAttribute(t3);
            o2.attributes[t3] = e2.accessorIndexMap.get(n3);
          }), s2.extensions = s2.extensions || {}, s2.extensions[Jw] = o2;
        }
      }), this;
    }
  }
  function $w() {
    return ($w = Object.assign || function(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var n2 = arguments[t2];
        for (var r2 in n2)
          Object.prototype.hasOwnProperty.call(n2, r2) && (e2[r2] = n2[r2]);
      }
      return e2;
    }).apply(this, arguments);
  }
  var eA, tA, nA;
  Zw.EXTENSION_NAME = Jw, function(e2) {
    e2.QUANTIZE = "quantize", e2.FILTER = "filter";
  }(eA || (eA = {})), function(e2) {
    e2.ATTRIBUTES = "ATTRIBUTES", e2.TRIANGLES = "TRIANGLES", e2.INDICES = "INDICES";
  }(tA || (tA = {})), function(e2) {
    e2.NONE = "NONE", e2.OCTAHEDRAL = "OCTAHEDRAL", e2.QUATERNION = "QUATERNION", e2.EXPONENTIAL = "EXPONENTIAL";
  }(nA || (nA = {}));
  const { BYTE: rA, SHORT: iA, FLOAT: sA } = ow.ComponentType, { encodeNormalizedInt: oA, decodeNormalizedInt: aA } = Qb;
  function lA(e2, t2, n2, r2) {
    const { filter: i2, bits: s2 } = r2, o2 = { array: e2.getArray(), byteStride: e2.getElementSize() * e2.getComponentSize(), componentType: e2.getComponentType(), normalized: e2.getNormalized() };
    if (n2 !== tA.ATTRIBUTES)
      return o2;
    if (i2 !== nA.NONE) {
      let n3 = e2.getNormalized() ? function(e3) {
        const t3 = e3.getComponentType(), n4 = e3.getArray(), r3 = new Float32Array(n4.length);
        for (let e4 = 0; e4 < n4.length; e4++)
          r3[e4] = aA(n4[e4], t3);
        return r3;
      }(e2) : new Float32Array(o2.array);
      switch (i2) {
        case nA.EXPONENTIAL:
          o2.byteStride = 4 * e2.getElementSize(), o2.componentType = sA, o2.normalized = false, o2.array = t2.encodeFilterExp(n3, e2.getCount(), o2.byteStride, s2);
          break;
        case nA.OCTAHEDRAL:
          o2.byteStride = s2 > 8 ? 8 : 4, o2.componentType = s2 > 8 ? iA : rA, o2.normalized = true, n3 = 3 === e2.getElementSize() ? function(e3) {
            const t3 = new Float32Array(4 * e3.length / 3);
            for (let n4 = 0, r3 = e3.length / 3; n4 < r3; n4++)
              t3[4 * n4] = e3[3 * n4], t3[4 * n4 + 1] = e3[3 * n4 + 1], t3[4 * n4 + 2] = e3[3 * n4 + 2];
            return t3;
          }(n3) : n3, o2.array = t2.encodeFilterOct(n3, e2.getCount(), o2.byteStride, s2);
          break;
        case nA.QUATERNION:
          o2.byteStride = 8, o2.componentType = iA, o2.normalized = true, o2.array = t2.encodeFilterQuat(n3, e2.getCount(), o2.byteStride, s2);
          break;
        default:
          throw new Error("Invalid filter.");
      }
      o2.min = e2.getMin([]), o2.max = e2.getMax([]), e2.getNormalized() && (o2.min = o2.min.map((t3) => aA(t3, e2.getComponentType())), o2.max = o2.max.map((t3) => aA(t3, e2.getComponentType()))), o2.normalized && (o2.min = o2.min.map((e3) => oA(e3, o2.componentType)), o2.max = o2.max.map((e3) => oA(e3, o2.componentType)));
    } else
      o2.byteStride % 4 && (o2.array = function(e3, t3) {
        const n3 = Ob.padNumber(e3.BYTES_PER_ELEMENT * t3) / e3.BYTES_PER_ELEMENT, r3 = new e3.constructor(e3.length / t3 * n3);
        for (let i3 = 0; i3 * t3 < e3.length; i3++)
          for (let s3 = 0; s3 < t3; s3++)
            r3[i3 * n3 + s3] = e3[i3 * t3 + s3];
        return r3;
      }(o2.array, e2.getElementSize()), o2.byteStride = o2.array.byteLength / e2.getCount());
    return o2;
  }
  function cA(e2, t2) {
    return t2 === Bw.BufferViewUsage.ELEMENT_ARRAY_BUFFER ? e2.listParents().some((e3) => e3 instanceof ww && e3.getMode() === ww.Mode.TRIANGLES) ? tA.TRIANGLES : tA.INDICES : tA.ATTRIBUTES;
  }
  function uA(e2, t2) {
    const n2 = t2.getGraph().listParentEdges(e2).filter((e3) => !(e3.getParent() instanceof Mw));
    for (const t3 of n2) {
      const n3 = t3.getName(), r2 = t3.getAttributes().key || "";
      if ("indices" === n3)
        return { filter: nA.NONE };
      if ("attributes" === n3) {
        if ("POSITION" === r2)
          return { filter: nA.NONE };
        if ("TEXCOORD_0" === r2)
          return { filter: nA.NONE };
        if ("NORMAL" === r2)
          return { filter: nA.OCTAHEDRAL, bits: 8 };
        if ("TANGENT" === r2)
          return { filter: nA.OCTAHEDRAL, bits: 8 };
        if (r2.startsWith("JOINTS_"))
          return { filter: nA.NONE };
        if (r2.startsWith("WEIGHTS_"))
          return { filter: nA.NONE };
      }
      if ("output" === n3) {
        const t4 = pA(e2);
        return "rotation" === t4 ? { filter: nA.QUATERNION, bits: 16 } : "translation" === t4 || "scale" === t4 ? { filter: nA.EXPONENTIAL, bits: 12 } : { filter: nA.NONE };
      }
      if ("input" === n3)
        return { filter: nA.NONE };
      if ("inverseBindMatrices" === n3)
        return { filter: nA.NONE };
    }
    return { filter: nA.NONE };
  }
  function pA(e2) {
    for (const t2 of e2.listParents())
      if (t2 instanceof cw) {
        for (const e3 of t2.listParents())
          if (e3 instanceof lw)
            return e3.getTargetPath();
      }
    return null;
  }
  const dA = "EXT_meshopt_compression", hA = { method: eA.QUANTIZE };
  class fA extends Pw {
    constructor(...e2) {
      super(...e2), this.extensionName = dA, this.prereadTypes = [Ab.BUFFER, Ab.PRIMITIVE], this.prewriteTypes = [Ab.BUFFER, Ab.ACCESSOR], this.readDependencies = ["meshopt.decoder"], this.writeDependencies = ["meshopt.encoder"], this._decoder = null, this._decoderFallbackBufferMap = /* @__PURE__ */ new Map(), this._encoder = null, this._encoderOptions = hA, this._encoderFallbackBuffer = null, this._encoderBufferViews = {}, this._encoderBufferViewData = {}, this._encoderBufferViewAccessors = {};
    }
    install(e2, t2) {
      return "meshopt.decoder" === e2 && (this._decoder = t2), "meshopt.encoder" === e2 && (this._encoder = t2), this;
    }
    setEncoderOptions(e2) {
      return this._encoderOptions = $w({}, hA, e2), this;
    }
    preread(e2, t2) {
      if (!this._decoder) {
        if (!this.isRequired())
          return this;
        throw new Error(`[${dA}] Please install extension dependency, "meshopt.decoder".`);
      }
      if (!this._decoder.supported) {
        if (!this.isRequired())
          return this;
        throw new Error(`[${dA}]: Missing WASM support.`);
      }
      return t2 === Ab.BUFFER ? this._prereadBuffers(e2) : t2 === Ab.PRIMITIVE && this._prereadPrimitives(e2), this;
    }
    _prereadBuffers(e2) {
      const t2 = e2.jsonDoc;
      (t2.json.bufferViews || []).forEach((n2, r2) => {
        if (!n2.extensions || !n2.extensions[dA])
          return;
        const i2 = n2.extensions[dA], s2 = i2.byteOffset || 0, o2 = i2.byteLength || 0, a2 = i2.count, l2 = i2.byteStride, c2 = new Uint8Array(a2 * l2), u2 = t2.json.buffers[i2.buffer], p2 = Ob.toView(u2.uri ? t2.resources[u2.uri] : t2.resources[wb], s2, o2);
        this._decoder.decodeGltfBuffer(c2, a2, l2, p2, i2.mode, i2.filter), e2.bufferViews[r2] = c2;
      });
    }
    _prereadPrimitives(e2) {
      const t2 = e2.jsonDoc;
      (t2.json.bufferViews || []).forEach((n2) => {
        var r2;
        n2.extensions && n2.extensions[dA] && (r2 = t2.json.buffers[n2.buffer]).extensions && r2.extensions.EXT_meshopt_compression && r2.extensions.EXT_meshopt_compression.fallback && this._decoderFallbackBufferMap.set(e2.buffers[n2.buffer], e2.buffers[n2.extensions[dA].buffer]);
      });
    }
    read(e2) {
      if (!this.isRequired())
        return this;
      for (const [e3, t2] of this._decoderFallbackBufferMap) {
        for (const n2 of e3.listParents())
          n2 instanceof ow && n2.swap(e3, t2);
        e3.dispose();
      }
      return this;
    }
    prewrite(e2, t2) {
      return t2 === Ab.ACCESSOR ? this._prewriteAccessors(e2) : t2 === Ab.BUFFER && this._prewriteBuffers(e2), this;
    }
    _prewriteAccessors(e2) {
      const t2 = e2.jsonDoc.json, n2 = this._encoder, r2 = this._encoderOptions, i2 = this.document.createBuffer(), s2 = this.document.getRoot().listBuffers().indexOf(i2);
      this._encoderFallbackBuffer = i2, this._encoderBufferViews = {}, this._encoderBufferViewData = {}, this._encoderBufferViewAccessors = {};
      for (const i3 of this.document.getRoot().listAccessors()) {
        if ("weights" === pA(i3))
          continue;
        if (i3.getSparse())
          continue;
        const o2 = e2.getAccessorUsage(i3), a2 = cA(i3, o2), l2 = r2.method === eA.FILTER ? uA(i3, this.document) : { filter: nA.NONE }, c2 = lA(i3, n2, a2, l2), { array: u2, byteStride: p2 } = c2, d2 = i3.getBuffer();
        if (!d2)
          throw new Error(`${dA}: Missing buffer for accessor.`);
        const h2 = this.document.getRoot().listBuffers().indexOf(d2), f2 = [o2, a2, l2.filter, p2, h2].join(":");
        let m2 = this._encoderBufferViews[f2], _2 = this._encoderBufferViewData[f2], g2 = this._encoderBufferViewAccessors[f2];
        m2 && _2 || (g2 = this._encoderBufferViewAccessors[f2] = [], _2 = this._encoderBufferViewData[f2] = [], m2 = this._encoderBufferViews[f2] = { buffer: s2, target: Bw.USAGE_TO_TARGET[o2], byteOffset: 0, byteLength: 0, byteStride: o2 === Bw.BufferViewUsage.ARRAY_BUFFER ? p2 : void 0, extensions: { [dA]: { buffer: h2, byteOffset: 0, byteLength: 0, mode: a2, filter: l2.filter !== nA.NONE ? l2.filter : void 0, byteStride: p2, count: 0 } } });
        const v2 = e2.createAccessorDef(i3);
        v2.componentType = c2.componentType, v2.normalized = c2.normalized, v2.byteOffset = m2.byteLength, v2.min && c2.min && (v2.min = c2.min), v2.max && c2.max && (v2.max = c2.max), e2.accessorIndexMap.set(i3, t2.accessors.length), t2.accessors.push(v2), g2.push(v2), _2.push(new Uint8Array(u2.buffer, u2.byteOffset, u2.byteLength)), m2.byteLength += u2.byteLength, m2.extensions.EXT_meshopt_compression.count += i3.getCount();
      }
    }
    _prewriteBuffers(e2) {
      const t2 = this._encoder;
      for (const n2 in this._encoderBufferViews) {
        const r2 = this._encoderBufferViews[n2], i2 = this._encoderBufferViewData[n2], s2 = this.document.getRoot().listBuffers()[r2.extensions[dA].buffer], o2 = e2.otherBufferViews.get(s2) || [], { count: a2, byteStride: l2, mode: c2 } = r2.extensions[dA], u2 = Ob.concat(i2), p2 = t2.encodeGltfBuffer(u2, a2, l2, c2), d2 = Ob.pad(p2);
        r2.extensions[dA].byteLength = p2.byteLength, i2.length = 0, i2.push(d2), o2.push(d2), e2.otherBufferViews.set(s2, o2);
      }
    }
    write(e2) {
      let t2 = 0;
      for (const n3 in this._encoderBufferViews) {
        const r3 = this._encoderBufferViews[n3], i3 = e2.otherBufferViewsIndexMap.get(this._encoderBufferViewData[n3][0]), s2 = this._encoderBufferViewAccessors[n3];
        for (const e3 of s2)
          e3.bufferView = i3;
        const o2 = e2.jsonDoc.json.bufferViews[i3], a2 = o2.byteOffset || 0;
        Object.assign(o2, r3), o2.byteOffset = t2, o2.extensions[dA].byteOffset = a2, t2 += Ob.padNumber(r3.byteLength);
      }
      const n2 = this._encoderFallbackBuffer, r2 = e2.bufferIndexMap.get(n2), i2 = e2.jsonDoc.json.buffers[r2];
      return i2.byteLength = t2, i2.extensions = { [dA]: { fallback: true } }, n2.dispose(), this;
    }
  }
  fA.EXTENSION_NAME = dA, fA.EncoderMethod = eA;
  const mA = "EXT_texture_avif";
  class _A {
    match(e2) {
      return e2.length >= 12 && "ftypavif" === Ob.decodeText(e2.slice(4, 12));
    }
    getSize(e2) {
      if (!this.match(e2))
        return null;
      const t2 = new DataView(e2.buffer, e2.byteOffset, e2.byteLength);
      let n2 = vA(t2, 0);
      if (!n2)
        return null;
      let r2 = n2.end;
      for (; n2 = vA(t2, r2); )
        if ("meta" === n2.type)
          r2 = n2.start + 4;
        else if ("iprp" === n2.type || "ipco" === n2.type)
          r2 = n2.start;
        else {
          if ("ispe" === n2.type)
            return [t2.getUint32(n2.start + 4), t2.getUint32(n2.start + 8)];
          if ("mdat" === n2.type)
            break;
          r2 = n2.end;
        }
      return null;
    }
    getChannels(e2) {
      return 4;
    }
  }
  class gA extends Pw {
    constructor(...e2) {
      super(...e2), this.extensionName = mA, this.prereadTypes = [Ab.TEXTURE];
    }
    static register() {
      Fb.registerFormat("image/avif", new _A());
    }
    preread(e2) {
      return (e2.jsonDoc.json.textures || []).forEach((e3) => {
        e3.extensions && e3.extensions[mA] && (e3.source = e3.extensions[mA].source);
      }), this;
    }
    read(e2) {
      return this;
    }
    write(e2) {
      const t2 = e2.jsonDoc;
      return this.document.getRoot().listTextures().forEach((n2) => {
        if ("image/avif" === n2.getMimeType()) {
          const r2 = e2.imageIndexMap.get(n2);
          (t2.json.textures || []).forEach((e3) => {
            e3.source === r2 && (e3.extensions = e3.extensions || {}, e3.extensions[mA] = { source: e3.source }, delete e3.source);
          });
        }
      }), this;
    }
  }
  function vA(e2, t2) {
    if (e2.byteLength < 4 + t2)
      return null;
    const n2 = e2.getUint32(t2);
    return e2.byteLength < n2 + t2 || n2 < 8 ? null : { type: Ob.decodeText(new Uint8Array(e2.buffer, e2.byteOffset + t2 + 4, 4)), start: t2 + 8, end: t2 + n2 };
  }
  gA.EXTENSION_NAME = mA;
  const yA = "EXT_texture_webp";
  class bA {
    match(e2) {
      return e2.length >= 12 && 87 === e2[8] && 69 === e2[9] && 66 === e2[10] && 80 === e2[11];
    }
    getSize(e2) {
      const t2 = Ob.decodeText(e2.slice(0, 4)), n2 = Ob.decodeText(e2.slice(8, 12));
      if ("RIFF" !== t2 || "WEBP" !== n2)
        return null;
      const r2 = new DataView(e2.buffer, e2.byteOffset);
      let i2 = 12;
      for (; i2 < r2.byteLength; ) {
        const e3 = Ob.decodeText(new Uint8Array([r2.getUint8(i2), r2.getUint8(i2 + 1), r2.getUint8(i2 + 2), r2.getUint8(i2 + 3)])), t3 = r2.getUint32(i2 + 4, true);
        if ("VP8 " === e3)
          return [16383 & r2.getInt16(i2 + 14, true), 16383 & r2.getInt16(i2 + 16, true)];
        if ("VP8L" === e3) {
          const e4 = r2.getUint8(i2 + 9), t4 = r2.getUint8(i2 + 10), n3 = r2.getUint8(i2 + 11);
          return [1 + ((63 & t4) << 8 | e4), 1 + ((15 & r2.getUint8(i2 + 12)) << 10 | n3 << 2 | (192 & t4) >> 6)];
        }
        i2 += 8 + t3 + t3 % 2;
      }
      return null;
    }
    getChannels(e2) {
      return 4;
    }
  }
  class wA extends Pw {
    constructor(...e2) {
      super(...e2), this.extensionName = yA, this.prereadTypes = [Ab.TEXTURE];
    }
    static register() {
      Fb.registerFormat("image/webp", new bA());
    }
    preread(e2) {
      return (e2.jsonDoc.json.textures || []).forEach((e3) => {
        e3.extensions && e3.extensions[yA] && (e3.source = e3.extensions[yA].source);
      }), this;
    }
    read(e2) {
      return this;
    }
    write(e2) {
      const t2 = e2.jsonDoc;
      return this.document.getRoot().listTextures().forEach((n2) => {
        if ("image/webp" === n2.getMimeType()) {
          const r2 = e2.imageIndexMap.get(n2);
          (t2.json.textures || []).forEach((e3) => {
            e3.source === r2 && (e3.extensions = e3.extensions || {}, e3.extensions[yA] = { source: e3.source }, delete e3.source);
          });
        }
      }), this;
    }
  }
  wA.EXTENSION_NAME = yA;
  const AA = "KHR_draco_mesh_compression";
  let xA, EA, CA, SA;
  function MA(e2, t2) {
    const n2 = new xA.DecoderBuffer();
    try {
      if (n2.Init(t2, t2.length), e2.GetEncodedGeometryType(n2) !== xA.TRIANGULAR_MESH)
        throw new Error(`[${AA}] Unknown geometry type.`);
      const r2 = new xA.Mesh();
      if (!e2.DecodeBufferToMesh(n2, r2).ok() || 0 === r2.ptr)
        throw new Error(`[${AA}] Decoding failure.`);
      return r2;
    } finally {
      xA.destroy(n2);
    }
  }
  function TA(e2, t2) {
    const n2 = 3 * t2.num_faces();
    let r2, i2;
    if (t2.num_points() <= 65534) {
      const s2 = n2 * Uint16Array.BYTES_PER_ELEMENT;
      r2 = xA._malloc(s2), e2.GetTrianglesUInt16Array(t2, s2, r2), i2 = new Uint16Array(xA.HEAPU16.buffer, r2, n2).slice();
    } else {
      const s2 = n2 * Uint32Array.BYTES_PER_ELEMENT;
      r2 = xA._malloc(s2), e2.GetTrianglesUInt32Array(t2, s2, r2), i2 = new Uint32Array(xA.HEAPU32.buffer, r2, n2).slice();
    }
    return xA._free(r2), i2;
  }
  function PA(e2, t2, n2, r2) {
    const i2 = CA[r2.componentType], s2 = EA[r2.componentType], o2 = n2.num_components(), a2 = t2.num_points() * o2, l2 = a2 * s2.BYTES_PER_ELEMENT, c2 = xA._malloc(l2);
    e2.GetAttributeDataArrayForAllPoints(t2, n2, i2, l2, c2);
    const u2 = new s2(xA.HEAPF32.buffer, c2, a2).slice();
    return xA._free(c2), u2;
  }
  var IA, RA;
  !function(e2) {
    e2[e2.EDGEBREAKER = 1] = "EDGEBREAKER", e2[e2.SEQUENTIAL = 0] = "SEQUENTIAL";
  }(IA || (IA = {})), function(e2) {
    e2.POSITION = "POSITION", e2.NORMAL = "NORMAL", e2.COLOR = "COLOR", e2.TEX_COORD = "TEX_COORD", e2.GENERIC = "GENERIC";
  }(RA || (RA = {}));
  const kA = { [RA.POSITION]: 14, [RA.NORMAL]: 10, [RA.COLOR]: 8, [RA.TEX_COORD]: 12, [RA.GENERIC]: 12 }, DA = { decodeSpeed: 5, encodeSpeed: 5, method: IA.EDGEBREAKER, quantizationBits: kA, quantizationVolume: "mesh" };
  function BA(e2, t2 = DA) {
    const n2 = $w({}, DA, t2);
    n2.quantizationBits = $w({}, kA, t2.quantizationBits);
    const r2 = new SA.Encoder(), i2 = new SA.MeshBuilder(), s2 = new SA.Mesh(), o2 = {}, a2 = new SA.DracoInt8Array(), l2 = e2.listTargets().length > 0;
    let c2 = false;
    for (const t3 of e2.listSemantics()) {
      const a3 = e2.getAttribute(t3);
      if (a3.getSparse()) {
        c2 = true;
        continue;
      }
      const l3 = OA(t3), u3 = LA(i2, a3.getComponentType(), s2, SA[l3], a3.getCount(), a3.getElementSize(), a3.getArray());
      if (-1 === u3)
        throw new Error(`Error compressing "${t3}" attribute.`);
      if (o2[t3] = u3, "mesh" === n2.quantizationVolume || "POSITION" !== t3)
        r2.SetAttributeQuantization(SA[l3], n2.quantizationBits[l3]);
      else {
        if ("object" != typeof n2.quantizationVolume)
          throw new Error("Invalid quantization volume state.");
        {
          const { quantizationVolume: e3 } = n2, t4 = Math.max(e3.max[0] - e3.min[0], e3.max[1] - e3.min[1], e3.max[2] - e3.min[2]);
          r2.SetAttributeExplicitQuantization(SA[l3], n2.quantizationBits[l3], a3.getElementSize(), e3.min, t4);
        }
      }
    }
    const u2 = e2.getIndices();
    if (!u2)
      throw new UA("Primitive must have indices.");
    i2.AddFacesToMesh(s2, u2.getCount() / 3, u2.getArray()), r2.SetSpeedOptions(n2.encodeSpeed, n2.decodeSpeed), r2.SetTrackEncodedProperties(true), r2.SetEncodingMethod(n2.method === IA.SEQUENTIAL || l2 || c2 ? SA.MESH_SEQUENTIAL_ENCODING : SA.MESH_EDGEBREAKER_ENCODING);
    const p2 = r2.EncodeMeshToDracoBuffer(s2, a2);
    if (p2 <= 0)
      throw new UA("Error applying Draco compression.");
    const d2 = new Uint8Array(p2);
    for (let e3 = 0; e3 < p2; ++e3)
      d2[e3] = a2.GetValue(e3);
    const h2 = e2.getAttribute("POSITION").getCount(), f2 = r2.GetNumberOfEncodedPoints(), m2 = 3 * r2.GetNumberOfEncodedFaces();
    if ((l2 || c2) && f2 !== h2)
      throw new UA('Compression reduced vertex count unexpectedly, corrupting mesh data. Applying the "weld" function before compression may resolve the issue. See: https://github.com/google/draco/issues/929');
    return SA.destroy(a2), SA.destroy(s2), SA.destroy(i2), SA.destroy(r2), { numVertices: f2, numIndices: m2, data: d2, attributeIDs: o2 };
  }
  function OA(e2) {
    return "POSITION" === e2 ? RA.POSITION : "NORMAL" === e2 ? RA.NORMAL : e2.startsWith("COLOR_") ? RA.COLOR : e2.startsWith("TEXCOORD_") ? RA.TEX_COORD : RA.GENERIC;
  }
  function LA(e2, t2, n2, r2, i2, s2, o2) {
    switch (t2) {
      case ow.ComponentType.UNSIGNED_BYTE:
        return e2.AddUInt8Attribute(n2, r2, i2, s2, o2);
      case ow.ComponentType.BYTE:
        return e2.AddInt8Attribute(n2, r2, i2, s2, o2);
      case ow.ComponentType.UNSIGNED_SHORT:
        return e2.AddUInt16Attribute(n2, r2, i2, s2, o2);
      case ow.ComponentType.SHORT:
        return e2.AddInt16Attribute(n2, r2, i2, s2, o2);
      case ow.ComponentType.UNSIGNED_INT:
        return e2.AddUInt32Attribute(n2, r2, i2, s2, o2);
      case ow.ComponentType.FLOAT:
        return e2.AddFloatAttribute(n2, r2, i2, s2, o2);
      default:
        throw new Error(`Unexpected component type, "${t2}".`);
    }
  }
  class UA extends Error {
  }
  const FA = "KHR_draco_mesh_compression";
  class NA extends Pw {
    constructor(...e2) {
      super(...e2), this.extensionName = FA, this.prereadTypes = [Ab.PRIMITIVE], this.prewriteTypes = [Ab.ACCESSOR], this.readDependencies = ["draco3d.decoder"], this.writeDependencies = ["draco3d.encoder"], this._decoderModule = null, this._encoderModule = null, this._encoderOptions = {};
    }
    install(e2, t2) {
      return "draco3d.decoder" === e2 && (this._decoderModule = t2, xA = this._decoderModule, EA = { [ow.ComponentType.FLOAT]: Float32Array, [ow.ComponentType.UNSIGNED_INT]: Uint32Array, [ow.ComponentType.UNSIGNED_SHORT]: Uint16Array, [ow.ComponentType.UNSIGNED_BYTE]: Uint8Array, [ow.ComponentType.SHORT]: Int16Array, [ow.ComponentType.BYTE]: Int8Array }, CA = { [ow.ComponentType.FLOAT]: xA.DT_FLOAT32, [ow.ComponentType.UNSIGNED_INT]: xA.DT_UINT32, [ow.ComponentType.UNSIGNED_SHORT]: xA.DT_UINT16, [ow.ComponentType.UNSIGNED_BYTE]: xA.DT_UINT8, [ow.ComponentType.SHORT]: xA.DT_INT16, [ow.ComponentType.BYTE]: xA.DT_INT8 }), "draco3d.encoder" === e2 && (this._encoderModule = t2, SA = this._encoderModule), this;
    }
    setEncoderOptions(e2) {
      return this._encoderOptions = e2, this;
    }
    preread(e2) {
      if (!this._decoderModule)
        throw new Error(`[${FA}] Please install extension dependency, "draco3d.decoder".`);
      const t2 = this.document.getLogger(), n2 = e2.jsonDoc, r2 = /* @__PURE__ */ new Map();
      try {
        const i2 = n2.json.meshes || [];
        for (const s2 of i2)
          for (const i3 of s2.primitives) {
            if (!i3.extensions || !i3.extensions[FA])
              continue;
            const s3 = i3.extensions[FA];
            let [o2, a2] = r2.get(s3.bufferView) || [];
            if (!a2 || !o2) {
              const e3 = n2.json.bufferViews[s3.bufferView], i4 = n2.json.buffers[e3.buffer], l2 = Ob.toView(i4.uri ? n2.resources[i4.uri] : n2.resources[wb], e3.byteOffset || 0, e3.byteLength);
              o2 = new this._decoderModule.Decoder(), a2 = MA(o2, l2), r2.set(s3.bufferView, [o2, a2]), t2.debug(`[${FA}] Decompressed ${l2.byteLength} bytes.`);
            }
            for (const t3 in i3.attributes) {
              const n3 = e2.jsonDoc.json.accessors[i3.attributes[t3]], r3 = o2.GetAttributeByUniqueId(a2, s3.attributes[t3]), l2 = PA(o2, a2, r3, n3);
              e2.accessors[i3.attributes[t3]].setArray(l2);
            }
            void 0 !== i3.indices && e2.accessors[i3.indices].setArray(TA(o2, a2));
          }
      } finally {
        for (const [e3, t3] of Array.from(r2.values()))
          this._decoderModule.destroy(e3), this._decoderModule.destroy(t3);
      }
      return this;
    }
    read(e2) {
      return this;
    }
    prewrite(e2, t2) {
      if (!this._encoderModule)
        throw new Error(`[${FA}] Please install extension dependency, "draco3d.encoder".`);
      const n2 = this.document.getLogger();
      n2.debug(`[${FA}] Compression options: ${JSON.stringify(this._encoderOptions)}`);
      const r2 = function(e3) {
        const t3 = e3.getLogger(), n3 = /* @__PURE__ */ new Set(), r3 = /* @__PURE__ */ new Set();
        for (const i4 of e3.getRoot().listMeshes())
          for (const e4 of i4.listPrimitives())
            e4.getIndices() ? e4.getMode() !== ww.Mode.TRIANGLES ? (r3.add(e4), t3.warn(`[${FA}] Skipping Draco compression on non-TRIANGLES primitive.`)) : n3.add(e4) : (r3.add(e4), t3.warn(`[${FA}] Skipping Draco compression on non-indexed primitive.`));
        const i3 = e3.getRoot().listAccessors(), s3 = /* @__PURE__ */ new Map();
        for (let e4 = 0; e4 < i3.length; e4++)
          s3.set(i3[e4], e4);
        const o2 = /* @__PURE__ */ new Map(), a2 = /* @__PURE__ */ new Set(), l2 = /* @__PURE__ */ new Map();
        for (const t4 of Array.from(n3)) {
          let n4 = jA(t4, s3);
          if (a2.has(n4))
            l2.set(t4, n4);
          else {
            if (o2.has(t4.getIndices())) {
              const n5 = t4.getIndices(), r4 = n5.clone();
              s3.set(r4, e3.getRoot().listAccessors().length - 1), t4.swap(n5, r4);
            }
            for (const n5 of t4.listAttributes())
              if (o2.has(n5)) {
                const r4 = n5.clone();
                s3.set(r4, e3.getRoot().listAccessors().length - 1), t4.swap(n5, r4);
              }
            n4 = jA(t4, s3), a2.add(n4), l2.set(t4, n4), o2.set(t4.getIndices(), n4);
            for (const e4 of t4.listAttributes())
              o2.set(e4, n4);
          }
        }
        for (const e4 of Array.from(o2.keys())) {
          const t4 = new Set(e4.listParents().map((e5) => e5.propertyType));
          if (2 !== t4.size || !t4.has(Ab.PRIMITIVE) || !t4.has(Ab.ROOT))
            throw new Error(`[${FA}] Compressed accessors must only be used as indices or vertex attributes.`);
        }
        for (const e4 of Array.from(n3)) {
          const t4 = l2.get(e4), n4 = e4.getIndices();
          if (o2.get(n4) !== t4 || e4.listAttributes().some((e5) => o2.get(e5) !== t4))
            throw new Error(`[${FA}] Draco primitives must share all, or no, accessors.`);
        }
        for (const e4 of Array.from(r3)) {
          const t4 = e4.getIndices();
          if (o2.has(t4) || e4.listAttributes().some((e5) => o2.has(e5)))
            throw new Error(`[${FA}] Accessor cannot be shared by compressed and uncompressed primitives.`);
        }
        return l2;
      }(this.document), i2 = /* @__PURE__ */ new Map();
      let s2 = "mesh";
      "scene" === this._encoderOptions.quantizationVolume && (1 !== this.document.getRoot().listScenes().length ? n2.warn(`[${FA}]: quantizationVolume=scene requires exactly 1 scene.`) : s2 = function(e3) {
        const t3 = { min: [1 / 0, 1 / 0, 1 / 0], max: [-1 / 0, -1 / 0, -1 / 0] }, n3 = e3.propertyType === Ab.NODE ? [e3] : e3.listChildren();
        for (const e4 of n3)
          e4.traverse((e5) => {
            const n4 = e5.getMesh();
            if (!n4)
              return;
            const r3 = Db(n4, e5.getWorldMatrix());
            Bb(r3.min, t3), Bb(r3.max, t3);
          });
        return t3;
      }(this.document.getRoot().listScenes().pop()));
      for (const t3 of Array.from(r2.keys())) {
        const o2 = r2.get(t3);
        if (!o2)
          throw new Error("Unexpected primitive.");
        if (i2.has(o2)) {
          i2.set(o2, i2.get(o2));
          continue;
        }
        const a2 = t3.getIndices(), l2 = e2.jsonDoc.json.accessors;
        let c2;
        try {
          c2 = BA(t3, $w({}, this._encoderOptions, { quantizationVolume: s2 }));
        } catch (e3) {
          if (e3 instanceof UA) {
            n2.warn(`[${FA}]: ${e3.message} Skipping primitive compression.`);
            continue;
          }
          throw e3;
        }
        i2.set(o2, c2);
        const u2 = e2.createAccessorDef(a2);
        u2.count = c2.numIndices, e2.accessorIndexMap.set(a2, l2.length), l2.push(u2);
        for (const n3 of t3.listSemantics()) {
          const r3 = t3.getAttribute(n3);
          if (void 0 === c2.attributeIDs[n3])
            continue;
          const i3 = e2.createAccessorDef(r3);
          i3.count = c2.numVertices, e2.accessorIndexMap.set(r3, l2.length), l2.push(i3);
        }
        const p2 = t3.getAttribute("POSITION").getBuffer() || this.document.getRoot().listBuffers()[0];
        e2.otherBufferViews.has(p2) || e2.otherBufferViews.set(p2, []), e2.otherBufferViews.get(p2).push(c2.data);
      }
      return n2.debug(`[${FA}] Compressed ${r2.size} primitives.`), e2.extensionData[FA] = { primitiveHashMap: r2, primitiveEncodingMap: i2 }, this;
    }
    write(e2) {
      const t2 = e2.extensionData[FA];
      for (const n2 of this.document.getRoot().listMeshes()) {
        const r2 = e2.jsonDoc.json.meshes[e2.meshIndexMap.get(n2)];
        for (let i2 = 0; i2 < n2.listPrimitives().length; i2++) {
          const s2 = n2.listPrimitives()[i2], o2 = r2.primitives[i2], a2 = t2.primitiveHashMap.get(s2);
          if (!a2)
            continue;
          const l2 = t2.primitiveEncodingMap.get(a2);
          l2 && (o2.extensions = o2.extensions || {}, o2.extensions[FA] = { bufferView: e2.otherBufferViewsIndexMap.get(l2.data), attributes: l2.attributeIDs });
        }
      }
      if (!t2.primitiveHashMap.size) {
        const t3 = e2.jsonDoc.json;
        t3.extensionsUsed = (t3.extensionsUsed || []).filter((e3) => e3 !== FA), t3.extensionsRequired = (t3.extensionsRequired || []).filter((e3) => e3 !== FA);
      }
      return this;
    }
  }
  function jA(e2, t2) {
    const n2 = [], r2 = e2.getIndices();
    n2.push(t2.get(r2));
    for (const r3 of e2.listAttributes())
      n2.push(t2.get(r3));
    return n2.sort().join("|");
  }
  NA.EXTENSION_NAME = FA, NA.EncoderMethod = IA;
  class zA extends dw {
    init() {
      this.extensionName = "KHR_lights_punctual", this.propertyType = "Light", this.parentTypes = [Ab.NODE];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { color: [1, 1, 1], intensity: 1, type: zA.Type.POINT, range: null, innerConeAngle: 0, outerConeAngle: Math.PI / 4 });
    }
    getColor() {
      return this.get("color");
    }
    setColor(e2) {
      return this.set("color", e2);
    }
    getColorHex() {
      return Lb.factorToHex(this.getColor());
    }
    setColorHex(e2) {
      const t2 = this.getColor().slice();
      return Lb.hexToFactor(e2, t2), this.setColor(t2);
    }
    getIntensity() {
      return this.get("intensity");
    }
    setIntensity(e2) {
      return this.set("intensity", e2);
    }
    getType() {
      return this.get("type");
    }
    setType(e2) {
      return this.set("type", e2);
    }
    getRange() {
      return this.get("range");
    }
    setRange(e2) {
      return this.set("range", e2);
    }
    getInnerConeAngle() {
      return this.get("innerConeAngle");
    }
    setInnerConeAngle(e2) {
      return this.set("innerConeAngle", e2);
    }
    getOuterConeAngle() {
      return this.get("outerConeAngle");
    }
    setOuterConeAngle(e2) {
      return this.set("outerConeAngle", e2);
    }
  }
  zA.EXTENSION_NAME = "KHR_lights_punctual", zA.Type = { POINT: "point", SPOT: "spot", DIRECTIONAL: "directional" };
  const GA = "KHR_lights_punctual";
  class VA extends Pw {
    constructor(...e2) {
      super(...e2), this.extensionName = GA;
    }
    createLight(e2 = "") {
      return new zA(this.document.getGraph(), e2);
    }
    read(e2) {
      const t2 = e2.jsonDoc;
      if (!t2.json.extensions || !t2.json.extensions[GA])
        return this;
      const n2 = (t2.json.extensions[GA].lights || []).map((e3) => {
        var t3, n3;
        const r2 = this.createLight().setName(e3.name || "").setType(e3.type);
        return void 0 !== e3.color && r2.setColor(e3.color), void 0 !== e3.intensity && r2.setIntensity(e3.intensity), void 0 !== e3.range && r2.setRange(e3.range), void 0 !== (null == (t3 = e3.spot) ? void 0 : t3.innerConeAngle) && r2.setInnerConeAngle(e3.spot.innerConeAngle), void 0 !== (null == (n3 = e3.spot) ? void 0 : n3.outerConeAngle) && r2.setOuterConeAngle(e3.spot.outerConeAngle), r2;
      });
      return t2.json.nodes.forEach((t3, r2) => {
        t3.extensions && t3.extensions[GA] && e2.nodes[r2].setExtension(GA, n2[t3.extensions[GA].light]);
      }), this;
    }
    write(e2) {
      const t2 = e2.jsonDoc;
      if (0 === this.properties.size)
        return this;
      const n2 = [], r2 = /* @__PURE__ */ new Map();
      for (const e3 of this.properties) {
        const t3 = e3, i2 = { type: t3.getType() };
        Qb.eq(t3.getColor(), [1, 1, 1]) || (i2.color = t3.getColor()), 1 !== t3.getIntensity() && (i2.intensity = t3.getIntensity()), null != t3.getRange() && (i2.range = t3.getRange()), t3.getName() && (i2.name = t3.getName()), t3.getType() === zA.Type.SPOT && (i2.spot = { innerConeAngle: t3.getInnerConeAngle(), outerConeAngle: t3.getOuterConeAngle() }), n2.push(i2), r2.set(t3, n2.length - 1);
      }
      return this.document.getRoot().listNodes().forEach((n3) => {
        const i2 = n3.getExtension(GA);
        if (i2) {
          const s2 = e2.nodeIndexMap.get(n3), o2 = t2.json.nodes[s2];
          o2.extensions = o2.extensions || {}, o2.extensions[GA] = { light: r2.get(i2) };
        }
      }), t2.json.extensions = t2.json.extensions || {}, t2.json.extensions[GA] = { lights: n2 }, this;
    }
  }
  VA.EXTENSION_NAME = GA;
  const { R: HA, G: QA } = Cb;
  class WA extends dw {
    init() {
      this.extensionName = "KHR_materials_anisotropy", this.propertyType = "Anisotropy", this.parentTypes = [Ab.MATERIAL];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { anisotropyStrength: 0, anisotropyRotation: 0, anisotropyTexture: null, anisotropyTextureInfo: new hw(this.graph, "anisotropyTextureInfo") });
    }
    getAnisotropyStrength() {
      return this.get("anisotropyStrength");
    }
    setAnisotropyStrength(e2) {
      return this.set("anisotropyStrength", e2);
    }
    getAnisotropyRotation() {
      return this.get("anisotropyRotation");
    }
    setAnisotropyRotation(e2) {
      return this.set("anisotropyRotation", e2);
    }
    getAnisotropyTexture() {
      return this.getRef("anisotropyTexture");
    }
    getAnisotropyTextureInfo() {
      return this.getRef("anisotropyTexture") ? this.getRef("anisotropyTextureInfo") : null;
    }
    setAnisotropyTexture(e2) {
      return this.setRef("anisotropyTexture", e2, { channels: HA | QA });
    }
  }
  WA.EXTENSION_NAME = "KHR_materials_anisotropy";
  const qA = "KHR_materials_anisotropy";
  class XA extends Pw {
    constructor(...e2) {
      super(...e2), this.extensionName = qA;
    }
    createAnisotropy() {
      return new WA(this.document.getGraph());
    }
    read(e2) {
      const t2 = e2.jsonDoc, n2 = t2.json.textures || [];
      return (t2.json.materials || []).forEach((t3, r2) => {
        if (t3.extensions && t3.extensions[qA]) {
          const i2 = this.createAnisotropy();
          e2.materials[r2].setExtension(qA, i2);
          const s2 = t3.extensions[qA];
          if (void 0 !== s2.anisotropyStrength && i2.setAnisotropyStrength(s2.anisotropyStrength), void 0 !== s2.anisotropyRotation && i2.setAnisotropyRotation(s2.anisotropyRotation), void 0 !== s2.anisotropyTexture) {
            const t4 = s2.anisotropyTexture;
            i2.setAnisotropyTexture(e2.textures[n2[t4.index].source]), e2.setTextureInfo(i2.getAnisotropyTextureInfo(), t4);
          }
        }
      }), this;
    }
    write(e2) {
      const t2 = e2.jsonDoc;
      return this.document.getRoot().listMaterials().forEach((n2) => {
        const r2 = n2.getExtension(qA);
        if (r2) {
          const i2 = e2.materialIndexMap.get(n2), s2 = t2.json.materials[i2];
          s2.extensions = s2.extensions || {};
          const o2 = s2.extensions[qA] = {};
          if (r2.getAnisotropyStrength() > 0 && (o2.anisotropyStrength = r2.getAnisotropyStrength()), 0 !== r2.getAnisotropyRotation() && (o2.anisotropyRotation = r2.getAnisotropyRotation()), r2.getAnisotropyTexture()) {
            const t3 = r2.getAnisotropyTexture(), n3 = r2.getAnisotropyTextureInfo();
            o2.anisotropyTexture = e2.createTextureInfoDef(t3, n3);
          }
        }
      }), this;
    }
  }
  XA.EXTENSION_NAME = qA;
  const { R: YA, G: KA, B: JA } = Cb;
  class ZA extends dw {
    init() {
      this.extensionName = "KHR_materials_clearcoat", this.propertyType = "Clearcoat", this.parentTypes = [Ab.MATERIAL];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { clearcoatFactor: 0, clearcoatTexture: null, clearcoatTextureInfo: new hw(this.graph, "clearcoatTextureInfo"), clearcoatRoughnessFactor: 0, clearcoatRoughnessTexture: null, clearcoatRoughnessTextureInfo: new hw(this.graph, "clearcoatRoughnessTextureInfo"), clearcoatNormalScale: 1, clearcoatNormalTexture: null, clearcoatNormalTextureInfo: new hw(this.graph, "clearcoatNormalTextureInfo") });
    }
    getClearcoatFactor() {
      return this.get("clearcoatFactor");
    }
    setClearcoatFactor(e2) {
      return this.set("clearcoatFactor", e2);
    }
    getClearcoatTexture() {
      return this.getRef("clearcoatTexture");
    }
    getClearcoatTextureInfo() {
      return this.getRef("clearcoatTexture") ? this.getRef("clearcoatTextureInfo") : null;
    }
    setClearcoatTexture(e2) {
      return this.setRef("clearcoatTexture", e2, { channels: YA });
    }
    getClearcoatRoughnessFactor() {
      return this.get("clearcoatRoughnessFactor");
    }
    setClearcoatRoughnessFactor(e2) {
      return this.set("clearcoatRoughnessFactor", e2);
    }
    getClearcoatRoughnessTexture() {
      return this.getRef("clearcoatRoughnessTexture");
    }
    getClearcoatRoughnessTextureInfo() {
      return this.getRef("clearcoatRoughnessTexture") ? this.getRef("clearcoatRoughnessTextureInfo") : null;
    }
    setClearcoatRoughnessTexture(e2) {
      return this.setRef("clearcoatRoughnessTexture", e2, { channels: KA });
    }
    getClearcoatNormalScale() {
      return this.get("clearcoatNormalScale");
    }
    setClearcoatNormalScale(e2) {
      return this.set("clearcoatNormalScale", e2);
    }
    getClearcoatNormalTexture() {
      return this.getRef("clearcoatNormalTexture");
    }
    getClearcoatNormalTextureInfo() {
      return this.getRef("clearcoatNormalTexture") ? this.getRef("clearcoatNormalTextureInfo") : null;
    }
    setClearcoatNormalTexture(e2) {
      return this.setRef("clearcoatNormalTexture", e2, { channels: YA | KA | JA });
    }
  }
  ZA.EXTENSION_NAME = "KHR_materials_clearcoat";
  const $A = "KHR_materials_clearcoat";
  class ex extends Pw {
    constructor(...e2) {
      super(...e2), this.extensionName = $A;
    }
    createClearcoat() {
      return new ZA(this.document.getGraph());
    }
    read(e2) {
      const t2 = e2.jsonDoc, n2 = t2.json.textures || [];
      return (t2.json.materials || []).forEach((t3, r2) => {
        if (t3.extensions && t3.extensions[$A]) {
          const i2 = this.createClearcoat();
          e2.materials[r2].setExtension($A, i2);
          const s2 = t3.extensions[$A];
          if (void 0 !== s2.clearcoatFactor && i2.setClearcoatFactor(s2.clearcoatFactor), void 0 !== s2.clearcoatRoughnessFactor && i2.setClearcoatRoughnessFactor(s2.clearcoatRoughnessFactor), void 0 !== s2.clearcoatTexture) {
            const t4 = s2.clearcoatTexture;
            i2.setClearcoatTexture(e2.textures[n2[t4.index].source]), e2.setTextureInfo(i2.getClearcoatTextureInfo(), t4);
          }
          if (void 0 !== s2.clearcoatRoughnessTexture) {
            const t4 = s2.clearcoatRoughnessTexture;
            i2.setClearcoatRoughnessTexture(e2.textures[n2[t4.index].source]), e2.setTextureInfo(i2.getClearcoatRoughnessTextureInfo(), t4);
          }
          if (void 0 !== s2.clearcoatNormalTexture) {
            const t4 = s2.clearcoatNormalTexture;
            i2.setClearcoatNormalTexture(e2.textures[n2[t4.index].source]), e2.setTextureInfo(i2.getClearcoatNormalTextureInfo(), t4), void 0 !== t4.scale && i2.setClearcoatNormalScale(t4.scale);
          }
        }
      }), this;
    }
    write(e2) {
      const t2 = e2.jsonDoc;
      return this.document.getRoot().listMaterials().forEach((n2) => {
        const r2 = n2.getExtension($A);
        if (r2) {
          const i2 = e2.materialIndexMap.get(n2), s2 = t2.json.materials[i2];
          s2.extensions = s2.extensions || {};
          const o2 = s2.extensions[$A] = { clearcoatFactor: r2.getClearcoatFactor(), clearcoatRoughnessFactor: r2.getClearcoatRoughnessFactor() };
          if (r2.getClearcoatTexture()) {
            const t3 = r2.getClearcoatTexture(), n3 = r2.getClearcoatTextureInfo();
            o2.clearcoatTexture = e2.createTextureInfoDef(t3, n3);
          }
          if (r2.getClearcoatRoughnessTexture()) {
            const t3 = r2.getClearcoatRoughnessTexture(), n3 = r2.getClearcoatRoughnessTextureInfo();
            o2.clearcoatRoughnessTexture = e2.createTextureInfoDef(t3, n3);
          }
          if (r2.getClearcoatNormalTexture()) {
            const t3 = r2.getClearcoatNormalTexture(), n3 = r2.getClearcoatNormalTextureInfo();
            o2.clearcoatNormalTexture = e2.createTextureInfoDef(t3, n3), 1 !== r2.getClearcoatNormalScale() && (o2.clearcoatNormalTexture.scale = r2.getClearcoatNormalScale());
          }
        }
      }), this;
    }
  }
  ex.EXTENSION_NAME = $A;
  class tx extends dw {
    init() {
      this.extensionName = "KHR_materials_emissive_strength", this.propertyType = "EmissiveStrength", this.parentTypes = [Ab.MATERIAL];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { emissiveStrength: 1 });
    }
    getEmissiveStrength() {
      return this.get("emissiveStrength");
    }
    setEmissiveStrength(e2) {
      return this.set("emissiveStrength", e2);
    }
  }
  tx.EXTENSION_NAME = "KHR_materials_emissive_strength";
  const nx = "KHR_materials_emissive_strength";
  class rx extends Pw {
    constructor(...e2) {
      super(...e2), this.extensionName = nx;
    }
    createEmissiveStrength() {
      return new tx(this.document.getGraph());
    }
    read(e2) {
      return (e2.jsonDoc.json.materials || []).forEach((t2, n2) => {
        if (t2.extensions && t2.extensions[nx]) {
          const r2 = this.createEmissiveStrength();
          e2.materials[n2].setExtension(nx, r2);
          const i2 = t2.extensions[nx];
          void 0 !== i2.emissiveStrength && r2.setEmissiveStrength(i2.emissiveStrength);
        }
      }), this;
    }
    write(e2) {
      const t2 = e2.jsonDoc;
      return this.document.getRoot().listMaterials().forEach((n2) => {
        const r2 = n2.getExtension(nx);
        if (r2) {
          const i2 = e2.materialIndexMap.get(n2), s2 = t2.json.materials[i2];
          s2.extensions = s2.extensions || {}, s2.extensions[nx] = { emissiveStrength: r2.getEmissiveStrength() };
        }
      }), this;
    }
  }
  rx.EXTENSION_NAME = nx;
  class ix extends dw {
    init() {
      this.extensionName = "KHR_materials_ior", this.propertyType = "IOR", this.parentTypes = [Ab.MATERIAL];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { ior: 1.5 });
    }
    getIOR() {
      return this.get("ior");
    }
    setIOR(e2) {
      return this.set("ior", e2);
    }
  }
  ix.EXTENSION_NAME = "KHR_materials_ior";
  const sx = "KHR_materials_ior";
  class ox extends Pw {
    constructor(...e2) {
      super(...e2), this.extensionName = sx;
    }
    createIOR() {
      return new ix(this.document.getGraph());
    }
    read(e2) {
      return (e2.jsonDoc.json.materials || []).forEach((t2, n2) => {
        if (t2.extensions && t2.extensions[sx]) {
          const r2 = this.createIOR();
          e2.materials[n2].setExtension(sx, r2);
          const i2 = t2.extensions[sx];
          void 0 !== i2.ior && r2.setIOR(i2.ior);
        }
      }), this;
    }
    write(e2) {
      const t2 = e2.jsonDoc;
      return this.document.getRoot().listMaterials().forEach((n2) => {
        const r2 = n2.getExtension(sx);
        if (r2) {
          const i2 = e2.materialIndexMap.get(n2), s2 = t2.json.materials[i2];
          s2.extensions = s2.extensions || {}, s2.extensions[sx] = { ior: r2.getIOR() };
        }
      }), this;
    }
  }
  ox.EXTENSION_NAME = sx;
  const { R: ax, G: lx } = Cb;
  class cx extends dw {
    init() {
      this.extensionName = "KHR_materials_iridescence", this.propertyType = "Iridescence", this.parentTypes = [Ab.MATERIAL];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { iridescenceFactor: 0, iridescenceTexture: null, iridescenceTextureInfo: new hw(this.graph, "iridescenceTextureInfo"), iridescenceIOR: 1.3, iridescenceThicknessMinimum: 100, iridescenceThicknessMaximum: 400, iridescenceThicknessTexture: null, iridescenceThicknessTextureInfo: new hw(this.graph, "iridescenceThicknessTextureInfo") });
    }
    getIridescenceFactor() {
      return this.get("iridescenceFactor");
    }
    setIridescenceFactor(e2) {
      return this.set("iridescenceFactor", e2);
    }
    getIridescenceTexture() {
      return this.getRef("iridescenceTexture");
    }
    getIridescenceTextureInfo() {
      return this.getRef("iridescenceTexture") ? this.getRef("iridescenceTextureInfo") : null;
    }
    setIridescenceTexture(e2) {
      return this.setRef("iridescenceTexture", e2, { channels: ax });
    }
    getIridescenceIOR() {
      return this.get("iridescenceIOR");
    }
    setIridescenceIOR(e2) {
      return this.set("iridescenceIOR", e2);
    }
    getIridescenceThicknessMinimum() {
      return this.get("iridescenceThicknessMinimum");
    }
    setIridescenceThicknessMinimum(e2) {
      return this.set("iridescenceThicknessMinimum", e2);
    }
    getIridescenceThicknessMaximum() {
      return this.get("iridescenceThicknessMaximum");
    }
    setIridescenceThicknessMaximum(e2) {
      return this.set("iridescenceThicknessMaximum", e2);
    }
    getIridescenceThicknessTexture() {
      return this.getRef("iridescenceThicknessTexture");
    }
    getIridescenceThicknessTextureInfo() {
      return this.getRef("iridescenceThicknessTexture") ? this.getRef("iridescenceThicknessTextureInfo") : null;
    }
    setIridescenceThicknessTexture(e2) {
      return this.setRef("iridescenceThicknessTexture", e2, { channels: lx });
    }
  }
  cx.EXTENSION_NAME = "KHR_materials_iridescence";
  const ux = "KHR_materials_iridescence";
  class px extends Pw {
    constructor(...e2) {
      super(...e2), this.extensionName = ux;
    }
    createIridescence() {
      return new cx(this.document.getGraph());
    }
    read(e2) {
      const t2 = e2.jsonDoc, n2 = t2.json.textures || [];
      return (t2.json.materials || []).forEach((t3, r2) => {
        if (t3.extensions && t3.extensions[ux]) {
          const i2 = this.createIridescence();
          e2.materials[r2].setExtension(ux, i2);
          const s2 = t3.extensions[ux];
          if (void 0 !== s2.iridescenceFactor && i2.setIridescenceFactor(s2.iridescenceFactor), void 0 !== s2.iridescenceIor && i2.setIridescenceIOR(s2.iridescenceIor), void 0 !== s2.iridescenceThicknessMinimum && i2.setIridescenceThicknessMinimum(s2.iridescenceThicknessMinimum), void 0 !== s2.iridescenceThicknessMaximum && i2.setIridescenceThicknessMaximum(s2.iridescenceThicknessMaximum), void 0 !== s2.iridescenceTexture) {
            const t4 = s2.iridescenceTexture;
            i2.setIridescenceTexture(e2.textures[n2[t4.index].source]), e2.setTextureInfo(i2.getIridescenceTextureInfo(), t4);
          }
          if (void 0 !== s2.iridescenceThicknessTexture) {
            const t4 = s2.iridescenceThicknessTexture;
            i2.setIridescenceThicknessTexture(e2.textures[n2[t4.index].source]), e2.setTextureInfo(i2.getIridescenceThicknessTextureInfo(), t4);
          }
        }
      }), this;
    }
    write(e2) {
      const t2 = e2.jsonDoc;
      return this.document.getRoot().listMaterials().forEach((n2) => {
        const r2 = n2.getExtension(ux);
        if (r2) {
          const i2 = e2.materialIndexMap.get(n2), s2 = t2.json.materials[i2];
          s2.extensions = s2.extensions || {};
          const o2 = s2.extensions[ux] = {};
          if (r2.getIridescenceFactor() > 0 && (o2.iridescenceFactor = r2.getIridescenceFactor()), 1.3 !== r2.getIridescenceIOR() && (o2.iridescenceIor = r2.getIridescenceIOR()), 100 !== r2.getIridescenceThicknessMinimum() && (o2.iridescenceThicknessMinimum = r2.getIridescenceThicknessMinimum()), 400 !== r2.getIridescenceThicknessMaximum() && (o2.iridescenceThicknessMaximum = r2.getIridescenceThicknessMaximum()), r2.getIridescenceTexture()) {
            const t3 = r2.getIridescenceTexture(), n3 = r2.getIridescenceTextureInfo();
            o2.iridescenceTexture = e2.createTextureInfoDef(t3, n3);
          }
          if (r2.getIridescenceThicknessTexture()) {
            const t3 = r2.getIridescenceThicknessTexture(), n3 = r2.getIridescenceThicknessTextureInfo();
            o2.iridescenceThicknessTexture = e2.createTextureInfoDef(t3, n3);
          }
        }
      }), this;
    }
  }
  px.EXTENSION_NAME = ux;
  const { R: dx, G: hx, B: fx, A: mx } = Cb;
  class _x extends dw {
    init() {
      this.extensionName = "KHR_materials_pbrSpecularGlossiness", this.propertyType = "PBRSpecularGlossiness", this.parentTypes = [Ab.MATERIAL];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { diffuseFactor: [1, 1, 1, 1], diffuseTexture: null, diffuseTextureInfo: new hw(this.graph, "diffuseTextureInfo"), specularFactor: [1, 1, 1], glossinessFactor: 1, specularGlossinessTexture: null, specularGlossinessTextureInfo: new hw(this.graph, "specularGlossinessTextureInfo") });
    }
    getDiffuseFactor() {
      return this.get("diffuseFactor");
    }
    setDiffuseFactor(e2) {
      return this.set("diffuseFactor", e2);
    }
    getDiffuseHex() {
      return Lb.factorToHex(this.getDiffuseFactor());
    }
    setDiffuseHex(e2) {
      const t2 = this.getDiffuseFactor().slice();
      return this.setDiffuseFactor(Lb.hexToFactor(e2, t2));
    }
    getDiffuseTexture() {
      return this.getRef("diffuseTexture");
    }
    getDiffuseTextureInfo() {
      return this.getRef("diffuseTexture") ? this.getRef("diffuseTextureInfo") : null;
    }
    setDiffuseTexture(e2) {
      return this.setRef("diffuseTexture", e2, { channels: dx | hx | fx | mx });
    }
    getSpecularFactor() {
      return this.get("specularFactor");
    }
    setSpecularFactor(e2) {
      return this.set("specularFactor", e2);
    }
    getGlossinessFactor() {
      return this.get("glossinessFactor");
    }
    setGlossinessFactor(e2) {
      return this.set("glossinessFactor", e2);
    }
    getSpecularGlossinessTexture() {
      return this.getRef("specularGlossinessTexture");
    }
    getSpecularGlossinessTextureInfo() {
      return this.getRef("specularGlossinessTexture") ? this.getRef("specularGlossinessTextureInfo") : null;
    }
    setSpecularGlossinessTexture(e2) {
      return this.setRef("specularGlossinessTexture", e2, { channels: dx | hx | fx | mx });
    }
  }
  _x.EXTENSION_NAME = "KHR_materials_pbrSpecularGlossiness";
  const gx = "KHR_materials_pbrSpecularGlossiness";
  class vx extends Pw {
    constructor(...e2) {
      super(...e2), this.extensionName = gx;
    }
    createPBRSpecularGlossiness() {
      return new _x(this.document.getGraph());
    }
    read(e2) {
      const t2 = e2.jsonDoc, n2 = t2.json.textures || [];
      return (t2.json.materials || []).forEach((t3, r2) => {
        if (t3.extensions && t3.extensions[gx]) {
          const i2 = this.createPBRSpecularGlossiness();
          e2.materials[r2].setExtension(gx, i2);
          const s2 = t3.extensions[gx];
          if (void 0 !== s2.diffuseFactor && i2.setDiffuseFactor(s2.diffuseFactor), void 0 !== s2.specularFactor && i2.setSpecularFactor(s2.specularFactor), void 0 !== s2.glossinessFactor && i2.setGlossinessFactor(s2.glossinessFactor), void 0 !== s2.diffuseTexture) {
            const t4 = s2.diffuseTexture;
            i2.setDiffuseTexture(e2.textures[n2[t4.index].source]), e2.setTextureInfo(i2.getDiffuseTextureInfo(), t4);
          }
          if (void 0 !== s2.specularGlossinessTexture) {
            const t4 = s2.specularGlossinessTexture;
            i2.setSpecularGlossinessTexture(e2.textures[n2[t4.index].source]), e2.setTextureInfo(i2.getSpecularGlossinessTextureInfo(), t4);
          }
        }
      }), this;
    }
    write(e2) {
      const t2 = e2.jsonDoc;
      return this.document.getRoot().listMaterials().forEach((n2) => {
        const r2 = n2.getExtension(gx);
        if (r2) {
          const i2 = e2.materialIndexMap.get(n2), s2 = t2.json.materials[i2];
          s2.extensions = s2.extensions || {};
          const o2 = s2.extensions[gx] = { diffuseFactor: r2.getDiffuseFactor(), specularFactor: r2.getSpecularFactor(), glossinessFactor: r2.getGlossinessFactor() };
          if (r2.getDiffuseTexture()) {
            const t3 = r2.getDiffuseTexture(), n3 = r2.getDiffuseTextureInfo();
            o2.diffuseTexture = e2.createTextureInfoDef(t3, n3);
          }
          if (r2.getSpecularGlossinessTexture()) {
            const t3 = r2.getSpecularGlossinessTexture(), n3 = r2.getSpecularGlossinessTextureInfo();
            o2.specularGlossinessTexture = e2.createTextureInfoDef(t3, n3);
          }
        }
      }), this;
    }
  }
  vx.EXTENSION_NAME = gx;
  const { R: yx, G: bx, B: wx, A: Ax } = Cb;
  class xx extends dw {
    init() {
      this.extensionName = "KHR_materials_sheen", this.propertyType = "Sheen", this.parentTypes = [Ab.MATERIAL];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { sheenColorFactor: [0, 0, 0], sheenColorTexture: null, sheenColorTextureInfo: new hw(this.graph, "sheenColorTextureInfo"), sheenRoughnessFactor: 0, sheenRoughnessTexture: null, sheenRoughnessTextureInfo: new hw(this.graph, "sheenRoughnessTextureInfo") });
    }
    getSheenColorFactor() {
      return this.get("sheenColorFactor");
    }
    getSheenColorHex() {
      return Lb.factorToHex(this.getSheenColorFactor());
    }
    setSheenColorFactor(e2) {
      return this.set("sheenColorFactor", e2);
    }
    setSheenColorHex(e2) {
      const t2 = this.getSheenColorFactor().slice();
      return this.set("sheenColorFactor", Lb.hexToFactor(e2, t2));
    }
    getSheenColorTexture() {
      return this.getRef("sheenColorTexture");
    }
    getSheenColorTextureInfo() {
      return this.getRef("sheenColorTexture") ? this.getRef("sheenColorTextureInfo") : null;
    }
    setSheenColorTexture(e2) {
      return this.setRef("sheenColorTexture", e2, { channels: yx | bx | wx });
    }
    getSheenRoughnessFactor() {
      return this.get("sheenRoughnessFactor");
    }
    setSheenRoughnessFactor(e2) {
      return this.set("sheenRoughnessFactor", e2);
    }
    getSheenRoughnessTexture() {
      return this.getRef("sheenRoughnessTexture");
    }
    getSheenRoughnessTextureInfo() {
      return this.getRef("sheenRoughnessTexture") ? this.getRef("sheenRoughnessTextureInfo") : null;
    }
    setSheenRoughnessTexture(e2) {
      return this.setRef("sheenRoughnessTexture", e2, { channels: Ax });
    }
  }
  xx.EXTENSION_NAME = "KHR_materials_sheen";
  const Ex = "KHR_materials_sheen";
  class Cx extends Pw {
    constructor(...e2) {
      super(...e2), this.extensionName = Ex;
    }
    createSheen() {
      return new xx(this.document.getGraph());
    }
    read(e2) {
      const t2 = e2.jsonDoc, n2 = t2.json.textures || [];
      return (t2.json.materials || []).forEach((t3, r2) => {
        if (t3.extensions && t3.extensions[Ex]) {
          const i2 = this.createSheen();
          e2.materials[r2].setExtension(Ex, i2);
          const s2 = t3.extensions[Ex];
          if (void 0 !== s2.sheenColorFactor && i2.setSheenColorFactor(s2.sheenColorFactor), void 0 !== s2.sheenRoughnessFactor && i2.setSheenRoughnessFactor(s2.sheenRoughnessFactor), void 0 !== s2.sheenColorTexture) {
            const t4 = s2.sheenColorTexture;
            i2.setSheenColorTexture(e2.textures[n2[t4.index].source]), e2.setTextureInfo(i2.getSheenColorTextureInfo(), t4);
          }
          if (void 0 !== s2.sheenRoughnessTexture) {
            const t4 = s2.sheenRoughnessTexture;
            i2.setSheenRoughnessTexture(e2.textures[n2[t4.index].source]), e2.setTextureInfo(i2.getSheenRoughnessTextureInfo(), t4);
          }
        }
      }), this;
    }
    write(e2) {
      const t2 = e2.jsonDoc;
      return this.document.getRoot().listMaterials().forEach((n2) => {
        const r2 = n2.getExtension(Ex);
        if (r2) {
          const i2 = e2.materialIndexMap.get(n2), s2 = t2.json.materials[i2];
          s2.extensions = s2.extensions || {};
          const o2 = s2.extensions[Ex] = { sheenColorFactor: r2.getSheenColorFactor(), sheenRoughnessFactor: r2.getSheenRoughnessFactor() };
          if (r2.getSheenColorTexture()) {
            const t3 = r2.getSheenColorTexture(), n3 = r2.getSheenColorTextureInfo();
            o2.sheenColorTexture = e2.createTextureInfoDef(t3, n3);
          }
          if (r2.getSheenRoughnessTexture()) {
            const t3 = r2.getSheenRoughnessTexture(), n3 = r2.getSheenRoughnessTextureInfo();
            o2.sheenRoughnessTexture = e2.createTextureInfoDef(t3, n3);
          }
        }
      }), this;
    }
  }
  Cx.EXTENSION_NAME = Ex;
  const { R: Sx, G: Mx, B: Tx, A: Px } = Cb;
  class Ix extends dw {
    init() {
      this.extensionName = "KHR_materials_specular", this.propertyType = "Specular", this.parentTypes = [Ab.MATERIAL];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { specularFactor: 1, specularTexture: null, specularTextureInfo: new hw(this.graph, "specularTextureInfo"), specularColorFactor: [1, 1, 1], specularColorTexture: null, specularColorTextureInfo: new hw(this.graph, "specularColorTextureInfo") });
    }
    getSpecularFactor() {
      return this.get("specularFactor");
    }
    setSpecularFactor(e2) {
      return this.set("specularFactor", e2);
    }
    getSpecularColorFactor() {
      return this.get("specularColorFactor");
    }
    setSpecularColorFactor(e2) {
      return this.set("specularColorFactor", e2);
    }
    getSpecularColorHex() {
      return Lb.factorToHex(this.getSpecularColorFactor());
    }
    setSpecularColorHex(e2) {
      const t2 = this.getSpecularColorFactor().slice();
      return this.set("specularColorFactor", Lb.hexToFactor(e2, t2));
    }
    getSpecularTexture() {
      return this.getRef("specularTexture");
    }
    getSpecularTextureInfo() {
      return this.getRef("specularTexture") ? this.getRef("specularTextureInfo") : null;
    }
    setSpecularTexture(e2) {
      return this.setRef("specularTexture", e2, { channels: Px });
    }
    getSpecularColorTexture() {
      return this.getRef("specularColorTexture");
    }
    getSpecularColorTextureInfo() {
      return this.getRef("specularColorTexture") ? this.getRef("specularColorTextureInfo") : null;
    }
    setSpecularColorTexture(e2) {
      return this.setRef("specularColorTexture", e2, { channels: Sx | Mx | Tx });
    }
  }
  Ix.EXTENSION_NAME = "KHR_materials_specular";
  const Rx = "KHR_materials_specular";
  class kx extends Pw {
    constructor(...e2) {
      super(...e2), this.extensionName = Rx;
    }
    createSpecular() {
      return new Ix(this.document.getGraph());
    }
    read(e2) {
      const t2 = e2.jsonDoc, n2 = t2.json.textures || [];
      return (t2.json.materials || []).forEach((t3, r2) => {
        if (t3.extensions && t3.extensions[Rx]) {
          const i2 = this.createSpecular();
          e2.materials[r2].setExtension(Rx, i2);
          const s2 = t3.extensions[Rx];
          if (void 0 !== s2.specularFactor && i2.setSpecularFactor(s2.specularFactor), void 0 !== s2.specularColorFactor && i2.setSpecularColorFactor(s2.specularColorFactor), void 0 !== s2.specularTexture) {
            const t4 = s2.specularTexture;
            i2.setSpecularTexture(e2.textures[n2[t4.index].source]), e2.setTextureInfo(i2.getSpecularTextureInfo(), t4);
          }
          if (void 0 !== s2.specularColorTexture) {
            const t4 = s2.specularColorTexture;
            i2.setSpecularColorTexture(e2.textures[n2[t4.index].source]), e2.setTextureInfo(i2.getSpecularColorTextureInfo(), t4);
          }
        }
      }), this;
    }
    write(e2) {
      const t2 = e2.jsonDoc;
      return this.document.getRoot().listMaterials().forEach((n2) => {
        const r2 = n2.getExtension(Rx);
        if (r2) {
          const i2 = e2.materialIndexMap.get(n2), s2 = t2.json.materials[i2];
          s2.extensions = s2.extensions || {};
          const o2 = s2.extensions[Rx] = {};
          if (1 !== r2.getSpecularFactor() && (o2.specularFactor = r2.getSpecularFactor()), Qb.eq(r2.getSpecularColorFactor(), [1, 1, 1]) || (o2.specularColorFactor = r2.getSpecularColorFactor()), r2.getSpecularTexture()) {
            const t3 = r2.getSpecularTexture(), n3 = r2.getSpecularTextureInfo();
            o2.specularTexture = e2.createTextureInfoDef(t3, n3);
          }
          if (r2.getSpecularColorTexture()) {
            const t3 = r2.getSpecularColorTexture(), n3 = r2.getSpecularColorTextureInfo();
            o2.specularColorTexture = e2.createTextureInfoDef(t3, n3);
          }
        }
      }), this;
    }
  }
  kx.EXTENSION_NAME = Rx;
  const { R: Dx } = Cb;
  class Bx extends dw {
    init() {
      this.extensionName = "KHR_materials_transmission", this.propertyType = "Transmission", this.parentTypes = [Ab.MATERIAL];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { transmissionFactor: 0, transmissionTexture: null, transmissionTextureInfo: new hw(this.graph, "transmissionTextureInfo") });
    }
    getTransmissionFactor() {
      return this.get("transmissionFactor");
    }
    setTransmissionFactor(e2) {
      return this.set("transmissionFactor", e2);
    }
    getTransmissionTexture() {
      return this.getRef("transmissionTexture");
    }
    getTransmissionTextureInfo() {
      return this.getRef("transmissionTexture") ? this.getRef("transmissionTextureInfo") : null;
    }
    setTransmissionTexture(e2) {
      return this.setRef("transmissionTexture", e2, { channels: Dx });
    }
  }
  Bx.EXTENSION_NAME = "KHR_materials_transmission";
  const Ox = "KHR_materials_transmission";
  class Lx extends Pw {
    constructor(...e2) {
      super(...e2), this.extensionName = Ox;
    }
    createTransmission() {
      return new Bx(this.document.getGraph());
    }
    read(e2) {
      const t2 = e2.jsonDoc, n2 = t2.json.textures || [];
      return (t2.json.materials || []).forEach((t3, r2) => {
        if (t3.extensions && t3.extensions[Ox]) {
          const i2 = this.createTransmission();
          e2.materials[r2].setExtension(Ox, i2);
          const s2 = t3.extensions[Ox];
          if (void 0 !== s2.transmissionFactor && i2.setTransmissionFactor(s2.transmissionFactor), void 0 !== s2.transmissionTexture) {
            const t4 = s2.transmissionTexture;
            i2.setTransmissionTexture(e2.textures[n2[t4.index].source]), e2.setTextureInfo(i2.getTransmissionTextureInfo(), t4);
          }
        }
      }), this;
    }
    write(e2) {
      const t2 = e2.jsonDoc;
      return this.document.getRoot().listMaterials().forEach((n2) => {
        const r2 = n2.getExtension(Ox);
        if (r2) {
          const i2 = e2.materialIndexMap.get(n2), s2 = t2.json.materials[i2];
          s2.extensions = s2.extensions || {};
          const o2 = s2.extensions[Ox] = { transmissionFactor: r2.getTransmissionFactor() };
          if (r2.getTransmissionTexture()) {
            const t3 = r2.getTransmissionTexture(), n3 = r2.getTransmissionTextureInfo();
            o2.transmissionTexture = e2.createTextureInfoDef(t3, n3);
          }
        }
      }), this;
    }
  }
  Lx.EXTENSION_NAME = Ox;
  class Ux extends dw {
    init() {
      this.extensionName = "KHR_materials_unlit", this.propertyType = "Unlit", this.parentTypes = [Ab.MATERIAL];
    }
  }
  Ux.EXTENSION_NAME = "KHR_materials_unlit";
  const Fx = "KHR_materials_unlit";
  class Nx extends Pw {
    constructor(...e2) {
      super(...e2), this.extensionName = Fx;
    }
    createUnlit() {
      return new Ux(this.document.getGraph());
    }
    read(e2) {
      return (e2.jsonDoc.json.materials || []).forEach((t2, n2) => {
        t2.extensions && t2.extensions[Fx] && e2.materials[n2].setExtension(Fx, this.createUnlit());
      }), this;
    }
    write(e2) {
      const t2 = e2.jsonDoc;
      return this.document.getRoot().listMaterials().forEach((n2) => {
        if (n2.getExtension(Fx)) {
          const r2 = e2.materialIndexMap.get(n2), i2 = t2.json.materials[r2];
          i2.extensions = i2.extensions || {}, i2.extensions[Fx] = {};
        }
      }), this;
    }
  }
  Nx.EXTENSION_NAME = Fx;
  class jx extends dw {
    init() {
      this.extensionName = "KHR_materials_variants", this.propertyType = "Mapping", this.parentTypes = ["MappingList"];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { material: null, variants: [] });
    }
    getMaterial() {
      return this.getRef("material");
    }
    setMaterial(e2) {
      return this.setRef("material", e2);
    }
    addVariant(e2) {
      return this.addRef("variants", e2);
    }
    removeVariant(e2) {
      return this.removeRef("variants", e2);
    }
    listVariants() {
      return this.listRefs("variants");
    }
  }
  jx.EXTENSION_NAME = "KHR_materials_variants";
  class zx extends dw {
    init() {
      this.extensionName = "KHR_materials_variants", this.propertyType = "MappingList", this.parentTypes = [Ab.PRIMITIVE];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { mappings: [] });
    }
    addMapping(e2) {
      return this.addRef("mappings", e2);
    }
    removeMapping(e2) {
      return this.removeRef("mappings", e2);
    }
    listMappings() {
      return this.listRefs("mappings");
    }
  }
  zx.EXTENSION_NAME = "KHR_materials_variants";
  class Gx extends dw {
    init() {
      this.extensionName = "KHR_materials_variants", this.propertyType = "Variant", this.parentTypes = ["MappingList"];
    }
  }
  Gx.EXTENSION_NAME = "KHR_materials_variants";
  const Vx = "KHR_materials_variants";
  class Hx extends Pw {
    constructor(...e2) {
      super(...e2), this.extensionName = Vx;
    }
    createMappingList() {
      return new zx(this.document.getGraph());
    }
    createVariant(e2 = "") {
      return new Gx(this.document.getGraph(), e2);
    }
    createMapping() {
      return new jx(this.document.getGraph());
    }
    listVariants() {
      return Array.from(this.properties).filter((e2) => e2 instanceof Gx);
    }
    read(e2) {
      const t2 = e2.jsonDoc;
      if (!t2.json.extensions || !t2.json.extensions[Vx])
        return this;
      const n2 = (t2.json.extensions[Vx].variants || []).map((e3) => this.createVariant().setName(e3.name || ""));
      return (t2.json.meshes || []).forEach((t3, r2) => {
        const i2 = e2.meshes[r2];
        (t3.primitives || []).forEach((t4, r3) => {
          if (!t4.extensions || !t4.extensions[Vx])
            return;
          const s2 = this.createMappingList(), o2 = t4.extensions[Vx];
          for (const t5 of o2.mappings) {
            const r4 = this.createMapping();
            void 0 !== t5.material && r4.setMaterial(e2.materials[t5.material]);
            for (const e3 of t5.variants || [])
              r4.addVariant(n2[e3]);
            s2.addMapping(r4);
          }
          i2.listPrimitives()[r3].setExtension(Vx, s2);
        });
      }), this;
    }
    write(e2) {
      const t2 = e2.jsonDoc, n2 = this.listVariants();
      if (!n2.length)
        return this;
      const r2 = [], i2 = /* @__PURE__ */ new Map();
      for (const t3 of n2)
        i2.set(t3, r2.length), r2.push(e2.createPropertyDef(t3));
      for (const t3 of this.document.getRoot().listMeshes()) {
        const n3 = e2.meshIndexMap.get(t3);
        t3.listPrimitives().forEach((t4, r3) => {
          const s2 = t4.getExtension(Vx);
          if (!s2)
            return;
          const o2 = e2.jsonDoc.json.meshes[n3].primitives[r3], a2 = s2.listMappings().map((t5) => {
            const n4 = e2.createPropertyDef(t5), r4 = t5.getMaterial();
            return r4 && (n4.material = e2.materialIndexMap.get(r4)), n4.variants = t5.listVariants().map((e3) => i2.get(e3)), n4;
          });
          o2.extensions = o2.extensions || {}, o2.extensions[Vx] = { mappings: a2 };
        });
      }
      return t2.json.extensions = t2.json.extensions || {}, t2.json.extensions[Vx] = { variants: r2 }, this;
    }
  }
  Hx.EXTENSION_NAME = Vx;
  const { G: Qx } = Cb;
  class Wx extends dw {
    init() {
      this.extensionName = "KHR_materials_volume", this.propertyType = "Volume", this.parentTypes = [Ab.MATERIAL];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { thicknessFactor: 0, thicknessTexture: null, thicknessTextureInfo: new hw(this.graph, "thicknessTexture"), attenuationDistance: 1 / 0, attenuationColor: [1, 1, 1] });
    }
    getThicknessFactor() {
      return this.get("thicknessFactor");
    }
    setThicknessFactor(e2) {
      return this.set("thicknessFactor", e2);
    }
    getThicknessTexture() {
      return this.getRef("thicknessTexture");
    }
    getThicknessTextureInfo() {
      return this.getRef("thicknessTexture") ? this.getRef("thicknessTextureInfo") : null;
    }
    setThicknessTexture(e2) {
      return this.setRef("thicknessTexture", e2, { channels: Qx });
    }
    getAttenuationDistance() {
      return this.get("attenuationDistance");
    }
    setAttenuationDistance(e2) {
      return this.set("attenuationDistance", e2);
    }
    getAttenuationColor() {
      return this.get("attenuationColor");
    }
    setAttenuationColor(e2) {
      return this.set("attenuationColor", e2);
    }
    getAttenuationColorHex() {
      return Lb.factorToHex(this.getAttenuationColor());
    }
    setAttenuationColorHex(e2) {
      const t2 = this.getAttenuationColor().slice();
      return this.set("attenuationColor", Lb.hexToFactor(e2, t2));
    }
  }
  Wx.EXTENSION_NAME = "KHR_materials_volume";
  const qx = "KHR_materials_volume";
  class Xx extends Pw {
    constructor(...e2) {
      super(...e2), this.extensionName = qx;
    }
    createVolume() {
      return new Wx(this.document.getGraph());
    }
    read(e2) {
      const t2 = e2.jsonDoc, n2 = t2.json.textures || [];
      return (t2.json.materials || []).forEach((t3, r2) => {
        if (t3.extensions && t3.extensions[qx]) {
          const i2 = this.createVolume();
          e2.materials[r2].setExtension(qx, i2);
          const s2 = t3.extensions[qx];
          if (void 0 !== s2.thicknessFactor && i2.setThicknessFactor(s2.thicknessFactor), void 0 !== s2.attenuationDistance && i2.setAttenuationDistance(s2.attenuationDistance), void 0 !== s2.attenuationColor && i2.setAttenuationColor(s2.attenuationColor), void 0 !== s2.thicknessTexture) {
            const t4 = s2.thicknessTexture;
            i2.setThicknessTexture(e2.textures[n2[t4.index].source]), e2.setTextureInfo(i2.getThicknessTextureInfo(), t4);
          }
        }
      }), this;
    }
    write(e2) {
      const t2 = e2.jsonDoc;
      return this.document.getRoot().listMaterials().forEach((n2) => {
        const r2 = n2.getExtension(qx);
        if (r2) {
          const i2 = e2.materialIndexMap.get(n2), s2 = t2.json.materials[i2];
          s2.extensions = s2.extensions || {};
          const o2 = s2.extensions[qx] = {};
          if (r2.getThicknessFactor() > 0 && (o2.thicknessFactor = r2.getThicknessFactor()), Number.isFinite(r2.getAttenuationDistance()) && (o2.attenuationDistance = r2.getAttenuationDistance()), Qb.eq(r2.getAttenuationColor(), [1, 1, 1]) || (o2.attenuationColor = r2.getAttenuationColor()), r2.getThicknessTexture()) {
            const t3 = r2.getThicknessTexture(), n3 = r2.getThicknessTextureInfo();
            o2.thicknessTexture = e2.createTextureInfoDef(t3, n3);
          }
        }
      }), this;
    }
  }
  Xx.EXTENSION_NAME = qx;
  const Yx = "KHR_mesh_quantization";
  class Kx extends Pw {
    constructor(...e2) {
      super(...e2), this.extensionName = Yx;
    }
    read(e2) {
      return this;
    }
    write(e2) {
      return this;
    }
  }
  Kx.EXTENSION_NAME = Yx;
  const Jx = "KHR_texture_basisu";
  class Zx {
    match(e2) {
      return 171 === e2[0] && 75 === e2[1] && 84 === e2[2] && 88 === e2[3] && 32 === e2[4] && 50 === e2[5] && 48 === e2[6] && 187 === e2[7] && 13 === e2[8] && 10 === e2[9] && 26 === e2[10] && 10 === e2[11];
    }
    getSize(e2) {
      const t2 = Yw(e2);
      return [t2.pixelWidth, t2.pixelHeight];
    }
    getChannels(e2) {
      const t2 = Yw(e2).dataFormatDescriptor[0];
      if (163 === t2.colorModel)
        return 2 === t2.samples.length && 15 == (15 & t2.samples[1].channelType) ? 4 : 3;
      if (166 === t2.colorModel)
        return 3 == (15 & t2.samples[0].channelType) ? 4 : 3;
      throw new Error(`Unexpected KTX2 colorModel, "${t2.colorModel}".`);
    }
    getVRAMByteLength(e2) {
      const t2 = Yw(e2), n2 = this.getChannels(e2) > 3;
      let r2 = 0;
      for (let e3 = 0; e3 < t2.levels.length; e3++) {
        const i2 = t2.levels[e3];
        r2 += i2.uncompressedByteLength ? i2.uncompressedByteLength : Math.max(1, Math.floor(t2.pixelWidth / Math.pow(2, e3))) / 4 * (Math.max(1, Math.floor(t2.pixelHeight / Math.pow(2, e3))) / 4) * (n2 ? 16 : 8);
      }
      return r2;
    }
  }
  class $x extends Pw {
    constructor(...e2) {
      super(...e2), this.extensionName = Jx, this.prereadTypes = [Ab.TEXTURE];
    }
    static register() {
      Fb.registerFormat("image/ktx2", new Zx());
    }
    preread(e2) {
      return e2.jsonDoc.json.textures.forEach((e3) => {
        e3.extensions && e3.extensions[Jx] && (e3.source = e3.extensions[Jx].source);
      }), this;
    }
    read(e2) {
      return this;
    }
    write(e2) {
      const t2 = e2.jsonDoc;
      return this.document.getRoot().listTextures().forEach((n2) => {
        if ("image/ktx2" === n2.getMimeType()) {
          const r2 = e2.imageIndexMap.get(n2);
          t2.json.textures.forEach((e3) => {
            e3.source === r2 && (e3.extensions = e3.extensions || {}, e3.extensions[Jx] = { source: e3.source }, delete e3.source);
          });
        }
      }), this;
    }
  }
  $x.EXTENSION_NAME = Jx;
  class eE extends dw {
    init() {
      this.extensionName = "KHR_texture_transform", this.propertyType = "Transform", this.parentTypes = [Ab.TEXTURE_INFO];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { offset: [0, 0], rotation: 0, scale: [1, 1], texCoord: null });
    }
    getOffset() {
      return this.get("offset");
    }
    setOffset(e2) {
      return this.set("offset", e2);
    }
    getRotation() {
      return this.get("rotation");
    }
    setRotation(e2) {
      return this.set("rotation", e2);
    }
    getScale() {
      return this.get("scale");
    }
    setScale(e2) {
      return this.set("scale", e2);
    }
    getTexCoord() {
      return this.get("texCoord");
    }
    setTexCoord(e2) {
      return this.set("texCoord", e2);
    }
  }
  eE.EXTENSION_NAME = "KHR_texture_transform";
  const tE = "KHR_texture_transform";
  class nE extends Pw {
    constructor(...e2) {
      super(...e2), this.extensionName = tE;
    }
    createTransform() {
      return new eE(this.document.getGraph());
    }
    read(e2) {
      for (const [t2, n2] of Array.from(e2.textureInfos.entries())) {
        if (!n2.extensions || !n2.extensions[tE])
          continue;
        const e3 = this.createTransform(), r2 = n2.extensions[tE];
        void 0 !== r2.offset && e3.setOffset(r2.offset), void 0 !== r2.rotation && e3.setRotation(r2.rotation), void 0 !== r2.scale && e3.setScale(r2.scale), void 0 !== r2.texCoord && e3.setTexCoord(r2.texCoord), t2.setExtension(tE, e3);
      }
      return this;
    }
    write(e2) {
      const t2 = Array.from(e2.textureInfoDefMap.entries());
      for (const [e3, n2] of t2) {
        const t3 = e3.getExtension(tE);
        if (!t3)
          continue;
        n2.extensions = n2.extensions || {};
        const r2 = {}, i2 = Qb.eq;
        i2(t3.getOffset(), [0, 0]) || (r2.offset = t3.getOffset()), 0 !== t3.getRotation() && (r2.rotation = t3.getRotation()), i2(t3.getScale(), [1, 1]) || (r2.scale = t3.getScale()), null != t3.getTexCoord() && (r2.texCoord = t3.getTexCoord()), n2.extensions[tE] = r2;
      }
      return this;
    }
  }
  nE.EXTENSION_NAME = tE;
  const rE = [Ab.ROOT, Ab.SCENE, Ab.NODE, Ab.MESH, Ab.MATERIAL, Ab.TEXTURE, Ab.ANIMATION];
  class iE extends dw {
    init() {
      this.extensionName = "KHR_xmp_json_ld", this.propertyType = "Packet", this.parentTypes = rE;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { context: {}, properties: {} });
    }
    getContext() {
      return this.get("context");
    }
    setContext(e2) {
      return this.set("context", $w({}, e2));
    }
    listProperties() {
      return Object.keys(this.get("properties"));
    }
    getProperty(e2) {
      const t2 = this.get("properties");
      return e2 in t2 ? t2[e2] : null;
    }
    setProperty(e2, t2) {
      this._assertContext(e2);
      const n2 = $w({}, this.get("properties"));
      return t2 ? n2[e2] = t2 : delete n2[e2], this.set("properties", n2);
    }
    toJSONLD() {
      return $w({ "@context": sE(this.get("context")) }, sE(this.get("properties")));
    }
    fromJSONLD(e2) {
      const t2 = (e2 = sE(e2))["@context"];
      return t2 && this.set("context", t2), delete e2["@context"], this.set("properties", e2);
    }
    _assertContext(e2) {
      if (!(e2.split(":")[0] in this.get("context")))
        throw new Error(`KHR_xmp_json_ld: Missing context for term, "${e2}".`);
    }
  }
  function sE(e2) {
    return JSON.parse(JSON.stringify(e2));
  }
  iE.EXTENSION_NAME = "KHR_xmp_json_ld";
  const oE = "KHR_xmp_json_ld";
  class aE extends Pw {
    constructor(...e2) {
      super(...e2), this.extensionName = oE;
    }
    createPacket() {
      return new iE(this.document.getGraph());
    }
    listPackets() {
      return Array.from(this.properties);
    }
    read(e2) {
      var t2;
      const n2 = null == (t2 = e2.jsonDoc.json.extensions) ? void 0 : t2[oE];
      if (!n2 || !n2.packets)
        return this;
      const r2 = e2.jsonDoc.json, i2 = this.document.getRoot(), s2 = n2.packets.map((e3) => this.createPacket().fromJSONLD(e3)), o2 = [[r2.asset], r2.scenes, r2.nodes, r2.meshes, r2.materials, r2.images, r2.animations], a2 = [[i2], i2.listScenes(), i2.listNodes(), i2.listMeshes(), i2.listMaterials(), i2.listTextures(), i2.listAnimations()];
      for (let e3 = 0; e3 < o2.length; e3++) {
        const t3 = o2[e3] || [];
        for (let n3 = 0; n3 < t3.length; n3++) {
          const r3 = t3[n3];
          r3.extensions && r3.extensions[oE] && a2[e3][n3].setExtension(oE, s2[r3.extensions[oE].packet]);
        }
      }
      return this;
    }
    write(e2) {
      const { json: t2 } = e2.jsonDoc, n2 = [];
      for (const r2 of this.properties) {
        n2.push(r2.toJSONLD());
        for (const i2 of r2.listParents()) {
          let r3;
          switch (i2.propertyType) {
            case Ab.ROOT:
              r3 = t2.asset;
              break;
            case Ab.SCENE:
              r3 = t2.scenes[e2.sceneIndexMap.get(i2)];
              break;
            case Ab.NODE:
              r3 = t2.nodes[e2.nodeIndexMap.get(i2)];
              break;
            case Ab.MESH:
              r3 = t2.meshes[e2.meshIndexMap.get(i2)];
              break;
            case Ab.MATERIAL:
              r3 = t2.materials[e2.materialIndexMap.get(i2)];
              break;
            case Ab.TEXTURE:
              r3 = t2.images[e2.imageIndexMap.get(i2)];
              break;
            case Ab.ANIMATION:
              r3 = t2.animations[e2.animationIndexMap.get(i2)];
              break;
            default:
              r3 = null, this.document.getLogger().warn(`[${oE}]: Unsupported parent property, "${i2.propertyType}"`);
          }
          r3 && (r3.extensions = r3.extensions || {}, r3.extensions[oE] = { packet: n2.length - 1 });
        }
      }
      return n2.length > 0 && (t2.extensions = t2.extensions || {}, t2.extensions[oE] = { packets: n2 }), this;
    }
  }
  aE.EXTENSION_NAME = oE;
  const lE = [Zw, fA, gA, wA, NA, VA, XA, ex, rx, ox, px, vx, kx, Cx, Lx, Nx, Hx, Xx, Kx, $x, nE, aE];
  class cE extends Uy {
    constructor(e2) {
      super(), this._loadedLibs = false, e2 = e2 || { method: NA.EncoderMethod.EDGEBREAKER, encodeSpeed: 5 }, this._io = new Vw().registerExtensions(lE).registerExtensions([dE, wE, gE, vE, yE, AE, xE, EE, CE, SE, ME, TE, PE, kE, IE, DE, bE, RE]), this._encoderOptions = e2;
    }
    preload() {
      return this._loadLibs(), this;
    }
    async _loadLibs() {
      if (this._loadedLibs || !this.loader)
        return;
      const e2 = await Promise.all([this.loader.initEncoder(), this.loader.initDecoder()]);
      this._io.registerDependencies({ "draco3d.encoder": e2[0], "draco3d.decoder": e2[1] }), this._loadedLibs = true;
    }
    async parseAsync(e2, { compress: t2 = false, dracoOptions: n2, ...r2 }) {
      if (!this.loader)
        return console.error("GLTFDracoExporter: No DRACOLoader2 instance provided"), super.parseAsync(e2, r2);
      await this._loadLibs();
      const i2 = { ...r2 };
      t2 && (i2.externalImagesInExtras = true);
      const s2 = await new Promise((t3, n3) => this.parse(e2, t3, n3, i2)), o2 = await super.parseAsync(s2, i2);
      if (!t2)
        return o2;
      if (!s2)
        throw new Error("GLTFDracoExporter: gltf is null");
      let a2 = s2;
      const l2 = a2.byteLength || 1 / 0, c2 = await ("object" != typeof a2 || a2.byteLength ? this._io.readBinary(new Uint8Array(a2)) : this._io.readJSON({ json: a2, resources: {} }));
      if (c2.createExtension(NA).setRequired(true).setEncoderOptions({ ...this._encoderOptions, ...null != n2 ? n2 : {} }), "glb" === i2.exportExt)
        a2 = await this._io.writeBinary(c2), isFinite(l2) && console.log("DRACO Compression ratio: " + (a2.byteLength / l2).toFixed(5));
      else {
        const e3 = await this._io.writeJSON(c2);
        a2 = e3.json, Object.values(e3.resources).filter((e4) => e4).length > 0 && (console.warn("DRACOExporter: extra resources in resources not supported properly"), a2.resources = e3.resources);
      }
      a2.__isGLTFOutput = true;
      const u2 = await super.parseAsync(a2, i2);
      if (!u2)
        throw new Error("GLTFDracoExporter: blob is null");
      return u2.ext = "glb", u2.__uncompressed = o2, u2;
    }
    addExtension(e2) {
      return this._io.registerExtensions([e2]), this;
    }
    createAndAddExtension(e2, t2) {
      return this.addExtension(_E(e2, t2));
    }
  }
  class uE extends gt {
    constructor() {
      super(...arguments), this.enabled = true, this.dependencies = [Ls, ub];
    }
    async onAdded(e2) {
      await super.onAdded(e2);
      const t2 = e2.getManager().importer, n2 = e2.getManager().exporter;
      if (!t2)
        throw new Error("GLTFDracoExportPlugin: AssetImporter not found");
      !function(e3, t3, n3) {
        jy(e3, t3, cE, (e4) => {
          const t4 = ke() + ".drc", r2 = e4;
          r2.loader = n3.registerFile(t4), r2.loader.setDecoderConfig({ type: "js" }), r2.loader.preload(true, true);
        });
      }(n2, e2, t2);
    }
  }
  uE.PluginType = "GLTFDracoExportPlugin";
  class pE extends dw {
    constructor() {
      super(...arguments), this.extensionName = jn, this.parentTypes = [Ab.SCENE], this.propertyType = "ViewerJSON";
    }
    init() {
    }
  }
  class dE extends Pw {
    constructor() {
      super(...arguments), this.extensionName = jn, this._viewerConfig = {}, this._texturesRef = [], this.required = true;
    }
    read(e2) {
      var t2;
      return this._viewerConfig = {}, null === (t2 = e2.jsonDoc.json.scenes) || void 0 === t2 || t2.forEach((t3, n2) => {
        if (t3.extensions && t3.extensions[jn]) {
          const r2 = new pE(this.document.getGraph());
          e2.scenes[n2].setExtension(jn, r2), this._viewerConfig = t3.extensions[jn];
        }
      }), this;
    }
    write(e2) {
      return this.document.getRoot().listScenes().forEach((t2) => {
        var n2;
        if (t2.getExtension(jn)) {
          const t3 = null === (n2 = e2.jsonDoc.json.scenes) || void 0 === n2 ? void 0 : n2[e2.jsonDoc.json.scene || 0];
          t3 && Object.keys(this._viewerConfig).length > 0 && (t3.extensions = t3.extensions || {}, t3.extensions[jn] = this._viewerConfig, this._texturesRef = [], this._viewerConfig = {});
        }
      }), this;
    }
  }
  dE.EXTENSION_NAME = jn;
  class hE extends dw {
    addTexture(e2, t2, n2, r2 = 4369) {
      this.setRef(e2, n2, { channels: r2 }), this.textures[e2] = [t2, n2];
    }
    constructor(e2, t2, n2) {
      super(e2, t2), this.parentTypes = [Ab.MATERIAL, Ab.MESH, Ab.NODE, Ab.SCENE], this.propertyType = "GenericExtension", this.textures = {}, this.extensionName = n2;
    }
    init() {
    }
  }
  class fE extends Pw {
    constructor() {
      super(...arguments), this.textureChannels = {};
    }
    read(e2) {
      const t2 = e2.jsonDoc, n2 = t2.json.materials || [], r2 = t2.json.textures || [];
      return n2.forEach((t3, n3) => {
        var i2, s2;
        if (t3.extensions && t3.extensions[this.extensionName]) {
          const o2 = new hE(this.document.getGraph(), "", this.extensionName);
          e2.materials[n3].setExtension(this.extensionName, o2);
          const a2 = { ...t3.extensions[this.extensionName] };
          for (const [t4, n4] of Object.entries(a2))
            if ("number" == typeof (null == n4 ? void 0 : n4.index)) {
              const l2 = n4, c2 = null === (i2 = r2[l2.index]) || void 0 === i2 ? void 0 : i2.source;
              if ("number" != typeof c2) {
                console.warn("GLTF Pipeline: source texture not found for texture info", l2);
                continue;
              }
              const u2 = e2.textures[c2], p2 = new hw(this.document.getGraph()), d2 = null !== (s2 = this.textureChannels[t4]) && void 0 !== s2 ? s2 : 4369;
              o2.addTexture(t4, p2, u2, d2), e2.setTextureInfo(p2, l2), delete a2[t4];
            }
          o2.setExtras(a2);
        }
      }), (t2.json.meshes || []).forEach((t3, n3) => {
        if (t3.extensions && t3.extensions[this.extensionName]) {
          const r3 = new hE(this.document.getGraph(), "", this.extensionName);
          e2.meshes[n3].setExtension(this.extensionName, r3);
          const i2 = t3.extensions[this.extensionName];
          r3.setExtras(i2);
        }
      }), (t2.json.nodes || []).forEach((t3, n3) => {
        if (t3.extensions && t3.extensions[this.extensionName]) {
          const r3 = new hE(this.document.getGraph(), "", this.extensionName);
          e2.nodes[n3].setExtension(this.extensionName, r3);
          const i2 = t3.extensions[this.extensionName];
          r3.setExtras(i2);
        }
      }), (t2.json.scenes || []).forEach((t3, n3) => {
        if (t3.extensions && t3.extensions[this.extensionName]) {
          const r3 = new hE(this.document.getGraph(), "", this.extensionName);
          e2.scenes[n3].setExtension(this.extensionName, r3);
          const i2 = t3.extensions[this.extensionName];
          r3.setExtras(i2);
        }
      }), this;
    }
    write(e2) {
      const t2 = e2.jsonDoc;
      return this.document.getRoot().listMaterials().forEach((n2) => {
        const r2 = n2.getExtension(this.extensionName);
        if (r2) {
          const i2 = e2.materialIndexMap.get(n2), s2 = t2.json.materials[i2];
          s2.extensions = s2.extensions || {};
          const o2 = { ...r2.getExtras() };
          for (const [t3, n3] of Object.entries(r2.textures)) {
            const r3 = n3[0], i3 = n3[1];
            i3 && (o2[t3] = e2.createTextureInfoDef(i3, r3));
          }
          s2.extensions[this.extensionName] = o2;
        }
      }), this.document.getRoot().listMeshes().forEach((n2) => {
        const r2 = n2.getExtension(this.extensionName);
        if (r2) {
          const i2 = e2.meshIndexMap.get(n2), s2 = t2.json.meshes[i2];
          s2.extensions = s2.extensions || {}, s2.extensions[this.extensionName] = r2.getExtras();
        }
      }), this.document.getRoot().listNodes().forEach((n2) => {
        const r2 = n2.getExtension(this.extensionName);
        if (r2) {
          const i2 = e2.nodeIndexMap.get(n2), s2 = t2.json.nodes[i2];
          s2.extensions = s2.extensions || {}, s2.extensions[this.extensionName] = r2.getExtras();
        }
      }), this.document.getRoot().listScenes().forEach((n2) => {
        const r2 = n2.getExtension(this.extensionName);
        if (r2) {
          const n3 = e2.jsonDoc.json.scene || 0, i2 = t2.json.scenes[n3];
          if (!i2)
            return;
          i2.extensions = i2.extensions || {}, i2.extensions[this.extensionName] = r2.getExtras();
        }
      }), this;
    }
  }
  function mE(e2) {
    let t2 = 0;
    return e2.includes("R") && (t2 |= Cb.R), e2.includes("G") && (t2 |= Cb.G), e2.includes("B") && (t2 |= Cb.B), e2.includes("A") && (t2 |= Cb.A), t2;
  }
  function _E(e2, t2) {
    var n2;
    return n2 = class extends fE {
      constructor() {
        super(...arguments), this.extensionName = e2, this.textureChannels = t2 ? Object.fromEntries(Object.entries(t2).map(([e3, t3]) => [e3, "number" == typeof t3 ? t3 : mE(t3)])) : {};
      }
    }, n2.EXTENSION_NAME = e2, n2;
  }
  class gE extends fE {
    constructor() {
      super(...arguments), this.extensionName = gE.EXTENSION_NAME, this.textureChannels = { bumpTexture: Cb.R };
    }
  }
  gE.EXTENSION_NAME = Yn;
  class vE extends fE {
    constructor() {
      super(...arguments), this.extensionName = vE.EXTENSION_NAME, this.textureChannels = { lightMapTexture: Cb.R | Cb.G | Cb.B };
    }
  }
  vE.EXTENSION_NAME = Zn;
  class yE extends fE {
    constructor() {
      super(...arguments), this.extensionName = yE.EXTENSION_NAME, this.textureChannels = { alphaTexture: Cb.G };
    }
  }
  yE.EXTENSION_NAME = Jn;
  class bE extends fE {
    constructor() {
      super(...arguments), this.extensionName = bE.EXTENSION_NAME, this.textureChannels = { displacementTexture: Cb.R };
    }
  }
  bE.EXTENSION_NAME = Kn;
  class wE extends fE {
    constructor() {
      super(...arguments), this.extensionName = wE.EXTENSION_NAME;
    }
  }
  wE.EXTENSION_NAME = Bc.DIAMOND_GLTF_EXTENSION;
  class AE extends fE {
    constructor() {
      super(...arguments), this.extensionName = AE.EXTENSION_NAME;
    }
  }
  AE.EXTENSION_NAME = Ya.AnimationMarkersExtension;
  class xE extends fE {
    constructor() {
      super(...arguments), this.extensionName = xE.EXTENSION_NAME, this.textureChannels = { anisotropyDirection: Cb.R | Cb.G | Cb.B };
    }
  }
  xE.EXTENSION_NAME = Sl.ANISOTROPY_GLTF_EXTENSION;
  class EE extends fE {
    constructor() {
      super(...arguments), this.extensionName = EE.EXTENSION_NAME, this.textureChannels = { customBumpMap: Cb.R | Cb.G | Cb.B };
    }
  }
  EE.EXTENSION_NAME = Ha.CUSTOM_BUMP_MAP_GLTF_EXTENSION;
  class CE extends fE {
    constructor() {
      super(...arguments), this.extensionName = CE.EXTENSION_NAME;
    }
  }
  CE.EXTENSION_NAME = Gn;
  class SE extends fE {
    constructor() {
      super(...arguments), this.extensionName = SE.EXTENSION_NAME;
    }
  }
  SE.EXTENSION_NAME = Vn;
  class ME extends fE {
    constructor() {
      super(...arguments), this.extensionName = ME.EXTENSION_NAME;
    }
  }
  ME.EXTENSION_NAME = Hn;
  class TE extends fE {
    constructor() {
      super(...arguments), this.extensionName = TE.EXTENSION_NAME;
    }
  }
  TE.EXTENSION_NAME = Wd.CLEARCOAT_TINT_GLTF_EXTENSION;
  class PE extends fE {
    constructor() {
      super(...arguments), this.extensionName = PE.EXTENSION_NAME;
    }
  }
  PE.EXTENSION_NAME = Do.THIN_FILM_LAYER_GLTF_EXTENSION;
  class IE extends fE {
    constructor() {
      super(...arguments), this.extensionName = IE.EXTENSION_NAME;
    }
  }
  IE.EXTENSION_NAME = Fd.TRIPLANAR_GLTF_EXTENSION;
  class RE extends fE {
    constructor() {
      super(...arguments), this.extensionName = RE.EXTENSION_NAME;
    }
  }
  RE.EXTENSION_NAME = Gd.LAYERED_MATERIAL_GLTF_EXTENSION;
  class kE extends fE {
    constructor() {
      super(...arguments), this.extensionName = kE.EXTENSION_NAME;
    }
  }
  kE.EXTENSION_NAME = kd.SSBEVEL_GLTF_EXTENSION;
  class DE extends fE {
    constructor() {
      super(...arguments), this.extensionName = DE.EXTENSION_NAME;
    }
  }
  DE.EXTENSION_NAME = fd.NOISE_BUMP_MATERIAL_GLTF_EXTENSION;
  class BE extends t.SimpleEventDispatcher {
    constructor() {
      super(...arguments), this.processor = { forAssetType: "texture", process: (e2, t2) => e2 };
    }
    async onAdded(e2) {
    }
    async onDispose(e2) {
    }
    async onRemove(e2) {
      this._pmrem = void 0;
    }
  }
  BE.PluginType = "PMREMGenerator";
  const OE = new n.Pa4(), LE = new n._fP(), UE = new n.Pa4();
  class FE extends n.Tme {
    constructor(e2 = document.createElement("div")) {
      super(), this.isCSS3DObject = true, this.element = e2, this.element.style.position = "absolute", this.element.style.pointerEvents = "auto", this.element.style.userSelect = "none", this.element.setAttribute("draggable", false), this.addEventListener("removed", function() {
        this.traverse(function(e3) {
          e3.element instanceof Element && null !== e3.element.parentNode && e3.element.parentNode.removeChild(e3.element);
        });
      });
    }
    copy(e2, t2) {
      return super.copy(e2, t2), this.element = e2.element.cloneNode(true), this;
    }
  }
  const NE = new n.yGw(), jE = new n.yGw();
  class zE {
    constructor(e2 = {}) {
      const t2 = this;
      let n2, r2, i2, s2;
      const o2 = { camera: { fov: 0, style: "" }, objects: /* @__PURE__ */ new WeakMap() }, a2 = void 0 !== e2.element ? e2.element : document.createElement("div");
      a2.style.overflow = "hidden", this.domElement = a2;
      const l2 = document.createElement("div");
      l2.style.transformOrigin = "0 0", l2.style.pointerEvents = "none", a2.appendChild(l2);
      const c2 = document.createElement("div");
      function u2(e3) {
        return Math.abs(e3) < 1e-10 ? 0 : e3;
      }
      function p2(e3) {
        const t3 = e3.elements;
        return "matrix3d(" + u2(t3[0]) + "," + u2(-t3[1]) + "," + u2(t3[2]) + "," + u2(t3[3]) + "," + u2(t3[4]) + "," + u2(-t3[5]) + "," + u2(t3[6]) + "," + u2(t3[7]) + "," + u2(t3[8]) + "," + u2(-t3[9]) + "," + u2(t3[10]) + "," + u2(t3[11]) + "," + u2(t3[12]) + "," + u2(-t3[13]) + "," + u2(t3[14]) + "," + u2(t3[15]) + ")";
      }
      function d2(e3) {
        const t3 = e3.elements;
        return "translate(-50%,-50%)matrix3d(" + u2(t3[0]) + "," + u2(t3[1]) + "," + u2(t3[2]) + "," + u2(t3[3]) + "," + u2(-t3[4]) + "," + u2(-t3[5]) + "," + u2(-t3[6]) + "," + u2(-t3[7]) + "," + u2(t3[8]) + "," + u2(t3[9]) + "," + u2(t3[10]) + "," + u2(t3[11]) + "," + u2(t3[12]) + "," + u2(t3[13]) + "," + u2(t3[14]) + "," + u2(t3[15]) + ")";
      }
      function h2(e3, n3, r3, i3) {
        if (e3.isCSS3DObject) {
          const i4 = true === e3.visible && true === e3.layers.test(r3.layers);
          if (e3.element.style.display = true === i4 ? "" : "none", true === i4) {
            let i5;
            e3.onBeforeRender(t2, n3, r3), e3.isCSS3DSprite ? (NE.copy(r3.matrixWorldInverse), NE.transpose(), 0 !== e3.rotation2D && NE.multiply(jE.makeRotationZ(e3.rotation2D)), e3.matrixWorld.decompose(OE, LE, UE), NE.setPosition(OE), NE.scale(UE), NE.elements[3] = 0, NE.elements[7] = 0, NE.elements[11] = 0, NE.elements[15] = 1, i5 = d2(NE)) : i5 = d2(e3.matrixWorld);
            const s3 = e3.element, a3 = o2.objects.get(e3);
            if (void 0 === a3 || a3.style !== i5) {
              s3.style.transform = i5;
              const t3 = { style: i5 };
              o2.objects.set(e3, t3);
            }
            s3.parentNode !== c2 && c2.appendChild(s3), e3.onAfterRender(t2, n3, r3);
          }
        }
        for (let t3 = 0, s3 = e3.children.length; t3 < s3; t3++)
          h2(e3.children[t3], n3, r3, i3);
      }
      c2.style.transformStyle = "preserve-3d", l2.appendChild(c2), this.getSize = function() {
        return { width: n2, height: r2 };
      }, this.render = function(e3, t3) {
        const a3 = t3.projectionMatrix.elements[5] * s2;
        let d3, f2;
        o2.camera.fov !== a3 && (l2.style.perspective = t3.isPerspectiveCamera ? a3 + "px" : "", o2.camera.fov = a3), t3.view && t3.view.enabled ? (l2.style.transform = `translate( ${-t3.view.offsetX * (n2 / t3.view.width)}px, ${-t3.view.offsetY * (r2 / t3.view.height)}px )`, l2.style.transform += `scale( ${t3.view.fullWidth / t3.view.width}, ${t3.view.fullHeight / t3.view.height} )`) : l2.style.transform = "", true === e3.matrixWorldAutoUpdate && e3.updateMatrixWorld(), null === t3.parent && true === t3.matrixWorldAutoUpdate && t3.updateMatrixWorld(), t3.isOrthographicCamera && (d3 = -(t3.right + t3.left) / 2, f2 = (t3.top + t3.bottom) / 2);
        const m2 = t3.view && t3.view.enabled ? t3.view.height / t3.view.fullHeight : 1, _2 = t3.isOrthographicCamera ? `scale( ${m2} )scale(` + a3 + ")translate(" + u2(d3) + "px," + u2(f2) + "px)" + p2(t3.matrixWorldInverse) : `scale( ${m2} )translateZ(` + a3 + "px)" + p2(t3.matrixWorldInverse), g2 = _2 + "translate(" + i2 + "px," + s2 + "px)";
        o2.camera.style !== g2 && (c2.style.transform = g2, o2.camera.style = g2), h2(e3, e3, t3, _2);
      }, this.setSize = function(e3, t3) {
        n2 = e3, r2 = t3, i2 = n2 / 2, s2 = r2 / 2, a2.style.width = e3 + "px", a2.style.height = t3 + "px", l2.style.width = e3 + "px", l2.style.height = t3 + "px", c2.style.width = e3 + "px", c2.style.height = t3 + "px";
      };
    }
  }
  var GE, VE = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let HE = GE = class extends gt {
    constructor(e2 = true) {
      super(), this._scene = new n.xsS(), this.overCanvas = true, this._trackers = [], this.attachIFrameToSelected = async () => {
        var e3, t2, n2, r2, i2;
        const s2 = null === (t2 = null === (e3 = this._viewer) || void 0 === e3 ? void 0 : e3.getPlugin(za)) || void 0 === t2 ? void 0 : t2.getSelectedObject();
        if (!(null == s2 ? void 0 : s2.geometry))
          return void await (null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.alert("No Geometry: Selected object must have a geometry to apply the iframe to"));
        const o2 = await (null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.prompt("URL: Enter the url for the webpage. (Make sure its allowed to be embedded in an iframe.)", "https://webgi.xyz/", false)) || "https://webgi.pixotronics.com/";
        if (!o2)
          return;
        const a2 = await (null === (i2 = this._viewer) || void 0 === i2 ? void 0 : i2.prompt("Width: Enter the width for the object.", "512", false)) || "512";
        a2 && this.attachIFrame(s2, o2, parseInt(a2));
      }, this._resizeObserver = new ResizeObserver(() => {
        var e3;
        this.enabled && (null === (e3 = this._viewer) || void 0 === e3 || e3.scene.setDirty({ sceneUpdate: true }));
      }), this.enabled = e2, this._refreshCanvasInDOM = this._refreshCanvasInDOM.bind(this), this._refreshEnabled = this._refreshEnabled.bind(this);
    }
    _refreshEnabled() {
    }
    _refreshCanvasInDOM() {
      const e2 = this._viewer;
      e2 && this._renderer && (e2.canvas.remove(), this.overCanvas ? this._renderer.domElement.insertAdjacentElement("afterbegin", e2.canvas) : this._renderer.domElement.appendChild(e2.canvas));
    }
    _initialize() {
      if (this._renderer)
        return;
      if (!this._viewer)
        return;
      this._renderer = new zE();
      const e2 = this._viewer.renderer.rendererObject.getSize(new n.FM8());
      this._renderer.setSize(e2.width, e2.height);
      const t2 = document.createElement("div");
      t2.style.position = "absolute", t2.style.top = "0", t2.style.zIndex = "0", t2.appendChild(this._renderer.domElement), this._viewer.canvas.style.position = "absolute", this._viewer.canvas.style.top = "0", this._viewer.canvas.style.left = "0", this._viewer.canvas.style.zIndex = "0", this._viewer.container.appendChild(t2), this._refreshCanvasInDOM(), this._viewer.renderer.addEventListener("resize", () => {
        if (!this._viewer || !this._renderer)
          return;
        const e3 = this._viewer.renderer.rendererObject.getSize(new n.FM8());
        this._renderer.setSize(e3.width, e3.height);
      });
    }
    async onAdded(e2) {
      await super.onAdded(e2);
      let t2 = true, r2 = true;
      e2.addEventListener("postFrame", (i3) => {
        var s3, o2;
        t2 && this.enabled && (this._renderer || this._initialize(), this._renderer && (r2 && this._trackers.forEach((e3) => {
          var t3, r3;
          let i4 = true;
          const s4 = e3.modelObj.material.side;
          if (s4 !== n.ehD) {
            const o3 = new n.Pa4(0, 0, 1).applyQuaternion(e3.cssObj.quaternion), a2 = null === (r3 = null === (t3 = this._viewer) || void 0 === t3 ? void 0 : t3.scene.activeCamera) || void 0 === r3 ? void 0 : r3.cameraObject, l2 = o3.dot(a2.getWorldDirection(new n.Pa4()));
            i4 = s4 === n._Li ? l2 > 0 : l2 < 0;
          }
          e3.cssObj.element.style.visibility = i4 ? "visible" : "hidden";
        }), this._trackers.filter((e3) => e3.dirty).forEach((e3) => this._syncProperties(e3)), null === (s3 = this._renderer) || void 0 === s3 || s3.render(this._scene, null === (o2 = e2.scene.activeCamera) || void 0 === o2 ? void 0 : o2.cameraObject), t2 = false));
      }), e2.addEventListener("update", (e3) => {
        this.enabled && (t2 = this._trackers.length > 0);
      }), e2.scene.addEventListener("sceneUpdate", (e3) => {
        this.enabled && (this._trackers.forEach((e4) => e4.dirty = true), t2 = this._trackers.length > 0);
      }), e2.scene.addEventListener("activeCameraUpdate", (e3) => {
        this.enabled && (t2 = this._trackers.length > 0, r2 = true);
      });
      let i2 = false;
      const s2 = new n.iMs();
      e2.container.addEventListener("mousemove", (e3) => {
        if (!this.enabled || !this._viewer || this.overCanvas)
          return;
        const t3 = this._viewer.canvas.getBoundingClientRect(), n2 = (e3.clientX - t3.x) / t3.width * 2 - 1, r3 = -(e3.clientY - t3.y) / t3.height * 2 + 1;
        s2.setFromCamera({ x: n2, y: r3 }, this._viewer.scene.activeCamera.cameraObject);
        const o2 = this._trackers.map((e4) => e4.modelObj), a2 = s2.intersectObjects(o2, false);
        if (console.log(a2), a2.length)
          return this._viewer.canvas.style.pointerEvents = "none", i2 = true, void console.log(this._viewer.canvas.style.pointerEvents);
        i2 && (this._viewer.canvas.style.pointerEvents = "auto", i2 = false);
      });
    }
    attachIFrame(e2, t2, n2) {
      const r2 = XE(e2.modelObject), i2 = QE(t2, n2, n2 * r2.y / r2.x, () => {
        var t3;
        return null === (t3 = e2.setDirty) || void 0 === t3 ? void 0 : t3.call(e2);
      });
      return this.attachCSS3DObject(i2, e2), i2;
    }
    attachCSS3DObject(e2, t2) {
      var r2, i2, s2, o2, a2;
      if (this._trackers.push({ cssObj: e2, modelObj: t2.modelObject, dirty: true }), e2.element && (this._resizeObserver.observe(e2.element), e2.element.__isCSS3DObjectElement = true, console.log(e2.element, e2.element.__isCSS3DObjectElement)), t2.userData.__oldMaterial = t2.material, !t2.setMaterial)
        throw "model not processed?";
      const l2 = null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.createMaterial("basic", { opacity: 0, color: new n.Ilk("black"), blending: n.jFi, side: n.Wl3 });
      if (!l2)
        throw "cannot create mat";
      l2.userData.forcedLinearDepth = 0, null === (i2 = t2.setMaterial) || void 0 === i2 || i2.call(t2, l2), WE(t2.modelObject), qE(t2.modelObject), XE(t2.modelObject), this._scene.add(e2), null === (o2 = null === (s2 = this.uiConfig) || void 0 === s2 ? void 0 : s2.uiRefresh) || void 0 === o2 || o2.call(s2), null === (a2 = t2.setDirty) || void 0 === a2 || a2.call(t2);
    }
    _syncProperties(e2) {
      const t2 = e2.modelObj, r2 = e2.cssObj;
      t2.updateMatrixWorld();
      const i2 = e2.cssObj.element.clientWidth < 1.5 ? 0 : (e2.cssObj.element.clientWidth - 1.5) / XE(t2).x, s2 = WE(t2);
      r2.quaternion.setFromUnitVectors(new n.Pa4(0, 0, 1), s2), r2.position.copy(qE(t2)), r2.scale.set(1, 1, 1).multiplyScalar(1 / i2), r2.updateMatrixWorld(), r2.applyMatrix4(t2.matrixWorld), e2.dirty = false;
    }
    async onDispose(e2) {
      return this._resizeObserver.disconnect(), super.onDispose(e2);
    }
  };
  function QE(e2, t2, n2, r2) {
    const i2 = document.createElement("div");
    i2.style.width = t2.toString() + "px", i2.style.height = n2.toString() + "px", i2.style.backgroundColor = "transparent";
    const s2 = document.createElement("iframe", { is: "x-frame-bypass" });
    s2.style.width = "100%", s2.style.height = "100%", s2.style.border = "0px";
    const o2 = () => {
      var e3, t3;
      try {
        s2.contentWindow.name;
      } catch (n3) {
        ("string" == typeof n3 ? n3 : null !== (t3 = null === (e3 = null == n3 ? void 0 : n3.toString) || void 0 === e3 ? void 0 : e3.call(n3)) && void 0 !== t3 ? t3 : "").includes("cross-origin") ? console.warn("Trying to load cross-origin scripts, Install chrome extension if not able to load: https://chrome.google.com/webstore/detail/ignore-x-frame-headers/gleekbfjekiniecknbkamfmkohkpodhe") : console.error(n3);
      }
      r2(), s2.removeEventListener("load", o2);
    };
    return s2.addEventListener("load", o2), s2.src = e2, i2.appendChild(s2), new FE(i2);
  }
  function WE(e2) {
    if (e2.geometry.userData.geometryNormal)
      return e2.geometry.userData.geometryNormal;
    const t2 = e2.geometry.attributes.normal, r2 = new n.Pa4(), i2 = new n.Pa4();
    for (let e3 = 0, n2 = t2.count; e3 < n2; e3++)
      r2.fromBufferAttribute(t2, e3), i2.add(r2);
    return i2.normalize(), e2.geometry.userData.geometryNormal = i2, i2;
  }
  function qE(e2) {
    if (e2.geometry.userData.geometryCenter)
      return e2.geometry.userData.geometryCenter;
    const t2 = e2.geometry;
    if (!t2)
      return new n.Pa4(0, 0, 0);
    t2.boundingBox || t2.computeBoundingBox();
    const r2 = t2.boundingBox.getCenter(new n.Pa4());
    return e2.geometry.userData.geometryCenter = r2, r2;
  }
  function XE(e2, t2 = new n.Pa4(0, 0, 1)) {
    if (e2.geometry.userData.geometrySize)
      return e2.geometry.userData.geometrySize;
    const r2 = e2.geometry;
    if (!r2)
      return new n.Pa4(0, 0, 0);
    const i2 = r2.clone();
    i2.applyMatrix4(new n.yGw().makeRotationFromQuaternion(new n._fP().setFromUnitVectors(t2, WE(e2)).invert())), i2.computeBoundingBox();
    const s2 = i2.boundingBox.getSize(new n.Pa4());
    return e2.geometry.userData.geometrySize = s2, i2.dispose(), s2;
  }
  HE.PluginType = "CSS3DRenderer", VE([Oe("Enabled"), (0, t.onChange)(GE.prototype._refreshEnabled), ie()], HE.prototype, "enabled", void 0), VE([Oe("Over canvas"), (0, t.onChange)(GE.prototype._refreshCanvasInDOM), ie()], HE.prototype, "overCanvas", void 0), VE([je("Attach iframe")], HE.prototype, "attachIFrameToSelected", void 0), HE = GE = VE([We("CSS3D Renderer")], HE);
  class YE extends ht {
    constructor(e2, t2, r2, i2 = new n.Ilk(1, 1, 1), s2 = 1) {
      super(void 0, void 0, r2, i2, s2), this._getSelectedObjectOrMaterial = e2, this.target = t2;
    }
    render(e2, t2, r2, i2, s2) {
      const o2 = e2.getRenderTarget(), a2 = e2.getActiveCubeFace(), l2 = e2.getActiveMipmapLevel(), c2 = this._getSelectedObjectOrMaterial();
      if (c2)
        this._renderSelectedObject(e2, c2, t2, i2, s2);
      else {
        e2.setRenderTarget(this.target);
        const t3 = new n.Ilk();
        e2.getClearColor(t3), e2.setClearColor(new n.Ilk(16777215)), e2.clear(true, true), e2.setClearColor(t3);
      }
      e2.setRenderTarget(o2, a2, l2);
    }
    _renderSelectedObject(e2, t2, n2, r2, i2) {
      if (!this.camera)
        return;
      const s2 = (Array.isArray(t2) ? t2 : [t2]).map((e3) => e3.isMaterial ? [...e3.userData.__appliedMeshes.values()] : e3).flat();
      s2.forEach((e3) => e3.traverse((e4) => {
        e4.layers.enable(6);
      }));
      const o2 = this.camera.layers.mask;
      this.camera.layers.set(6);
      const a2 = e2.userData;
      a2 || console.error("threejs is not patched?"), a2.transmissionRenderTarget = n2, H(e2, { shadowMapRender: false, backgroundRender: false, opaqueRender: true, transparentRender: true, transmissionRender: true, mainRenderPass: false }, () => super.render(e2, n2, this.target, r2, i2)), a2.transmissionRenderTarget = void 0, s2.forEach((e3) => e3.traverse((e4) => {
        e4.layers.disable(6);
      })), this.camera.layers.mask = o2;
    }
  }
  var KE, JE = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let ZE = KE = class {
    constructor(e2, r2) {
      this.enabled = true, this.enableHighlight = false, this.enableDynamicSelection = true, this.outlineIntensity = 2, this.highlightTransparency = 0.84, this.outlineColor = new n.Ilk(15305317), this.debugOutline = false, this.highlightSelectedMaterials = false, this.highlightMaterialSameNames = false, this.transparency = 0, this._outlineThickness = 2, this.extraUniforms = { outlineIntensity: { value: 1 }, tDiffuseSize: { value: new n.FM8(1, 1) }, outlineThickness: { value: 2 }, highlightTransparency: { value: 1 }, outlineColor: { value: new n.Ilk(15305317) }, enableHighlight: { value: true }, outlineBuffer: { value: null }, dpr: { value: 1 } }, this.extraDefines = { DEBUG_OUTLINE: "0" }, this.parsFragmentSnippet = (e3, n2) => this.enabled ? t.glsl`
            ${_t}
            ${"uniform sampler2D outlineBuffer;uniform vec2 tDiffuseSize;uniform vec3 outlineColor;uniform float outlineThickness;uniform float outlineIntensity;uniform float highlightTransparency;uniform bool enableHighlight;uniform float dpr;float isSelected(vec2 uv){return 1.-texture2D(outlineBuffer,uv).b;}vec4 outline(in vec4 color){vec2 invSize=1./tDiffuseSize;\n#if DEBUG_OUTLINE > 0\ncolor=vec4(0.,0.,0.,1.);\n#endif\nvec3 finalColor=color.rgb;float c=isSelected(vUv);if(c>0.){vec4 uvOffset=1.5*dpr*outlineThickness*vec4(1.,0.,-1.,1.)*vec4(invSize,invSize);float c1=isSelected(vUv+uvOffset.xy);float c2=isSelected(vUv-uvOffset.xy);float c3=isSelected(vUv+uvOffset.yw);float c4=isSelected(vUv-uvOffset.yw);float diff1=(c1-c2)*0.5;float diff2=(c3-c4)*0.5;float d=length(vec2(diff1,diff2));vec4 highlightColor=enableHighlight?vec4(c*outlineColor,(1.-highlightTransparency)*c):vec4(0.);vec4 edgeColor=vec4(outlineColor,1.)*vec4(d);float gbufferDepth=getDepth(vUv);float outlineDepth=unpack16(texture2D(outlineBuffer,vUv).xy);outlineDepth*=outlineDepth;outlineDepth-=0.005;if(gbufferDepth<outlineDepth){highlightColor.rgb=highlightColor.rgb*0.3;edgeColor.rgb=edgeColor.rgb*0.5;}vec4 outColor=edgeColor+highlightColor*(1.-d);finalColor=mix(color.rgb,outlineIntensity*outColor.rgb,outColor.a);}else{finalColor.rgb=color.rgb;}return vec4(finalColor.rgb,color.a);}"}
        ` : "", this._combinedPostPlugin = e2.getPlugin(Qs), this._pickingPlugin = e2.getPluginByType("Picking"), this._setDirty = this._setDirty.bind(this), r2 && (this.extraUniforms.outlineBuffer.value = r2.texture), this._enable();
    }
    shaderExtender(e2, t2, n2) {
      this.enabled && (e2.fragmentShader = ot(e2.fragmentShader, "#glMarker", " \n            gl_FragColor = outline(gl_FragColor);\n            #glMarker\n        "));
    }
    getUiConfig() {
      return this.uiConfig;
    }
    computeCacheKey(e2) {
      return this.enabled ? "1" : "0";
    }
    isCompatible(e2) {
      return true;
    }
    _setDirty() {
      this._combinedPostPlugin && this._combinedPostPlugin.reRender(), this.extraDefines && (this.extraDefines.DEBUG_OUTLINE = this.debugOutline ? "1" : "0"), this.extraUniforms && (this.extraUniforms.outlineIntensity.value = this.outlineIntensity, this.extraUniforms.outlineColor.value.copy(this.outlineColor), this.extraUniforms.outlineThickness.value = this._outlineThickness, this.extraUniforms.enableHighlight.value = this.enableHighlight, this.extraUniforms.highlightTransparency.value = this.transparency);
    }
    setDirty() {
      var e2;
      null === (e2 = this.__setDirty) || void 0 === e2 || e2.call(this), this._setDirty();
    }
    _enable() {
      var e2;
      null === (e2 = this._pickingPlugin) || void 0 === e2 || e2.enableWidget(!this.enabled), this._setDirty();
    }
  };
  ZE.PluginType = "Outline", JE([(0, t.onChange)(KE.prototype._enable), Oe("Enable"), ie()], ZE.prototype, "enabled", void 0), JE([(0, t.onChange)(KE.prototype._setDirty), Oe("Highlight"), ie()], ZE.prototype, "enableHighlight", void 0), JE([(0, t.onChange)(KE.prototype._setDirty), Oe("DynamicSelection"), ie()], ZE.prototype, "enableDynamicSelection", void 0), JE([(0, t.onChange)(KE.prototype._setDirty), Ue("Intensity", [0, 2], 1e-3, { limitedUi: true }), ie()], ZE.prototype, "outlineIntensity", void 0), JE([(0, t.onChange)(KE.prototype._setDirty), Ue("Transparency", [0, 1], 0.01, { limitedUi: true }), ie()], ZE.prototype, "highlightTransparency", void 0), JE([(0, t.onChange)(KE.prototype._setDirty), Ge("Color"), ie()], ZE.prototype, "outlineColor", void 0), JE([(0, t.onChange)(KE.prototype._setDirty), Oe("Debug")], ZE.prototype, "debugOutline", void 0), JE([(0, t.onChange)(KE.prototype._setDirty), Oe("Highlight Selected Materials")], ZE.prototype, "highlightSelectedMaterials", void 0), JE([(0, t.onChange)(KE.prototype._setDirty), Oe("Highlight Materials (same name)")], ZE.prototype, "highlightMaterialSameNames", void 0), ZE = KE = JE([We("Outline")], ZE);
  class $E extends qs {
    constructor() {
      super(), this._state = "in", this.mouseInOutAnimationEnabled = true;
    }
    generateExtension(e2) {
      return new ZE(e2, this._outlineTarget);
    }
    async onAdded(e2) {
      this._outlineTarget = e2.renderer.createTarget({ sizeMultiplier: 1 }), await super.onAdded(e2);
      const t2 = null == e2 ? void 0 : e2.getPluginByType("Picking");
      t2 || console.error("OutlinePlugin requires PickingPlugin to be added to the viewer"), e2.addEventListener("preRender", () => {
        this._extension.extraUniforms.dpr.value = e2.renderer.displayCanvasScaling;
      });
      const r2 = new n.jyz({ uniforms: { cameraNearFar: { value: new n.FM8(0.1, 100) } }, vertexShader: "#ifdef USE_ALPHAMAP\n#define USE_UV \n#endif\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec3 vViewPosition;void main(){\n#include <skinbase_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition=-mvPosition.xyz;}", fragmentShader: "uniform vec2 cameraNearFar;varying vec3 vViewPosition;vec2 pack16(float value){float sMax=65535.;int v=int(clamp(value,0.,1.)*sMax+0.5);int digit0=v/256;int digit1=v-digit0*256;return vec2(float(digit0)/255.,float(digit1)/255.);}float linstep(float edge0,float edge1,float value){return clamp((value-edge0)/(edge1-edge0),0.,1.);}void main(){float linearZ=linstep(-cameraNearFar.x,-cameraNearFar.y,-vViewPosition.z);vec2 packedZ=pack16(pow(linearZ,0.5));gl_FragColor=vec4(packedZ.x,packedZ.y,0.,0.);}", side: n.ehD }), i2 = vt(e2, { passId: "outline", after: ["gbuffer"], before: ["render"], passObject: new YE(() => {
        var n2, r3;
        if (null === (n2 = this._extension) || void 0 === n2 ? void 0 : n2.highlightSelectedMaterials) {
          const n3 = null === (r3 = null == t2 ? void 0 : t2.getSelectedObject()) || void 0 === r3 ? void 0 : r3.material;
          if (this._extension.highlightMaterialSameNames && n3) {
            const t3 = Array.isArray(n3) ? n3.map((e3) => e3.name) : [n3.name], r4 = /* @__PURE__ */ new Set();
            return t3.forEach((t4) => {
              var n4, i3;
              const s2 = null === (i3 = null === (n4 = e2.assetManager) || void 0 === n4 ? void 0 : n4.materials) || void 0 === i3 ? void 0 : i3.findMaterialsByName(t4);
              null == s2 || s2.forEach((e3) => r4.add(e3));
            }), [...r4];
          }
          return n3;
        }
        return null == t2 ? void 0 : t2.getSelectedObject();
      }, this._outlineTarget, r2), update() {
        e2.scene.renderCamera.updateShaderProperties(this.passObject.overrideMaterial), i2.passObject.scene = e2.scene.modelObject, i2.passObject.camera = e2.scene.renderCamera.cameraObject;
      } });
      e2.renderer.registerPass(i2), null == t2 || t2.addEventListener("selectedObjectChanged", () => {
        !this._animationCallBack && this._extension && ((null == t2 ? void 0 : t2.getSelectedObject()) ? this._extension.enableDynamicSelection ? (this._extension.transparency = 1, this._animationCallBack = this._startTransparencyAnimation(1, this._extension.highlightTransparency, 400)) : this._extension.transparency = this._extension.highlightTransparency : this._extension.transparency = 1);
      }), document.addEventListener("mousemove", (n2) => {
        if (!this._extension)
          return;
        if (!this.mouseInOutAnimationEnabled)
          return;
        const r3 = null == t2 ? void 0 : t2.getSelectedObject();
        r3 && this._extension.enableDynamicSelection ? n2.target !== e2.canvas ? this._animationCallBack || "in" !== this._state || (this._animationCallBack = this._startTransparencyAnimation(this._extension.highlightTransparency, 1, 600), this._state = "out") : this._animationCallBack || "out" !== this._state || (this._animationCallBack = this._startTransparencyAnimation(1, this._extension.highlightTransparency, 600), this._state = "in") : this._extension.transparency = r3 ? this._extension.highlightTransparency : 1;
      });
    }
    async _startTransparencyAnimation(e2, t2, n2) {
      return Lp(this._extension, "transparency", { from: e2, to: t2, duration: n2, onComplete: () => {
        this._animationCallBack = null;
      } });
    }
  }
  $E.PluginType = "Outline";
  const eC = 0.2, tC = Math.PI / 24, nC = new n.FM8(), rC = (e2, t2, n2) => {
    let r2 = t2 > 0 ? n2 > 0 ? 0 : -Math.PI / 2 : n2 > 0 ? Math.PI / 2 : Math.PI;
    for (let i2 = 0; i2 <= 12; ++i2)
      e2.push(t2 + 0.17 * Math.cos(r2), n2 + 0.17 * Math.sin(r2), 0, t2 + eC * Math.cos(r2), n2 + eC * Math.sin(r2), 0), r2 += tC;
  };
  class iC extends n.Kj0 {
    constructor(e2, t2, r2 = false) {
      super(((e3, t3) => {
        const r3 = new n.u9r(), i3 = [], s3 = [], o3 = e3.getSize(new n.Pa4()), a3 = o3.x / 2, l2 = (t3 ? o3.y : o3.z) / 2;
        rC(s3, a3, l2), rC(s3, -a3, l2), rC(s3, -a3, -l2), rC(s3, a3, -l2);
        const c2 = s3.length / 3;
        for (let e4 = 0; e4 < c2 - 2; e4 += 2)
          i3.push(e4, e4 + 1, e4 + 3, e4, e4 + 3, e4 + 2);
        const u2 = c2 - 2;
        return i3.push(u2, u2 + 1, 1, u2, 1, 0), r3.setAttribute("position", new n.a$l(s3, 3)), r3.setIndex(i3), r3;
      })(e2, r2)), this.boundingSize = new n.Pa4(), this._raycaster = new n.iMs(), this._camera = t2, this._placeOnWall = r2;
      const i2 = this.material;
      i2.side = n.Wl3, i2.color = new n.Ilk(16711935), i2.opacity = 0, this.userData.bboxVisible = false;
      const s2 = e2.getSize(this.boundingSize), o2 = s2.x / 2, a2 = (r2 ? s2.y : s2.z) / 2;
      this.hitPlane = new n.Kj0(new n._12(2 * (o2 + eC), 2 * (a2 + eC))), this.hitPlane.visible = false, this.add(this.hitPlane), e2.getCenter(this.position), r2 ? (this.shadowHeight = e2.min.z, this.position.z = this.shadowHeight) : (this.rotateX(-Math.PI / 2), this.shadowHeight = e2.min.y, this.position.y = this.shadowHeight), this.offsetHeight = 0;
    }
    getHit(e2, t2, n2) {
      nC.set(t2, -n2), this.hitPlane.visible = true;
      const r2 = this._positionAndNormalFromPoint(nC, this.hitPlane);
      return this.hitPlane.visible = false, null == r2 ? null : r2.position;
    }
    getExpandedHit(e2, t2, n2) {
      this.hitPlane.scale.set(1e3, 1e3, 1e3);
      const r2 = this.getHit(e2, t2, n2);
      return this.hitPlane.scale.set(1, 1, 1), r2;
    }
    set offsetHeight(e2) {
      e2 -= 1e-3, this._placeOnWall ? this.position.z = this.shadowHeight + e2 : this.position.y = this.shadowHeight + e2;
    }
    get offsetHeight() {
      return this._placeOnWall ? this.position.z - this.shadowHeight : this.position.y - this.shadowHeight;
    }
    set show(e2) {
      this.material.opacity = e2 ? 0.75 : 0;
    }
    get show() {
      return this.material.opacity > 0.01;
    }
    updateOpacity(e2) {
      const t2 = this.material;
      this.visible = t2.opacity > 0;
    }
    dispose() {
      var e2;
      const { geometry: t2, material: n2 } = this.hitPlane;
      t2.dispose(), n2.dispose(), this.geometry.dispose(), this.material.dispose(), null === (e2 = this.parent) || void 0 === e2 || e2.remove(this);
    }
    _positionAndNormalFromPoint(e2, t2) {
      if (!this._camera)
        return null;
      this._raycaster.setFromCamera(e2, this._camera);
      const r2 = this._raycaster.intersectObject(t2, true);
      if (0 === r2.length)
        return null;
      const i2 = r2[0];
      return null == i2.face ? null : null == i2.uv ? { position: i2.point, normal: i2.face.normal, uv: null } : (i2.face.normal.applyNormalMatrix(new n.Vkp().getNormalMatrix(i2.object.matrixWorld)), { position: i2.point, normal: i2.face.normal, uv: i2.uv });
    }
  }
  const sC = new n.Pa4();
  class oC {
    constructor() {
      this.inputSource = null, this.isTranslating = false, this.isRotating = false, this.isTwoFingering = false, this.lastDragPosition = new n.Pa4(), this.firstRatio = 0, this.lastAngle = 0, this.goalPosition = new n.Pa4(), this.goalYaw = 0, this.goalScale = 1, this.presentedScene = null, this.placementBox = null, this.placeOnWall = false, this.placementComplete = false, this.xr = null, this.session = null, this._hitPosition = new n.Pa4(), this._hitMatrix = new n.yGw(), this.xDamper = new t.Damper(), this.yDamper = new t.Damper(), this.zDamper = new t.Damper(), this.yawDamper = new t.Damper(), this.scaleDamper = new t.Damper(), this.onSelectStart = (e2) => {
        const t2 = this.transientHitTestSource;
        if (null == t2)
          return;
        const n2 = this.frame.getHitTestResultsForTransientInput(t2), r2 = this.presentedScene, i2 = this.placementBox;
        if (1 === n2.length) {
          this.inputSource = e2.inputSource;
          const { axes: t3 } = this.inputSource.gamepad || { axes: [0, 0] }, n3 = i2.getHit(r2, t3[0], t3[1]);
          i2.show = true, null != n3 ? (this.isTranslating = true, this.lastDragPosition.copy(n3), this.presentedScene && (this.presentedScene.visible = true)) : this.placeOnWall || (this.isRotating = true, this.lastAngle = 1.5 * t3[0]);
        } else if (2 === n2.length) {
          i2.show = true, this.isTwoFingering = true;
          const { separation: e3 } = this.fingerPolar(n2);
          this.firstRatio = e3 / r2.scale.x;
        }
      }, this.onSelectEnd = () => {
        this.isTranslating = false, this.isRotating = false, this.isTwoFingering = false, this.inputSource = null, this.goalPosition.y += this.placementBox.offsetHeight * this.presentedScene.scale.x, this.placementBox.show = false;
      };
    }
    async setSession(e2, t2, n2) {
      var r2;
      this.transientHitTestSource = await (null === (r2 = e2.requestHitTestSourceForTransientInput) || void 0 === r2 ? void 0 : r2.call(e2, { profile: "generic-touchscreen" })), this.presentedScene = t2, this.placementBox = n2, this.session = e2, this.placementComplete = false, this.goalPosition.copy(t2.position), this.goalYaw = t2.rotation.y, this.goalScale = t2.scale.x, e2.addEventListener("selectstart", this.onSelectStart), e2.addEventListener("selectend", this.onSelectEnd);
    }
    cancel() {
      this.transientHitTestSource && (this.transientHitTestSource.cancel(), this.transientHitTestSource = void 0), this.presentedScene = null, this.placeOnWall = false, this.frame = void 0, this.xr = null, this.placementBox && (this.placementBox.show = false, this.placementBox = null), this.session && (this.session.removeEventListener("selectstart", this.onSelectStart), this.session.removeEventListener("selectend", this.onSelectEnd), this.session = null);
    }
    getHitPoint(e2) {
      var t2;
      const n2 = null === (t2 = this.xr) || void 0 === t2 ? void 0 : t2.getReferenceSpace(), r2 = n2 ? e2.getPose(n2) : null;
      return r2 ? (this._hitMatrix.fromArray(r2.transform.matrix), this.placeOnWall && (this.goalYaw = Math.atan2(this._hitMatrix.elements[4], this._hitMatrix.elements[6])), this._hitMatrix.elements[5] > 0.75 !== this.placeOnWall ? this._hitPosition.setFromMatrixPosition(this._hitMatrix) : null) : null;
    }
    moveScene(e2) {
      if (!this.session)
        return;
      const t2 = this.presentedScene, n2 = t2.position, r2 = t2.rotation.y, i2 = this.placementBox, s2 = Math.max(i2.boundingSize.x, i2.boundingSize.y, i2.boundingSize.z) / 2, o2 = this.goalPosition, a2 = t2.scale.x;
      if (!o2.equals(n2) || this.goalScale !== a2) {
        let { x: r3, y: l2, z: c2 } = n2;
        r3 = this.xDamper.update(r3, o2.x, e2, s2), l2 = this.yDamper.update(l2, o2.y, e2, s2), c2 = this.zDamper.update(c2, o2.z, e2, s2), n2.set(r3, l2, c2);
        const u2 = this.scaleDamper.update(a2, this.goalScale, e2, 1);
        if (t2.scale.set(u2, u2, u2), !this.isTranslating) {
          const e3 = o2.y - l2;
          this.placementComplete && !this.placeOnWall ? i2.offsetHeight = e3 / u2 : 0 === e3 && (this.placementComplete = true, i2.show = false);
        }
      }
      i2.updateOpacity(e2), t2.rotation.y = this.yawDamper.update(r2, this.goalYaw, e2, Math.PI);
    }
    processInput(e2) {
      var t2;
      this.frame = e2;
      const n2 = this.transientHitTestSource;
      if (!n2)
        return;
      if (!this.isTranslating && !this.isTwoFingering && !this.isRotating)
        return;
      const r2 = e2.getHitTestResultsForTransientInput(n2), i2 = this.presentedScene, s2 = i2.scale.x;
      if (this.isTwoFingering)
        if (r2.length < 2)
          this.isTwoFingering = false;
        else {
          const { separation: e3, deltaYaw: t3 } = this.fingerPolar(r2);
          if (this.placeOnWall || (this.goalYaw += t3), !i2.userData.__scaleDisabled) {
            const t4 = e3 / this.firstRatio;
            this.goalScale = t4 < 1.3 && t4 > 0.7692307692307692 ? 1 : t4;
          }
        }
      else if (2 !== r2.length)
        if (this.isRotating && (null === (t2 = this.inputSource) || void 0 === t2 ? void 0 : t2.gamepad)) {
          const e3 = 1.5 * this.inputSource.gamepad.axes[0];
          this.goalYaw += e3 - this.lastAngle, this.lastAngle = e3;
        } else
          this.isTranslating && (console.log("translating"), r2.forEach((e3) => {
            if (e3.inputSource !== this.inputSource)
              return;
            let t3 = null;
            if (e3.results.length > 0 && (t3 = this.getHitPoint(e3.results[0])), null == t3 && (t3 = this.getTouchLocation()), null != t3) {
              if (this.goalPosition.sub(this.lastDragPosition), !this.placeOnWall) {
                const e4 = t3.y - this.lastDragPosition.y;
                if (e4 < 0) {
                  this.placementBox.offsetHeight = e4 / s2;
                  const n3 = sC.copy(this.xr.getCamera().position), r3 = -e4 / (n3.y - t3.y);
                  n3.multiplyScalar(r3), t3.multiplyScalar(1 - r3).add(n3);
                }
              }
              this.goalPosition.add(t3), this.lastDragPosition.copy(t3);
            }
          }));
      else {
        this.isTranslating = false, this.isRotating = false, this.isTwoFingering = true;
        const { separation: e3 } = this.fingerPolar(r2);
        this.firstRatio = e3 / s2;
      }
    }
    getTouchLocation() {
      var e2, t2;
      const { axes: n2 } = null !== (e2 = this.inputSource.gamepad) && void 0 !== e2 ? e2 : { axes: [0, 0] }, r2 = this.placementBox.getExpandedHit(this.presentedScene, n2[0], n2[1]);
      return null != r2 && (sC.copy(r2).sub(null === (t2 = this.xr) || void 0 === t2 ? void 0 : t2.getCamera().position), sC.length() > 10) ? null : r2;
    }
    fingerPolar(e2) {
      var t2, n2, r2, i2, s2, o2;
      const a2 = null !== (r2 = null === (n2 = null === (t2 = e2[0].inputSource) || void 0 === t2 ? void 0 : t2.gamepad) || void 0 === n2 ? void 0 : n2.axes) && void 0 !== r2 ? r2 : [0, 0], l2 = null !== (o2 = null === (s2 = null === (i2 = e2[1].inputSource) || void 0 === i2 ? void 0 : i2.gamepad) || void 0 === s2 ? void 0 : s2.axes) && void 0 !== o2 ? o2 : [0, 0], c2 = l2[0] - a2[0], u2 = l2[1] - a2[1], p2 = Math.atan2(u2, c2);
      let d2 = this.lastAngle - p2;
      return d2 > Math.PI ? d2 -= 2 * Math.PI : d2 < -Math.PI && (d2 += 2 * Math.PI), this.lastAngle = p2, { separation: Math.sqrt(c2 * c2 + u2 * u2), deltaYaw: d2 };
    }
  }
  class aC {
    constructor(e2, t2, r2, i2, s2) {
      this.xrLight = e2, this.renderer = t2, this.lightProbe = r2, this.xrWebGLBinding = null, this.estimationStartCallback = s2, this.frameCallback = this.onXRFrame.bind(this);
      const o2 = t2.xr.getSession();
      if (i2 && "XRWebGLBinding" in window) {
        const r3 = new n.oAp(16);
        e2.environment = r3.texture;
        const i3 = t2.getContext();
        switch (o2.preferredReflectionFormat) {
          case "srgba8":
            i3.getExtension("EXT_sRGB");
            break;
          case "rgba16f":
            i3.getExtension("OES_texture_half_float");
        }
        this.xrWebGLBinding = new XRWebGLBinding(o2, i3), this.lightProbe.addEventListener("reflectionchange", () => {
          this.updateReflection();
        });
      }
      o2.requestAnimationFrame(this.frameCallback);
    }
    updateReflection() {
      const e2 = this.renderer.properties.get(this.xrLight.environment);
      if (e2) {
        const t2 = this.xrWebGLBinding.getReflectionCubeMap(this.lightProbe);
        t2 && (e2.__webglTexture = t2, this.xrLight.environment.needsPMREMUpdate = true);
      }
    }
    onXRFrame(e2, t2) {
      if (!this.xrLight)
        return;
      t2.session.requestAnimationFrame(this.frameCallback);
      const n2 = t2.getLightEstimate(this.lightProbe);
      if (n2) {
        this.xrLight.lightProbe.sh.fromArray(n2.sphericalHarmonicsCoefficients), this.xrLight.lightProbe.intensity = 1;
        const e3 = Math.max(1, Math.max(n2.primaryLightIntensity.x, Math.max(n2.primaryLightIntensity.y, n2.primaryLightIntensity.z)));
        this.xrLight.directionalLight.color.setRGB(n2.primaryLightIntensity.x / e3, n2.primaryLightIntensity.y / e3, n2.primaryLightIntensity.z / e3), this.xrLight.directionalLight.intensity = e3, this.xrLight.directionalLight.position.copy(n2.primaryLightDirection), this.estimationStartCallback && (this.estimationStartCallback(), this.estimationStartCallback = null);
      }
    }
    dispose() {
      this.xrLight = null, this.renderer = null, this.lightProbe = null, this.xrWebGLBinding = null;
    }
  }
  class lC extends n.ZAu {
    constructor(e2, t2 = true) {
      super(), this.lightProbe = new n.lk7(), this.lightProbe.intensity = 0, this.add(this.lightProbe), this.directionalLight = new n.Ox3(), this.directionalLight.intensity = 0, this.add(this.directionalLight), this.environment = null;
      let r2 = null, i2 = false;
      e2.xr.addEventListener("sessionstart", () => {
        const n2 = e2.xr.getSession();
        "requestLightProbe" in n2 && n2.requestLightProbe({ reflectionFormat: n2.preferredReflectionFormat }).then((n3) => {
          r2 = new aC(this, e2, n3, t2, () => {
            i2 = true, this.dispatchEvent({ type: "estimationstart" });
          });
        });
      }), e2.xr.addEventListener("sessionend", () => {
        r2 && (r2.dispose(), r2 = null), i2 && this.dispatchEvent({ type: "estimationend" });
      }), this.dispose = () => {
        r2 && (r2.dispose(), r2 = null), this.remove(this.lightProbe), this.lightProbe = null, this.remove(this.directionalLight), this.directionalLight = null, this.environment = null;
      };
    }
  }
  var cC, uC = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let pC = cC = class extends gt {
    constructor() {
      super(...arguments), this.enabled = true, this._touchInputHelper = new oC(), this.dependencies = [wt], this.estimateLighting = false, this.placeOnWall = false, this.xrResolutionScale = 1, this.toJSON = void 0, this.enterAR = () => {
        var e2;
        this.enabled && this._viewer && (navigator && navigator.xr ? this._xrSession ? console.warn("Already in AR") : this._xrManager ? (this._xrManager.enabled = true, null === (e2 = this._xrManager) || void 0 === e2 || e2.setFramebufferScaleFactor(this.xrResolutionScale), navigator.xr.requestSession("immersive-ar", { requiredFeatures: ["hit-test"], optionalFeatures: ["dom-overlay", "light-estimation"], domOverlay: this.domOverlay }).then(this._onSessionStarted)) : console.error("XR manager not found") : console.error("XR not supported"));
      }, this.exitAR = () => {
        this._xrSession && this._xrSession.end();
      }, this._preRender = () => {
        var e2;
        if (!(this._dirty && this._viewer && this._xrManager && this._xrSession))
          return;
        this._viewer.renderer.defaultRenderToScreen = false, this._xrManager.enabled = false;
        const t2 = this._xrManager.getCamera(), n2 = (null === (e2 = t2.cameras) || void 0 === e2 ? void 0 : e2[0]) || t2, r2 = this._viewer.scene.activeCamera;
        r2.cameraObject.projectionMatrix.copy(n2.projectionMatrix), r2.cameraObject.projectionMatrixInverse.copy(r2.cameraObject.projectionMatrix).invert();
      }, this._postRender = () => {
        var e2, t2;
        if (!this._dirty || !this._viewer || !this._xrSession)
          return;
        this._viewer.scene.activeCamera.cameraObject.updateProjectionMatrix();
        const n2 = this._viewer.renderer, r2 = null === (t2 = null === (e2 = this._xrManager) || void 0 === e2 ? void 0 : e2.getCamera()) || void 0 === t2 ? void 0 : t2.cameras[0].viewport;
        r2 ? n2.rendererObject.setViewport(r2) : console.warn("no viewport for ar camera"), this._viewer.getPlugin(wt).updateShaderProperties(dC.material), dC.uniforms.tTransparentMap.value = this._viewer.renderFilter.passObject.transparentTarget.texture, H(n2.rendererObject, { sceneRender: true, opaqueRender: true, shadowMapRender: false, backgroundRender: false, transparentRender: false, transmissionRender: false, screenSpaceRendering: false }, () => {
          dC.render(n2.rendererObject, null, n2.composer.readBuffer, 0, false);
        }), this._xrManager.enabled = true, this._viewer.renderer.defaultRenderToScreen = true;
      }, this._frameCount = 0, this._isPresenting = false, this._interactionsDisabled = false, this._preFrame = ({ xrFrame: e2, deltaTime: t2 }) => {
        var n2, r2;
        if (this.dirty = !!e2 && (null === (n2 = this._xrManager) || void 0 === n2 ? void 0 : n2.isPresenting) || false, (this._dirty || this._interactionsDisabled) && (this._viewer.scene.activeCamera.setInteractions(!this._dirty, cC.PluginType), this._viewer.scene.activeCamera.autoLookAtTarget = !this._dirty, this._interactionsDisabled = this._dirty), !this._dirty || !e2)
          return void (this._isPresenting && this._xrRenderingEnd());
        if (!this._xrSession)
          return console.error("no xr session found, shouldn't happen"), void (this.dirty = false);
        this._isPresenting || console.log("webxr: AR session init"), this._frameCount++;
        const i2 = this._xrManager.getReferenceSpace(), s2 = e2.getViewerPose(i2);
        if (null == s2 && this._frameCount, null == s2 || 0 === (null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.scene.modelRoot.children.length))
          return this.dirty = false, void console.warn("no pose or no model");
        this._isPresenting || (this._isPresenting = true, this._frameCount = 0, this._savePreXRState(), this._preSetupModel(), this._xrRenderingBegin());
        const o2 = this._viewer.scene.activeCamera;
        this._xrManager.updateCamera(o2.cameraObject), o2.setDirty(), this.moveToFloor(e2), this._touchInputHelper.processInput(e2), this._touchInputHelper.moveScene(t2), this._updateShadow();
      }, this._preXRState = { viewerBg: null, viewerBgColor: void 0, modelScale: new n.Pa4(1, 1, 1), modelPosition: new n.Pa4(), modelRotation: new n._fP(), cameraPosition: new n.Pa4(0, 0, 5), cameraTarget: new n.Pa4(), cameraUp: new n.Pa4(0, 1, 0), cameraAspect: 1, cameraFov: 50, cameraZoom: 1, cameraNear: 0.01, cameraFar: 100, cameraProjectionMatrix: new n.yGw(), cameraAutoNearFar: void 0, groundOffset: new n.Pa4(), groundScale: 1, groundRotation: 0, groundRenderToDepth: false, groundShadowBaker: false, viewport: new n.FM8(), environment: void 0, preserveTransparentTarget: true }, this._savePreXRState = () => {
        var e2;
        if (!this._viewer)
          return;
        this._preXRState.viewport.copy(this._viewer.renderer.renderSize), this._preXRState.viewerBg = this._viewer.scene.background, this._preXRState.viewerBgColor = null === (e2 = this._viewer.scene.backgroundColor) || void 0 === e2 ? void 0 : e2.getHex();
        const t2 = this._viewer.scene.modelRoot, n2 = this._viewer.scene.activeCamera;
        t2.updateMatrix(), t2.updateMatrixWorld(true), this._preXRState.modelScale.copy(t2.scale), this._preXRState.modelPosition.copy(t2.position), this._preXRState.modelRotation.copy(t2.quaternion), this._preXRState.cameraPosition.copy(n2.position), this._preXRState.cameraTarget.copy(n2.target), this._preXRState.cameraUp.copy(n2.cameraObject.up), n2.cameraObject.isPerspectiveCamera && (this._preXRState.cameraFov = n2.cameraObject.fov, this._preXRState.cameraAspect = n2.cameraObject.aspect), this._preXRState.cameraZoom = n2.cameraObject.zoom, this._preXRState.cameraNear = n2.cameraObject.near, this._preXRState.cameraFar = n2.cameraObject.far, this._preXRState.cameraAutoNearFar = n2.cameraObject.userData.autoNearFar, this._preXRState.cameraProjectionMatrix.copy(n2.cameraObject.projectionMatrix);
        const r2 = this._viewer.getPluginByType("Ground");
        (null == r2 ? void 0 : r2.mesh) && (this._preXRState.groundOffset.subVectors(t2.position, r2.mesh.modelObject.position), this._preXRState.groundScale = r2.mesh.modelObject.scale.x, this._preXRState.groundRotation = r2.mesh.modelObject.rotation.z, this._preXRState.groundRenderToDepth = r2.renderToDepth, this._preXRState.groundShadowBaker = r2.shadowBaker.enabled), this._preXRState.environment || (this._preXRState.environment = this._viewer.scene.getEnvironment()), this._preXRState.preserveTransparentTarget = this._viewer.renderFilter.passObject.preserveTransparentTarget;
      }, this._xrRenderingBegin = () => {
        if (!this._xrSession || !this._viewer)
          return;
        console.log("webxr: AR session start");
        const e2 = 20 * Math.PI / 180, t2 = this.placeOnWall ? void 0 : new window.XRRay(new DOMPoint(0, 0, 0), { x: 0, y: -Math.sin(e2), z: -Math.cos(e2) });
        this._viewer.renderer.useTotalFrameCount = true, this._viewer.resize(), (async () => {
          var e3, n2;
          if (this._xrSession) {
            this._touchInputHelper.placeOnWall = this.placeOnWall, await this._touchInputHelper.setSession(this._xrSession, this._viewer.scene.modelRoot, this._placementBox);
            const r2 = await this._xrSession.requestReferenceSpace("viewer");
            this._hitTestSource = await (null === (n2 = (e3 = this._xrSession).requestHitTestSource) || void 0 === n2 ? void 0 : n2.call(e3, { space: r2, offsetRay: t2 }));
          }
        })();
      }, this._xrRenderingEnd = () => {
        console.log("webxr: AR session end"), this._xrManager && (this._xrManager.enabled = false), this._isPresenting = false, this._frameCount = 0, this._xrSession = void 0, this._removePlacementBox(), this._cancelHitSources(), this._viewer && (this._viewer.renderer.stableNoise = false), this._restorePreXRState();
      }, this._onSessionStarted = async (e2) => {
        e2.addEventListener("end", this._onSessionEnded), this.estimateLighting && (this._xrLight = new lC(this._viewer.renderer.rendererObject), this._xrLight.addEventListener("estimationstart", () => {
          this._xrSession && this._xrLight && (this._viewer.scene.modelRoot.add(this._xrLight), this._preXRState.environment || (this._preXRState.environment = this._viewer.scene.getEnvironment()), this._viewer.scene.setEnvironment(this._xrLight.environment));
        })), this._xrManager.setReferenceSpaceType("local"), await this._xrManager.setSession(e2), this._xrSession = e2;
      }, this._onSessionEnded = () => {
        this._xrSession && (this._xrSession.removeEventListener("end", this._onSessionEnded), this._xrLight && (this._xrLight.removeFromParent(), this._xrLight.dispose(), this._xrLight = void 0));
      };
    }
    async onAdded(e2) {
      await super.onAdded(e2);
      const t2 = e2.renderer.rendererObject.xr;
      if (t2.cameraAutoUpdate = false, this._xrManager = t2, this._touchInputHelper.xr = t2, !this.domOverlay) {
        const e3 = document.getElementById("tweakpaneUiContainer");
        this.domOverlay = e3 ? { root: e3 } : void 0;
      }
      if (e2.addEventListener("preRender", this._preRender), e2.addEventListener("postRender", this._postRender), e2.addEventListener("preFrame", this._preFrame), !window.isSecureContext)
        return e2.console.error("XR not supported in insecure context, try https://"), void (this.enabled = false);
      navigator && "xr" in navigator && navigator.xr ? navigator.xr.isSessionSupported("immersive-ar").then((e3) => {
        if (!e3)
          throw new Error("AR not supported");
      }).catch((n2) => {
        e2.console.error("AR not supported:", n2), t2.enabled = false, this.enabled = false;
      }) : (t2.enabled = false, this.enabled = false);
    }
    _updateShadow() {
      var e2, t2;
      if (!this._viewer)
        return;
      const n2 = this._viewer.scene.modelRoot, r2 = null === (t2 = null === (e2 = this._viewer.getPluginByType("Ground")) || void 0 === e2 ? void 0 : e2.mesh) || void 0 === t2 ? void 0 : t2.modelObject;
      r2 && (r2.rotation.z = this._viewer.scene.modelRoot.rotation.y, r2.position.copy(this._preXRState.groundOffset).multiplyScalar(n2.modelObject.scale.x).sub(n2.modelObject.position).negate(), r2.scale.setScalar(n2.modelObject.scale.x * this._preXRState.groundScale));
    }
    moveToFloor(e2) {
      if (!this._dirty || !this._hitTestSource || !this._xrManager)
        return;
      const t2 = e2.getHitTestResults(this._hitTestSource);
      if (!t2.length)
        return;
      const n2 = t2[0];
      this._touchInputHelper.placeOnWall = this.placeOnWall;
      const r2 = this._touchInputHelper.getHitPoint(n2);
      if (!r2)
        return;
      this._placementBox.show = true;
      const i2 = this._viewer.scene.modelRoot;
      this._touchInputHelper.goalPosition.copy(r2), i2.position.copy(r2), this._viewer.scene.modelRoot.visible = true, this._hitTestSource.cancel(), this._hitTestSource = void 0;
    }
    _removePlacementBox() {
      this._placementBox && (this._placementBox.removeFromParent(), this._placementBox = void 0);
    }
    _preSetupModel() {
      var e2, t2;
      const r2 = this._viewer.scene.modelRoot, i2 = this._viewer.scene.activeCamera, s2 = null === (e2 = this._xrManager) || void 0 === e2 ? void 0 : e2.getCamera(), o2 = s2.cameras[0] || s2;
      this._removePlacementBox();
      const a2 = this._viewer.scene.getBounds(true, true);
      a2.getSize(new n.Pa4()).length() > 0.01 && (this._placementBox = new iC(a2, s2, this.placeOnWall), r2.add(this._placementBox), this._placementBox.show = false);
      const l2 = s2.getWorldDirection(new n.Pa4());
      r2.rotation.y = Math.atan2(-l2.x, -l2.z) - 0, i2.cameraObject.zoom = o2.zoom, i2.cameraObject.near = o2.near, i2.cameraObject.far = o2.far, i2.cameraObject.userData.autoNearFar = false, i2.cameraObject.isPerspectiveCamera ? (i2.cameraObject.fov = o2.fov, i2.cameraObject.aspect = o2.viewport.width / o2.viewport.height) : console.warn("Perspective camera required."), i2.cameraObject.updateProjectionMatrix();
      const c2 = r2.userData.arScale || 1;
      r2.scale.set(c2, c2, c2), r2.position.copy(s2.position).add(l2.multiplyScalar(5)), r2.visible = true;
      const u2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPluginByType("Ground");
      (null == u2 ? void 0 : u2.mesh) && (u2.shadowBaker.enabled = false, u2.renderToDepth = false);
    }
    _restorePreXRState() {
      var e2;
      if (!this._viewer)
        return;
      this._viewer.renderer.rendererObject.setSize(this._preXRState.viewport.x, this._preXRState.viewport.y), this._viewer.resize(), this._viewer.scene.activeCamera.setInteractions(true, cC.PluginType), this._viewer.scene.activeCamera.autoLookAtTarget = true, this._viewer.scene.background = this._preXRState.viewerBg, void 0 !== this._preXRState.viewerBgColor && (null === (e2 = this._viewer.scene.backgroundColor) || void 0 === e2 || e2.set(this._preXRState.viewerBgColor)), this._preXRState.viewerBg = null;
      const t2 = this._viewer.scene.modelRoot;
      t2.scale.copy(this._preXRState.modelScale), t2.position.copy(this._preXRState.modelPosition), t2.quaternion.copy(this._preXRState.modelRotation), t2.updateMatrix(), t2.updateMatrixWorld(true), t2.visible = true;
      const n2 = this._viewer.scene.activeCamera;
      n2.position.copy(this._preXRState.cameraPosition), n2.target.copy(this._preXRState.cameraTarget), n2.cameraObject.up.copy(this._preXRState.cameraUp), n2.cameraObject.near = this._preXRState.cameraNear, n2.cameraObject.far = this._preXRState.cameraFar, n2.cameraObject.userData.autoNearFar = this._preXRState.cameraAutoNearFar, n2.cameraObject.isPerspectiveCamera && (void 0 !== this._preXRState.cameraFov && (n2.cameraObject.fov = this._preXRState.cameraFov), void 0 !== this._preXRState.cameraAspect && (n2.cameraObject.aspect = this._preXRState.cameraAspect)), n2.positionUpdated(false), n2.targetUpdated(true), n2.cameraObject.projectionMatrix.copy(this._preXRState.cameraProjectionMatrix), n2.cameraObject.projectionMatrixInverse.copy(this._preXRState.cameraProjectionMatrix).invert(), n2.cameraObject.updateMatrixWorld(true), n2.cameraObject.updateProjectionMatrix();
      const r2 = this._viewer.getPluginByType("Ground");
      (null == r2 ? void 0 : r2.mesh) && (r2.mesh.modelObject.position.subVectors(t2.position, this._preXRState.groundOffset), r2.mesh.modelObject.scale.setScalar(this._preXRState.groundScale), r2.mesh.modelObject.rotation.z = this._preXRState.groundRotation, r2.renderToDepth = this._preXRState.groundRenderToDepth, r2.shadowBaker.enabled = this._preXRState.groundShadowBaker, r2.refreshTransform()), this._viewer.scene.setEnvironment(this._preXRState.environment), this._preXRState.environment = void 0, this._viewer.renderFilter.passObject.preserveTransparentTarget = this._preXRState.preserveTransparentTarget;
    }
    _cancelHitSources() {
      this._hitTestSource && (this._hitTestSource.cancel(), this._hitTestSource = void 0), this._touchInputHelper.cancel();
    }
  };
  pC.PluginType = "WEBXR_ARPlugin", uC([Oe("Light Estimate")], pC.prototype, "estimateLighting", void 0), uC([Oe("Place on Wall")], pC.prototype, "placeOnWall", void 0), uC([Ue("Resilution scale", [0.1, 1], 0.1)], pC.prototype, "xrResolutionScale", void 0), uC([je("Enter AR")], pC.prototype, "enterAR", void 0), uC([je("Exit AR")], pC.prototype, "exitAR", void 0), pC = cC = uC([We("WebXR AR")], pC);
  const dC = new dt({ vertexShader: r.vertexShader, fragmentShader: `
        ${_t}
        
        uniform float opacity;

		uniform sampler2D tDiffuse;
		uniform sampler2D tTransparentMap;

		varying vec2 vUv;

		void main() {
		
            float depth = getDepth(vUv);
            vec4 texel;
            if(depth>0.9999) {
			    texel = texture2D( tTransparentMap, vUv );
                if(texel.a < 0.01) discard; // background
                // transparent objects with render to depth = false
            }else {
                texel = texture2D( tDiffuse, vUv );
			}
            gl_FragColor = texel;
            
		}
		`, uniforms: { ...r.uniforms, tNormalDepth: { value: null }, tTransparentMap: { value: null } } });
  dC.renderToScreen = false, dC.useExistingRenderTarget = true, dC.clear = false;
  var hC, fC = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let mC = hC = class extends gt {
    constructor() {
      super(...arguments), this.enabled = true, this.dependencies = [wt], this.xrResolutionScale = 1, this.toJSON = void 0, this.enterVR = () => {
        var e2;
        this.enabled && this._viewer && (navigator && navigator.xr ? this._xrSession ? console.warn("Already inVR") : this._xrManager ? (this._xrManager.enabled = true, null === (e2 = this._xrManager) || void 0 === e2 || e2.setFramebufferScaleFactor(this.xrResolutionScale), navigator.xr.requestSession("immersive-vr", { optionalFeatures: ["local-floor", "bounded-floor", "hand-tracking", "layers"] }).then(this._onSessionStarted)) : console.error("XR manager not found") : console.error("XR not supported"));
      }, this.exitVR = () => {
        this._xrSession && this._xrSession.end();
      }, this._currentCameraIndex = 0, this._preRender = () => {
        var e2;
        if (!(this._dirty && this._viewer && this._xrManager && this._xrSession))
          return;
        this._viewer.renderer.defaultRenderToScreen = false, this._xrManager.enabled = false;
        const t2 = this._xrManager.getCamera(), n2 = (null === (e2 = t2.cameras) || void 0 === e2 ? void 0 : e2[this._currentCameraIndex]) || t2, r2 = this._viewer.scene.activeCamera;
        r2.cameraObject.zoom = n2.zoom, r2.cameraObject.near = n2.near, r2.cameraObject.far = n2.far, r2.cameraObject.userData.autoNearFar = false, r2.cameraObject.isPerspectiveCamera ? (r2.cameraObject.fov = n2.fov, r2.cameraObject.aspect = n2.viewport.width / n2.viewport.height) : console.warn("Perspective camera required."), r2.cameraObject.position.copy(n2.position), r2.cameraObject.rotation.copy(n2.rotation), r2.cameraObject.updateMatrix(), r2.cameraObject.updateProjectionMatrix(), r2.cameraObject.projectionMatrix.copy(n2.projectionMatrix), r2.cameraObject.projectionMatrixInverse.copy(r2.cameraObject.projectionMatrix).invert();
      }, this._currentRt = null, this._postRender = () => {
        var e2, t2, r2, i2;
        if (!this._dirty || !this._viewer || !this._xrSession)
          return;
        this._viewer.scene.activeCamera.cameraObject.updateProjectionMatrix();
        const s2 = this._viewer.renderer, o2 = (s2.rendererObject.getViewport(new n.Ltg()), null !== (r2 = null === (t2 = null === (e2 = this._xrManager) || void 0 === e2 ? void 0 : e2.getCamera()) || void 0 === t2 ? void 0 : t2.cameras) && void 0 !== r2 ? r2 : []), a2 = s2.rendererObject.getRenderTarget(), l2 = null === (i2 = o2[this._currentCameraIndex]) || void 0 === i2 ? void 0 : i2.viewport;
        l2 ? a2 && s2.rendererObject.setViewport(l2) : console.warn("no viewport for vr camera index", this._currentCameraIndex), this._viewer.getPlugin(wt).updateShaderProperties(_C.material), _C.uniforms.tTransparentMap.value = this._viewer.renderFilter.passObject.transparentTarget.texture, H(s2.rendererObject, { sceneRender: true, opaqueRender: true, shadowMapRender: false, backgroundRender: false, transparentRender: false, transmissionRender: false, screenSpaceRendering: false }, () => {
          _C.render(s2.rendererObject, null, s2.composer.readBuffer, 0, false);
        }), this._xrManager.enabled = true, this._viewer.renderer.defaultRenderToScreen = true, a2 && s2.rendererObject.setViewport(a2.viewport), this._currentCameraIndex++, this._currentCameraIndex >= o2.length && (this._currentCameraIndex = 0);
      }, this._frameCount = 0, this._isPresenting = false, this._interactionsDisabled = false, this._preFrame = ({ xrFrame: e2, deltaTime: t2 }) => {
        var n2, r2;
        if (this.dirty = !!e2 && (null === (n2 = this._xrManager) || void 0 === n2 ? void 0 : n2.isPresenting) || false, (this._dirty || this._interactionsDisabled) && (this._viewer.scene.activeCamera.setInteractions(!this._dirty, hC.PluginType), this._viewer.scene.activeCamera.autoLookAtTarget = !this._dirty, this._interactionsDisabled = this._dirty), !this._dirty || !e2)
          return void (this._isPresenting && this._xrRenderingEnd());
        if (!this._xrSession)
          return console.error("no xr session found, shouldn't happen"), void (this.dirty = false);
        this._isPresenting || console.log("webxr: VR session init"), this._frameCount++;
        const i2 = this._xrManager.getReferenceSpace(), s2 = e2.getViewerPose(i2);
        if (null == s2 && this._frameCount, null == s2 || 0 === (null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.scene.modelRoot.children.length))
          return this.dirty = false, void console.warn("no pose or no model");
        this._isPresenting || (this._isPresenting = true, this._frameCount = 0, this._savePreXRState(), this._preSetupModel(), this._xrRenderingBegin());
        const o2 = this._viewer.scene.activeCamera;
        this._xrManager.updateCamera(o2.cameraObject), o2.setDirty(), this._viewer.rendersPerFrame = s2 ? s2.views.length : 1, this._updateShadow();
      }, this._preXRState = { viewerBg: null, viewerBgColor: void 0, modelScale: new n.Pa4(1, 1, 1), modelPosition: new n.Pa4(), modelRotation: new n._fP(), cameraPosition: new n.Pa4(0, 0, 5), cameraTarget: new n.Pa4(), cameraUp: new n.Pa4(0, 1, 0), cameraAspect: 1, cameraFov: 50, cameraZoom: 1, cameraNear: 0.01, cameraFar: 100, cameraProjectioMatrix: new n.yGw(), cameraAutoNearFar: void 0, groundOffset: new n.Pa4(), groundScale: 1, groundRotation: 0, groundRenderToDepth: false, groundShadowBaker: false, viewport: new n.FM8(), environment: void 0, preserveTransparentTarget: true }, this._savePreXRState = () => {
        var e2;
        if (!this._viewer)
          return;
        this._preXRState.viewport.copy(this._viewer.renderer.renderSize), this._preXRState.viewerBg = this._viewer.scene.background, this._preXRState.viewerBgColor = null === (e2 = this._viewer.scene.backgroundColor) || void 0 === e2 ? void 0 : e2.getHex();
        const t2 = this._viewer.scene.modelRoot, n2 = this._viewer.scene.activeCamera;
        t2.updateMatrix(), t2.updateMatrixWorld(true), this._preXRState.modelScale.copy(t2.scale), this._preXRState.modelPosition.copy(t2.position), this._preXRState.modelRotation.copy(t2.quaternion), this._preXRState.cameraPosition.copy(n2.position), this._preXRState.cameraTarget.copy(n2.target), this._preXRState.cameraUp.copy(n2.cameraObject.up), n2.cameraObject.isPerspectiveCamera && (this._preXRState.cameraFov = n2.cameraObject.fov, this._preXRState.cameraAspect = n2.cameraObject.aspect), this._preXRState.cameraZoom = n2.cameraObject.zoom, this._preXRState.cameraNear = n2.cameraObject.near, this._preXRState.cameraFar = n2.cameraObject.far, this._preXRState.cameraAutoNearFar = n2.cameraObject.userData.autoNearFar, this._preXRState.cameraProjectioMatrix.copy(n2.cameraObject.projectionMatrix);
        const r2 = this._viewer.getPluginByType("Ground");
        (null == r2 ? void 0 : r2.mesh) && (this._preXRState.groundOffset.subVectors(t2.position, r2.mesh.modelObject.position), this._preXRState.groundScale = r2.mesh.modelObject.scale.x, this._preXRState.groundRotation = r2.mesh.modelObject.rotation.z, this._preXRState.groundRenderToDepth = r2.renderToDepth, this._preXRState.groundShadowBaker = r2.shadowBaker.enabled), this._preXRState.environment || (this._preXRState.environment = this._viewer.scene.environment), this._preXRState.preserveTransparentTarget = this._viewer.renderFilter.passObject.preserveTransparentTarget;
      }, this._xrRenderingBegin = () => {
        this._xrSession && this._viewer && (console.log("webxr: VR session start"), Math.PI, this._viewer.renderer.stableNoise = true, this._viewer.resize());
      }, this._xrRenderingEnd = () => {
        console.log("webxr: VR session end"), this._xrManager && (this._xrManager.enabled = false), this._isPresenting = false, this._frameCount = 0, this._xrSession = void 0, this._cancelHitSources(), this._viewer && (this._viewer.renderer.stableNoise = false), this._restorePreXRState();
      }, this._onSessionStarted = async (e2) => {
        e2.addEventListener("end", this._onSessionEnded), this._xrManager.setReferenceSpaceType("local"), await this._xrManager.setSession(e2), this._xrSession = e2;
      }, this._onSessionEnded = () => {
        this._xrSession && this._xrSession.removeEventListener("end", this._onSessionEnded);
      };
    }
    async onAdded(e2) {
      await super.onAdded(e2);
      const t2 = e2.renderer.rendererObject.xr;
      if (t2.cameraAutoUpdate = false, this._xrManager = t2, !this.domOverlay) {
        const e3 = document.getElementById("tweakpaneUiContainer");
        this.domOverlay = e3 ? { root: e3 } : void 0;
      }
      if (e2.addEventListener("preRender", this._preRender), e2.addEventListener("postRender", this._postRender), e2.addEventListener("preFrame", this._preFrame), !window.isSecureContext)
        return e2.console.error("XR not supported in insecure context, try https://"), void (this.enabled = false);
      navigator && "xr" in navigator && navigator.xr ? navigator.xr.isSessionSupported("immersive-vr").then((e3) => {
        if (!e3)
          throw new Error("VR not supported");
      }).catch((n2) => {
        e2.console.error("VR not supported:", n2), t2.enabled = false, this.enabled = false;
      }) : (t2.enabled = false, this.enabled = false);
    }
    _updateShadow() {
      var e2, t2;
      if (!this._viewer)
        return;
      const n2 = this._viewer.scene.modelRoot, r2 = null === (t2 = null === (e2 = this._viewer.getPluginByType("Ground")) || void 0 === e2 ? void 0 : e2.mesh) || void 0 === t2 ? void 0 : t2.modelObject;
      r2 && (r2.rotation.z = this._viewer.scene.modelRoot.rotation.y, r2.position.copy(this._preXRState.groundOffset).multiplyScalar(n2.modelObject.scale.x).sub(n2.modelObject.position).negate(), r2.scale.setScalar(n2.modelObject.scale.x * this._preXRState.groundScale));
    }
    _preSetupModel() {
      var e2;
      const t2 = this._viewer.scene.modelRoot, n2 = t2.userData.arScale || 1;
      t2.scale.set(n2, n2, n2), t2.visible = true;
      const r2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPluginByType("Ground");
      (null == r2 ? void 0 : r2.mesh) && (r2.shadowBaker.enabled = false, r2.renderToDepth = false);
    }
    _restorePreXRState() {
      var e2;
      if (!this._viewer)
        return;
      this._viewer.renderer.rendererObject.setSize(this._preXRState.viewport.x, this._preXRState.viewport.y), this._viewer.resize(), this._viewer.scene.activeCamera.setInteractions(true, hC.PluginType), this._viewer.scene.activeCamera.autoLookAtTarget = true, this._viewer.scene.background = this._preXRState.viewerBg, void 0 !== this._preXRState.viewerBgColor && (null === (e2 = this._viewer.scene.backgroundColor) || void 0 === e2 || e2.set(this._preXRState.viewerBgColor)), this._preXRState.viewerBg = null;
      const t2 = this._viewer.scene.modelRoot;
      t2.scale.copy(this._preXRState.modelScale), t2.position.copy(this._preXRState.modelPosition), t2.quaternion.copy(this._preXRState.modelRotation), t2.updateMatrix(), t2.updateMatrixWorld(true), t2.visible = true;
      const n2 = this._viewer.scene.activeCamera;
      n2.position.copy(this._preXRState.cameraPosition), n2.target.copy(this._preXRState.cameraTarget), n2.cameraObject.up.copy(this._preXRState.cameraUp), n2.cameraObject.near = this._preXRState.cameraNear, n2.cameraObject.far = this._preXRState.cameraFar, n2.cameraObject.userData.autoNearFar = this._preXRState.cameraAutoNearFar, n2.cameraObject.isPerspectiveCamera && (void 0 !== this._preXRState.cameraFov && (n2.cameraObject.fov = this._preXRState.cameraFov), void 0 !== this._preXRState.cameraAspect && (n2.cameraObject.aspect = this._preXRState.cameraAspect)), n2.positionUpdated(false), n2.targetUpdated(true), n2.cameraObject.projectionMatrix.copy(this._preXRState.cameraProjectioMatrix), n2.cameraObject.projectionMatrixInverse.copy(this._preXRState.cameraProjectioMatrix).invert(), n2.cameraObject.updateMatrixWorld(true), n2.cameraObject.updateProjectionMatrix();
      const r2 = this._viewer.getPluginByType("Ground");
      (null == r2 ? void 0 : r2.mesh) && (r2.mesh.modelObject.position.subVectors(t2.position, this._preXRState.groundOffset), r2.mesh.modelObject.scale.setScalar(this._preXRState.groundScale), r2.mesh.modelObject.rotation.z = this._preXRState.groundRotation, r2.renderToDepth = this._preXRState.groundRenderToDepth, r2.shadowBaker.enabled = this._preXRState.groundShadowBaker, r2.refreshTransform()), this._viewer.scene.environment = this._preXRState.environment, this._preXRState.environment = void 0, this._viewer.renderFilter.passObject.preserveTransparentTarget = this._preXRState.preserveTransparentTarget;
    }
    _cancelHitSources() {
    }
  };
  mC.PluginType = "WEBXR_VRPluginBasic", fC([Ue("Resolution scale", [0.1, 1], 0.1)], mC.prototype, "xrResolutionScale", void 0), fC([je("Enter VR")], mC.prototype, "enterVR", void 0), fC([je("Exit VR")], mC.prototype, "exitVR", void 0), mC = hC = fC([We("WebXR VR")], mC);
  const _C = new dt({ vertexShader: r.vertexShader, fragmentShader: `
        ${_t}
        
        uniform float opacity;

		uniform sampler2D tDiffuse;
		uniform sampler2D tTransparentMap;

		varying vec2 vUv;

		void main() {
		
            float depth = getDepth(vUv);
            vec4 texel;
            if(depth>0.9999) {
			    texel = texture2D( tTransparentMap, vUv );
                if(texel.a < 0.01) discard; // background
                // transparent objects with render to depth = false
            }else {
                texel = texture2D( tDiffuse, vUv );
			}
            gl_FragColor = texel;
            
		}
		`, uniforms: { ...r.uniforms, tNormalDepth: { value: null }, tTransparentMap: { value: null } } });
  _C.renderToScreen = false, _C.useExistingRenderTarget = true, _C.clear = false;
  class gC extends t.SimpleEventDispatcher {
    get state() {
      return this._state;
    }
    setState(e2, t2) {
      this._state = e2, this.dispatchEvent({ type: e2, ...t2 });
    }
    _setOptions(e2) {
      Object.assign(this.options, e2);
    }
    setOptions(e2) {
      this._setOptions(e2);
    }
    constructor(e2, t2) {
      super(), this._state = "stopped", this._console = console, this._currentRecording = [], this._frameCount = 0, this._ondataavailable = (e3) => {
        e3.data && e3.data.size > 0 && this._currentRecording.push(e3.data);
      }, this._canvas = e2, null == t2 || t2.mimeType, this.options = { mimeType: "auto", frameRate: 30, stepMode: false }, this._setOptions(t2 || this.options);
    }
    isRecording() {
      return "recording" === this._state;
    }
    requestFrame() {
      return "recording" === this._state && (this._frameCount++, true);
    }
    dispose() {
      (this.isRecording() || "paused" === this._state) && this.stop((e2) => {
        this._console.warn("disposed with blob", e2), this.dispose();
      });
    }
  }
  class vC extends gC {
    constructor() {
      super(...arguments), this._currentImages = [], this._onstop = (e2) => {
        this._currentImages.length > 0 && (this._writeImages([...this._currentImages]), this._currentImages = []), this.setState("stopped");
      }, this._onerror = (e2) => {
        this.setState("error", { error: e2 }), this._console.error(e2);
      };
    }
    start() {
      if ("recording" !== this.state) {
        if ("error" === this.state && this._console.warn("Resetting from error state."), "paused" === this.state)
          return this.setState("starting"), void this.setState("recording");
        this._currentRecording = [], this._currentImages = [], this._frameCount = 0, this.setState("starting"), window && window.showDirectoryPicker && window.showDirectoryPicker().then(async (e2) => {
          const t2 = await (null == e2 ? void 0 : e2.getDirectoryHandle("i-" + Math.floor(Date.now()), { create: true }));
          this._imgDirectory = t2, this._frameCount = 0, this.setState("recording");
        }).catch((e2) => {
          this._onerror({ detail: e2 });
        });
      } else
        this._console.log("Already recording canvas");
    }
    requestFrame() {
      if (!super.requestFrame())
        return false;
      const e2 = this.options.mimeType;
      return this._canvas.toBlob((t2) => {
        this._currentImages.push(["frame_" + String(this._frameCount).padStart(5, "0") + (e2.includes("png") ? ".png" : ".jpg"), t2]);
      }, e2, 90), this._currentImages.length > 60 && (this._writeImages([...this._currentImages]), this._currentImages = []), true;
    }
    pause() {
      "paused" !== this.state && "stopped" !== this.state && this.setState("paused");
    }
    stop(e2) {
      "stopped" !== this.state && ("error" !== this.state ? (this._recordingCallback = e2, this.setState("stopping"), this._onstop({})) : this._console.error("Recorder in error state, cannot stop, call start again."));
    }
    async _writeImages(e2) {
      if (!this._imgDirectory)
        return;
      const n2 = [];
      for (const r2 of e2) {
        const e3 = await this._imgDirectory.getFileHandle(r2[0], { create: true });
        n2.push((0, t.writeFile)(e3, r2[1]));
      }
      await Promise.all(n2);
    }
  }
  class yC extends gC {
    _setOptions(e2) {
      var t2, n2;
      super._setOptions(e2), this.options.mimeType && "auto" !== this.options.mimeType || (this.options.mimeType = null !== (t2 = yC.GetSupportedMimeTypes([], ["h264"], true)) && void 0 !== t2 ? t2 : yC.GetSupportedMimeTypes(void 0, void 0, true)), this.options.mimeType && !(null === (n2 = this.options.mimeType) || void 0 === n2 ? void 0 : n2.startsWith("video/")) || window.MediaRecorder || (this._console.warn("MediaRecorder is not supported, switching to png"), this.options.mimeType = "image/png"), this.options.mimeType || console.warn(new Error("No supported mimetype found"));
    }
    setOptions(e2) {
      this._setOptions(e2);
    }
    constructor(e2, n2) {
      super(e2, n2), this._resumeSyncTime = 0, this._onstop = (e3) => {
        var t2;
        if (this._recorder && this._currentRecording.length > 0) {
          const e4 = new Blob(this._currentRecording, { type: this.options.mimeType });
          null === (t2 = this._recordingCallback) || void 0 === t2 || t2.call(this, e4);
        }
        this._recorder = void 0, this.setState("stopped");
      }, this._onstart = (e3) => {
        var t2;
        this._frameCount = 0, this.options.stepMode && (null === (t2 = this._recorder) || void 0 === t2 || t2.pause()), this.setState("recording");
      }, this._onresume = (e3) => {
        if ("paused" !== this.state && "starting" !== this.state && "stopped" !== this.state || this.setState("recording"), !this.options.stepMode)
          return;
        const n3 = () => {
          var e4;
          "recording" === this.state && (null === (e4 = this._recorder) || void 0 === e4 || e4.pause());
        }, r2 = Math.min(this._resumeSyncTime - (0, t.now)(), 0) + 1e3 / this.options.frameRate;
        r2 > 0 ? (0, t.timeout)(r2).then(n3) : n3();
      }, this._onerror = (e3) => {
        this.setState("error", { error: e3 }), this._console.error(e3), this._recorder = void 0;
      };
    }
    start() {
      var e2, t2, n2;
      if ("recording" === this.state)
        return void this._console.log("Already recording canvas");
      if ("error" === this.state && (this._recorder = void 0, this._console.warn("Resetting from error state.")), this._recorder)
        return "paused" === this.state ? (this.setState("starting"), void this._recorder.resume()) : void this._console.warn("Canvas recorder unknown state", this.state);
      const r2 = { mimeType: this.options.mimeType, videoBitsPerSecond: this.options.videoBitsPerSecond };
      if (this._currentRecording = [], this._frameCount = 0, null === (e2 = r2.mimeType) || void 0 === e2 ? void 0 : e2.startsWith("video")) {
        if (!window.MediaRecorder)
          return this._console.error("MediaRecorder not supported, use image sequence"), void this.setState("error", { error: new Error("MediaRecorder not supported") });
        {
          const e3 = this._canvas.captureStream(this.options.stepMode ? 0 : this.options.frameRate), n3 = null === (t2 = e3.getVideoTracks()) || void 0 === t2 ? void 0 : t2[0];
          this._track = n3, this._recorder = new window.MediaRecorder(e3, r2), this._recorder.onstop = this._onstop, this._recorder.ondataavailable = this._ondataavailable, this._recorder.onerror = this._onerror, this._recorder.onresume = this._onresume, this._recorder.onstart = this._onstart;
        }
      }
      this.setState("starting"), this._recorder && (null === (n2 = this._recorder) || void 0 === n2 || n2.start());
    }
    requestFrame() {
      return !(!this._recorder || !super.requestFrame() || this._track && this.options.stepMode && (this._resumeSyncTime = (0, t.now)(), this._track.requestFrame(), this._recorder.resume(), 0));
    }
    pause() {
      "paused" !== this.state && "stopped" !== this.state && (this.options.stepMode ? console.error("Pause not supported in stepMode") : this._recorder && (this._recorder.pause(), this.setState("paused")));
    }
    stop(e2) {
      "stopped" !== this.state && ("error" !== this.state ? (this._recordingCallback = e2, this.setState("stopping"), this._recorder && this._recorder.stop()) : this._console.error("Recorder in error state, cannot stop, call start again."));
    }
    dispose() {
      this._recorder && (super.dispose(), this._recorder = void 0);
    }
    static GetSupportedMimeTypes(e2, t2, n2 = false) {
      if (!window.MediaRecorder)
        return n2 ? void 0 : [];
      const r2 = ["webm", "ogg", "mp4", "x-matroska"].filter((t3) => !e2 || e2.length < 1 || e2.includes(t3)), i2 = ["vp9", "vp9.0", "vp8", "vp8.0", "avc1", "av1", "h265", "h.265", "h264", "h.264", "opus"].filter((e3) => !t2 || t2.length < 1 || t2.includes(e3)), s2 = [];
      return r2.forEach((e3) => {
        const t3 = `video/${e3}`;
        i2.forEach((e4) => {
          [`${t3};codecs=${e4}`, `${t3};codecs:${e4}`, `${t3};codecs=${e4.toUpperCase()}`, `${t3};codecs:${e4.toUpperCase()}`, `${t3}`].forEach((e5) => {
            MediaRecorder.isTypeSupported(e5) && s2.push(e5);
          });
        });
      }), n2 ? s2.length > 0 ? s2[0] : void 0 : s2;
    }
  }
  class bC extends gC {
    constructor(e2, n2) {
      super(e2, n2), this._workerRunning = false, this.worker = new Worker((0, t.remoteWorkerURL)(bC.LIBRARY_PATH + "ffmpeg-worker-mp4.js", bC.LIBRARY_PATH + "ffmpeg-worker-mp4.wasm"));
      let r2 = 0;
      this.worker.onmessage = (e3) => {
        var t2;
        const n3 = e3.data;
        switch (n3.type) {
          case "stdout":
          case "stderr":
            if (0 === n3.data.indexOf("frame=")) {
              const e4 = parseInt(n3.data.split("frame=")[1].split("fps")[0].trim()), t3 = this._frameCount, r3 = Math.round(e4 / t3 * 100);
              this.dispatchEvent({ type: "encode-progress", progress: r3, frame: e4, totalFrames: t3 });
            }
            console.log(n3.data + "\n");
            break;
          case "exit":
            console.log("Process exited with code " + n3.data), r2 = parseInt(n3.data);
            break;
          case "done":
            if (void 0 === n3.data.MEMFS[0].data)
              return void console.log("video processing failed");
            this._workerRunning = false, null === (t2 = this._recordingCallback) || void 0 === t2 || t2.call(this, new Blob([n3.data.MEMFS[0].data], { type: "video/mp4" })), console.timeEnd("ffmpeg-record"), this.setState("stopped");
        }
      };
    }
    start() {
      "recording" !== this.state ? ("error" === this.state && console.warn("Resetting from error state."), "paused" !== this.state && (this._frameCount = 0), this.setState("starting"), this.setState("recording")) : console.log("Already recording canvas");
    }
    stop(e2) {
      "stopped" !== this.state && ("error" !== this.state ? (this._recordingCallback = e2, this.setState("stopping"), this._onStop()) : console.error("Recorder in error state, cannot stop, call start again."));
    }
    _onStop() {
      const e2 = this._canvas.width % 2 == 0 ? this._canvas.width : this._canvas.width - 1;
      this._workerRunning = true, console.time("ffmpeg-record");
      const t2 = this.options.frameRate.toString(), n2 = this.options.frameRate.toString();
      this.worker.postMessage({ type: "run", arguments: ["-r", t2, "-an", "-i", "img%03d.jpeg", "-c:v", "libx264", "-crf", "17", "-filter:v", `scale=${e2}:-2`, "-pix_fmt", "yuv420p", "-b:v", "10M", "-preset", "ultrafast", "-r", n2, "out.mp4"] });
    }
    requestFrame() {
      return !!super.requestFrame() && (this.sendBlobToWorker(this._frameCount - 1), true);
    }
    sendBlobToWorker(e2) {
      this._canvas.toBlob((t2) => {
        this.worker.postMessage({ type: "image", file: { name: `img${this.pad(e2, 3)}.jpeg`, data: t2 } });
      }, "image/jpeg", 90);
    }
    pad(e2, t2) {
      return (e2 += "").length >= t2 ? e2 : new Array(t2 - e2.length + 1).join("0") + e2;
    }
    pause() {
      "paused" !== this.state && "stopped" !== this.state && this.setState("paused");
    }
  }
  bC.LIBRARY_PATH = "https://cdn.jsdelivr.net/npm/@repalash/ffmpeg.js@4.2.9005/dist/";
  var wC = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  class AC extends gt {
    get recorder() {
      return this._recorder;
    }
    constructor() {
      super(), this.enabled = true, this.convergeMode = true, this.mimeType = "video/mp4", this.videoFrameRate = 30, this._recorders = {}, this._renderToScreenDisabled = false, this._preRender = () => {
        var e2, t2, n2;
        if (this.convergeMode && (null === (e2 = this._recorder) || void 0 === e2 ? void 0 : e2.isRecording())) {
          const e3 = this._viewer.renderer.composer.renderToScreen;
          this._viewer.renderer.composer.renderToScreen = (null === (n2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPluginByType("Progressive")) || void 0 === n2 ? void 0 : n2.isConverged()) || false, e3 && !this._viewer.renderer.composer.renderToScreen && (this._renderToScreenDisabled = true);
        }
      }, this._postRender = () => {
        var e2, n2, r2;
        if ((null === (e2 = this._recorder) || void 0 === e2 ? void 0 : e2.isRecording()) && (!this.convergeMode || (null === (r2 = null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.getPluginByType("Progressive")) || void 0 === r2 ? void 0 : r2.isConverged(true)))) {
          const e3 = () => {
            var e4;
            return null === (e4 = this._recorder) || void 0 === e4 ? void 0 : e4.requestFrame();
          };
          if (this.convergeMode) {
            const n3 = 1;
            (0, t.timeout)(n3).then(e3);
          } else
            e3();
        }
        this._renderToScreenDisabled && (this._viewer.renderer.composer.renderToScreen = true);
      }, this._refreshUi = () => {
        var e2;
        null === (e2 = this.uiConfig.children) || void 0 === e2 || e2.map((e3) => (0, t.getOrCall)(e3)).flat(2).forEach((e3) => {
          var t2;
          return null === (t2 = null == e3 ? void 0 : e3.uiRefresh) || void 0 === t2 ? void 0 : t2.call(e3);
        });
      }, this.uiConfig = { type: "folder", label: "Video Export", children: [{ type: "slider", label: "Frame Rate", bounds: [1, 60], stepSize: 1, property: [this, "videoFrameRate"] }, { type: "checkbox", property: [this, "convergeMode"] }, { type: "dropdown", label: "Mime type", property: [this, "mimeType"], children: [["Auto Video (x264)", "auto"], ["PNG sequence", "image/png"], ["JPEG sequence", "image/jpeg"], ["MP4 Video (ffmpeg)", "video/mp4"]].map((e2) => ({ label: e2[0], value: e2[1] })) }, { type: "input", disabled: true, label: "State", getValue: () => {
        var e2, t2;
        return null !== (t2 = null === (e2 = this.recorder) || void 0 === e2 ? void 0 : e2.state) && void 0 !== t2 ? t2 : "not initialized";
      } }, { type: "button", label: () => {
        var e2;
        return (null === (e2 = this.recorder) || void 0 === e2 ? void 0 : e2.isRecording()) ? "Stop Recording" : "Start Recording";
      }, value: () => {
        var e2;
        (null === (e2 = this.recorder) || void 0 === e2 ? void 0 : e2.isRecording()) ? this.stopRecording().then(async (e3) => {
          if (e3) {
            const t2 = e3.type.split(";")[0].split("/").pop() || "mp4";
            await this._downloadBlob(e3, t2);
          }
        }) : this.startRecording();
      } }, { type: "button", label: "Record Camera Views", hidden: () => {
        var e2, t2;
        return !!(null === (e2 = this.recorder) || void 0 === e2 ? void 0 : e2.isRecording()) || !(null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPluginByType("CameraViews"));
      }, value: () => {
        var e2, t2;
        null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPluginByType("CameraViews")) || void 0 === t2 || t2.recordAllViews();
      } }, { type: "button", label: "Record Camera Views + GLTF Anim", hidden: () => {
        var e2, t2, n2, r2;
        return !!(null === (e2 = this.recorder) || void 0 === e2 ? void 0 : e2.isRecording()) || !(null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPluginByType("CameraViews")) || !(null === (r2 = null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.getPluginByType("GLTFAnimation")) || void 0 === r2 ? void 0 : r2.animations.length);
      }, value: () => {
        var e2, t2, n2, r2;
        const i2 = "playing" === (null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPluginByType("GLTFAnimation")) || void 0 === t2 ? void 0 : t2.animationState);
        null === (r2 = null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.getPluginByType("CameraViews")) || void 0 === r2 || r2.recordAllViews(() => {
          var e3, t3;
          null === (t3 = null === (e3 = this._viewer) || void 0 === e3 ? void 0 : e3.getPluginByType("GLTFAnimation")) || void 0 === t3 || t3.playAnimation();
        }).then(() => {
          var e3, t3;
          i2 || null === (t3 = null === (e3 = this._viewer) || void 0 === e3 ? void 0 : e3.getPluginByType("GLTFAnimation")) || void 0 === t3 || t3.stopAnimation();
        });
      } }, { type: "button", label: "Record GLTF Anim", hidden: () => {
        var e2, t2, n2;
        return !!(null === (e2 = this.recorder) || void 0 === e2 ? void 0 : e2.isRecording()) || !(null === (n2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPluginByType("GLTFAnimation")) || void 0 === n2 ? void 0 : n2.animations.length);
      }, value: async () => {
        var e2, t2;
        if (null === (e2 = this.recorder) || void 0 === e2 ? void 0 : e2.isRecording())
          return;
        const n2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPluginByType("GLTFAnimation");
        if (!n2)
          return;
        let r2 = false;
        n2.loopAnimations && (r2 = true), r2 && (n2.loopAnimations = false);
        const i2 = await this.record(async () => n2.playAnimation());
        if (r2 && (n2.loopAnimations = true), i2) {
          const e3 = i2.type.split(";")[0].split("/").pop() || "mp4";
          await this._downloadBlob(i2, e3);
        }
      } }, { type: "button", label: "Record 360 animation", hidden: () => {
        var e2;
        return !!(null === (e2 = this.recorder) || void 0 === e2 ? void 0 : e2.isRecording());
      }, value: async () => this.download360Recording(null, false) }, { type: "button", label: "Record 360 animation (CCW)", hidden: () => {
        var e2;
        return !!(null === (e2 = this.recorder) || void 0 === e2 ? void 0 : e2.isRecording());
      }, value: async () => this.download360Recording(null, true) }] }, this.refreshRecorderOptions = this.refreshRecorderOptions.bind(this);
    }
    isRecording() {
      var e2, t2;
      return null !== (t2 = null === (e2 = this._recorder) || void 0 === e2 ? void 0 : e2.isRecording()) && void 0 !== t2 && t2;
    }
    refreshRecorderOptions() {
      if (!this._viewer)
        return;
      let e2 = "image";
      "video/mp4" === this.mimeType ? e2 = "ffmpeg.js" : "auto" === this.mimeType ? e2 = "canvas-media" : this.mimeType.startsWith("image") && (e2 = "image"), this._recorder = this._getRecorder(e2), this._recorder && this._recorder.setOptions({ frameRate: this.videoFrameRate, mimeType: this.mimeType, stepMode: this.convergeMode });
    }
    async onAdded(e2) {
      var t2;
      await super.onAdded(e2), e2.addEventListener("preRender", this._preRender), e2.addEventListener("postRender", this._postRender), e2.scene.addEventListener("addSceneObject", this._refreshUi), this._recordIndicator = document.createElement("div"), this._recordIndicator.style.width = "20px", this._recordIndicator.style.height = "20px", this._recordIndicator.style.backgroundColor = "red", this._recordIndicator.style.top = "10px", this._recordIndicator.style.left = "10px", this._recordIndicator.style.position = "absolute", this._recordIndicator.style.borderRadius = "100%", this._recordIndicator.style.visibility = "hidden", null === (t2 = e2.canvas.parentElement) || void 0 === t2 || t2.appendChild(this._recordIndicator), this.refreshRecorderOptions();
    }
    _stateChange(e2) {
      var n2, r2;
      this.dirty = e2, null === (n2 = this._viewer) || void 0 === n2 || n2.setDirty(), null === (r2 = this.uiConfig.children) || void 0 === r2 || r2.map((e3) => (0, t.getOrCall)(e3)).flat(2).forEach((e3) => {
        var t2;
        return null === (t2 = null == e3 ? void 0 : e3.uiRefresh) || void 0 === t2 ? void 0 : t2.call(e3);
      });
    }
    async onRemove(e2) {
      var t2;
      return e2.removeEventListener("preRender", this._preRender), e2.removeEventListener("preRender", this._postRender), e2.scene.removeEventListener("addSceneObject", this._refreshUi), null === (t2 = this._recorder) || void 0 === t2 || t2.dispose(), Object.values(this._recorders).forEach((e3) => {
        null == e3 || e3.dispose();
      }), super.onRemove(e2);
    }
    async record(e2, t2) {
      var n2, r2;
      if (!this.enabled)
        return;
      if (null === (n2 = this._recorder) || void 0 === n2 ? void 0 : n2.isRecording())
        return;
      const i2 = null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.getPluginByType("Progressive"), s2 = null == i2 ? void 0 : i2.maxFrameCount;
      i2 && this.convergeMode && (i2.maxFrameCount = Math.min(16, null != s2 ? s2 : 16)), await new Promise((n3, r3) => {
        const i3 = () => {
          this.removeEventListener("start", s3), this.removeEventListener("stop", i3), this.removeEventListener("error", o3);
        }, s3 = async () => {
          i3(), null == t2 || t2(), await e2(), n3();
        }, o3 = async () => {
          i3(), r3();
        };
        this.addEventListener("start", s3), this.addEventListener("stop", i3), this.addEventListener("error", o3), this.startRecording();
      });
      const o2 = await this.stopRecording();
      return i2 && this.convergeMode && (i2.maxFrameCount = null != s2 ? s2 : 16), o2;
    }
    startRecording() {
      var e2;
      return !!this.enabled && false === (null === (e2 = this.recorder) || void 0 === e2 ? void 0 : e2.isRecording()) && (this.recorder.options.stepMode = this.convergeMode, this.recorder.start(), true);
    }
    async stopRecording() {
      var e2;
      if (null === (e2 = this.recorder) || void 0 === e2 ? void 0 : e2.isRecording())
        return new Promise((e3, t2) => {
          var n2;
          return null === (n2 = this.recorder) || void 0 === n2 ? void 0 : n2.stop(e3);
        });
    }
    async _downloadBlob(e2, t2) {
      var n2, r2, i2;
      const s2 = await (null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.prompt("Canvas Recorder: Save file as", "recording.mp4", false)), o2 = null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.getPluginByType("FileTransferPlugin");
      o2 ? await o2.exportFile(e2, s2 || "recording.mp4") : null === (i2 = this._viewer) || void 0 === i2 || i2.console.error("FileTransferPlugin required to export/download file");
    }
    async download360Recording(e2 = null, t2 = false) {
      var n2;
      if (null === (n2 = this.recorder) || void 0 === n2 ? void 0 : n2.isRecording())
        return;
      if (!this._viewer)
        return;
      const r2 = e2 || await this._viewer.prompt("Enter duration in seconds", "5", true);
      if (null === r2)
        return;
      const i2 = parseFloat(r2 || "5");
      if (!isFinite(i2) || i2 <= 0)
        return;
      const s2 = await this.recordCamera360(i2, t2);
      if (s2) {
        const e3 = s2.type.split(";")[0].split("/").pop() || "mp4";
        await this._downloadBlob(s2, e3);
      }
    }
    async recordCamera360(e2, t2 = false) {
      var r2;
      if (null === (r2 = this.recorder) || void 0 === r2 ? void 0 : r2.isRecording())
        return;
      if (!this._viewer)
        return;
      const i2 = this._viewer.scene.activeCamera;
      let s2 = i2.interactionsEnabled, o2 = 0;
      for (; !(s2 || (this._viewer.setDirty(), await this._viewer.doOnce("postFrame"), o2 % 30 == 0 && this._viewer.console.warn("CanvasRecorderPlugin: interactions are already disabled by something, waiting..."), s2 = i2.interactionsEnabled, o2 > 5e3 / 30)); )
        o2++;
      i2.setInteractions(false, AC.PluginType);
      const a2 = i2.target.clone(), l2 = i2.position.clone().sub(a2), c2 = await this._viewer.getPluginByType("PopmotionPlugin");
      if (!c2)
        return void console.error("Popmotion plugin not found");
      const u2 = new n.$V().setFromVector3(l2);
      i2.position.setFromSpherical(u2).add(a2), i2.positionUpdated(true);
      const p2 = i2.autoLookAtTarget;
      i2.autoLookAtTarget = true;
      const d2 = await this.record(async () => c2.animate({ from: u2.theta, to: u2.theta + 2 * Math.PI * (t2 ? -1 : 1), duration: 1e3 * e2, ease: Dp.linear, onUpdate: (e3) => {
        u2.theta = e3, i2.position.setFromSpherical(u2).add(a2), i2.positionUpdated(true);
      } }).promise);
      return i2.autoLookAtTarget = p2, i2.position.copy(l2).add(a2), i2.positionUpdated(true), i2.setInteractions(true, AC.PluginType), d2;
    }
    _getRecorder(e2) {
      if (!this._viewer)
        throw new Error("No viewer");
      if (this._recorders[e2])
        return this._recorders[e2];
      let t2;
      return t2 = "canvas-media" === e2 ? new yC(this._viewer.canvas, { frameRate: this.videoFrameRate, mimeType: this.mimeType }) : "ffmpeg.js" === e2 ? new bC(this._viewer.canvas, { frameRate: this.videoFrameRate, mimeType: this.mimeType }) : new vC(this._viewer.canvas, { frameRate: this.videoFrameRate, mimeType: this.mimeType }), t2.addEventListener("starting", () => this._stateChange(false)), t2.addEventListener("recording", () => {
        this._recordIndicator.style.visibility = "visible", this._recordIndicator.style.backgroundColor = "red", this.dispatchEvent({ type: "start" }), this._stateChange(!this.convergeMode);
      }), t2.addEventListener("error", () => {
        this.dispatchEvent({ type: "error" });
      }), t2.addEventListener("paused", () => this._stateChange(false)), t2.addEventListener("stopped", () => {
        this._recordIndicator.style.visibility = "hidden", this.dispatchEvent({ type: "stop" }), this._stateChange(false);
      }), t2.addEventListener("encode-progress", (e3) => {
        this.dispatchEvent({ ...e3 });
      }), this._recorders[e2] = t2, t2;
    }
  }
  AC.PluginType = "CanvasRecorder", wC([(0, t.onChange)(AC.prototype.refreshRecorderOptions), ie()], AC.prototype, "convergeMode", void 0), wC([(0, t.onChange)(AC.prototype.refreshRecorderOptions), ie()], AC.prototype, "mimeType", void 0), wC([(0, t.onChange)(AC.prototype.refreshRecorderOptions), ie()], AC.prototype, "videoFrameRate", void 0);
  var xC = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  const EC = new n.jyz({ name: "HorizontalBlurShader", uniforms: { tDiffuse: { value: null }, h: { value: 1 / 512 } }, vertexShader: "\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vUv = uv;\n			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n		}", fragmentShader: "\n\n		uniform sampler2D tDiffuse;\n		uniform float h;\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vec4 sum = vec4( 0.0 );\n\n			sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\n			sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\n			sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\n			sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n			sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\n			sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\n			sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\n			sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\n\n			gl_FragColor = sum;\n\n		}" });
  EC.depthTest = false;
  const CC = new n.jyz({ name: "VerticalBlurShader", uniforms: { tDiffuse: { value: null }, v: { value: 1 / 512 } }, vertexShader: "\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vUv = uv;\n			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n		}", fragmentShader: "\n\n		uniform sampler2D tDiffuse;\n		uniform float v;\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vec4 sum = vec4( 0.0 );\n\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\n\n			gl_FragColor = sum;\n\n		}" });
  CC.depthTest = false;
  class SC extends jg {
    constructor(e2 = {}, t2 = false) {
      super(e2), this.contactShadows = true, this.blurAmount = 1, this.shadowScale = 1, this.shadowHeight = 5, this.shadowCamera = new n.iKG(-1, 1, 1, -1, 1e-3, this.shadowHeight), this._refreshShadowCameraFrustum = this._refreshShadowCameraFrustum.bind(this), this.refreshOptions = this.refreshOptions.bind(this), this._showDebug = t2, t2 && this.dependencies.push(bh);
    }
    async onAdded(e2) {
      const t2 = e2.renderer.createTarget({ type: n.ywz, format: n.wk1, colorSpace: n.aCh, size: { width: 512, height: 512 }, generateMipmaps: false, depthBuffer: true, minFilter: n.wem, magFilter: n.wem });
      t2.texture.name = "groundContactDepthTexture";
      const r2 = new n.lRF({ depthPacking: n.z81 });
      r2.onBeforeCompile = function(e3) {
        e3.uniforms.opacity.value = 1, e3.fragmentShader = `
						${e3.fragmentShader.replace("gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );", "gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), 1.0 );")}
					`;
      };
      const i2 = new bt(t2, r2, new n.Ilk(0, 0, 0), 0);
      this._depthPass = i2, await super.onAdded(e2);
    }
    _postFrame() {
      super._postFrame(), this._viewer;
    }
    _preRender() {
      if (super._preRender(), !this._viewer)
        return;
      if (!this._depthPass)
        return;
      this._depthPass.scene = this._viewer.scene.modelObject, this._depthPass.camera = this.shadowCamera, this._depthPass.render(this._viewer.renderer.rendererObject, null);
      const e2 = this._viewer.renderer.getTempTarget({ type: n.ywz, format: n.wk1, colorSpace: n.aCh, size: { width: 1024, height: 1024 }, generateMipmaps: false, depthBuffer: false, minFilter: n.wem, magFilter: n.wem });
      this._blurShadow(e2), this._blurShadow(e2, 0.4), this._viewer.renderer.releaseTempTarget(e2);
    }
    _blurShadow(e2, t2 = 1) {
      this._viewer && this._depthPass && (EC.uniforms.h.value = t2 * this.blurAmount / 256, CC.uniforms.v.value = t2 * this.blurAmount / 256, this._viewer.renderer.blit(this._depthPass.target.texture, e2, { material: EC, clear: true }), this._viewer.renderer.blit(e2.texture, this._depthPass.target, { material: CC, clear: true }));
    }
    async onDispose(e2) {
      return super.onDispose(e2);
    }
    async onRemove(e2) {
      var t2, n2, r2;
      const i2 = null === (t2 = this._depthPass) || void 0 === t2 ? void 0 : t2.target;
      return i2 && (null === (n2 = this._viewer) || void 0 === n2 || n2.renderer.disposeTarget(i2)), null === (r2 = this._depthPass) || void 0 === r2 || r2.dispose(), this._depthPass = void 0, super.onRemove(e2);
    }
    _refreshTransform() {
      super._refreshTransform(), this._mesh && this._viewer && (this.shadowCamera.position.copy(this._mesh.getWorldPosition(new n.Pa4())), this.shadowCamera.setRotationFromEuler(new n.USm(Math.PI / 2, 0, 0)), this.shadowCamera.updateMatrixWorld(), this._refreshShadowCameraFrustum(), this._mesh.scale.y = -this.size);
    }
    _refreshShadowCameraFrustum() {
      this.shadowCamera && (this.shadowCamera.left = -this.size / (2 * this.shadowScale), this.shadowCamera.right = this.size / (2 * this.shadowScale), this.shadowCamera.top = this.size / (2 * this.shadowScale), this.shadowCamera.bottom = -this.size / (2 * this.shadowScale), this.shadowCamera.far = this.shadowHeight, this.shadowCamera.updateProjectionMatrix(), this._setDirty());
    }
    _setDirty() {
      var e2;
      null === (e2 = this._viewer) || void 0 === e2 || e2.setDirty();
    }
    _removeMaterial() {
      this._material && super._removeMaterial();
    }
    refreshOptions() {
      this._viewer && super.refreshOptions();
    }
    _refreshMaterial() {
      var e2;
      if (!this._viewer)
        return false;
      const t2 = super._refreshMaterial();
      return this._material ? (this._material.alphaMap = (null === (e2 = this._depthPass) || void 0 === e2 ? void 0 : e2.target.texture) || null, t2 && (this._material.roughness = 1, this._material.metalness = 0, this._material.color.set(1118481), this._material.transparent = true, this._material.materialObject.userData.ssreflDisabled = true, this._material.materialObject.userData.ssreflNonPhysical = false), t2) : t2;
    }
    _extraUiConfig() {
      return [{ label: "Contact Shadows", type: "checkbox", property: [this, "contactShadows"] }, { label: "Shadow Scale", type: "slider", bounds: [0, 2], property: [this, "shadowScale"] }, { label: "Shadow Height", type: "slider", bounds: [0, 20], property: [this, "shadowHeight"] }, { label: "Blur Amount", type: "slider", bounds: [0, 10], property: [this, "blurAmount"] }, ...super._extraUiConfig()];
    }
  }
  function MC(e2, t2, r2, i2) {
    e2.traverse((e3) => {
      e3 && (e3.userData.cloneRotI = t2, e3.userData.rotationCount = r2, e3.userData.rotationAxis = i2, e3.addEventListener("beforeRender", (t3) => function(e4, t4) {
        var r3;
        t4 && (null === (r3 = t4.map) || void 0 === r3 ? void 0 : r3.isTexture) && (t4.extraUniformsToUpload || (t4.extraUniformsToUpload = {}), t4.extraUniformsToUpload.uvTransform || (t4.extraUniformsToUpload.uvTransform = { value: new n.Vkp() }), t4.extraUniformsToUpload.uvTransform.value.setUvTransform(t4.map.offset.x * t4.map.repeat.x * e4.userData.cloneRotI / (e4.userData.rotationCount || 1), t4.map.offset.y * t4.map.repeat.y * e4.userData.cloneRotI / (e4.userData.rotationCount || 1), t4.map.repeat.x, t4.map.repeat.y, t4.map.rotation, t4.map.center.x, t4.map.center.y));
      }(e3, t3.material)));
    });
  }
  function TC(e2, t2, n2, r2 = "x") {
    var i2;
    if (e2.userData.rotationCount > 1 && !e2.userData.rotationRoot)
      return e2;
    const s2 = e2.parent;
    if (!s2)
      throw new Error("No parent");
    if (e2.userData.cloneParent) {
      const t3 = e2.userData.cloneParent;
      if (!(e2 = s2.children.find((e3) => t3 === e3.uuid)))
        return console.error("Couldn't find clone root, cannot rotate. maybe a serialization issue?", t3, s2), e2;
    }
    let o2 = s2.children.filter((t3) => {
      var n3;
      return (null === (n3 = t3.userData) || void 0 === n3 ? void 0 : n3.cloneParent) === e2.uuid;
    }).sort((e3, t3) => e3.userData.cloneRotI - t3.userData.cloneRotI);
    if (e2.userData.rotationCount === t2 && t2 === o2.length && void 0 === n2 && e2.userData.rotationAxis === r2)
      return e2;
    if (null == n2 && (n2 = null !== (i2 = e2.userData.rotationSkips) && void 0 !== i2 ? i2 : []), n2 !== e2.userData.rotationSkips && (e2.userData.rotationSkips = [...n2]), MC(e2, 0, t2, r2), e2.userData.rotationRoot = true, e2.visible = true, t2 <= o2.length) {
      for (let e3 = t2 - 1; e3 < o2.length; e3++)
        s2.remove(o2[e3]), o2[e3].traverse((e4) => e4.userData = { __disposed: true });
      o2 = o2.slice(0, t2);
    }
    for (let i3 = 1; i3 < t2; i3++) {
      const a2 = i3 <= o2.length ? o2[i3 - 1] : e2.clone();
      a2.rotation.copy(e2.rotation), a2.rotation[r2] += i3 / t2 * Math.PI * 2, MC(a2, i3, t2, r2), i3 > o2.length && s2.add(a2), a2.visible = !n2.includes(i3);
    }
    return e2.visible = !n2.includes(0), e2;
  }
  SC.PluginType = "ContactShadowGroundPlugin", xC([(0, t.onChange)(SC.prototype.refreshOptions), ie()], SC.prototype, "contactShadows", void 0), xC([ie(), (0, t.onChange)(SC.prototype._setDirty)], SC.prototype, "blurAmount", void 0), xC([ie(), (0, t.onChange)(SC.prototype._refreshShadowCameraFrustum)], SC.prototype, "shadowScale", void 0), xC([ie(), (0, t.onChange)(SC.prototype._refreshShadowCameraFrustum)], SC.prototype, "shadowHeight", void 0);
  var PC, IC = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let RC = PC = class extends gt {
    async onAdded(e2) {
      var t2;
      await super.onAdded(e2), null === (t2 = e2.getPluginByType("Picking")) || void 0 === t2 || t2.addEventListener("selectedObjectChanged", this._selectedObjectChanged);
    }
    constructor(e2 = true) {
      super(), this.rotations = 1, this.axis = "x", this.skips = "", this._selectedObjectChanged = this._selectedObjectChanged.bind(this), this.enabled = e2;
    }
    _selectedObjectChanged() {
      var e2, t2, n2, r2, i2, s2, o2, a2, l2;
      if (!this.enabled)
        return;
      const c2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPluginByType("Picking")) || void 0 === t2 ? void 0 : t2.getSelectedObject();
      if (!c2)
        return void (null === (r2 = (n2 = this.uiConfig).uiRefresh) || void 0 === r2 || r2.call(n2, "postFrame", true));
      const u2 = c2.userData.rotationRoot && null !== (i2 = c2.userData.rotationCount) && void 0 !== i2 ? i2 : 1;
      this.rotations = u2, this.skips = null !== (o2 = null === (s2 = c2.userData.rotationSkips) || void 0 === s2 ? void 0 : s2.join(",")) && void 0 !== o2 ? o2 : "", this.axis = c2.userData.rotationAxis || "x", null === (l2 = (a2 = this.uiConfig).uiRefresh) || void 0 === l2 || l2.call(a2, "postFrame", true);
    }
    _paramsChanged() {
      var e2, t2, r2, i2, s2, o2;
      if (!this.enabled)
        return;
      const a2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPluginByType("Picking")) || void 0 === t2 ? void 0 : t2.getSelectedObject();
      if (a2) {
        if (this.rotations > 1 || a2.userData.rotationCount) {
          const e3 = a2.userData.rotationCount, t3 = TC(a2, this.rotations, this.skips.split(",").map((e4) => parseInt(e4)).filter((e4) => isFinite(e4)), this.axis), o3 = null == t3 ? void 0 : t3.userData.rotationCount;
          if (o3 && o3 !== e3) {
            const e4 = [];
            null == t3 || t3.traverseAncestors((t4) => {
              e4.push(t4);
            });
            for (const t4 of e4)
              if (t4.userData.autoScaled) {
                W(t4), null === (r2 = this._viewer) || void 0 === r2 || r2.resetCamera({ rootObject: t4, centerOffset: new n.Pa4(4, 4, 4) });
                break;
              }
          }
          a2.parent && !a2.userData.__disposed || null === (s2 = null === (i2 = this._viewer) || void 0 === i2 ? void 0 : i2.getPluginByType("Picking")) || void 0 === s2 || s2.setSelectedObject(t3, true);
        }
        null === (o2 = this._viewer) || void 0 === o2 || o2.scene.setDirty({ frameFade: false, sceneUpdate: true });
      }
    }
  };
  RC.PluginType = "ObjectRotationPlugin", IC([ie(), Oe("Enabled"), (0, t.onChange)(PC.prototype._paramsChanged)], RC.prototype, "enabled", void 0), IC([Ue("Rotation Count", [1, 100], 1, (e2) => ({ hidden: () => {
    var t2, n2;
    return !(null === (n2 = null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.getPluginByType("Picking")) || void 0 === n2 ? void 0 : n2.getSelectedObject()) || !e2.rotations;
  } })), (0, t.onChange)(PC.prototype._paramsChanged)], RC.prototype, "rotations", void 0), IC([Ne("Axis", ["x", "y", "z"].map((e2) => ({ label: e2 })), (e2) => ({ hidden: () => {
    var t2, n2;
    return !(null === (n2 = null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.getPluginByType("Picking")) || void 0 === n2 ? void 0 : n2.getSelectedObject()) || !e2.rotations;
  } })), (0, t.onChange)(PC.prototype._paramsChanged)], RC.prototype, "axis", void 0), IC([ze("Rotation Skips", (e2) => ({ hidden: () => {
    var t2, n2;
    return !(null === (n2 = null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.getPluginByType("Picking")) || void 0 === n2 ? void 0 : n2.getSelectedObject()) || !e2.rotations;
  } })), (0, t.onChange)(PC.prototype._paramsChanged)], RC.prototype, "skips", void 0), RC = PC = IC([We("Object Rotations")], RC);
  var kC, DC = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let BC = kC = class extends gt {
    constructor(e2 = true) {
      super(), this.enabled = true, this.debugNormals = false, this.debugHitHeight = false, this._defines = { PARALLAX_NORMAL_MAP_QUALITY: 0 }, this.stepCount = 12, this.binaryStepCount = 3, this._bumpMapExtension = { shaderExtender: (e3, t2, r2) => {
        if (t2.materialObject.bumpMap && this.enabled) {
          e3.fragmentShader = e3.fragmentShader.replace("#include <normal_fragment_begin>", ""), e3.fragmentShader = e3.fragmentShader.replace("#include <normal_fragment_maps>", ""), e3.fragmentShader = e3.fragmentShader.replace("#include <map_fragment>", "#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#include <map_fragment>");
          for (const t3 of ["map_fragment", "alphamap_fragment", "roughnessmap_fragment", "metalnessmap_fragment", "emissivemap_fragment", "transmission_fragment"])
            e3.fragmentShader = ot(e3.fragmentShader, `#include <${t3}>`, n.WdD[t3].replace(/\bv\w+Uv\b/g, "parallaxUv.xy", { replaceAll: true }));
          (this.debugNormals || this.debugHitHeight) && (e3.fragmentShader = ot(e3.fragmentShader, "texture2D( map, parallaxUv.xy )", this.debugNormals ? "vec4(normal, 1.); normal = geometryNormal" : "vec4(parallaxUv.z,0., 0., 1.)")), e3.fragmentShader = ot(e3.fragmentShader, "#include <normal_fragment_maps>", ot(ot(n.WdD.normal_fragment_maps, "#elif defined( USE_NORMALMAP_TANGENTSPACE )", "#elif defined( USE_NORMALMAP_TANGENTSPACE ) && !defined( USE_BUMPMAP )"), "normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );", "vec3 parallaxUv = reliefParallaxPerturbNormal(faceDirection, normal);"));
        }
      }, parsFragmentSnippet: () => this.enabled ? "#ifdef USE_BUMPMAP\nmat3 mat3_inverse(mat3 A){mat3 M_t=mat3(vec3(A[0][0],A[1][0],A[2][0]),vec3(A[0][1],A[1][1],A[2][1]),vec3(A[0][2],A[1][2],A[2][2]));float det=dot(cross(M_t[0],M_t[1]),M_t[2]);mat3 adjugate=mat3(cross(M_t[1],M_t[2]),cross(M_t[2],M_t[0]),cross(M_t[0],M_t[1]));return adjugate/det;}float CalculateHeight(in vec2 texCoords){float height=texture2D(bumpMap,texCoords).x;return clamp(height,0.,1.);}const vec2 bumpMapSize=vec2(512,512);vec3 CalculateNormal(in vec2 texCoords){\n#if defined( TANGENTSPACE_NORMALMAP ) && 0 \nvec3 mapN=texture2D(normalMap,texCoords).xyz;mapN.xy*=normalScale;return normalize(mapN);\n#else\nvec2 texOffs=1./bumpMapSize;\n#if PARALLAX_NORMAL_MAP_QUALITY > 0\nfloat hx[9];hx[0]=texture2D(bumpMap,texCoords.st+texOffs*vec2(-1.,-1.)).r;hx[1]=texture2D(bumpMap,texCoords.st+texOffs*vec2(0.,-1.)).r;hx[2]=texture2D(bumpMap,texCoords.st+texOffs*vec2(1.,-1.)).r;hx[3]=texture2D(bumpMap,texCoords.st+texOffs*vec2(-1.,0.)).r;hx[4]=texture2D(bumpMap,texCoords.st).r;hx[5]=texture2D(bumpMap,texCoords.st+texOffs*vec2(1.,0.)).r;hx[6]=texture2D(bumpMap,texCoords.st+texOffs*vec2(-1.,1.)).r;hx[7]=texture2D(bumpMap,texCoords.st+texOffs*vec2(0.,1.)).r;hx[8]=texture2D(bumpMap,texCoords.st+texOffs*vec2(1.,1.)).r;vec2 deltaH=vec2(hx[0]-hx[2]+2.*(hx[3]-hx[5])+hx[6]-hx[8],hx[0]-hx[6]+2.*(hx[1]-hx[7])+hx[2]-hx[8]);\n#else\nfloat h_xa=texture2D(bumpMap,texCoords.st+texOffs*vec2(-1.,0.)).r;float h_xb=texture2D(bumpMap,texCoords.st+texOffs*vec2(1.,0.)).r;float h_ya=texture2D(bumpMap,texCoords.st+texOffs*vec2(0.,-1.)).r;float h_yb=texture2D(bumpMap,texCoords.st+texOffs*vec2(0.,1.)).r;vec2 deltaH=vec2(h_xa-h_xb,h_ya-h_yb);\n#endif\nreturn normalize(vec3(deltaH/texOffs,1.));\n#endif\n}vec3 ReliefParallax(in float frontFace,in vec3 texDir3D,in vec2 texCoord){float surf_sign=frontFace;float back_face=step(0.,-surf_sign);vec2 texStep=surf_sign*texDir3D.xy/abs(texDir3D.z);vec2 texC=texCoord.st+surf_sign*texStep+back_face*texStep.xy;float mapHeight=1.;float bumpHeightStep=1./float(PARALLAX_MAP_STEPS);float bestBumpHeight=mapHeight+bumpHeightStep;\n#pragma unroll_loop_start\nfor(int i=0;i<PARALLAX_MAP_STEPS;i++){if(mapHeight<bestBumpHeight){bestBumpHeight-=bumpHeightStep;mapHeight=back_face+surf_sign*CalculateHeight(texC.xy-bestBumpHeight*texStep.xy);}}\n#pragma unroll_loop_end\nbestBumpHeight+=bumpHeightStep;\n#pragma unroll_loop_start\nfor(int i=0;i<PARALLAX_MAP_B_STEPS;i++){bumpHeightStep*=0.5;bestBumpHeight-=bumpHeightStep;mapHeight=back_face+surf_sign*CalculateHeight(texC.xy-bestBumpHeight*texStep.xy);bestBumpHeight+=(bestBumpHeight<mapHeight)?bumpHeightStep:0.;}\n#pragma unroll_loop_end\nbestBumpHeight-=bumpHeightStep*clamp((bestBumpHeight-mapHeight)/bumpHeightStep,0.,1.);mapHeight=bestBumpHeight;texC-=mapHeight*texStep;return vec3(texC.xy,mapHeight);}vec3 reliefParallaxPerturbNormal(in float faceDirection,inout vec3 normal){if(abs(bumpScale)<0.001)return vec3(vBumpMapUv,0.);float parallaxHeight;vec2 texCoords=vBumpMapUv;float face_sign=sign(dot(normal,vViewPosition));vec3 N=normalize(normal);vec3 dp1=dFdx(-vViewPosition);vec3 dp2=dFdy(-vViewPosition);vec2 duv1=dFdx(vBumpMapUv);vec2 duv2=dFdy(vBumpMapUv);vec3 dp2perp=cross(dp2,N);vec3 dp1perp=cross(N,dp1);vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;float invmax=inversesqrt(max(dot(T,T),dot(B,B)));mat3 tbnMat=mat3(T*invmax,B*invmax,N*bumpScale);vec3 tangentPos=normalize(mat3_inverse(tbnMat)*-vViewPosition);vec3 parallaxUv=ReliefParallax(face_sign,tangentPos,vBumpMapUv);tbnMat[2]=face_sign*N/bumpScale;normal=normalize(tbnMat*CalculateNormal(parallaxUv.xy).xyz);\n#ifdef FLIP_SIDED\nnormal=-normal;\n#endif\nreturn parallaxUv;}\n#endif \n\n".replaceAll("PARALLAX_MAP_STEPS", this._defines.PARALLAX_MAP_STEPS).replaceAll("PARALLAX_MAP_B_STEPS", this._defines.PARALLAX_MAP_B_STEPS) : "", isCompatible: (e3) => e3.isMeshStandardMaterial2, computeCacheKey: (e3) => {
        var t2;
        return this.enabled + " " + (null === (t2 = e3.materialObject.bumpMap) || void 0 === t2 ? void 0 : t2.uuid) + " " + this.debugNormals + " " + this.debugHitHeight + "  ";
      }, onObjectRender: (e3, { materialObject: t2 }, n2) => {
        if (this.enabled)
          for (const [e4, n3] of Object.entries(this._defines)) {
            const r2 = "number" == typeof n3 ? n3 : n3 ? 1 : 0;
            t2.defines[e4] !== r2 && (t2.defines[e4] = r2, t2.needsUpdate = true);
          }
      } }, this.dependencies = [Ls], this.enabled = e2, this._updateExtension = this._updateExtension.bind(this);
    }
    _updateExtension() {
      var e2, t2, n2;
      null === (t2 = null === (e2 = this._bumpMapExtension) || void 0 === e2 ? void 0 : e2.setDirty) || void 0 === t2 || t2.call(e2), null === (n2 = this._viewer) || void 0 === n2 || n2.setDirty();
    }
    async onAdded(e2) {
      var t2, n2;
      return null === (n2 = null === (t2 = e2.getPlugin(Ls)) || void 0 === t2 ? void 0 : t2.materials) || void 0 === n2 || n2.registerMaterialExtension(this._bumpMapExtension), super.onAdded(e2);
    }
    async onRemove(e2) {
      var t2, n2;
      return null === (n2 = null === (t2 = e2.getPlugin(Ls)) || void 0 === t2 ? void 0 : t2.materials) || void 0 === n2 || n2.unregisterMaterialExtension(this._bumpMapExtension), super.onRemove(e2);
    }
  };
  BC.PluginType = "ReliefParallaxMapping", DC([(0, t.onChange)(kC.prototype._updateExtension), ie(), Oe("Enabled")], BC.prototype, "enabled", void 0), DC([(0, t.onChange)(kC.prototype._updateExtension), Oe("Debug Normals")], BC.prototype, "debugNormals", void 0), DC([(0, t.onChange)(kC.prototype._updateExtension), Oe("Debug Hit Height")], BC.prototype, "debugHitHeight", void 0), DC([z("PARALLAX_MAP_STEPS", void 0, true, kC.prototype._updateExtension), Ue("Step count", [1, 32], 1), ie()], BC.prototype, "stepCount", void 0), DC([z("PARALLAX_MAP_B_STEPS", void 0, true, kC.prototype._updateExtension), Ue("Binary search steps", [1, 8], 1), ie()], BC.prototype, "binaryStepCount", void 0), BC = kC = DC([We("Parallax Mapping")], BC);
  class OC extends n.u9r {
    constructor(e2, t2, r2 = 32, i2 = 64, s2 = false, o2 = new n.FM8(1, 1), a2 = "shape") {
      super(), this.type = "TubeShapeGeometry", this.parameters = { path: t2, shape: e2, shapeSegments: r2, tubularSegments: i2, closed: s2, primary: a2, shapeScale: o2.clone() };
      const l2 = t2.computeFrenetFrames(i2, s2);
      this.frames = l2;
      const c2 = new n.Pa4(), u2 = new n.Pa4(), p2 = new n.Pa4(), d2 = new n.FM8();
      let h2 = new n.Pa4();
      const f2 = [], m2 = [], _2 = [], g2 = e2.getSpacedPoints(r2);
      for (const e3 of g2)
        e3.multiply(o2);
      !function() {
        for (let e3 = 0; e3 < i2; e3++)
          y2(e3);
        y2(false === s2 ? i2 : 0), function() {
          for (let e3 = 0; e3 <= i2; e3++)
            for (let t3 = 0; t3 <= r2; t3++)
              d2.x = e3 / i2, d2.y = t3 / r2, m2.push(d2.x, d2.y);
        }(), function() {
          const e3 = "shape" === a2, t3 = e3 ? r2 : i2, n2 = e3 ? i2 : r2;
          for (let i3 = 1; i3 <= t3; i3++)
            for (let t4 = 1; t4 <= n2; t4++) {
              const [n3, s3] = e3 ? [t4, i3] : [i3, t4], o3 = (r2 + 1) * (n3 - 1) + (s3 - 1), a3 = (r2 + 1) * n3 + (s3 - 1), l3 = (r2 + 1) * n3 + s3, c3 = (r2 + 1) * (n3 - 1) + s3;
              _2.push(o3, a3, c3), _2.push(a3, l3, c3);
            }
        }();
      }(), this.setIndex(_2), this.setAttribute("position", new n.a$l(f2, 3)), this.setAttribute("uv", new n.a$l(m2, 2)), this.computeVertexNormals();
      const v2 = this.attributes.normal;
      function y2(e3) {
        h2 = t2.getPointAt(e3 / i2, h2);
        const n2 = l2.normals[e3], s3 = l2.binormals[e3];
        for (let e4 = 0; e4 <= r2; e4++) {
          const t3 = g2[e4 % r2];
          u2.set(0, 0, 0).addScaledVector(n2, t3.x).addScaledVector(s3, t3.y), c2.copy(h2).add(u2), f2.push(c2.x, c2.y, c2.z);
        }
      }
      !function() {
        for (let e4 = 1; e4 < r2; e4++) {
          const t3 = e4 + i2 * (r2 + 1);
          u2.fromBufferAttribute(v2, e4), p2.fromBufferAttribute(v2, t3), u2.add(p2).normalize(), v2.setXYZ(e4, u2.x, u2.y, u2.z), v2.setXYZ(t3, u2.x, u2.y, u2.z);
        }
        for (let e4 = 1; e4 < i2; e4++) {
          const t3 = e4 * (r2 + 1), n2 = t3 + r2;
          u2.fromBufferAttribute(v2, t3), p2.fromBufferAttribute(v2, n2), u2.add(p2).normalize(), v2.setXYZ(t3, u2.x, u2.y, u2.z), v2.setXYZ(n2, u2.x, u2.y, u2.z);
        }
        u2.fromBufferAttribute(v2, 0), p2.fromBufferAttribute(v2, r2), u2.add(p2);
        const e3 = i2 * (r2 + 1);
        p2.fromBufferAttribute(v2, e3), u2.add(p2), p2.fromBufferAttribute(v2, e3 + r2), u2.add(p2), u2.normalize(), v2.setXYZ(0, u2.x, u2.y, u2.z), v2.setXYZ(r2, u2.x, u2.y, u2.z), v2.setXYZ(e3, u2.x, u2.y, u2.z), v2.setXYZ(e3 + r2, u2.x, u2.y, u2.z), v2.needsUpdate = true;
      }();
    }
    createSplits(e2) {
      this.clearGroups();
      const t2 = "shape" === this.parameters.primary ? this.parameters.shapeSegments : this.parameters.tubularSegments, n2 = this.index.count, r2 = [...e2, 1].sort((e3, t3) => e3 - t3);
      let i2 = 0, s2 = 0;
      for (const e3 of r2) {
        const r3 = Math.round(t2 * e3) * n2 / t2;
        this.addGroup(i2, r3 - i2, s2++), i2 = r3;
      }
      return this.groups.length;
    }
    toJSON() {
      const e2 = super.toJSON();
      return e2.path = this.parameters.path.toJSON(), e2.shape = this.parameters.shape.toJSON(), e2;
    }
  }
  var LC, UC = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let FC = LC = class extends gt {
    constructor() {
      super(...arguments), this.enabled = true, this.shapeSegments = 32, this.tubularSegments = 32, this.shapeScale = new n.FM8(1, 1), this.materialSplits = "0.3, 0.6", this.horizontalSplits = true, this.extrudeCirceTube = async () => {
        var e2, t2;
        const n2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPlugin(za)) || void 0 === t2 ? void 0 : t2.getSelectedObject();
        if (!n2)
          return;
        let r2 = this._viewer.prompt("Radius: Radius for the circle", "1", true);
        if (!r2)
          return;
        r2 = parseFloat(r2);
        const i2 = new NC(0, 0, r2, r2, 0, 2 * Math.PI, true, 0);
        await this.extrudeObject(n2, i2);
      };
    }
    async onAdded(e2) {
      await super.onAdded(e2);
    }
    static CreateCurve(e2, t2) {
      var n2, r2;
      if ("circle" === e2)
        return new NC(0, 0, null !== (n2 = t2.radius) && void 0 !== n2 ? n2 : 1, null !== (r2 = t2.radius) && void 0 !== r2 ? r2 : 1, 0, 2 * Math.PI, true, 0);
      throw new Error("Unknown curve type");
    }
    async extrudeObject(e2, t2, r2 = this.shapeSegments, i2 = this.tubularSegments, s2 = this.shapeScale, o2 = this.materialSplits.split(",").map((e3) => parseFloat(e3.trim())), a2 = this.horizontalSplits) {
      var l2, c2, u2, p2, d2, h2, f2, m2;
      if (e2.userData.isExtrudedTube, e2.userData._extrudeSource) {
        const t3 = e2.userData._extrudeSource;
        if (e2 = null === (l2 = e2.parent) || void 0 === l2 ? void 0 : l2.children.find((e3) => t3 === e3.uuid), !e2)
          return void console.warn("Could not find extrude source with uuid", t3);
      }
      if (e2.userData.extrudedObject) {
        const t3 = e2.userData.extrudedObject, n2 = null === (c2 = e2.parent) || void 0 === c2 ? void 0 : c2.children.find((e3) => t3 === e3.uuid);
        n2 && (n2.removeFromParent(), n2.geometry.dispose(), n2.geometry = null, n2.material = null), delete e2.userData.extrudedObject;
      }
      const _2 = e2.geometry;
      if (!_2)
        return void (null === (u2 = this._viewer) || void 0 === u2 || u2.alert("Extrude: No geometry to extrude"));
      const g2 = [e2.material];
      let v2;
      try {
        const e3 = LC.ConvertGeometryToFlatShape(_2);
        v2 = new OC(e3, t2, r2, i2, true, s2, a2 ? "shape" : "path"), v2.computeBoundingBox(), v2.createSplits(o2);
      } catch (e3) {
        return void (null === (p2 = this._viewer) || void 0 === p2 || p2.alert("string" == typeof e3 ? e3 : null == e3 ? void 0 : e3.message));
      }
      g2[0].color.set(16777215);
      for (let e3 = g2.length; e3 < v2.groups.length; e3++) {
        const e4 = g2[0].clone();
        g2.push(e4), e4.color.set(16777215 * Math.random());
      }
      const y2 = new n.Kj0(v2, g2);
      y2.userData._extrudeSource = e2.uuid, y2.userData.isExtrudedTube = true, e2.visible = false, e2.userData.bboxVisible = false, y2.name = e2.name + "_extruded";
      const b2 = await (null === (f2 = null === (h2 = null === (d2 = this._viewer) || void 0 === d2 ? void 0 : d2.getManager()) || void 0 === h2 ? void 0 : h2.importer) || void 0 === f2 ? void 0 : f2.processImportedSingle(y2, { autoCenter: false, autoScale: false }));
      b2 && (null === (m2 = e2.parent) || void 0 === m2 || m2.add(b2.modelObject), e2.userData.extrudedObject = b2.modelObject.uuid, b2.dispatchEvent({ type: "select", ui: true, value: b2 }));
    }
    static ExtrudeShape(e2, t2, r2, i2, s2, o2, a2, l2) {
      const c2 = new OC(e2, i2, t2, r2, true, new n.FM8(s2, o2), l2 ? "shape" : "path");
      c2.computeBoundingBox(), c2.createSplits(a2);
      const u2 = new n.Kj0(c2, []);
      return u2.userData.isExtrudedTube = true, u2;
    }
    static ConvertGeometryToFlatShape(e2, t2 = true) {
      if (e2.userData.__planarShape)
        return e2.userData.__planarShape;
      let r2 = e2.attributes.position;
      if (!r2)
        throw "no position attribute";
      if (r2.count > 500)
        throw "too large to extrude";
      const i2 = e2;
      r2 = i2.attributes.position, i2.boundingBox || i2.computeBoundingBox();
      const s2 = i2.boundingBox.getSize(new n.Pa4()), o2 = s2.x < 1e-3 ? "x" : s2.y < 1e-3 ? "y" : s2.z < 1e-3 ? "z" : null;
      if (!o2)
        throw "geometry is not axis aligned not planar";
      let a2 = [];
      for (let e3 = 0; e3 < r2.count; e3++) {
        const t3 = new n.FM8();
        "x" === o2 ? t3.set(r2.getY(e3), r2.getZ(e3)) : "y" === o2 ? t3.set(r2.getX(e3), r2.getZ(e3)) : t3.set(r2.getX(e3), r2.getY(e3)), a2.push(t3);
      }
      if (t2) {
        let e3 = 0;
        for (let t3 = 0; t3 < a2.length; t3++)
          (a2[t3].x < a2[e3].x || a2[t3].x === a2[e3].x && a2[t3].y < a2[e3].y) && (e3 = t3);
        0 !== e3 && (a2 = a2.slice(e3).concat(a2.slice(0, e3)));
      }
      const l2 = new n.bnF(a2);
      return e2.userData.__planarShape = l2, l2;
    }
  };
  FC.PluginType = "ShapeTubeExtrudePlugin", UC([Oe("Enabled")], FC.prototype, "enabled", void 0), UC([Ue("Shape Segments (X)", [1, 100], 1, (e2) => ({ hidden: () => {
    var t2, n2;
    return !(null === (n2 = null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(za)) || void 0 === n2 ? void 0 : n2.getSelectedObject());
  } }))], FC.prototype, "shapeSegments", void 0), UC([Ue("Tube Segments (Y)", [1, 100], 1, (e2) => ({ hidden: () => {
    var t2, n2;
    return !(null === (n2 = null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(za)) || void 0 === n2 ? void 0 : n2.getSelectedObject());
  } }))], FC.prototype, "tubularSegments", void 0), UC([Fe("Shape scale", [0.01, 10], 0.01, (e2) => ({ hidden: () => {
    var t2, n2;
    return !(null === (n2 = null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(za)) || void 0 === n2 ? void 0 : n2.getSelectedObject());
  } }))], FC.prototype, "shapeScale", void 0), UC([ze("Material Splits", (e2) => ({ hidden: () => {
    var t2, n2;
    return !(null === (n2 = null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(za)) || void 0 === n2 ? void 0 : n2.getSelectedObject());
  } }))], FC.prototype, "materialSplits", void 0), UC([Oe("Horizontal Splits", (e2) => ({ hidden: () => {
    var t2, n2;
    return !(null === (n2 = null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(za)) || void 0 === n2 ? void 0 : n2.getSelectedObject());
  } }))], FC.prototype, "horizontalSplits", void 0), UC([je("Extrude Circle Tube", (e2) => ({ hidden: () => {
    var t2, n2;
    return !(null === (n2 = null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(za)) || void 0 === n2 ? void 0 : n2.getSelectedObject());
  } }))], FC.prototype, "extrudeCirceTube", void 0), FC = LC = UC([We("Extrude Tube Shapes")], FC);
  class NC extends n.Ny0 {
    getPoint(e2, t2) {
      return super.getPoint(e2, t2 || new n.Pa4());
    }
  }
  class jC extends gt {
    constructor(e2 = true) {
      super(), this.enabled = true, this.toJSON = void 0, this.fromJSON = void 0, this._lastFrameTime = 0, this._updaters = [], this.dependencies = [], this._fadeDisabled = false, this.disableFrameFade = true, this._postFrame = () => {
        var e3, n2;
        if (!this._viewer)
          return;
        if (!this.enabled || Object.keys(this.animations).length < 1)
          return this._lastFrameTime = 0, void (this._fadeDisabled && (null === (e3 = this._viewer.getPluginByType("FrameFade")) || void 0 === e3 || e3.enable(jC.PluginType), this._fadeDisabled = false));
        const r2 = (0, t.now)() / 1e3;
        this._lastFrameTime < 1 && (this._lastFrameTime = r2 - 1 / 60);
        let i2 = r2 - this._lastFrameTime;
        this._lastFrameTime = r2;
        const s2 = null === (n2 = this._viewer.getPluginByType("Progressive")) || void 0 === n2 ? void 0 : n2.postFrameConvergedRecordingDelta();
        if (s2 && s2 > 0 && (i2 = s2), 0 !== s2 && (i2 *= 1e3, !(i2 <= 1e-3) && (this._updaters.forEach((e4) => {
          let t2 = i2;
          e4.time + t2 < 0 && (t2 = -e4.time), e4.time += t2, Math.abs(t2) > 1e-3 && e4.u(t2);
        }), !this._fadeDisabled && this.disableFrameFade))) {
          const e4 = this._viewer.getPluginByType("FrameFade");
          e4 && (e4.disable(jC.PluginType), this._fadeDisabled = true);
        }
      }, this.defaultDriver = (e3) => ({ start: () => this._updaters.push({ u: e3, time: 0 }), stop: () => this._updaters.splice(this._updaters.findIndex((t2) => t2.u === e3), 1) }), this.animations = {}, this.enabled = e2, this._postFrame = this._postFrame.bind(this);
    }
    async onAdded(e2) {
      await super.onAdded(e2), e2.addEventListener("postFrame", this._postFrame);
    }
    async onRemove(e2) {
      return e2.removeEventListener("postFrame", this._postFrame), super.onRemove(e2);
    }
    animate(e2) {
      const t2 = ke(), n2 = { id: t2, options: e2, stop: () => {
        var e3, n3, r2;
        (null === (e3 = this.animations[t2]) || void 0 === e3 ? void 0 : e3._stop) ? null === (r2 = null === (n3 = this.animations[t2]) || void 0 === n3 ? void 0 : n3._stop) || void 0 === r2 || r2.call(n3) : console.warn("Animation not started");
      } };
      return this.animations[t2] = n2, n2.promise = new Promise((n3, r2) => {
        const i2 = { driver: this.defaultDriver, ...e2, onComplete: () => {
          var t3;
          try {
            null === (t3 = e2.onComplete) || void 0 === t3 || t3.call(e2);
          } catch (e3) {
            return void r2(e3);
          }
          n3();
        }, onStop: () => {
          var t3;
          try {
            null === (t3 = e2.onStop) || void 0 === t3 || t3.call(e2);
          } catch (e3) {
            return void r2(e3);
          }
          n3();
        } }, s2 = kp(i2);
        this.animations[t2]._stop = s2.stop, this.animations[t2].options = i2;
      }).then(() => (delete this.animations[t2], t2)), this.animations[t2];
    }
    async animateAsync(e2) {
      return this.animate(e2).promise;
    }
  }
  jC.PluginType = "PopmotionPlugin";
  var zC, GC, VC = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  const HC = (e2) => ({ onChange: (t2) => {
    t2.last && e2.onChange();
  } });
  let QC = zC = class {
    constructor() {
      this.text = "Custom Text", this.fontSize = 100, this.width = 1024, this.height = 1024, this.xOffset = 0, this.yOffset = 0, this.boxWidth = 1024, this.boxHeight = 1024, this.textAnchor = "middle", this.fontFamily = "", this.fontPath = "", this.maskText = false, this.innerShadow = false, this.textColor = "#000000", this.bgFillColor = "#ffffff", this.svgBackground = "#ffffff", this.onChange = () => {
      };
    }
    set(e2) {
      Object.assign(this, e2);
    }
    reset() {
      const e2 = this.onChange;
      Object.assign(this, new zC()), this.onChange = e2;
    }
    toJSON() {
      return { text: this.text, fontFamily: this.fontFamily, fontPath: this.fontPath, svgBackground: this.svgBackground, width: this.width, height: this.height, xOffset: this.xOffset, yOffset: this.yOffset, boxWidth: this.boxWidth, boxHeight: this.boxHeight, fontSize: this.fontSize, maskText: this.maskText, innerShadow: this.innerShadow, bgFillColor: this.bgFillColor, textColor: this.textColor, textAnchor: this.textAnchor };
    }
  };
  VC([ze("Text", HC)], QC.prototype, "text", void 0), VC([Ue("Font Size", [2, 400], 1, HC)], QC.prototype, "fontSize", void 0), VC([Ue("Width", [2, 4096], 1, HC)], QC.prototype, "width", void 0), VC([Ue("Height", [2, 4096], 1, HC)], QC.prototype, "height", void 0), VC([Ue("X Offset", [-1024, 1024], 1, HC)], QC.prototype, "xOffset", void 0), VC([Ue("Y Offset", [-1024, 1024], 1, HC)], QC.prototype, "yOffset", void 0), VC([Ue("V-Width", [2, 4096], 1, HC)], QC.prototype, "boxWidth", void 0), VC([Ue("V-Height", [2, 4096], 1, HC)], QC.prototype, "boxHeight", void 0), VC([Ne("Text Anchor", ["start", "middle", "end"].map((e2) => ({ label: e2 })), HC)], QC.prototype, "textAnchor", void 0), VC([ze("Font", HC)], QC.prototype, "fontFamily", void 0), VC([ze("Font Url", HC)], QC.prototype, "fontPath", void 0), VC([Oe("Mask Text", HC)], QC.prototype, "maskText", void 0), VC([Oe("Inner Shadow", HC)], QC.prototype, "innerShadow", void 0), VC([Ge("Text Color", HC)], QC.prototype, "textColor", void 0), VC([Ge("BG Fill", HC)], QC.prototype, "bgFillColor", void 0), VC([Ge("SVG BG", HC)], QC.prototype, "svgBackground", void 0), QC = zC = VC([We("Text SVG Options")], QC);
  const WC = { woff: "woff", woff2: "woff2", ttf: "truetype", otf: "opentype", eot: "embedded-opentype" }, qC = (e2) => ({ hidden: () => {
    const t2 = e2.getSelected();
    return !t2 || !t2.userData[XC.PluginType];
  } });
  let XC = GC = class extends gt {
    async onAdded(e2) {
      var t2;
      await super.onAdded(e2), null === (t2 = e2.getPluginByType("Picking")) || void 0 === t2 || t2.addEventListener("selectedObjectChanged", this._selectedObjectChanged);
    }
    constructor() {
      super(), this.enabled = true, this.getSelected = () => {
        var e2, t2;
        return null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPluginByType("Picking")) || void 0 === t2 ? void 0 : t2.getSelectedObject();
      }, this.options = new QC(), this.applyToMap = true, this.applyToBumpMap = false, this.applyToAlphaMap = true, this.inverseAlphaMap = false, this._lastMeta = void 0, this.fonts = { roboto: "https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4mxKKTU1Kg.woff2" }, this._assetLoadOptions = void 0, this._selectedObjectChanged = this._selectedObjectChanged.bind(this), this.addTextToSelected = this.addTextToSelected.bind(this), this._paramsChanged = this._paramsChanged.bind(this), this.options.onChange = this._paramsChanged;
    }
    _selectedObjectChanged() {
      var e2, t2, n2, r2, i2, s2;
      if (!this.enabled)
        return;
      const o2 = this.getSelected();
      if (!o2)
        return void (null === (t2 = (e2 = this.uiConfig).uiRefresh) || void 0 === t2 || t2.call(e2, "postFrame", true));
      const a2 = o2.userData[GC.PluginType];
      if (!a2)
        return this.options.reset(), this._lastMeta = void 0, void (null === (r2 = (n2 = this.uiConfig).uiRefresh) || void 0 === r2 || r2.call(n2, "postFrame", true));
      this._lastMeta !== a2 && (this.options.set(a2), this._lastMeta = a2), null === (s2 = (i2 = this.uiConfig).uiRefresh) || void 0 === s2 || s2.call(i2, "postFrame", true);
    }
    _paramsChanged() {
      if (!this.enabled)
        return;
      const e2 = this.getSelected();
      e2 && e2.isMesh && e2.userData[GC.PluginType] && this.updateText(e2, this.options.toJSON());
    }
    async addTextToSelected() {
      var e2;
      const t2 = this.getSelected();
      t2 && t2.isMesh ? t2.material ? (t2.userData[GC.PluginType] || !t2.material.map || await (null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.confirm("Add Text: This mesh already has a texture. Adding text will replace the texture. Continue?"))) && await this.addText(t2) : console.error("no material on mesh") : console.error("no mesh is selected");
    }
    async addText(e2, t2) {
      return this.updateText(e2, Object.assign(this.options.toJSON(), t2));
    }
    async updateText(e2, t2) {
      var n2, r2;
      if (!e2.isMesh)
        return;
      if (!e2.material)
        return void console.error("updateText: no material on mesh");
      let i2 = e2.userData[GC.PluginType];
      i2 || (e2.userData[GC.PluginType] = i2 = {}), Object.assign(i2, t2);
      const s2 = e2.material;
      s2.map && (s2.map._isSimpleTextTexture && s2.map.dispose(), s2.map = void 0), s2.alphaMap && (s2.alphaMap._isSimpleTextTexture && s2.alphaMap.dispose(), s2.alphaMap = void 0), s2.bumpMap && (s2.bumpMap._isSimpleTextTexture && s2.bumpMap.dispose(), s2.bumpMap = void 0);
      const o2 = await this.makeTextSvg(i2);
      this.applyToMap && (s2.map = o2), this.applyToAlphaMap && (s2.alphaMap = o2, s2.transparent = true), this.applyToBumpMap && (s2.bumpMap = o2), s2.userData.inverseAlphaMap = this.inverseAlphaMap, s2.setDirty(), s2.needsUpdate = true, null === (r2 = (n2 = this.uiConfig).uiRefresh) || void 0 === r2 || r2.call(n2, "postFrame", true);
    }
    async makeTextSvg(e2) {
      const r2 = e2.fontFamily || "Arial", i2 = e2.fontPath || this.fonts[r2] || "";
      let s2 = e2.style;
      if (i2.length > 0) {
        const e3 = i2.split("?")[0].split(".").pop() || "woff";
        s2 += "\n" + (i2.length > 0 ? `
            @font-face {
                font-family: ${r2};
                src: url(${i2}) format(${WC[e3] || e3});
            }` : "");
      }
      let o2 = function({ text: e3 = "Custom Text", svgBackground: t2 = "#ffffff", xOffset: n2 = 0, yOffset: r3 = 0, width: i3 = 1024, height: s3 = 1024, boxWidth: o3 = 1024, boxHeight: a3 = 1024, fontFamily: l2 = "", fontSize: c2 = 32, maskText: u2 = true, innerShadow: p2 = true, bgFillColor: d2 = "#000000", textColor: h2 = "#ffffff", textAnchor: f2 = "middle", style: m2 = "" }) {
        return `
<svg style="background-color:${t2}" width="${i3}" height="${s3}" viewBox="0 0 ${o3} ${a3}"
 xmlns="http://www.w3.org/2000/svg"
 xmlns:xlink="http://www.w3.org/1999/xlink">
     <defs>
        <style>
        ${m2}
        </style>
    </defs>

    <g style="overflow:hidden; text-anchor: ${f2}; font-size: ${c2}px; font-family: ${l2 || "Arial"}">
        <defs>

` + (u2 ? `
<mask id="textMask">
<text style="fill:white; font-size: ${c2}px;" x="${n2 + o3 / 2}" y="${a3 / 2 + r3 + c2 / 4}" > ${e3} </text>
</mask>
` : "") + "\n\n" + (p2 ? '\n<filter id="innerShadow" x="-20%" y="-20%" width="140%" height="140%">\n<feGaussianBlur in="SourceGraphic" stdDeviation="0.5" result="blur"/>\n<feOffset in="blur" dx="1.5" dy="1.5"/>\n</filter>\n' : "") + "\n\n        </defs>\n\n" + (u2 ? '\n        <g mask="url(#textMask)">\n' : "") + `

        <rect x="0" y="0" width="${o3}" height="${a3}" style="fill:${d2}"/>
        <text style="${p2 ? "filter: url(#innerShadow);" : ""} fill:${h2};" x="${n2 + o3 / 2}" y="${a3 / 2 + r3 + c2 / 4}"> ${e3} </text>

` + (u2 ? "\n        </g>\n" : "") + "\n\n    </g>\n</svg>\n";
      }({ ...e2, fontFamily: r2, style: s2 });
      o2 = await (0, t.embedUrlRefs)(o2, async (e3) => this._getAssetData(e3)), o2 = (0, t.svgUrl)(o2);
      const a2 = await this._viewer.getManager().importer.importSinglePath(o2, { generateMipmaps: false, minFilter: n.wem });
      return a2._isSimpleTextTexture = true, a2.flipY = false, a2.needsUpdate = true, a2;
    }
    async _getAssetData(e2) {
      var t2, n2;
      if (e2.startsWith("http://www.w3.org"))
        return e2;
      const r2 = null === (n2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getManager()) || void 0 === n2 ? void 0 : n2.importer;
      if (!r2)
        throw new Error("no importer");
      this._assetLoadOptions = this._assetLoadOptions || { fileHandler: new ry(r2.loadingManager), processImported: false };
      try {
        return await r2.importPath(e2, this._assetLoadOptions);
      } catch (e3) {
        return console.error(e3), "";
      }
    }
  };
  XC.PluginType = "SimpleTextPlugin", VC([Be(void 0, { params: qC })], XC.prototype, "options", void 0), VC([Oe("Apply Map", qC), (0, t.onChange)(GC.prototype._paramsChanged), ie()], XC.prototype, "applyToMap", void 0), VC([Oe("Apply Bump Map", qC), (0, t.onChange)(GC.prototype._paramsChanged), ie()], XC.prototype, "applyToBumpMap", void 0), VC([Oe("Apply Alpha Map", qC), (0, t.onChange)(GC.prototype._paramsChanged), ie()], XC.prototype, "applyToAlphaMap", void 0), VC([Oe("Invert Alpha Map", qC), (0, t.onChange)(GC.prototype._paramsChanged), ie()], XC.prototype, "inverseAlphaMap", void 0), VC([je("Add Text", (e2) => ({ hidden: () => !e2.getSelected() }))], XC.prototype, "addTextToSelected", null), XC = GC = VC([We("Simple Text")], XC);
  class YC {
    constructor(e2) {
      this.top = 0, this.array = new Float32Array(e2);
    }
    write(e2) {
      this.array[this.top++] = e2.x, this.array[this.top++] = e2.y, this.array[this.top++] = e2.z;
    }
  }
  class KC {
    constructor(e2) {
      this.top = 0, this.array = new Float32Array(e2);
    }
    write(e2) {
      this.array[this.top++] = e2.x, this.array[this.top++] = e2.y;
    }
  }
  class JC {
    constructor(e2) {
      this.plane = null, this.front = null, this.back = null, this.polygons = [], e2 && this.build(e2);
    }
    clone() {
      const e2 = new JC();
      return e2.plane = this.plane && this.plane.clone(), e2.front = this.front && this.front.clone(), e2.back = this.back && this.back.clone(), e2.polygons = this.polygons.map((e3) => e3.clone()), e2;
    }
    invert() {
      for (let e3 = 0; e3 < this.polygons.length; e3++)
        this.polygons[e3].flip();
      this.plane && this.plane.flip(), this.front && this.front.invert(), this.back && this.back.invert();
      const e2 = this.front;
      this.front = this.back, this.back = e2;
    }
    clipPolygons(e2) {
      if (!this.plane)
        return e2.slice();
      let t2 = new Array(), n2 = new Array();
      for (let r2 = 0; r2 < e2.length; r2++)
        this.plane.splitPolygon(e2[r2], t2, n2, t2, n2);
      return this.front && (t2 = this.front.clipPolygons(t2)), n2 = this.back ? this.back.clipPolygons(n2) : [], t2.concat(n2);
    }
    clipTo(e2) {
      this.polygons = e2.clipPolygons(this.polygons), this.front && this.front.clipTo(e2), this.back && this.back.clipTo(e2);
    }
    allPolygons() {
      let e2 = this.polygons.slice();
      return this.front && (e2 = e2.concat(this.front.allPolygons())), this.back && (e2 = e2.concat(this.back.allPolygons())), e2;
    }
    build(e2) {
      if (!e2.length)
        return;
      this.plane || (this.plane = e2[0].plane.clone());
      const t2 = [], n2 = [];
      for (let r2 = 0; r2 < e2.length; r2++)
        this.plane.splitPolygon(e2[r2], this.polygons, this.polygons, t2, n2);
      t2.length && (this.front || (this.front = new JC()), this.front.build(t2)), n2.length && (this.back || (this.back = new JC()), this.back.build(n2));
    }
  }
  class ZC {
    constructor(e2 = 0, t2 = 0, n2 = 0) {
      this.x = e2, this.y = t2, this.z = n2;
    }
    copy(e2) {
      return this.x = e2.x, this.y = e2.y, this.z = e2.z, this;
    }
    clone() {
      return new ZC(this.x, this.y, this.z);
    }
    negate() {
      return this.x *= -1, this.y *= -1, this.z *= -1, this;
    }
    add(e2) {
      return this.x += e2.x, this.y += e2.y, this.z += e2.z, this;
    }
    sub(e2) {
      return this.x -= e2.x, this.y -= e2.y, this.z -= e2.z, this;
    }
    times(e2) {
      return this.x *= e2, this.y *= e2, this.z *= e2, this;
    }
    dividedBy(e2) {
      return this.x /= e2, this.y /= e2, this.z /= e2, this;
    }
    lerp(e2, t2) {
      return this.add(new ZC().copy(e2).sub(this).times(t2));
    }
    unit() {
      return this.dividedBy(this.length());
    }
    length() {
      return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2) + Math.pow(this.z, 2));
    }
    normalize() {
      return this.unit();
    }
    cross(e2) {
      const t2 = this.clone(), n2 = t2.x, r2 = t2.y, i2 = t2.z, s2 = e2.x, o2 = e2.y, a2 = e2.z;
      return this.x = r2 * a2 - i2 * o2, this.y = i2 * s2 - n2 * a2, this.z = n2 * o2 - r2 * s2, this;
    }
    dot(e2) {
      return this.x * e2.x + this.y * e2.y + this.z * e2.z;
    }
    toVector3() {
      return new n.Pa4(this.x, this.y, this.z);
    }
  }
  class $C {
    constructor(e2, t2) {
      this.normal = e2, this.w = t2, this.normal = e2, this.w = t2;
    }
    clone() {
      return new $C(this.normal.clone(), this.w);
    }
    flip() {
      this.normal.negate(), this.w = -this.w;
    }
    splitPolygon(e2, t2, n2, r2, i2) {
      let s2 = 0;
      const o2 = [];
      for (let t3 = 0; t3 < e2.vertices.length; t3++) {
        const n3 = this.normal.dot(e2.vertices[t3].pos) - this.w, r3 = n3 < -$C.EPSILON ? 2 : n3 > $C.EPSILON ? 1 : 0;
        s2 |= r3, o2.push(r3);
      }
      switch (s2) {
        case 0:
          (this.normal.dot(e2.plane.normal) > 0 ? t2 : n2).push(e2);
          break;
        case 1:
          r2.push(e2);
          break;
        case 2:
          i2.push(e2);
          break;
        case 3: {
          const t3 = [], n3 = [];
          for (let r3 = 0; r3 < e2.vertices.length; r3++) {
            const i3 = (r3 + 1) % e2.vertices.length, s3 = o2[r3], a2 = o2[i3], l2 = e2.vertices[r3], c2 = e2.vertices[i3];
            if (2 != s3 && t3.push(l2), 1 != s3 && n3.push(2 != s3 ? l2.clone() : l2), 3 == (s3 | a2)) {
              const e3 = (this.w - this.normal.dot(l2.pos)) / this.normal.dot(new ZC().copy(c2.pos).sub(l2.pos)), r4 = l2.interpolate(c2, e3);
              t3.push(r4), n3.push(r4.clone());
            }
          }
          t3.length >= 3 && r2.push(new eS(t3, e2.shared)), n3.length >= 3 && i2.push(new eS(n3, e2.shared));
          break;
        }
      }
    }
    static fromPoints(e2, t2, n2) {
      const r2 = new ZC().copy(t2).sub(e2).cross(new ZC().copy(n2).sub(e2)).normalize();
      return new $C(r2.clone(), r2.dot(e2));
    }
  }
  $C.EPSILON = 1e-5;
  class eS {
    constructor(e2, t2) {
      this.vertices = e2, this.shared = t2, this.plane = $C.fromPoints(e2[0].pos, e2[1].pos, e2[2].pos);
    }
    clone() {
      return new eS(this.vertices.map((e2) => e2.clone()), this.shared);
    }
    flip() {
      this.vertices.reverse().map((e2) => e2.flip()), this.plane.flip();
    }
  }
  class tS {
    constructor(e2, t2, n2, r2) {
      this.pos = new ZC().copy(e2), this.normal = new ZC().copy(t2), this.uv = new ZC().copy(n2), this.uv.z = 0, r2 && (this.color = new ZC().copy(r2));
    }
    clone() {
      return new tS(this.pos, this.normal, this.uv, this.color);
    }
    flip() {
      this.normal.negate();
    }
    interpolate(e2, t2) {
      return new tS(this.pos.clone().lerp(e2.pos, t2), this.normal.clone().lerp(e2.normal, t2), this.uv.clone().lerp(e2.uv, t2), this.color && e2.color && this.color.clone().lerp(e2.color, t2));
    }
  }
  class nS {
    constructor() {
      this.polygons = new Array();
    }
    static fromPolygons(e2) {
      const t2 = new nS();
      return t2.polygons = e2, t2;
    }
    static fromGeometry(e2, t2) {
      let n2 = [];
      const r2 = e2.attributes.position, i2 = e2.attributes.normal, s2 = e2.attributes.uv, o2 = e2.attributes.color, a2 = e2.groups;
      let l2;
      if (e2.index)
        l2 = e2.index.array;
      else {
        l2 = new Array(r2.array.length / r2.itemSize | 0);
        for (let e3 = 0; e3 < l2.length; e3++)
          l2[e3] = e3;
      }
      const c2 = l2.length / 3 | 0;
      n2 = new Array(c2);
      for (let e3 = 0, c3 = 0, u2 = l2.length; e3 < u2; e3 += 3, c3++) {
        const u3 = new Array(3);
        for (let t3 = 0; t3 < 3; t3++) {
          const n3 = l2[e3 + t3], a3 = 3 * n3, c4 = 2 * n3, p2 = r2.array[a3], d2 = r2.array[a3 + 1], h2 = r2.array[a3 + 2], f2 = i2.array[a3], m2 = i2.array[a3 + 1], _2 = i2.array[a3 + 2], g2 = null == s2 ? void 0 : s2.array[c4], v2 = null == s2 ? void 0 : s2.array[c4 + 1];
          u3[t3] = new tS(new ZC(p2, d2, h2), new ZC(f2, m2, _2), new ZC(g2, v2, 0), o2 && new ZC(o2.array[c4], o2.array[c4 + 1], o2.array[c4 + 2]));
        }
        if (void 0 === t2 && a2 && a2.length > 0)
          for (const t3 of a2)
            e3 >= t3.start && e3 < t3.start + t3.count && (n2[c3] = new eS(u3, t3.materialIndex));
        else
          n2[c3] = new eS(u3, t2);
      }
      return nS.fromPolygons(n2.filter((e3) => !isNaN(e3.plane.normal.x)));
    }
    static toGeometry(e2, t2) {
      let r2 = 0;
      const i2 = e2.polygons;
      for (const e3 of i2)
        r2 += e3.vertices.length - 2;
      const s2 = new n.u9r(), o2 = new YC(3 * r2 * 3), a2 = new YC(3 * r2 * 3), l2 = new KC(2 * r2 * 3);
      let c2;
      const u2 = [], p2 = [];
      for (const e3 of i2) {
        const t3 = e3.vertices, n2 = t3.length;
        void 0 !== e3.shared && (u2[e3.shared] || (u2[e3.shared] = [])), n2 && void 0 !== t3[0].color && (c2 || (c2 = new YC(3 * r2 * 3)));
        for (let r3 = 3; r3 <= n2; r3++)
          (void 0 === e3.shared ? p2 : u2[e3.shared]).push(o2.top / 3, o2.top / 3 + 1, o2.top / 3 + 2), o2.write(t3[0].pos), o2.write(t3[r3 - 2].pos), o2.write(t3[r3 - 1].pos), a2.write(t3[0].normal), a2.write(t3[r3 - 2].normal), a2.write(t3[r3 - 1].normal), l2 && (l2.write(t3[0].uv), l2.write(t3[r3 - 2].uv), l2.write(t3[r3 - 1].uv)), c2 && (c2.write(t3[0].color), c2.write(t3[r3 - 2].color), c2.write(t3[r3 - 1].color));
      }
      s2.setAttribute("position", new n.TlE(o2.array, 3)), s2.setAttribute("normal", new n.TlE(a2.array, 3)), l2 && s2.setAttribute("uv", new n.TlE(l2.array, 2)), c2 && s2.setAttribute("color", new n.TlE(c2.array, 3));
      for (let e3 = 0; e3 < u2.length; e3++)
        void 0 === u2[e3] && (u2[e3] = []);
      if (u2.length) {
        let e3 = [], t3 = 0;
        for (let n2 = 0; n2 < u2.length; n2++)
          s2.addGroup(t3, u2[n2].length, n2), t3 += u2[n2].length, e3 = e3.concat(u2[n2]);
        s2.addGroup(t3, p2.length, u2.length), e3 = e3.concat(p2), s2.setIndex(e3);
      }
      const d2 = new n.yGw().copy(t2).invert();
      return s2.applyMatrix4(d2), s2.computeBoundingSphere(), s2.computeBoundingBox(), s2;
    }
    static fromMesh(e2, t2) {
      const r2 = nS.fromGeometry(e2.geometry, t2), i2 = new n.Pa4(), s2 = new n.Vkp();
      s2.getNormalMatrix(e2.matrix);
      for (let t3 = 0; t3 < r2.polygons.length; t3++) {
        const n2 = r2.polygons[t3];
        for (let t4 = 0; t4 < n2.vertices.length; t4++) {
          const r3 = n2.vertices[t4];
          r3.pos.copy(i2.copy(r3.pos.toVector3()).applyMatrix4(e2.matrix)), r3.normal.copy(i2.copy(r3.normal.toVector3()).applyMatrix3(s2));
        }
      }
      return r2;
    }
    static toMesh(e2, t2, r2) {
      const i2 = nS.toGeometry(e2, t2), s2 = new n.Kj0(i2, r2);
      return s2.matrix.copy(t2), s2.matrix.decompose(s2.position, s2.quaternion, s2.scale), s2.rotation.setFromQuaternion(s2.quaternion), s2.updateMatrixWorld(), s2.castShadow = s2.receiveShadow = true, s2;
    }
    static union(e2, t2) {
      const n2 = nS.fromMesh(e2), r2 = nS.fromMesh(t2);
      return nS.toMesh(n2.union(r2), e2.matrix, e2.material);
    }
    static subtract(e2, t2) {
      const n2 = nS.fromMesh(e2), r2 = nS.fromMesh(t2);
      return nS.toMesh(n2.subtract(r2), e2.matrix, e2.material);
    }
    static intersect(e2, t2) {
      const n2 = nS.fromMesh(e2), r2 = nS.fromMesh(t2);
      return nS.toMesh(n2.intersect(r2), e2.matrix, e2.material);
    }
    clone() {
      const e2 = new nS();
      return e2.polygons = this.polygons.map((e3) => e3.clone()).filter((e3) => Number.isFinite(e3.plane.w)), e2;
    }
    toPolygons() {
      return this.polygons;
    }
    union(e2) {
      const t2 = new JC(this.clone().polygons), n2 = new JC(e2.clone().polygons);
      return t2.clipTo(n2), n2.clipTo(t2), n2.invert(), n2.clipTo(t2), n2.invert(), t2.build(n2.allPolygons()), nS.fromPolygons(t2.allPolygons());
    }
    subtract(e2) {
      const t2 = new JC(this.clone().polygons), n2 = new JC(e2.clone().polygons);
      return t2.invert(), t2.clipTo(n2), n2.clipTo(t2), n2.invert(), n2.clipTo(t2), n2.invert(), t2.build(n2.allPolygons()), t2.invert(), nS.fromPolygons(t2.allPolygons());
    }
    intersect(e2) {
      const t2 = new JC(this.clone().polygons), n2 = new JC(e2.clone().polygons);
      return t2.invert(), n2.clipTo(t2), n2.invert(), t2.clipTo(n2), n2.clipTo(t2), t2.build(n2.allPolygons()), t2.invert(), nS.fromPolygons(t2.allPolygons());
    }
    inverse() {
      const e2 = this.clone();
      for (const t2 of e2.polygons)
        t2.flip();
      return e2;
    }
    toMesh(e2, t2) {
      return nS.toMesh(this, e2, t2);
    }
    toGeometry(e2) {
      return nS.toGeometry(this, e2);
    }
  }
  var rS = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  const iS = ["union", "subtract", "intersect"];
  class sS extends gt {
    constructor() {
      super(), this.enabled = true, this.toJSON = void 0, this.dependencies = [za], this.rootMesh = new n.Kj0(), this.showResult = false, this.csgSelectedEnabled = false, this.csgSelectedOperation = "union", this._csgNeedsUpdate = false, this._csgVisible = false, this._sceneUpdate = this._sceneUpdate.bind(this), this._preFrame = this._preFrame.bind(this), this.makeSelectedCSGBrush = this.makeSelectedCSGBrush.bind(this), this.refreshCSG = this.refreshCSG.bind(this), this._selectedObjectChanged = this._selectedObjectChanged.bind(this), this._updateSelectedProperties = this._updateSelectedProperties.bind(this), this.downloadObject = this.downloadObject.bind(this), this.exportObject = this.exportObject.bind(this);
    }
    async onAdded(e2) {
      var t2;
      await super.onAdded(e2), this.rootObject = await e2.createObject3D(), this.rootObject.modelObject.add(this.rootMesh), e2.scene.addEventListener("sceneUpdate", this._sceneUpdate), e2.addEventListener("preFrame", this._preFrame), null === (t2 = e2.getPlugin(za)) || void 0 === t2 || t2.addEventListener("selectedObjectChanged", this._selectedObjectChanged);
    }
    async makeSelectedCSGBrush() {
      var e2, t2;
      const n2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPlugin(za)) || void 0 === t2 ? void 0 : t2.getSelectedObject();
      n2 && n2.geometry && (n2.userData._isCSGMesh || (n2.userData.csgBrush || (n2.userData.csgBrush = { enabled: true, operation: "union" }), this._selectedObjectChanged()));
    }
    refreshCSG() {
      this._sceneUpdate();
    }
    async downloadObject() {
      const e2 = await this.exportObject();
      e2 && (0, t.downloadBlob)(e2, "csg." + e2.ext);
    }
    async exportObject() {
      var e2, t2;
      const n2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPluginByType("AssetExporterPlugin")) || void 0 === t2 ? void 0 : t2.exporter;
      if (!n2 || !this.rootObject)
        return;
      const r2 = this.rootMesh.visible;
      this.rootMesh.visible = true;
      const i2 = await n2.exportObject(this.rootObject.modelObject, {});
      return this.rootMesh.visible = r2, i2;
    }
    _updateSelectedProperties() {
      var e2, t2;
      const n2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPlugin(za)) || void 0 === t2 ? void 0 : t2.getSelectedObject();
      n2 && n2.userData.csgBrush && (n2.userData.csgBrush.enabled = this.csgSelectedEnabled, n2.userData.csgBrush.operation = this.csgSelectedOperation);
    }
    _selectedObjectChanged() {
      var e2, t2, n2, r2, i2, s2, o2, a2;
      const l2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPlugin(za)) || void 0 === t2 ? void 0 : t2.getSelectedObject();
      l2 && (this.csgSelectedEnabled = null !== (r2 = null === (n2 = l2.userData.csgBrush) || void 0 === n2 ? void 0 : n2.enabled) && void 0 !== r2 && r2, this.csgSelectedOperation = null !== (s2 = null === (i2 = l2.userData.csgBrush) || void 0 === i2 ? void 0 : i2.operation) && void 0 !== s2 ? s2 : "union"), null === (a2 = null === (o2 = this.uiConfig) || void 0 === o2 ? void 0 : o2.uiRefresh) || void 0 === a2 || a2.call(o2, "postFrame", true);
    }
    _preFrame() {
      var e2, t2, n2;
      if (!this.rootObject)
        return;
      if (!this._csgNeedsUpdate && this._csgVisible === this.showResult)
        return;
      const r2 = this._findCSGMeshes();
      this._csgNeedsUpdate && (this._csgNeedsUpdate = false, null === (e2 = this.rootObject) || void 0 === e2 || e2.modelObject.updateMatrixWorld(true), (null !== (t2 = this.rootMesh.userData.dispose) && void 0 !== t2 ? t2 : this.rootMesh.removeFromParent)(), this.rootMesh = this._buildCSGMesh(r2)), this.rootMesh && !this.rootMesh.parent && (null === (n2 = this.rootObject) || void 0 === n2 || n2.modelObject.add(this.rootMesh)), this.showResult ? (r2.forEach((e3) => {
        e3[0].visible = false;
      }), this.rootObject.visible = true, this._csgVisible = true, this.rootObject.setDirty()) : (r2.forEach((e3) => {
        e3[0].visible = true;
      }), this.rootObject.visible = false, this._csgVisible = false, this.rootObject.setDirty());
    }
    _findCSGMeshes() {
      var e2;
      const t2 = [];
      return null === (e2 = this._viewer) || void 0 === e2 || e2.scene.traverse((e3) => {
        var n2;
        e3.isMesh && e3.geometry && (null === (n2 = e3.userData.csgBrush) || void 0 === n2 ? void 0 : n2.enabled) && t2.push([e3, e3.userData.csgBrush.operation]);
      }), t2;
    }
    _sceneUpdate(e2) {
      var t2, n2;
      (null === (n2 = null === (t2 = null == e2 ? void 0 : e2.object) || void 0 === t2 ? void 0 : t2.userData) || void 0 === n2 ? void 0 : n2._isCSGMesh) || (this._csgNeedsUpdate = true);
    }
  }
  rS([Oe("Show Result", (e2) => ({ onChange: () => {
    var t2;
    return null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.setDirty();
  } }))], sS.prototype, "showResult", void 0), rS([je("Make CSG Brush", (e2) => ({ hidden: () => {
    var t2, n2;
    const r2 = null === (n2 = null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(za)) || void 0 === n2 ? void 0 : n2.getSelectedObject();
    return !(null == r2 ? void 0 : r2.userData) || !!r2.userData.csgBrush || r2.userData._isCSGMesh;
  } }))], sS.prototype, "makeSelectedCSGBrush", null), rS([Oe("Enabled", (e2) => ({ hidden: () => {
    var t2, n2;
    const r2 = null === (n2 = null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(za)) || void 0 === n2 ? void 0 : n2.getSelectedObject();
    return !r2 || !r2.userData.csgBrush;
  }, onChange: e2._updateSelectedProperties }))], sS.prototype, "csgSelectedEnabled", void 0), rS([Ne("Operation", iS.map((e2) => ({ label: e2 })), (e2) => ({ hidden: () => {
    var t2, n2;
    const r2 = null === (n2 = null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(za)) || void 0 === n2 ? void 0 : n2.getSelectedObject();
    return !r2 || !r2.userData.csgBrush;
  }, onChange: e2._updateSelectedProperties }))], sS.prototype, "csgSelectedOperation", void 0), rS([je("Refresh CSG")], sS.prototype, "refreshCSG", null), rS([je("Export Result", (e2) => ({ hidden: () => {
    var t2;
    return !(null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.getPluginByType("AssetExporterPlugin"));
  } }))], sS.prototype, "downloadObject", null);
  function oS(e2, t2) {
    let r2 = new nS();
    const i2 = e2.map((e3) => e3[0].material).flatMap((e3) => e3);
    e2.forEach(([e3, t3]) => {
      if (!iS.includes(t3))
        return void console.error(`Unknown operation ${t3}`);
      e3.updateMatrix(), e3.updateMatrixWorld();
      const n2 = e3.matrix;
      e3.matrix = e3.matrixWorld;
      let s3 = 0;
      s3 = Array.isArray(e3.material) ? void 0 : i2.indexOf(e3.material), r2 = r2[t3](nS.fromMesh(e3, s3)), e3.matrix = n2;
    });
    const s2 = r2.toMesh(null != t2 ? t2 : new n.yGw().identity(), i2);
    return s2.userData._isCSGMesh = true, s2.geometry.groups = s2.geometry.groups.filter((e3) => e3.count > 0), s2;
  }
  let aS = class extends sS {
    _buildCSGMesh(e2) {
      return oS(e2);
    }
  };
  aS.PluginType = "CSGPluginBSP", aS = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  }([We("CSG Plugin (BSP)")], aS);
  const lS = 0, cS = 1, uS = 3, pS = 4;
  class dS {
    constructor() {
      this.min = 1 / 0, this.max = -1 / 0;
    }
    setFromPointsField(e2, t2) {
      let n2 = 1 / 0, r2 = -1 / 0;
      for (let i2 = 0, s2 = e2.length; i2 < s2; i2++) {
        const s3 = e2[i2][t2];
        n2 = s3 < n2 ? s3 : n2, r2 = s3 > r2 ? s3 : r2;
      }
      this.min = n2, this.max = r2;
    }
    setFromPoints(e2, t2) {
      let n2 = 1 / 0, r2 = -1 / 0;
      for (let i2 = 0, s2 = t2.length; i2 < s2; i2++) {
        const s3 = t2[i2], o2 = e2.dot(s3);
        n2 = o2 < n2 ? o2 : n2, r2 = o2 > r2 ? o2 : r2;
      }
      this.min = n2, this.max = r2;
    }
    isSeparated(e2) {
      return this.min > e2.max || e2.min > this.max;
    }
  }
  dS.prototype.setFromBox = function() {
    const e2 = new n.Pa4();
    return function(t2, n2) {
      const r2 = n2.min, i2 = n2.max;
      let s2 = 1 / 0, o2 = -1 / 0;
      for (let n3 = 0; n3 <= 1; n3++)
        for (let a2 = 0; a2 <= 1; a2++)
          for (let l2 = 0; l2 <= 1; l2++) {
            e2.x = r2.x * n3 + i2.x * (1 - n3), e2.y = r2.y * a2 + i2.y * (1 - a2), e2.z = r2.z * l2 + i2.z * (1 - l2);
            const c2 = t2.dot(e2);
            s2 = Math.min(c2, s2), o2 = Math.max(c2, o2);
          }
      this.min = s2, this.max = o2;
    };
  }(), new dS();
  const hS = function() {
    const e2 = new n.Pa4(), t2 = new n.Pa4(), r2 = new n.Pa4();
    return function(n2, i2, s2) {
      const o2 = n2.start, a2 = e2, l2 = i2.start, c2 = t2;
      r2.subVectors(o2, l2), e2.subVectors(n2.end, n2.start), t2.subVectors(i2.end, i2.start);
      const u2 = r2.dot(c2), p2 = c2.dot(a2), d2 = c2.dot(c2), h2 = r2.dot(a2), f2 = a2.dot(a2) * d2 - p2 * p2;
      let m2, _2;
      m2 = 0 !== f2 ? (u2 * p2 - h2 * d2) / f2 : 0, _2 = (u2 + m2 * p2) / d2, s2.x = m2, s2.y = _2;
    };
  }(), fS = function() {
    const e2 = new n.FM8(), t2 = new n.Pa4(), r2 = new n.Pa4();
    return function(n2, i2, s2, o2) {
      hS(n2, i2, e2);
      let a2 = e2.x, l2 = e2.y;
      if (a2 >= 0 && a2 <= 1 && l2 >= 0 && l2 <= 1)
        return n2.at(a2, s2), void i2.at(l2, o2);
      if (a2 >= 0 && a2 <= 1)
        return l2 < 0 ? i2.at(0, o2) : i2.at(1, o2), void n2.closestPointToPoint(o2, true, s2);
      if (l2 >= 0 && l2 <= 1)
        return a2 < 0 ? n2.at(0, s2) : n2.at(1, s2), void i2.closestPointToPoint(s2, true, o2);
      {
        let e3, c2;
        e3 = a2 < 0 ? n2.start : n2.end, c2 = l2 < 0 ? i2.start : i2.end;
        const u2 = t2, p2 = r2;
        return n2.closestPointToPoint(c2, true, t2), i2.closestPointToPoint(e3, true, r2), u2.distanceToSquared(c2) <= p2.distanceToSquared(e3) ? (s2.copy(u2), void o2.copy(c2)) : (s2.copy(e3), void o2.copy(p2));
      }
    };
  }(), mS = function() {
    const e2 = new n.Pa4(), t2 = new n.Pa4(), r2 = new n.JOQ(), i2 = new n.Zzh();
    return function(n2, s2) {
      const { radius: o2, center: a2 } = n2, { a: l2, b: c2, c: u2 } = s2;
      if (i2.start = l2, i2.end = c2, i2.closestPointToPoint(a2, true, e2).distanceTo(a2) <= o2)
        return true;
      if (i2.start = l2, i2.end = u2, i2.closestPointToPoint(a2, true, e2).distanceTo(a2) <= o2)
        return true;
      if (i2.start = c2, i2.end = u2, i2.closestPointToPoint(a2, true, e2).distanceTo(a2) <= o2)
        return true;
      const p2 = s2.getPlane(r2);
      if (Math.abs(p2.distanceToPoint(a2)) <= o2) {
        const e3 = p2.projectPoint(a2, t2);
        if (s2.containsPoint(e3))
          return true;
      }
      return false;
    };
  }(), _S = 1e-15;
  function gS(e2) {
    return Math.abs(e2) < _S;
  }
  class vS extends n.CJI {
    constructor(...e2) {
      super(...e2), this.isExtendedTriangle = true, this.satAxes = new Array(4).fill().map(() => new n.Pa4()), this.satBounds = new Array(4).fill().map(() => new dS()), this.points = [this.a, this.b, this.c], this.sphere = new n.aLr(), this.plane = new n.JOQ(), this.needsUpdate = true;
    }
    intersectsSphere(e2) {
      return mS(e2, this);
    }
    update() {
      const e2 = this.a, t2 = this.b, n2 = this.c, r2 = this.points, i2 = this.satAxes, s2 = this.satBounds, o2 = i2[0], a2 = s2[0];
      this.getNormal(o2), a2.setFromPoints(o2, r2);
      const l2 = i2[1], c2 = s2[1];
      l2.subVectors(e2, t2), c2.setFromPoints(l2, r2);
      const u2 = i2[2], p2 = s2[2];
      u2.subVectors(t2, n2), p2.setFromPoints(u2, r2);
      const d2 = i2[3], h2 = s2[3];
      d2.subVectors(n2, e2), h2.setFromPoints(d2, r2), this.sphere.setFromPoints(this.points), this.plane.setFromNormalAndCoplanarPoint(o2, e2), this.needsUpdate = false;
    }
  }
  vS.prototype.closestPointToSegment = function() {
    const e2 = new n.Pa4(), t2 = new n.Pa4(), r2 = new n.Zzh();
    return function(n2, i2 = null, s2 = null) {
      const { start: o2, end: a2 } = n2, l2 = this.points;
      let c2, u2 = 1 / 0;
      for (let o3 = 0; o3 < 3; o3++) {
        const a3 = (o3 + 1) % 3;
        r2.start.copy(l2[o3]), r2.end.copy(l2[a3]), fS(r2, n2, e2, t2), c2 = e2.distanceToSquared(t2), c2 < u2 && (u2 = c2, i2 && i2.copy(e2), s2 && s2.copy(t2));
      }
      return this.closestPointToPoint(o2, e2), c2 = o2.distanceToSquared(e2), c2 < u2 && (u2 = c2, i2 && i2.copy(e2), s2 && s2.copy(o2)), this.closestPointToPoint(a2, e2), c2 = a2.distanceToSquared(e2), c2 < u2 && (u2 = c2, i2 && i2.copy(e2), s2 && s2.copy(a2)), Math.sqrt(u2);
    };
  }(), vS.prototype.intersectsTriangle = function() {
    const e2 = new vS(), t2 = new Array(3), r2 = new Array(3), i2 = new dS(), s2 = new dS(), o2 = new n.Pa4(), a2 = new n.Pa4(), l2 = new n.Pa4(), c2 = new n.Pa4(), u2 = new n.Zzh(), p2 = new n.Zzh(), d2 = new n.Zzh();
    return function(n2, h2 = null, f2 = false) {
      this.needsUpdate && this.update(), n2.isExtendedTriangle ? n2.needsUpdate && n2.update() : (e2.copy(n2), e2.update(), n2 = e2);
      const m2 = this.plane, _2 = n2.plane;
      if (Math.abs(m2.normal.dot(_2.normal)) > 1 - 1e-10) {
        const e3 = this.satBounds, a3 = this.satAxes;
        r2[0] = n2.a, r2[1] = n2.b, r2[2] = n2.c;
        for (let t3 = 0; t3 < 4; t3++) {
          const n3 = e3[t3], s3 = a3[t3];
          if (i2.setFromPoints(s3, r2), n3.isSeparated(i2))
            return false;
        }
        const l3 = n2.satBounds, c3 = n2.satAxes;
        t2[0] = this.a, t2[1] = this.b, t2[2] = this.c;
        for (let e4 = 0; e4 < 4; e4++) {
          const n3 = l3[e4], r3 = c3[e4];
          if (i2.setFromPoints(r3, t2), n3.isSeparated(i2))
            return false;
        }
        for (let e4 = 0; e4 < 4; e4++) {
          const n3 = a3[e4];
          for (let e5 = 0; e5 < 4; e5++) {
            const a4 = c3[e5];
            if (o2.crossVectors(n3, a4), i2.setFromPoints(o2, t2), s2.setFromPoints(o2, r2), i2.isSeparated(s2))
              return false;
          }
        }
        return h2 && (f2 || console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."), h2.start.set(0, 0, 0), h2.end.set(0, 0, 0)), true;
      }
      {
        const e3 = this.points;
        let t3 = false, r3 = 0;
        for (let n3 = 0; n3 < 3; n3++) {
          const i4 = e3[n3], s4 = e3[(n3 + 1) % 3];
          u2.start.copy(i4), u2.end.copy(s4), u2.delta(a2);
          const o4 = t3 ? p2.start : p2.end, l3 = gS(_2.distanceToPoint(i4));
          if (gS(_2.normal.dot(a2)) && l3) {
            p2.copy(u2), r3 = 2;
            break;
          }
          if ((_2.intersectLine(u2, o4) || l3) && !gS(o4.distanceTo(s4))) {
            if (r3++, t3)
              break;
            t3 = true;
          }
        }
        if (1 === r3 && n2.containsPoint(p2.end))
          return h2 && (h2.start.copy(p2.end), h2.end.copy(p2.end)), true;
        if (2 !== r3)
          return false;
        const i3 = n2.points;
        let s3 = false, o3 = 0;
        for (let e4 = 0; e4 < 3; e4++) {
          const t4 = i3[e4], n3 = i3[(e4 + 1) % 3];
          u2.start.copy(t4), u2.end.copy(n3), u2.delta(l2);
          const r4 = s3 ? d2.start : d2.end, a3 = gS(m2.distanceToPoint(t4));
          if (gS(m2.normal.dot(l2)) && a3) {
            d2.copy(u2), o3 = 2;
            break;
          }
          if ((m2.intersectLine(u2, r4) || a3) && !gS(r4.distanceTo(n3))) {
            if (o3++, s3)
              break;
            s3 = true;
          }
        }
        if (1 === o3 && this.containsPoint(d2.end))
          return h2 && (h2.start.copy(d2.end), h2.end.copy(d2.end)), true;
        if (2 !== o3)
          return false;
        if (p2.delta(a2), d2.delta(l2), a2.dot(l2) < 0) {
          let e4 = d2.start;
          d2.start = d2.end, d2.end = e4;
        }
        const f3 = p2.start.dot(a2), g2 = p2.end.dot(a2), v2 = d2.start.dot(a2), y2 = d2.end.dot(a2);
        return (f3 === y2 || v2 === g2 || g2 < v2 != f3 < y2) && (h2 && (c2.subVectors(p2.start, d2.start), c2.dot(a2) > 0 ? h2.start.copy(p2.start) : h2.start.copy(d2.start), c2.subVectors(p2.end, d2.end), c2.dot(a2) < 0 ? h2.end.copy(p2.end) : h2.end.copy(d2.end)), true);
      }
    };
  }(), vS.prototype.distanceToPoint = function() {
    const e2 = new n.Pa4();
    return function(t2) {
      return this.closestPointToPoint(t2, e2), t2.distanceTo(e2);
    };
  }(), vS.prototype.distanceToTriangle = function() {
    const e2 = new n.Pa4(), t2 = new n.Pa4(), r2 = ["a", "b", "c"], i2 = new n.Zzh(), s2 = new n.Zzh();
    return function(n2, o2 = null, a2 = null) {
      const l2 = o2 || a2 ? i2 : null;
      if (this.intersectsTriangle(n2, l2))
        return (o2 || a2) && (o2 && l2.getCenter(o2), a2 && l2.getCenter(a2)), 0;
      let c2 = 1 / 0;
      for (let t3 = 0; t3 < 3; t3++) {
        let i3;
        const s3 = r2[t3], l3 = n2[s3];
        this.closestPointToPoint(l3, e2), i3 = l3.distanceToSquared(e2), i3 < c2 && (c2 = i3, o2 && o2.copy(e2), a2 && a2.copy(l3));
        const u2 = this[s3];
        n2.closestPointToPoint(u2, e2), i3 = u2.distanceToSquared(e2), i3 < c2 && (c2 = i3, o2 && o2.copy(u2), a2 && a2.copy(e2));
      }
      for (let l3 = 0; l3 < 3; l3++) {
        const u2 = r2[l3], p2 = r2[(l3 + 1) % 3];
        i2.set(this[u2], this[p2]);
        for (let l4 = 0; l4 < 3; l4++) {
          const u3 = r2[l4], p3 = r2[(l4 + 1) % 3];
          s2.set(n2[u3], n2[p3]), fS(i2, s2, e2, t2);
          const d2 = e2.distanceToSquared(t2);
          d2 < c2 && (c2 = d2, o2 && o2.copy(e2), a2 && a2.copy(t2));
        }
      }
      return Math.sqrt(c2);
    };
  }();
  const yS = 1e-14, bS = 1e-10, wS = new n.Zzh(), AS = new n.Zzh(), xS = new n.Pa4(), ES = new n.Pa4(), CS = new n.JOQ(), SS = new vS();
  function MS(e2) {
    return e2.a.distanceToSquared(e2.b) < yS || e2.a.distanceToSquared(e2.c) < yS || e2.b.distanceToSquared(e2.c) < yS;
  }
  class TS {
    constructor() {
      this._pool = [], this._index = 0;
    }
    getTriangle() {
      return this._index >= this._pool.length && this._pool.push(new n.CJI()), this._pool[this._index++];
    }
    clear() {
      this._index = 0;
    }
    reset() {
      this._pool.length = 0, this._index = 0;
    }
  }
  class PS {
    constructor() {
      this.trianglePool = new TS(), this.triangles = [], this.normal = new n.Pa4();
    }
    initialize(e2) {
      const { triangles: t2, trianglePool: n2, normal: r2 } = this;
      if (t2.length = 0, n2.clear(), Array.isArray(e2))
        for (let i2 = 0, s2 = e2.length; i2 < s2; i2++) {
          const s3 = e2[i2];
          if (0 === i2)
            s3.getNormal(r2);
          else if (Math.abs(1 - s3.getNormal(xS).dot(r2)) > yS)
            throw new Error("Triangle Splitter: Cannot initialize with triangles that have different normals.");
          const o2 = n2.getTriangle();
          o2.copy(s3), t2.push(o2);
        }
      else {
        e2.getNormal(r2);
        const i2 = n2.getTriangle();
        i2.copy(e2), t2.push(i2);
      }
    }
    splitByTriangle(e2) {
      const { normal: t2, triangles: n2 } = this;
      if (e2.getPlane(CS), Math.abs(1 - Math.abs(CS.normal.dot(t2))) < bS) {
        const r2 = [e2.a, e2.b, e2.c];
        for (let n3 = 0; n3 < 3; n3++) {
          const i2 = (n3 + 1) % 3, s2 = r2[n3], o2 = r2[i2];
          xS.subVectors(o2, s2).normalize(), ES.crossVectors(t2, xS), CS.setFromNormalAndCoplanarPoint(ES, s2), this.splitByPlane(CS, e2, n3);
        }
        for (let e3 = 0, t3 = n2.length; e3 < t3; e3++)
          n2[e3].coplanarCount = 0;
      } else
        this.splitByPlane(CS, e2);
    }
    splitByPlane(e2, t2 = null, n2 = -1) {
      const { triangles: r2, trianglePool: i2 } = this;
      let s2 = null;
      null !== t2 && (s2 = SS, s2.copy(t2), s2.needsUpdate = true);
      for (let t3 = 0, n3 = r2.length; t3 < n3; t3++) {
        const o2 = r2[t3], { a: a2, b: l2, c: c2 } = o2;
        if (s2 && !s2.intersectsTriangle(o2, wS, true))
          continue;
        let u2 = 0, p2 = -1, d2 = 0, h2 = false;
        const f2 = [a2, l2, c2];
        for (let t4 = 0; t4 < 3; t4++) {
          const n4 = (t4 + 1) % 3;
          wS.start.copy(f2[t4]), wS.end.copy(f2[n4]);
          const r3 = e2.distanceToPoint(wS.start), i3 = e2.distanceToPoint(wS.end);
          if (Math.abs(r3) < bS && Math.abs(i3) < bS) {
            h2 = true;
            break;
          }
          if (Math.abs(r3) < bS)
            continue;
          r3 > 0 && d2++;
          let s3 = !!e2.intersectLine(wS, xS);
          !s3 && Math.abs(i3) < bS && (xS.copy(wS.end), s3 = true), !s3 || xS.distanceTo(wS.start) < yS || (xS.distanceTo(wS.end) < yS && (p2 = t4), 0 === u2 ? AS.start.copy(xS) : AS.end.copy(xS), u2++);
        }
        if (!h2)
          if (2 === u2 && AS.distance() > bS)
            if (-1 !== p2) {
              p2 = (p2 + 1) % 3;
              let e3 = 0;
              e3 === p2 && (e3 = (e3 + 1) % 3);
              let s3 = e3 + 1;
              s3 === p2 && (s3 = (s3 + 1) % 3);
              const a3 = i2.getTriangle();
              a3.a.copy(f2[s3]), a3.b.copy(AS.end), a3.c.copy(AS.start), MS(a3) || r2.push(a3), o2.a.copy(f2[e3]), o2.b.copy(AS.start), o2.c.copy(AS.end), MS(o2) && (r2.splice(t3, 1), t3--, n3--);
            } else {
              const s3 = f2.findIndex((t4) => d2 >= 2 ? e2.distanceToPoint(t4) < 0 : e2.distanceToPoint(t4) > 0);
              if (0 === s3) {
                let e3 = AS.start;
                AS.start = AS.end, AS.end = e3;
              } else if (-1 === s3)
                continue;
              const a3 = (s3 + 1) % 3, l3 = (s3 + 2) % 3, c3 = i2.getTriangle(), u3 = i2.getTriangle();
              f2[a3].distanceToSquared(AS.start) < f2[l3].distanceToSquared(AS.end) ? (c3.a.copy(f2[a3]), c3.b.copy(AS.start), c3.c.copy(AS.end), u3.a.copy(f2[a3]), u3.b.copy(f2[l3]), u3.c.copy(AS.start)) : (c3.a.copy(f2[l3]), c3.b.copy(AS.start), c3.c.copy(AS.end), u3.a.copy(f2[a3]), u3.b.copy(f2[l3]), u3.c.copy(AS.end)), o2.a.copy(f2[s3]), o2.b.copy(AS.end), o2.c.copy(AS.start), MS(c3) || r2.push(c3), MS(u3) || r2.push(u3), MS(o2) && (r2.splice(t3, 1), t3--, n3--);
            }
          else
            3 === u2 && console.warn("TriangleClipper: Coplanar clip not handled");
      }
    }
    reset() {
      this.triangles.length = 0;
    }
  }
  function IS() {
    return "undefined" != typeof SharedArrayBuffer;
  }
  function RS(e2) {
    if (e2.buffer instanceof SharedArrayBuffer)
      return e2;
    const t2 = e2.constructor, n2 = e2.buffer, r2 = new SharedArrayBuffer(n2.byteLength), i2 = new Uint8Array(n2);
    return new Uint8Array(r2).set(i2, 0), new t2(r2);
  }
  class kS {
    constructor(e2, t2 = 500) {
      const n2 = IS() ? SharedArrayBuffer : ArrayBuffer;
      this.expansionFactor = 1.5, this.type = e2, this.array = new e2(new n2(t2 * e2.BYTES_PER_ELEMENT)), this.length = 0;
    }
    expand(e2 = null) {
      const { type: t2, array: n2, expansionFactor: r2 } = this;
      null === e2 && (e2 = ~~(n2.length * r2));
      const i2 = new t2(e2);
      i2.set(n2, 0), this.array = i2;
    }
    push(...e2) {
      let { array: t2, length: n2 } = this;
      n2 + e2.length > t2.length && (this.expand(), t2 = this.array);
      for (let r2 = 0, i2 = e2.length; r2 < i2; r2++)
        t2[n2 + r2] = e2[r2];
      this.length += e2.length;
    }
    clear() {
      this.length = 0;
    }
  }
  class DS {
    constructor() {
      this.groupAttributes = [{}], this.groupCount = 0;
    }
    getType(e2) {
      return this.groupAttributes[0][e2].type;
    }
    getTotalLength(e2) {
      const { groupCount: t2, groupAttributes: n2 } = this;
      let r2 = 0;
      for (let i2 = 0; i2 < t2; i2++)
        r2 += n2[i2][e2].length;
      return r2;
    }
    getGroupSet(e2 = 0) {
      const { groupAttributes: t2 } = this;
      if (t2[e2])
        return this.groupCount = Math.max(this.groupCount, e2 + 1), t2[e2];
      const n2 = t2[0];
      for (this.groupCount = Math.max(this.groupCount, e2 + 1); e2 >= t2.length; ) {
        const e3 = {};
        t2.push(e3);
        for (const t3 in n2)
          e3[t3] = new kS(n2[t3].type);
      }
      return t2[e2];
    }
    getGroupArray(e2, t2 = 0) {
      const { groupAttributes: n2 } = this;
      if (!n2[0][e2])
        throw new Error(`TypedAttributeData: Attribute with "${e2}" has not been initialized`);
      return this.getGroupSet(t2)[e2];
    }
    initializeArray(e2, t2) {
      const { groupAttributes: n2 } = this, r2 = n2[0][e2];
      if (r2) {
        if (r2.type !== t2)
          throw new Error(`TypedAttributeData: Array ${e2} already initialized with a different type.`);
      } else
        for (let r3 = 0, i2 = n2.length; r3 < i2; r3++)
          n2[r3][e2] = new kS(t2);
    }
    clear() {
      this.groupCount = 0;
      const { groupAttributes: e2 } = this;
      e2.forEach((e3) => {
        for (const t2 in e3)
          e3[t2].clear();
      });
    }
    delete(e2) {
      this.groupAttributes.forEach((t2) => {
        delete t2[e2];
      });
    }
    reset() {
      this.groupAttributes = [];
    }
  }
  class BS {
    constructor(e2) {
      this.triangle = new n.CJI().copy(e2), this.intersects = {};
    }
    addTriangle(e2, t2) {
      this.intersects[e2] = new n.CJI().copy(t2);
    }
    getIntersectArray() {
      const e2 = [], { intersects: t2 } = this;
      for (const n2 in t2)
        e2.push(t2[n2]);
      return e2;
    }
  }
  class OS {
    constructor() {
      this.data = {};
    }
    addTriangleIntersection(e2, t2, n2, r2) {
      const { data: i2 } = this;
      i2[e2] || (i2[e2] = new BS(t2)), i2[e2].addTriangle(n2, r2);
    }
    getTrianglesAsArray(e2 = null) {
      const { data: t2 } = this, n2 = [];
      if (null !== e2)
        e2 in t2 && n2.push(t2[e2].triangle);
      else
        for (const e3 in t2)
          n2.push(t2[e3].triangle);
      return n2;
    }
    getTriangleIndices() {
      return Object.keys(this.data).map((e2) => parseInt(e2));
    }
    getIntersectionIndices(e2) {
      const { data: t2 } = this;
      return t2[e2] ? Object.keys(t2[e2].intersects).map((e3) => parseInt(e3)) : [];
    }
    getIntersectionsAsArray(e2 = null, t2 = null) {
      const { data: n2 } = this, r2 = /* @__PURE__ */ new Set(), i2 = [], s2 = (e3) => {
        if (n2[e3])
          if (null !== t2)
            n2[e3].intersects[t2] && i2.push(n2[e3].intersects[t2]);
          else {
            const t3 = n2[e3].intersects;
            for (const e4 in t3)
              r2.has(e4) || (r2.add(e4), i2.push(t3[e4]));
          }
      };
      if (null !== e2)
        s2(e2);
      else
        for (const e3 in n2)
          s2(e3);
      return i2;
    }
    reset() {
      this.data = {};
    }
  }
  class LS {
    constructor() {
      this.enabled = false, this.triangleIntersectsA = new OS(), this.triangleIntersectsB = new OS(), this.intersectionEdges = [];
    }
    addIntersectingTriangles(e2, t2, n2, r2) {
      const { triangleIntersectsA: i2, triangleIntersectsB: s2 } = this;
      i2.addTriangleIntersection(e2, t2, n2, r2), s2.addTriangleIntersection(n2, r2, e2, t2);
    }
    addEdge(e2) {
      this.intersectionEdges.push(e2.clone());
    }
    reset() {
      this.triangleIntersectsA.reset(), this.triangleIntersectsB.reset(), this.intersectionEdges = [];
    }
  }
  class US {
    constructor() {
      this.intersectionSet = {}, this.ids = [];
    }
    add(e2, t2) {
      const { intersectionSet: n2, ids: r2 } = this;
      n2[e2] || (n2[e2] = [], r2.push(e2)), n2[e2].push(t2);
    }
  }
  const FS = new n.zHn(), NS = new n.yGw(), jS = new n.CJI(), zS = new n.Pa4(), GS = new n.Ltg(), VS = new n.Ltg(), HS = new n.Ltg(), QS = new n.Ltg(), WS = new n.Ltg(), qS = new n.Ltg(), XS = new n.Zzh(), YS = new n.Pa4(), KS = 1e-8, JS = 1e-15, ZS = -1, $S = 1, eM = -2, tM = 2, nM = 0, rM = 1, iM = 2;
  let sM = null;
  function oM(e2) {
    sM = e2;
  }
  function aM(e2, t2) {
    function r2() {
      return Math.random() - 0.5;
    }
    e2.getNormal(YS), FS.direction.copy(YS), e2.getMidpoint(FS.origin);
    let i2 = 0, s2 = 1 / 0;
    for (let e3 = 0; e3 < 3; e3++) {
      FS.direction.x += r2() * KS, FS.direction.y += r2() * KS, FS.direction.z += r2() * KS, FS.direction.multiplyScalar(-1);
      const o2 = t2.raycastFirst(FS, n.ehD);
      if (Boolean(o2 && FS.direction.dot(o2.face.normal) > 0) && i2++, null !== o2 && (s2 = Math.min(s2, o2.distance)), s2 <= JS)
        return o2.face.normal.dot(YS) > 0 ? tM : eM;
      if (i2 / 3 > 0.5 || (e3 - i2 + 1) / 3 > 0.5)
        break;
    }
    return i2 / 3 > 0.5 ? ZS : $S;
  }
  function lM(e2, t2, n2, r2, i2, s2, o2 = false) {
    const a2 = n2.attributes, l2 = n2.index, c2 = 3 * e2, u2 = l2.getX(c2 + 0), p2 = l2.getX(c2 + 1), d2 = l2.getX(c2 + 2);
    for (const e3 in s2) {
      const n3 = a2[e3], l3 = s2[e3];
      if (!(e3 in a2))
        throw new Error(`CSG Operations: Attribute ${e3} not available on geometry.`);
      const c3 = n3.itemSize;
      "position" === e3 ? (jS.a.fromBufferAttribute(n3, u2).applyMatrix4(r2), jS.b.fromBufferAttribute(n3, p2).applyMatrix4(r2), jS.c.fromBufferAttribute(n3, d2).applyMatrix4(r2), pM(jS.a, jS.b, jS.c, t2, 3, l3, o2)) : "normal" === e3 ? (jS.a.fromBufferAttribute(n3, u2).applyNormalMatrix(i2), jS.b.fromBufferAttribute(n3, p2).applyNormalMatrix(i2), jS.c.fromBufferAttribute(n3, d2).applyNormalMatrix(i2), o2 && (jS.a.multiplyScalar(-1), jS.b.multiplyScalar(-1), jS.c.multiplyScalar(-1)), pM(jS.a, jS.b, jS.c, t2, 3, l3, o2, true)) : (GS.fromBufferAttribute(n3, u2), VS.fromBufferAttribute(n3, p2), HS.fromBufferAttribute(n3, d2), pM(GS, VS, HS, t2, c3, l3, o2));
    }
  }
  function cM(e2, t2, n2, r2, i2, s2, o2, a2 = false) {
    dM(e2, r2, i2, s2, o2, a2), dM(a2 ? n2 : t2, r2, i2, s2, o2, a2), dM(a2 ? t2 : n2, r2, i2, s2, o2, a2);
  }
  function uM(e2, t2, n2 = false) {
    switch (e2) {
      case lS:
        if (t2 === $S || t2 === tM && !n2)
          return rM;
        break;
      case cS:
        if (n2) {
          if (t2 === ZS)
            return nM;
        } else if (t2 === $S || t2 === eM)
          return rM;
        break;
      case uS:
        if (t2 === ZS)
          return nM;
        if (t2 === $S)
          return rM;
        break;
      case pS:
        if (t2 === ZS || t2 === tM && !n2)
          return rM;
        break;
      default:
        throw new Error(`Unrecognized CSG operation enum "${e2}".`);
    }
    return iM;
  }
  function pM(e2, t2, n2, r2, i2, s2, o2 = false, a2 = false) {
    const l2 = (e3) => {
      s2.push(e3.x), i2 > 1 && s2.push(e3.y), i2 > 2 && s2.push(e3.z), i2 > 3 && s2.push(e3.w);
    };
    QS.set(0, 0, 0, 0).addScaledVector(e2, r2.a.x).addScaledVector(t2, r2.a.y).addScaledVector(n2, r2.a.z), WS.set(0, 0, 0, 0).addScaledVector(e2, r2.b.x).addScaledVector(t2, r2.b.y).addScaledVector(n2, r2.b.z), qS.set(0, 0, 0, 0).addScaledVector(e2, r2.c.x).addScaledVector(t2, r2.c.y).addScaledVector(n2, r2.c.z), a2 && (QS.normalize(), WS.normalize(), qS.normalize()), l2(QS), o2 ? (l2(qS), l2(WS)) : (l2(WS), l2(qS));
  }
  function dM(e2, t2, n2, r2, i2, s2 = false) {
    for (const o2 in i2) {
      const a2 = t2[o2], l2 = i2[o2];
      if (!(o2 in t2))
        throw new Error(`CSG Operations: Attribute ${o2} no available on geometry.`);
      const c2 = a2.itemSize;
      "position" === o2 ? (zS.fromBufferAttribute(a2, e2).applyMatrix4(n2), l2.push(zS.x, zS.y, zS.z)) : "normal" === o2 ? (zS.fromBufferAttribute(a2, e2).applyNormalMatrix(r2), s2 && zS.multiplyScalar(-1), l2.push(zS.x, zS.y, zS.z)) : (l2.push(a2.getX(e2)), c2 > 1 && l2.push(a2.getY(e2)), c2 > 2 && l2.push(a2.getZ(e2)), c2 > 3 && l2.push(a2.getW(e2)));
    }
  }
  const hM = new n.yGw(), fM = new n.Vkp(), mM = new n.CJI(), _M = new n.CJI(), gM = new n.CJI(), vM = new n.CJI();
  function yM(e2) {
    for (const t2 of e2)
      return t2;
  }
  function bM(e2, t2, n2, r2, i2, s2, o2, a2 = 0) {
    const l2 = e2.matrixWorld.determinant() < 0;
    hM.copy(t2.matrixWorld).invert().multiply(e2.matrixWorld), fM.getNormalMatrix(e2.matrixWorld).multiplyScalar(l2 ? -1 : 1);
    const c2 = e2.geometry.groupIndices, u2 = e2.geometry.index, p2 = e2.geometry.attributes.position, d2 = t2.geometry.boundsTree, h2 = t2.geometry.index, f2 = t2.geometry.attributes.position, m2 = n2.ids, _2 = n2.intersectionSet;
    for (let t3 = 0, n3 = m2.length; t3 < n3; t3++) {
      const n4 = m2[t3], g2 = -1 === a2 ? 0 : c2[n4] + a2, v2 = o2.getGroupSet(g2), y2 = 3 * n4, b2 = u2.getX(y2 + 0), w2 = u2.getX(y2 + 1), A2 = u2.getX(y2 + 2);
      mM.a.fromBufferAttribute(p2, b2).applyMatrix4(hM), mM.b.fromBufferAttribute(p2, w2).applyMatrix4(hM), mM.c.fromBufferAttribute(p2, A2).applyMatrix4(hM), s2.initialize(mM);
      const x2 = _2[n4];
      for (let e3 = 0, t4 = x2.length; e3 < t4; e3++) {
        const t5 = 3 * x2[e3], n5 = h2.getX(t5 + 0), r3 = h2.getX(t5 + 1), i3 = h2.getX(t5 + 2);
        _M.a.fromBufferAttribute(f2, n5), _M.b.fromBufferAttribute(f2, r3), _M.c.fromBufferAttribute(f2, i3), s2.splitByTriangle(_M);
      }
      const E2 = s2.triangles;
      for (let t4 = 0, s3 = E2.length; t4 < s3; t4++) {
        const s4 = E2[t4], o3 = uM(r2, aM(s4, d2), i2);
        if (o3 !== iM) {
          mM.getBarycoord(s4.a, vM.a), mM.getBarycoord(s4.b, vM.b), mM.getBarycoord(s4.c, vM.c);
          const t5 = o3 === nM;
          lM(n4, vM, e2.geometry, e2.matrixWorld, fM, v2, l2 !== t5);
        }
      }
    }
    return m2.length;
  }
  function wM(e2, t2, n2, r2, i2, s2, o2 = 0) {
    const a2 = e2.matrixWorld.determinant() < 0;
    hM.copy(t2.matrixWorld).invert().multiply(e2.matrixWorld), fM.getNormalMatrix(e2.matrixWorld).multiplyScalar(a2 ? -1 : 1);
    const l2 = t2.geometry.boundsTree, c2 = e2.geometry.groupIndices, u2 = e2.geometry.index, p2 = e2.geometry.attributes, d2 = p2.position, h2 = [], f2 = e2.geometry.halfEdges, m2 = /* @__PURE__ */ new Set();
    for (let e3 = 0, t3 = u2.count / 3; e3 < t3; e3++)
      e3 in n2.intersectionSet || m2.add(e3);
    for (; m2.size > 0; ) {
      const t3 = yM(m2);
      m2.delete(t3), h2.push(t3);
      const n3 = 3 * t3, _2 = u2.getX(n3 + 0), g2 = u2.getX(n3 + 1), v2 = u2.getX(n3 + 2);
      gM.a.fromBufferAttribute(d2, _2).applyMatrix4(hM), gM.b.fromBufferAttribute(d2, g2).applyMatrix4(hM), gM.c.fromBufferAttribute(d2, v2).applyMatrix4(hM);
      const y2 = uM(r2, aM(gM, l2), i2);
      for (; h2.length > 0; ) {
        const t4 = h2.pop(), n4 = -1 === o2 ? 0 : c2[t4] + o2, r3 = s2.getGroupSet(n4);
        for (let e3 = 0; e3 < 3; e3++) {
          const n5 = f2.getSiblingTriangleIndex(t4, e3);
          -1 !== n5 && m2.has(n5) && (h2.push(n5), m2.delete(n5));
        }
        if (y2 === iM)
          continue;
        const i3 = 3 * t4, l3 = u2.getX(i3 + 0), d3 = u2.getX(i3 + 1), _3 = u2.getX(i3 + 2), g3 = y2 === nM;
        cM(l3, d3, _3, p2, e2.matrixWorld, fM, r3, g3 !== a2);
      }
    }
  }
  const AM = 0, xM = 1, EM = 2, CM = 1.25, SM = 1, MM = 65535, TM = Math.pow(2, -24);
  class PM {
    constructor() {
    }
  }
  function IM(e2, t2, n2) {
    return n2.min.x = t2[e2], n2.min.y = t2[e2 + 1], n2.min.z = t2[e2 + 2], n2.max.x = t2[e2 + 3], n2.max.y = t2[e2 + 4], n2.max.z = t2[e2 + 5], n2;
  }
  function RM(e2) {
    let t2 = -1, n2 = -1 / 0;
    for (let r2 = 0; r2 < 3; r2++) {
      const i2 = e2[r2 + 3] - e2[r2];
      i2 > n2 && (n2 = i2, t2 = r2);
    }
    return t2;
  }
  function kM(e2, t2) {
    t2.set(e2);
  }
  function DM(e2, t2, n2) {
    let r2, i2;
    for (let s2 = 0; s2 < 3; s2++) {
      const o2 = s2 + 3;
      r2 = e2[s2], i2 = t2[s2], n2[s2] = r2 < i2 ? r2 : i2, r2 = e2[o2], i2 = t2[o2], n2[o2] = r2 > i2 ? r2 : i2;
    }
  }
  function BM(e2, t2, n2) {
    for (let r2 = 0; r2 < 3; r2++) {
      const i2 = t2[e2 + 2 * r2], s2 = t2[e2 + 2 * r2 + 1], o2 = i2 - s2, a2 = i2 + s2;
      o2 < n2[r2] && (n2[r2] = o2), a2 > n2[r2 + 3] && (n2[r2 + 3] = a2);
    }
  }
  function OM(e2) {
    const t2 = e2[3] - e2[0], n2 = e2[4] - e2[1], r2 = e2[5] - e2[2];
    return 2 * (t2 * n2 + n2 * r2 + r2 * t2);
  }
  function LM(e2, t2, n2, r2, i2 = null) {
    let s2 = 1 / 0, o2 = 1 / 0, a2 = 1 / 0, l2 = -1 / 0, c2 = -1 / 0, u2 = -1 / 0, p2 = 1 / 0, d2 = 1 / 0, h2 = 1 / 0, f2 = -1 / 0, m2 = -1 / 0, _2 = -1 / 0;
    const g2 = null !== i2;
    for (let r3 = 6 * t2, i3 = 6 * (t2 + n2); r3 < i3; r3 += 6) {
      const t3 = e2[r3 + 0], n3 = e2[r3 + 1], i4 = t3 - n3, v2 = t3 + n3;
      i4 < s2 && (s2 = i4), v2 > l2 && (l2 = v2), g2 && t3 < p2 && (p2 = t3), g2 && t3 > f2 && (f2 = t3);
      const y2 = e2[r3 + 2], b2 = e2[r3 + 3], w2 = y2 - b2, A2 = y2 + b2;
      w2 < o2 && (o2 = w2), A2 > c2 && (c2 = A2), g2 && y2 < d2 && (d2 = y2), g2 && y2 > m2 && (m2 = y2);
      const x2 = e2[r3 + 4], E2 = e2[r3 + 5], C2 = x2 - E2, S2 = x2 + E2;
      C2 < a2 && (a2 = C2), S2 > u2 && (u2 = S2), g2 && x2 < h2 && (h2 = x2), g2 && x2 > _2 && (_2 = x2);
    }
    r2[0] = s2, r2[1] = o2, r2[2] = a2, r2[3] = l2, r2[4] = c2, r2[5] = u2, g2 && (i2[0] = p2, i2[1] = d2, i2[2] = h2, i2[3] = f2, i2[4] = m2, i2[5] = _2);
  }
  const UM = 32, FM = (e2, t2) => e2.candidate - t2.candidate, NM = new Array(UM).fill().map(() => ({ count: 0, bounds: new Float32Array(6), rightCacheBounds: new Float32Array(6), leftCacheBounds: new Float32Array(6), candidate: 0 })), jM = new Float32Array(6);
  class zM {
    constructor(e2, t2, r2) {
      this.isOrientedBox = true, this.min = new n.Pa4(), this.max = new n.Pa4(), this.matrix = new n.yGw(), this.invMatrix = new n.yGw(), this.points = new Array(8).fill().map(() => new n.Pa4()), this.satAxes = new Array(3).fill().map(() => new n.Pa4()), this.satBounds = new Array(3).fill().map(() => new dS()), this.alignedSatBounds = new Array(3).fill().map(() => new dS()), this.needsUpdate = false, e2 && this.min.copy(e2), t2 && this.max.copy(t2), r2 && this.matrix.copy(r2);
    }
    set(e2, t2, n2) {
      this.min.copy(e2), this.max.copy(t2), this.matrix.copy(n2), this.needsUpdate = true;
    }
    copy(e2) {
      this.min.copy(e2.min), this.max.copy(e2.max), this.matrix.copy(e2.matrix), this.needsUpdate = true;
    }
  }
  zM.prototype.update = function() {
    const e2 = this.matrix, t2 = this.min, n2 = this.max, r2 = this.points;
    for (let i3 = 0; i3 <= 1; i3++)
      for (let s3 = 0; s3 <= 1; s3++)
        for (let o3 = 0; o3 <= 1; o3++) {
          const a3 = r2[1 * i3 | 2 * s3 | 4 * o3];
          a3.x = i3 ? n2.x : t2.x, a3.y = s3 ? n2.y : t2.y, a3.z = o3 ? n2.z : t2.z, a3.applyMatrix4(e2);
        }
    const i2 = this.satBounds, s2 = this.satAxes, o2 = r2[0];
    for (let e3 = 0; e3 < 3; e3++) {
      const t3 = s2[e3], n3 = i2[e3], a3 = r2[1 << e3];
      t3.subVectors(o2, a3), n3.setFromPoints(t3, r2);
    }
    const a2 = this.alignedSatBounds;
    a2[0].setFromPointsField(r2, "x"), a2[1].setFromPointsField(r2, "y"), a2[2].setFromPointsField(r2, "z"), this.invMatrix.copy(this.matrix).invert(), this.needsUpdate = false;
  }, zM.prototype.intersectsBox = function() {
    const e2 = new dS();
    return function(t2) {
      this.needsUpdate && this.update();
      const n2 = t2.min, r2 = t2.max, i2 = this.satBounds, s2 = this.satAxes, o2 = this.alignedSatBounds;
      if (e2.min = n2.x, e2.max = r2.x, o2[0].isSeparated(e2))
        return false;
      if (e2.min = n2.y, e2.max = r2.y, o2[1].isSeparated(e2))
        return false;
      if (e2.min = n2.z, e2.max = r2.z, o2[2].isSeparated(e2))
        return false;
      for (let n3 = 0; n3 < 3; n3++) {
        const r3 = s2[n3], o3 = i2[n3];
        if (e2.setFromBox(r3, t2), o3.isSeparated(e2))
          return false;
      }
      return true;
    };
  }(), zM.prototype.intersectsTriangle = function() {
    const e2 = new vS(), t2 = new Array(3), r2 = new dS(), i2 = new dS(), s2 = new n.Pa4();
    return function(n2) {
      this.needsUpdate && this.update(), n2.isExtendedTriangle ? n2.needsUpdate && n2.update() : (e2.copy(n2), e2.update(), n2 = e2);
      const o2 = this.satBounds, a2 = this.satAxes;
      t2[0] = n2.a, t2[1] = n2.b, t2[2] = n2.c;
      for (let e3 = 0; e3 < 3; e3++) {
        const n3 = o2[e3], i3 = a2[e3];
        if (r2.setFromPoints(i3, t2), n3.isSeparated(r2))
          return false;
      }
      const l2 = n2.satBounds, c2 = n2.satAxes, u2 = this.points;
      for (let e3 = 0; e3 < 3; e3++) {
        const t3 = l2[e3], n3 = c2[e3];
        if (r2.setFromPoints(n3, u2), t3.isSeparated(r2))
          return false;
      }
      for (let e3 = 0; e3 < 3; e3++) {
        const n3 = a2[e3];
        for (let e4 = 0; e4 < 4; e4++) {
          const o3 = c2[e4];
          if (s2.crossVectors(n3, o3), r2.setFromPoints(s2, t2), i2.setFromPoints(s2, u2), r2.isSeparated(i2))
            return false;
        }
      }
      return true;
    };
  }(), zM.prototype.closestPointToPoint = function(e2, t2) {
    return this.needsUpdate && this.update(), t2.copy(e2).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix), t2;
  }, zM.prototype.distanceToPoint = function() {
    const e2 = new n.Pa4();
    return function(t2) {
      return this.closestPointToPoint(t2, e2), t2.distanceTo(e2);
    };
  }(), zM.prototype.distanceToBox = function() {
    const e2 = ["x", "y", "z"], t2 = new Array(12).fill().map(() => new n.Zzh()), r2 = new Array(12).fill().map(() => new n.Zzh()), i2 = new n.Pa4(), s2 = new n.Pa4();
    return function(n2, o2 = 0, a2 = null, l2 = null) {
      if (this.needsUpdate && this.update(), this.intersectsBox(n2))
        return (a2 || l2) && (n2.getCenter(s2), this.closestPointToPoint(s2, i2), n2.closestPointToPoint(i2, s2), a2 && a2.copy(i2), l2 && l2.copy(s2)), 0;
      const c2 = o2 * o2, u2 = n2.min, p2 = n2.max, d2 = this.points;
      let h2 = 1 / 0;
      for (let e3 = 0; e3 < 8; e3++) {
        const t3 = d2[e3];
        s2.copy(t3).clamp(u2, p2);
        const n3 = t3.distanceToSquared(s2);
        if (n3 < h2 && (h2 = n3, a2 && a2.copy(t3), l2 && l2.copy(s2), n3 < c2))
          return Math.sqrt(n3);
      }
      let f2 = 0;
      for (let n3 = 0; n3 < 3; n3++)
        for (let i3 = 0; i3 <= 1; i3++)
          for (let s3 = 0; s3 <= 1; s3++) {
            const o3 = (n3 + 1) % 3, a3 = (n3 + 2) % 3, l3 = 1 << n3 | i3 << o3 | s3 << a3, c3 = d2[i3 << o3 | s3 << a3], h3 = d2[l3];
            t2[f2].set(c3, h3);
            const m2 = e2[n3], _2 = e2[o3], g2 = e2[a3], v2 = r2[f2], y2 = v2.start, b2 = v2.end;
            y2[m2] = u2[m2], y2[_2] = i3 ? u2[_2] : p2[_2], y2[g2] = s3 ? u2[g2] : p2[_2], b2[m2] = p2[m2], b2[_2] = i3 ? u2[_2] : p2[_2], b2[g2] = s3 ? u2[g2] : p2[_2], f2++;
          }
      for (let e3 = 0; e3 <= 1; e3++)
        for (let t3 = 0; t3 <= 1; t3++)
          for (let n3 = 0; n3 <= 1; n3++) {
            s2.x = e3 ? p2.x : u2.x, s2.y = t3 ? p2.y : u2.y, s2.z = n3 ? p2.z : u2.z, this.closestPointToPoint(s2, i2);
            const r3 = s2.distanceToSquared(i2);
            if (r3 < h2 && (h2 = r3, a2 && a2.copy(i2), l2 && l2.copy(s2), r3 < c2))
              return Math.sqrt(r3);
          }
      for (let e3 = 0; e3 < 12; e3++) {
        const n3 = t2[e3];
        for (let e4 = 0; e4 < 12; e4++) {
          const t3 = r2[e4];
          fS(n3, t3, i2, s2);
          const o3 = i2.distanceToSquared(s2);
          if (o3 < h2 && (h2 = o3, a2 && a2.copy(i2), l2 && l2.copy(s2), o3 < c2))
            return Math.sqrt(o3);
        }
      }
      return Math.sqrt(h2);
    };
  }();
  const GM = new n.Pa4(), VM = new n.Pa4(), HM = new n.Pa4(), QM = new n.FM8(), WM = new n.FM8(), qM = new n.FM8(), XM = new n.Pa4();
  function YM(e2, t2, r2, i2, s2) {
    const o2 = 3 * i2, a2 = e2.index.getX(o2), l2 = e2.index.getX(o2 + 1), c2 = e2.index.getX(o2 + 2), u2 = function(e3, t3, r3, i3, s3, o3, a3) {
      GM.fromBufferAttribute(t3, i3), VM.fromBufferAttribute(t3, s3), HM.fromBufferAttribute(t3, o3);
      const l3 = function(e4, t4, r4, i4, s4, o4) {
        let a4;
        return a4 = o4 === n._Li ? e4.intersectTriangle(i4, r4, t4, true, s4) : e4.intersectTriangle(t4, r4, i4, o4 !== n.ehD, s4), null === a4 ? null : { distance: e4.origin.distanceTo(s4), point: s4.clone() };
      }(e3, GM, VM, HM, XM, a3);
      if (l3) {
        r3 && (QM.fromBufferAttribute(r3, i3), WM.fromBufferAttribute(r3, s3), qM.fromBufferAttribute(r3, o3), l3.uv = n.CJI.getUV(XM, GM, VM, HM, QM, WM, qM, new n.FM8()));
        const e4 = { a: i3, b: s3, c: o3, normal: new n.Pa4(), materialIndex: 0 };
        n.CJI.getNormal(GM, VM, HM, e4.normal), l3.face = e4, l3.faceIndex = i3;
      }
      return l3;
    }(r2, e2.attributes.position, e2.attributes.uv, a2, l2, c2, t2);
    return u2 ? (u2.faceIndex = i2, s2 && s2.push(u2), u2) : null;
  }
  function KM(e2, t2, n2, r2) {
    const i2 = e2.a, s2 = e2.b, o2 = e2.c;
    let a2 = t2, l2 = t2 + 1, c2 = t2 + 2;
    n2 && (a2 = n2.getX(t2), l2 = n2.getX(t2 + 1), c2 = n2.getX(t2 + 2)), i2.x = r2.getX(a2), i2.y = r2.getY(a2), i2.z = r2.getZ(a2), s2.x = r2.getX(l2), s2.y = r2.getY(l2), s2.z = r2.getZ(l2), o2.x = r2.getX(c2), o2.y = r2.getY(c2), o2.z = r2.getZ(c2);
  }
  function JM(e2, t2, n2, r2, i2, s2, o2) {
    const a2 = n2.index, l2 = n2.attributes.position;
    for (let n3 = e2, c2 = t2 + e2; n3 < c2; n3++)
      if (KM(o2, 3 * n3, a2, l2), o2.needsUpdate = true, r2(o2, n3, i2, s2))
        return true;
    return false;
  }
  class ZM {
    constructor(e2) {
      this._getNewPrimitive = e2, this._primitives = [];
    }
    getPrimitive() {
      const e2 = this._primitives;
      return 0 === e2.length ? this._getNewPrimitive() : e2.pop();
    }
    releasePrimitive(e2) {
      this._primitives.push(e2);
    }
  }
  function $M(e2, t2) {
    return 65535 === t2[e2 + 15];
  }
  function eT(e2, t2) {
    return t2[e2 + 6];
  }
  function tT(e2, t2) {
    return t2[e2 + 14];
  }
  function nT(e2) {
    return e2 + 8;
  }
  function rT(e2, t2) {
    return t2[e2 + 6];
  }
  const iT = new n.ZzF(), sT = new n.Pa4(), oT = ["x", "y", "z"];
  function aT(e2, t2, n2, r2, i2) {
    let s2 = 2 * e2, o2 = fT, a2 = mT, l2 = _T;
    if ($M(s2, a2))
      !function(e3, t3, n3, r3, i3, s3) {
        for (let o3 = r3, a3 = r3 + i3; o3 < a3; o3++)
          YM(e3, t3, n3, o3, s3);
      }(t2, n2, r2, eT(e2, l2), tT(s2, a2), i2);
    else {
      const s3 = nT(e2);
      pT(s3, o2, r2, sT) && aT(s3, t2, n2, r2, i2);
      const a3 = rT(e2, l2);
      pT(a3, o2, r2, sT) && aT(a3, t2, n2, r2, i2);
    }
  }
  function lT(e2, t2, n2, r2) {
    let i2 = 2 * e2, s2 = fT, o2 = mT, a2 = _T;
    if ($M(i2, o2))
      return function(e3, t3, n3, r3, i3) {
        let s3 = 1 / 0, o3 = null;
        for (let a3 = r3, l2 = r3 + i3; a3 < l2; a3++) {
          const r4 = YM(e3, t3, n3, a3);
          r4 && r4.distance < s3 && (o3 = r4, s3 = r4.distance);
        }
        return o3;
      }(t2, n2, r2, eT(e2, a2), tT(i2, o2));
    {
      const i3 = function(e3, t3) {
        return t3[e3 + 7];
      }(e2, a2), o3 = oT[i3], l2 = r2.direction[o3] >= 0;
      let c2, u2;
      l2 ? (c2 = nT(e2), u2 = rT(e2, a2)) : (c2 = rT(e2, a2), u2 = nT(e2));
      const p2 = pT(c2, s2, r2, sT) ? lT(c2, t2, n2, r2) : null;
      if (p2) {
        const e3 = p2.point[o3];
        if (l2 ? e3 <= s2[u2 + i3] : e3 >= s2[u2 + i3 + 3])
          return p2;
      }
      const d2 = pT(u2, s2, r2, sT) ? lT(u2, t2, n2, r2) : null;
      return p2 && d2 ? p2.distance <= d2.distance ? p2 : d2 : p2 || d2 || null;
    }
  }
  const cT = function() {
    let e2, t2;
    const r2 = [], i2 = new ZM(() => new n.ZzF());
    return function(...n2) {
      e2 = i2.getPrimitive(), t2 = i2.getPrimitive(), r2.push(e2, t2);
      const o2 = s2(...n2);
      i2.releasePrimitive(e2), i2.releasePrimitive(t2), r2.pop(), r2.pop();
      const a2 = r2.length;
      return a2 > 0 && (t2 = r2[a2 - 1], e2 = r2[a2 - 2]), o2;
    };
    function s2(n2, r3, i3, o2, a2 = null, l2 = 0, c2 = 0) {
      function u2(e3) {
        let t3 = 2 * e3, n3 = mT, r4 = _T;
        for (; !$M(t3, n3); )
          t3 = 2 * (e3 = nT(e3));
        return eT(e3, r4);
      }
      function p2(e3) {
        let t3 = 2 * e3, n3 = mT, r4 = _T;
        for (; !$M(t3, n3); )
          t3 = 2 * (e3 = rT(e3, r4));
        return eT(e3, r4) + tT(t3, n3);
      }
      let d2 = 2 * n2, h2 = fT, f2 = mT, m2 = _T;
      if ($M(d2, f2)) {
        const t3 = eT(n2, m2), r4 = tT(d2, f2);
        return IM(n2, h2, e2), o2(t3, r4, false, c2, l2 + n2, e2);
      }
      {
        const d3 = nT(n2), _2 = rT(n2, m2);
        let g2, v2, y2, b2, w2 = d3, A2 = _2;
        if (a2 && (y2 = e2, b2 = t2, IM(w2, h2, y2), IM(A2, h2, b2), g2 = a2(y2), v2 = a2(b2), v2 < g2)) {
          w2 = _2, A2 = d3;
          const e3 = g2;
          g2 = v2, v2 = e3, y2 = b2;
        }
        y2 || (y2 = e2, IM(w2, h2, y2));
        const x2 = i3(y2, $M(2 * w2, f2), g2, c2 + 1, l2 + w2);
        let E2;
        if (2 === x2) {
          const e3 = u2(w2);
          E2 = o2(e3, p2(w2) - e3, true, c2 + 1, l2 + w2, y2);
        } else
          E2 = x2 && s2(w2, r3, i3, o2, a2, l2, c2 + 1);
        if (E2)
          return true;
        b2 = t2, IM(A2, h2, b2);
        const C2 = i3(b2, $M(2 * A2, f2), v2, c2 + 1, l2 + A2);
        let S2;
        if (2 === C2) {
          const e3 = u2(A2);
          S2 = o2(e3, p2(A2) - e3, true, c2 + 1, l2 + A2, b2);
        } else
          S2 = C2 && s2(A2, r3, i3, o2, a2, l2, c2 + 1);
        return !!S2;
      }
    }
  }(), uT = function() {
    const e2 = new vS(), t2 = new vS(), r2 = new n.yGw(), i2 = new zM(), s2 = new zM();
    return function n2(o2, a2, l2, c2, u2 = null) {
      let p2 = 2 * o2, d2 = fT, h2 = mT, f2 = _T;
      if (null === u2 && (l2.boundingBox || l2.computeBoundingBox(), i2.set(l2.boundingBox.min, l2.boundingBox.max, c2), u2 = i2), !$M(p2, h2)) {
        const e3 = o2 + 8, t3 = f2[o2 + 6];
        return IM(e3, d2, iT), u2.intersectsBox(iT) && n2(e3, a2, l2, c2, u2) ? true : (IM(t3, d2, iT), !(!u2.intersectsBox(iT) || !n2(t3, a2, l2, c2, u2)));
      }
      {
        const n3 = a2, i3 = n3.index, u3 = n3.attributes.position, m2 = l2.index, _2 = l2.attributes.position, g2 = eT(o2, f2), v2 = tT(p2, h2);
        if (r2.copy(c2).invert(), l2.boundsTree) {
          IM(o2, d2, s2), s2.matrix.copy(r2), s2.needsUpdate = true;
          const e3 = l2.boundsTree.shapecast({ intersectsBounds: (e4) => s2.intersectsBox(e4), intersectsTriangle: (e4) => {
            e4.a.applyMatrix4(c2), e4.b.applyMatrix4(c2), e4.c.applyMatrix4(c2), e4.needsUpdate = true;
            for (let n4 = 3 * g2, r3 = 3 * (v2 + g2); n4 < r3; n4 += 3)
              if (KM(t2, n4, i3, u3), t2.needsUpdate = true, e4.intersectsTriangle(t2))
                return true;
            return false;
          } });
          return e3;
        }
        for (let n4 = 3 * g2, s3 = v2 + 3 * g2; n4 < s3; n4 += 3) {
          KM(e2, n4, i3, u3), e2.a.applyMatrix4(r2), e2.b.applyMatrix4(r2), e2.c.applyMatrix4(r2), e2.needsUpdate = true;
          for (let n5 = 0, r3 = m2.count; n5 < r3; n5 += 3)
            if (KM(t2, n5, m2, _2), t2.needsUpdate = true, e2.intersectsTriangle(t2))
              return true;
        }
      }
    };
  }();
  function pT(e2, t2, n2, r2) {
    return IM(e2, t2, iT), n2.intersectBox(iT, r2);
  }
  const dT = [];
  let hT, fT, mT, _T;
  function gT(e2) {
    hT && dT.push(hT), hT = e2, fT = new Float32Array(e2), mT = new Uint16Array(e2), _T = new Uint32Array(e2);
  }
  function vT() {
    hT = null, fT = null, mT = null, _T = null, dT.length && gT(dT.pop());
  }
  const yT = Symbol("skip tree generation"), bT = new n.ZzF(), wT = new n.ZzF(), AT = new n.yGw(), xT = new zM(), ET = new zM(), CT = new n.Pa4(), ST = new n.Pa4(), MT = new n.Pa4(), TT = new n.Pa4(), PT = new n.Pa4(), IT = new n.ZzF(), RT = new ZM(() => new vS());
  class kT {
    static serialize(e2, t2 = {}) {
      if (t2.isBufferGeometry)
        return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."), kT.serialize(arguments[0], { cloneBuffers: void 0 === arguments[2] || arguments[2] });
      t2 = { cloneBuffers: true, ...t2 };
      const n2 = e2.geometry, r2 = e2._roots, i2 = n2.getIndex();
      let s2;
      return s2 = t2.cloneBuffers ? { roots: r2.map((e3) => e3.slice()), index: i2.array.slice() } : { roots: r2, index: i2.array }, s2;
    }
    static deserialize(e2, t2, r2 = {}) {
      if ("boolean" == typeof r2)
        return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."), kT.deserialize(arguments[0], arguments[1], { setIndex: void 0 === arguments[2] || arguments[2] });
      r2 = { setIndex: true, ...r2 };
      const { index: i2, roots: s2 } = e2, o2 = new kT(t2, { ...r2, [yT]: true });
      if (o2._roots = s2, r2.setIndex) {
        const r3 = t2.getIndex();
        if (null === r3) {
          const r4 = new n.TlE(e2.index, 1, false);
          t2.setIndex(r4);
        } else
          r3.array !== i2 && (r3.array.set(i2), r3.needsUpdate = true);
      }
      return o2;
    }
    constructor(e2, t2 = {}) {
      if (!e2.isBufferGeometry)
        throw new Error("MeshBVH: Only BufferGeometries are supported.");
      if (e2.index && e2.index.isInterleavedBufferAttribute)
        throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
      if ((t2 = Object.assign({ strategy: AM, maxDepth: 40, maxLeafTris: 10, verbose: true, useSharedArrayBuffer: false, setBoundingBox: true, onProgress: null, [yT]: false }, t2)).useSharedArrayBuffer && "undefined" == typeof SharedArrayBuffer)
        throw new Error("MeshBVH: SharedArrayBuffer is not available.");
      this._roots = null, t2[yT] || (this._roots = function(e3, t3) {
        const r2 = function(e4, t4) {
          function r3(e5) {
            h2 && h2(e5 / f2);
          }
          function i3(t5, n2, s4, h3 = null, f3 = 0) {
            if (!m2 && f3 >= c3 && (m2 = true, u3 && (console.warn(`MeshBVH: Max depth of ${c3} reached when generating BVH. Consider increasing maxDepth.`), console.warn(e4))), s4 <= p2 || f3 >= c3)
              return r3(n2 + s4), t5.offset = n2, t5.count = s4, t5;
            const _3 = function(e5, t6, n3, r4, i4, s5) {
              let o4 = -1, a4 = 0;
              if (s5 === AM)
                o4 = RM(t6), -1 !== o4 && (a4 = (t6[o4] + t6[o4 + 3]) / 2);
              else if (s5 === xM)
                o4 = RM(e5), -1 !== o4 && (a4 = function(e6, t7, n4, r5) {
                  let i5 = 0;
                  for (let s6 = t7, o5 = t7 + n4; s6 < o5; s6++)
                    i5 += e6[6 * s6 + 2 * r5];
                  return i5 / n4;
                }(n3, r4, i4, o4));
              else if (s5 === EM) {
                const s6 = OM(e5);
                let l4 = CM * i4;
                const c4 = 6 * r4, u4 = 6 * (r4 + i4);
                for (let e6 = 0; e6 < 3; e6++) {
                  const r5 = t6[e6], p3 = (t6[e6 + 3] - r5) / UM;
                  if (i4 < UM / 4) {
                    const t7 = [...NM];
                    t7.length = i4;
                    let r6 = 0;
                    for (let i5 = c4; i5 < u4; i5 += 6, r6++) {
                      const s7 = t7[r6];
                      s7.candidate = n3[i5 + 2 * e6], s7.count = 0;
                      const { bounds: o5, leftCacheBounds: a5, rightCacheBounds: l5 } = s7;
                      for (let e7 = 0; e7 < 3; e7++)
                        l5[e7] = 1 / 0, l5[e7 + 3] = -1 / 0, a5[e7] = 1 / 0, a5[e7 + 3] = -1 / 0, o5[e7] = 1 / 0, o5[e7 + 3] = -1 / 0;
                      BM(i5, n3, o5);
                    }
                    t7.sort(FM);
                    let p4 = i4;
                    for (let e7 = 0; e7 < p4; e7++) {
                      const n4 = t7[e7];
                      for (; e7 + 1 < p4 && t7[e7 + 1].candidate === n4.candidate; )
                        t7.splice(e7 + 1, 1), p4--;
                    }
                    for (let r7 = c4; r7 < u4; r7 += 6) {
                      const i5 = n3[r7 + 2 * e6];
                      for (let e7 = 0; e7 < p4; e7++) {
                        const s7 = t7[e7];
                        i5 >= s7.candidate ? BM(r7, n3, s7.rightCacheBounds) : (BM(r7, n3, s7.leftCacheBounds), s7.count++);
                      }
                    }
                    for (let n4 = 0; n4 < p4; n4++) {
                      const r7 = t7[n4], c5 = r7.count, u5 = i4 - r7.count, p5 = r7.leftCacheBounds, d3 = r7.rightCacheBounds;
                      let h4 = 0;
                      0 !== c5 && (h4 = OM(p5) / s6);
                      let f4 = 0;
                      0 !== u5 && (f4 = OM(d3) / s6);
                      const m3 = SM + CM * (h4 * c5 + f4 * u5);
                      m3 < l4 && (o4 = e6, l4 = m3, a4 = r7.candidate);
                    }
                  } else {
                    for (let e7 = 0; e7 < UM; e7++) {
                      const t8 = NM[e7];
                      t8.count = 0, t8.candidate = r5 + p3 + e7 * p3;
                      const n4 = t8.bounds;
                      for (let e8 = 0; e8 < 3; e8++)
                        n4[e8] = 1 / 0, n4[e8 + 3] = -1 / 0;
                    }
                    for (let t8 = c4; t8 < u4; t8 += 6) {
                      let i5 = ~~((n3[t8 + 2 * e6] - r5) / p3);
                      i5 >= UM && (i5 = UM - 1);
                      const s7 = NM[i5];
                      s7.count++, BM(t8, n3, s7.bounds);
                    }
                    const t7 = NM[UM - 1];
                    kM(t7.bounds, t7.rightCacheBounds);
                    for (let e7 = UM - 2; e7 >= 0; e7--) {
                      const t8 = NM[e7], n4 = NM[e7 + 1];
                      DM(t8.bounds, n4.rightCacheBounds, t8.rightCacheBounds);
                    }
                    let d3 = 0;
                    for (let t8 = 0; t8 < UM - 1; t8++) {
                      const n4 = NM[t8], r6 = n4.count, c5 = n4.bounds, u5 = NM[t8 + 1].rightCacheBounds;
                      0 !== r6 && (0 === d3 ? kM(c5, jM) : DM(c5, jM, jM)), d3 += r6;
                      let p4 = 0, h4 = 0;
                      0 !== d3 && (p4 = OM(jM) / s6);
                      const f4 = i4 - d3;
                      0 !== f4 && (h4 = OM(u5) / s6);
                      const m3 = SM + CM * (p4 * d3 + h4 * f4);
                      m3 < l4 && (o4 = e6, l4 = m3, a4 = n4.candidate);
                    }
                  }
                }
              } else
                console.warn(`MeshBVH: Invalid build strategy value ${s5} used.`);
              return { axis: o4, pos: a4 };
            }(t5.boundingData, h3, a3, n2, s4, d2);
            if (-1 === _3.axis)
              return r3(n2 + s4), t5.offset = n2, t5.count = s4, t5;
            const g3 = function(e5, t6, n3, r4, i4) {
              let s5 = n3, o4 = n3 + r4 - 1;
              const a4 = i4.pos, l4 = 2 * i4.axis;
              for (; ; ) {
                for (; s5 <= o4 && t6[6 * s5 + l4] < a4; )
                  s5++;
                for (; s5 <= o4 && t6[6 * o4 + l4] >= a4; )
                  o4--;
                if (!(s5 < o4))
                  return s5;
                for (let n4 = 0; n4 < 3; n4++) {
                  let r5 = e5[3 * s5 + n4];
                  e5[3 * s5 + n4] = e5[3 * o4 + n4], e5[3 * o4 + n4] = r5;
                  let i5 = t6[6 * s5 + 2 * n4 + 0];
                  t6[6 * s5 + 2 * n4 + 0] = t6[6 * o4 + 2 * n4 + 0], t6[6 * o4 + 2 * n4 + 0] = i5;
                  let a5 = t6[6 * s5 + 2 * n4 + 1];
                  t6[6 * s5 + 2 * n4 + 1] = t6[6 * o4 + 2 * n4 + 1], t6[6 * o4 + 2 * n4 + 1] = a5;
                }
                s5++, o4--;
              }
            }(l3, a3, n2, s4, _3);
            if (g3 === n2 || g3 === n2 + s4)
              r3(n2 + s4), t5.offset = n2, t5.count = s4;
            else {
              t5.splitAxis = _3.axis;
              const e5 = new PM(), r4 = n2, l4 = g3 - n2;
              t5.left = e5, e5.boundingData = new Float32Array(6), LM(a3, r4, l4, e5.boundingData, o3), i3(e5, r4, l4, o3, f3 + 1);
              const c4 = new PM(), u4 = g3, p3 = s4 - l4;
              t5.right = c4, c4.boundingData = new Float32Array(6), LM(a3, u4, p3, c4.boundingData, o3), i3(c4, u4, p3, o3, f3 + 1);
            }
            return t5;
          }
          !function(e5, t5) {
            if (!e5.index) {
              const r4 = e5.attributes.position.count, i4 = t5.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
              let s4;
              s4 = r4 > 65535 ? new Uint32Array(new i4(4 * r4)) : new Uint16Array(new i4(2 * r4)), e5.setIndex(new n.TlE(s4, 1));
              for (let e6 = 0; e6 < r4; e6++)
                s4[e6] = e6;
            }
          }(e4, t4);
          const s3 = new Float32Array(6), o3 = new Float32Array(6), a3 = function(e5, t5) {
            const n2 = e5.attributes.position, r4 = e5.index.array, i4 = r4.length / 3, s4 = new Float32Array(6 * i4), o4 = n2.normalized, a4 = n2.array, l4 = n2.offset || 0;
            let c4 = 3;
            n2.isInterleavedBufferAttribute && (c4 = n2.data.stride);
            const u4 = ["getX", "getY", "getZ"];
            for (let e6 = 0; e6 < i4; e6++) {
              const i5 = 3 * e6, p3 = 6 * e6;
              let d3, h3, f3;
              o4 ? (d3 = r4[i5 + 0], h3 = r4[i5 + 1], f3 = r4[i5 + 2]) : (d3 = r4[i5 + 0] * c4 + l4, h3 = r4[i5 + 1] * c4 + l4, f3 = r4[i5 + 2] * c4 + l4);
              for (let e7 = 0; e7 < 3; e7++) {
                let r5, i6, l5;
                o4 ? (r5 = n2[u4[e7]](d3), i6 = n2[u4[e7]](h3), l5 = n2[u4[e7]](f3)) : (r5 = a4[d3 + e7], i6 = a4[h3 + e7], l5 = a4[f3 + e7]);
                let c5 = r5;
                i6 < c5 && (c5 = i6), l5 < c5 && (c5 = l5);
                let m3 = r5;
                i6 > m3 && (m3 = i6), l5 > m3 && (m3 = l5);
                const _3 = (m3 - c5) / 2, g3 = 2 * e7;
                s4[p3 + g3 + 0] = c5 + _3, s4[p3 + g3 + 1] = _3 + (Math.abs(c5) + _3) * TM, c5 < t5[e7] && (t5[e7] = c5), m3 > t5[e7 + 3] && (t5[e7 + 3] = m3);
              }
            }
            return s4;
          }(e4, s3), l3 = e4.index.array, c3 = t4.maxDepth, u3 = t4.verbose, p2 = t4.maxLeafTris, d2 = t4.strategy, h2 = t4.onProgress, f2 = e4.index.count / 3;
          let m2 = false;
          const _2 = [], g2 = function(e5) {
            if (!e5.groups || !e5.groups.length)
              return [{ offset: 0, count: e5.index.count / 3 }];
            const t5 = [], n2 = /* @__PURE__ */ new Set();
            for (const t6 of e5.groups)
              n2.add(t6.start), n2.add(t6.start + t6.count);
            const r4 = Array.from(n2.values()).sort((e6, t6) => e6 - t6);
            for (let e6 = 0; e6 < r4.length - 1; e6++) {
              const n3 = r4[e6], i4 = r4[e6 + 1];
              t5.push({ offset: n3 / 3, count: (i4 - n3) / 3 });
            }
            return t5;
          }(e4);
          if (1 === g2.length) {
            const e5 = g2[0], t5 = new PM();
            t5.boundingData = s3, function(e6, t6, n2, r4) {
              let i4 = 1 / 0, s4 = 1 / 0, o4 = 1 / 0, a4 = -1 / 0, l4 = -1 / 0, c4 = -1 / 0;
              for (let r5 = 6 * t6, u4 = 6 * (t6 + n2); r5 < u4; r5 += 6) {
                const t7 = e6[r5 + 0];
                t7 < i4 && (i4 = t7), t7 > a4 && (a4 = t7);
                const n3 = e6[r5 + 2];
                n3 < s4 && (s4 = n3), n3 > l4 && (l4 = n3);
                const u5 = e6[r5 + 4];
                u5 < o4 && (o4 = u5), u5 > c4 && (c4 = u5);
              }
              r4[0] = i4, r4[1] = s4, r4[2] = o4, r4[3] = a4, r4[4] = l4, r4[5] = c4;
            }(a3, e5.offset, e5.count, o3), i3(t5, e5.offset, e5.count, o3), _2.push(t5);
          } else
            for (let e5 of g2) {
              const t5 = new PM();
              t5.boundingData = new Float32Array(6), LM(a3, e5.offset, e5.count, t5.boundingData, o3), i3(t5, e5.offset, e5.count, o3), _2.push(t5);
            }
          return _2;
        }(e3, t3);
        let i2, s2, o2;
        const a2 = [], l2 = t3.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
        for (let e4 = 0; e4 < r2.length; e4++) {
          const t4 = r2[e4];
          const n2 = new l2(32 * c2(t4));
          i2 = new Float32Array(n2), s2 = new Uint32Array(n2), o2 = new Uint16Array(n2), u2(0, t4), a2.push(n2);
        }
        return a2;
        function c2(e4) {
          return e4.count ? 1 : 1 + c2(e4.left) + c2(e4.right);
        }
        function u2(e4, t4) {
          const n2 = e4 / 4, r3 = e4 / 2, a3 = !!t4.count, l3 = t4.boundingData;
          for (let e5 = 0; e5 < 6; e5++)
            i2[n2 + e5] = l3[e5];
          if (a3) {
            const i3 = t4.offset, a4 = t4.count;
            return s2[n2 + 6] = i3, o2[r3 + 14] = a4, o2[r3 + 15] = MM, e4 + 32;
          }
          {
            const r4 = t4.left, i3 = t4.right, o3 = t4.splitAxis;
            let a4;
            if (a4 = u2(e4 + 32, r4), a4 / 4 > Math.pow(2, 32))
              throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
            return s2[n2 + 6] = a4 / 4, a4 = u2(a4, i3), s2[n2 + 7] = o3, a4;
          }
        }
      }(e2, t2), !e2.boundingBox && t2.setBoundingBox && (e2.boundingBox = this.getBoundingBox(new n.ZzF()))), this.geometry = e2;
    }
    refit(e2 = null) {
      e2 && Array.isArray(e2) && (e2 = new Set(e2));
      const t2 = this.geometry, n2 = t2.index.array, r2 = t2.attributes.position;
      let i2, s2, o2, a2, l2 = 0;
      const c2 = this._roots;
      for (let e3 = 0, t3 = c2.length; e3 < t3; e3++)
        i2 = c2[e3], s2 = new Uint32Array(i2), o2 = new Uint16Array(i2), a2 = new Float32Array(i2), u2(0, l2), l2 += i2.byteLength;
      function u2(t3, i3, l3 = false) {
        const c3 = 2 * t3;
        if (o2[c3 + 15] === MM) {
          const e3 = s2[t3 + 6];
          let i4 = 1 / 0, l4 = 1 / 0, u3 = 1 / 0, p2 = -1 / 0, d2 = -1 / 0, h2 = -1 / 0;
          for (let t4 = 3 * e3, s3 = 3 * (e3 + o2[c3 + 14]); t4 < s3; t4++) {
            const e4 = n2[t4], s4 = r2.getX(e4), o3 = r2.getY(e4), a3 = r2.getZ(e4);
            s4 < i4 && (i4 = s4), s4 > p2 && (p2 = s4), o3 < l4 && (l4 = o3), o3 > d2 && (d2 = o3), a3 < u3 && (u3 = a3), a3 > h2 && (h2 = a3);
          }
          return (a2[t3 + 0] !== i4 || a2[t3 + 1] !== l4 || a2[t3 + 2] !== u3 || a2[t3 + 3] !== p2 || a2[t3 + 4] !== d2 || a2[t3 + 5] !== h2) && (a2[t3 + 0] = i4, a2[t3 + 1] = l4, a2[t3 + 2] = u3, a2[t3 + 3] = p2, a2[t3 + 4] = d2, a2[t3 + 5] = h2, true);
        }
        {
          const n3 = t3 + 8, r3 = s2[t3 + 6], o3 = n3 + i3, c4 = r3 + i3;
          let p2 = l3, d2 = false, h2 = false;
          e2 ? p2 || (d2 = e2.has(o3), h2 = e2.has(c4), p2 = !d2 && !h2) : (d2 = true, h2 = true);
          const f2 = p2 || h2;
          let m2 = false;
          (p2 || d2) && (m2 = u2(n3, i3, p2));
          let _2 = false;
          f2 && (_2 = u2(r3, i3, p2));
          const g2 = m2 || _2;
          if (g2)
            for (let e3 = 0; e3 < 3; e3++) {
              const i4 = n3 + e3, s3 = r3 + e3, o4 = a2[i4], l4 = a2[i4 + 3], c5 = a2[s3], u3 = a2[s3 + 3];
              a2[t3 + e3] = o4 < c5 ? o4 : c5, a2[t3 + e3 + 3] = l4 > u3 ? l4 : u3;
            }
          return g2;
        }
      }
    }
    traverse(e2, t2 = 0) {
      const n2 = this._roots[t2], r2 = new Uint32Array(n2), i2 = new Uint16Array(n2);
      !function t3(s2, o2 = 0) {
        const a2 = 2 * s2, l2 = i2[a2 + 15] === MM;
        if (l2) {
          const t4 = r2[s2 + 6], c2 = i2[a2 + 14];
          e2(o2, l2, new Float32Array(n2, 4 * s2, 6), t4, c2);
        } else {
          const i3 = s2 + 8, a3 = r2[s2 + 6], c2 = r2[s2 + 7];
          e2(o2, l2, new Float32Array(n2, 4 * s2, 6), c2) || (t3(i3, o2 + 1), t3(a3, o2 + 1));
        }
      }(0);
    }
    raycast(e2, t2 = n.Wl3) {
      const r2 = this._roots, i2 = this.geometry, s2 = [], o2 = t2.isMaterial, a2 = Array.isArray(t2), l2 = i2.groups, c2 = o2 ? t2.side : t2;
      for (let n2 = 0, o3 = r2.length; n2 < o3; n2++) {
        const o4 = a2 ? t2[l2[n2].materialIndex].side : c2, u2 = s2.length;
        if (gT(r2[n2]), aT(0, i2, o4, e2, s2), vT(), a2) {
          const e3 = l2[n2].materialIndex;
          for (let t3 = u2, n3 = s2.length; t3 < n3; t3++)
            s2[t3].face.materialIndex = e3;
        }
      }
      return s2;
    }
    raycastFirst(e2, t2 = n.Wl3) {
      const r2 = this._roots, i2 = this.geometry, s2 = t2.isMaterial, o2 = Array.isArray(t2);
      let a2 = null;
      const l2 = i2.groups, c2 = s2 ? t2.side : t2;
      for (let n2 = 0, s3 = r2.length; n2 < s3; n2++) {
        const s4 = o2 ? t2[l2[n2].materialIndex].side : c2;
        gT(r2[n2]);
        const u2 = lT(0, i2, s4, e2);
        vT(), null != u2 && (null == a2 || u2.distance < a2.distance) && (a2 = u2, o2 && (u2.face.materialIndex = l2[n2].materialIndex));
      }
      return a2;
    }
    intersectsGeometry(e2, t2) {
      const n2 = this.geometry;
      let r2 = false;
      for (const i2 of this._roots)
        if (gT(i2), r2 = uT(0, n2, e2, t2), vT(), r2)
          break;
      return r2;
    }
    shapecast(e2, t2, n2) {
      const r2 = this.geometry;
      if (e2 instanceof Function) {
        if (t2) {
          const e3 = t2;
          t2 = (t3, n3, r3, i3) => {
            const s3 = 3 * n3;
            return e3(t3, s3, s3 + 1, s3 + 2, r3, i3);
          };
        }
        e2 = { boundsTraverseOrder: n2, intersectsBounds: e2, intersectsTriangle: t2, intersectsRange: null }, console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.");
      }
      const i2 = RT.getPrimitive();
      let { boundsTraverseOrder: s2, intersectsBounds: o2, intersectsRange: a2, intersectsTriangle: l2 } = e2;
      if (a2 && l2) {
        const e3 = a2;
        a2 = (t3, n3, s3, o3, a3) => !!e3(t3, n3, s3, o3, a3) || JM(t3, n3, r2, l2, s3, o3, i2);
      } else
        a2 || (a2 = l2 ? (e3, t3, n3, s3) => JM(e3, t3, r2, l2, n3, s3, i2) : (e3, t3, n3) => n3);
      let c2 = false, u2 = 0;
      for (const e3 of this._roots) {
        if (gT(e3), c2 = cT(0, r2, o2, a2, s2, u2), vT(), c2)
          break;
        u2 += e3.byteLength;
      }
      return RT.releasePrimitive(i2), c2;
    }
    bvhcast(e2, t2, n2) {
      let { intersectsRanges: r2, intersectsTriangles: i2 } = n2;
      const s2 = this.geometry.index, o2 = this.geometry.attributes.position, a2 = e2.geometry.index, l2 = e2.geometry.attributes.position;
      AT.copy(t2).invert();
      const c2 = RT.getPrimitive(), u2 = RT.getPrimitive();
      if (i2) {
        let d2 = function(e3, n3, r3, p3, d3, h2, f2, m2) {
          for (let _2 = r3, g2 = r3 + p3; _2 < g2; _2++) {
            KM(u2, 3 * _2, a2, l2), u2.a.applyMatrix4(t2), u2.b.applyMatrix4(t2), u2.c.applyMatrix4(t2), u2.needsUpdate = true;
            for (let t3 = e3, r4 = e3 + n3; t3 < r4; t3++)
              if (KM(c2, 3 * t3, s2, o2), c2.needsUpdate = true, i2(c2, u2, t3, _2, d3, h2, f2, m2))
                return true;
          }
          return false;
        };
        if (r2) {
          const h2 = r2;
          r2 = function(e3, t3, n3, r3, i3, s3, o3, a3) {
            return !!h2(e3, t3, n3, r3, i3, s3, o3, a3) || d2(e3, t3, n3, r3, i3, s3, o3, a3);
          };
        } else
          r2 = d2;
      }
      e2.getBoundingBox(wT), wT.applyMatrix4(t2);
      const p2 = this.shapecast({ intersectsBounds: (e3) => wT.intersectsBox(e3), intersectsRange: (t3, n3, i3, s3, o3, a3) => (bT.copy(a3), bT.applyMatrix4(AT), e2.shapecast({ intersectsBounds: (e3) => bT.intersectsBox(e3), intersectsRange: (e3, i4, a4, l3, c3) => r2(t3, n3, e3, i4, s3, o3, l3, c3) })) });
      return RT.releasePrimitive(c2), RT.releasePrimitive(u2), p2;
    }
    intersectsBox(e2, t2) {
      return xT.set(e2.min, e2.max, t2), xT.needsUpdate = true, this.shapecast({ intersectsBounds: (e3) => xT.intersectsBox(e3), intersectsTriangle: (e3) => xT.intersectsTriangle(e3) });
    }
    intersectsSphere(e2) {
      return this.shapecast({ intersectsBounds: (t2) => e2.intersectsBox(t2), intersectsTriangle: (t2) => t2.intersectsSphere(e2) });
    }
    closestPointToGeometry(e2, t2, n2 = {}, r2 = {}, i2 = 0, s2 = 1 / 0) {
      e2.boundingBox || e2.computeBoundingBox(), xT.set(e2.boundingBox.min, e2.boundingBox.max, t2), xT.needsUpdate = true;
      const o2 = this.geometry, a2 = o2.attributes.position, l2 = o2.index, c2 = e2.attributes.position, u2 = e2.index, p2 = RT.getPrimitive(), d2 = RT.getPrimitive();
      let h2 = ST, f2 = MT, m2 = null, _2 = null;
      r2 && (m2 = TT, _2 = PT);
      let g2 = 1 / 0, v2 = null, y2 = null;
      return AT.copy(t2).invert(), ET.matrix.copy(AT), this.shapecast({ boundsTraverseOrder: (e3) => xT.distanceToBox(e3), intersectsBounds: (e3, t3, n3) => n3 < g2 && n3 < s2 && (t3 && (ET.min.copy(e3.min), ET.max.copy(e3.max), ET.needsUpdate = true), true), intersectsRange: (n3, r3) => {
        if (e2.boundsTree)
          return e2.boundsTree.shapecast({ boundsTraverseOrder: (e3) => ET.distanceToBox(e3), intersectsBounds: (e3, t3, n4) => n4 < g2 && n4 < s2, intersectsRange: (e3, s3) => {
            for (let o3 = 3 * e3, b2 = 3 * (e3 + s3); o3 < b2; o3 += 3) {
              KM(d2, o3, u2, c2), d2.a.applyMatrix4(t2), d2.b.applyMatrix4(t2), d2.c.applyMatrix4(t2), d2.needsUpdate = true;
              for (let e4 = 3 * n3, t3 = 3 * (n3 + r3); e4 < t3; e4 += 3) {
                KM(p2, e4, l2, a2), p2.needsUpdate = true;
                const t4 = p2.distanceToTriangle(d2, h2, m2);
                if (t4 < g2 && (f2.copy(h2), _2 && _2.copy(m2), g2 = t4, v2 = e4 / 3, y2 = o3 / 3), t4 < i2)
                  return true;
              }
            }
          } });
        for (let e3 = 0, s3 = u2 ? u2.count : c2.count; e3 < s3; e3 += 3) {
          KM(d2, e3, u2, c2), d2.a.applyMatrix4(t2), d2.b.applyMatrix4(t2), d2.c.applyMatrix4(t2), d2.needsUpdate = true;
          for (let t3 = 3 * n3, s4 = 3 * (n3 + r3); t3 < s4; t3 += 3) {
            KM(p2, t3, l2, a2), p2.needsUpdate = true;
            const n4 = p2.distanceToTriangle(d2, h2, m2);
            if (n4 < g2 && (f2.copy(h2), _2 && _2.copy(m2), g2 = n4, v2 = t3 / 3, y2 = e3 / 3), n4 < i2)
              return true;
          }
        }
      } }), RT.releasePrimitive(p2), RT.releasePrimitive(d2), g2 === 1 / 0 ? null : (n2.point ? n2.point.copy(f2) : n2.point = f2.clone(), n2.distance = g2, n2.faceIndex = v2, r2 && (r2.point ? r2.point.copy(_2) : r2.point = _2.clone(), r2.point.applyMatrix4(AT), f2.applyMatrix4(AT), r2.distance = f2.sub(r2.point).length(), r2.faceIndex = y2), n2);
    }
    closestPointToPoint(e2, t2 = {}, n2 = 0, r2 = 1 / 0) {
      const i2 = n2 * n2, s2 = r2 * r2;
      let o2 = 1 / 0, a2 = null;
      if (this.shapecast({ boundsTraverseOrder: (t3) => (CT.copy(e2).clamp(t3.min, t3.max), CT.distanceToSquared(e2)), intersectsBounds: (e3, t3, n3) => n3 < o2 && n3 < s2, intersectsTriangle: (t3, n3) => {
        t3.closestPointToPoint(e2, CT);
        const r3 = e2.distanceToSquared(CT);
        return r3 < o2 && (ST.copy(CT), o2 = r3, a2 = n3), r3 < i2;
      } }), o2 === 1 / 0)
        return null;
      const l2 = Math.sqrt(o2);
      return t2.point ? t2.point.copy(ST) : t2.point = ST.clone(), t2.distance = l2, t2.faceIndex = a2, t2;
    }
    getBoundingBox(e2) {
      return e2.makeEmpty(), this._roots.forEach((t2) => {
        IM(0, new Float32Array(t2), IT), e2.union(IT);
      }), e2;
    }
  }
  const DT = 1e6 * (1 + 1e-7);
  function BT(e2) {
    return ~~(e2 * DT);
  }
  function OT(e2) {
    return `${BT(e2.x)},${BT(e2.y)},${BT(e2.z)}`;
  }
  const LT = [new n.Pa4(), new n.Pa4(), new n.Pa4()];
  class UT {
    constructor(e2 = null) {
      this.data = null, this.unmatchedEdges = null, this.matchedEdges = null, this.useDrawRange = true, e2 && this.updateFrom(e2);
    }
    getSiblingTriangleIndex(e2, t2) {
      const n2 = this.data[3 * e2 + t2];
      return -1 === n2 ? -1 : ~~(n2 / 3);
    }
    getSiblingEdgeIndex(e2, t2) {
      const n2 = this.data[3 * e2 + t2];
      return -1 === n2 ? -1 : n2 % 3;
    }
    updateFrom(e2) {
      const t2 = /* @__PURE__ */ new Map(), { attributes: n2 } = e2, r2 = e2.index, i2 = n2.position;
      let s2 = r2 ? r2.count / 3 : i2.count / 3;
      const o2 = s2;
      let a2 = 0;
      this.useDrawRange && (a2 = e2.drawRange.start, e2.drawRange.count !== 1 / 0 && (s2 = ~~(e2.drawRange.count / 3)));
      let l2 = this.data;
      (!l2 || l2.length < 3 * o2) && (l2 = new Int32Array(3 * o2)), l2.fill(-1);
      let c2 = 0, u2 = 0;
      for (let e3 = 0; e3 < s2; e3++) {
        const n3 = 3 * e3 + a2;
        for (let e4 = 0; e4 < 3; e4++) {
          let t3 = n3 + e4;
          r2 && (t3 = r2.getX(t3)), LT[e4].fromBufferAttribute(i2, t3);
        }
        for (let e4 = 0; e4 < 3; e4++) {
          const r3 = (e4 + 1) % 3, i3 = LT[e4], s3 = LT[r3], o3 = OT(i3), a3 = OT(s3), p2 = `${a3}_${o3}`;
          if (t2.has(p2)) {
            const r4 = t2.get(p2);
            l2[n3 + e4] = r4, l2[r4] = n3 + e4, t2.delete(p2), c2--, u2++;
          } else {
            const r4 = `${o3}_${a3}`;
            t2.set(r4, n3 + e4), c2++;
          }
        }
      }
      this.matchedEdges = u2, this.unmatchedEdges = c2, this.data = l2;
    }
  }
  class FT extends n.Kj0 {
    constructor(...e2) {
      super(...e2), this.isBrush = true, this._previousMatrix = new n.yGw(), this._previousMatrix.elements.fill(0);
    }
    markUpdated() {
      this._previousMatrix.copy(this.matrix);
    }
    isDirty() {
      const { matrix: e2, _previousMatrix: t2 } = this, n2 = e2.elements, r2 = t2.elements;
      for (let e3 = 0; e3 < 16; e3++)
        if (n2[e3] !== r2[e3])
          return true;
      return false;
    }
    prepareGeometry() {
      const e2 = this.geometry, t2 = e2.attributes;
      if (IS())
        for (const e3 in t2) {
          const n2 = t2[e3];
          if (n2.isInterleavedBufferAttribute)
            throw new Error("Brush: InterleavedBufferAttributes are not supported.");
          n2.array = RS(n2.array);
        }
      if (e2.boundsTree || (e2.boundsTree = new kT(e2, { maxLeafTris: 3 }), e2.halfEdges && e2.halfEdges.updateFrom(e2)), e2.halfEdges || (e2.halfEdges = new UT(e2)), !e2.groupIndices) {
        const t3 = e2.index.count / 3, n2 = new Uint16Array(t3), r2 = e2.groups;
        for (let e3 = 0, t4 = r2.length; e3 < t4; e3++) {
          const { start: t5, count: i2 } = r2[e3];
          for (let r3 = t5 / 3, s2 = (t5 + i2) / 3; r3 < s2; r3++)
            n2[r3] = e3;
        }
        e2.groupIndices = n2;
      }
    }
    disposeCacheData() {
      const { geometry: e2 } = this;
      e2.halfEdges = null, e2.boundsTree = null, e2.groupIndices = null;
    }
  }
  function NT(e2, t2) {
    let n2 = t2;
    return Array.isArray(t2) || (n2 = [], e2.forEach((e3) => {
      n2[e3.materialIndex] = t2;
    })), n2;
  }
  class jT {
    constructor() {
      this.triangleSplitter = new PS(), this.attributeData = new DS(), this.attributes = ["position", "uv", "normal"], this.useGroups = true, this.debug = new LS();
    }
    evaluate(e2, t2, r2, i2 = new FT()) {
      e2.prepareGeometry(), t2.prepareGeometry();
      const { triangleSplitter: s2, attributeData: o2, attributes: a2, useGroups: l2, debug: c2 } = this, u2 = i2.geometry, p2 = e2.geometry.attributes;
      for (let e3 = 0, t3 = a2.length; e3 < t3; e3++) {
        const t4 = a2[e3], n2 = p2[t4];
        o2.initializeArray(t4, n2.array.constructor);
      }
      for (const e3 in o2.attributes)
        a2.includes(e3) || o2.delete(e3);
      for (const e3 in u2.attributes)
        a2.includes(e3) || (u2.deleteAttribute(e3), u2.dispose());
      o2.clear(), c2.enabled && (c2.reset(), oM(c2)), function(e3, t3, n2, r3, i3, s3) {
        const { useGroups: o3 = true } = s3, { aIntersections: a3, bIntersections: l3 } = function(e4, t4) {
          const n3 = new US(), r4 = new US();
          return NS.copy(e4.matrixWorld).invert().multiply(t4.matrixWorld), e4.geometry.boundsTree.bvhcast(t4.geometry.boundsTree, NS, { intersectsTriangles(e5, t5, i4, s4) {
            if (e5.intersectsTriangle(t5, XS, true)) {
              if (0 === XS.distanceSq() && e5.plane.normal.dot(t5.plane.normal) < 1 - 1e-10)
                return false;
              n3.add(i4, s4), r4.add(s4, i4), sM && (sM.addEdge(XS), sM.addIntersectingTriangles(i4, e5, s4, t5));
            }
            return false;
          } }), { aIntersections: n3, bIntersections: r4 };
        }(e3, t3);
        let c3;
        c3 = o3 ? 0 : -1, wM(e3, t3, a3, n2, false, i3, c3), bM(e3, t3, a3, n2, false, r3, i3, c3), c3 = o3 ? e3.geometry.groups.length || 1 : -1, wM(t3, e3, l3, n2, true, i3, c3), bM(t3, e3, l3, n2, true, r3, i3, c3);
      }(e2, t2, r2, s2, o2, { useGroups: l2 }), c2.enabled && oM(null);
      const d2 = l2 && 0 !== e2.geometry.groups.length ? e2.geometry.groups.map((e3) => ({ ...e3 })) : [{ start: 0, count: 1 / 0, materialIndex: 0 }], h2 = l2 && 0 !== t2.geometry.groups.length ? t2.geometry.groups.map((e3) => ({ ...e3 })) : [{ start: 0, count: 1 / 0, materialIndex: 0 }], f2 = NT(d2, e2.material), m2 = NT(h2, t2.material);
      h2.forEach((e3) => {
        e3.materialIndex += f2.length;
      }), function(e3, t3, r3, i3) {
        let s3 = false, o3 = -1;
        const a3 = i3.groupCount, l3 = e3.attributes, c3 = i3.groupAttributes[0];
        for (const r4 in c3) {
          const u4 = i3.getTotalLength(r4, a3), p3 = c3[r4].type;
          let d3 = l3[r4];
          if (!d3 || d3.array.length < u4) {
            const i4 = t3.attributes[r4];
            d3 = new n.TlE(new p3(u4), i4.itemSize, i4.normalized), e3.setAttribute(r4, d3), s3 = true;
          }
          let h3 = 0;
          for (let e4 = 0; e4 < a3; e4++) {
            const { array: t4, type: n2, length: s4 } = i3.groupAttributes[e4][r4], o4 = new n2(t4.buffer, 0, s4);
            d3.array.set(o4, h3), h3 += o4.length;
          }
          d3.needsUpdate = true, o3 = u4 / d3.itemSize;
        }
        e3.setDrawRange(0, o3), e3.clearGroups();
        let u3 = 0;
        for (let t4 = 0; t4 < a3; t4++) {
          const n2 = i3.getGroupArray("position", t4).length / 3;
          if (0 !== n2) {
            const i4 = r3[t4];
            e3.addGroup(u3, n2, i4.materialIndex), u3 += n2;
          }
        }
        if (e3.index) {
          const t4 = e3.index.array;
          if (t4.length < o3)
            e3.index = null, s3 = true;
          else
            for (let e4 = 0, n2 = t4.length; e4 < n2; e4++)
              t4[e4] = e4;
        }
        e3.boundsTree = null, s3 && e3.dispose();
      }(u2, e2.geometry, [...d2, ...h2], o2);
      const _2 = u2.groups;
      if (l2) {
        const e3 = /* @__PURE__ */ new Map(), t3 = [...f2, ...m2];
        let n2 = 0;
        for (let r3 = 0, i3 = t3.length; r3 < i3; r3++)
          Boolean(_2.find((e4) => e4.materialIndex === r3)) ? (e3.set(r3, n2), n2++) : t3[r3] = null;
        for (let t4 = 0, n3 = _2.length; t4 < n3; t4++) {
          const n4 = _2[t4];
          n4.materialIndex = e3.get(n4.materialIndex);
        }
        i2.material = t3.filter((e4) => e4);
      }
      return i2;
    }
    evaluateHierarchy(e2, t2 = new FT()) {
      e2.updateMatrixWorld(true);
      const n2 = (e3, t3) => {
        const r3 = e3.children;
        for (let e4 = 0, i2 = r3.length; e4 < i2; e4++) {
          const i3 = r3[e4];
          i3.isOperationGroup ? n2(i3, t3) : t3(i3);
        }
      }, r2 = (e3) => {
        const t3 = e3.children;
        let i2 = false;
        for (let e4 = 0, n3 = t3.length; e4 < n3; e4++) {
          const n4 = t3[e4];
          i2 = r2(n4) || i2;
        }
        const s2 = e3.isDirty();
        if (s2 && e3.markUpdated(), i2 && !e3.isOperationGroup) {
          let t4;
          return n2(e3, (n3) => {
            t4 = t4 ? this.evaluate(t4, n3, n3.operation) : this.evaluate(e3, n3, n3.operation);
          }), e3._cachedGeometry = t4.geometry, e3._cachedMaterials = t4.material, true;
        }
        return i2 || s2;
      };
      return r2(e2), t2.geometry = e2._cachedGeometry, t2.material = e2._cachedMaterials, t2;
    }
    reset() {
      this.triangleSplitter.reset();
    }
  }
  const zT = { union: lS, subtract: cS, intersect: pS, difference: uS };
  function GT(e2, t2) {
    const r2 = new jT();
    r2.useGroups = true, r2.attributes = ["position", "normal", "uv"], e2.forEach((e3) => {
      for (const t3 of [...r2.attributes])
        e3[0].geometry.getAttribute(t3) || r2.attributes.splice(r2.attributes.indexOf(t3), 1);
    });
    let i2 = new FT(new n._12(0.01, 0.01, 2, 2));
    e2.forEach(([e3, t3]) => {
      if (!Object.keys(zT).includes(t3))
        return void console.error(`Unknown operation ${t3}`);
      e3.updateMatrix(), e3.updateMatrixWorld();
      const n2 = new FT();
      n2.geometry = e3.geometry, n2.material = e3.material, e3.matrixWorld.decompose(n2.position, n2.quaternion, n2.scale), n2.updateMatrix(), n2.updateMatrixWorld(), i2 = r2.evaluate(i2, n2, zT[t3]);
    });
    const s2 = i2;
    return s2.userData._isCSGMesh = true, s2;
  }
  let VT = class extends sS {
    _buildCSGMesh(e2) {
      return GT(e2);
    }
  };
  VT.PluginType = "CSGPluginBVH", VT = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  }([We("CSG Plugin (BVH)")], VT);
  class HT extends gt {
    constructor() {
      super(...arguments), this.enabled = true, this.toJSON = void 0, this._cameraChanged = (e2) => {
        var t2, n2, r2, i2;
        null === (n2 = null === (t2 = e2.lastCamera) || void 0 === t2 ? void 0 : t2.removeControlsCtor) || void 0 === n2 || n2.call(t2, this.controlsKey), null === (i2 = null === (r2 = e2.camera) || void 0 === r2 ? void 0 : r2.setControlsCtor) || void 0 === i2 || i2.call(r2, this.controlsKey, this._controlsCtor);
      };
    }
    async onAdded(e2) {
      await super.onAdded(e2), this._cameraChanged({ camera: e2.scene.activeCamera }), e2.scene.addEventListener("activeCameraChange", this._cameraChanged);
    }
    async onRemove(e2) {
      return this._cameraChanged({ lastCamera: e2.scene.activeCamera }), e2.scene.removeEventListener("activeCameraChange", this._cameraChanged), super.onRemove(e2);
    }
  }
  var QT = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  const WT = new n.Pa4(0, 0, 1), qT = new n.USm(), XT = new n._fP(), YT = new n._fP(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)), KT = new n._fP(), JT = { type: "change" };
  let ZT = class extends t.SimpleEventDispatcher {
    constructor(e2) {
      super(), this.enabled = false, this.lastOrder = "XYZ", this.dampingFactor = 0.05, this.lastQuaternion = new n._fP(), this.onDeviceOrientationChangeEvent = (e3) => {
        this.deviceOrientation = e3;
      }, this.onScreenOrientationChangeEvent = () => {
        this.screenOrientation = screen.orientation;
      }, this._initQuaternion = new n._fP(), this._initQuaternionInvert = new n._fP(), this._initQuaternionDest = new n._fP(), this._lastTime = -1, false === window.isSecureContext && console.error("DeviceOrientationControls2: DeviceOrientationEvent is only available in secure contexts (https)"), this.object = e2, this.lastOrder = this.object.rotation.order, this.object.rotation.reorder("YXZ"), this.connect();
    }
    connect() {
      this.onScreenOrientationChangeEvent(), void 0 !== window.DeviceOrientationEvent && "function" == typeof window.DeviceOrientationEvent.requestPermission ? window.DeviceOrientationEvent.requestPermission().then((e2) => {
        "granted" == e2 && (window.addEventListener("orientationchange", this.onScreenOrientationChangeEvent), window.addEventListener("deviceorientation", this.onDeviceOrientationChangeEvent));
      }).catch((e2) => {
        console.error("DeviceOrientationControls2: Unable to use DeviceOrientation API:", e2);
      }) : (window.addEventListener("orientationchange", this.onScreenOrientationChangeEvent), window.addEventListener("deviceorientation", this.onDeviceOrientationChangeEvent)), this.enabled = true, this._initQuaternion.copy(this.object.quaternion), this._initQuaternionInvert.copy(this.object.quaternion).invert();
    }
    disconnect() {
      window.removeEventListener("orientationchange", this.onScreenOrientationChangeEvent), window.removeEventListener("deviceorientation", this.onDeviceOrientationChangeEvent), this._initQuaternion.identity(), this._initQuaternionInvert.identity(), this._initQuaternionDest = new n._fP(), this.object.rotation.reorder(this.lastOrder), this.lastOrder = "XYZ", this.enabled = false;
    }
    update() {
      if (!this.enabled)
        return;
      const e2 = this.deviceOrientation;
      if (e2) {
        const t2 = null !== e2.alpha ? n.M8C.degToRad(e2.alpha) : 0, r2 = null !== e2.beta ? n.M8C.degToRad(e2.beta) : 0, i2 = null !== e2.gamma ? n.M8C.degToRad(e2.gamma) : 0, s2 = this.screenOrientation ? n.M8C.degToRad(this.screenOrientation.angle) : 0;
        this.setObjectQuaternion(t2, r2, i2, s2), 8 * (1 - this.lastQuaternion.dot(this.object.quaternion)) > 1e-6 && (this.lastQuaternion.copy(this.object.quaternion), this.dispatchEvent(JT));
      }
    }
    dispose() {
      this.disconnect();
    }
    setObjectQuaternion(e2, n2, r2, i2) {
      const s2 = (0, t.now)() / 1e3;
      qT.set(n2, e2, -r2, "YXZ"), KT.setFromEuler(qT), KT.multiply(YT), KT.multiply(XT.setFromAxisAngle(WT, -i2)), this._initQuaternionDest.__init || (this._initQuaternionDest.copy(KT).invert(), this._initQuaternionDest.__init = true), KT.premultiply(this._initQuaternionDest), this.object.quaternion.slerp(KT, this.dampingFactor / (Math.min(1, s2 - this._lastTime) / (1 / 60))), this._lastTime = s2;
    }
  };
  QT([ie(), Ue("Damping", [0, 1], 0.01)], ZT.prototype, "dampingFactor", void 0), ZT = QT([qe("Device Orientation Controls")], ZT);
  class $T extends HT {
    constructor() {
      super(...arguments), this.controlsKey = "deviceOrientation", this._controlsCtor = (e2, t2) => new ZT(e2);
    }
  }
  $T.PluginType = "DeviceOrientationControlsPlugin";
  var eP = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  const tP = new n.Pa4(), nP = new n.$V(), rP = new n.Pa4(), iP = { type: "change" };
  let sP = class extends t.SimpleEventDispatcher {
    constructor(e2, t2) {
      super(), this.enabled = true, this.enableKeys = true, this.movementSpeed = 1, this.lookSpeed = 5e-3, this.lookVertical = true, this.autoForward = false, this.activeLook = true, this.heightSpeed = false, this.heightCoef = 1, this.heightMin = 0, this.heightMax = 1, this.constrainVertical = false, this.verticalMin = 0, this.verticalMax = Math.PI, this.mouseDragOn = false, this.autoSpeedFactor = 0, this.pointerX = 0, this.pointerY = 0, this.moveForward = false, this.moveBackward = false, this.moveLeft = false, this.moveRight = false, this.moveUp = false, this.moveDown = false, this.viewHalfX = 0, this.viewHalfY = 0, this.lat = 0, this.lon = 0, this.targetPosition = new n.Pa4(), this._lastTime = -1, this.object = e2, this.domElement = t2, this.onPointerMove = this.onPointerMove.bind(this), this.onPointerDown = this.onPointerDown.bind(this), this.onPointerUp = this.onPointerUp.bind(this), this.onKeyDown = this.onKeyDown.bind(this), this.onKeyUp = this.onKeyUp.bind(this), this.onContextMenu = this.onContextMenu.bind(this), this.domElement.addEventListener("contextmenu", this.onContextMenu), this.domElement.addEventListener("pointermove", this.onPointerMove), this.domElement.addEventListener("pointerdown", this.onPointerDown), this.domElement.addEventListener("pointerup", this.onPointerUp), window.addEventListener("keydown", this.onKeyDown), window.addEventListener("keyup", this.onKeyUp), this.handleResize(), this.setOrientation();
    }
    setOrientation() {
      const e2 = this.object.quaternion;
      tP.set(0, 0, -1).applyQuaternion(e2), nP.setFromVector3(tP), this.lat = 90 - n.M8C.radToDeg(nP.phi), this.lon = n.M8C.radToDeg(nP.theta);
    }
    handleResize() {
      this.domElement === document ? (this.viewHalfX = window.innerWidth / 2, this.viewHalfY = window.innerHeight / 2) : (this.viewHalfX = this.domElement.offsetWidth / 2, this.viewHalfY = this.domElement.offsetHeight / 2);
    }
    onPointerDown(e2) {
      if (this.domElement !== document && this.domElement.focus(), this.activeLook)
        switch (e2.button) {
          case 0:
            this.moveForward = true;
            break;
          case 2:
            this.moveBackward = true;
        }
      this.mouseDragOn = true;
    }
    onPointerUp(e2) {
      if (this.activeLook)
        switch (e2.button) {
          case 0:
            this.moveForward = false;
            break;
          case 2:
            this.moveBackward = false;
        }
      this.mouseDragOn = false;
    }
    onPointerMove(e2) {
      this.domElement === document ? (this.pointerX = e2.pageX - this.viewHalfX, this.pointerY = e2.pageY - this.viewHalfY) : (this.pointerX = e2.pageX - this.domElement.offsetLeft - this.viewHalfX, this.pointerY = e2.pageY - this.domElement.offsetTop - this.viewHalfY);
    }
    onKeyDown(e2) {
      if (this.enableKeys)
        switch (e2.code) {
          case "ArrowUp":
          case "KeyW":
            this.moveForward = true;
            break;
          case "ArrowLeft":
          case "KeyA":
            this.moveLeft = true;
            break;
          case "ArrowDown":
          case "KeyS":
            this.moveBackward = true;
            break;
          case "ArrowRight":
          case "KeyD":
            this.moveRight = true;
            break;
          case "KeyR":
            this.moveUp = true;
            break;
          case "KeyF":
            this.moveDown = true;
        }
    }
    onKeyUp(e2) {
      if (this.enableKeys)
        switch (e2.code) {
          case "ArrowUp":
          case "KeyW":
            this.moveForward = false;
            break;
          case "ArrowLeft":
          case "KeyA":
            this.moveLeft = false;
            break;
          case "ArrowDown":
          case "KeyS":
            this.moveBackward = false;
            break;
          case "ArrowRight":
          case "KeyD":
            this.moveRight = false;
            break;
          case "KeyR":
            this.moveUp = false;
            break;
          case "KeyF":
            this.moveDown = false;
        }
    }
    lookAt(e2, t2, n2) {
      return e2.isVector3 ? rP.copy(e2) : void 0 === t2 || void 0 === n2 ? console.error("FirstPersonControls2.lookAt: y and z parameters are required") : rP.set(e2, t2, n2), this.object.lookAt(rP), this.setOrientation(), this;
    }
    update() {
      const e2 = (0, t.now)(), r2 = (this._lastTime < 0 ? 16 : Math.min(e2 - this._lastTime, 1e3)) / 1e3;
      if (this._lastTime = e2, !this.enabled)
        return;
      if (this.heightSpeed) {
        const e3 = n.M8C.clamp(this.object.position.y, this.heightMin, this.heightMax) - this.heightMin;
        this.autoSpeedFactor = r2 * (e3 * this.heightCoef);
      } else
        this.autoSpeedFactor = 0;
      const i2 = r2 * this.movementSpeed;
      (this.moveForward || this.autoForward && !this.moveBackward) && this.object.translateZ(-(i2 + this.autoSpeedFactor)), this.moveBackward && this.object.translateZ(i2), this.moveLeft && this.object.translateX(-i2), this.moveRight && this.object.translateX(i2), this.moveUp && this.object.translateY(i2), this.moveDown && this.object.translateY(-i2);
      let s2 = r2 * this.lookSpeed;
      this.activeLook || (s2 = 0);
      let o2 = 1;
      this.constrainVertical && (o2 = Math.PI / (this.verticalMax - this.verticalMin)), this.lon -= this.pointerX * s2, this.lookVertical && (this.lat -= this.pointerY * s2 * o2), this.lat = Math.max(-85, Math.min(85, this.lat));
      let a2 = n.M8C.degToRad(90 - this.lat);
      const l2 = n.M8C.degToRad(this.lon);
      this.constrainVertical && (a2 = n.M8C.mapLinear(a2, 0, Math.PI, this.verticalMin, this.verticalMax));
      const c2 = this.object.position;
      this.targetPosition.setFromSphericalCoords(1, a2, l2).add(c2), this.object.lookAt(this.targetPosition), this.dispatchEvent(iP);
    }
    dispose() {
      this.domElement.removeEventListener("contextmenu", this.onContextMenu), this.domElement.removeEventListener("pointerdown", this.onPointerDown), this.domElement.removeEventListener("pointermove", this.onPointerMove), this.domElement.removeEventListener("pointerup", this.onPointerUp), window.removeEventListener("keydown", this.onKeyDown), window.removeEventListener("keyup", this.onKeyUp);
    }
    onContextMenu(e2) {
      this.enableKeys && e2.preventDefault();
    }
  };
  eP([ie(), Oe()], sP.prototype, "enabled", void 0), eP([ie(), Oe()], sP.prototype, "enableKeys", void 0), eP([ie(), ze()], sP.prototype, "movementSpeed", void 0), eP([ie(), ze()], sP.prototype, "lookSpeed", void 0), eP([ie(), Oe()], sP.prototype, "lookVertical", void 0), eP([ie(), Oe()], sP.prototype, "autoForward", void 0), eP([ie(), Oe()], sP.prototype, "activeLook", void 0), eP([ie(), Oe()], sP.prototype, "heightSpeed", void 0), eP([ie(), ze()], sP.prototype, "heightCoef", void 0), eP([ie(), ze()], sP.prototype, "heightMin", void 0), eP([ie(), ze()], sP.prototype, "heightMax", void 0), eP([ie(), Oe()], sP.prototype, "constrainVertical", void 0), eP([ie(), ze()], sP.prototype, "verticalMin", void 0), eP([ie(), ze()], sP.prototype, "verticalMax", void 0), eP([ie(), Oe()], sP.prototype, "mouseDragOn", void 0), sP = eP([We("First Person Controls")], sP);
  class oP extends HT {
    constructor() {
      super(...arguments), this.controlsKey = "firstPerson", this._controlsCtor = (e2, t2) => new sP(e2, t2);
    }
  }
  oP.PluginType = "FirstPersonControlsPlugin";
  var aP = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  const lP = new n.USm(0, 0, 0, "YXZ"), cP = new n.Pa4(), uP = { type: "change" }, pP = { type: "lock" }, dP = { type: "unlock" }, hP = Math.PI / 2;
  let fP = class extends t.SimpleEventDispatcher {
    constructor(e2, t2) {
      super(), this.isLocked = false, this.enabled = true, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.pointerSpeed = 1, this.autoLockOnClick = true, this._movementX = 0, this._movementY = 0, this._forwardDirection = new n.Pa4(0, 0, -1), this.domElement = t2, this.object = e2, this.onElementClick = this.onElementClick.bind(this), this.onMouseMove = this.onMouseMove.bind(this), this.onPointerlockChange = this.onPointerlockChange.bind(this), this.onPointerlockError = this.onPointerlockError.bind(this), this.connect();
    }
    onElementClick(e2) {
      this.isLocked || this.autoLockOnClick && (e2.preventDefault(), this.lock());
    }
    onMouseMove(e2) {
      this.isLocked && (this._movementX += e2.movementX || e2.mozMovementX || e2.webkitMovementX || 0, this._movementY += e2.movementY || e2.mozMovementY || e2.webkitMovementY || 0);
    }
    onPointerlockChange() {
      this.domElement.ownerDocument.pointerLockElement === this.domElement ? (this.dispatchEvent(pP), this.isLocked = true) : (this.dispatchEvent(dP), this.isLocked = false);
    }
    onPointerlockError() {
      console.error("THREE.PointerLockControls: Unable to use Pointer Lock API");
    }
    connect() {
      this.domElement.ownerDocument.addEventListener("mousemove", this.onMouseMove), this.domElement.ownerDocument.addEventListener("pointerlockchange", this.onPointerlockChange), this.domElement.ownerDocument.addEventListener("pointerlockerror", this.onPointerlockError), this.domElement.addEventListener("click", this.onElementClick);
    }
    disconnect() {
      this.domElement.ownerDocument.removeEventListener("mousemove", this.onMouseMove), this.domElement.ownerDocument.removeEventListener("pointerlockchange", this.onPointerlockChange), this.domElement.ownerDocument.removeEventListener("pointerlockerror", this.onPointerlockError), this.domElement.removeEventListener("click", this.onElementClick);
    }
    dispose() {
      this.disconnect();
    }
    getDirection(e2) {
      return e2.copy(this._forwardDirection).applyQuaternion(this.object.quaternion);
    }
    moveForward(e2) {
      cP.setFromMatrixColumn(this.object.matrix, 0), cP.crossVectors(this.object.up, cP), this.object.position.addScaledVector(cP, e2);
    }
    moveRight(e2) {
      cP.setFromMatrixColumn(this.object.matrix, 0), this.object.position.addScaledVector(cP, e2);
    }
    lock() {
      this.domElement.requestPointerLock();
    }
    unlock() {
      this.domElement.ownerDocument.exitPointerLock();
    }
    update() {
      Math.abs(this._movementX) < 1e-4 && Math.abs(this._movementY) < 1e-4 || (lP.setFromQuaternion(this.object.quaternion), lP.y -= 2e-3 * this._movementX * this.pointerSpeed, lP.x -= 2e-3 * this._movementY * this.pointerSpeed, this._movementX = 0, this._movementY = 0, lP.x = Math.max(hP - this.maxPolarAngle, Math.min(hP - this.minPolarAngle, lP.x)), this.object.quaternion.setFromEuler(lP), this.dispatchEvent(uP));
    }
  };
  aP([Oe(), ie()], fP.prototype, "enabled", void 0), aP([ze(), ie()], fP.prototype, "minPolarAngle", void 0), aP([ze(), ie()], fP.prototype, "maxPolarAngle", void 0), aP([ze(), ie()], fP.prototype, "pointerSpeed", void 0), aP([Oe(), ie()], fP.prototype, "autoLockOnClick", void 0), fP = aP([qe("Pointer Lock Controls")], fP);
  class mP extends HT {
    constructor() {
      super(...arguments), this.controlsKey = "pointerLock", this._controlsCtor = (e2, t2) => new fP(e2, t2.ownerDocument ? t2 : t2.documentElement);
    }
  }
  mP.PluginType = "PointerLockControlsPlugin";
  const _P = { type: "change" }, gP = { type: "start" }, vP = { type: "end" };
  class yP extends n.pBf {
    constructor(e2, t2) {
      super();
      const r2 = this, i2 = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };
      this.object = e2, this.domElement = t2, this.domElement.style.touchAction = "none", this.enabled = true, this.screen = { left: 0, top: 0, width: 0, height: 0 }, this.rotateSpeed = 1, this.zoomSpeed = 1.2, this.panSpeed = 0.3, this.noRotate = false, this.noZoom = false, this.noPan = false, this.staticMoving = false, this.dynamicDampingFactor = 0.2, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.keys = ["KeyA", "KeyS", "KeyD"], this.mouseButtons = { LEFT: n.RsA.ROTATE, MIDDLE: n.RsA.DOLLY, RIGHT: n.RsA.PAN }, this.target = new n.Pa4();
      const s2 = 1e-6, o2 = new n.Pa4();
      let a2 = 1, l2 = i2.NONE, c2 = i2.NONE, u2 = 0, p2 = 0, d2 = 0;
      const h2 = new n.Pa4(), f2 = new n.FM8(), m2 = new n.FM8(), _2 = new n.Pa4(), g2 = new n.FM8(), v2 = new n.FM8(), y2 = new n.FM8(), b2 = new n.FM8(), w2 = [], A2 = {};
      this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.up0 = this.object.up.clone(), this.zoom0 = this.object.zoom, this.handleResize = function() {
        const e3 = r2.domElement.getBoundingClientRect(), t3 = r2.domElement.ownerDocument.documentElement;
        r2.screen.left = e3.left + window.pageXOffset - t3.clientLeft, r2.screen.top = e3.top + window.pageYOffset - t3.clientTop, r2.screen.width = e3.width, r2.screen.height = e3.height;
      };
      const x2 = function() {
        const e3 = new n.FM8();
        return function(t3, n2) {
          return e3.set((t3 - r2.screen.left) / r2.screen.width, (n2 - r2.screen.top) / r2.screen.height), e3;
        };
      }(), E2 = function() {
        const e3 = new n.FM8();
        return function(t3, n2) {
          return e3.set((t3 - 0.5 * r2.screen.width - r2.screen.left) / (0.5 * r2.screen.width), (r2.screen.height + 2 * (r2.screen.top - n2)) / r2.screen.width), e3;
        };
      }();
      function C2(e3) {
        false !== r2.enabled && (0 === w2.length && (r2.domElement.setPointerCapture(e3.pointerId), r2.domElement.addEventListener("pointermove", S2), r2.domElement.addEventListener("pointerup", M2)), function(e4) {
          w2.push(e4);
        }(e3), "touch" === e3.pointerType ? function(e4) {
          if (1 === (B2(e4), w2.length))
            l2 = i2.TOUCH_ROTATE, m2.copy(E2(w2[0].pageX, w2[0].pageY)), f2.copy(m2);
          else {
            l2 = i2.TOUCH_ZOOM_PAN;
            const e5 = w2[0].pageX - w2[1].pageX, t3 = w2[0].pageY - w2[1].pageY;
            p2 = u2 = Math.sqrt(e5 * e5 + t3 * t3);
            const n2 = (w2[0].pageX + w2[1].pageX) / 2, r3 = (w2[0].pageY + w2[1].pageY) / 2;
            y2.copy(x2(n2, r3)), b2.copy(y2);
          }
          r2.dispatchEvent(gP);
        }(e3) : function(e4) {
          if (l2 === i2.NONE)
            switch (e4.button) {
              case r2.mouseButtons.LEFT:
                l2 = i2.ROTATE;
                break;
              case r2.mouseButtons.MIDDLE:
                l2 = i2.ZOOM;
                break;
              case r2.mouseButtons.RIGHT:
                l2 = i2.PAN;
            }
          const t3 = c2 !== i2.NONE ? c2 : l2;
          t3 !== i2.ROTATE || r2.noRotate ? t3 !== i2.ZOOM || r2.noZoom ? t3 !== i2.PAN || r2.noPan || (y2.copy(x2(e4.pageX, e4.pageY)), b2.copy(y2)) : (g2.copy(x2(e4.pageX, e4.pageY)), v2.copy(g2)) : (m2.copy(E2(e4.pageX, e4.pageY)), f2.copy(m2)), r2.dispatchEvent(gP);
        }(e3));
      }
      function S2(e3) {
        false !== r2.enabled && ("touch" === e3.pointerType ? function(e4) {
          if (1 === (B2(e4), w2.length))
            f2.copy(m2), m2.copy(E2(e4.pageX, e4.pageY));
          else {
            const t3 = function(e5) {
              const t4 = e5.pointerId === w2[0].pointerId ? w2[1] : w2[0];
              return A2[t4.pointerId];
            }(e4), n2 = e4.pageX - t3.x, r3 = e4.pageY - t3.y;
            p2 = Math.sqrt(n2 * n2 + r3 * r3);
            const i3 = (e4.pageX + t3.x) / 2, s3 = (e4.pageY + t3.y) / 2;
            b2.copy(x2(i3, s3));
          }
        }(e3) : function(e4) {
          const t3 = c2 !== i2.NONE ? c2 : l2;
          t3 !== i2.ROTATE || r2.noRotate ? t3 !== i2.ZOOM || r2.noZoom ? t3 !== i2.PAN || r2.noPan || b2.copy(x2(e4.pageX, e4.pageY)) : v2.copy(x2(e4.pageX, e4.pageY)) : (f2.copy(m2), m2.copy(E2(e4.pageX, e4.pageY)));
        }(e3));
      }
      function M2(e3) {
        false !== r2.enabled && ("touch" === e3.pointerType ? function(e4) {
          switch (w2.length) {
            case 0:
              l2 = i2.NONE;
              break;
            case 1:
              l2 = i2.TOUCH_ROTATE, m2.copy(E2(e4.pageX, e4.pageY)), f2.copy(m2);
              break;
            case 2:
              l2 = i2.TOUCH_ZOOM_PAN;
              for (let t3 = 0; t3 < w2.length; t3++)
                if (w2[t3].pointerId !== e4.pointerId) {
                  const e5 = A2[w2[t3].pointerId];
                  m2.copy(E2(e5.x, e5.y)), f2.copy(m2);
                  break;
                }
          }
          r2.dispatchEvent(vP);
        }(e3) : (l2 = i2.NONE, r2.dispatchEvent(vP)), D2(e3), 0 === w2.length && (r2.domElement.releasePointerCapture(e3.pointerId), r2.domElement.removeEventListener("pointermove", S2), r2.domElement.removeEventListener("pointerup", M2)));
      }
      function T2(e3) {
        D2(e3);
      }
      function P2(e3) {
        false !== r2.enabled && (window.removeEventListener("keydown", P2), c2 === i2.NONE && (e3.code !== r2.keys[i2.ROTATE] || r2.noRotate ? e3.code !== r2.keys[i2.ZOOM] || r2.noZoom ? e3.code !== r2.keys[i2.PAN] || r2.noPan || (c2 = i2.PAN) : c2 = i2.ZOOM : c2 = i2.ROTATE));
      }
      function I2() {
        false !== r2.enabled && (c2 = i2.NONE, window.addEventListener("keydown", P2));
      }
      function R2(e3) {
        if (false !== r2.enabled && true !== r2.noZoom) {
          switch (e3.preventDefault(), e3.deltaMode) {
            case 2:
              g2.y -= 0.025 * e3.deltaY;
              break;
            case 1:
              g2.y -= 0.01 * e3.deltaY;
              break;
            default:
              g2.y -= 25e-5 * e3.deltaY;
          }
          r2.dispatchEvent(gP), r2.dispatchEvent(vP);
        }
      }
      function k2(e3) {
        false !== r2.enabled && e3.preventDefault();
      }
      function D2(e3) {
        delete A2[e3.pointerId];
        for (let t3 = 0; t3 < w2.length; t3++)
          if (w2[t3].pointerId == e3.pointerId)
            return void w2.splice(t3, 1);
      }
      function B2(e3) {
        let t3 = A2[e3.pointerId];
        void 0 === t3 && (t3 = new n.FM8(), A2[e3.pointerId] = t3), t3.set(e3.pageX, e3.pageY);
      }
      this.rotateCamera = function() {
        const e3 = new n.Pa4(), t3 = new n._fP(), i3 = new n.Pa4(), s3 = new n.Pa4(), o3 = new n.Pa4(), a3 = new n.Pa4();
        return function() {
          a3.set(m2.x - f2.x, m2.y - f2.y, 0);
          let n2 = a3.length();
          n2 ? (h2.copy(r2.object.position).sub(r2.target), i3.copy(h2).normalize(), s3.copy(r2.object.up).normalize(), o3.crossVectors(s3, i3).normalize(), s3.setLength(m2.y - f2.y), o3.setLength(m2.x - f2.x), a3.copy(s3.add(o3)), e3.crossVectors(a3, h2).normalize(), n2 *= r2.rotateSpeed, t3.setFromAxisAngle(e3, n2), h2.applyQuaternion(t3), r2.object.up.applyQuaternion(t3), _2.copy(e3), d2 = n2) : !r2.staticMoving && d2 && (d2 *= Math.sqrt(1 - r2.dynamicDampingFactor), h2.copy(r2.object.position).sub(r2.target), t3.setFromAxisAngle(_2, d2), h2.applyQuaternion(t3), r2.object.up.applyQuaternion(t3)), f2.copy(m2);
        };
      }(), this.zoomCamera = function() {
        let e3;
        l2 === i2.TOUCH_ZOOM_PAN ? (e3 = u2 / p2, u2 = p2, r2.object.isPerspectiveCamera ? h2.multiplyScalar(e3) : r2.object.isOrthographicCamera ? (r2.object.zoom = n.M8C.clamp(r2.object.zoom / e3, r2.minZoom, r2.maxZoom), a2 !== r2.object.zoom && r2.object.updateProjectionMatrix()) : console.warn("THREE.TrackballControls: Unsupported camera type")) : (e3 = 1 + (v2.y - g2.y) * r2.zoomSpeed, 1 !== e3 && e3 > 0 && (r2.object.isPerspectiveCamera ? h2.multiplyScalar(e3) : r2.object.isOrthographicCamera ? (r2.object.zoom = n.M8C.clamp(r2.object.zoom / e3, r2.minZoom, r2.maxZoom), a2 !== r2.object.zoom && r2.object.updateProjectionMatrix()) : console.warn("THREE.TrackballControls: Unsupported camera type")), r2.staticMoving ? g2.copy(v2) : g2.y += (v2.y - g2.y) * this.dynamicDampingFactor);
      }, this.panCamera = function() {
        const e3 = new n.FM8(), t3 = new n.Pa4(), i3 = new n.Pa4();
        return function() {
          if (e3.copy(b2).sub(y2), e3.lengthSq()) {
            if (r2.object.isOrthographicCamera) {
              const t4 = (r2.object.right - r2.object.left) / r2.object.zoom / r2.domElement.clientWidth, n2 = (r2.object.top - r2.object.bottom) / r2.object.zoom / r2.domElement.clientWidth;
              e3.x *= t4, e3.y *= n2;
            }
            e3.multiplyScalar(h2.length() * r2.panSpeed), i3.copy(h2).cross(r2.object.up).setLength(e3.x), i3.add(t3.copy(r2.object.up).setLength(e3.y)), r2.object.position.add(i3), r2.target.add(i3), r2.staticMoving ? y2.copy(b2) : y2.add(e3.subVectors(b2, y2).multiplyScalar(r2.dynamicDampingFactor));
          }
        };
      }(), this.checkDistances = function() {
        r2.noZoom && r2.noPan || (h2.lengthSq() > r2.maxDistance * r2.maxDistance && (r2.object.position.addVectors(r2.target, h2.setLength(r2.maxDistance)), g2.copy(v2)), h2.lengthSq() < r2.minDistance * r2.minDistance && (r2.object.position.addVectors(r2.target, h2.setLength(r2.minDistance)), g2.copy(v2)));
      }, this.update = function() {
        h2.subVectors(r2.object.position, r2.target), r2.noRotate || r2.rotateCamera(), r2.noZoom || r2.zoomCamera(), r2.noPan || r2.panCamera(), r2.object.position.addVectors(r2.target, h2), r2.object.isPerspectiveCamera ? (r2.checkDistances(), r2.object.lookAt(r2.target), o2.distanceToSquared(r2.object.position) > s2 && (r2.dispatchEvent(_P), o2.copy(r2.object.position))) : r2.object.isOrthographicCamera ? (r2.object.lookAt(r2.target), (o2.distanceToSquared(r2.object.position) > s2 || a2 !== r2.object.zoom) && (r2.dispatchEvent(_P), o2.copy(r2.object.position), a2 = r2.object.zoom)) : console.warn("THREE.TrackballControls: Unsupported camera type");
      }, this.reset = function() {
        l2 = i2.NONE, c2 = i2.NONE, r2.target.copy(r2.target0), r2.object.position.copy(r2.position0), r2.object.up.copy(r2.up0), r2.object.zoom = r2.zoom0, r2.object.updateProjectionMatrix(), h2.subVectors(r2.object.position, r2.target), r2.object.lookAt(r2.target), r2.dispatchEvent(_P), o2.copy(r2.object.position), a2 = r2.object.zoom;
      }, this.dispose = function() {
        r2.domElement.removeEventListener("contextmenu", k2), r2.domElement.removeEventListener("pointerdown", C2), r2.domElement.removeEventListener("pointercancel", T2), r2.domElement.removeEventListener("wheel", R2), r2.domElement.removeEventListener("pointermove", S2), r2.domElement.removeEventListener("pointerup", M2), window.removeEventListener("keydown", P2), window.removeEventListener("keyup", I2);
      }, this.domElement.addEventListener("contextmenu", k2), this.domElement.addEventListener("pointerdown", C2), this.domElement.addEventListener("pointercancel", T2), this.domElement.addEventListener("wheel", R2, { passive: false }), window.addEventListener("keydown", P2), window.addEventListener("keyup", I2), this.handleResize(), this.update();
    }
  }
  var bP = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let wP = class extends yP {
    constructor(e2, t2) {
      super(e2, t2), this.type = "TrackballControls", this.enabled = true, this.rotateSpeed = 1, this.zoomSpeed = 1.2, this.panSpeed = 0.3, this.noRotate = false, this.noZoom = false, this.noPan = false, this.noRoll = false, this.staticMoving = false, this.dynamicDampingFactor = 0.2, this.minDistance = 0, this.maxDistance = 999999, this.minZoom = 0, this.maxZoom = 999999, this.object = e2;
    }
  };
  bP([ie()], wP.prototype, "type", void 0), bP([Oe()], wP.prototype, "enabled", void 0), bP([ze(), ie()], wP.prototype, "rotateSpeed", void 0), bP([ze(), ie()], wP.prototype, "zoomSpeed", void 0), bP([ze(), ie()], wP.prototype, "panSpeed", void 0), bP([Oe(), ie()], wP.prototype, "noRotate", void 0), bP([Oe(), ie()], wP.prototype, "noZoom", void 0), bP([Oe(), ie()], wP.prototype, "noPan", void 0), bP([Oe(), ie()], wP.prototype, "noRoll", void 0), bP([Oe(), ie()], wP.prototype, "staticMoving", void 0), bP([ze(), ie()], wP.prototype, "dynamicDampingFactor", void 0), bP([ze(), ie()], wP.prototype, "minDistance", void 0), bP([ze(), ie()], wP.prototype, "maxDistance", void 0), bP([ze(), ie()], wP.prototype, "minZoom", void 0), bP([ze(), ie()], wP.prototype, "maxZoom", void 0), wP = bP([qe("Track Ball")], wP);
  class AP extends HT {
    constructor() {
      super(...arguments), this.controlsKey = "trackball", this._controlsCtor = (e2, t2) => new wP(e2, t2.ownerDocument ? t2 : t2.documentElement);
    }
  }
  AP.PluginType = "TrackballControlsPlugin";
  var xP = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  class EP extends gt {
    constructor() {
      super(), this.enabled = true, this.toJSON = void 0, this.simplifyFactor = 0.5;
    }
    get initialized() {
      return true;
    }
    async initialize() {
    }
    async onAdded(e2) {
      await super.onAdded(e2), this._pickingPlugin = e2.getPlugin(za);
    }
    simplifyGeometries(e2, t2) {
      var n2;
      if (!e2) {
        const t3 = null === (n2 = this._pickingPlugin) || void 0 === n2 ? void 0 : n2.getSelectedObject(), r3 = [];
        if (null == t3 || t3.traverse((e3) => {
          e3.geometry && !r3.includes(e3.geometry) && r3.push(e3.geometry);
        }), !(e2 = r3) || !e2.length)
          return;
      }
      Array.isArray(e2) || (e2 = [e2]);
      const r2 = [];
      for (const n3 of e2)
        r2.push(this.simplifyGeometry(n3, t2));
      return r2;
    }
    simplifyGeometry(e2, { factor: t2, count: r2, replace: i2 = true, disposeOnReplace: s2 = false } = {}) {
      var o2, a2, l2;
      if (!e2) {
        const t3 = null === (o2 = this._pickingPlugin) || void 0 === o2 ? void 0 : o2.getSelectedObject();
        if (!(e2 = null == t3 ? void 0 : t3.geometry))
          return;
      }
      if (!e2.attributes.position)
        return null === (a2 = this._viewer) || void 0 === a2 || a2.console.error("SimplifyModifierPlugin: Geometry does not have position attribute", e2), e2;
      t2 = t2 || this.simplifyFactor, r2 = r2 || e2.attributes.position.count * t2, e2.boundingBox || e2.computeBoundingBox();
      const c2 = this._simplify(e2, r2);
      c2.computeBoundingBox(), c2.computeBoundingSphere(), c2.computeVertexNormals();
      const u2 = c2.boundingBox, p2 = u2.getSize(new n.Pa4());
      if (!isFinite(p2.x) || !isFinite(p2.y) || !isFinite(p2.z))
        return null === (l2 = this._viewer) || void 0 === l2 || l2.console.error("SimplifyModifierPlugin: Unable to simplify", e2, c2, p2), e2;
      const d2 = e2.boundingBox, h2 = d2.getSize(new n.Pa4()), f2 = p2.clone().sub(h2), m2 = f2.clone().divide(h2);
      if (m2.lengthSq() > 1e-3 && console.warn("Simplify", e2, c2, u2, d2, p2, h2, f2, m2), !i2)
        return c2;
      const _2 = e2.userData.__appliedMeshes;
      if (!_2)
        return console.error("No meshes found for geometry, cannot replace", e2), c2;
      for (const e3 of _2)
        e3.setGeometry ? e3.setGeometry(c2) : e3.geometry = c2;
      return s2 && e2.dispose(true), c2;
    }
    async simplifyAll(e2, t2) {
      var n2;
      if (!e2 && this._viewer && (e2 = this._viewer.scene.modelRoot), !e2)
        return void console.error("SimplifyModifierPlugin: No root found");
      if (!this.initialized && (await this.initialize(), !this.initialized))
        return void (null === (n2 = this._viewer) || void 0 === n2 || n2.console.error("SimplifyModifierPlugin cannot be initialized"));
      const r2 = [];
      if (e2.modelObject.traverse((e3) => {
        e3.geometry && !r2.includes(e3.geometry) && r2.push(e3.geometry);
      }), r2.length)
        return this.simplifyGeometries(r2, t2);
      console.error("SimplifyModifierPlugin: No geometries found");
    }
    async simplifySelected() {
      var e2;
      if (!this._viewer)
        return;
      if (!this.initialized && (await this.initialize(), !this.initialized))
        return void await this._viewer.alert("Simplify: SimplifyModifierPlugin cannot be initialized");
      const t2 = null === (e2 = this._pickingPlugin) || void 0 === e2 ? void 0 : e2.getSelectedObject();
      if (!t2)
        return void await this._viewer.alert("Simplify: Nothing Selected");
      let n2 = false;
      t2.geometry ? 0 === t2.children.length && (n2 = true) : n2 = true, n2 || await this._viewer.confirm("Simplify: Simplify all in hierarchy?") && (n2 = true), n2 ? this.simplifyGeometries() : this.simplifyGeometry(t2.geometry);
    }
  }
  EP.PluginType = "SimplifyModifierPlugin", xP([Ue("Simplify Factor", [0, 1])], EP.prototype, "simplifyFactor", void 0), xP([je("Simplify All", { sendArgs: false })], EP.prototype, "simplifyAll", null), xP([je("Simplify Selected")], EP.prototype, "simplifySelected", null);
  var CP, SP = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let MP = CP = class extends EP {
    constructor(e2 = true, t2 = document.head) {
      super(), this.rootNode = t2, this._initializing = void 0, this.errorThreshold = 0.5, this.lockBorder = false, e2 && this.initialize();
    }
    get initialized() {
      return !!window.MeshoptSimplifier;
    }
    async initialize() {
      if (this.initialized)
        return;
      if (this._initializing)
        return await this._initializing;
      const e2 = document.createElement("script");
      e2.type = "module";
      const t2 = Math.random().toString(36).substring(7);
      return e2.innerHTML = `
import { MeshoptSimplifier } from '${CP.SIMPLIFIER_URL}';
MeshoptSimplifier.ready.then(() => {
window.MeshoptSimplifier = MeshoptSimplifier;
window.dispatchEvent(new CustomEvent('${t2}'))
});
`, this._initializing = new Promise((n2) => {
        window.addEventListener(t2, () => n2(), { once: true }), this.rootNode.appendChild(e2), this._script = e2;
      }), await this._initializing;
    }
    dispose() {
      this._script && (this._script.remove(), delete window.MeshoptSimplifier), this._script = void 0;
    }
    _simplify(e2, t2) {
      if (!this.initialized)
        throw new Error("MeshOptSimplifyModifierPlugin not initialized");
      const r2 = (e2 = e2.index ? e2.clone() : q(e2)).index.array, i2 = e2.attributes.position.array, s2 = t2 / e2.attributes.position.count, o2 = 3 * Math.floor(s2 * r2.length / 3), [a2, l2] = window.MeshoptSimplifier.simplify(r2, i2, 3, o2, this.errorThreshold, this.lockBorder ? ["LockBorder"] : []);
      return console.log("srcCount", r2.length / 3, "destCount", a2.length / 3), l2 && console.log("Simplify error", l2), e2.setIndex(new n.TlE(new Uint32Array(a2), 1)), e2;
    }
  };
  MP.PluginType = "MeshOptSimplifyModifierPlugin", MP.SIMPLIFIER_URL = "https://unpkg.com/meshoptimizer@0.20.0/meshopt_simplifier.module.js", SP([ze()], MP.prototype, "errorThreshold", void 0), SP([Oe()], MP.prototype, "lockBorder", void 0), MP = CP = SP([We("Simplify Modifier (meshopt)")], MP);
  class TP {
    constructor() {
      this._animations = [], this._playingAnimations = /* @__PURE__ */ new Set(), this._clock = new n.SUY();
    }
    loadModel(e2) {
      this._model = e2, this.mixer = new n.Xcj(e2), e2 && (this._animations = [...e2.animations]);
    }
    get getMixer() {
      return this.mixer;
    }
    get getAnimationClips() {
      return this._animations;
    }
    async playAllAnimations(e2) {
      var t2;
      const n2 = [];
      null === (t2 = this._animations) || void 0 === t2 || t2.forEach((t3) => {
        n2.push(this.playClip(t3, e2));
      }), await Promise.all(n2);
    }
    async reverseAllAnimation(e2) {
      var t2;
      const n2 = [];
      null === (t2 = this._animations) || void 0 === t2 || t2.forEach((t3) => {
        n2.push(this.playClip(t3, e2, 1, true));
      }), await Promise.all(n2);
    }
    async playClip(e2, t2, r2 = 1, i2 = false, s2 = false) {
      if (!this.mixer)
        return;
      const o2 = this.mixer.clipAction(e2);
      return this._playingAnimations.has(o2) && this.mixer.dispatchEvent({ type: "canceled", action: o2 }), s2 && (this.mixer.setTime(0), this.mixer.stopAllAction()), i2 ? (o2.paused = false, o2.timeScale = -r2) : (o2.reset(), o2.timeScale = r2), o2.loop = t2 ? n.YKA : n.jAl, o2.clampWhenFinished = true, new Promise((e3) => {
        const t3 = async (n2) => {
          n2.action === o2 && (this.mixer.removeEventListener("finished", t3), this.mixer.removeEventListener("canceled", t3), this._playingAnimations.delete(o2), e3());
        };
        this.mixer.addEventListener("finished", t3), this.mixer.addEventListener("canceled", t3), this._playingAnimations.add(o2), o2.play();
      });
    }
    playClipByName(e2, t2, n2 = 1, r2 = false) {
      let i2;
      this._animations.forEach((t3) => {
        t3.name === e2 && (i2 = t3);
      }), i2 && this.playClip(i2, t2, n2, r2);
    }
    update() {
      const e2 = this._clock.getDelta();
      return this._playingAnimations.size > 0 && (this.mixer.update(e2), true);
    }
  }
  class PP extends gt {
    constructor() {
      super(), this.helperIdentities = /* @__PURE__ */ new Map();
    }
    async onAdded(e2) {
      var t2;
      await super.onAdded(e2), null === (t2 = this._viewer) || void 0 === t2 || t2.addEventListener("postFrame", () => {
        this.helperIdentities.forEach((e3) => {
          var t3;
          e3.update() && (null === (t3 = this._viewer) || void 0 === t3 || t3.setDirty());
        });
      });
    }
    createHelper(e2, t2) {
      var n2;
      if (this.helperIdentities.has(e2))
        null === (n2 = this._viewer) || void 0 === n2 || n2.console.warn("Helper with this id already exists");
      else {
        const n3 = new TP();
        n3.loadModel(t2), this.helperIdentities.set(e2, n3);
      }
    }
    getAnimationClips(e2) {
      if (this.helperIdentities.has(e2))
        return this.helperIdentities.get(e2).getAnimationClips;
    }
    async playClip(e2, t2, n2, r2 = 1, i2 = false, s2 = false) {
      if (this.helperIdentities.has(e2)) {
        const o2 = this.helperIdentities.get(e2);
        await o2.playClip(t2, n2, r2, i2, s2);
      }
    }
    async playAllAnimations(e2, t2) {
      if (this.helperIdentities.has(e2)) {
        const n2 = this.helperIdentities.get(e2);
        await n2.playAllAnimations(t2);
      }
    }
    async playAllAnimationsInReverse(e2, t2) {
      if (this.helperIdentities.has(e2)) {
        const n2 = this.helperIdentities.get(e2);
        await n2.reverseAllAnimation(t2);
      }
    }
    async playAnimationByName(e2, t2, n2, r2 = 1, i2 = false) {
      if (this.helperIdentities.has(e2)) {
        const s2 = this.helperIdentities.get(e2);
        await s2.playClipByName(t2, n2, r2, i2);
      }
    }
  }
  PP.PluginType = "AnimationHelperPlugin";
  class IP extends gt {
    constructor() {
      super(...arguments), this.enabled = true, this.toJSON = void 0, this.defaultActions = { exportFile: async (e2, n2, r2) => {
        (0, t.downloadBlob)(e2, n2);
      } }, this.actions = { ...this.defaultActions };
    }
    async exportFile(e2, t2) {
      t2 = t2 || e2.name || "file_export", this.dispatchEvent({ type: "transferFile", path: t2, state: "exporting" }), await this.actions.exportFile(e2, t2, ({ state: e3, progress: n2 }) => {
        this.dispatchEvent({ type: "transferFile", path: t2, state: null != e3 ? e3 : "exporting", progress: n2 });
      }), this.dispatchEvent({ type: "transferFile", path: t2, state: "done" });
    }
  }
  IP.PluginType = "FileTransferPlugin";
  var RP = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  class kP extends gt {
    _onEnabledChanged1() {
      this._onEnabledChanged();
    }
    _onEnabledChanged() {
      this._viewer && (this._viewer.scene.activeCamera.interactionsEnabled = !this.enabled);
      const e2 = this._cameraViews.length;
      this._oldState = e2 < 2 ? 0 : n.M8C.clamp(this._currentState, 0, e2 - 1.001), this.enabled && this._animateCameraToView(), this.dispatchEvent({ type: "enableChanged", enabled: this.enabled });
    }
    constructor(e2 = true) {
      super(), this.enabled = true, this.animEase = "easeInOutSine", this.interpolateMode = "spherical", this.enableDamping = true, this.damping = 0.04, this.initAnimationTime = 1, this.dependencies = [zp], this._currentState = 0, this._oldState = 0, this._overrideTime = 0, this._preFrame1 = (e3) => {
        this._preFrame(e3);
      }, this.enabled = e2, this._onEnabledChanged1 = this._onEnabledChanged1.bind(this);
    }
    get _cameraViews() {
      var e2, t2, n2;
      return null !== (n2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPlugin(zp)) || void 0 === t2 ? void 0 : t2.camViews) && void 0 !== n2 ? n2 : [];
    }
    setState(e2) {
      this._currentState = e2;
    }
    async onAdded(e2) {
      await super.onAdded(e2), this.enabled && this._onEnabledChanged(), e2.addEventListener("preFrame", this._preFrame1);
    }
    async onRemove(e2) {
      return e2.removeEventListener("preFrame", this._preFrame1), this.enabled = false, super.onRemove(e2);
    }
    _preFrame(e2) {
      var t2;
      if (!this.enabled)
        return;
      const r2 = this._cameraViews;
      if (r2.length <= 1)
        return;
      if (!this._overrideStartView && Math.abs(this._currentState - this._oldState) < 1e-3)
        return;
      this.enableDamping ? this._oldState = n.M8C.lerp(this._oldState, this._currentState, this.damping) : this._oldState = this._currentState, this._oldState = n.M8C.clamp(this._oldState, 0, r2.length - 1.001);
      const i2 = Math.floor(this._oldState), s2 = this._overrideStartView || r2[i2], o2 = this._overrideEndView || r2[i2 + 1];
      let a2, l2 = this._overrideStartView ? this._overrideTime : this._oldState - i2;
      l2 = Dp[this.animEase](l2), a2 = "spherical" === this.interpolateMode ? this._lerpViewsSpherical(s2, o2, l2) : this._lerpViewsLinear(s2, o2, l2);
      const c2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.scene.activeCamera;
      c2 && (c2.position.copy(a2[0]), c2.target.copy(a2[1]), c2.positionTargetUpdated(true)), this._overrideStartView && (this._overrideTime += e2.deltaTime / 1e3, this._overrideTime >= this.initAnimationTime && (this._overrideTime = 0, this._overrideStartView = void 0, this._overrideEndView = void 0));
    }
    _lerpViewsLinear(e2, t2, r2) {
      const i2 = new n.Pa4(), s2 = new n.Pa4();
      return s2.lerpVectors(e2.position, t2.position, r2), i2.lerpVectors(e2.target, t2.target, r2), [s2, i2];
    }
    _lerpViewsSpherical(e2, t2, r2) {
      const i2 = e2.target.clone(), s2 = new n.Pa4(), o2 = new n.Pa4(), a2 = Gp(e2, e2.target), l2 = Gp(t2, t2.target), c2 = new n.$V();
      return c2.phi = Vp(a2.phi, l2.phi, r2), c2.theta = Vp(a2.theta, l2.theta, r2), c2.radius = n.M8C.lerp(a2.radius, l2.radius, r2), s2.copy(i2).lerp(t2.target, r2), o2.setFromSpherical(c2), o2.add(s2), [o2, s2];
    }
    _animateCameraToView() {
      const e2 = this._cameraViews;
      if (!this._viewer || e2.length < 2 || !this.enabled)
        return;
      this._overrideStartView = new jp(this._viewer.scene.activeCamera.position, this._viewer.scene.activeCamera.target);
      const t2 = Math.floor(this._oldState), n2 = this._oldState - t2;
      let r2;
      r2 = "spherical" === this.interpolateMode ? this._lerpViewsSpherical(e2[t2], e2[t2 + 1], n2) : this._lerpViewsLinear(e2[t2], e2[t2 + 1], n2), this._overrideEndView = new jp(r2[0], r2[1]), this._overrideTime = 0;
    }
  }
  kP.PluginType = "CameraViewControlPlugin", RP([Oe("Enabled"), (0, t.onChange)(kP.prototype._onEnabledChanged1), ie()], kP.prototype, "enabled", void 0), RP([ie(), Ne("Ease", Object.keys(Dp).map((e2) => ({ label: e2 })))], kP.prototype, "animEase", void 0), RP([ie(), Ne("Interpolation", ["spherical", "linear"].map((e2) => ({ label: e2 })))], kP.prototype, "interpolateMode", void 0), RP([Oe("Enable Damping"), ie()], kP.prototype, "enableDamping", void 0), RP([Ue("Damping", [0.01, 1], 1e-3), ie()], kP.prototype, "damping", void 0), RP([Ue("Init Anim Time", [0.01, 5], 1e-3), ie()], kP.prototype, "initAnimationTime", void 0);
  class DP extends kP {
    constructor(e2 = document.body, t2 = true) {
      super(t2), this.wrapper = document.createElement("div"), this.toJSON = void 0, this.uiConfig = { type: "folder", label: "Scrollable Camera Views", children: [...He(this)] }, "string" == typeof e2 ? (this.parent = document.getElementById(e2), this.parent || (console.error("parent doesn't exist"), this.parent = document.body)) : this.parent = e2;
    }
    _preFrame(e2) {
      var t2;
      if (this.enabled && !(this._cameraViews.length <= 1))
        try {
          const t3 = this._findActiveView(), n2 = this._getScroll(t3);
          this.setState(n2 + t3), super._preFrame(e2);
        } catch (e3) {
          return void ((null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPluginByType("Debug")) && console.error(e3));
        }
    }
    _getScroll(e2) {
      var t2, r2;
      if (e2 >= this._cameraViews.length - 1)
        return 0;
      const i2 = null !== (t2 = this.parent.querySelector(this._cameraViews[e2].name)) && void 0 !== t2 ? t2 : this.parent.getElementsByTagName("section")[e2], s2 = null !== (r2 = this.parent.querySelector(this._cameraViews[e2 + 1].name)) && void 0 !== r2 ? r2 : this.parent.getElementsByTagName("section")[e2 + 1], o2 = this.parent.getBoundingClientRect();
      if (!i2 || !s2)
        return 0;
      const a2 = i2.getBoundingClientRect(), l2 = s2.getBoundingClientRect(), c2 = this.parent === document.body ? 0 : o2.top;
      return n.M8C.clamp((c2 - a2.top) / Math.max(l2.top - a2.top, 1e-4), 0, 1);
    }
    _findActiveView() {
      var e2, t2;
      for (let n2 = this._cameraViews.length - 1; n2 >= 0; n2--) {
        const r2 = null !== (e2 = this.parent.querySelector(this._cameraViews[n2].name)) && void 0 !== e2 ? e2 : this.parent.getElementsByTagName("section")[n2], i2 = this.parent.getBoundingClientRect();
        if (r2) {
          if (r2.getBoundingClientRect().top < (this.parent === document.body ? 0 : i2.top))
            return n2;
        } else
          (null === (t2 = this._cameraViews[n2].name) || void 0 === t2 ? void 0 : t2.startsWith("#")) && console.error("section with id " + this._cameraViews[n2].name + " doesn't exist!");
      }
      return 0;
    }
  }
  DP.PluginType = "ScrollableCameraViewPlugin";
  var BP, OP = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let LP = BP = class extends DP {
    generateCode() {
      var e2;
      const t2 = document.createElement("div");
      t2.style.position = "absolute", t2.style.top = "0", t2.style.width = "100%", t2.style.height = "100%", t2.style.display = "flex", t2.style.flexDirection = "column", t2.style.justifyContent = "center", t2.style.alignItems = "center", t2.style.zIndex = "200";
      const n2 = document.createElement("textarea");
      n2.rows = 20, n2.style.border = "3px solid #27223a", n2.style.borderRadius = "5px", n2.style.width = "30%", n2.style.padding = "5px", n2.style.zIndex = "1000";
      const r2 = document.createElement("div");
      r2.textContent = "X", r2.style.color = "red", r2.style.width = "20px", r2.style.height = "20px", r2.style.padding = "2", r2.style.textAlign = "center", r2.style.backgroundColor = "white", r2.style.borderRadius = "100%", r2.style.border = "2px solid #27223a", r2.style.cursor = "pointer", r2.addEventListener("click", () => {
        var e3;
        null === (e3 = this._viewer) || void 0 === e3 || e3.container.removeChild(t2);
      });
      const i2 = document.createElement("div");
      i2.textContent = "Update", i2.style.marginTop = "10px", i2.style.color = "white", i2.style.padding = "4px 10px 4px 10px", i2.style.justifyContent = "center", i2.style.alignItems = "center", i2.style.backgroundColor = "green", i2.style.borderRadius = "10px", i2.style.border = "2px solid #fff", i2.style.cursor = "pointer", i2.addEventListener("click", () => {
        var e3, t3;
        const r3 = this.parent.innerHTML;
        this.parent.innerHTML = n2.value;
        let i3 = 0;
        for (; i3 < this._cameraViews.length; i3++) {
          let r4;
          try {
            r4 = null !== (e3 = this.parent.querySelector(this._cameraViews[i3].name)) && void 0 !== e3 ? e3 : this.parent.getElementsByTagName("section")[i3];
          } catch (e4) {
            r4 = null;
          }
          if (!r4 && i3 < 2) {
            alert("you need to add 2 sections at least");
            break;
          }
          if (!r4) {
            const e4 = (null === (t3 = this._cameraViews[i3].name) || void 0 === t3 || t3.startsWith("#"), this._cameraViews[i3].name.replace(/^#/, ""));
            n2.value += e4, n2.value = this._format(n2.value);
          }
        }
        i3 < 2 ? this.parent.innerHTML = r3 : async function(e4, t4) {
          var n3;
          e4.innerHTML = t4;
          const r4 = e4.getElementsByTagName("script");
          for (let e5 = 0; e5 < r4.length; e5++) {
            const t5 = r4[e5], i4 = Oy(t5);
            let s2 = false;
            await new Promise((e6) => {
              i4.onload = e6, i4.onerror = () => {
                s2 = true, e6(void 0);
              };
            }), s2 || null === (n3 = t5.parentNode) || void 0 === n3 || n3.replaceChild(i4, t5);
          }
        }(this.parent, n2.value);
      }), t2.appendChild(r2), t2.appendChild(n2), t2.appendChild(i2), n2.value = this._format(this.parent.innerHTML), null === (e2 = this._viewer) || void 0 === e2 || e2.container.appendChild(t2);
    }
    _onEnabledChanged() {
      super._onEnabledChanged(), this._togglePreview();
    }
    _togglePreview() {
      this.wrapper && (this.wrapper.style.zIndex = this.canvasUp ? "-100" : "100", this.wrapper.style.visibility = this.enabled ? "visible" : "hidden", this._viewer && (this._viewer.canvas.style.pointerEvents = this.enabled && this.canvasUp ? "none" : "auto"));
    }
    constructor(e2 = document.body, t2 = false) {
      super(e2, t2), this.canvasUp = false, this._togglePreview = this._togglePreview.bind(this), this.generateCode = this.generateCode.bind(this);
    }
    async onAdded(e2) {
      var t2, n2, r2, i2, s2, o2;
      this.parent = this.wrapper, await super.onAdded(e2), this._addWrapper(), this._togglePreview(), this.deserialize = this.deserialize.bind(this), this.addView = this.addView.bind(this), this.deleteView = this.deleteView.bind(this), null === (n2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(zp)) || void 0 === n2 || n2.addEventListener("viewDelete", this.deleteView), null === (i2 = null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.getPlugin(zp)) || void 0 === i2 || i2.addEventListener("deserialize", this.deserialize), null === (o2 = null === (s2 = this._viewer) || void 0 === s2 ? void 0 : s2.getPlugin(zp)) || void 0 === o2 || o2.addEventListener("viewAdd", this.addView);
    }
    deserialize(e2) {
      this._cameraViews.forEach((e3) => {
        this._createSection(e3.name);
      });
    }
    _addWrapper() {
      var e2;
      this.wrapper.style.width = "100%", this.wrapper.style.height = "100%", this.wrapper.style.zIndex = "-100", this.wrapper.style.position = "absolute", this.wrapper.style.top = "0", this.wrapper.id = "parentWrapper", this.wrapper.style.borderRadius = "10px", this.wrapper.style.overflowY = "scroll", this.wrapper.style.overflowX = "hidden", null === (e2 = this._viewer) || void 0 === e2 || e2.container.appendChild(this.wrapper);
    }
    _createSection(e2) {
      const t2 = document.createElement("section");
      t2.style.width = "100%", t2.style.height = "100%", t2.style.opacity = "50%", t2.style.backgroundColor = "black", t2.style.zIndex = "100", t2.style.top = "0", t2.textContent = e2, t2.style.color = "white", t2.style.fontSize = "100px", t2.style.display = "flex", t2.style.alignItems = "center", t2.style.justifyContent = "center", t2.id = e2, this.parent.appendChild(t2);
    }
    addView(e2) {
      this._cameraViews.forEach((e3, t2) => {
        var n2, r2;
        let i2;
        try {
          i2 = null !== (n2 = this.parent.querySelector(e3.name)) && void 0 !== n2 ? n2 : this.parent.getElementsByTagName("section")[t2];
        } catch (e4) {
          i2 = null;
        }
        if (!i2) {
          const t3 = `<section id="${(null === (r2 = e3.name) || void 0 === r2 ? void 0 : r2.startsWith("#")) ? e3.name.replace(/^#/, "") : ""}" style="width: 100%; height: 100%; opacity: 0.5; background-color: black; z-index: 100; top: 0px; color: white; font-size: 100px; display: flex; align-items: center; justify-content: center;">
                    ${e3.name}
                    </section>`;
          this.parent.innerHTML += t3;
        }
      });
    }
    deleteView(e2) {
      var t2;
      try {
        const n2 = null !== (t2 = this.parent.querySelector(e2.view.name)) && void 0 !== t2 ? t2 : this.parent.getElementsByTagName("section").namedItem(e2.view.name);
        null == n2 || n2.remove();
      } catch (e3) {
        return;
      }
    }
    _format(e2) {
      let t2 = "", n2 = "";
      return e2.split(/>\s*</).forEach(function(e3) {
        e3.match(/^\/\w/) && (n2 = n2.substring("	".length)), t2 += n2 + "<" + e3 + ">\r\n", e3.match(/^<?\w[^>]*[^/]$/) && !e3.startsWith("input") && (n2 += "	");
      }), t2.substring(1, t2.length - 3);
    }
  };
  OP([je("Show/Edit Code")], LP.prototype, "generateCode", null), OP([Oe("Canvas on top"), (0, t.onChange)(BP.prototype._togglePreview)], LP.prototype, "canvasUp", void 0), LP = BP = OP([We("Scrollable Camera View Preview (Dev)")], LP);
  var UP = { d: (e2, t2) => {
    for (var n2 in t2)
      UP.o(t2, n2) && !UP.o(e2, n2) && Object.defineProperty(e2, n2, { enumerable: true, get: t2[n2] });
  }, o: (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2) }, FP = {};
  UP.d(FP, { Q: () => iI });
  var NP = function(e2, t2, n2, r2) {
    return new (n2 || (n2 = Promise))(function(i2, s2) {
      function o2(e3) {
        try {
          l2(r2.next(e3));
        } catch (e4) {
          s2(e4);
        }
      }
      function a2(e3) {
        try {
          l2(r2.throw(e3));
        } catch (e4) {
          s2(e4);
        }
      }
      function l2(e3) {
        var t3;
        e3.done ? i2(e3.value) : (t3 = e3.value, t3 instanceof n2 ? t3 : new n2(function(e4) {
          e4(t3);
        })).then(o2, a2);
      }
      l2((r2 = r2.apply(e2, t2 || [])).next());
    });
  };
  const jP = Symbol("Comlink.proxy"), zP = Symbol("Comlink.endpoint"), GP = Symbol("Comlink.releaseProxy"), VP = Symbol("Comlink.thrown"), HP = (e2) => "object" == typeof e2 && null !== e2 || "function" == typeof e2, QP = /* @__PURE__ */ new Map([["proxy", { canHandle: (e2) => HP(e2) && e2[jP], serialize(e2) {
    const { port1: t2, port2: n2 } = new MessageChannel();
    return WP(e2, t2), [n2, [n2]];
  }, deserialize: (e2) => (e2.start(), XP(e2)) }], ["throw", { canHandle: (e2) => HP(e2) && VP in e2, serialize({ value: e2 }) {
    let t2;
    return t2 = e2 instanceof Error ? { isError: true, value: { message: e2.message, name: e2.name, stack: e2.stack } } : { isError: false, value: e2 }, [t2, []];
  }, deserialize(e2) {
    if (e2.isError)
      throw Object.assign(new Error(e2.value.message), e2.value);
    throw e2.value;
  } }]]);
  function WP(e2, t2 = self) {
    t2.addEventListener("message", function n2(r2) {
      if (!r2 || !r2.data)
        return;
      const { id: i2, type: s2, path: o2 } = Object.assign({ path: [] }, r2.data), a2 = (r2.data.argumentList || []).map(tI);
      let l2;
      try {
        const t3 = o2.slice(0, -1).reduce((e3, t4) => e3[t4], e2), n3 = o2.reduce((e3, t4) => e3[t4], e2);
        switch (s2) {
          case "GET":
            l2 = n3;
            break;
          case "SET":
            t3[o2.slice(-1)[0]] = tI(r2.data.value), l2 = true;
            break;
          case "APPLY":
            l2 = n3.apply(t3, a2);
            break;
          case "CONSTRUCT":
            l2 = $P(new n3(...a2));
            break;
          case "ENDPOINT":
            {
              const { port1: t4, port2: n4 } = new MessageChannel();
              WP(e2, n4), l2 = function(e3, t5) {
                return ZP.set(e3, t5), e3;
              }(t4, [t4]);
            }
            break;
          case "RELEASE":
            l2 = void 0;
            break;
          default:
            return;
        }
      } catch (e3) {
        l2 = { value: e3, [VP]: 0 };
      }
      Promise.resolve(l2).catch((e3) => ({ value: e3, [VP]: 0 })).then((e3) => {
        const [r3, o3] = eI(e3);
        t2.postMessage(Object.assign(Object.assign({}, r3), { id: i2 }), o3), "RELEASE" === s2 && (t2.removeEventListener("message", n2), qP(t2));
      });
    }), t2.start && t2.start();
  }
  function qP(e2) {
    (function(e3) {
      return "MessagePort" === e3.constructor.name;
    })(e2) && e2.close();
  }
  function XP(e2, t2) {
    return KP(e2, [], t2);
  }
  function YP(e2) {
    if (e2)
      throw new Error("Proxy has been released and is not useable");
  }
  function KP(e2, t2 = [], n2 = function() {
  }) {
    let r2 = false;
    const i2 = new Proxy(n2, { get(n3, s2) {
      if (YP(r2), s2 === GP)
        return () => nI(e2, { type: "RELEASE", path: t2.map((e3) => e3.toString()) }).then(() => {
          qP(e2), r2 = true;
        });
      if ("then" === s2) {
        if (0 === t2.length)
          return { then: () => i2 };
        const n4 = nI(e2, { type: "GET", path: t2.map((e3) => e3.toString()) }).then(tI);
        return n4.then.bind(n4);
      }
      return KP(e2, [...t2, s2]);
    }, set(n3, i3, s2) {
      YP(r2);
      const [o2, a2] = eI(s2);
      return nI(e2, { type: "SET", path: [...t2, i3].map((e3) => e3.toString()), value: o2 }, a2).then(tI);
    }, apply(n3, i3, s2) {
      YP(r2);
      const o2 = t2[t2.length - 1];
      if (o2 === zP)
        return nI(e2, { type: "ENDPOINT" }).then(tI);
      if ("bind" === o2)
        return KP(e2, t2.slice(0, -1));
      const [a2, l2] = JP(s2);
      return nI(e2, { type: "APPLY", path: t2.map((e3) => e3.toString()), argumentList: a2 }, l2).then(tI);
    }, construct(n3, i3) {
      YP(r2);
      const [s2, o2] = JP(i3);
      return nI(e2, { type: "CONSTRUCT", path: t2.map((e3) => e3.toString()), argumentList: s2 }, o2).then(tI);
    } });
    return i2;
  }
  function JP(e2) {
    const t2 = e2.map(eI);
    return [t2.map((e3) => e3[0]), (n2 = t2.map((e3) => e3[1]), Array.prototype.concat.apply([], n2))];
    var n2;
  }
  const ZP = /* @__PURE__ */ new WeakMap();
  function $P(e2) {
    return Object.assign(e2, { [jP]: true });
  }
  function eI(e2) {
    for (const [t2, n2] of QP)
      if (n2.canHandle(e2)) {
        const [r2, i2] = n2.serialize(e2);
        return [{ type: "HANDLER", name: t2, value: r2 }, i2];
      }
    return [{ type: "RAW", value: e2 }, ZP.get(e2) || []];
  }
  function tI(e2) {
    switch (e2.type) {
      case "HANDLER":
        return QP.get(e2.name).deserialize(e2.value);
      case "RAW":
        return e2.value;
    }
  }
  function nI(e2, t2, n2) {
    return new Promise((r2) => {
      const i2 = new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-");
      e2.addEventListener("message", function t3(n3) {
        n3.data && n3.data.id && n3.data.id === i2 && (e2.removeEventListener("message", t3), r2(n3.data));
      }), e2.start && e2.start(), e2.postMessage(Object.assign({ id: i2 }, t2), n2);
    });
  }
  class rI extends class {
  } {
    init(e2, t2, n2, r2) {
      if (!this.api) {
        if (!r2)
          throw new Error("workerFilePath is required");
        (() => {
          var i2, s2, o2;
          i2 = this, o2 = function* () {
            const i3 = yield fetch(r2).then((e3) => e3.blob()), s3 = URL.createObjectURL(i3), o3 = new Worker(s3, { type: "module" });
            this.api = yield new (XP(o3))($P(() => {
              e2(), URL.revokeObjectURL(s3);
            }), $P((e3, t3) => "xatlas_web.wasm" === e3 ? n2 : e3 + t3), $P(t2));
          }, new ((s2 = void 0) || (s2 = Promise))(function(e3, t3) {
            function n3(e4) {
              try {
                a2(o2.next(e4));
              } catch (e5) {
                t3(e5);
              }
            }
            function r3(e4) {
              try {
                a2(o2.throw(e4));
              } catch (e5) {
                t3(e5);
              }
            }
            function a2(t4) {
              var i3;
              t4.done ? e3(t4.value) : (i3 = t4.value, i3 instanceof s2 ? i3 : new s2(function(e4) {
                e4(i3);
              })).then(n3, r3);
            }
            a2((o2 = o2.apply(i2, [])).next());
          });
        })();
      }
    }
  }
  class iI extends class {
    constructor(e2, t2 = { resolution: 2048 }, n2 = {}, r2 = false, i2 = false, s2 = false) {
      this.THREE = e2, this.packOptions = t2, this.chartOptions = n2, this.useNormals = r2, this.timeUnwrap = i2, this.logProgress = s2, this._libraryLoaded = false, this._isUnwrapping = false, this.xAtlas = this._createXAtlas();
    }
    loadLibrary(e2, t2, n2) {
      return NP(this, void 0, void 0, function* () {
        if (!this._libraryLoaded) {
          for (yield new Promise((r2, i2) => {
            try {
              this.xAtlas.init(() => {
                r2();
              }, e2, t2, n2);
            } catch (e3) {
              i2(e3);
            }
          }); !this.xAtlas.api || !(yield this.xAtlas.api.loaded); )
            yield new Promise((e3) => setTimeout(e3, 100));
          this._libraryLoaded = true;
        }
      });
    }
    packAtlas(e2, t2 = "uv2", n2 = "uv") {
      return NP(this, void 0, void 0, function* () {
        if (!this._libraryLoaded)
          return console.warn("xatlas-three: library not loaded"), [];
        if (!e2)
          return [];
        if (e2.length < 1)
          return [];
        const r2 = this.chartOptions.useInputMeshUvs;
        for (; this._isUnwrapping; )
          console.log("xatlas-three: unwrapping another mesh, waiting 100 ms"), yield new Promise((e3) => setTimeout(e3, 100));
        this._isUnwrapping = true, yield this.xAtlas.api.setProgressLogging(this.logProgress), yield this.xAtlas.api.createAtlas();
        let i2 = [], s2 = "";
        for (let t3 of e2) {
          let { uuid: e3, index: n3, attributes: o3 } = t3;
          const a3 = t3.userData.worldScale || 1;
          i2.push(e3), n3 && o3.position && 3 === o3.position.itemSize ? (s2 = "Mesh" + i2.length + " added to atlas: " + e3, this.timeUnwrap && console.time(s2), yield this.xAtlas.api.addMesh(n3.array, o3.position.array, o3.normal ? o3.normal.array : void 0, o3.uv ? o3.uv.array : void 0, e3, this.useNormals, r2, a3), this.timeUnwrap && console.timeEnd(s2)) : console.warn("xatlas-three: Geometry not supported: ", t3);
        }
        s2 = "Generated atlas with " + i2.length + " meshes", this.timeUnwrap && console.time(s2);
        let o2 = yield this.xAtlas.api.generateAtlas(this.chartOptions, this.packOptions, true);
        this.timeUnwrap && console.timeEnd(s2);
        let a2 = [];
        for (let r3 of o2) {
          let i3 = e2.find((e3) => e3.uuid === r3.mesh);
          i3 ? (r3.vertex.vertices && i3.setAttribute("position", new this.THREE.BufferAttribute(r3.vertex.vertices, 3, false)), r3.vertex.normals && i3.setAttribute("normal", new this.THREE.BufferAttribute(r3.vertex.normals, 3, true)), r3.vertex.coords1 && i3.setAttribute(t2, new this.THREE.BufferAttribute(r3.vertex.coords1, 2, false)), r3.vertex.coords && t2 !== n2 && i3.setAttribute(n2, new this.THREE.BufferAttribute(r3.vertex.coords, 2, false)), r3.index && i3.setIndex(new this.THREE.BufferAttribute(r3.index, 1, false)), a2.push(i3)) : console.error("xatlas-three: Mesh not found: ", r3.mesh);
        }
        return yield this.xAtlas.api.destroyAtlas(), this._isUnwrapping = false, a2;
      });
    }
    unwrapGeometry(e2, t2 = "uv", n2 = "uv2") {
      return NP(this, void 0, void 0, function* () {
        return this.packAtlas([e2], t2, n2);
      });
    }
  } {
    _createXAtlas() {
      return new rI();
    }
  }
  var sI, oI = FP.Q, aI = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let lI = class {
    constructor() {
      this.fixWinding = false, this.maxBoundaryLength = 0, this.maxChartArea = 0, this.maxCost = 2, this.maxIterations = 1, this.normalDeviationWeight = 2, this.normalSeamWeight = 4, this.roundnessWeight = 0.009999999776482582, this.straightnessWeight = 6, this.textureSeamWeight = 0.5, this.useInputMeshUvs = false;
    }
  };
  aI([ie()], lI.prototype, "fixWinding", void 0), aI([ie()], lI.prototype, "maxBoundaryLength", void 0), aI([ie()], lI.prototype, "maxChartArea", void 0), aI([ie()], lI.prototype, "maxCost", void 0), aI([ie()], lI.prototype, "maxIterations", void 0), aI([ie()], lI.prototype, "normalDeviationWeight", void 0), aI([ie()], lI.prototype, "normalSeamWeight", void 0), aI([ie()], lI.prototype, "roundnessWeight", void 0), aI([ie()], lI.prototype, "straightnessWeight", void 0), aI([ie()], lI.prototype, "textureSeamWeight", void 0), aI([ie()], lI.prototype, "useInputMeshUvs", void 0), lI = aI([We("Chart Options"), pe("UChartOptions")], lI);
  let cI = class {
    constructor() {
      this.bilinear = true, this.blockAlign = false, this.bruteForce = false, this.createImage = false, this.maxChartSize = 0, this.padding = 0, this.resolution = 0, this.rotateCharts = true, this.rotateChartsToAxis = true, this.texelsPerUnit = 0;
    }
  };
  aI([ie()], cI.prototype, "bilinear", void 0), aI([ie()], cI.prototype, "blockAlign", void 0), aI([ie()], cI.prototype, "bruteForce", void 0), aI([ie()], cI.prototype, "createImage", void 0), aI([ie()], cI.prototype, "maxChartSize", void 0), aI([ie()], cI.prototype, "padding", void 0), aI([ie()], cI.prototype, "resolution", void 0), aI([ie()], cI.prototype, "rotateCharts", void 0), aI([ie()], cI.prototype, "rotateChartsToAxis", void 0), aI([ie()], cI.prototype, "texelsPerUnit", void 0), cI = aI([We("Pack Options"), pe("UPackOptions")], cI);
  let uI = sI = class extends gt {
    constructor(e2 = false) {
      super(), this.enabled = true, this.useNormals = true, this.chartOptions = new lI(), this.packOptions = new cI(), this._loaded = false, this._unwrapProgress = (e3, t2) => {
        console.log("Unwrapping", e3, t2);
      }, this.unwrapSelected = async () => {
        var e3, t2, n2, r2, i2;
        const s2 = null === (t2 = null === (e3 = this._viewer) || void 0 === e3 ? void 0 : e3.getPlugin(za)) || void 0 === t2 ? void 0 : t2.getSelectedObject();
        if (s2)
          if (s2.geometry) {
            if (s2.geometry.attributes.uv && !await (null === (i2 = this._viewer) || void 0 === i2 ? void 0 : i2.confirm("Unwrap: Geometry already has UVs. Overwrite?")))
              return;
            await this.unwrapGeometry(s2.geometry);
          } else
            null === (r2 = this._viewer) || void 0 === r2 || r2.alert("Unwrap: Selected object has no geometry");
        else
          null === (n2 = this._viewer) || void 0 === n2 || n2.alert("Unwrap: No object selected");
      }, e2 && this.loadLibrary();
    }
    async loadLibrary() {
      if (this._unwrapper)
        for (; !this._loaded; )
          await (0, t.timeout)(100);
      else
        this._unwrapper = new oI({ BufferAttribute: n.TlE }, this.packOptions, this.chartOptions, this.useNormals), await this._unwrapper.loadLibrary(this._unwrapProgress, sI.LIBRARY_PATH + "xatlas.wasm", sI.LIBRARY_PATH + "xatlas.js"), console.log("xatlas loaded"), this._loaded = true;
    }
    async unwrapGeometry(e2, t2 = "uv", n2 = "uv") {
      var r2;
      await this.loadLibrary(), await (null === (r2 = this._unwrapper) || void 0 === r2 ? void 0 : r2.unwrapGeometry(e2, t2, n2));
    }
    async packAtlas(e2, t2 = true, n2 = "uv2", r2 = "uv") {
      var i2;
      await this.loadLibrary(), Array.isArray(e2) || (e2 = [e2]);
      const s2 = [];
      t2 ? e2.forEach((e3) => e3.traverse((e4) => {
        e4.geometry && s2.push(e4.geometry);
      })) : e2.forEach((e3) => {
        e3.geometry && s2.push(e3.geometry);
      }), await (null === (i2 = this._unwrapper) || void 0 === i2 ? void 0 : i2.packAtlas(s2, n2, r2));
    }
    _useNormalsChanged() {
      this._unwrapper && (this._unwrapper.useNormals = this.useNormals);
    }
  };
  uI.PluginType = "XAtlasPlugin", uI.LIBRARY_PATH = "https://cdn.jsdelivr.net/npm/xatlasjs@0.1.0/dist/", aI([(0, t.onChange)(sI.prototype._useNormalsChanged), ie()], uI.prototype, "useNormals", void 0), aI([ie()], uI.prototype, "chartOptions", void 0), aI([ie()], uI.prototype, "packOptions", void 0), aI([je("Unwrap Selected Geometry")], uI.prototype, "unwrapSelected", void 0), uI = sI = aI([We("UV Unwrapping (xAtlas)")], uI);
  class pI extends gt {
    constructor() {
      super(...arguments), this.dependencies = [Ls], this.enabled = true, this.serializeWithViewer = false, this.baseUrl = "", this.variations = { objects: [], materials: [] }, this.autoDispose = true, this._ty = ["objects", "materials"], this._extForType = { objects: ["glb", "fbx", "obj", "gltf", "stl", "3dm", "json", "vjson"], materials: ["pmat", "dmat"], images: ["png", "jpg", "jpeg", "gif", "bmp", "webp", "svg"] }, this.utils = { getName: (e2) => e2.name || e2.prefix.replace(/^\//, "").replace(/\/$/, "").replaceAll("/", "_"), getTitle: (e2) => e2.title || this.utils.getName(e2), getIcon: (e2, n2) => {
        let r2 = e2.icon;
        return (r2 && /^(\w+)\(([^)]*)\)/.exec(r2) || /^#([A-Fa-f\d]+)$/.exec(r2)) && (r2 = (0, t.makeColorSvg)(r2)), r2 && r2.startsWith("http") && r2.startsWith("data:") || (r2 = this.utils.pathToIcon(this.baseUrl + n2 + "/" + e2.prefix + (r2 || ""))), r2;
      }, getItemIcon: (e2, n2, r2) => {
        const i2 = e2.iconFiles[n2];
        if (i2)
          return URL.createObjectURL(i2);
        let s2 = e2.icons[n2];
        return (s2 && /^(\w+)\(([^)]*)\)/.exec(s2) || /^#([A-Fa-f\d]+)$/.exec(s2)) && (s2 = (0, t.makeColorSvg)(s2)), s2 || (s2 = this.utils.pathToIcon(e2.items[n2])), !s2 || s2.startsWith("http") || s2.startsWith("data:") || (s2 = this.baseUrl + r2 + "/" + e2.prefix + s2), s2;
      }, getItemTitle: (e2, t2) => e2.titles[t2] || this.utils.pathToTitle(e2.items[t2]), getItemPath: (e2, t2, n2) => e2.items[t2].startsWith("http") ? e2.items[t2] : `${this.baseUrl}${n2}/${e2.prefix}${e2.items[t2]}`, pathToTitle: (e2) => e2.split("/").pop().replace(/\.[^.]*$/, ""), pathToIcon: (e2) => e2.replace(/\/$/, "").replace(/\.[^/.]+$/, "") + ".webp" }, this.toJSON = void 0;
    }
    _getVariationId(e2) {
      return this.utils.getName(e2);
    }
    async applyVariation(e2, t2, n2, r2 = false) {
      var i2, s2;
      if (!this._viewer)
        return;
      const o2 = this._getVariationId(e2);
      "number" == typeof t2 && (t2 = e2.items[t2]);
      const a2 = e2.items.indexOf(t2);
      if (-1 === a2)
        return void this._viewer.console.warn(`Item ${t2} not found`);
      const l2 = e2.itemFiles[a2], c2 = e2.selected;
      if (!r2 && c2 === a2)
        return;
      e2.selected = a2;
      const u2 = this._viewer.getManager(), p2 = this.utils.getItemPath(e2, a2, n2);
      if ("objects" === n2) {
        let e3 = this._viewer.scene.findObjectsByName(o2).map((e4) => e4.modelObject);
        0 === e3.length && (e3 = [(await this._viewer.createObject3D()).modelObject], e3[0].name = o2), this._viewer.renderEnabled = false;
        for (const t4 of e3)
          [...t4.children].forEach((e4) => e4.dispose && this.autoDispose ? e4.dispose() : e4.removeFromParent());
        const t3 = await this._loadObject(p2, l2);
        if (!t3.length)
          return void (p2.endsWith("json") || this._viewer.console.warn(`Object ${p2} not found`));
        let n3 = false;
        for (const r4 of e3) {
          [...r4.children].forEach((e4) => e4.dispose && this.autoDispose ? e4.dispose() : e4.removeFromParent());
          for (const e4 of t3)
            n3 ? r4.add(e4.modelObject.clone()) : r4.add(e4.modelObject);
          n3 = true;
        }
        const r3 = [], i3 = this.variations.materials.filter((e4) => e4 && "number" == typeof e4.selected);
        for (const e4 of i3)
          r3.push(this.applyVariation(e4, e4.selected, "materials", true));
        await Promise.all(r3), this._viewer.renderEnabled = true;
      }
      if ("materials" === n2) {
        const t3 = await this._loadMaterial(p2, l2);
        if (!t3)
          return void this._viewer.console.warn(`Material ${p2} not found`);
        t3.userData.__isVariation = true;
        const n3 = this._viewer.scene.findObjectsByName(o2), r3 = (n4) => {
          var r4, i3, s3;
          n4.material && (Array.isArray(n4.material) ? 0 !== n4.material.length && (null === (r4 = e2.data) || void 0 === r4 ? void 0 : r4.matType) !== n4.material[0].typeSlug : (null === (i3 = e2.data) || void 0 === i3 ? void 0 : i3.matType) !== n4.material.typeSlug) || null === (s3 = null == n4 ? void 0 : n4.setMaterial) || void 0 === s3 || s3.call(n4, t3);
        };
        for (const t4 of n3)
          (null === (i2 = e2.data) || void 0 === i2 ? void 0 : i2.traverse) ? t4.traverse(r3) : r3(t4);
        null === (s2 = u2.materials) || void 0 === s2 || s2.applyMaterial(t3, o2);
      }
    }
    clearVariations() {
      const e2 = this.variations.objects;
      if (this.variations.materials, this.variations = { objects: [], materials: [] }, this._viewer)
        for (const t2 of e2) {
          const e3 = this._getVariationId(t2), n2 = this._viewer.scene.findObjectsByName(e3);
          for (const e4 of n2)
            [...e4.children].forEach((e5) => {
              var t3;
              return (null !== (t3 = e5.dispose) && void 0 !== t3 ? t3 : e5.removeFromParent)();
            });
        }
    }
    async _loadMaterial(e2, t2) {
      var n2, r2, i2;
      return null === (i2 = null === (r2 = null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.getManager()) || void 0 === r2 ? void 0 : r2.importer) || void 0 === i2 ? void 0 : i2.importSinglePath(e2, { importedFile: t2 });
    }
    async _loadObject(e2, t2) {
      var n2, r2, i2;
      return null === (i2 = null === (r2 = null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.getManager()) || void 0 === r2 ? void 0 : r2.importer) || void 0 === i2 ? void 0 : i2.importPath(e2, { importedFile: t2, reimportDisposed: true });
    }
    importConfig(e2, t2) {
      var n2, r2;
      "string" == typeof e2 && (e2 = JSON.parse(e2)), void 0 !== e2.baseUrl && (this.baseUrl = e2.baseUrl), !t2 && e2.folder && (t2 = "object" == typeof e2.folder ? e2.folder : "string" == typeof e2.folder ? Is(us(e2.folder)) : Is(e2.folder));
      for (const i2 of this._ty)
        if (e2[i2])
          for (const s2 of e2[i2]) {
            const e3 = { items: s2.items, prefix: s2.prefix, name: s2.name, title: s2.title || "", icon: s2.icon || "", icons: null !== (n2 = s2.icons) && void 0 !== n2 ? n2 : s2.items.map(() => ""), titles: null !== (r2 = s2.titles) && void 0 !== r2 ? r2 : s2.items.map(() => ""), itemFiles: [], iconFiles: [], data: { ...s2.data } };
            if (t2)
              for (let n3 = 0; n3 < s2.items.length; n3++) {
                const r3 = s2.items[n3], o2 = t2[i2 + "/" + s2.prefix + r3];
                e3.itemFiles[n3] = o2 ? new File([o2], r3) : void 0;
                const a2 = s2.icons[n3];
                if (!a2)
                  continue;
                const l2 = t2[i2 + "/" + s2.prefix + a2];
                e3.iconFiles[n3] = l2 ? new File([l2], a2) : void 0;
              }
            this.variations[i2].push(e3);
          }
    }
    async importPath(e2) {
      var t2, n2;
      if (e2.endsWith(".json")) {
        const r2 = await (null === (n2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getManager().importer) || void 0 === n2 ? void 0 : n2.importSinglePath(e2, { processImported: false })), i2 = e2.split("?")[0];
        return this.baseUrl || (this.baseUrl = i2.substring(0, i2.lastIndexOf("/") + 1)), this.importConfig(r2);
      }
      e2.endsWith(".zip") ? alert("not implemented") : alert("not supported");
    }
    getMaterials(e2) {
      var t2;
      return (null === (t2 = this.variations.materials.find((t3) => this.utils.getName(t3) === e2)) || void 0 === t2 ? void 0 : t2.items) || [];
    }
    getObjects(e2) {
      var t2;
      return (null === (t2 = this.variations.objects.find((t3) => this.utils.getName(t3) === e2)) || void 0 === t2 ? void 0 : t2.items) || [];
    }
    getMaterialVariations() {
      return this.variations.materials.map((e2) => this.utils.getName(e2));
    }
    getObjectVariations() {
      return this.variations.objects.map((e2) => this.utils.getName(e2));
    }
    async onRemove(e2) {
      return super.onRemove(e2);
    }
    fromJSON(e2) {
      return super.fromJSON(e2) ? (this.importConfig(e2), this) : null;
    }
    async _exportConfiguratorState() {
      var e2;
      let t2 = { objects: {}, materials: {} };
      const n2 = { objects: [], materials: [], type: pI.PluginType };
      this.baseUrl && (n2.baseUrl = this.baseUrl);
      let r2 = false;
      for (const i2 of this._ty)
        for (const s2 of this.variations[i2]) {
          const o2 = { ...s2 };
          o2.data = { ...o2.data }, delete o2.itemFiles, delete o2.iconFiles, n2[i2].push(o2);
          const a2 = s2.prefix.replace(/^\//, ""), l2 = a2.trimEnd().endsWith("/") ? "" : a2.split("/").pop() || "", c2 = a2.replace(l2, "").trimEnd().replace(/\/$/, ""), u2 = {};
          let p2 = false;
          for (let t3 = 0; t3 < s2.items.length; t3++) {
            const n3 = s2.items[t3], r3 = s2.itemFiles[t3], i3 = s2.iconFiles[t3], o3 = s2.icons[t3];
            r3 ? (u2[l2 + n3] = new Uint8Array(await r3.arrayBuffer()), i3 && !o3 && (null === (e2 = this._viewer) || void 0 === e2 || e2.console.error("Icon file without icon name")), i3 && o3 && (u2[l2 + o3] = new Uint8Array(await i3.arrayBuffer())), p2 = true) : i3 && alert("Icon file without model/material file not supported");
          }
          if (!p2)
            continue;
          r2 = true;
          const d2 = c2.split("/");
          let h2 = t2[i2];
          for (const e3 of d2) {
            h2[e3] || (h2[e3] = {});
            const t3 = h2[e3];
            if ("object" != typeof t3)
              throw new Error("Invalid prefix: " + s2.prefix);
            h2 = t3;
          }
          Object.assign(h2, u2);
        }
      return r2 || (t2 = void 0), { folder: t2, config: n2 };
    }
  }
  pI.PluginType = "VariationConfiguratorPlugin";
  class dI extends pI {
    constructor() {
      super(), this._uiNeedRefresh = false, this._refreshUi = this._refreshUi.bind(this);
    }
    async onAdded(e2) {
      await super.onAdded(e2), e2.addEventListener("preFrame", this._refreshUi);
    }
    async onRemove(e2) {
      return e2.removeEventListener("preFrame", this._refreshUi), super.onRemove(e2);
    }
    refreshUi() {
      this.enabled && (this._uiNeedRefresh = true);
    }
    async _refreshUi() {
      if (!this.enabled)
        return false;
      if (!this._viewer || !this._uiNeedRefresh)
        return false;
      this._uiNeedRefresh = false, am.RemoveAll(dI.PluginType);
      for (const e2 of ["objects", "materials"])
        for (const t2 of this.variations[e2])
          am.Create(dI.PluginType, this.utils.getTitle(t2), 5, 20, 0, t2.items.map((n2, r2) => ({ id: n2, image: this.utils.getItemIcon(t2, r2, e2), onClick: async (n3) => this.applyVariation(t2, n3, e2, false), tooltip: this.utils.getItemTitle(t2, r2) })), (e3, t3) => Mg(e3, { placement: "bottom", content: t3.tooltip }));
      return am.RebuildUi(this._viewer.container), true;
    }
  }
  dI.PluginType = "VariationConfiguratorPlugin";
  class hI extends dI {
    constructor() {
      super(...arguments), this._uiExpandedState = {}, this.uiConfig = { type: "folder", label: "Configurator", children: [{ type: "input", label: "Base URL", property: [this, "baseUrl"] }, ...this._ty.map((e2) => ({ type: "folder", expanded: this._uiExpandedState["__/" + e2], onExpand: () => this._uiExpandedState["__/" + e2] = true, onCollapse: () => this._uiExpandedState["__/" + e2] = false, label: e2, children: [() => this.variations[e2].map((n2) => ({ type: "folder", expanded: this._uiExpandedState[n2.name], onExpand: () => this._uiExpandedState[n2.name] = true, onCollapse: () => this._uiExpandedState[n2.name] = false, label: () => this.utils.getName(n2), children: [{ type: "input", placeholder: () => this.utils.getName(n2), property: [n2, "name"] }, { type: "input", property: [n2, "prefix"] }, { type: "input", placeholder: () => this.utils.pathToTitle(this.utils.getName(n2)), property: [n2, "title"] }, { type: "input", placeholder: () => this.utils.pathToIcon(this.baseUrl + n2.prefix), property: [n2, "icon"] }, { type: "folder", label: "items", children: n2.items.map((r2, i2) => ({ type: "folder", label: () => n2.items[i2], children: [{ type: "input", label: "File/URL", isMonitor: !n2.itemFiles[i2], getValue: () => n2.items[i2], setValue: (e3) => {
        n2.items[i2] = e3;
      } }, { type: "input", label: "Icon/Image", placeholder: this.utils.pathToIcon(n2.items[i2]), getValue: () => n2.icons[i2], setValue: (e3) => {
        n2.icons[i2] = e3;
      } }, { type: "input", label: "Title", placeholder: this.utils.pathToTitle(n2.items[i2]), getValue: () => n2.titles[i2], setValue: (e3) => {
        n2.titles[i2] = e3;
      } }, { type: "button", label: "Apply", value: async () => this.applyVariation(n2, i2, e2) }, n2.itemFiles[i2] ? [{ type: "button", label: "Remove", value: () => {
        n2.items.splice(i2, 1), n2.itemFiles.splice(i2, 1), this.refreshUi();
      } }, { type: "button", label: "Replace", value: async () => {
        const e3 = await (0, t.uploadFile)(false, false);
        0 !== e3.length && (n2.itemFiles[i2] = e3[0], n2.items[i2] = e3[0].name, this.refreshUi());
      } }, { type: "button", label: "Download", value: async () => {
        const e3 = n2.itemFiles[i2];
        (0, t.downloadBlob)(e3, e3.name);
      } }] : {}] })) }, { type: "button", label: "Add item (local)", value: async () => {
        var r2, i2, s2;
        const o2 = await (0, t.uploadFile)(true, false);
        if (0 !== o2.length) {
          for (const t2 of o2) {
            if (!this._extForType[e2].includes(null !== (r2 = t2.name.split(".").pop()) && void 0 !== r2 ? r2 : "")) {
              await (null === (i2 = this._viewer) || void 0 === i2 ? void 0 : i2.alert(`Invalid file: ${t2.name} is not a valid ${e2} file`));
              continue;
            }
            if (n2.items.includes(t2.name)) {
              await (null === (s2 = this._viewer) || void 0 === s2 ? void 0 : s2.alert(`Already exists: Item with name ${t2.name} already exists`));
              continue;
            }
            const o3 = n2.items.push(t2.name) - 1;
            n2.icons[o3] = "", n2.titles[o3] = "", n2.itemFiles[o3] = t2;
          }
          this.refreshUi();
        }
      } }, { type: "button", label: "Add item (url)", value: async () => {
        var t2, r2, i2, s2, o2;
        const a2 = await (null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.prompt("URL: Enter the url of the object/material"));
        if (!a2)
          return;
        if (!a2.startsWith("http") && !this.baseUrl.startsWith("http"))
          return void await (null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.alert(`Invalid url: ${a2} should be a valid HTTP(S) url. If you are passing a relative path, set the baseURL first`));
        if (!this._extForType[e2].includes(null !== (i2 = a2.split(".").pop()) && void 0 !== i2 ? i2 : ""))
          return void await (null === (s2 = this._viewer) || void 0 === s2 ? void 0 : s2.alert(`Invalid url: ${a2} should be of a material ending with mat`));
        n2.items.includes(a2) && await (null === (o2 = this._viewer) || void 0 === o2 ? void 0 : o2.alert(`Already exists: Item with url ${a2} already exists`)), n2.items.push(a2);
        const l2 = n2.items.length - 1;
        n2.icons[l2] = "", n2.titles[l2] = "", this.refreshUi();
      } }, { type: "button", label: () => "Remove " + this.utils.getName(n2), value: async () => {
        var t2;
        await (null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.confirm(`Delete Group: Are you sure you want to remove ${this.utils.getName(n2)}?`)) && (this.variations[e2].splice(this.variations[e2].indexOf(n2), 1), this.refreshUi());
      } }] })), { type: "button", label: `Add ${e2} group (empty)`, value: async () => {
        var t2;
        const n2 = await (null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.prompt("Name: Enter the name of the object/material"));
        n2 && (this.variations[e2].push({ items: [], itemFiles: [], icons: [], iconFiles: [], titles: [], prefix: n2 + "/", name: n2, icon: "", title: "" }), this.refreshUi());
      } }, { type: "button", label: `Add ${e2} group (local folder)`, value: async () => {
        var n2, r2, i2, s2;
        const o2 = await (0, t.uploadFile)(false, true);
        if (0 === o2.length)
          return;
        const a2 = [], l2 = [], c2 = [], u2 = [];
        for (const t2 of o2) {
          if (t2.name.startsWith("."))
            continue;
          const s3 = null !== (n2 = t2.name.split(".").pop()) && void 0 !== n2 ? n2 : "";
          s3 ? this._extForType[e2].includes(s3) ? (a2.push(t2.webkitRelativePath.replace(/^\//, "")), l2.push(t2)) : this._extForType.images.includes(s3) ? (c2.push(t2.webkitRelativePath.replace(/^\//, "")), u2.push(t2)) : await (null === (i2 = this._viewer) || void 0 === i2 ? void 0 : i2.alert(`Invalid file: ${t2.name} is not a valid ${e2} file`)) : await (null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.alert(`Invalid file: ${t2.name} has no extension`));
        }
        const p2 = (0, t.longestCommonPrefix)(a2), d2 = this.utils.getName({ prefix: p2 });
        let h2 = await (null === (s2 = this._viewer) || void 0 === s2 ? void 0 : s2.prompt("Name: Enter the name of the object/material", d2, true));
        if (null === h2)
          return;
        h2 = h2 || d2;
        const f2 = a2.map((e3) => {
          var t2;
          const n3 = e3.replace(p2, ""), r3 = null !== (t2 = n3.split(".").pop()) && void 0 !== t2 ? t2 : "", i3 = n3.replace("." + r3, "") + ".", s3 = c2.findIndex((e4) => e4.replace(p2, "").startsWith(i3));
          return s3 < 0 ? ["", void 0] : [c2[s3].replace(p2, ""), u2[s3] || void 0];
        });
        this.variations[e2].push({ items: a2.map((e3) => e3.replace(p2, "")), icons: f2.map((e3) => e3[0]), iconFiles: f2.map((e3) => e3[1]), titles: a2.map(() => ""), itemFiles: l2, prefix: p2, name: h2, icon: "", title: "" }), this.refreshUi();
      } }] })), { type: "button", label: "Download JSON/Zip", value: async () => {
        var e2, n2;
        try {
          const { folder: e3, config: n3 } = await this._exportConfiguratorState(), r2 = JSON.stringify(n3, null, 4);
          if (e3) {
            e3["config.json"] = us(r2);
            const n4 = await Es(e3), i2 = new Blob([n4], { type: "application/zip" });
            (0, t.downloadBlob)(i2, "configurator.zip");
          } else {
            const e4 = new Blob([r2], { type: "application/json" });
            (0, t.downloadBlob)(e4, "config.json");
          }
        } catch (t2) {
          return null === (e2 = this._viewer) || void 0 === e2 || e2.console.error(t2), void await (null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.alert("Error: " + ((null == t2 ? void 0 : t2.message) || t2)));
        }
      } }, { type: "button", label: "Load JSON/Zip", value: async () => {
        var e2, n2, r2;
        const i2 = await (0, t.uploadFile)(false, false, "application/zip,application/json");
        if (0 === i2.length)
          return;
        const s2 = i2[0];
        if (s2.name.endsWith(".zip")) {
          const t2 = Is(new Uint8Array(await s2.arrayBuffer()));
          if (!t2["config.json"])
            return void await (null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.alert("Invalid zip: config.json not found"));
          const n3 = JSON.parse(ps(t2["config.json"]));
          this.importConfig(n3, t2);
        } else {
          if (!s2.name.endsWith(".json"))
            return void await (null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.alert("Invalid file: " + s2.name));
          {
            const e3 = JSON.parse(await s2.text());
            this.importConfig(e3);
          }
        }
        await (null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.alert("Imported successfully")), this.refreshUi();
      } }, { type: "button", label: "Import Path", value: async () => {
        var e2, t2;
        const n2 = await (null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.prompt("URL: Enter the url of the json file."));
        n2 && (await this.importPath(n2), await (null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.alert("Imported successfully")), this.refreshUi());
      } }, { type: "button", label: "Refresh UI", value: () => {
        this.refreshUi();
      } }, { type: "button", label: "Clear All", value: async () => {
        var e2;
        await (null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.confirm("Clear: Are you sure you want to clear the configuration ?")) && (this.variations.objects = [], this.variations.materials = [], this.refreshUi());
      } }] };
    }
    _refreshUiConfig() {
      var e2, t2;
      null === (t2 = null === (e2 = this.uiConfig) || void 0 === e2 ? void 0 : e2.uiRefresh) || void 0 === t2 || t2.call(e2, "postFrame", true);
    }
    refreshUi() {
      this._refreshUiConfig(), super.refreshUi();
    }
    async _loadObject(e2, t2) {
      const n2 = await super._loadObject(e2, t2);
      for (const e3 of n2)
        (e3.modelObject || e3).userData.excludeFromExport = true;
      return n2;
    }
  }
  hI.PluginType = "VariationConfiguratorPlugin";
  class fI extends gt {
    constructor() {
      super(), this.toJSON = void 0, this.enabled = true, this._addSceneObject = (e2) => {
        const t2 = e2.object;
        (null == t2 ? void 0 : t2.traverse) && t2.traverse((e3) => {
          var t3, n2;
          void 0 === e3.userData[fI.PluginType] && (e3.userData[fI.PluginType] = { transforms: [] });
          const r2 = { type: "folder", label: "Transform Animation", children: [{ type: "button", label: "Add Current Transform", value: () => {
            var t4;
            this.addTransform(e3), null === (t4 = null == r2 ? void 0 : r2.uiRefresh) || void 0 === t4 || t4.call(r2);
          } }, () => {
            var t4;
            return null === (t4 = e3.userData[fI.PluginType]) || void 0 === t4 ? void 0 : t4.transforms.map((t5, n3) => ({ type: "folder", label: `Transform ${n3}`, children: [{ type: "vec3", label: "Position", property: [t5, "position"] }, { type: "vec3", label: "Quaternion", property: [t5, "quaternion"] }, { type: "vec3", label: "Scale", property: [t5, "scale"] }, { type: "button", label: "Set", value: () => {
              this.setTransform(e3, t5);
            } }, { type: "button", label: "Animate", value: () => {
              this.animateTransform(e3, t5);
            } }] }));
          }] };
          null === (n2 = null === (t3 = e3.uiConfig) || void 0 === t3 ? void 0 : t3.children) || void 0 === n2 || n2.push(r2);
        });
      };
    }
    async onAdded(e2) {
      await super.onAdded(e2), e2.scene.addEventListener("addSceneObject", this._addSceneObject);
    }
    async onRemove(e2) {
      return e2.scene.removeEventListener("addSceneObject", this._addSceneObject), super.onRemove(e2);
    }
    addTransform(e2) {
      e2.userData[fI.PluginType].transforms.push({ position: e2.position.clone(), quaternion: e2.quaternion.clone(), scale: e2.scale.clone() });
    }
    setTransform(e2, t2) {
      var n2, r2, i2, s2;
      e2.position.copy(t2.position), e2.quaternion.copy(t2.quaternion), e2.scale.copy(t2.scale), null === (r2 = (n2 = e2.userData).setDirty) || void 0 === r2 || r2.call(n2), null === (s2 = null === (i2 = e2.uiConfig) || void 0 === i2 ? void 0 : i2.uiRefresh) || void 0 === s2 || s2.call(i2);
    }
    animateTransform(e2, t2, r2 = 2e3) {
      var i2, s2;
      const o2 = null === (i2 = this._viewer) || void 0 === i2 ? void 0 : i2.getPluginByType("PopmotionPlugin");
      o2 || null === (s2 = this._viewer) || void 0 === s2 || s2.console.error("PopmotionPlugin required for animation");
      const a2 = "number" == typeof t2 ? e2.userData[fI.PluginType].transforms[t2] : t2, l2 = new n.Pa4(), c2 = new n._fP(), u2 = new n.Pa4(), p2 = e2.position.clone(), d2 = e2.quaternion.clone(), h2 = e2.scale.clone(), f2 = a2.position, m2 = a2.quaternion, _2 = a2.scale;
      return null == o2 ? void 0 : o2.animate({ from: 0, to: 1, duration: r2, onUpdate: (t3) => {
        var n2, r3;
        l2.lerpVectors(p2, f2, t3), c2.slerpQuaternions(d2, m2, t3), u2.lerpVectors(h2, _2, t3), e2.position.copy(l2), e2.quaternion.copy(c2), e2.scale.copy(u2), null === (n2 = this._viewer) || void 0 === n2 || n2.setDirty(), null === (r3 = this._viewer) || void 0 === r3 || r3.renderer.resetShadows();
      }, onStop: () => {
        var t3, n2, r3, i3;
        e2.position.copy(a2.position), e2.quaternion.copy(a2.quaternion), e2.scale.copy(a2.scale), null === (n2 = (t3 = e2.userData).setDirty) || void 0 === n2 || n2.call(t3), null === (i3 = null === (r3 = e2.uiConfig) || void 0 === r3 ? void 0 : r3.uiRefresh) || void 0 === i3 || i3.call(r3);
      } });
    }
  }
  fI.PluginType = "TransformAnimationPlugin";
  var mI = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let _I = class extends gt {
    constructor(e2 = true) {
      super(), this.enabled = true, this.toJSON = void 0, this.cameras = [], this._preRender = () => {
        if (this.enabled && this._viewer)
          for (const e3 of this.cameras) {
            if (!e3.enabled)
              continue;
            const t2 = this._viewer, n2 = e3.camera;
            try {
              this.dispatchEvent({ type: "preRenderCamera", camera: e3 }), t2.scene.renderCamera = n2, t2.renderer.render(false);
              const r2 = t2.renderer.composer.readBuffer;
              this.dispatchEvent({ type: "preBlitCamera", camera: e3, readBuffer: r2 }), t2.renderer.blit(r2.texture, e3.target), this.dispatchEvent({ type: "postRenderCamera", camera: e3 });
            } catch (t3) {
              console.error(t3), e3.enabled = false;
            }
          }
      }, this.enabled = e2;
    }
    async onAdded(e2) {
      await super.onAdded(e2), e2.addEventListener("preRender", this._preRender);
    }
    addCamera(e2) {
      if (!this._viewer)
        throw "Plugin not added to viewer";
      const t2 = { camera: e2, target: this._viewer.renderer.composerTarget.clone(true), enabled: true };
      return this.cameras.push(t2), t2;
    }
  };
  function gI(e2, t2, r2, i2, s2) {
    const o2 = e2.getAttribute(t2), a2 = i2.length / r2;
    return o2 && o2.count === a2 ? (o2.set(i2), o2.needsUpdate = true) : e2.setAttribute(t2, new (null != s2 ? s2 : n.a$l)(i2, r2)), o2;
  }
  function vI(e2, t2) {
    var n2, r2, i2;
    if (!e2.uiConfig)
      return;
    let s2 = null === (n2 = e2.uiConfig.children) || void 0 === n2 ? void 0 : n2.find((e3) => {
      var t3;
      return null === (t3 = e3.tags) || void 0 === t3 ? void 0 : t3.includes("generatedGeometry");
    });
    s2 || (s2 = { type: "folder", label: "Generation Params", tags: ["generatedGeometry"], children: [] }, null === (r2 = e2.uiConfig.children) || void 0 === r2 || r2.push(s2)), e2.userData.__generationParamsUiType !== e2.userData.generationParams.type && (s2.children = t2(), e2.userData.__generationParamsUiType = e2.userData.generationParams.type, null === (i2 = s2.uiRefresh) || void 0 === i2 || i2.call(s2, "postFrame", true));
  }
  _I.PluginType = "VirtualCamerasPlugin", mI([Oe()], _I.prototype, "enabled", void 0), _I = mI([We("Virtual Cameras")], _I);
  class yI {
    constructor(e2) {
      this.type = e2;
    }
    createUiConfig(e2) {
      const n2 = He(e2.userData.generationParams).filter((e3) => {
        var n3;
        return "type" !== (null === (n3 = (0, t.getOrCall)(e3.property)) || void 0 === n3 ? void 0 : n3[1]);
      });
      return n2.forEach((t2) => {
        t2.onChange = () => this.generate(e2);
      }), n2;
    }
    generate(e2, t2 = {}) {
      const r2 = null != e2 ? e2 : new n.u9r();
      if (r2.userData.generationParams || (r2.userData.generationParams = { type: this.type }), r2.userData.generationParams.type = this.type, t2.type)
        return console.error("Cannot set type parameter here, use the plugin instead"), r2;
      const i2 = { ...this.defaultParams, ...r2.userData.generationParams, ...t2 }, { indices: s2, vertices: o2, normals: a2, uvs: l2, groups: c2 } = this._generateData(i2);
      if (function(e3, t3) {
        const n2 = e3.index;
        n2 && n2.count === t3.length ? (n2.set(t3), n2.needsUpdate = true) : e3.setIndex(t3);
      }(r2, s2), gI(r2, "position", 3, o2), gI(r2, "normal", 3, a2), gI(r2, "uv", 2, l2), c2) {
        r2.clearGroups();
        for (const e3 of c2)
          r2.addGroup(e3.start, e3.count, e3.materialIndex);
      }
      return r2.computeBoundingBox(), r2.computeBoundingSphere(), Object.assign(r2.userData.generationParams, i2), vI(r2, () => this.createUiConfig(r2)), r2.dispatchEvent({ type: "geometryUpdate" }), r2;
    }
  }
  class bI extends yI {
    constructor() {
      super(...arguments), this.defaultParams = { radius: 1, widthSegments: 32, heightSegments: 16, phiStart: 0, phiLength: 2 * Math.PI, thetaStart: 0, thetaLength: Math.PI };
    }
    _generateData(e2) {
      const { radius: t2, phiStart: r2, phiLength: i2, thetaStart: s2, thetaLength: o2 } = e2;
      let { widthSegments: a2, heightSegments: l2 } = e2;
      a2 = Math.max(3, Math.floor(a2)), l2 = Math.max(2, Math.floor(l2));
      const c2 = Math.min(s2 + o2, Math.PI);
      let u2 = 0;
      const p2 = [], d2 = new n.Pa4(), h2 = new n.Pa4(), f2 = [], m2 = [], _2 = [], g2 = [];
      for (let e3 = 0; e3 <= l2; e3++) {
        const n2 = [], f3 = e3 / l2;
        let v2 = 0;
        0 === e3 && 0 === s2 ? v2 = 0.5 / a2 : e3 === l2 && c2 === Math.PI && (v2 = -0.5 / a2);
        for (let e4 = 0; e4 <= a2; e4++) {
          const l3 = e4 / a2;
          d2.x = -t2 * Math.cos(r2 + l3 * i2) * Math.sin(s2 + f3 * o2), d2.y = t2 * Math.cos(s2 + f3 * o2), d2.z = t2 * Math.sin(r2 + l3 * i2) * Math.sin(s2 + f3 * o2), m2.push(d2.x, d2.y, d2.z), h2.copy(d2).normalize(), _2.push(h2.x, h2.y, h2.z), g2.push(l3 + v2, 1 - f3), n2.push(u2++);
        }
        p2.push(n2);
      }
      for (let e3 = 0; e3 < l2; e3++)
        for (let t3 = 0; t3 < a2; t3++) {
          const n2 = p2[e3][t3 + 1], r3 = p2[e3][t3], i3 = p2[e3 + 1][t3], o3 = p2[e3 + 1][t3 + 1];
          (0 !== e3 || s2 > 0) && f2.push(n2, r3, o3), (e3 !== l2 - 1 || c2 < Math.PI) && f2.push(r3, i3, o3);
        }
      return { indices: f2, vertices: m2, normals: _2, uvs: g2 };
    }
  }
  class wI extends yI {
    constructor() {
      super(...arguments), this.defaultParams = { width: 1, height: 1, widthSegments: 2, heightSegments: 2 };
    }
    _generateData(e2) {
      const t2 = e2.width / 2, n2 = e2.height / 2, r2 = Math.floor(e2.widthSegments), i2 = Math.floor(e2.heightSegments), s2 = r2 + 1, o2 = i2 + 1, a2 = e2.width / r2, l2 = e2.height / i2, c2 = [], u2 = [], p2 = [], d2 = [];
      for (let e3 = 0; e3 < o2; e3++) {
        const o3 = e3 * l2 - n2;
        for (let n3 = 0; n3 < s2; n3++) {
          const s3 = n3 * a2 - t2;
          u2.push(s3, -o3, 0), p2.push(0, 0, 1), d2.push(n3 / r2), d2.push(1 - e3 / i2);
        }
      }
      for (let e3 = 0; e3 < i2; e3++)
        for (let t3 = 0; t3 < r2; t3++) {
          const n3 = t3 + s2 * e3, r3 = t3 + s2 * (e3 + 1), i3 = t3 + 1 + s2 * (e3 + 1), o3 = t3 + 1 + s2 * e3;
          c2.push(n3, r3, o3), c2.push(r3, i3, o3);
        }
      return { indices: c2, vertices: u2, normals: p2, uvs: d2 };
    }
  }
  class AI extends yI {
    constructor() {
      super(...arguments), this.defaultParams = { radius: 1, segments: 32, thetaStart: 0, thetaLength: 2 * Math.PI };
    }
    _generateData(e2) {
      const { radius: t2, thetaStart: r2, thetaLength: i2 } = e2, s2 = Math.max(3, e2.segments), o2 = [], a2 = [], l2 = [], c2 = [], u2 = new n.Pa4(), p2 = new n.FM8();
      a2.push(0, 0, 0), l2.push(0, 0, 1), c2.push(0.5, 0.5);
      for (let e3 = 0, n2 = 3; e3 <= s2; e3++, n2 += 3) {
        const o3 = r2 + e3 / s2 * i2;
        u2.x = t2 * Math.cos(o3), u2.y = t2 * Math.sin(o3), a2.push(u2.x, u2.y, u2.z), l2.push(0, 0, 1), p2.x = (a2[n2] / t2 + 1) / 2, p2.y = (a2[n2 + 1] / t2 + 1) / 2, c2.push(p2.x, p2.y);
      }
      for (let e3 = 1; e3 <= s2; e3++)
        o2.push(e3, e3 + 1, 0);
      return { indices: o2, vertices: a2, normals: l2, uvs: c2 };
    }
  }
  class xI extends yI {
    constructor() {
      super(...arguments), this.defaultParams = { radius: 1, tube: 0.4, radialSegments: 12, tubularSegments: 48, arc: 2 * Math.PI };
    }
    _generateData(e2) {
      const { radius: t2, tube: r2, arc: i2 } = e2;
      let { radialSegments: s2, tubularSegments: o2 } = e2;
      s2 = Math.floor(s2), o2 = Math.floor(o2);
      const a2 = [], l2 = [], c2 = [], u2 = [], p2 = new n.Pa4(), d2 = new n.Pa4(), h2 = new n.Pa4();
      for (let e3 = 0; e3 <= s2; e3++)
        for (let n2 = 0; n2 <= o2; n2++) {
          const a3 = n2 / o2 * i2, f2 = e3 / s2 * Math.PI * 2;
          d2.x = (t2 + r2 * Math.cos(f2)) * Math.cos(a3), d2.y = (t2 + r2 * Math.cos(f2)) * Math.sin(a3), d2.z = r2 * Math.sin(f2), l2.push(d2.x, d2.y, d2.z), p2.x = t2 * Math.cos(a3), p2.y = t2 * Math.sin(a3), h2.subVectors(d2, p2).normalize(), c2.push(h2.x, h2.y, h2.z), u2.push(n2 / o2), u2.push(e3 / s2);
        }
      for (let e3 = 1; e3 <= s2; e3++)
        for (let t3 = 1; t3 <= o2; t3++) {
          const n2 = (o2 + 1) * e3 + t3 - 1, r3 = (o2 + 1) * (e3 - 1) + t3 - 1, i3 = (o2 + 1) * (e3 - 1) + t3, s3 = (o2 + 1) * e3 + t3;
          a2.push(n2, r3, s3), a2.push(r3, i3, s3);
        }
      return { indices: a2, vertices: l2, normals: c2, uvs: u2 };
    }
  }
  class EI extends yI {
    constructor() {
      super(...arguments), this.defaultParams = { radiusTop: 1, radiusBottom: 1, height: 1, radialSegments: 32, heightSegments: 1, openEnded: false, thetaStart: 0, thetaLength: 2 * Math.PI };
    }
    _generateTorso(e2) {
      const { radiusTop: t2, radiusBottom: r2, height: i2, radialSegments: s2, heightSegments: o2, thetaStart: a2, thetaLength: l2, indexArray: c2, indices: u2, groups: p2, vertices: d2, normals: h2, uvs: f2, groupStart: m2, halfHeight: _2 } = e2, g2 = new n.Pa4(), v2 = new n.Pa4();
      let y2 = 0;
      const b2 = (r2 - t2) / i2;
      for (let n2 = 0; n2 <= o2; n2++) {
        const u3 = [], p3 = n2 / o2, m3 = p3 * (r2 - t2) + t2;
        for (let t3 = 0; t3 <= s2; t3++) {
          const n3 = t3 / s2, r3 = n3 * l2 + a2, o3 = Math.sin(r3), c3 = Math.cos(r3);
          v2.x = m3 * o3, v2.y = -p3 * i2 + _2, v2.z = m3 * c3, d2.push(v2.x, v2.y, v2.z), g2.set(o3, b2, c3).normalize(), h2.push(g2.x, g2.y, g2.z), f2.push(n3, 1 - p3), u3.push(e2.index++);
        }
        c2.push(u3);
      }
      for (let e3 = 0; e3 < s2; e3++)
        for (let t3 = 0; t3 < o2; t3++) {
          const n2 = c2[t3][e3], r3 = c2[t3 + 1][e3], i3 = c2[t3 + 1][e3 + 1], s3 = c2[t3][e3 + 1];
          u2.push(n2, r3, s3), u2.push(r3, i3, s3), y2 += 6;
        }
      p2.push({ start: m2, count: y2, materialIndex: 0 }), e2.groupStart += y2;
    }
    _generateCap(e2, t2) {
      const { radiusTop: r2, radiusBottom: i2, radialSegments: s2, thetaStart: o2, thetaLength: a2, indices: l2, groups: c2, vertices: u2, normals: p2, uvs: d2, groupStart: h2, halfHeight: f2 } = e2, m2 = e2.index, _2 = new n.FM8(), g2 = new n.Pa4();
      let v2 = 0;
      const y2 = true === t2 ? r2 : i2, b2 = true === t2 ? 1 : -1;
      for (let t3 = 1; t3 <= s2; t3++)
        u2.push(0, f2 * b2, 0), p2.push(0, b2, 0), d2.push(0.5, 0.5), e2.index++;
      const w2 = e2.index;
      for (let t3 = 0; t3 <= s2; t3++) {
        const n2 = t3 / s2 * a2 + o2, r3 = Math.cos(n2), i3 = Math.sin(n2);
        g2.x = y2 * i3, g2.y = f2 * b2, g2.z = y2 * r3, u2.push(g2.x, g2.y, g2.z), p2.push(0, b2, 0), _2.x = 0.5 * r3 + 0.5, _2.y = 0.5 * i3 * b2 + 0.5, d2.push(_2.x, _2.y), e2.index++;
      }
      for (let e3 = 0; e3 < s2; e3++) {
        const n2 = m2 + e3, r3 = w2 + e3;
        true === t2 ? l2.push(r3, r3 + 1, n2) : l2.push(r3 + 1, r3, n2), v2 += 3;
      }
      c2.push({ start: h2, count: v2, materialIndex: true === t2 ? 1 : 2 }), e2.groupStart += v2;
    }
    _generateData(e2) {
      let { radialSegments: t2, heightSegments: n2 } = e2;
      t2 = Math.floor(t2), n2 = Math.floor(n2);
      const r2 = { indices: [], vertices: [], normals: [], uvs: [], numberOfVertices: 0, groupStart: 0, groups: [], index: 0, indexArray: [], halfHeight: e2.height / 2, ...e2, radialSegments: t2, heightSegments: n2 };
      return this._generateTorso(r2), false === e2.openEnded && (e2.radiusTop > 0 && this._generateCap(r2, true), e2.radiusBottom > 0 && this._generateCap(r2, false)), r2;
    }
  }
  class CI extends yI {
    constructor() {
      super(...arguments), this.defaultParams = { width: 1, height: 1, depth: 1, widthSegments: 1, heightSegments: 1, depthSegments: 1 };
    }
    _buildPlane(e2, t2, r2, i2, s2, o2, a2, l2, c2, u2, p2, d2) {
      const { indices: h2, vertices: f2, normals: m2, uvs: _2, numberOfVertices: g2, groupStart: v2, groups: y2 } = e2, b2 = a2 / u2, w2 = l2 / p2, A2 = a2 / 2, x2 = l2 / 2, E2 = c2 / 2, C2 = u2 + 1, S2 = p2 + 1;
      let M2 = 0, T2 = 0;
      const P2 = new n.Pa4();
      for (let e3 = 0; e3 < S2; e3++) {
        const n2 = e3 * w2 - x2;
        for (let a3 = 0; a3 < C2; a3++) {
          const l3 = a3 * b2 - A2;
          P2[t2] = l3 * s2, P2[r2] = n2 * o2, P2[i2] = E2, f2.push(P2.x, P2.y, P2.z), P2[t2] = 0, P2[r2] = 0, P2[i2] = c2 > 0 ? 1 : -1, m2.push(P2.x, P2.y, P2.z), _2.push(a3 / u2), _2.push(1 - e3 / p2), M2 += 1;
        }
      }
      for (let e3 = 0; e3 < p2; e3++)
        for (let t3 = 0; t3 < u2; t3++) {
          const n2 = g2 + t3 + C2 * e3, r3 = g2 + t3 + C2 * (e3 + 1), i3 = g2 + (t3 + 1) + C2 * (e3 + 1), s3 = g2 + (t3 + 1) + C2 * e3;
          h2.push(n2, r3, s3), h2.push(r3, i3, s3), T2 += 6;
        }
      y2.push({ start: v2, count: T2, materialIndex: d2 }), e2.groupStart += T2, e2.numberOfVertices += M2;
    }
    _generateData(e2) {
      const { width: t2, height: n2, depth: r2 } = e2;
      let { widthSegments: i2, heightSegments: s2, depthSegments: o2 } = e2;
      i2 = Math.floor(i2), s2 = Math.floor(s2), o2 = Math.floor(o2);
      const a2 = { indices: [], vertices: [], normals: [], uvs: [], numberOfVertices: 0, groupStart: 0, groups: [] };
      return this._buildPlane(a2, "z", "y", "x", -1, -1, r2, n2, t2, o2, s2, 0), this._buildPlane(a2, "z", "y", "x", 1, -1, r2, n2, -t2, o2, s2, 1), this._buildPlane(a2, "x", "z", "y", 1, 1, t2, r2, n2, i2, o2, 2), this._buildPlane(a2, "x", "z", "y", 1, -1, t2, r2, -n2, i2, o2, 3), this._buildPlane(a2, "x", "y", "z", 1, -1, t2, n2, r2, i2, s2, 4), this._buildPlane(a2, "x", "y", "z", -1, -1, t2, n2, -r2, i2, s2, 5), a2;
    }
  }
  class SI extends gt {
    constructor() {
      super(...arguments), this.enabled = true, this.toJSON = void 0, this.generators = { plane: new wI("plane"), sphere: new bI("sphere"), box: new CI("box"), circle: new AI("circle"), torus: new xI("torus"), cylinder: new EI("cylinder") }, this._sceneUpdate = (e2) => {
        var t2;
        if (e2.hierarchyChanged) {
          const n2 = e2.object || (null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.scene.modelRoot);
          n2 && n2.traverse((e3) => {
            var t3, n3, r2;
            const i2 = null === (r2 = null === (n3 = null === (t3 = e3.geometry) || void 0 === t3 ? void 0 : t3.userData) || void 0 === n3 ? void 0 : n3.generationParams) || void 0 === r2 ? void 0 : r2.type;
            i2 && vI(e3.geometry, () => {
              var t4;
              const n4 = this.generators[i2];
              return (null == n4 ? void 0 : n4.createUiConfig) && null !== (t4 = n4.createUiConfig(e3.geometry)) && void 0 !== t4 ? t4 : [];
            });
          });
        }
      }, this.uiConfig = { type: "folder", label: "Generate Geometry", children: [() => Object.keys(this.generators).map((e2) => ({ type: "button", label: "Generate " + e2, value: async () => {
        (await this.generateObject(e2)).name = e2;
      } }))] };
    }
    async generateObject(e2) {
      var t2, r2;
      const i2 = this.generators[e2];
      if (!i2)
        throw new Error("Unknown generator type: " + e2);
      const s2 = await (null === (r2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getManager()) || void 0 === r2 ? void 0 : r2.addImportedSingle(new n.Kj0(new n.u9r(), new It({ color: 16711680 })), { autoScale: false, autoCenter: false }));
      return i2.generate(s2.modelObject.geometry), s2.name = e2, s2.geometry.name = "Generated " + e2, s2.modelObject;
    }
    async onAdded(e2) {
      await super.onAdded(e2), e2.scene.addEventListener("sceneUpdate", this._sceneUpdate);
    }
  }
  SI.PluginType = "GeometryGeneratorPlugin";
  var MI = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let TI = class extends gt {
    constructor() {
      super(...arguments), this.toJSON = null, this.enabled = true, this.dependencies = [ub], this._exporting = false;
    }
    async exportObject(e2) {
      var t2, n2;
      const r2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(ub);
      if (!r2)
        throw new Error("AssetExporterPlugin not found");
      return e2 ? null === (n2 = r2.exporter) || void 0 === n2 ? void 0 : n2.exportObject(e2, { format: "glb" }) : r2.exportScene(r2.exportOptions);
    }
    async getLink(e2) {
      var t2;
      const n2 = await this.exportObject(e2);
      if (!n2)
        throw new Error("Failed to export object or scene");
      const r2 = await fetch("https://bee.transfr.one/model.glb", { method: "PUT", body: n2 });
      if (200 !== r2.status)
        throw new Error("Failed to upload file");
      const i2 = null === (t2 = await r2.text()) || void 0 === t2 ? void 0 : t2.trim();
      console.log(i2);
      try {
        new URL(i2);
      } catch (e3) {
        throw new Error("Invalid URL " + i2);
      }
      return i2;
    }
    async shareLink(e2, t2 = "m") {
      var n2;
      if (this._exporting)
        return;
      this._exporting = true;
      let r2 = await this.getLink().catch((e3) => {
        var t3, n3;
        return null === (t3 = this._viewer) || void 0 === t3 || t3.console.error(e3), null === (n3 = this._viewer) || void 0 === n3 || n3.alert("Error: Failed to share scene: \n" + e3.message), null;
      });
      if (r2) {
        if (e2) {
          const n3 = "string" == typeof e2 ? new URL(e2) : e2;
          n3.searchParams.set(null != t2 ? t2 : "m", r2), r2 = n3.href;
        }
        let i2 = false;
        try {
          window && window.navigator && navigator.clipboard && (await navigator.clipboard.writeText(r2), i2 = true);
        } catch (e3) {
          console.error("Failed to copy link", e3);
        }
        null === (n2 = this._viewer) || void 0 === n2 || n2.alert("Link" + (i2 ? " Copied: " : ": " + r2) + "\n\nNote: File will be deleted in 7 days");
      }
      return this._exporting = false, r2;
    }
    async shareEditorLink() {
      const e2 = new URL(window.location.href);
      return this.shareLink(e2);
    }
    async shareViewerLink() {
      const e2 = new URL(window.location.href);
      return e2.pathname = e2.pathname.replace(/editor\.html$/, "viewer.html"), this.shareLink(e2);
    }
  };
  TI.PluginType = "TransfrSharePlugin", MI([je("Share editor link")], TI.prototype, "shareEditorLink", null), MI([je("Share viewer link")], TI.prototype, "shareViewerLink", null), TI = MI([We("Share Link (transfr.one)")], TI);
  var PI = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let II = class extends gt {
    constructor() {
      super(...arguments), this.enabled = true, this.toJSON = void 0, this.prefix = "", this.count = 50, this.loops = 1, this.color = new n.Ilk().setHSL(0, 0.8, 0.5);
    }
    colorItems() {
      if (!this._viewer)
        return;
      const e2 = this._viewer.scene.modelRoot;
      let t2 = 0;
      const r2 = this.color.getHSL({ h: 0, s: 0, l: 0 });
      e2.traverse((e3) => {
        const i2 = e3.material && e3.material.isDiamondMaterial, s2 = i2 && e3.name.startsWith(this.prefix);
        if (i2 && console.log("Found Diamond, name = ", e3.name, ", coloring = ", s2), s2) {
          let i3 = e3.name.replace(this.prefix, "");
          i3 = parseFloat(i3) / this.count;
          const s3 = new n.Ilk().setHSL((this.loops * i3 + r2.h) % 1, r2.s, r2.l);
          e3.material = e3.material.userData.isColoredClone ? e3.material : e3.material.clone(), e3.material.color.set(s3), e3.material.boostFactors.set(1, 1, 1), e3.material.userData.isColoredClone = true, t2++;
        }
      }), console.log("total", t2), this._viewer.setDirty();
    }
  };
  II.PluginType = "RainbowDiamondPlugin", PI([ze("Object name prefix")], II.prototype, "prefix", void 0), PI([ze("Count")], II.prototype, "count", void 0), PI([ze("Loops")], II.prototype, "loops", void 0), PI([Ge("First Color")], II.prototype, "color", void 0), PI([je("Color All Items")], II.prototype, "colorItems", null), II = PI([We("Rainbow Diamond Coloring")], II);
  class RI extends gt {
    constructor() {
      super(...arguments), this.enabled = true, this.toJSON = null, this.ringSlots = [], this.dependencies = [Ls, jC], this._animating = false, this._runningAnimations = [], this.uiConfig = { type: "folder", label: "Bering Animation", children: [{ label: "Play Animation", type: "button", value: () => {
        this.startRingAnimation(false);
      } }, { label: "Record Animation", type: "button", value: async () => {
        var e2;
        const n2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPluginByType("CanvasRecorder");
        if (!n2 || n2.isRecording())
          return;
        this.animating && this.stopRingAnimation(false), await (0, t.timeout)(500);
        const r2 = await n2.record(async () => {
          console.log("start"), await this.startRingAnimation(false), console.log("finish");
        });
        r2 && (console.log("recorded", r2), (0, t.downloadBlob)(r2, "animation.mp4"));
      } }] };
    }
    get animating() {
      return this._animating;
    }
    set animating(e2) {
      var t2, n2;
      if (this._animating === e2)
        return;
      this._animating = e2;
      const r2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(Po);
      r2 && (e2 ? r2.disable("bering") : r2.enable("bering"));
      const i2 = null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.getPlugin(yd);
      i2 && (i2.enabled = !e2);
    }
    async onAdded(e2) {
      await super.onAdded(e2), e2.scene.addEventListener("addSceneObject", (e3) => {
        var t2, n2, r2, i2, s2;
        if (!(null === (n2 = null === (t2 = e3.options) || void 0 === t2 ? void 0 : t2.allImported) || void 0 === n2 ? void 0 : n2.length) || !e3.object)
          return;
        if (!e3.object.__importedViewerConfig && !(null === (r2 = e3.object.modelObject) || void 0 === r2 ? void 0 : r2.__importedViewerConfig) || !(null === (i2 = e3.options) || void 0 === i2 ? void 0 : i2.allImported))
          return;
        let o2 = 0;
        const a2 = null === (s2 = e3.options) || void 0 === s2 ? void 0 : s2.allImported.filter((e4) => !!(e4 && e4.modelObject && e4.name.endsWith("bmod"))).reverse();
        a2.forEach((e4) => {
          this.loadRingBMod(e4, e4.name, o2, a2.length - 1), o2++;
        });
      });
    }
    loadRingBMod(e2, t2, n2, r2) {
      var i2, s2, o2;
      if (!t2)
        return;
      if (!(null === (i2 = this._viewer) || void 0 === i2 ? void 0 : i2.getPlugin(Ls)))
        throw new Error("no asset manager");
      this._runningAnimations && this.stopRingAnimation(), t2.endsWith(".bmod") || (t2 += ".bmod");
      const a2 = null == e2 ? void 0 : e2.modelObject;
      if (!a2 || !e2)
        throw new Error("no model");
      a2.userData.__ringSlot = n2, this.ringSlots[n2] = e2;
      const l2 = [];
      a2.traverse((e3) => {
        e3.userData.rotationCount > 1 && l2.push(e3);
      }), new h().expandByObjects(l2, true, true), t2.toLowerCase().includes("x3") || t2.toLowerCase().includes("x4");
      const c2 = parseInt(t2.split("-").pop().toLowerCase().replace("x", "").replace(".bmod", "")) + 1;
      return a2.userData.__ringWidth = c2, a2.userData.__ringTotalSlots = r2, null === (o2 = null === (s2 = this._viewer) || void 0 === s2 ? void 0 : s2.scene) || void 0 === o2 || o2.setDirty({ sceneUpdate: true, frameFade: false }), e2;
    }
    clearAllSlots() {
      this.ringSlots.forEach((e2) => {
        e2.modelObject.removeFromParent();
      }), this.ringSlots = [];
    }
    stopRingAnimation(e2 = true) {
      var t2, n2;
      if (0 !== this._runningAnimations.length) {
        for (const e3 of this._runningAnimations)
          e3.stop();
        this._runningAnimations = [], e2 && (null === (n2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(Po)) || void 0 === n2 || n2.startTransition(1200));
      }
    }
    async startRingAnimation(e2 = true) {
      if (this.animating || !this._viewer)
        return;
      this.stopRingAnimation(), this.animating = true;
      let t2 = 0;
      const r2 = [];
      await new Promise((i2) => {
        var s2, o2, a2;
        if (!this._viewer)
          return;
        const l2 = () => {
          t2 += 1, t2 < r2.length || i2();
        }, c2 = 2500, u2 = this._viewer.getPlugin(jC), p2 = this.ringSlots[0];
        if (p2) {
          const t3 = p2.modelObject, i3 = { left: [], right: [], rem: [] };
          t3.traverse((e3) => {
            const t4 = (null == e3 ? void 0 : e3.name.trim().toLowerCase().replace(/[0-9]/g, "")) || "";
            t4.endsWith("-s") ? i3.left.push(e3) : t4.endsWith("-l") ? i3.right.push(e3) : t4.startsWith("testlogo") && i3.rem.push(e3);
          });
          const d2 = [];
          for (const e3 of i3.left) {
            const t4 = (null === (s2 = e3.parent) || void 0 === s2 ? void 0 : s2.children) || [];
            d2.push(...t4);
          }
          for (const e3 of i3.right) {
            const t4 = (null === (o2 = e3.parent) || void 0 === o2 ? void 0 : o2.children) || [];
            d2.push(...t4);
          }
          for (const e3 of d2)
            i3.left.includes(e3) || i3.right.includes(e3) || i3.rem.includes(e3) || i3.rem.push(e3);
          for (const e3 of i3.rem)
            new h().expandByObject(e3, false, true).getCenter(new n.Pa4()).x <= 0 ? i3.left.push(e3) : i3.right.push(e3);
          for (const e3 of [...i3.left, ...i3.right])
            e3.userData.__initX = e3.position.x, e3.userData.__initRotX = e3.rotation.x;
          const f2 = null === (a2 = this._viewer) || void 0 === a2 ? void 0 : a2.getPluginByType("Ground");
          if (i3.left.length > 0 && i3.right.length > 0) {
            const t4 = (t5) => (n3) => {
              var r3, s3, o3;
              for (const e3 of i3[t5])
                e3.position.x = n3 + e3.userData.__initX;
              null === (s3 = null === (r3 = this._viewer) || void 0 === r3 ? void 0 : r3.scene) || void 0 === s3 || s3.setDirty({ sceneUpdate: false, frameFade: false }), e2 && (null === (o3 = null == f2 ? void 0 : f2.shadowBaker) || void 0 === o3 || o3.reset());
            }, n2 = (e3) => (t5) => {
              var n3, r3;
              for (const n4 of i3[e3])
                n4.rotation.x = t5 + n4.userData.__initRotX;
              null === (r3 = null === (n3 = this._viewer) || void 0 === n3 ? void 0 : n3.scene) || void 0 === r3 || r3.setDirty({ sceneUpdate: false, frameFade: false });
            };
            r2.push(u2.animate({ from: 0, to: -0.75, onUpdate: t4("left"), onStop: () => {
              t4("left")(0), l2();
            }, onComplete: l2, duration: c2, ease: Dp.easeInOut, repeat: 1, repeatDelay: 250, repeatType: "mirror" })), r2.push(u2.animate({ from: 0, to: 0.75, onUpdate: t4("right"), onStop: () => {
              t4("right")(0), l2();
            }, onComplete: l2, duration: c2, ease: Dp.easeInOut, repeat: 1, repeatDelay: 250, repeatType: "mirror" })), r2.push(u2.animate({ from: 0, to: 1.5 * -Math.PI, onUpdate: n2("left"), onStop: () => {
              n2("left")(0), l2();
            }, onComplete: l2, duration: 1250, ease: Dp.easeInOut, repeat: 1, repeatDelay: 2750, repeatType: "mirror" }));
          }
        }
        this.ringSlots.forEach((e3) => {
          if (p2 === e3)
            return;
          const t3 = e3.modelObject.userData.__ringSlot, n2 = e3.modelObject.userData.__ringTotalSlots, i3 = e3.modelObject.userData.__ringWidth, s3 = e3.modelObject.position.x;
          r2.push(u2.animate({ from: s3, to: s3 + 0.75 - 1.5 * (1 - (t3 + 1) / (n2 + 1 + (2 - i3))), onUpdate: (t4) => {
            var n3, r3;
            e3.modelObject.position.x = t4, null === (r3 = null === (n3 = this._viewer) || void 0 === n3 ? void 0 : n3.scene) || void 0 === r3 || r3.setDirty({ sceneUpdate: false, frameFade: false });
          }, onStop: () => {
            e3.modelObject.position.x = s3, l2();
          }, onComplete: l2, duration: c2, ease: Dp.easeInOut, repeat: 1, repeatDelay: 250, repeatType: "mirror" }));
        }), r2.length > 0 ? this._runningAnimations = r2 : (this.animating = false, i2());
      }), this.animating = false;
      for (const e3 of this._runningAnimations)
        e3.stop();
      this._runningAnimations = [], console.log("animation end");
    }
  }
  RI.PluginType = "BeringRingAnimation";
  class kI {
    constructor(e2) {
      void 0 === e2 && (e2 = [0, 0, 0, 0, 0, 0, 0, 0, 0]), this.elements = e2;
    }
    identity() {
      const e2 = this.elements;
      e2[0] = 1, e2[1] = 0, e2[2] = 0, e2[3] = 0, e2[4] = 1, e2[5] = 0, e2[6] = 0, e2[7] = 0, e2[8] = 1;
    }
    setZero() {
      const e2 = this.elements;
      e2[0] = 0, e2[1] = 0, e2[2] = 0, e2[3] = 0, e2[4] = 0, e2[5] = 0, e2[6] = 0, e2[7] = 0, e2[8] = 0;
    }
    setTrace(e2) {
      const t2 = this.elements;
      t2[0] = e2.x, t2[4] = e2.y, t2[8] = e2.z;
    }
    getTrace(e2) {
      void 0 === e2 && (e2 = new BI());
      const t2 = this.elements;
      return e2.x = t2[0], e2.y = t2[4], e2.z = t2[8], e2;
    }
    vmult(e2, t2) {
      void 0 === t2 && (t2 = new BI());
      const n2 = this.elements, r2 = e2.x, i2 = e2.y, s2 = e2.z;
      return t2.x = n2[0] * r2 + n2[1] * i2 + n2[2] * s2, t2.y = n2[3] * r2 + n2[4] * i2 + n2[5] * s2, t2.z = n2[6] * r2 + n2[7] * i2 + n2[8] * s2, t2;
    }
    smult(e2) {
      for (let t2 = 0; t2 < this.elements.length; t2++)
        this.elements[t2] *= e2;
    }
    mmult(e2, t2) {
      void 0 === t2 && (t2 = new kI());
      const n2 = this.elements, r2 = e2.elements, i2 = t2.elements, s2 = n2[0], o2 = n2[1], a2 = n2[2], l2 = n2[3], c2 = n2[4], u2 = n2[5], p2 = n2[6], d2 = n2[7], h2 = n2[8], f2 = r2[0], m2 = r2[1], _2 = r2[2], g2 = r2[3], v2 = r2[4], y2 = r2[5], b2 = r2[6], w2 = r2[7], A2 = r2[8];
      return i2[0] = s2 * f2 + o2 * g2 + a2 * b2, i2[1] = s2 * m2 + o2 * v2 + a2 * w2, i2[2] = s2 * _2 + o2 * y2 + a2 * A2, i2[3] = l2 * f2 + c2 * g2 + u2 * b2, i2[4] = l2 * m2 + c2 * v2 + u2 * w2, i2[5] = l2 * _2 + c2 * y2 + u2 * A2, i2[6] = p2 * f2 + d2 * g2 + h2 * b2, i2[7] = p2 * m2 + d2 * v2 + h2 * w2, i2[8] = p2 * _2 + d2 * y2 + h2 * A2, t2;
    }
    scale(e2, t2) {
      void 0 === t2 && (t2 = new kI());
      const n2 = this.elements, r2 = t2.elements;
      for (let t3 = 0; 3 !== t3; t3++)
        r2[3 * t3 + 0] = e2.x * n2[3 * t3 + 0], r2[3 * t3 + 1] = e2.y * n2[3 * t3 + 1], r2[3 * t3 + 2] = e2.z * n2[3 * t3 + 2];
      return t2;
    }
    solve(e2, t2) {
      void 0 === t2 && (t2 = new BI());
      const n2 = [];
      let r2, i2;
      for (r2 = 0; r2 < 12; r2++)
        n2.push(0);
      for (r2 = 0; r2 < 3; r2++)
        for (i2 = 0; i2 < 3; i2++)
          n2[r2 + 4 * i2] = this.elements[r2 + 3 * i2];
      n2[3] = e2.x, n2[7] = e2.y, n2[11] = e2.z;
      let s2 = 3;
      const o2 = s2;
      let a2, l2;
      do {
        if (r2 = o2 - s2, 0 === n2[r2 + 4 * r2]) {
          for (i2 = r2 + 1; i2 < o2; i2++)
            if (0 !== n2[r2 + 4 * i2]) {
              a2 = 4;
              do {
                l2 = 4 - a2, n2[l2 + 4 * r2] += n2[l2 + 4 * i2];
              } while (--a2);
              break;
            }
        }
        if (0 !== n2[r2 + 4 * r2])
          for (i2 = r2 + 1; i2 < o2; i2++) {
            const e3 = n2[r2 + 4 * i2] / n2[r2 + 4 * r2];
            a2 = 4;
            do {
              l2 = 4 - a2, n2[l2 + 4 * i2] = l2 <= r2 ? 0 : n2[l2 + 4 * i2] - n2[l2 + 4 * r2] * e3;
            } while (--a2);
          }
      } while (--s2);
      if (t2.z = n2[11] / n2[10], t2.y = (n2[7] - n2[6] * t2.z) / n2[5], t2.x = (n2[3] - n2[2] * t2.z - n2[1] * t2.y) / n2[0], isNaN(t2.x) || isNaN(t2.y) || isNaN(t2.z) || t2.x === 1 / 0 || t2.y === 1 / 0 || t2.z === 1 / 0)
        throw `Could not solve equation! Got x=[${t2.toString()}], b=[${e2.toString()}], A=[${this.toString()}]`;
      return t2;
    }
    e(e2, t2, n2) {
      if (void 0 === n2)
        return this.elements[t2 + 3 * e2];
      this.elements[t2 + 3 * e2] = n2;
    }
    copy(e2) {
      for (let t2 = 0; t2 < e2.elements.length; t2++)
        this.elements[t2] = e2.elements[t2];
      return this;
    }
    toString() {
      let e2 = "";
      for (let t2 = 0; t2 < 9; t2++)
        e2 += this.elements[t2] + ",";
      return e2;
    }
    reverse(e2) {
      void 0 === e2 && (e2 = new kI());
      const t2 = DI;
      let n2, r2;
      for (n2 = 0; n2 < 3; n2++)
        for (r2 = 0; r2 < 3; r2++)
          t2[n2 + 6 * r2] = this.elements[n2 + 3 * r2];
      t2[3] = 1, t2[9] = 0, t2[15] = 0, t2[4] = 0, t2[10] = 1, t2[16] = 0, t2[5] = 0, t2[11] = 0, t2[17] = 1;
      let i2 = 3;
      const s2 = i2;
      let o2, a2;
      do {
        if (n2 = s2 - i2, 0 === t2[n2 + 6 * n2]) {
          for (r2 = n2 + 1; r2 < s2; r2++)
            if (0 !== t2[n2 + 6 * r2]) {
              o2 = 6;
              do {
                a2 = 6 - o2, t2[a2 + 6 * n2] += t2[a2 + 6 * r2];
              } while (--o2);
              break;
            }
        }
        if (0 !== t2[n2 + 6 * n2])
          for (r2 = n2 + 1; r2 < s2; r2++) {
            const e3 = t2[n2 + 6 * r2] / t2[n2 + 6 * n2];
            o2 = 6;
            do {
              a2 = 6 - o2, t2[a2 + 6 * r2] = a2 <= n2 ? 0 : t2[a2 + 6 * r2] - t2[a2 + 6 * n2] * e3;
            } while (--o2);
          }
      } while (--i2);
      n2 = 2;
      do {
        r2 = n2 - 1;
        do {
          const e3 = t2[n2 + 6 * r2] / t2[n2 + 6 * n2];
          o2 = 6;
          do {
            a2 = 6 - o2, t2[a2 + 6 * r2] = t2[a2 + 6 * r2] - t2[a2 + 6 * n2] * e3;
          } while (--o2);
        } while (r2--);
      } while (--n2);
      n2 = 2;
      do {
        const e3 = 1 / t2[n2 + 6 * n2];
        o2 = 6;
        do {
          a2 = 6 - o2, t2[a2 + 6 * n2] = t2[a2 + 6 * n2] * e3;
        } while (--o2);
      } while (n2--);
      n2 = 2;
      do {
        r2 = 2;
        do {
          if (a2 = t2[3 + r2 + 6 * n2], isNaN(a2) || a2 === 1 / 0)
            throw `Could not reverse! A=[${this.toString()}]`;
          e2.e(n2, r2, a2);
        } while (r2--);
      } while (n2--);
      return e2;
    }
    setRotationFromQuaternion(e2) {
      const t2 = e2.x, n2 = e2.y, r2 = e2.z, i2 = e2.w, s2 = t2 + t2, o2 = n2 + n2, a2 = r2 + r2, l2 = t2 * s2, c2 = t2 * o2, u2 = t2 * a2, p2 = n2 * o2, d2 = n2 * a2, h2 = r2 * a2, f2 = i2 * s2, m2 = i2 * o2, _2 = i2 * a2, g2 = this.elements;
      return g2[0] = 1 - (p2 + h2), g2[1] = c2 - _2, g2[2] = u2 + m2, g2[3] = c2 + _2, g2[4] = 1 - (l2 + h2), g2[5] = d2 - f2, g2[6] = u2 - m2, g2[7] = d2 + f2, g2[8] = 1 - (l2 + p2), this;
    }
    transpose(e2) {
      void 0 === e2 && (e2 = new kI());
      const t2 = this.elements, n2 = e2.elements;
      let r2;
      return n2[0] = t2[0], n2[4] = t2[4], n2[8] = t2[8], r2 = t2[1], n2[1] = t2[3], n2[3] = r2, r2 = t2[2], n2[2] = t2[6], n2[6] = r2, r2 = t2[5], n2[5] = t2[7], n2[7] = r2, e2;
    }
  }
  const DI = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  class BI {
    constructor(e2, t2, n2) {
      void 0 === e2 && (e2 = 0), void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = 0), this.x = e2, this.y = t2, this.z = n2;
    }
    cross(e2, t2) {
      void 0 === t2 && (t2 = new BI());
      const n2 = e2.x, r2 = e2.y, i2 = e2.z, s2 = this.x, o2 = this.y, a2 = this.z;
      return t2.x = o2 * i2 - a2 * r2, t2.y = a2 * n2 - s2 * i2, t2.z = s2 * r2 - o2 * n2, t2;
    }
    set(e2, t2, n2) {
      return this.x = e2, this.y = t2, this.z = n2, this;
    }
    setZero() {
      this.x = this.y = this.z = 0;
    }
    vadd(e2, t2) {
      if (!t2)
        return new BI(this.x + e2.x, this.y + e2.y, this.z + e2.z);
      t2.x = e2.x + this.x, t2.y = e2.y + this.y, t2.z = e2.z + this.z;
    }
    vsub(e2, t2) {
      if (!t2)
        return new BI(this.x - e2.x, this.y - e2.y, this.z - e2.z);
      t2.x = this.x - e2.x, t2.y = this.y - e2.y, t2.z = this.z - e2.z;
    }
    crossmat() {
      return new kI([0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0]);
    }
    normalize() {
      const e2 = this.x, t2 = this.y, n2 = this.z, r2 = Math.sqrt(e2 * e2 + t2 * t2 + n2 * n2);
      if (r2 > 0) {
        const e3 = 1 / r2;
        this.x *= e3, this.y *= e3, this.z *= e3;
      } else
        this.x = 0, this.y = 0, this.z = 0;
      return r2;
    }
    unit(e2) {
      void 0 === e2 && (e2 = new BI());
      const t2 = this.x, n2 = this.y, r2 = this.z;
      let i2 = Math.sqrt(t2 * t2 + n2 * n2 + r2 * r2);
      return i2 > 0 ? (i2 = 1 / i2, e2.x = t2 * i2, e2.y = n2 * i2, e2.z = r2 * i2) : (e2.x = 1, e2.y = 0, e2.z = 0), e2;
    }
    length() {
      const e2 = this.x, t2 = this.y, n2 = this.z;
      return Math.sqrt(e2 * e2 + t2 * t2 + n2 * n2);
    }
    lengthSquared() {
      return this.dot(this);
    }
    distanceTo(e2) {
      const t2 = this.x, n2 = this.y, r2 = this.z, i2 = e2.x, s2 = e2.y, o2 = e2.z;
      return Math.sqrt((i2 - t2) * (i2 - t2) + (s2 - n2) * (s2 - n2) + (o2 - r2) * (o2 - r2));
    }
    distanceSquared(e2) {
      const t2 = this.x, n2 = this.y, r2 = this.z, i2 = e2.x, s2 = e2.y, o2 = e2.z;
      return (i2 - t2) * (i2 - t2) + (s2 - n2) * (s2 - n2) + (o2 - r2) * (o2 - r2);
    }
    scale(e2, t2) {
      void 0 === t2 && (t2 = new BI());
      const n2 = this.x, r2 = this.y, i2 = this.z;
      return t2.x = e2 * n2, t2.y = e2 * r2, t2.z = e2 * i2, t2;
    }
    vmul(e2, t2) {
      return void 0 === t2 && (t2 = new BI()), t2.x = e2.x * this.x, t2.y = e2.y * this.y, t2.z = e2.z * this.z, t2;
    }
    addScaledVector(e2, t2, n2) {
      return void 0 === n2 && (n2 = new BI()), n2.x = this.x + e2 * t2.x, n2.y = this.y + e2 * t2.y, n2.z = this.z + e2 * t2.z, n2;
    }
    dot(e2) {
      return this.x * e2.x + this.y * e2.y + this.z * e2.z;
    }
    isZero() {
      return 0 === this.x && 0 === this.y && 0 === this.z;
    }
    negate(e2) {
      return void 0 === e2 && (e2 = new BI()), e2.x = -this.x, e2.y = -this.y, e2.z = -this.z, e2;
    }
    tangents(e2, t2) {
      const n2 = this.length();
      if (n2 > 0) {
        const r2 = OI, i2 = 1 / n2;
        r2.set(this.x * i2, this.y * i2, this.z * i2);
        const s2 = LI;
        Math.abs(r2.x) < 0.9 ? (s2.set(1, 0, 0), r2.cross(s2, e2)) : (s2.set(0, 1, 0), r2.cross(s2, e2)), r2.cross(e2, t2);
      } else
        e2.set(1, 0, 0), t2.set(0, 1, 0);
    }
    toString() {
      return `${this.x},${this.y},${this.z}`;
    }
    toArray() {
      return [this.x, this.y, this.z];
    }
    copy(e2) {
      return this.x = e2.x, this.y = e2.y, this.z = e2.z, this;
    }
    lerp(e2, t2, n2) {
      const r2 = this.x, i2 = this.y, s2 = this.z;
      n2.x = r2 + (e2.x - r2) * t2, n2.y = i2 + (e2.y - i2) * t2, n2.z = s2 + (e2.z - s2) * t2;
    }
    almostEquals(e2, t2) {
      return void 0 === t2 && (t2 = 1e-6), !(Math.abs(this.x - e2.x) > t2 || Math.abs(this.y - e2.y) > t2 || Math.abs(this.z - e2.z) > t2);
    }
    almostZero(e2) {
      return void 0 === e2 && (e2 = 1e-6), !(Math.abs(this.x) > e2 || Math.abs(this.y) > e2 || Math.abs(this.z) > e2);
    }
    isAntiparallelTo(e2, t2) {
      return this.negate(UI), UI.almostEquals(e2, t2);
    }
    clone() {
      return new BI(this.x, this.y, this.z);
    }
  }
  BI.ZERO = new BI(0, 0, 0), BI.UNIT_X = new BI(1, 0, 0), BI.UNIT_Y = new BI(0, 1, 0), BI.UNIT_Z = new BI(0, 0, 1);
  const OI = new BI(), LI = new BI(), UI = new BI();
  class FI {
    constructor(e2) {
      void 0 === e2 && (e2 = {}), this.lowerBound = new BI(), this.upperBound = new BI(), e2.lowerBound && this.lowerBound.copy(e2.lowerBound), e2.upperBound && this.upperBound.copy(e2.upperBound);
    }
    setFromPoints(e2, t2, n2, r2) {
      const i2 = this.lowerBound, s2 = this.upperBound, o2 = n2;
      i2.copy(e2[0]), o2 && o2.vmult(i2, i2), s2.copy(i2);
      for (let t3 = 1; t3 < e2.length; t3++) {
        let n3 = e2[t3];
        o2 && (o2.vmult(n3, NI), n3 = NI), n3.x > s2.x && (s2.x = n3.x), n3.x < i2.x && (i2.x = n3.x), n3.y > s2.y && (s2.y = n3.y), n3.y < i2.y && (i2.y = n3.y), n3.z > s2.z && (s2.z = n3.z), n3.z < i2.z && (i2.z = n3.z);
      }
      return t2 && (t2.vadd(i2, i2), t2.vadd(s2, s2)), r2 && (i2.x -= r2, i2.y -= r2, i2.z -= r2, s2.x += r2, s2.y += r2, s2.z += r2), this;
    }
    copy(e2) {
      return this.lowerBound.copy(e2.lowerBound), this.upperBound.copy(e2.upperBound), this;
    }
    clone() {
      return new FI().copy(this);
    }
    extend(e2) {
      this.lowerBound.x = Math.min(this.lowerBound.x, e2.lowerBound.x), this.upperBound.x = Math.max(this.upperBound.x, e2.upperBound.x), this.lowerBound.y = Math.min(this.lowerBound.y, e2.lowerBound.y), this.upperBound.y = Math.max(this.upperBound.y, e2.upperBound.y), this.lowerBound.z = Math.min(this.lowerBound.z, e2.lowerBound.z), this.upperBound.z = Math.max(this.upperBound.z, e2.upperBound.z);
    }
    overlaps(e2) {
      const t2 = this.lowerBound, n2 = this.upperBound, r2 = e2.lowerBound, i2 = e2.upperBound, s2 = r2.x <= n2.x && n2.x <= i2.x || t2.x <= i2.x && i2.x <= n2.x, o2 = r2.y <= n2.y && n2.y <= i2.y || t2.y <= i2.y && i2.y <= n2.y, a2 = r2.z <= n2.z && n2.z <= i2.z || t2.z <= i2.z && i2.z <= n2.z;
      return s2 && o2 && a2;
    }
    volume() {
      const e2 = this.lowerBound, t2 = this.upperBound;
      return (t2.x - e2.x) * (t2.y - e2.y) * (t2.z - e2.z);
    }
    contains(e2) {
      const t2 = this.lowerBound, n2 = this.upperBound, r2 = e2.lowerBound, i2 = e2.upperBound;
      return t2.x <= r2.x && n2.x >= i2.x && t2.y <= r2.y && n2.y >= i2.y && t2.z <= r2.z && n2.z >= i2.z;
    }
    getCorners(e2, t2, n2, r2, i2, s2, o2, a2) {
      const l2 = this.lowerBound, c2 = this.upperBound;
      e2.copy(l2), t2.set(c2.x, l2.y, l2.z), n2.set(c2.x, c2.y, l2.z), r2.set(l2.x, c2.y, c2.z), i2.set(c2.x, l2.y, c2.z), s2.set(l2.x, c2.y, l2.z), o2.set(l2.x, l2.y, c2.z), a2.copy(c2);
    }
    toLocalFrame(e2, t2) {
      const n2 = jI, r2 = n2[0], i2 = n2[1], s2 = n2[2], o2 = n2[3], a2 = n2[4], l2 = n2[5], c2 = n2[6], u2 = n2[7];
      this.getCorners(r2, i2, s2, o2, a2, l2, c2, u2);
      for (let t3 = 0; 8 !== t3; t3++) {
        const r3 = n2[t3];
        e2.pointToLocal(r3, r3);
      }
      return t2.setFromPoints(n2);
    }
    toWorldFrame(e2, t2) {
      const n2 = jI, r2 = n2[0], i2 = n2[1], s2 = n2[2], o2 = n2[3], a2 = n2[4], l2 = n2[5], c2 = n2[6], u2 = n2[7];
      this.getCorners(r2, i2, s2, o2, a2, l2, c2, u2);
      for (let t3 = 0; 8 !== t3; t3++) {
        const r3 = n2[t3];
        e2.pointToWorld(r3, r3);
      }
      return t2.setFromPoints(n2);
    }
    overlapsRay(e2) {
      const { direction: t2, from: n2 } = e2, r2 = 1 / t2.x, i2 = 1 / t2.y, s2 = 1 / t2.z, o2 = (this.lowerBound.x - n2.x) * r2, a2 = (this.upperBound.x - n2.x) * r2, l2 = (this.lowerBound.y - n2.y) * i2, c2 = (this.upperBound.y - n2.y) * i2, u2 = (this.lowerBound.z - n2.z) * s2, p2 = (this.upperBound.z - n2.z) * s2, d2 = Math.max(Math.max(Math.min(o2, a2), Math.min(l2, c2)), Math.min(u2, p2)), h2 = Math.min(Math.min(Math.max(o2, a2), Math.max(l2, c2)), Math.max(u2, p2));
      return !(h2 < 0 || d2 > h2);
    }
  }
  const NI = new BI(), jI = [new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new BI()];
  class zI {
    constructor() {
      this.matrix = [];
    }
    get(e2, t2) {
      let { index: n2 } = e2, { index: r2 } = t2;
      if (r2 > n2) {
        const e3 = r2;
        r2 = n2, n2 = e3;
      }
      return this.matrix[(n2 * (n2 + 1) >> 1) + r2 - 1];
    }
    set(e2, t2, n2) {
      let { index: r2 } = e2, { index: i2 } = t2;
      if (i2 > r2) {
        const e3 = i2;
        i2 = r2, r2 = e3;
      }
      this.matrix[(r2 * (r2 + 1) >> 1) + i2 - 1] = n2 ? 1 : 0;
    }
    reset() {
      for (let e2 = 0, t2 = this.matrix.length; e2 !== t2; e2++)
        this.matrix[e2] = 0;
    }
    setNumObjects(e2) {
      this.matrix.length = e2 * (e2 - 1) >> 1;
    }
  }
  class GI {
    addEventListener(e2, t2) {
      void 0 === this._listeners && (this._listeners = {});
      const n2 = this._listeners;
      return void 0 === n2[e2] && (n2[e2] = []), n2[e2].includes(t2) || n2[e2].push(t2), this;
    }
    hasEventListener(e2, t2) {
      if (void 0 === this._listeners)
        return false;
      const n2 = this._listeners;
      return !(void 0 === n2[e2] || !n2[e2].includes(t2));
    }
    hasAnyEventListener(e2) {
      return void 0 !== this._listeners && void 0 !== this._listeners[e2];
    }
    removeEventListener(e2, t2) {
      if (void 0 === this._listeners)
        return this;
      const n2 = this._listeners;
      if (void 0 === n2[e2])
        return this;
      const r2 = n2[e2].indexOf(t2);
      return -1 !== r2 && n2[e2].splice(r2, 1), this;
    }
    dispatchEvent(e2) {
      if (void 0 === this._listeners)
        return this;
      const t2 = this._listeners[e2.type];
      if (void 0 !== t2) {
        e2.target = this;
        for (let n2 = 0, r2 = t2.length; n2 < r2; n2++)
          t2[n2].call(this, e2);
      }
      return this;
    }
  }
  class VI {
    constructor(e2, t2, n2, r2) {
      void 0 === e2 && (e2 = 0), void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = 0), void 0 === r2 && (r2 = 1), this.x = e2, this.y = t2, this.z = n2, this.w = r2;
    }
    set(e2, t2, n2, r2) {
      return this.x = e2, this.y = t2, this.z = n2, this.w = r2, this;
    }
    toString() {
      return `${this.x},${this.y},${this.z},${this.w}`;
    }
    toArray() {
      return [this.x, this.y, this.z, this.w];
    }
    setFromAxisAngle(e2, t2) {
      const n2 = Math.sin(0.5 * t2);
      return this.x = e2.x * n2, this.y = e2.y * n2, this.z = e2.z * n2, this.w = Math.cos(0.5 * t2), this;
    }
    toAxisAngle(e2) {
      void 0 === e2 && (e2 = new BI()), this.normalize();
      const t2 = 2 * Math.acos(this.w), n2 = Math.sqrt(1 - this.w * this.w);
      return n2 < 1e-3 ? (e2.x = this.x, e2.y = this.y, e2.z = this.z) : (e2.x = this.x / n2, e2.y = this.y / n2, e2.z = this.z / n2), [e2, t2];
    }
    setFromVectors(e2, t2) {
      if (e2.isAntiparallelTo(t2)) {
        const t3 = HI, n2 = QI;
        e2.tangents(t3, n2), this.setFromAxisAngle(t3, Math.PI);
      } else {
        const n2 = e2.cross(t2);
        this.x = n2.x, this.y = n2.y, this.z = n2.z, this.w = Math.sqrt(e2.length() ** 2 * t2.length() ** 2) + e2.dot(t2), this.normalize();
      }
      return this;
    }
    mult(e2, t2) {
      void 0 === t2 && (t2 = new VI());
      const n2 = this.x, r2 = this.y, i2 = this.z, s2 = this.w, o2 = e2.x, a2 = e2.y, l2 = e2.z, c2 = e2.w;
      return t2.x = n2 * c2 + s2 * o2 + r2 * l2 - i2 * a2, t2.y = r2 * c2 + s2 * a2 + i2 * o2 - n2 * l2, t2.z = i2 * c2 + s2 * l2 + n2 * a2 - r2 * o2, t2.w = s2 * c2 - n2 * o2 - r2 * a2 - i2 * l2, t2;
    }
    inverse(e2) {
      void 0 === e2 && (e2 = new VI());
      const t2 = this.x, n2 = this.y, r2 = this.z, i2 = this.w;
      this.conjugate(e2);
      const s2 = 1 / (t2 * t2 + n2 * n2 + r2 * r2 + i2 * i2);
      return e2.x *= s2, e2.y *= s2, e2.z *= s2, e2.w *= s2, e2;
    }
    conjugate(e2) {
      return void 0 === e2 && (e2 = new VI()), e2.x = -this.x, e2.y = -this.y, e2.z = -this.z, e2.w = this.w, e2;
    }
    normalize() {
      let e2 = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
      return 0 === e2 ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (e2 = 1 / e2, this.x *= e2, this.y *= e2, this.z *= e2, this.w *= e2), this;
    }
    normalizeFast() {
      const e2 = (3 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2;
      return 0 === e2 ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (this.x *= e2, this.y *= e2, this.z *= e2, this.w *= e2), this;
    }
    vmult(e2, t2) {
      void 0 === t2 && (t2 = new BI());
      const n2 = e2.x, r2 = e2.y, i2 = e2.z, s2 = this.x, o2 = this.y, a2 = this.z, l2 = this.w, c2 = l2 * n2 + o2 * i2 - a2 * r2, u2 = l2 * r2 + a2 * n2 - s2 * i2, p2 = l2 * i2 + s2 * r2 - o2 * n2, d2 = -s2 * n2 - o2 * r2 - a2 * i2;
      return t2.x = c2 * l2 + d2 * -s2 + u2 * -a2 - p2 * -o2, t2.y = u2 * l2 + d2 * -o2 + p2 * -s2 - c2 * -a2, t2.z = p2 * l2 + d2 * -a2 + c2 * -o2 - u2 * -s2, t2;
    }
    copy(e2) {
      return this.x = e2.x, this.y = e2.y, this.z = e2.z, this.w = e2.w, this;
    }
    toEuler(e2, t2) {
      let n2, r2, i2;
      void 0 === t2 && (t2 = "YZX");
      const s2 = this.x, o2 = this.y, a2 = this.z, l2 = this.w;
      if ("YZX" !== t2)
        throw new Error(`Euler order ${t2} not supported yet.`);
      {
        const e3 = s2 * o2 + a2 * l2;
        if (e3 > 0.499 && (n2 = 2 * Math.atan2(s2, l2), r2 = Math.PI / 2, i2 = 0), e3 < -0.499 && (n2 = -2 * Math.atan2(s2, l2), r2 = -Math.PI / 2, i2 = 0), void 0 === n2) {
          const t3 = s2 * s2, c2 = o2 * o2, u2 = a2 * a2;
          n2 = Math.atan2(2 * o2 * l2 - 2 * s2 * a2, 1 - 2 * c2 - 2 * u2), r2 = Math.asin(2 * e3), i2 = Math.atan2(2 * s2 * l2 - 2 * o2 * a2, 1 - 2 * t3 - 2 * u2);
        }
      }
      e2.y = n2, e2.z = r2, e2.x = i2;
    }
    setFromEuler(e2, t2, n2, r2) {
      void 0 === r2 && (r2 = "XYZ");
      const i2 = Math.cos(e2 / 2), s2 = Math.cos(t2 / 2), o2 = Math.cos(n2 / 2), a2 = Math.sin(e2 / 2), l2 = Math.sin(t2 / 2), c2 = Math.sin(n2 / 2);
      return "XYZ" === r2 ? (this.x = a2 * s2 * o2 + i2 * l2 * c2, this.y = i2 * l2 * o2 - a2 * s2 * c2, this.z = i2 * s2 * c2 + a2 * l2 * o2, this.w = i2 * s2 * o2 - a2 * l2 * c2) : "YXZ" === r2 ? (this.x = a2 * s2 * o2 + i2 * l2 * c2, this.y = i2 * l2 * o2 - a2 * s2 * c2, this.z = i2 * s2 * c2 - a2 * l2 * o2, this.w = i2 * s2 * o2 + a2 * l2 * c2) : "ZXY" === r2 ? (this.x = a2 * s2 * o2 - i2 * l2 * c2, this.y = i2 * l2 * o2 + a2 * s2 * c2, this.z = i2 * s2 * c2 + a2 * l2 * o2, this.w = i2 * s2 * o2 - a2 * l2 * c2) : "ZYX" === r2 ? (this.x = a2 * s2 * o2 - i2 * l2 * c2, this.y = i2 * l2 * o2 + a2 * s2 * c2, this.z = i2 * s2 * c2 - a2 * l2 * o2, this.w = i2 * s2 * o2 + a2 * l2 * c2) : "YZX" === r2 ? (this.x = a2 * s2 * o2 + i2 * l2 * c2, this.y = i2 * l2 * o2 + a2 * s2 * c2, this.z = i2 * s2 * c2 - a2 * l2 * o2, this.w = i2 * s2 * o2 - a2 * l2 * c2) : "XZY" === r2 && (this.x = a2 * s2 * o2 - i2 * l2 * c2, this.y = i2 * l2 * o2 - a2 * s2 * c2, this.z = i2 * s2 * c2 + a2 * l2 * o2, this.w = i2 * s2 * o2 + a2 * l2 * c2), this;
    }
    clone() {
      return new VI(this.x, this.y, this.z, this.w);
    }
    slerp(e2, t2, n2) {
      void 0 === n2 && (n2 = new VI());
      const r2 = this.x, i2 = this.y, s2 = this.z, o2 = this.w;
      let a2, l2, c2, u2, p2, d2 = e2.x, h2 = e2.y, f2 = e2.z, m2 = e2.w;
      return l2 = r2 * d2 + i2 * h2 + s2 * f2 + o2 * m2, l2 < 0 && (l2 = -l2, d2 = -d2, h2 = -h2, f2 = -f2, m2 = -m2), 1 - l2 > 1e-6 ? (a2 = Math.acos(l2), c2 = Math.sin(a2), u2 = Math.sin((1 - t2) * a2) / c2, p2 = Math.sin(t2 * a2) / c2) : (u2 = 1 - t2, p2 = t2), n2.x = u2 * r2 + p2 * d2, n2.y = u2 * i2 + p2 * h2, n2.z = u2 * s2 + p2 * f2, n2.w = u2 * o2 + p2 * m2, n2;
    }
    integrate(e2, t2, n2, r2) {
      void 0 === r2 && (r2 = new VI());
      const i2 = e2.x * n2.x, s2 = e2.y * n2.y, o2 = e2.z * n2.z, a2 = this.x, l2 = this.y, c2 = this.z, u2 = this.w, p2 = 0.5 * t2;
      return r2.x += p2 * (i2 * u2 + s2 * c2 - o2 * l2), r2.y += p2 * (s2 * u2 + o2 * a2 - i2 * c2), r2.z += p2 * (o2 * u2 + i2 * l2 - s2 * a2), r2.w += p2 * (-i2 * a2 - s2 * l2 - o2 * c2), r2;
    }
  }
  const HI = new BI(), QI = new BI();
  class WI {
    constructor(e2) {
      void 0 === e2 && (e2 = {}), this.id = WI.idCounter++, this.type = e2.type || 0, this.boundingSphereRadius = 0, this.collisionResponse = !e2.collisionResponse || e2.collisionResponse, this.collisionFilterGroup = void 0 !== e2.collisionFilterGroup ? e2.collisionFilterGroup : 1, this.collisionFilterMask = void 0 !== e2.collisionFilterMask ? e2.collisionFilterMask : -1, this.material = e2.material ? e2.material : null, this.body = null;
    }
    updateBoundingSphereRadius() {
      throw `computeBoundingSphereRadius() not implemented for shape type ${this.type}`;
    }
    volume() {
      throw `volume() not implemented for shape type ${this.type}`;
    }
    calculateLocalInertia(e2, t2) {
      throw `calculateLocalInertia() not implemented for shape type ${this.type}`;
    }
    calculateWorldAABB(e2, t2, n2, r2) {
      throw `calculateWorldAABB() not implemented for shape type ${this.type}`;
    }
  }
  WI.idCounter = 0, WI.types = { SPHERE: 1, PLANE: 2, BOX: 4, COMPOUND: 8, CONVEXPOLYHEDRON: 16, HEIGHTFIELD: 32, PARTICLE: 64, CYLINDER: 128, TRIMESH: 256 };
  class qI {
    constructor(e2) {
      void 0 === e2 && (e2 = {}), this.position = new BI(), this.quaternion = new VI(), e2.position && this.position.copy(e2.position), e2.quaternion && this.quaternion.copy(e2.quaternion);
    }
    pointToLocal(e2, t2) {
      return qI.pointToLocalFrame(this.position, this.quaternion, e2, t2);
    }
    pointToWorld(e2, t2) {
      return qI.pointToWorldFrame(this.position, this.quaternion, e2, t2);
    }
    vectorToWorldFrame(e2, t2) {
      return void 0 === t2 && (t2 = new BI()), this.quaternion.vmult(e2, t2), t2;
    }
    static pointToLocalFrame(e2, t2, n2, r2) {
      return void 0 === r2 && (r2 = new BI()), n2.vsub(e2, r2), t2.conjugate(XI), XI.vmult(r2, r2), r2;
    }
    static pointToWorldFrame(e2, t2, n2, r2) {
      return void 0 === r2 && (r2 = new BI()), t2.vmult(n2, r2), r2.vadd(e2, r2), r2;
    }
    static vectorToWorldFrame(e2, t2, n2) {
      return void 0 === n2 && (n2 = new BI()), e2.vmult(t2, n2), n2;
    }
    static vectorToLocalFrame(e2, t2, n2, r2) {
      return void 0 === r2 && (r2 = new BI()), t2.w *= -1, t2.vmult(n2, r2), t2.w *= -1, r2;
    }
  }
  const XI = new VI();
  class YI extends WI {
    constructor(e2) {
      void 0 === e2 && (e2 = {});
      const { vertices: t2 = [], faces: n2 = [], normals: r2 = [], axes: i2, boundingSphereRadius: s2 } = e2;
      super({ type: WI.types.CONVEXPOLYHEDRON }), this.vertices = t2, this.faces = n2, this.faceNormals = r2, 0 === this.faceNormals.length && this.computeNormals(), s2 ? this.boundingSphereRadius = s2 : this.updateBoundingSphereRadius(), this.worldVertices = [], this.worldVerticesNeedsUpdate = true, this.worldFaceNormals = [], this.worldFaceNormalsNeedsUpdate = true, this.uniqueAxes = i2 ? i2.slice() : null, this.uniqueEdges = [], this.computeEdges();
    }
    computeEdges() {
      const e2 = this.faces, t2 = this.vertices, n2 = this.uniqueEdges;
      n2.length = 0;
      const r2 = new BI();
      for (let i2 = 0; i2 !== e2.length; i2++) {
        const s2 = e2[i2], o2 = s2.length;
        for (let e3 = 0; e3 !== o2; e3++) {
          const i3 = (e3 + 1) % o2;
          t2[s2[e3]].vsub(t2[s2[i3]], r2), r2.normalize();
          let a2 = false;
          for (let e4 = 0; e4 !== n2.length; e4++)
            if (n2[e4].almostEquals(r2) || n2[e4].almostEquals(r2)) {
              a2 = true;
              break;
            }
          a2 || n2.push(r2.clone());
        }
      }
    }
    computeNormals() {
      this.faceNormals.length = this.faces.length;
      for (let e2 = 0; e2 < this.faces.length; e2++) {
        for (let t3 = 0; t3 < this.faces[e2].length; t3++)
          if (!this.vertices[this.faces[e2][t3]])
            throw new Error(`Vertex ${this.faces[e2][t3]} not found!`);
        const t2 = this.faceNormals[e2] || new BI();
        this.getFaceNormal(e2, t2), t2.negate(t2), this.faceNormals[e2] = t2;
        const n2 = this.vertices[this.faces[e2][0]];
        if (t2.dot(n2) < 0) {
          console.error(`.faceNormals[${e2}] = Vec3(${t2.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);
          for (let t3 = 0; t3 < this.faces[e2].length; t3++)
            console.warn(`.vertices[${this.faces[e2][t3]}] = Vec3(${this.vertices[this.faces[e2][t3]].toString()})`);
        }
      }
    }
    getFaceNormal(e2, t2) {
      const n2 = this.faces[e2], r2 = this.vertices[n2[0]], i2 = this.vertices[n2[1]], s2 = this.vertices[n2[2]];
      YI.computeNormal(r2, i2, s2, t2);
    }
    static computeNormal(e2, t2, n2, r2) {
      const i2 = new BI(), s2 = new BI();
      t2.vsub(e2, s2), n2.vsub(t2, i2), i2.cross(s2, r2), r2.isZero() || r2.normalize();
    }
    clipAgainstHull(e2, t2, n2, r2, i2, s2, o2, a2, l2) {
      const c2 = new BI();
      let u2 = -1, p2 = -Number.MAX_VALUE;
      for (let e3 = 0; e3 < n2.faces.length; e3++) {
        c2.copy(n2.faceNormals[e3]), i2.vmult(c2, c2);
        const t3 = c2.dot(s2);
        t3 > p2 && (p2 = t3, u2 = e3);
      }
      const d2 = [];
      for (let e3 = 0; e3 < n2.faces[u2].length; e3++) {
        const t3 = n2.vertices[n2.faces[u2][e3]], s3 = new BI();
        s3.copy(t3), i2.vmult(s3, s3), r2.vadd(s3, s3), d2.push(s3);
      }
      u2 >= 0 && this.clipFaceAgainstHull(s2, e2, t2, d2, o2, a2, l2);
    }
    findSeparatingAxis(e2, t2, n2, r2, i2, s2, o2, a2) {
      const l2 = new BI(), c2 = new BI(), u2 = new BI(), p2 = new BI(), d2 = new BI(), h2 = new BI();
      let f2 = Number.MAX_VALUE;
      const m2 = this;
      if (m2.uniqueAxes)
        for (let o3 = 0; o3 !== m2.uniqueAxes.length; o3++) {
          n2.vmult(m2.uniqueAxes[o3], l2);
          const a3 = m2.testSepAxis(l2, e2, t2, n2, r2, i2);
          if (false === a3)
            return false;
          a3 < f2 && (f2 = a3, s2.copy(l2));
        }
      else {
        const a3 = o2 ? o2.length : m2.faces.length;
        for (let c3 = 0; c3 < a3; c3++) {
          const a4 = o2 ? o2[c3] : c3;
          l2.copy(m2.faceNormals[a4]), n2.vmult(l2, l2);
          const u3 = m2.testSepAxis(l2, e2, t2, n2, r2, i2);
          if (false === u3)
            return false;
          u3 < f2 && (f2 = u3, s2.copy(l2));
        }
      }
      if (e2.uniqueAxes)
        for (let o3 = 0; o3 !== e2.uniqueAxes.length; o3++) {
          i2.vmult(e2.uniqueAxes[o3], c2);
          const a3 = m2.testSepAxis(c2, e2, t2, n2, r2, i2);
          if (false === a3)
            return false;
          a3 < f2 && (f2 = a3, s2.copy(c2));
        }
      else {
        const o3 = a2 ? a2.length : e2.faces.length;
        for (let l3 = 0; l3 < o3; l3++) {
          const o4 = a2 ? a2[l3] : l3;
          c2.copy(e2.faceNormals[o4]), i2.vmult(c2, c2);
          const u3 = m2.testSepAxis(c2, e2, t2, n2, r2, i2);
          if (false === u3)
            return false;
          u3 < f2 && (f2 = u3, s2.copy(c2));
        }
      }
      for (let o3 = 0; o3 !== m2.uniqueEdges.length; o3++) {
        n2.vmult(m2.uniqueEdges[o3], p2);
        for (let o4 = 0; o4 !== e2.uniqueEdges.length; o4++)
          if (i2.vmult(e2.uniqueEdges[o4], d2), p2.cross(d2, h2), !h2.almostZero()) {
            h2.normalize();
            const o5 = m2.testSepAxis(h2, e2, t2, n2, r2, i2);
            if (false === o5)
              return false;
            o5 < f2 && (f2 = o5, s2.copy(h2));
          }
      }
      return r2.vsub(t2, u2), u2.dot(s2) > 0 && s2.negate(s2), true;
    }
    testSepAxis(e2, t2, n2, r2, i2, s2) {
      YI.project(this, e2, n2, r2, KI), YI.project(t2, e2, i2, s2, JI);
      const o2 = KI[0], a2 = KI[1], l2 = JI[0], c2 = JI[1];
      if (o2 < c2 || l2 < a2)
        return false;
      const u2 = o2 - c2, p2 = l2 - a2;
      return u2 < p2 ? u2 : p2;
    }
    calculateLocalInertia(e2, t2) {
      const n2 = new BI(), r2 = new BI();
      this.computeLocalAABB(r2, n2);
      const i2 = n2.x - r2.x, s2 = n2.y - r2.y, o2 = n2.z - r2.z;
      t2.x = 1 / 12 * e2 * (2 * s2 * 2 * s2 + 2 * o2 * 2 * o2), t2.y = 1 / 12 * e2 * (2 * i2 * 2 * i2 + 2 * o2 * 2 * o2), t2.z = 1 / 12 * e2 * (2 * s2 * 2 * s2 + 2 * i2 * 2 * i2);
    }
    getPlaneConstantOfFace(e2) {
      const t2 = this.faces[e2], n2 = this.faceNormals[e2], r2 = this.vertices[t2[0]];
      return -n2.dot(r2);
    }
    clipFaceAgainstHull(e2, t2, n2, r2, i2, s2, o2) {
      const a2 = new BI(), l2 = new BI(), c2 = new BI(), u2 = new BI(), p2 = new BI(), d2 = new BI(), h2 = new BI(), f2 = new BI(), m2 = this, _2 = r2, g2 = [];
      let v2 = -1, y2 = Number.MAX_VALUE;
      for (let t3 = 0; t3 < m2.faces.length; t3++) {
        a2.copy(m2.faceNormals[t3]), n2.vmult(a2, a2);
        const r3 = a2.dot(e2);
        r3 < y2 && (y2 = r3, v2 = t3);
      }
      if (v2 < 0)
        return;
      const b2 = m2.faces[v2];
      b2.connectedFaces = [];
      for (let e3 = 0; e3 < m2.faces.length; e3++)
        for (let t3 = 0; t3 < m2.faces[e3].length; t3++)
          -1 !== b2.indexOf(m2.faces[e3][t3]) && e3 !== v2 && -1 === b2.connectedFaces.indexOf(e3) && b2.connectedFaces.push(e3);
      const w2 = b2.length;
      for (let e3 = 0; e3 < w2; e3++) {
        const r3 = m2.vertices[b2[e3]], i3 = m2.vertices[b2[(e3 + 1) % w2]];
        r3.vsub(i3, l2), c2.copy(l2), n2.vmult(c2, c2), t2.vadd(c2, c2), u2.copy(this.faceNormals[v2]), n2.vmult(u2, u2), t2.vadd(u2, u2), c2.cross(u2, p2), p2.negate(p2), d2.copy(r3), n2.vmult(d2, d2), t2.vadd(d2, d2);
        const s3 = b2.connectedFaces[e3];
        h2.copy(this.faceNormals[s3]);
        const o3 = this.getPlaneConstantOfFace(s3);
        f2.copy(h2), n2.vmult(f2, f2);
        const a3 = o3 - f2.dot(t2);
        for (this.clipFaceAgainstPlane(_2, g2, f2, a3); _2.length; )
          _2.shift();
        for (; g2.length; )
          _2.push(g2.shift());
      }
      h2.copy(this.faceNormals[v2]);
      const A2 = this.getPlaneConstantOfFace(v2);
      f2.copy(h2), n2.vmult(f2, f2);
      const x2 = A2 - f2.dot(t2);
      for (let e3 = 0; e3 < _2.length; e3++) {
        let t3 = f2.dot(_2[e3]) + x2;
        if (t3 <= i2 && (console.log(`clamped: depth=${t3} to minDist=${i2}`), t3 = i2), t3 <= s2) {
          const n3 = _2[e3];
          if (t3 <= 1e-6) {
            const e4 = { point: n3, normal: f2, depth: t3 };
            o2.push(e4);
          }
        }
      }
    }
    clipFaceAgainstPlane(e2, t2, n2, r2) {
      let i2, s2;
      const o2 = e2.length;
      if (o2 < 2)
        return t2;
      let a2 = e2[e2.length - 1], l2 = e2[0];
      i2 = n2.dot(a2) + r2;
      for (let c2 = 0; c2 < o2; c2++) {
        if (l2 = e2[c2], s2 = n2.dot(l2) + r2, i2 < 0)
          if (s2 < 0) {
            const e3 = new BI();
            e3.copy(l2), t2.push(e3);
          } else {
            const e3 = new BI();
            a2.lerp(l2, i2 / (i2 - s2), e3), t2.push(e3);
          }
        else if (s2 < 0) {
          const e3 = new BI();
          a2.lerp(l2, i2 / (i2 - s2), e3), t2.push(e3), t2.push(l2);
        }
        a2 = l2, i2 = s2;
      }
      return t2;
    }
    computeWorldVertices(e2, t2) {
      for (; this.worldVertices.length < this.vertices.length; )
        this.worldVertices.push(new BI());
      const n2 = this.vertices, r2 = this.worldVertices;
      for (let i2 = 0; i2 !== this.vertices.length; i2++)
        t2.vmult(n2[i2], r2[i2]), e2.vadd(r2[i2], r2[i2]);
      this.worldVerticesNeedsUpdate = false;
    }
    computeLocalAABB(e2, t2) {
      const n2 = this.vertices;
      e2.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), t2.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
      for (let r2 = 0; r2 < this.vertices.length; r2++) {
        const i2 = n2[r2];
        i2.x < e2.x ? e2.x = i2.x : i2.x > t2.x && (t2.x = i2.x), i2.y < e2.y ? e2.y = i2.y : i2.y > t2.y && (t2.y = i2.y), i2.z < e2.z ? e2.z = i2.z : i2.z > t2.z && (t2.z = i2.z);
      }
    }
    computeWorldFaceNormals(e2) {
      const t2 = this.faceNormals.length;
      for (; this.worldFaceNormals.length < t2; )
        this.worldFaceNormals.push(new BI());
      const n2 = this.faceNormals, r2 = this.worldFaceNormals;
      for (let i2 = 0; i2 !== t2; i2++)
        e2.vmult(n2[i2], r2[i2]);
      this.worldFaceNormalsNeedsUpdate = false;
    }
    updateBoundingSphereRadius() {
      let e2 = 0;
      const t2 = this.vertices;
      for (let n2 = 0; n2 !== t2.length; n2++) {
        const r2 = t2[n2].lengthSquared();
        r2 > e2 && (e2 = r2);
      }
      this.boundingSphereRadius = Math.sqrt(e2);
    }
    calculateWorldAABB(e2, t2, n2, r2) {
      const i2 = this.vertices;
      let s2, o2, a2, l2, c2, u2, p2 = new BI();
      for (let n3 = 0; n3 < i2.length; n3++) {
        p2.copy(i2[n3]), t2.vmult(p2, p2), e2.vadd(p2, p2);
        const r3 = p2;
        (void 0 === s2 || r3.x < s2) && (s2 = r3.x), (void 0 === l2 || r3.x > l2) && (l2 = r3.x), (void 0 === o2 || r3.y < o2) && (o2 = r3.y), (void 0 === c2 || r3.y > c2) && (c2 = r3.y), (void 0 === a2 || r3.z < a2) && (a2 = r3.z), (void 0 === u2 || r3.z > u2) && (u2 = r3.z);
      }
      n2.set(s2, o2, a2), r2.set(l2, c2, u2);
    }
    volume() {
      return 4 * Math.PI * this.boundingSphereRadius / 3;
    }
    getAveragePointLocal(e2) {
      void 0 === e2 && (e2 = new BI());
      const t2 = this.vertices;
      for (let n2 = 0; n2 < t2.length; n2++)
        e2.vadd(t2[n2], e2);
      return e2.scale(1 / t2.length, e2), e2;
    }
    transformAllPoints(e2, t2) {
      const n2 = this.vertices.length, r2 = this.vertices;
      if (t2) {
        for (let e3 = 0; e3 < n2; e3++) {
          const n3 = r2[e3];
          t2.vmult(n3, n3);
        }
        for (let e3 = 0; e3 < this.faceNormals.length; e3++) {
          const n3 = this.faceNormals[e3];
          t2.vmult(n3, n3);
        }
      }
      if (e2)
        for (let t3 = 0; t3 < n2; t3++) {
          const n3 = r2[t3];
          n3.vadd(e2, n3);
        }
    }
    pointIsInside(e2) {
      const t2 = this.vertices, n2 = this.faces, r2 = this.faceNormals, i2 = new BI();
      this.getAveragePointLocal(i2);
      for (let s2 = 0; s2 < this.faces.length; s2++) {
        let o2 = r2[s2];
        const a2 = t2[n2[s2][0]], l2 = new BI();
        e2.vsub(a2, l2);
        const c2 = o2.dot(l2), u2 = new BI();
        i2.vsub(a2, u2);
        const p2 = o2.dot(u2);
        if (c2 < 0 && p2 > 0 || c2 > 0 && p2 < 0)
          return false;
      }
      return -1;
    }
    static project(e2, t2, n2, r2, i2) {
      const s2 = e2.vertices.length, o2 = ZI;
      let a2 = 0, l2 = 0;
      const c2 = $I, u2 = e2.vertices;
      c2.setZero(), qI.vectorToLocalFrame(n2, r2, t2, o2), qI.pointToLocalFrame(n2, r2, c2, c2);
      const p2 = c2.dot(o2);
      l2 = a2 = u2[0].dot(o2);
      for (let e3 = 1; e3 < s2; e3++) {
        const t3 = u2[e3].dot(o2);
        t3 > a2 && (a2 = t3), t3 < l2 && (l2 = t3);
      }
      if (l2 -= p2, a2 -= p2, l2 > a2) {
        const e3 = l2;
        l2 = a2, a2 = e3;
      }
      i2[0] = a2, i2[1] = l2;
    }
  }
  const KI = [], JI = [], ZI = (new BI(), new BI()), $I = new BI();
  class eR extends WI {
    constructor(e2) {
      super({ type: WI.types.BOX }), this.halfExtents = e2, this.convexPolyhedronRepresentation = null, this.updateConvexPolyhedronRepresentation(), this.updateBoundingSphereRadius();
    }
    updateConvexPolyhedronRepresentation() {
      const e2 = this.halfExtents.x, t2 = this.halfExtents.y, n2 = this.halfExtents.z, r2 = BI, i2 = [new r2(-e2, -t2, -n2), new r2(e2, -t2, -n2), new r2(e2, t2, -n2), new r2(-e2, t2, -n2), new r2(-e2, -t2, n2), new r2(e2, -t2, n2), new r2(e2, t2, n2), new r2(-e2, t2, n2)], s2 = [new r2(0, 0, 1), new r2(0, 1, 0), new r2(1, 0, 0)], o2 = new YI({ vertices: i2, faces: [[3, 2, 1, 0], [4, 5, 6, 7], [5, 4, 0, 1], [2, 3, 7, 6], [0, 4, 7, 3], [1, 2, 6, 5]], axes: s2 });
      this.convexPolyhedronRepresentation = o2, o2.material = this.material;
    }
    calculateLocalInertia(e2, t2) {
      return void 0 === t2 && (t2 = new BI()), eR.calculateInertia(this.halfExtents, e2, t2), t2;
    }
    static calculateInertia(e2, t2, n2) {
      const r2 = e2;
      n2.x = 1 / 12 * t2 * (2 * r2.y * 2 * r2.y + 2 * r2.z * 2 * r2.z), n2.y = 1 / 12 * t2 * (2 * r2.x * 2 * r2.x + 2 * r2.z * 2 * r2.z), n2.z = 1 / 12 * t2 * (2 * r2.y * 2 * r2.y + 2 * r2.x * 2 * r2.x);
    }
    getSideNormals(e2, t2) {
      const n2 = e2, r2 = this.halfExtents;
      if (n2[0].set(r2.x, 0, 0), n2[1].set(0, r2.y, 0), n2[2].set(0, 0, r2.z), n2[3].set(-r2.x, 0, 0), n2[4].set(0, -r2.y, 0), n2[5].set(0, 0, -r2.z), void 0 !== t2)
        for (let e3 = 0; e3 !== n2.length; e3++)
          t2.vmult(n2[e3], n2[e3]);
      return n2;
    }
    volume() {
      return 8 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;
    }
    updateBoundingSphereRadius() {
      this.boundingSphereRadius = this.halfExtents.length();
    }
    forEachWorldCorner(e2, t2, n2) {
      const r2 = this.halfExtents, i2 = [[r2.x, r2.y, r2.z], [-r2.x, r2.y, r2.z], [-r2.x, -r2.y, r2.z], [-r2.x, -r2.y, -r2.z], [r2.x, -r2.y, -r2.z], [r2.x, r2.y, -r2.z], [-r2.x, r2.y, -r2.z], [r2.x, -r2.y, r2.z]];
      for (let r3 = 0; r3 < i2.length; r3++)
        tR.set(i2[r3][0], i2[r3][1], i2[r3][2]), t2.vmult(tR, tR), e2.vadd(tR, tR), n2(tR.x, tR.y, tR.z);
    }
    calculateWorldAABB(e2, t2, n2, r2) {
      const i2 = this.halfExtents;
      nR[0].set(i2.x, i2.y, i2.z), nR[1].set(-i2.x, i2.y, i2.z), nR[2].set(-i2.x, -i2.y, i2.z), nR[3].set(-i2.x, -i2.y, -i2.z), nR[4].set(i2.x, -i2.y, -i2.z), nR[5].set(i2.x, i2.y, -i2.z), nR[6].set(-i2.x, i2.y, -i2.z), nR[7].set(i2.x, -i2.y, i2.z);
      const s2 = nR[0];
      t2.vmult(s2, s2), e2.vadd(s2, s2), r2.copy(s2), n2.copy(s2);
      for (let i3 = 1; i3 < 8; i3++) {
        const s3 = nR[i3];
        t2.vmult(s3, s3), e2.vadd(s3, s3);
        const o2 = s3.x, a2 = s3.y, l2 = s3.z;
        o2 > r2.x && (r2.x = o2), a2 > r2.y && (r2.y = a2), l2 > r2.z && (r2.z = l2), o2 < n2.x && (n2.x = o2), a2 < n2.y && (n2.y = a2), l2 < n2.z && (n2.z = l2);
      }
    }
  }
  const tR = new BI(), nR = [new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new BI()];
  class rR extends GI {
    constructor(e2) {
      void 0 === e2 && (e2 = {}), super(), this.id = rR.idCounter++, this.index = -1, this.world = null, this.vlambda = new BI(), this.collisionFilterGroup = "number" == typeof e2.collisionFilterGroup ? e2.collisionFilterGroup : 1, this.collisionFilterMask = "number" == typeof e2.collisionFilterMask ? e2.collisionFilterMask : -1, this.collisionResponse = "boolean" != typeof e2.collisionResponse || e2.collisionResponse, this.position = new BI(), this.previousPosition = new BI(), this.interpolatedPosition = new BI(), this.initPosition = new BI(), e2.position && (this.position.copy(e2.position), this.previousPosition.copy(e2.position), this.interpolatedPosition.copy(e2.position), this.initPosition.copy(e2.position)), this.velocity = new BI(), e2.velocity && this.velocity.copy(e2.velocity), this.initVelocity = new BI(), this.force = new BI();
      const t2 = "number" == typeof e2.mass ? e2.mass : 0;
      this.mass = t2, this.invMass = t2 > 0 ? 1 / t2 : 0, this.material = e2.material || null, this.linearDamping = "number" == typeof e2.linearDamping ? e2.linearDamping : 0.01, this.type = t2 <= 0 ? rR.STATIC : rR.DYNAMIC, typeof e2.type == typeof rR.STATIC && (this.type = e2.type), this.allowSleep = void 0 === e2.allowSleep || e2.allowSleep, this.sleepState = rR.AWAKE, this.sleepSpeedLimit = void 0 !== e2.sleepSpeedLimit ? e2.sleepSpeedLimit : 0.1, this.sleepTimeLimit = void 0 !== e2.sleepTimeLimit ? e2.sleepTimeLimit : 1, this.timeLastSleepy = 0, this.wakeUpAfterNarrowphase = false, this.torque = new BI(), this.quaternion = new VI(), this.initQuaternion = new VI(), this.previousQuaternion = new VI(), this.interpolatedQuaternion = new VI(), e2.quaternion && (this.quaternion.copy(e2.quaternion), this.initQuaternion.copy(e2.quaternion), this.previousQuaternion.copy(e2.quaternion), this.interpolatedQuaternion.copy(e2.quaternion)), this.angularVelocity = new BI(), e2.angularVelocity && this.angularVelocity.copy(e2.angularVelocity), this.initAngularVelocity = new BI(), this.shapes = [], this.shapeOffsets = [], this.shapeOrientations = [], this.inertia = new BI(), this.invInertia = new BI(), this.invInertiaWorld = new kI(), this.invMassSolve = 0, this.invInertiaSolve = new BI(), this.invInertiaWorldSolve = new kI(), this.fixedRotation = void 0 !== e2.fixedRotation && e2.fixedRotation, this.angularDamping = void 0 !== e2.angularDamping ? e2.angularDamping : 0.01, this.linearFactor = new BI(1, 1, 1), e2.linearFactor && this.linearFactor.copy(e2.linearFactor), this.angularFactor = new BI(1, 1, 1), e2.angularFactor && this.angularFactor.copy(e2.angularFactor), this.aabb = new FI(), this.aabbNeedsUpdate = true, this.boundingRadius = 0, this.wlambda = new BI(), this.isTrigger = Boolean(e2.isTrigger), e2.shape && this.addShape(e2.shape), this.updateMassProperties();
    }
    wakeUp() {
      const e2 = this.sleepState;
      this.sleepState = rR.AWAKE, this.wakeUpAfterNarrowphase = false, e2 === rR.SLEEPING && this.dispatchEvent(rR.wakeupEvent);
    }
    sleep() {
      this.sleepState = rR.SLEEPING, this.velocity.set(0, 0, 0), this.angularVelocity.set(0, 0, 0), this.wakeUpAfterNarrowphase = false;
    }
    sleepTick(e2) {
      if (this.allowSleep) {
        const t2 = this.sleepState, n2 = this.velocity.lengthSquared() + this.angularVelocity.lengthSquared(), r2 = this.sleepSpeedLimit ** 2;
        t2 === rR.AWAKE && n2 < r2 ? (this.sleepState = rR.SLEEPY, this.timeLastSleepy = e2, this.dispatchEvent(rR.sleepyEvent)) : t2 === rR.SLEEPY && n2 > r2 ? this.wakeUp() : t2 === rR.SLEEPY && e2 - this.timeLastSleepy > this.sleepTimeLimit && (this.sleep(), this.dispatchEvent(rR.sleepEvent));
      }
    }
    updateSolveMassProperties() {
      this.sleepState === rR.SLEEPING || this.type === rR.KINEMATIC ? (this.invMassSolve = 0, this.invInertiaSolve.setZero(), this.invInertiaWorldSolve.setZero()) : (this.invMassSolve = this.invMass, this.invInertiaSolve.copy(this.invInertia), this.invInertiaWorldSolve.copy(this.invInertiaWorld));
    }
    pointToLocalFrame(e2, t2) {
      return void 0 === t2 && (t2 = new BI()), e2.vsub(this.position, t2), this.quaternion.conjugate().vmult(t2, t2), t2;
    }
    vectorToLocalFrame(e2, t2) {
      return void 0 === t2 && (t2 = new BI()), this.quaternion.conjugate().vmult(e2, t2), t2;
    }
    pointToWorldFrame(e2, t2) {
      return void 0 === t2 && (t2 = new BI()), this.quaternion.vmult(e2, t2), t2.vadd(this.position, t2), t2;
    }
    vectorToWorldFrame(e2, t2) {
      return void 0 === t2 && (t2 = new BI()), this.quaternion.vmult(e2, t2), t2;
    }
    addShape(e2, t2, n2) {
      const r2 = new BI(), i2 = new VI();
      return t2 && r2.copy(t2), n2 && i2.copy(n2), this.shapes.push(e2), this.shapeOffsets.push(r2), this.shapeOrientations.push(i2), this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = true, e2.body = this, this;
    }
    removeShape(e2) {
      const t2 = this.shapes.indexOf(e2);
      return -1 === t2 ? (console.warn("Shape does not belong to the body"), this) : (this.shapes.splice(t2, 1), this.shapeOffsets.splice(t2, 1), this.shapeOrientations.splice(t2, 1), this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = true, e2.body = null, this);
    }
    updateBoundingRadius() {
      const e2 = this.shapes, t2 = this.shapeOffsets, n2 = e2.length;
      let r2 = 0;
      for (let i2 = 0; i2 !== n2; i2++) {
        const n3 = e2[i2];
        n3.updateBoundingSphereRadius();
        const s2 = t2[i2].length(), o2 = n3.boundingSphereRadius;
        s2 + o2 > r2 && (r2 = s2 + o2);
      }
      this.boundingRadius = r2;
    }
    updateAABB() {
      const e2 = this.shapes, t2 = this.shapeOffsets, n2 = this.shapeOrientations, r2 = e2.length, i2 = iR, s2 = sR, o2 = this.quaternion, a2 = this.aabb, l2 = oR;
      for (let c2 = 0; c2 !== r2; c2++) {
        const r3 = e2[c2];
        o2.vmult(t2[c2], i2), i2.vadd(this.position, i2), o2.mult(n2[c2], s2), r3.calculateWorldAABB(i2, s2, l2.lowerBound, l2.upperBound), 0 === c2 ? a2.copy(l2) : a2.extend(l2);
      }
      this.aabbNeedsUpdate = false;
    }
    updateInertiaWorld(e2) {
      const t2 = this.invInertia;
      if (t2.x !== t2.y || t2.y !== t2.z || e2) {
        const e3 = aR, n2 = lR;
        e3.setRotationFromQuaternion(this.quaternion), e3.transpose(n2), e3.scale(t2, e3), e3.mmult(n2, this.invInertiaWorld);
      }
    }
    applyForce(e2, t2) {
      if (void 0 === t2 && (t2 = new BI()), this.type !== rR.DYNAMIC)
        return;
      this.sleepState === rR.SLEEPING && this.wakeUp();
      const n2 = cR;
      t2.cross(e2, n2), this.force.vadd(e2, this.force), this.torque.vadd(n2, this.torque);
    }
    applyLocalForce(e2, t2) {
      if (void 0 === t2 && (t2 = new BI()), this.type !== rR.DYNAMIC)
        return;
      const n2 = uR, r2 = pR;
      this.vectorToWorldFrame(e2, n2), this.vectorToWorldFrame(t2, r2), this.applyForce(n2, r2);
    }
    applyTorque(e2) {
      this.type === rR.DYNAMIC && (this.sleepState === rR.SLEEPING && this.wakeUp(), this.torque.vadd(e2, this.torque));
    }
    applyImpulse(e2, t2) {
      if (void 0 === t2 && (t2 = new BI()), this.type !== rR.DYNAMIC)
        return;
      this.sleepState === rR.SLEEPING && this.wakeUp();
      const n2 = t2, r2 = dR;
      r2.copy(e2), r2.scale(this.invMass, r2), this.velocity.vadd(r2, this.velocity);
      const i2 = hR;
      n2.cross(e2, i2), this.invInertiaWorld.vmult(i2, i2), this.angularVelocity.vadd(i2, this.angularVelocity);
    }
    applyLocalImpulse(e2, t2) {
      if (void 0 === t2 && (t2 = new BI()), this.type !== rR.DYNAMIC)
        return;
      const n2 = fR, r2 = mR;
      this.vectorToWorldFrame(e2, n2), this.vectorToWorldFrame(t2, r2), this.applyImpulse(n2, r2);
    }
    updateMassProperties() {
      const e2 = _R;
      this.invMass = this.mass > 0 ? 1 / this.mass : 0;
      const t2 = this.inertia, n2 = this.fixedRotation;
      this.updateAABB(), e2.set((this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2, (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2, (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2), eR.calculateInertia(e2, this.mass, t2), this.invInertia.set(t2.x > 0 && !n2 ? 1 / t2.x : 0, t2.y > 0 && !n2 ? 1 / t2.y : 0, t2.z > 0 && !n2 ? 1 / t2.z : 0), this.updateInertiaWorld(true);
    }
    getVelocityAtWorldPoint(e2, t2) {
      const n2 = new BI();
      return e2.vsub(this.position, n2), this.angularVelocity.cross(n2, t2), this.velocity.vadd(t2, t2), t2;
    }
    integrate(e2, t2, n2) {
      if (this.previousPosition.copy(this.position), this.previousQuaternion.copy(this.quaternion), this.type !== rR.DYNAMIC && this.type !== rR.KINEMATIC || this.sleepState === rR.SLEEPING)
        return;
      const r2 = this.velocity, i2 = this.angularVelocity, s2 = this.position, o2 = this.force, a2 = this.torque, l2 = this.quaternion, c2 = this.invMass, u2 = this.invInertiaWorld, p2 = this.linearFactor, d2 = c2 * e2;
      r2.x += o2.x * d2 * p2.x, r2.y += o2.y * d2 * p2.y, r2.z += o2.z * d2 * p2.z;
      const h2 = u2.elements, f2 = this.angularFactor, m2 = a2.x * f2.x, _2 = a2.y * f2.y, g2 = a2.z * f2.z;
      i2.x += e2 * (h2[0] * m2 + h2[1] * _2 + h2[2] * g2), i2.y += e2 * (h2[3] * m2 + h2[4] * _2 + h2[5] * g2), i2.z += e2 * (h2[6] * m2 + h2[7] * _2 + h2[8] * g2), s2.x += r2.x * e2, s2.y += r2.y * e2, s2.z += r2.z * e2, l2.integrate(this.angularVelocity, e2, this.angularFactor, l2), t2 && (n2 ? l2.normalizeFast() : l2.normalize()), this.aabbNeedsUpdate = true, this.updateInertiaWorld();
    }
  }
  rR.idCounter = 0, rR.COLLIDE_EVENT_NAME = "collide", rR.DYNAMIC = 1, rR.STATIC = 2, rR.KINEMATIC = 4, rR.AWAKE = 0, rR.SLEEPY = 1, rR.SLEEPING = 2, rR.wakeupEvent = { type: "wakeup" }, rR.sleepyEvent = { type: "sleepy" }, rR.sleepEvent = { type: "sleep" };
  const iR = new BI(), sR = new VI(), oR = new FI(), aR = new kI(), lR = new kI(), cR = (new kI(), new BI()), uR = new BI(), pR = new BI(), dR = new BI(), hR = new BI(), fR = new BI(), mR = new BI(), _R = new BI();
  class gR {
    constructor() {
      this.world = null, this.useBoundingBoxes = false, this.dirty = true;
    }
    collisionPairs(e2, t2, n2) {
      throw new Error("collisionPairs not implemented for this BroadPhase class!");
    }
    needBroadphaseCollision(e2, t2) {
      return 0 != (e2.collisionFilterGroup & t2.collisionFilterMask) && 0 != (t2.collisionFilterGroup & e2.collisionFilterMask) && (0 == (e2.type & rR.STATIC) && e2.sleepState !== rR.SLEEPING || 0 == (t2.type & rR.STATIC) && t2.sleepState !== rR.SLEEPING);
    }
    intersectionTest(e2, t2, n2, r2) {
      this.useBoundingBoxes ? this.doBoundingBoxBroadphase(e2, t2, n2, r2) : this.doBoundingSphereBroadphase(e2, t2, n2, r2);
    }
    doBoundingSphereBroadphase(e2, t2, n2, r2) {
      const i2 = vR;
      t2.position.vsub(e2.position, i2);
      const s2 = (e2.boundingRadius + t2.boundingRadius) ** 2;
      i2.lengthSquared() < s2 && (n2.push(e2), r2.push(t2));
    }
    doBoundingBoxBroadphase(e2, t2, n2, r2) {
      e2.aabbNeedsUpdate && e2.updateAABB(), t2.aabbNeedsUpdate && t2.updateAABB(), e2.aabb.overlaps(t2.aabb) && (n2.push(e2), r2.push(t2));
    }
    makePairsUnique(e2, t2) {
      const n2 = yR, r2 = bR, i2 = wR, s2 = e2.length;
      for (let n3 = 0; n3 !== s2; n3++)
        r2[n3] = e2[n3], i2[n3] = t2[n3];
      e2.length = 0, t2.length = 0;
      for (let e3 = 0; e3 !== s2; e3++) {
        const t3 = r2[e3].id, s3 = i2[e3].id, o2 = t3 < s3 ? `${t3},${s3}` : `${s3},${t3}`;
        n2[o2] = e3, n2.keys.push(o2);
      }
      for (let s3 = 0; s3 !== n2.keys.length; s3++) {
        const s4 = n2.keys.pop(), o2 = n2[s4];
        e2.push(r2[o2]), t2.push(i2[o2]), delete n2[s4];
      }
    }
    setWorld(e2) {
    }
    static boundingSphereCheck(e2, t2) {
      const n2 = new BI();
      e2.position.vsub(t2.position, n2);
      const r2 = e2.shapes[0], i2 = t2.shapes[0];
      return Math.pow(r2.boundingSphereRadius + i2.boundingSphereRadius, 2) > n2.lengthSquared();
    }
    aabbQuery(e2, t2, n2) {
      return console.warn(".aabbQuery is not implemented in this Broadphase subclass."), [];
    }
  }
  const vR = new BI();
  new BI(), new VI(), new BI();
  const yR = { keys: [] }, bR = [], wR = [];
  new BI(), new BI(), new BI();
  class AR extends gR {
    constructor() {
      super();
    }
    collisionPairs(e2, t2, n2) {
      const r2 = e2.bodies, i2 = r2.length;
      let s2, o2;
      for (let e3 = 0; e3 !== i2; e3++)
        for (let i3 = 0; i3 !== e3; i3++)
          s2 = r2[e3], o2 = r2[i3], this.needBroadphaseCollision(s2, o2) && this.intersectionTest(s2, o2, t2, n2);
    }
    aabbQuery(e2, t2, n2) {
      void 0 === n2 && (n2 = []);
      for (let r2 = 0; r2 < e2.bodies.length; r2++) {
        const i2 = e2.bodies[r2];
        i2.aabbNeedsUpdate && i2.updateAABB(), i2.aabb.overlaps(t2) && n2.push(i2);
      }
      return n2;
    }
  }
  class xR {
    constructor() {
      this.rayFromWorld = new BI(), this.rayToWorld = new BI(), this.hitNormalWorld = new BI(), this.hitPointWorld = new BI(), this.hasHit = false, this.shape = null, this.body = null, this.hitFaceIndex = -1, this.distance = -1, this.shouldStop = false;
    }
    reset() {
      this.rayFromWorld.setZero(), this.rayToWorld.setZero(), this.hitNormalWorld.setZero(), this.hitPointWorld.setZero(), this.hasHit = false, this.shape = null, this.body = null, this.hitFaceIndex = -1, this.distance = -1, this.shouldStop = false;
    }
    abort() {
      this.shouldStop = true;
    }
    set(e2, t2, n2, r2, i2, s2, o2) {
      this.rayFromWorld.copy(e2), this.rayToWorld.copy(t2), this.hitNormalWorld.copy(n2), this.hitPointWorld.copy(r2), this.shape = i2, this.body = s2, this.distance = o2;
    }
  }
  let ER, CR, SR, MR, TR, PR, IR;
  ER = WI.types.SPHERE, CR = WI.types.PLANE, SR = WI.types.BOX, MR = WI.types.CYLINDER, TR = WI.types.CONVEXPOLYHEDRON, PR = WI.types.HEIGHTFIELD, IR = WI.types.TRIMESH;
  class RR {
    get [ER]() {
      return this._intersectSphere;
    }
    get [CR]() {
      return this._intersectPlane;
    }
    get [SR]() {
      return this._intersectBox;
    }
    get [MR]() {
      return this._intersectConvex;
    }
    get [TR]() {
      return this._intersectConvex;
    }
    get [PR]() {
      return this._intersectHeightfield;
    }
    get [IR]() {
      return this._intersectTrimesh;
    }
    constructor(e2, t2) {
      void 0 === e2 && (e2 = new BI()), void 0 === t2 && (t2 = new BI()), this.from = e2.clone(), this.to = t2.clone(), this.direction = new BI(), this.precision = 1e-4, this.checkCollisionResponse = true, this.skipBackfaces = false, this.collisionFilterMask = -1, this.collisionFilterGroup = -1, this.mode = RR.ANY, this.result = new xR(), this.hasHit = false, this.callback = (e3) => {
      };
    }
    intersectWorld(e2, t2) {
      return this.mode = t2.mode || RR.ANY, this.result = t2.result || new xR(), this.skipBackfaces = !!t2.skipBackfaces, this.collisionFilterMask = void 0 !== t2.collisionFilterMask ? t2.collisionFilterMask : -1, this.collisionFilterGroup = void 0 !== t2.collisionFilterGroup ? t2.collisionFilterGroup : -1, this.checkCollisionResponse = void 0 === t2.checkCollisionResponse || t2.checkCollisionResponse, t2.from && this.from.copy(t2.from), t2.to && this.to.copy(t2.to), this.callback = t2.callback || (() => {
      }), this.hasHit = false, this.result.reset(), this.updateDirection(), this.getAABB(kR), DR.length = 0, e2.broadphase.aabbQuery(e2, kR, DR), this.intersectBodies(DR), this.hasHit;
    }
    intersectBody(e2, t2) {
      t2 && (this.result = t2, this.updateDirection());
      const n2 = this.checkCollisionResponse;
      if (n2 && !e2.collisionResponse)
        return;
      if (0 == (this.collisionFilterGroup & e2.collisionFilterMask) || 0 == (e2.collisionFilterGroup & this.collisionFilterMask))
        return;
      const r2 = LR, i2 = UR;
      for (let t3 = 0, s2 = e2.shapes.length; t3 < s2; t3++) {
        const s3 = e2.shapes[t3];
        if ((!n2 || s3.collisionResponse) && (e2.quaternion.mult(e2.shapeOrientations[t3], i2), e2.quaternion.vmult(e2.shapeOffsets[t3], r2), r2.vadd(e2.position, r2), this.intersectShape(s3, i2, r2, e2), this.result.shouldStop))
          break;
      }
    }
    intersectBodies(e2, t2) {
      t2 && (this.result = t2, this.updateDirection());
      for (let t3 = 0, n2 = e2.length; !this.result.shouldStop && t3 < n2; t3++)
        this.intersectBody(e2[t3]);
    }
    updateDirection() {
      this.to.vsub(this.from, this.direction), this.direction.normalize();
    }
    intersectShape(e2, t2, n2, r2) {
      const i2 = function(e3, t3, n3) {
        n3.vsub(e3, ik);
        const r3 = ik.dot(t3);
        t3.scale(r3, sk), sk.vadd(e3, sk);
        return n3.distanceTo(sk);
      }(this.from, this.direction, n2);
      if (i2 > e2.boundingSphereRadius)
        return;
      const s2 = this[e2.type];
      s2 && s2.call(this, e2, t2, n2, r2, e2);
    }
    _intersectBox(e2, t2, n2, r2, i2) {
      return this._intersectConvex(e2.convexPolyhedronRepresentation, t2, n2, r2, i2);
    }
    _intersectPlane(e2, t2, n2, r2, i2) {
      const s2 = this.from, o2 = this.to, a2 = this.direction, l2 = new BI(0, 0, 1);
      t2.vmult(l2, l2);
      const c2 = new BI();
      s2.vsub(n2, c2);
      const u2 = c2.dot(l2);
      if (o2.vsub(n2, c2), u2 * c2.dot(l2) > 0)
        return;
      if (s2.distanceTo(o2) < u2)
        return;
      const p2 = l2.dot(a2);
      if (Math.abs(p2) < this.precision)
        return;
      const d2 = new BI(), h2 = new BI(), f2 = new BI();
      s2.vsub(n2, d2);
      const m2 = -l2.dot(d2) / p2;
      a2.scale(m2, h2), s2.vadd(h2, f2), this.reportIntersection(l2, f2, i2, r2, -1);
    }
    getAABB(e2) {
      const { lowerBound: t2, upperBound: n2 } = e2, r2 = this.to, i2 = this.from;
      t2.x = Math.min(r2.x, i2.x), t2.y = Math.min(r2.y, i2.y), t2.z = Math.min(r2.z, i2.z), n2.x = Math.max(r2.x, i2.x), n2.y = Math.max(r2.y, i2.y), n2.z = Math.max(r2.z, i2.z);
    }
    _intersectHeightfield(e2, t2, n2, r2, i2) {
      e2.data, e2.elementSize;
      const s2 = HR;
      s2.from.copy(this.from), s2.to.copy(this.to), qI.pointToLocalFrame(n2, t2, s2.from, s2.from), qI.pointToLocalFrame(n2, t2, s2.to, s2.to), s2.updateDirection();
      const o2 = QR;
      let a2, l2, c2, u2;
      a2 = l2 = 0, c2 = u2 = e2.data.length - 1;
      const p2 = new FI();
      s2.getAABB(p2), e2.getIndexOfPosition(p2.lowerBound.x, p2.lowerBound.y, o2, true), a2 = Math.max(a2, o2[0]), l2 = Math.max(l2, o2[1]), e2.getIndexOfPosition(p2.upperBound.x, p2.upperBound.y, o2, true), c2 = Math.min(c2, o2[0] + 1), u2 = Math.min(u2, o2[1] + 1);
      for (let o3 = a2; o3 < c2; o3++)
        for (let a3 = l2; a3 < u2; a3++) {
          if (this.result.shouldStop)
            return;
          if (e2.getAabbAtIndex(o3, a3, p2), p2.overlapsRay(s2)) {
            if (e2.getConvexTrianglePillar(o3, a3, false), qI.pointToWorldFrame(n2, t2, e2.pillarOffset, VR), this._intersectConvex(e2.pillarConvex, t2, VR, r2, i2, GR), this.result.shouldStop)
              return;
            e2.getConvexTrianglePillar(o3, a3, true), qI.pointToWorldFrame(n2, t2, e2.pillarOffset, VR), this._intersectConvex(e2.pillarConvex, t2, VR, r2, i2, GR);
          }
        }
    }
    _intersectSphere(e2, t2, n2, r2, i2) {
      const s2 = this.from, o2 = this.to, a2 = e2.radius, l2 = (o2.x - s2.x) ** 2 + (o2.y - s2.y) ** 2 + (o2.z - s2.z) ** 2, c2 = 2 * ((o2.x - s2.x) * (s2.x - n2.x) + (o2.y - s2.y) * (s2.y - n2.y) + (o2.z - s2.z) * (s2.z - n2.z)), u2 = c2 ** 2 - 4 * l2 * ((s2.x - n2.x) ** 2 + (s2.y - n2.y) ** 2 + (s2.z - n2.z) ** 2 - a2 ** 2), p2 = WR, d2 = qR;
      if (!(u2 < 0))
        if (0 === u2)
          s2.lerp(o2, u2, p2), p2.vsub(n2, d2), d2.normalize(), this.reportIntersection(d2, p2, i2, r2, -1);
        else {
          const e3 = (-c2 - Math.sqrt(u2)) / (2 * l2), t3 = (-c2 + Math.sqrt(u2)) / (2 * l2);
          if (e3 >= 0 && e3 <= 1 && (s2.lerp(o2, e3, p2), p2.vsub(n2, d2), d2.normalize(), this.reportIntersection(d2, p2, i2, r2, -1)), this.result.shouldStop)
            return;
          t3 >= 0 && t3 <= 1 && (s2.lerp(o2, t3, p2), p2.vsub(n2, d2), d2.normalize(), this.reportIntersection(d2, p2, i2, r2, -1));
        }
    }
    _intersectConvex(e2, t2, n2, r2, i2, s2) {
      const o2 = XR, a2 = YR, l2 = s2 && s2.faceList || null, c2 = e2.faces, u2 = e2.vertices, p2 = e2.faceNormals, d2 = this.direction, h2 = this.from, f2 = this.to, m2 = h2.distanceTo(f2), _2 = l2 ? l2.length : c2.length, g2 = this.result;
      for (let e3 = 0; !g2.shouldStop && e3 < _2; e3++) {
        const s3 = l2 ? l2[e3] : e3, f3 = c2[s3], _3 = p2[s3], v2 = t2, y2 = n2;
        a2.copy(u2[f3[0]]), v2.vmult(a2, a2), a2.vadd(y2, a2), a2.vsub(h2, a2), v2.vmult(_3, o2);
        const b2 = d2.dot(o2);
        if (Math.abs(b2) < this.precision)
          continue;
        const w2 = o2.dot(a2) / b2;
        if (!(w2 < 0)) {
          d2.scale(w2, FR), FR.vadd(h2, FR), NR.copy(u2[f3[0]]), v2.vmult(NR, NR), y2.vadd(NR, NR);
          for (let e4 = 1; !g2.shouldStop && e4 < f3.length - 1; e4++) {
            jR.copy(u2[f3[e4]]), zR.copy(u2[f3[e4 + 1]]), v2.vmult(jR, jR), v2.vmult(zR, zR), y2.vadd(jR, jR), y2.vadd(zR, zR);
            const t3 = FR.distanceTo(h2);
            !RR.pointInTriangle(FR, NR, jR, zR) && !RR.pointInTriangle(FR, jR, NR, zR) || t3 > m2 || this.reportIntersection(o2, FR, i2, r2, s3);
          }
        }
      }
    }
    _intersectTrimesh(e2, t2, n2, r2, i2, s2) {
      const o2 = KR, a2 = nk, l2 = rk, c2 = YR, u2 = JR, p2 = ZR, d2 = $R, h2 = tk, f2 = ek, m2 = e2.indices;
      e2.vertices;
      const _2 = this.from, g2 = this.to, v2 = this.direction;
      l2.position.copy(n2), l2.quaternion.copy(t2), qI.vectorToLocalFrame(n2, t2, v2, u2), qI.pointToLocalFrame(n2, t2, _2, p2), qI.pointToLocalFrame(n2, t2, g2, d2), d2.x *= e2.scale.x, d2.y *= e2.scale.y, d2.z *= e2.scale.z, p2.x *= e2.scale.x, p2.y *= e2.scale.y, p2.z *= e2.scale.z, d2.vsub(p2, u2), u2.normalize();
      const y2 = p2.distanceSquared(d2);
      e2.tree.rayQuery(this, l2, a2);
      for (let s3 = 0, l3 = a2.length; !this.result.shouldStop && s3 !== l3; s3++) {
        const l4 = a2[s3];
        e2.getNormal(l4, o2), e2.getVertex(m2[3 * l4], NR), NR.vsub(p2, c2);
        const d3 = u2.dot(o2), _3 = o2.dot(c2) / d3;
        if (_3 < 0)
          continue;
        u2.scale(_3, FR), FR.vadd(p2, FR), e2.getVertex(m2[3 * l4 + 1], jR), e2.getVertex(m2[3 * l4 + 2], zR);
        const g3 = FR.distanceSquared(p2);
        !RR.pointInTriangle(FR, jR, NR, zR) && !RR.pointInTriangle(FR, NR, jR, zR) || g3 > y2 || (qI.vectorToWorldFrame(t2, o2, f2), qI.pointToWorldFrame(n2, t2, FR, h2), this.reportIntersection(f2, h2, i2, r2, l4));
      }
      a2.length = 0;
    }
    reportIntersection(e2, t2, n2, r2, i2) {
      const s2 = this.from, o2 = this.to, a2 = s2.distanceTo(t2), l2 = this.result;
      if (!(this.skipBackfaces && e2.dot(this.direction) > 0))
        switch (l2.hitFaceIndex = void 0 !== i2 ? i2 : -1, this.mode) {
          case RR.ALL:
            this.hasHit = true, l2.set(s2, o2, e2, t2, n2, r2, a2), l2.hasHit = true, this.callback(l2);
            break;
          case RR.CLOSEST:
            (a2 < l2.distance || !l2.hasHit) && (this.hasHit = true, l2.hasHit = true, l2.set(s2, o2, e2, t2, n2, r2, a2));
            break;
          case RR.ANY:
            this.hasHit = true, l2.hasHit = true, l2.set(s2, o2, e2, t2, n2, r2, a2), l2.shouldStop = true;
        }
    }
    static pointInTriangle(e2, t2, n2, r2) {
      r2.vsub(t2, ik), n2.vsub(t2, BR), e2.vsub(t2, OR);
      const i2 = ik.dot(ik), s2 = ik.dot(BR), o2 = ik.dot(OR), a2 = BR.dot(BR), l2 = BR.dot(OR);
      let c2, u2;
      return (c2 = a2 * o2 - s2 * l2) >= 0 && (u2 = i2 * l2 - s2 * o2) >= 0 && c2 + u2 < i2 * a2 - s2 * s2;
    }
  }
  RR.CLOSEST = 1, RR.ANY = 2, RR.ALL = 4;
  const kR = new FI(), DR = [], BR = new BI(), OR = new BI(), LR = new BI(), UR = new VI(), FR = new BI(), NR = new BI(), jR = new BI(), zR = new BI();
  new BI(), new xR();
  const GR = { faceList: [0] }, VR = new BI(), HR = new RR(), QR = [], WR = new BI(), qR = new BI(), XR = new BI(), YR = (new BI(), new BI(), new BI()), KR = new BI(), JR = new BI(), ZR = new BI(), $R = new BI(), ek = new BI(), tk = new BI();
  new FI();
  const nk = [], rk = new qI(), ik = new BI(), sk = new BI();
  class ok {
    static defaults(e2, t2) {
      void 0 === e2 && (e2 = {});
      for (let n2 in t2)
        n2 in e2 || (e2[n2] = t2[n2]);
      return e2;
    }
  }
  class ak {
    constructor(e2, t2, n2) {
      void 0 === n2 && (n2 = {}), n2 = ok.defaults(n2, { collideConnected: true, wakeUpBodies: true }), this.equations = [], this.bodyA = e2, this.bodyB = t2, this.id = ak.idCounter++, this.collideConnected = n2.collideConnected, n2.wakeUpBodies && (e2 && e2.wakeUp(), t2 && t2.wakeUp());
    }
    update() {
      throw new Error("method update() not implmemented in this Constraint subclass!");
    }
    enable() {
      const e2 = this.equations;
      for (let t2 = 0; t2 < e2.length; t2++)
        e2[t2].enabled = true;
    }
    disable() {
      const e2 = this.equations;
      for (let t2 = 0; t2 < e2.length; t2++)
        e2[t2].enabled = false;
    }
  }
  ak.idCounter = 0;
  class lk {
    constructor() {
      this.spatial = new BI(), this.rotational = new BI();
    }
    multiplyElement(e2) {
      return e2.spatial.dot(this.spatial) + e2.rotational.dot(this.rotational);
    }
    multiplyVectors(e2, t2) {
      return e2.dot(this.spatial) + t2.dot(this.rotational);
    }
  }
  class ck {
    constructor(e2, t2, n2, r2) {
      void 0 === n2 && (n2 = -1e6), void 0 === r2 && (r2 = 1e6), this.id = ck.idCounter++, this.minForce = n2, this.maxForce = r2, this.bi = e2, this.bj = t2, this.a = 0, this.b = 0, this.eps = 0, this.jacobianElementA = new lk(), this.jacobianElementB = new lk(), this.enabled = true, this.multiplier = 0, this.setSpookParams(1e7, 4, 1 / 60);
    }
    setSpookParams(e2, t2, n2) {
      const r2 = t2, i2 = e2, s2 = n2;
      this.a = 4 / (s2 * (1 + 4 * r2)), this.b = 4 * r2 / (1 + 4 * r2), this.eps = 4 / (s2 * s2 * i2 * (1 + 4 * r2));
    }
    computeB(e2, t2, n2) {
      const r2 = this.computeGW();
      return -this.computeGq() * e2 - r2 * t2 - this.computeGiMf() * n2;
    }
    computeGq() {
      const e2 = this.jacobianElementA, t2 = this.jacobianElementB, n2 = this.bi, r2 = this.bj, i2 = n2.position, s2 = r2.position;
      return e2.spatial.dot(i2) + t2.spatial.dot(s2);
    }
    computeGW() {
      const e2 = this.jacobianElementA, t2 = this.jacobianElementB, n2 = this.bi, r2 = this.bj, i2 = n2.velocity, s2 = r2.velocity, o2 = n2.angularVelocity, a2 = r2.angularVelocity;
      return e2.multiplyVectors(i2, o2) + t2.multiplyVectors(s2, a2);
    }
    computeGWlambda() {
      const e2 = this.jacobianElementA, t2 = this.jacobianElementB, n2 = this.bi, r2 = this.bj, i2 = n2.vlambda, s2 = r2.vlambda, o2 = n2.wlambda, a2 = r2.wlambda;
      return e2.multiplyVectors(i2, o2) + t2.multiplyVectors(s2, a2);
    }
    computeGiMf() {
      const e2 = this.jacobianElementA, t2 = this.jacobianElementB, n2 = this.bi, r2 = this.bj, i2 = n2.force, s2 = n2.torque, o2 = r2.force, a2 = r2.torque, l2 = n2.invMassSolve, c2 = r2.invMassSolve;
      return i2.scale(l2, uk), o2.scale(c2, pk), n2.invInertiaWorldSolve.vmult(s2, dk), r2.invInertiaWorldSolve.vmult(a2, hk), e2.multiplyVectors(uk, dk) + t2.multiplyVectors(pk, hk);
    }
    computeGiMGt() {
      const e2 = this.jacobianElementA, t2 = this.jacobianElementB, n2 = this.bi, r2 = this.bj, i2 = n2.invMassSolve, s2 = r2.invMassSolve, o2 = n2.invInertiaWorldSolve, a2 = r2.invInertiaWorldSolve;
      let l2 = i2 + s2;
      return o2.vmult(e2.rotational, fk), l2 += fk.dot(e2.rotational), a2.vmult(t2.rotational, fk), l2 += fk.dot(t2.rotational), l2;
    }
    addToWlambda(e2) {
      const t2 = this.jacobianElementA, n2 = this.jacobianElementB, r2 = this.bi, i2 = this.bj, s2 = mk;
      r2.vlambda.addScaledVector(r2.invMassSolve * e2, t2.spatial, r2.vlambda), i2.vlambda.addScaledVector(i2.invMassSolve * e2, n2.spatial, i2.vlambda), r2.invInertiaWorldSolve.vmult(t2.rotational, s2), r2.wlambda.addScaledVector(e2, s2, r2.wlambda), i2.invInertiaWorldSolve.vmult(n2.rotational, s2), i2.wlambda.addScaledVector(e2, s2, i2.wlambda);
    }
    computeC() {
      return this.computeGiMGt() + this.eps;
    }
  }
  ck.idCounter = 0;
  const uk = new BI(), pk = new BI(), dk = new BI(), hk = new BI(), fk = new BI(), mk = new BI();
  class _k extends ck {
    constructor(e2, t2, n2) {
      void 0 === n2 && (n2 = 1e6), super(e2, t2, 0, n2), this.restitution = 0, this.ri = new BI(), this.rj = new BI(), this.ni = new BI();
    }
    computeB(e2) {
      const t2 = this.a, n2 = this.b, r2 = this.bi, i2 = this.bj, s2 = this.ri, o2 = this.rj, a2 = gk, l2 = vk, c2 = r2.velocity, u2 = r2.angularVelocity;
      r2.force, r2.torque;
      const p2 = i2.velocity, d2 = i2.angularVelocity;
      i2.force, i2.torque;
      const h2 = yk, f2 = this.jacobianElementA, m2 = this.jacobianElementB, _2 = this.ni;
      s2.cross(_2, a2), o2.cross(_2, l2), _2.negate(f2.spatial), a2.negate(f2.rotational), m2.spatial.copy(_2), m2.rotational.copy(l2), h2.copy(i2.position), h2.vadd(o2, h2), h2.vsub(r2.position, h2), h2.vsub(s2, h2);
      const g2 = _2.dot(h2), v2 = this.restitution + 1;
      return -g2 * t2 - (v2 * p2.dot(_2) - v2 * c2.dot(_2) + d2.dot(l2) - u2.dot(a2)) * n2 - e2 * this.computeGiMf();
    }
    getImpactVelocityAlongNormal() {
      const e2 = bk, t2 = wk, n2 = Ak, r2 = xk, i2 = Ek;
      return this.bi.position.vadd(this.ri, n2), this.bj.position.vadd(this.rj, r2), this.bi.getVelocityAtWorldPoint(n2, e2), this.bj.getVelocityAtWorldPoint(r2, t2), e2.vsub(t2, i2), this.ni.dot(i2);
    }
  }
  const gk = new BI(), vk = new BI(), yk = new BI(), bk = new BI(), wk = new BI(), Ak = new BI(), xk = new BI(), Ek = new BI();
  class Ck extends ak {
    constructor(e2, t2, n2, r2, i2) {
      void 0 === t2 && (t2 = new BI()), void 0 === r2 && (r2 = new BI()), void 0 === i2 && (i2 = 1e6), super(e2, n2), this.pivotA = t2.clone(), this.pivotB = r2.clone();
      const s2 = this.equationX = new _k(e2, n2), o2 = this.equationY = new _k(e2, n2), a2 = this.equationZ = new _k(e2, n2);
      this.equations.push(s2, o2, a2), s2.minForce = o2.minForce = a2.minForce = -i2, s2.maxForce = o2.maxForce = a2.maxForce = i2, s2.ni.set(1, 0, 0), o2.ni.set(0, 1, 0), a2.ni.set(0, 0, 1);
    }
    update() {
      const e2 = this.bodyA, t2 = this.bodyB, n2 = this.equationX, r2 = this.equationY, i2 = this.equationZ;
      e2.quaternion.vmult(this.pivotA, n2.ri), t2.quaternion.vmult(this.pivotB, n2.rj), r2.ri.copy(n2.ri), r2.rj.copy(n2.rj), i2.ri.copy(n2.ri), i2.rj.copy(n2.rj);
    }
  }
  new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new BI();
  class Sk extends ck {
    constructor(e2, t2, n2) {
      super(e2, t2, -n2, n2), this.ri = new BI(), this.rj = new BI(), this.t = new BI();
    }
    computeB(e2) {
      this.a;
      const t2 = this.b;
      this.bi, this.bj;
      const n2 = this.ri, r2 = this.rj, i2 = Mk, s2 = Tk, o2 = this.t;
      n2.cross(o2, i2), r2.cross(o2, s2);
      const a2 = this.jacobianElementA, l2 = this.jacobianElementB;
      return o2.negate(a2.spatial), i2.negate(a2.rotational), l2.spatial.copy(o2), l2.rotational.copy(s2), -this.computeGW() * t2 - e2 * this.computeGiMf();
    }
  }
  const Mk = new BI(), Tk = new BI();
  class Pk {
    constructor(e2, t2, n2) {
      n2 = ok.defaults(n2, { friction: 0.3, restitution: 0.3, contactEquationStiffness: 1e7, contactEquationRelaxation: 3, frictionEquationStiffness: 1e7, frictionEquationRelaxation: 3 }), this.id = Pk.idCounter++, this.materials = [e2, t2], this.friction = n2.friction, this.restitution = n2.restitution, this.contactEquationStiffness = n2.contactEquationStiffness, this.contactEquationRelaxation = n2.contactEquationRelaxation, this.frictionEquationStiffness = n2.frictionEquationStiffness, this.frictionEquationRelaxation = n2.frictionEquationRelaxation;
    }
  }
  Pk.idCounter = 0;
  class Ik {
    constructor(e2) {
      void 0 === e2 && (e2 = {});
      let t2 = "";
      "string" == typeof e2 && (t2 = e2, e2 = {}), this.name = t2, this.id = Ik.idCounter++, this.friction = void 0 !== e2.friction ? e2.friction : -1, this.restitution = void 0 !== e2.restitution ? e2.restitution : -1;
    }
  }
  Ik.idCounter = 0, new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new RR(), new BI(), new BI(), new BI(), new BI(1, 0, 0), new BI(0, 1, 0), new BI(0, 0, 1), new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new BI();
  class Rk extends WI {
    constructor(e2) {
      if (super({ type: WI.types.SPHERE }), this.radius = void 0 !== e2 ? e2 : 1, this.radius < 0)
        throw new Error("The sphere radius cannot be negative.");
      this.updateBoundingSphereRadius();
    }
    calculateLocalInertia(e2, t2) {
      void 0 === t2 && (t2 = new BI());
      const n2 = 2 * e2 * this.radius * this.radius / 5;
      return t2.x = n2, t2.y = n2, t2.z = n2, t2;
    }
    volume() {
      return 4 * Math.PI * Math.pow(this.radius, 3) / 3;
    }
    updateBoundingSphereRadius() {
      this.boundingSphereRadius = this.radius;
    }
    calculateWorldAABB(e2, t2, n2, r2) {
      const i2 = this.radius, s2 = ["x", "y", "z"];
      for (let t3 = 0; t3 < s2.length; t3++) {
        const o2 = s2[t3];
        n2[o2] = e2[o2] - i2, r2[o2] = e2[o2] + i2;
      }
    }
  }
  new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new BI();
  class kk extends YI {
    constructor(e2, t2, n2, r2) {
      if (void 0 === e2 && (e2 = 1), void 0 === t2 && (t2 = 1), void 0 === n2 && (n2 = 1), void 0 === r2 && (r2 = 8), e2 < 0)
        throw new Error("The cylinder radiusTop cannot be negative.");
      if (t2 < 0)
        throw new Error("The cylinder radiusBottom cannot be negative.");
      const i2 = r2, s2 = [], o2 = [], a2 = [], l2 = [], c2 = [], u2 = Math.cos, p2 = Math.sin;
      s2.push(new BI(-t2 * p2(0), 0.5 * -n2, t2 * u2(0))), l2.push(0), s2.push(new BI(-e2 * p2(0), 0.5 * n2, e2 * u2(0))), c2.push(1);
      for (let r3 = 0; r3 < i2; r3++) {
        const d3 = 2 * Math.PI / i2 * (r3 + 1), h2 = 2 * Math.PI / i2 * (r3 + 0.5);
        r3 < i2 - 1 ? (s2.push(new BI(-t2 * p2(d3), 0.5 * -n2, t2 * u2(d3))), l2.push(2 * r3 + 2), s2.push(new BI(-e2 * p2(d3), 0.5 * n2, e2 * u2(d3))), c2.push(2 * r3 + 3), a2.push([2 * r3, 2 * r3 + 1, 2 * r3 + 3, 2 * r3 + 2])) : a2.push([2 * r3, 2 * r3 + 1, 1, 0]), (i2 % 2 == 1 || r3 < i2 / 2) && o2.push(new BI(-p2(h2), 0, u2(h2)));
      }
      a2.push(l2), o2.push(new BI(0, 1, 0));
      const d2 = [];
      for (let e3 = 0; e3 < c2.length; e3++)
        d2.push(c2[c2.length - e3 - 1]);
      a2.push(d2), super({ vertices: s2, faces: a2, axes: o2 }), this.type = WI.types.CYLINDER, this.radiusTop = e2, this.radiusBottom = t2, this.height = n2, this.numSegments = r2;
    }
  }
  class Dk extends WI {
    constructor() {
      super({ type: WI.types.PLANE }), this.worldNormal = new BI(), this.worldNormalNeedsUpdate = true, this.boundingSphereRadius = Number.MAX_VALUE;
    }
    computeWorldNormal(e2) {
      const t2 = this.worldNormal;
      t2.set(0, 0, 1), e2.vmult(t2, t2), this.worldNormalNeedsUpdate = false;
    }
    calculateLocalInertia(e2, t2) {
      return void 0 === t2 && (t2 = new BI()), t2;
    }
    volume() {
      return Number.MAX_VALUE;
    }
    calculateWorldAABB(e2, t2, n2, r2) {
      Bk.set(0, 0, 1), t2.vmult(Bk, Bk);
      const i2 = Number.MAX_VALUE;
      n2.set(-i2, -i2, -i2), r2.set(i2, i2, i2), 1 === Bk.x ? r2.x = e2.x : -1 === Bk.x && (n2.x = e2.x), 1 === Bk.y ? r2.y = e2.y : -1 === Bk.y && (n2.y = e2.y), 1 === Bk.z ? r2.z = e2.z : -1 === Bk.z && (n2.z = e2.z);
    }
    updateBoundingSphereRadius() {
      this.boundingSphereRadius = Number.MAX_VALUE;
    }
  }
  const Bk = new BI();
  new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new BI(), new BI();
  class Ok {
    constructor(e2) {
      void 0 === e2 && (e2 = {}), this.root = e2.root || null, this.aabb = e2.aabb ? e2.aabb.clone() : new FI(), this.data = [], this.children = [];
    }
    reset() {
      this.children.length = this.data.length = 0;
    }
    insert(e2, t2, n2) {
      void 0 === n2 && (n2 = 0);
      const r2 = this.data;
      if (!this.aabb.contains(e2))
        return false;
      const i2 = this.children;
      if (n2 < (this.maxDepth || this.root.maxDepth)) {
        let r3 = false;
        i2.length || (this.subdivide(), r3 = true);
        for (let r4 = 0; 8 !== r4; r4++)
          if (i2[r4].insert(e2, t2, n2 + 1))
            return true;
        r3 && (i2.length = 0);
      }
      return r2.push(t2), true;
    }
    subdivide() {
      const e2 = this.aabb, t2 = e2.lowerBound, n2 = e2.upperBound, r2 = this.children;
      r2.push(new Ok({ aabb: new FI({ lowerBound: new BI(0, 0, 0) }) }), new Ok({ aabb: new FI({ lowerBound: new BI(1, 0, 0) }) }), new Ok({ aabb: new FI({ lowerBound: new BI(1, 1, 0) }) }), new Ok({ aabb: new FI({ lowerBound: new BI(1, 1, 1) }) }), new Ok({ aabb: new FI({ lowerBound: new BI(0, 1, 1) }) }), new Ok({ aabb: new FI({ lowerBound: new BI(0, 0, 1) }) }), new Ok({ aabb: new FI({ lowerBound: new BI(1, 0, 1) }) }), new Ok({ aabb: new FI({ lowerBound: new BI(0, 1, 0) }) })), n2.vsub(t2, Uk), Uk.scale(0.5, Uk);
      const i2 = this.root || this;
      for (let e3 = 0; 8 !== e3; e3++) {
        const n3 = r2[e3];
        n3.root = i2;
        const s2 = n3.aabb.lowerBound;
        s2.x *= Uk.x, s2.y *= Uk.y, s2.z *= Uk.z, s2.vadd(t2, s2), s2.vadd(Uk, n3.aabb.upperBound);
      }
    }
    aabbQuery(e2, t2) {
      this.data, this.children;
      const n2 = [this];
      for (; n2.length; ) {
        const r2 = n2.pop();
        r2.aabb.overlaps(e2) && Array.prototype.push.apply(t2, r2.data), Array.prototype.push.apply(n2, r2.children);
      }
      return t2;
    }
    rayQuery(e2, t2, n2) {
      return e2.getAABB(Fk), Fk.toLocalFrame(t2, Fk), this.aabbQuery(Fk, n2), n2;
    }
    removeEmptyNodes() {
      for (let e2 = this.children.length - 1; e2 >= 0; e2--)
        this.children[e2].removeEmptyNodes(), this.children[e2].children.length || this.children[e2].data.length || this.children.splice(e2, 1);
    }
  }
  class Lk extends Ok {
    constructor(e2, t2) {
      void 0 === t2 && (t2 = {}), super({ root: null, aabb: e2 }), this.maxDepth = void 0 !== t2.maxDepth ? t2.maxDepth : 8;
    }
  }
  const Uk = new BI(), Fk = new FI();
  class Nk extends WI {
    constructor(e2, t2) {
      super({ type: WI.types.TRIMESH }), this.vertices = new Float32Array(e2), this.indices = new Int16Array(t2), this.normals = new Float32Array(t2.length), this.aabb = new FI(), this.edges = null, this.scale = new BI(1, 1, 1), this.tree = new Lk(), this.updateEdges(), this.updateNormals(), this.updateAABB(), this.updateBoundingSphereRadius(), this.updateTree();
    }
    updateTree() {
      const e2 = this.tree;
      e2.reset(), e2.aabb.copy(this.aabb);
      const t2 = this.scale;
      e2.aabb.lowerBound.x *= 1 / t2.x, e2.aabb.lowerBound.y *= 1 / t2.y, e2.aabb.lowerBound.z *= 1 / t2.z, e2.aabb.upperBound.x *= 1 / t2.x, e2.aabb.upperBound.y *= 1 / t2.y, e2.aabb.upperBound.z *= 1 / t2.z;
      const n2 = new FI(), r2 = new BI(), i2 = new BI(), s2 = new BI(), o2 = [r2, i2, s2];
      for (let t3 = 0; t3 < this.indices.length / 3; t3++) {
        const a2 = 3 * t3;
        this._getUnscaledVertex(this.indices[a2], r2), this._getUnscaledVertex(this.indices[a2 + 1], i2), this._getUnscaledVertex(this.indices[a2 + 2], s2), n2.setFromPoints(o2), e2.insert(n2, t3);
      }
      e2.removeEmptyNodes();
    }
    getTrianglesInAABB(e2, t2) {
      zk.copy(e2);
      const n2 = this.scale, r2 = n2.x, i2 = n2.y, s2 = n2.z, o2 = zk.lowerBound, a2 = zk.upperBound;
      return o2.x /= r2, o2.y /= i2, o2.z /= s2, a2.x /= r2, a2.y /= i2, a2.z /= s2, this.tree.aabbQuery(zk, t2);
    }
    setScale(e2) {
      const t2 = this.scale.x === this.scale.y && this.scale.y === this.scale.z, n2 = e2.x === e2.y && e2.y === e2.z;
      t2 && n2 || this.updateNormals(), this.scale.copy(e2), this.updateAABB(), this.updateBoundingSphereRadius();
    }
    updateNormals() {
      const e2 = jk, t2 = this.normals;
      for (let n2 = 0; n2 < this.indices.length / 3; n2++) {
        const r2 = 3 * n2, i2 = this.indices[r2], s2 = this.indices[r2 + 1], o2 = this.indices[r2 + 2];
        this.getVertex(i2, Wk), this.getVertex(s2, qk), this.getVertex(o2, Xk), Nk.computeNormal(qk, Wk, Xk, e2), t2[r2] = e2.x, t2[r2 + 1] = e2.y, t2[r2 + 2] = e2.z;
      }
    }
    updateEdges() {
      const e2 = {}, t2 = (t3, n3) => {
        e2[t3 < n3 ? `${t3}_${n3}` : `${n3}_${t3}`] = true;
      };
      for (let e3 = 0; e3 < this.indices.length / 3; e3++) {
        const n3 = 3 * e3, r2 = this.indices[n3], i2 = this.indices[n3 + 1], s2 = this.indices[n3 + 2];
        t2(r2, i2), t2(i2, s2), t2(s2, r2);
      }
      const n2 = Object.keys(e2);
      this.edges = new Int16Array(2 * n2.length);
      for (let e3 = 0; e3 < n2.length; e3++) {
        const t3 = n2[e3].split("_");
        this.edges[2 * e3] = parseInt(t3[0], 10), this.edges[2 * e3 + 1] = parseInt(t3[1], 10);
      }
    }
    getEdgeVertex(e2, t2, n2) {
      const r2 = this.edges[2 * e2 + (t2 ? 1 : 0)];
      this.getVertex(r2, n2);
    }
    getEdgeVector(e2, t2) {
      const n2 = Gk, r2 = Vk;
      this.getEdgeVertex(e2, 0, n2), this.getEdgeVertex(e2, 1, r2), r2.vsub(n2, t2);
    }
    static computeNormal(e2, t2, n2, r2) {
      t2.vsub(e2, Qk), n2.vsub(t2, Hk), Hk.cross(Qk, r2), r2.isZero() || r2.normalize();
    }
    getVertex(e2, t2) {
      const n2 = this.scale;
      return this._getUnscaledVertex(e2, t2), t2.x *= n2.x, t2.y *= n2.y, t2.z *= n2.z, t2;
    }
    _getUnscaledVertex(e2, t2) {
      const n2 = 3 * e2, r2 = this.vertices;
      return t2.set(r2[n2], r2[n2 + 1], r2[n2 + 2]);
    }
    getWorldVertex(e2, t2, n2, r2) {
      return this.getVertex(e2, r2), qI.pointToWorldFrame(t2, n2, r2, r2), r2;
    }
    getTriangleVertices(e2, t2, n2, r2) {
      const i2 = 3 * e2;
      this.getVertex(this.indices[i2], t2), this.getVertex(this.indices[i2 + 1], n2), this.getVertex(this.indices[i2 + 2], r2);
    }
    getNormal(e2, t2) {
      const n2 = 3 * e2;
      return t2.set(this.normals[n2], this.normals[n2 + 1], this.normals[n2 + 2]);
    }
    calculateLocalInertia(e2, t2) {
      this.computeLocalAABB(Yk);
      const n2 = Yk.upperBound.x - Yk.lowerBound.x, r2 = Yk.upperBound.y - Yk.lowerBound.y, i2 = Yk.upperBound.z - Yk.lowerBound.z;
      return t2.set(1 / 12 * e2 * (2 * r2 * 2 * r2 + 2 * i2 * 2 * i2), 1 / 12 * e2 * (2 * n2 * 2 * n2 + 2 * i2 * 2 * i2), 1 / 12 * e2 * (2 * r2 * 2 * r2 + 2 * n2 * 2 * n2));
    }
    computeLocalAABB(e2) {
      const t2 = e2.lowerBound, n2 = e2.upperBound, r2 = this.vertices.length;
      this.vertices;
      const i2 = Kk;
      this.getVertex(0, i2), t2.copy(i2), n2.copy(i2);
      for (let e3 = 0; e3 !== r2; e3++)
        this.getVertex(e3, i2), i2.x < t2.x ? t2.x = i2.x : i2.x > n2.x && (n2.x = i2.x), i2.y < t2.y ? t2.y = i2.y : i2.y > n2.y && (n2.y = i2.y), i2.z < t2.z ? t2.z = i2.z : i2.z > n2.z && (n2.z = i2.z);
    }
    updateAABB() {
      this.computeLocalAABB(this.aabb);
    }
    updateBoundingSphereRadius() {
      let e2 = 0;
      const t2 = this.vertices, n2 = new BI();
      for (let r2 = 0, i2 = t2.length / 3; r2 !== i2; r2++) {
        this.getVertex(r2, n2);
        const t3 = n2.lengthSquared();
        t3 > e2 && (e2 = t3);
      }
      this.boundingSphereRadius = Math.sqrt(e2);
    }
    calculateWorldAABB(e2, t2, n2, r2) {
      const i2 = Jk, s2 = Zk;
      i2.position = e2, i2.quaternion = t2, this.aabb.toWorldFrame(i2, s2), n2.copy(s2.lowerBound), r2.copy(s2.upperBound);
    }
    volume() {
      return 4 * Math.PI * this.boundingSphereRadius / 3;
    }
    static createTorus(e2, t2, n2, r2, i2) {
      void 0 === e2 && (e2 = 1), void 0 === t2 && (t2 = 0.5), void 0 === n2 && (n2 = 8), void 0 === r2 && (r2 = 6), void 0 === i2 && (i2 = 2 * Math.PI);
      const s2 = [], o2 = [];
      for (let o3 = 0; o3 <= n2; o3++)
        for (let a2 = 0; a2 <= r2; a2++) {
          const l2 = a2 / r2 * i2, c2 = o3 / n2 * Math.PI * 2, u2 = (e2 + t2 * Math.cos(c2)) * Math.cos(l2), p2 = (e2 + t2 * Math.cos(c2)) * Math.sin(l2), d2 = t2 * Math.sin(c2);
          s2.push(u2, p2, d2);
        }
      for (let e3 = 1; e3 <= n2; e3++)
        for (let t3 = 1; t3 <= r2; t3++) {
          const n3 = (r2 + 1) * e3 + t3 - 1, i3 = (r2 + 1) * (e3 - 1) + t3 - 1, s3 = (r2 + 1) * (e3 - 1) + t3, a2 = (r2 + 1) * e3 + t3;
          o2.push(n3, i3, a2), o2.push(i3, s3, a2);
        }
      return new Nk(s2, o2);
    }
  }
  const jk = new BI(), zk = new FI(), Gk = new BI(), Vk = new BI(), Hk = new BI(), Qk = new BI(), Wk = new BI(), qk = new BI(), Xk = new BI(), Yk = new FI(), Kk = new BI(), Jk = new qI(), Zk = new FI();
  class $k {
    constructor() {
      this.equations = [];
    }
    solve(e2, t2) {
      return 0;
    }
    addEquation(e2) {
      !e2.enabled || e2.bi.isTrigger || e2.bj.isTrigger || this.equations.push(e2);
    }
    removeEquation(e2) {
      const t2 = this.equations, n2 = t2.indexOf(e2);
      -1 !== n2 && t2.splice(n2, 1);
    }
    removeAllEquations() {
      this.equations.length = 0;
    }
  }
  class eD extends $k {
    constructor() {
      super(), this.iterations = 10, this.tolerance = 1e-7;
    }
    solve(e2, t2) {
      let n2 = 0;
      const r2 = this.iterations, i2 = this.tolerance * this.tolerance, s2 = this.equations, o2 = s2.length, a2 = t2.bodies, l2 = a2.length, c2 = e2;
      let u2, p2, d2, h2, f2, m2;
      if (0 !== o2)
        for (let e3 = 0; e3 !== l2; e3++)
          a2[e3].updateSolveMassProperties();
      const _2 = nD, g2 = rD, v2 = tD;
      _2.length = o2, g2.length = o2, v2.length = o2;
      for (let e3 = 0; e3 !== o2; e3++) {
        const t3 = s2[e3];
        v2[e3] = 0, g2[e3] = t3.computeB(c2), _2[e3] = 1 / t3.computeC();
      }
      if (0 !== o2) {
        for (let e4 = 0; e4 !== l2; e4++) {
          const t4 = a2[e4], n3 = t4.vlambda, r3 = t4.wlambda;
          n3.set(0, 0, 0), r3.set(0, 0, 0);
        }
        for (n2 = 0; n2 !== r2; n2++) {
          h2 = 0;
          for (let e4 = 0; e4 !== o2; e4++) {
            const t4 = s2[e4];
            u2 = g2[e4], p2 = _2[e4], m2 = v2[e4], f2 = t4.computeGWlambda(), d2 = p2 * (u2 - f2 - t4.eps * m2), m2 + d2 < t4.minForce ? d2 = t4.minForce - m2 : m2 + d2 > t4.maxForce && (d2 = t4.maxForce - m2), v2[e4] += d2, h2 += d2 > 0 ? d2 : -d2, t4.addToWlambda(d2);
          }
          if (h2 * h2 < i2)
            break;
        }
        for (let e4 = 0; e4 !== l2; e4++) {
          const t4 = a2[e4], n3 = t4.velocity, r3 = t4.angularVelocity;
          t4.vlambda.vmul(t4.linearFactor, t4.vlambda), n3.vadd(t4.vlambda, n3), t4.wlambda.vmul(t4.angularFactor, t4.wlambda), r3.vadd(t4.wlambda, r3);
        }
        let e3 = s2.length;
        const t3 = 1 / c2;
        for (; e3--; )
          s2[e3].multiplier = v2[e3] * t3;
      }
      return n2;
    }
  }
  const tD = [], nD = [], rD = [];
  rR.STATIC;
  class iD {
    constructor() {
      this.objects = [], this.type = Object;
    }
    release() {
      const e2 = arguments.length;
      for (let t2 = 0; t2 !== e2; t2++)
        this.objects.push(t2 < 0 || arguments.length <= t2 ? void 0 : arguments[t2]);
      return this;
    }
    get() {
      return 0 === this.objects.length ? this.constructObject() : this.objects.pop();
    }
    constructObject() {
      throw new Error("constructObject() not implemented in this Pool subclass yet!");
    }
    resize(e2) {
      const t2 = this.objects;
      for (; t2.length > e2; )
        t2.pop();
      for (; t2.length < e2; )
        t2.push(this.constructObject());
      return this;
    }
  }
  class sD extends iD {
    constructor() {
      super(...arguments), this.type = BI;
    }
    constructObject() {
      return new BI();
    }
  }
  const oD = WI.types.SPHERE, aD = WI.types.SPHERE | WI.types.PLANE, lD = WI.types.BOX | WI.types.BOX, cD = WI.types.SPHERE | WI.types.BOX, uD = WI.types.PLANE | WI.types.BOX, pD = WI.types.CONVEXPOLYHEDRON, dD = WI.types.SPHERE | WI.types.CONVEXPOLYHEDRON, hD = WI.types.PLANE | WI.types.CONVEXPOLYHEDRON, fD = WI.types.BOX | WI.types.CONVEXPOLYHEDRON, mD = WI.types.SPHERE | WI.types.HEIGHTFIELD, _D = WI.types.BOX | WI.types.HEIGHTFIELD, gD = WI.types.CONVEXPOLYHEDRON | WI.types.HEIGHTFIELD, vD = WI.types.PARTICLE | WI.types.SPHERE, yD = WI.types.PLANE | WI.types.PARTICLE, bD = WI.types.BOX | WI.types.PARTICLE, wD = WI.types.PARTICLE | WI.types.CONVEXPOLYHEDRON, AD = WI.types.CYLINDER, xD = WI.types.SPHERE | WI.types.CYLINDER, ED = WI.types.PLANE | WI.types.CYLINDER, CD = WI.types.BOX | WI.types.CYLINDER, SD = WI.types.CONVEXPOLYHEDRON | WI.types.CYLINDER, MD = WI.types.HEIGHTFIELD | WI.types.CYLINDER, TD = WI.types.PARTICLE | WI.types.CYLINDER, PD = WI.types.SPHERE | WI.types.TRIMESH, ID = WI.types.PLANE | WI.types.TRIMESH;
  class RD {
    get [oD]() {
      return this.sphereSphere;
    }
    get [aD]() {
      return this.spherePlane;
    }
    get [lD]() {
      return this.boxBox;
    }
    get [cD]() {
      return this.sphereBox;
    }
    get [uD]() {
      return this.planeBox;
    }
    get [pD]() {
      return this.convexConvex;
    }
    get [dD]() {
      return this.sphereConvex;
    }
    get [hD]() {
      return this.planeConvex;
    }
    get [fD]() {
      return this.boxConvex;
    }
    get [mD]() {
      return this.sphereHeightfield;
    }
    get [_D]() {
      return this.boxHeightfield;
    }
    get [gD]() {
      return this.convexHeightfield;
    }
    get [vD]() {
      return this.sphereParticle;
    }
    get [yD]() {
      return this.planeParticle;
    }
    get [bD]() {
      return this.boxParticle;
    }
    get [wD]() {
      return this.convexParticle;
    }
    get [AD]() {
      return this.convexConvex;
    }
    get [xD]() {
      return this.sphereConvex;
    }
    get [ED]() {
      return this.planeConvex;
    }
    get [CD]() {
      return this.boxConvex;
    }
    get [SD]() {
      return this.convexConvex;
    }
    get [MD]() {
      return this.heightfieldCylinder;
    }
    get [TD]() {
      return this.particleCylinder;
    }
    get [PD]() {
      return this.sphereTrimesh;
    }
    get [ID]() {
      return this.planeTrimesh;
    }
    constructor(e2) {
      this.contactPointPool = [], this.frictionEquationPool = [], this.result = [], this.frictionResult = [], this.v3pool = new sD(), this.world = e2, this.currentContactMaterial = e2.defaultContactMaterial, this.enableFrictionReduction = false;
    }
    createContactEquation(e2, t2, n2, r2, i2, s2) {
      let o2;
      this.contactPointPool.length ? (o2 = this.contactPointPool.pop(), o2.bi = e2, o2.bj = t2) : o2 = new _k(e2, t2), o2.enabled = e2.collisionResponse && t2.collisionResponse && n2.collisionResponse && r2.collisionResponse;
      const a2 = this.currentContactMaterial;
      o2.restitution = a2.restitution, o2.setSpookParams(a2.contactEquationStiffness, a2.contactEquationRelaxation, this.world.dt);
      const l2 = n2.material || e2.material, c2 = r2.material || t2.material;
      return l2 && c2 && l2.restitution >= 0 && c2.restitution >= 0 && (o2.restitution = l2.restitution * c2.restitution), o2.si = i2 || n2, o2.sj = s2 || r2, o2;
    }
    createFrictionEquationsFromContact(e2, t2) {
      const n2 = e2.bi, r2 = e2.bj, i2 = e2.si, s2 = e2.sj, o2 = this.world, a2 = this.currentContactMaterial;
      let l2 = a2.friction;
      const c2 = i2.material || n2.material, u2 = s2.material || r2.material;
      if (c2 && u2 && c2.friction >= 0 && u2.friction >= 0 && (l2 = c2.friction * u2.friction), l2 > 0) {
        const i3 = l2 * o2.gravity.length();
        let s3 = n2.invMass + r2.invMass;
        s3 > 0 && (s3 = 1 / s3);
        const c3 = this.frictionEquationPool, u3 = c3.length ? c3.pop() : new Sk(n2, r2, i3 * s3), p2 = c3.length ? c3.pop() : new Sk(n2, r2, i3 * s3);
        return u3.bi = p2.bi = n2, u3.bj = p2.bj = r2, u3.minForce = p2.minForce = -i3 * s3, u3.maxForce = p2.maxForce = i3 * s3, u3.ri.copy(e2.ri), u3.rj.copy(e2.rj), p2.ri.copy(e2.ri), p2.rj.copy(e2.rj), e2.ni.tangents(u3.t, p2.t), u3.setSpookParams(a2.frictionEquationStiffness, a2.frictionEquationRelaxation, o2.dt), p2.setSpookParams(a2.frictionEquationStiffness, a2.frictionEquationRelaxation, o2.dt), u3.enabled = p2.enabled = e2.enabled, t2.push(u3, p2), true;
      }
      return false;
    }
    createFrictionFromAverage(e2) {
      let t2 = this.result[this.result.length - 1];
      if (!this.createFrictionEquationsFromContact(t2, this.frictionResult) || 1 === e2)
        return;
      const n2 = this.frictionResult[this.frictionResult.length - 2], r2 = this.frictionResult[this.frictionResult.length - 1];
      kD.setZero(), DD.setZero(), BD.setZero();
      const i2 = t2.bi;
      t2.bj;
      for (let n3 = 0; n3 !== e2; n3++)
        t2 = this.result[this.result.length - 1 - n3], t2.bi !== i2 ? (kD.vadd(t2.ni, kD), DD.vadd(t2.ri, DD), BD.vadd(t2.rj, BD)) : (kD.vsub(t2.ni, kD), DD.vadd(t2.rj, DD), BD.vadd(t2.ri, BD));
      const s2 = 1 / e2;
      DD.scale(s2, n2.ri), BD.scale(s2, n2.rj), r2.ri.copy(n2.ri), r2.rj.copy(n2.rj), kD.normalize(), kD.tangents(n2.t, r2.t);
    }
    getContacts(e2, t2, n2, r2, i2, s2, o2) {
      this.contactPointPool = i2, this.frictionEquationPool = o2, this.result = r2, this.frictionResult = s2;
      const a2 = UD, l2 = FD, c2 = OD, u2 = LD;
      for (let r3 = 0, i3 = e2.length; r3 !== i3; r3++) {
        const i4 = e2[r3], s3 = t2[r3];
        let o3 = null;
        i4.material && s3.material && (o3 = n2.getContactMaterial(i4.material, s3.material) || null);
        const p2 = i4.type & rR.KINEMATIC && s3.type & rR.STATIC || i4.type & rR.STATIC && s3.type & rR.KINEMATIC || i4.type & rR.KINEMATIC && s3.type & rR.KINEMATIC;
        for (let e3 = 0; e3 < i4.shapes.length; e3++) {
          i4.quaternion.mult(i4.shapeOrientations[e3], a2), i4.quaternion.vmult(i4.shapeOffsets[e3], c2), c2.vadd(i4.position, c2);
          const t3 = i4.shapes[e3];
          for (let e4 = 0; e4 < s3.shapes.length; e4++) {
            s3.quaternion.mult(s3.shapeOrientations[e4], l2), s3.quaternion.vmult(s3.shapeOffsets[e4], u2), u2.vadd(s3.position, u2);
            const r4 = s3.shapes[e4];
            if (!(t3.collisionFilterMask & r4.collisionFilterGroup && r4.collisionFilterMask & t3.collisionFilterGroup))
              continue;
            if (c2.distanceTo(u2) > t3.boundingSphereRadius + r4.boundingSphereRadius)
              continue;
            let d2 = null;
            t3.material && r4.material && (d2 = n2.getContactMaterial(t3.material, r4.material) || null), this.currentContactMaterial = d2 || o3 || n2.defaultContactMaterial;
            const h2 = this[t3.type | r4.type];
            if (h2) {
              let e5 = false;
              e5 = t3.type < r4.type ? h2.call(this, t3, r4, c2, u2, a2, l2, i4, s3, t3, r4, p2) : h2.call(this, r4, t3, u2, c2, l2, a2, s3, i4, t3, r4, p2), e5 && p2 && (n2.shapeOverlapKeeper.set(t3.id, r4.id), n2.bodyOverlapKeeper.set(i4.id, s3.id));
            }
          }
        }
      }
    }
    sphereSphere(e2, t2, n2, r2, i2, s2, o2, a2, l2, c2, u2) {
      if (u2)
        return n2.distanceSquared(r2) < (e2.radius + t2.radius) ** 2;
      const p2 = this.createContactEquation(o2, a2, e2, t2, l2, c2);
      r2.vsub(n2, p2.ni), p2.ni.normalize(), p2.ri.copy(p2.ni), p2.rj.copy(p2.ni), p2.ri.scale(e2.radius, p2.ri), p2.rj.scale(-t2.radius, p2.rj), p2.ri.vadd(n2, p2.ri), p2.ri.vsub(o2.position, p2.ri), p2.rj.vadd(r2, p2.rj), p2.rj.vsub(a2.position, p2.rj), this.result.push(p2), this.createFrictionEquationsFromContact(p2, this.frictionResult);
    }
    spherePlane(e2, t2, n2, r2, i2, s2, o2, a2, l2, c2, u2) {
      const p2 = this.createContactEquation(o2, a2, e2, t2, l2, c2);
      if (p2.ni.set(0, 0, 1), s2.vmult(p2.ni, p2.ni), p2.ni.negate(p2.ni), p2.ni.normalize(), p2.ni.scale(e2.radius, p2.ri), n2.vsub(r2, rB), p2.ni.scale(p2.ni.dot(rB), iB), rB.vsub(iB, p2.rj), -rB.dot(p2.ni) <= e2.radius) {
        if (u2)
          return true;
        const e3 = p2.ri, t3 = p2.rj;
        e3.vadd(n2, e3), e3.vsub(o2.position, e3), t3.vadd(r2, t3), t3.vsub(a2.position, t3), this.result.push(p2), this.createFrictionEquationsFromContact(p2, this.frictionResult);
      }
    }
    boxBox(e2, t2, n2, r2, i2, s2, o2, a2, l2, c2, u2) {
      return e2.convexPolyhedronRepresentation.material = e2.material, t2.convexPolyhedronRepresentation.material = t2.material, e2.convexPolyhedronRepresentation.collisionResponse = e2.collisionResponse, t2.convexPolyhedronRepresentation.collisionResponse = t2.collisionResponse, this.convexConvex(e2.convexPolyhedronRepresentation, t2.convexPolyhedronRepresentation, n2, r2, i2, s2, o2, a2, e2, t2, u2);
    }
    sphereBox(e2, t2, n2, r2, i2, s2, o2, a2, l2, c2, u2) {
      const p2 = this.v3pool, d2 = hB;
      n2.vsub(r2, cB), t2.getSideNormals(d2, s2);
      const h2 = e2.radius;
      let f2 = false;
      const m2 = mB, _2 = _B, g2 = gB;
      let v2 = null, y2 = 0, b2 = 0, w2 = 0, A2 = null;
      for (let e3 = 0, t3 = d2.length; e3 !== t3 && false === f2; e3++) {
        const t4 = uB;
        t4.copy(d2[e3]);
        const n3 = t4.length();
        t4.normalize();
        const r3 = cB.dot(t4);
        if (r3 < n3 + h2 && r3 > 0) {
          const i3 = pB, s3 = dB;
          i3.copy(d2[(e3 + 1) % 3]), s3.copy(d2[(e3 + 2) % 3]);
          const o3 = i3.length(), a3 = s3.length();
          i3.normalize(), s3.normalize();
          const l3 = cB.dot(i3), c3 = cB.dot(s3);
          if (l3 < o3 && l3 > -o3 && c3 < a3 && c3 > -a3) {
            const e4 = Math.abs(r3 - n3 - h2);
            if ((null === A2 || e4 < A2) && (A2 = e4, b2 = l3, w2 = c3, v2 = n3, m2.copy(t4), _2.copy(i3), g2.copy(s3), y2++, u2))
              return true;
          }
        }
      }
      if (y2) {
        f2 = true;
        const i3 = this.createContactEquation(o2, a2, e2, t2, l2, c2);
        m2.scale(-h2, i3.ri), i3.ni.copy(m2), i3.ni.negate(i3.ni), m2.scale(v2, m2), _2.scale(b2, _2), m2.vadd(_2, m2), g2.scale(w2, g2), m2.vadd(g2, i3.rj), i3.ri.vadd(n2, i3.ri), i3.ri.vsub(o2.position, i3.ri), i3.rj.vadd(r2, i3.rj), i3.rj.vsub(a2.position, i3.rj), this.result.push(i3), this.createFrictionEquationsFromContact(i3, this.frictionResult);
      }
      let x2 = p2.get();
      const E2 = fB;
      for (let i3 = 0; 2 !== i3 && !f2; i3++)
        for (let s3 = 0; 2 !== s3 && !f2; s3++)
          for (let p3 = 0; 2 !== p3 && !f2; p3++)
            if (x2.set(0, 0, 0), i3 ? x2.vadd(d2[0], x2) : x2.vsub(d2[0], x2), s3 ? x2.vadd(d2[1], x2) : x2.vsub(d2[1], x2), p3 ? x2.vadd(d2[2], x2) : x2.vsub(d2[2], x2), r2.vadd(x2, E2), E2.vsub(n2, E2), E2.lengthSquared() < h2 * h2) {
              if (u2)
                return true;
              f2 = true;
              const i4 = this.createContactEquation(o2, a2, e2, t2, l2, c2);
              i4.ri.copy(E2), i4.ri.normalize(), i4.ni.copy(i4.ri), i4.ri.scale(h2, i4.ri), i4.rj.copy(x2), i4.ri.vadd(n2, i4.ri), i4.ri.vsub(o2.position, i4.ri), i4.rj.vadd(r2, i4.rj), i4.rj.vsub(a2.position, i4.rj), this.result.push(i4), this.createFrictionEquationsFromContact(i4, this.frictionResult);
            }
      p2.release(x2), x2 = null;
      const C2 = p2.get(), S2 = p2.get(), M2 = p2.get(), T2 = p2.get(), P2 = p2.get(), I2 = d2.length;
      for (let i3 = 0; i3 !== I2 && !f2; i3++)
        for (let s3 = 0; s3 !== I2 && !f2; s3++)
          if (i3 % 3 != s3 % 3) {
            d2[s3].cross(d2[i3], C2), C2.normalize(), d2[i3].vadd(d2[s3], S2), M2.copy(n2), M2.vsub(S2, M2), M2.vsub(r2, M2);
            const p3 = M2.dot(C2);
            C2.scale(p3, T2);
            let m3 = 0;
            for (; m3 === i3 % 3 || m3 === s3 % 3; )
              m3++;
            P2.copy(n2), P2.vsub(T2, P2), P2.vsub(S2, P2), P2.vsub(r2, P2);
            const _3 = Math.abs(p3), g3 = P2.length();
            if (_3 < d2[m3].length() && g3 < h2) {
              if (u2)
                return true;
              f2 = true;
              const i4 = this.createContactEquation(o2, a2, e2, t2, l2, c2);
              S2.vadd(T2, i4.rj), i4.rj.copy(i4.rj), P2.negate(i4.ni), i4.ni.normalize(), i4.ri.copy(i4.rj), i4.ri.vadd(r2, i4.ri), i4.ri.vsub(n2, i4.ri), i4.ri.normalize(), i4.ri.scale(h2, i4.ri), i4.ri.vadd(n2, i4.ri), i4.ri.vsub(o2.position, i4.ri), i4.rj.vadd(r2, i4.rj), i4.rj.vsub(a2.position, i4.rj), this.result.push(i4), this.createFrictionEquationsFromContact(i4, this.frictionResult);
            }
          }
      p2.release(C2, S2, M2, T2, P2);
    }
    planeBox(e2, t2, n2, r2, i2, s2, o2, a2, l2, c2, u2) {
      return t2.convexPolyhedronRepresentation.material = t2.material, t2.convexPolyhedronRepresentation.collisionResponse = t2.collisionResponse, t2.convexPolyhedronRepresentation.id = t2.id, this.planeConvex(e2, t2.convexPolyhedronRepresentation, n2, r2, i2, s2, o2, a2, e2, t2, u2);
    }
    convexConvex(e2, t2, n2, r2, i2, s2, o2, a2, l2, c2, u2, p2, d2) {
      const h2 = kB;
      if (!(n2.distanceTo(r2) > e2.boundingSphereRadius + t2.boundingSphereRadius) && e2.findSeparatingAxis(t2, n2, i2, r2, s2, h2, p2, d2)) {
        const p3 = [], d3 = DB;
        e2.clipAgainstHull(n2, i2, t2, r2, s2, h2, -100, 100, p3);
        let f2 = 0;
        for (let i3 = 0; i3 !== p3.length; i3++) {
          if (u2)
            return true;
          const s3 = this.createContactEquation(o2, a2, e2, t2, l2, c2), m2 = s3.ri, _2 = s3.rj;
          h2.negate(s3.ni), p3[i3].normal.negate(d3), d3.scale(p3[i3].depth, d3), p3[i3].point.vadd(d3, m2), _2.copy(p3[i3].point), m2.vsub(n2, m2), _2.vsub(r2, _2), m2.vadd(n2, m2), m2.vsub(o2.position, m2), _2.vadd(r2, _2), _2.vsub(a2.position, _2), this.result.push(s3), f2++, this.enableFrictionReduction || this.createFrictionEquationsFromContact(s3, this.frictionResult);
        }
        this.enableFrictionReduction && f2 && this.createFrictionFromAverage(f2);
      }
    }
    sphereConvex(e2, t2, n2, r2, i2, s2, o2, a2, l2, c2, u2) {
      const p2 = this.v3pool;
      n2.vsub(r2, vB);
      const d2 = t2.faceNormals, h2 = t2.faces, f2 = t2.vertices, m2 = e2.radius;
      let _2 = false;
      for (let i3 = 0; i3 !== f2.length; i3++) {
        const p3 = f2[i3], d3 = AB;
        s2.vmult(p3, d3), r2.vadd(d3, d3);
        const h3 = wB;
        if (d3.vsub(n2, h3), h3.lengthSquared() < m2 * m2) {
          if (u2)
            return true;
          _2 = true;
          const i4 = this.createContactEquation(o2, a2, e2, t2, l2, c2);
          return i4.ri.copy(h3), i4.ri.normalize(), i4.ni.copy(i4.ri), i4.ri.scale(m2, i4.ri), d3.vsub(r2, i4.rj), i4.ri.vadd(n2, i4.ri), i4.ri.vsub(o2.position, i4.ri), i4.rj.vadd(r2, i4.rj), i4.rj.vsub(a2.position, i4.rj), this.result.push(i4), void this.createFrictionEquationsFromContact(i4, this.frictionResult);
        }
      }
      for (let i3 = 0, g2 = h2.length; i3 !== g2 && false === _2; i3++) {
        const g3 = d2[i3], v2 = h2[i3], y2 = xB;
        s2.vmult(g3, y2);
        const b2 = EB;
        s2.vmult(f2[v2[0]], b2), b2.vadd(r2, b2);
        const w2 = CB;
        y2.scale(-m2, w2), n2.vadd(w2, w2);
        const A2 = SB;
        w2.vsub(b2, A2);
        const x2 = A2.dot(y2), E2 = MB;
        if (n2.vsub(b2, E2), x2 < 0 && E2.dot(y2) > 0) {
          const i4 = [];
          for (let e3 = 0, t3 = v2.length; e3 !== t3; e3++) {
            const t4 = p2.get();
            s2.vmult(f2[v2[e3]], t4), r2.vadd(t4, t4), i4.push(t4);
          }
          if (lB(i4, y2, n2)) {
            if (u2)
              return true;
            _2 = true;
            const s3 = this.createContactEquation(o2, a2, e2, t2, l2, c2);
            y2.scale(-m2, s3.ri), y2.negate(s3.ni);
            const d3 = p2.get();
            y2.scale(-x2, d3);
            const h3 = p2.get();
            y2.scale(-m2, h3), n2.vsub(r2, s3.rj), s3.rj.vadd(h3, s3.rj), s3.rj.vadd(d3, s3.rj), s3.rj.vadd(r2, s3.rj), s3.rj.vsub(a2.position, s3.rj), s3.ri.vadd(n2, s3.ri), s3.ri.vsub(o2.position, s3.ri), p2.release(d3), p2.release(h3), this.result.push(s3), this.createFrictionEquationsFromContact(s3, this.frictionResult);
            for (let e3 = 0, t3 = i4.length; e3 !== t3; e3++)
              p2.release(i4[e3]);
            return;
          }
          for (let d3 = 0; d3 !== v2.length; d3++) {
            const h3 = p2.get(), _3 = p2.get();
            s2.vmult(f2[v2[(d3 + 1) % v2.length]], h3), s2.vmult(f2[v2[(d3 + 2) % v2.length]], _3), r2.vadd(h3, h3), r2.vadd(_3, _3);
            const g4 = yB;
            _3.vsub(h3, g4);
            const y3 = bB;
            g4.unit(y3);
            const b3 = p2.get(), w3 = p2.get();
            n2.vsub(h3, w3);
            const A3 = w3.dot(y3);
            y3.scale(A3, b3), b3.vadd(h3, b3);
            const x3 = p2.get();
            if (b3.vsub(n2, x3), A3 > 0 && A3 * A3 < g4.lengthSquared() && x3.lengthSquared() < m2 * m2) {
              if (u2)
                return true;
              const s3 = this.createContactEquation(o2, a2, e2, t2, l2, c2);
              b3.vsub(r2, s3.rj), b3.vsub(n2, s3.ni), s3.ni.normalize(), s3.ni.scale(m2, s3.ri), s3.rj.vadd(r2, s3.rj), s3.rj.vsub(a2.position, s3.rj), s3.ri.vadd(n2, s3.ri), s3.ri.vsub(o2.position, s3.ri), this.result.push(s3), this.createFrictionEquationsFromContact(s3, this.frictionResult);
              for (let e3 = 0, t3 = i4.length; e3 !== t3; e3++)
                p2.release(i4[e3]);
              return p2.release(h3), p2.release(_3), p2.release(b3), p2.release(x3), void p2.release(w3);
            }
            p2.release(h3), p2.release(_3), p2.release(b3), p2.release(x3), p2.release(w3);
          }
          for (let e3 = 0, t3 = i4.length; e3 !== t3; e3++)
            p2.release(i4[e3]);
        }
      }
    }
    planeConvex(e2, t2, n2, r2, i2, s2, o2, a2, l2, c2, u2) {
      const p2 = TB, d2 = PB;
      d2.set(0, 0, 1), i2.vmult(d2, d2);
      let h2 = 0;
      const f2 = IB;
      for (let i3 = 0; i3 !== t2.vertices.length; i3++)
        if (p2.copy(t2.vertices[i3]), s2.vmult(p2, p2), r2.vadd(p2, p2), p2.vsub(n2, f2), d2.dot(f2) <= 0) {
          if (u2)
            return true;
          const i4 = this.createContactEquation(o2, a2, e2, t2, l2, c2), s3 = RB;
          d2.scale(d2.dot(f2), s3), p2.vsub(s3, s3), s3.vsub(n2, i4.ri), i4.ni.copy(d2), p2.vsub(r2, i4.rj), i4.ri.vadd(n2, i4.ri), i4.ri.vsub(o2.position, i4.ri), i4.rj.vadd(r2, i4.rj), i4.rj.vsub(a2.position, i4.rj), this.result.push(i4), h2++, this.enableFrictionReduction || this.createFrictionEquationsFromContact(i4, this.frictionResult);
        }
      this.enableFrictionReduction && h2 && this.createFrictionFromAverage(h2);
    }
    boxConvex(e2, t2, n2, r2, i2, s2, o2, a2, l2, c2, u2) {
      return e2.convexPolyhedronRepresentation.material = e2.material, e2.convexPolyhedronRepresentation.collisionResponse = e2.collisionResponse, this.convexConvex(e2.convexPolyhedronRepresentation, t2, n2, r2, i2, s2, o2, a2, e2, t2, u2);
    }
    sphereHeightfield(e2, t2, n2, r2, i2, s2, o2, a2, l2, c2, u2) {
      const p2 = t2.data, d2 = e2.radius, h2 = t2.elementSize, f2 = qB, m2 = WB;
      qI.pointToLocalFrame(r2, s2, n2, m2);
      let _2 = Math.floor((m2.x - d2) / h2) - 1, g2 = Math.ceil((m2.x + d2) / h2) + 1, v2 = Math.floor((m2.y - d2) / h2) - 1, y2 = Math.ceil((m2.y + d2) / h2) + 1;
      if (g2 < 0 || y2 < 0 || _2 > p2.length || v2 > p2[0].length)
        return;
      _2 < 0 && (_2 = 0), g2 < 0 && (g2 = 0), v2 < 0 && (v2 = 0), y2 < 0 && (y2 = 0), _2 >= p2.length && (_2 = p2.length - 1), g2 >= p2.length && (g2 = p2.length - 1), y2 >= p2[0].length && (y2 = p2[0].length - 1), v2 >= p2[0].length && (v2 = p2[0].length - 1);
      const b2 = [];
      t2.getRectMinMax(_2, v2, g2, y2, b2);
      const w2 = b2[0], A2 = b2[1];
      if (m2.z - d2 > A2 || m2.z + d2 < w2)
        return;
      const x2 = this.result;
      for (let l3 = _2; l3 < g2; l3++)
        for (let c3 = v2; c3 < y2; c3++) {
          const p3 = x2.length;
          let d3 = false;
          if (t2.getConvexTrianglePillar(l3, c3, false), qI.pointToWorldFrame(r2, s2, t2.pillarOffset, f2), n2.distanceTo(f2) < t2.pillarConvex.boundingSphereRadius + e2.boundingSphereRadius && (d3 = this.sphereConvex(e2, t2.pillarConvex, n2, f2, i2, s2, o2, a2, e2, t2, u2)), u2 && d3)
            return true;
          if (t2.getConvexTrianglePillar(l3, c3, true), qI.pointToWorldFrame(r2, s2, t2.pillarOffset, f2), n2.distanceTo(f2) < t2.pillarConvex.boundingSphereRadius + e2.boundingSphereRadius && (d3 = this.sphereConvex(e2, t2.pillarConvex, n2, f2, i2, s2, o2, a2, e2, t2, u2)), u2 && d3)
            return true;
          if (x2.length - p3 > 2)
            return;
        }
    }
    boxHeightfield(e2, t2, n2, r2, i2, s2, o2, a2, l2, c2, u2) {
      return e2.convexPolyhedronRepresentation.material = e2.material, e2.convexPolyhedronRepresentation.collisionResponse = e2.collisionResponse, this.convexHeightfield(e2.convexPolyhedronRepresentation, t2, n2, r2, i2, s2, o2, a2, e2, t2, u2);
    }
    convexHeightfield(e2, t2, n2, r2, i2, s2, o2, a2, l2, c2, u2) {
      const p2 = t2.data, d2 = t2.elementSize, h2 = e2.boundingSphereRadius, f2 = HB, m2 = QB, _2 = VB;
      qI.pointToLocalFrame(r2, s2, n2, _2);
      let g2 = Math.floor((_2.x - h2) / d2) - 1, v2 = Math.ceil((_2.x + h2) / d2) + 1, y2 = Math.floor((_2.y - h2) / d2) - 1, b2 = Math.ceil((_2.y + h2) / d2) + 1;
      if (v2 < 0 || b2 < 0 || g2 > p2.length || y2 > p2[0].length)
        return;
      g2 < 0 && (g2 = 0), v2 < 0 && (v2 = 0), y2 < 0 && (y2 = 0), b2 < 0 && (b2 = 0), g2 >= p2.length && (g2 = p2.length - 1), v2 >= p2.length && (v2 = p2.length - 1), b2 >= p2[0].length && (b2 = p2[0].length - 1), y2 >= p2[0].length && (y2 = p2[0].length - 1);
      const w2 = [];
      t2.getRectMinMax(g2, y2, v2, b2, w2);
      const A2 = w2[0], x2 = w2[1];
      if (!(_2.z - h2 > x2 || _2.z + h2 < A2))
        for (let l3 = g2; l3 < v2; l3++)
          for (let c3 = y2; c3 < b2; c3++) {
            let p3 = false;
            if (t2.getConvexTrianglePillar(l3, c3, false), qI.pointToWorldFrame(r2, s2, t2.pillarOffset, f2), n2.distanceTo(f2) < t2.pillarConvex.boundingSphereRadius + e2.boundingSphereRadius && (p3 = this.convexConvex(e2, t2.pillarConvex, n2, f2, i2, s2, o2, a2, null, null, u2, m2, null)), u2 && p3)
              return true;
            if (t2.getConvexTrianglePillar(l3, c3, true), qI.pointToWorldFrame(r2, s2, t2.pillarOffset, f2), n2.distanceTo(f2) < t2.pillarConvex.boundingSphereRadius + e2.boundingSphereRadius && (p3 = this.convexConvex(e2, t2.pillarConvex, n2, f2, i2, s2, o2, a2, null, null, u2, m2, null)), u2 && p3)
              return true;
          }
    }
    sphereParticle(e2, t2, n2, r2, i2, s2, o2, a2, l2, c2, u2) {
      const p2 = UB;
      if (p2.set(0, 0, 1), r2.vsub(n2, p2), p2.lengthSquared() <= e2.radius * e2.radius) {
        if (u2)
          return true;
        const n3 = this.createContactEquation(a2, o2, t2, e2, l2, c2);
        p2.normalize(), n3.rj.copy(p2), n3.rj.scale(e2.radius, n3.rj), n3.ni.copy(p2), n3.ni.negate(n3.ni), n3.ri.set(0, 0, 0), this.result.push(n3), this.createFrictionEquationsFromContact(n3, this.frictionResult);
      }
    }
    planeParticle(e2, t2, n2, r2, i2, s2, o2, a2, l2, c2, u2) {
      const p2 = BB;
      p2.set(0, 0, 1), o2.quaternion.vmult(p2, p2);
      const d2 = OB;
      if (r2.vsub(o2.position, d2), p2.dot(d2) <= 0) {
        if (u2)
          return true;
        const n3 = this.createContactEquation(a2, o2, t2, e2, l2, c2);
        n3.ni.copy(p2), n3.ni.negate(n3.ni), n3.ri.set(0, 0, 0);
        const i3 = LB;
        p2.scale(p2.dot(r2), i3), r2.vsub(i3, i3), n3.rj.copy(i3), this.result.push(n3), this.createFrictionEquationsFromContact(n3, this.frictionResult);
      }
    }
    boxParticle(e2, t2, n2, r2, i2, s2, o2, a2, l2, c2, u2) {
      return e2.convexPolyhedronRepresentation.material = e2.material, e2.convexPolyhedronRepresentation.collisionResponse = e2.collisionResponse, this.convexParticle(e2.convexPolyhedronRepresentation, t2, n2, r2, i2, s2, o2, a2, e2, t2, u2);
    }
    convexParticle(e2, t2, n2, r2, i2, s2, o2, a2, l2, c2, u2) {
      let p2 = -1;
      const d2 = jB, h2 = GB;
      let f2 = null;
      const m2 = NB;
      if (m2.copy(r2), m2.vsub(n2, m2), i2.conjugate(FB), FB.vmult(m2, m2), e2.pointIsInside(m2)) {
        e2.worldVerticesNeedsUpdate && e2.computeWorldVertices(n2, i2), e2.worldFaceNormalsNeedsUpdate && e2.computeWorldFaceNormals(i2);
        for (let t3 = 0, n3 = e2.faces.length; t3 !== n3; t3++) {
          const n4 = [e2.worldVertices[e2.faces[t3][0]]], i3 = e2.worldFaceNormals[t3];
          r2.vsub(n4[0], zB);
          const s3 = -i3.dot(zB);
          if (null === f2 || Math.abs(s3) < Math.abs(f2)) {
            if (u2)
              return true;
            f2 = s3, p2 = t3, d2.copy(i3);
          }
        }
        if (-1 !== p2) {
          const i3 = this.createContactEquation(a2, o2, t2, e2, l2, c2);
          d2.scale(f2, h2), h2.vadd(r2, h2), h2.vsub(n2, h2), i3.rj.copy(h2), d2.negate(i3.ni), i3.ri.set(0, 0, 0);
          const s3 = i3.ri, u3 = i3.rj;
          s3.vadd(r2, s3), s3.vsub(a2.position, s3), u3.vadd(n2, u3), u3.vsub(o2.position, u3), this.result.push(i3), this.createFrictionEquationsFromContact(i3, this.frictionResult);
        } else
          console.warn("Point found inside convex, but did not find penetrating face!");
      }
    }
    heightfieldCylinder(e2, t2, n2, r2, i2, s2, o2, a2, l2, c2, u2) {
      return this.convexHeightfield(t2, e2, r2, n2, s2, i2, a2, o2, l2, c2, u2);
    }
    particleCylinder(e2, t2, n2, r2, i2, s2, o2, a2, l2, c2, u2) {
      return this.convexParticle(t2, e2, r2, n2, s2, i2, a2, o2, l2, c2, u2);
    }
    sphereTrimesh(e2, t2, n2, r2, i2, s2, o2, a2, l2, c2, u2) {
      const p2 = WD, d2 = qD, h2 = XD, f2 = YD, m2 = KD, _2 = JD, g2 = tB, v2 = QD, y2 = VD, b2 = nB;
      qI.pointToLocalFrame(r2, s2, n2, m2);
      const w2 = e2.radius;
      g2.lowerBound.set(m2.x - w2, m2.y - w2, m2.z - w2), g2.upperBound.set(m2.x + w2, m2.y + w2, m2.z + w2), t2.getTrianglesInAABB(g2, b2);
      const A2 = HD, x2 = e2.radius * e2.radius;
      for (let i3 = 0; i3 < b2.length; i3++)
        for (let p3 = 0; p3 < 3; p3++)
          if (t2.getVertex(t2.indices[3 * b2[i3] + p3], A2), A2.vsub(m2, y2), y2.lengthSquared() <= x2) {
            if (v2.copy(A2), qI.pointToWorldFrame(r2, s2, v2, A2), A2.vsub(n2, y2), u2)
              return true;
            let i4 = this.createContactEquation(o2, a2, e2, t2, l2, c2);
            i4.ni.copy(y2), i4.ni.normalize(), i4.ri.copy(i4.ni), i4.ri.scale(e2.radius, i4.ri), i4.ri.vadd(n2, i4.ri), i4.ri.vsub(o2.position, i4.ri), i4.rj.copy(A2), i4.rj.vsub(a2.position, i4.rj), this.result.push(i4), this.createFrictionEquationsFromContact(i4, this.frictionResult);
          }
      for (let i3 = 0; i3 < b2.length; i3++)
        for (let g3 = 0; g3 < 3; g3++) {
          t2.getVertex(t2.indices[3 * b2[i3] + g3], p2), t2.getVertex(t2.indices[3 * b2[i3] + (g3 + 1) % 3], d2), d2.vsub(p2, h2), m2.vsub(d2, _2);
          const v3 = _2.dot(h2);
          m2.vsub(p2, _2);
          let y3 = _2.dot(h2);
          if (y3 > 0 && v3 < 0 && (m2.vsub(p2, _2), f2.copy(h2), f2.normalize(), y3 = _2.dot(f2), f2.scale(y3, _2), _2.vadd(p2, _2), _2.distanceTo(m2) < e2.radius)) {
            if (u2)
              return true;
            const i4 = this.createContactEquation(o2, a2, e2, t2, l2, c2);
            _2.vsub(m2, i4.ni), i4.ni.normalize(), i4.ni.scale(e2.radius, i4.ri), i4.ri.vadd(n2, i4.ri), i4.ri.vsub(o2.position, i4.ri), qI.pointToWorldFrame(r2, s2, _2, _2), _2.vsub(a2.position, i4.rj), qI.vectorToWorldFrame(s2, i4.ni, i4.ni), qI.vectorToWorldFrame(s2, i4.ri, i4.ri), this.result.push(i4), this.createFrictionEquationsFromContact(i4, this.frictionResult);
          }
        }
      const E2 = ZD, C2 = $D, S2 = eB, M2 = GD;
      for (let i3 = 0, p3 = b2.length; i3 !== p3; i3++) {
        t2.getTriangleVertices(b2[i3], E2, C2, S2), t2.getNormal(b2[i3], M2), m2.vsub(E2, _2);
        let p4 = _2.dot(M2);
        if (M2.scale(p4, _2), m2.vsub(_2, _2), p4 = _2.distanceTo(m2), RR.pointInTriangle(_2, E2, C2, S2) && p4 < e2.radius) {
          if (u2)
            return true;
          let i4 = this.createContactEquation(o2, a2, e2, t2, l2, c2);
          _2.vsub(m2, i4.ni), i4.ni.normalize(), i4.ni.scale(e2.radius, i4.ri), i4.ri.vadd(n2, i4.ri), i4.ri.vsub(o2.position, i4.ri), qI.pointToWorldFrame(r2, s2, _2, _2), _2.vsub(a2.position, i4.rj), qI.vectorToWorldFrame(s2, i4.ni, i4.ni), qI.vectorToWorldFrame(s2, i4.ri, i4.ri), this.result.push(i4), this.createFrictionEquationsFromContact(i4, this.frictionResult);
        }
      }
      b2.length = 0;
    }
    planeTrimesh(e2, t2, n2, r2, i2, s2, o2, a2, l2, c2, u2) {
      const p2 = new BI(), d2 = ND;
      d2.set(0, 0, 1), i2.vmult(d2, d2);
      for (let i3 = 0; i3 < t2.vertices.length / 3; i3++) {
        t2.getVertex(i3, p2);
        const h2 = new BI();
        h2.copy(p2), qI.pointToWorldFrame(r2, s2, h2, p2);
        const f2 = jD;
        if (p2.vsub(n2, f2), d2.dot(f2) <= 0) {
          if (u2)
            return true;
          const n3 = this.createContactEquation(o2, a2, e2, t2, l2, c2);
          n3.ni.copy(d2);
          const r3 = zD;
          d2.scale(f2.dot(d2), r3), p2.vsub(r3, r3), n3.ri.copy(r3), n3.ri.vsub(o2.position, n3.ri), n3.rj.copy(p2), n3.rj.vsub(a2.position, n3.rj), this.result.push(n3), this.createFrictionEquationsFromContact(n3, this.frictionResult);
        }
      }
    }
  }
  const kD = new BI(), DD = new BI(), BD = new BI(), OD = new BI(), LD = new BI(), UD = new VI(), FD = new VI(), ND = new BI(), jD = new BI(), zD = new BI(), GD = new BI(), VD = new BI();
  new BI();
  const HD = new BI(), QD = new BI(), WD = new BI(), qD = new BI(), XD = new BI(), YD = new BI(), KD = new BI(), JD = new BI(), ZD = new BI(), $D = new BI(), eB = new BI(), tB = new FI(), nB = [], rB = new BI(), iB = new BI(), sB = new BI(), oB = new BI(), aB = new BI();
  function lB(e2, t2, n2) {
    let r2 = null;
    const i2 = e2.length;
    for (let s2 = 0; s2 !== i2; s2++) {
      const o2 = e2[s2], a2 = sB;
      e2[(s2 + 1) % i2].vsub(o2, a2);
      const l2 = oB;
      a2.cross(t2, l2);
      const c2 = aB;
      n2.vsub(o2, c2);
      const u2 = l2.dot(c2);
      if (!(null === r2 || u2 > 0 && true === r2 || u2 <= 0 && false === r2))
        return false;
      null === r2 && (r2 = u2 > 0);
    }
    return true;
  }
  const cB = new BI(), uB = new BI(), pB = new BI(), dB = new BI(), hB = [new BI(), new BI(), new BI(), new BI(), new BI(), new BI()], fB = new BI(), mB = new BI(), _B = new BI(), gB = new BI(), vB = new BI(), yB = new BI(), bB = new BI(), wB = new BI(), AB = new BI(), xB = new BI(), EB = new BI(), CB = new BI(), SB = new BI(), MB = new BI();
  new BI(), new BI();
  const TB = new BI(), PB = new BI(), IB = new BI(), RB = new BI(), kB = new BI(), DB = new BI(), BB = new BI(), OB = new BI(), LB = new BI(), UB = new BI(), FB = new VI(), NB = new BI();
  new BI();
  const jB = new BI(), zB = new BI(), GB = new BI(), VB = new BI(), HB = new BI(), QB = [0], WB = new BI(), qB = new BI();
  class XB {
    constructor() {
      this.current = [], this.previous = [];
    }
    getKey(e2, t2) {
      if (t2 < e2) {
        const n2 = t2;
        t2 = e2, e2 = n2;
      }
      return e2 << 16 | t2;
    }
    set(e2, t2) {
      const n2 = this.getKey(e2, t2), r2 = this.current;
      let i2 = 0;
      for (; n2 > r2[i2]; )
        i2++;
      if (n2 !== r2[i2]) {
        for (let e3 = r2.length - 1; e3 >= i2; e3--)
          r2[e3 + 1] = r2[e3];
        r2[i2] = n2;
      }
    }
    tick() {
      const e2 = this.current;
      this.current = this.previous, this.previous = e2, this.current.length = 0;
    }
    getDiff(e2, t2) {
      const n2 = this.current, r2 = this.previous, i2 = n2.length, s2 = r2.length;
      let o2 = 0;
      for (let t3 = 0; t3 < i2; t3++) {
        let i3 = false;
        const s3 = n2[t3];
        for (; s3 > r2[o2]; )
          o2++;
        i3 = s3 === r2[o2], i3 || YB(e2, s3);
      }
      o2 = 0;
      for (let e3 = 0; e3 < s2; e3++) {
        let i3 = false;
        const s3 = r2[e3];
        for (; s3 > n2[o2]; )
          o2++;
        i3 = n2[o2] === s3, i3 || YB(t2, s3);
      }
    }
  }
  function YB(e2, t2) {
    e2.push((4294901760 & t2) >> 16, 65535 & t2);
  }
  const KB = (e2, t2) => e2 < t2 ? `${e2}-${t2}` : `${t2}-${e2}`;
  class JB {
    constructor() {
      this.data = { keys: [] };
    }
    get(e2, t2) {
      const n2 = KB(e2, t2);
      return this.data[n2];
    }
    set(e2, t2, n2) {
      const r2 = KB(e2, t2);
      this.get(e2, t2) || this.data.keys.push(r2), this.data[r2] = n2;
    }
    delete(e2, t2) {
      const n2 = KB(e2, t2), r2 = this.data.keys.indexOf(n2);
      -1 !== r2 && this.data.keys.splice(r2, 1), delete this.data[n2];
    }
    reset() {
      const e2 = this.data, t2 = e2.keys;
      for (; t2.length > 0; )
        delete e2[t2.pop()];
    }
  }
  class ZB extends GI {
    constructor(e2) {
      void 0 === e2 && (e2 = {}), super(), this.dt = -1, this.allowSleep = !!e2.allowSleep, this.contacts = [], this.frictionEquations = [], this.quatNormalizeSkip = void 0 !== e2.quatNormalizeSkip ? e2.quatNormalizeSkip : 0, this.quatNormalizeFast = void 0 !== e2.quatNormalizeFast && e2.quatNormalizeFast, this.time = 0, this.stepnumber = 0, this.default_dt = 1 / 60, this.nextId = 0, this.gravity = new BI(), e2.gravity && this.gravity.copy(e2.gravity), this.broadphase = void 0 !== e2.broadphase ? e2.broadphase : new AR(), this.bodies = [], this.hasActiveBodies = false, this.solver = void 0 !== e2.solver ? e2.solver : new eD(), this.constraints = [], this.narrowphase = new RD(this), this.collisionMatrix = new zI(), this.collisionMatrixPrevious = new zI(), this.bodyOverlapKeeper = new XB(), this.shapeOverlapKeeper = new XB(), this.contactmaterials = [], this.contactMaterialTable = new JB(), this.defaultMaterial = new Ik("default"), this.defaultContactMaterial = new Pk(this.defaultMaterial, this.defaultMaterial, { friction: 0.3, restitution: 0 }), this.doProfiling = false, this.profile = { solve: 0, makeContactConstraints: 0, broadphase: 0, integrate: 0, narrowphase: 0 }, this.accumulator = 0, this.subsystems = [], this.addBodyEvent = { type: "addBody", body: null }, this.removeBodyEvent = { type: "removeBody", body: null }, this.idToBodyMap = {}, this.broadphase.setWorld(this);
    }
    getContactMaterial(e2, t2) {
      return this.contactMaterialTable.get(e2.id, t2.id);
    }
    collisionMatrixTick() {
      const e2 = this.collisionMatrixPrevious;
      this.collisionMatrixPrevious = this.collisionMatrix, this.collisionMatrix = e2, this.collisionMatrix.reset(), this.bodyOverlapKeeper.tick(), this.shapeOverlapKeeper.tick();
    }
    addConstraint(e2) {
      this.constraints.push(e2);
    }
    removeConstraint(e2) {
      const t2 = this.constraints.indexOf(e2);
      -1 !== t2 && this.constraints.splice(t2, 1);
    }
    rayTest(e2, t2, n2) {
      n2 instanceof xR ? this.raycastClosest(e2, t2, { skipBackfaces: true }, n2) : this.raycastAll(e2, t2, { skipBackfaces: true }, n2);
    }
    raycastAll(e2, t2, n2, r2) {
      return void 0 === n2 && (n2 = {}), n2.mode = RR.ALL, n2.from = e2, n2.to = t2, n2.callback = r2, $B.intersectWorld(this, n2);
    }
    raycastAny(e2, t2, n2, r2) {
      return void 0 === n2 && (n2 = {}), n2.mode = RR.ANY, n2.from = e2, n2.to = t2, n2.result = r2, $B.intersectWorld(this, n2);
    }
    raycastClosest(e2, t2, n2, r2) {
      return void 0 === n2 && (n2 = {}), n2.mode = RR.CLOSEST, n2.from = e2, n2.to = t2, n2.result = r2, $B.intersectWorld(this, n2);
    }
    addBody(e2) {
      this.bodies.includes(e2) || (e2.index = this.bodies.length, this.bodies.push(e2), e2.world = this, e2.initPosition.copy(e2.position), e2.initVelocity.copy(e2.velocity), e2.timeLastSleepy = this.time, e2 instanceof rR && (e2.initAngularVelocity.copy(e2.angularVelocity), e2.initQuaternion.copy(e2.quaternion)), this.collisionMatrix.setNumObjects(this.bodies.length), this.addBodyEvent.body = e2, this.idToBodyMap[e2.id] = e2, this.dispatchEvent(this.addBodyEvent));
    }
    removeBody(e2) {
      e2.world = null;
      const t2 = this.bodies.length - 1, n2 = this.bodies, r2 = n2.indexOf(e2);
      if (-1 !== r2) {
        n2.splice(r2, 1);
        for (let e3 = 0; e3 !== n2.length; e3++)
          n2[e3].index = e3;
        this.collisionMatrix.setNumObjects(t2), this.removeBodyEvent.body = e2, delete this.idToBodyMap[e2.id], this.dispatchEvent(this.removeBodyEvent);
      }
    }
    getBodyById(e2) {
      return this.idToBodyMap[e2];
    }
    getShapeById(e2) {
      const t2 = this.bodies;
      for (let n2 = 0; n2 < t2.length; n2++) {
        const r2 = t2[n2].shapes;
        for (let t3 = 0; t3 < r2.length; t3++) {
          const n3 = r2[t3];
          if (n3.id === e2)
            return n3;
        }
      }
      return null;
    }
    addContactMaterial(e2) {
      this.contactmaterials.push(e2), this.contactMaterialTable.set(e2.materials[0].id, e2.materials[1].id, e2);
    }
    removeContactMaterial(e2) {
      const t2 = this.contactmaterials.indexOf(e2);
      -1 !== t2 && (this.contactmaterials.splice(t2, 1), this.contactMaterialTable.delete(e2.materials[0].id, e2.materials[1].id));
    }
    fixedStep(e2, t2) {
      void 0 === e2 && (e2 = 1 / 60), void 0 === t2 && (t2 = 10);
      const n2 = eO.now() / 1e3;
      if (this.lastCallTime) {
        const r2 = n2 - this.lastCallTime;
        this.step(e2, r2, t2);
      } else
        this.step(e2, void 0, t2);
      this.lastCallTime = n2;
    }
    step(e2, t2, n2) {
      if (void 0 === n2 && (n2 = 10), void 0 === t2)
        this.internalStep(e2), this.time += e2;
      else {
        this.accumulator += t2;
        const r2 = eO.now();
        let i2 = 0;
        for (; this.accumulator >= e2 && i2 < n2 && (this.internalStep(e2), this.accumulator -= e2, i2++, !(eO.now() - r2 > 1e3 * e2)); )
          ;
        this.accumulator = this.accumulator % e2;
        const s2 = this.accumulator / e2;
        for (let e3 = 0; e3 !== this.bodies.length; e3++) {
          const t3 = this.bodies[e3];
          t3.previousPosition.lerp(t3.position, s2, t3.interpolatedPosition), t3.previousQuaternion.slerp(t3.quaternion, s2, t3.interpolatedQuaternion), t3.previousQuaternion.normalize();
        }
        this.time += t2;
      }
    }
    internalStep(e2) {
      this.dt = e2;
      const t2 = this.contacts, n2 = oO, r2 = aO, i2 = this.bodies.length, s2 = this.bodies, o2 = this.solver, a2 = this.gravity, l2 = this.doProfiling, c2 = this.profile, u2 = rR.DYNAMIC;
      let p2 = -1 / 0;
      const d2 = this.constraints, h2 = sO;
      a2.length();
      const f2 = a2.x, m2 = a2.y, _2 = a2.z;
      let g2 = 0;
      for (l2 && (p2 = eO.now()), g2 = 0; g2 !== i2; g2++) {
        const e3 = s2[g2];
        if (e3.type === u2) {
          const t3 = e3.force, n3 = e3.mass;
          t3.x += n3 * f2, t3.y += n3 * m2, t3.z += n3 * _2;
        }
      }
      for (let e3 = 0, t3 = this.subsystems.length; e3 !== t3; e3++)
        this.subsystems[e3].update();
      l2 && (p2 = eO.now()), n2.length = 0, r2.length = 0, this.broadphase.collisionPairs(this, n2, r2), l2 && (c2.broadphase = eO.now() - p2);
      let v2 = d2.length;
      for (g2 = 0; g2 !== v2; g2++) {
        const e3 = d2[g2];
        if (!e3.collideConnected)
          for (let t3 = n2.length - 1; t3 >= 0; t3 -= 1)
            (e3.bodyA === n2[t3] && e3.bodyB === r2[t3] || e3.bodyB === n2[t3] && e3.bodyA === r2[t3]) && (n2.splice(t3, 1), r2.splice(t3, 1));
      }
      this.collisionMatrixTick(), l2 && (p2 = eO.now());
      const y2 = iO, b2 = t2.length;
      for (g2 = 0; g2 !== b2; g2++)
        y2.push(t2[g2]);
      t2.length = 0;
      const w2 = this.frictionEquations.length;
      for (g2 = 0; g2 !== w2; g2++)
        h2.push(this.frictionEquations[g2]);
      for (this.frictionEquations.length = 0, this.narrowphase.getContacts(n2, r2, this, t2, y2, this.frictionEquations, h2), l2 && (c2.narrowphase = eO.now() - p2), l2 && (p2 = eO.now()), g2 = 0; g2 < this.frictionEquations.length; g2++)
        o2.addEquation(this.frictionEquations[g2]);
      const A2 = t2.length;
      for (let e3 = 0; e3 !== A2; e3++) {
        const n3 = t2[e3], r3 = n3.bi, i3 = n3.bj, s3 = n3.si, a3 = n3.sj;
        let l3;
        l3 = r3.material && i3.material && this.getContactMaterial(r3.material, i3.material) || this.defaultContactMaterial, l3.friction, r3.material && i3.material && (r3.material.friction >= 0 && i3.material.friction >= 0 && (r3.material.friction, i3.material.friction), r3.material.restitution >= 0 && i3.material.restitution >= 0 && (n3.restitution = r3.material.restitution * i3.material.restitution)), o2.addEquation(n3), r3.allowSleep && r3.type === rR.DYNAMIC && r3.sleepState === rR.SLEEPING && i3.sleepState === rR.AWAKE && i3.type !== rR.STATIC && i3.velocity.lengthSquared() + i3.angularVelocity.lengthSquared() >= 2 * i3.sleepSpeedLimit ** 2 && (r3.wakeUpAfterNarrowphase = true), i3.allowSleep && i3.type === rR.DYNAMIC && i3.sleepState === rR.SLEEPING && r3.sleepState === rR.AWAKE && r3.type !== rR.STATIC && r3.velocity.lengthSquared() + r3.angularVelocity.lengthSquared() >= 2 * r3.sleepSpeedLimit ** 2 && (i3.wakeUpAfterNarrowphase = true), this.collisionMatrix.set(r3, i3, true), this.collisionMatrixPrevious.get(r3, i3) || (rO.body = i3, rO.contact = n3, r3.dispatchEvent(rO), rO.body = r3, i3.dispatchEvent(rO)), this.bodyOverlapKeeper.set(r3.id, i3.id), this.shapeOverlapKeeper.set(s3.id, a3.id);
      }
      for (this.emitContactEvents(), l2 && (c2.makeContactConstraints = eO.now() - p2, p2 = eO.now()), g2 = 0; g2 !== i2; g2++) {
        const e3 = s2[g2];
        e3.wakeUpAfterNarrowphase && (e3.wakeUp(), e3.wakeUpAfterNarrowphase = false);
      }
      for (v2 = d2.length, g2 = 0; g2 !== v2; g2++) {
        const e3 = d2[g2];
        e3.update();
        for (let t3 = 0, n3 = e3.equations.length; t3 !== n3; t3++) {
          const n4 = e3.equations[t3];
          o2.addEquation(n4);
        }
      }
      o2.solve(e2, this), l2 && (c2.solve = eO.now() - p2), o2.removeAllEquations();
      const x2 = Math.pow;
      for (g2 = 0; g2 !== i2; g2++) {
        const t3 = s2[g2];
        if (t3.type & u2) {
          const n3 = x2(1 - t3.linearDamping, e2), r3 = t3.velocity;
          r3.scale(n3, r3);
          const i3 = t3.angularVelocity;
          if (i3) {
            const n4 = x2(1 - t3.angularDamping, e2);
            i3.scale(n4, i3);
          }
        }
      }
      this.dispatchEvent(nO), l2 && (p2 = eO.now());
      const E2 = this.stepnumber % (this.quatNormalizeSkip + 1) == 0, C2 = this.quatNormalizeFast;
      for (g2 = 0; g2 !== i2; g2++)
        s2[g2].integrate(e2, E2, C2);
      this.clearForces(), this.broadphase.dirty = true, l2 && (c2.integrate = eO.now() - p2), this.stepnumber += 1, this.dispatchEvent(tO);
      let S2 = true;
      if (this.allowSleep)
        for (S2 = false, g2 = 0; g2 !== i2; g2++) {
          const e3 = s2[g2];
          e3.sleepTick(this.time), e3.sleepState !== rR.SLEEPING && (S2 = true);
        }
      this.hasActiveBodies = S2;
    }
    emitContactEvents() {
      const e2 = this.hasAnyEventListener("beginContact"), t2 = this.hasAnyEventListener("endContact");
      if ((e2 || t2) && this.bodyOverlapKeeper.getDiff(lO, cO), e2) {
        for (let e3 = 0, t3 = lO.length; e3 < t3; e3 += 2)
          uO.bodyA = this.getBodyById(lO[e3]), uO.bodyB = this.getBodyById(lO[e3 + 1]), this.dispatchEvent(uO);
        uO.bodyA = uO.bodyB = null;
      }
      if (t2) {
        for (let e3 = 0, t3 = cO.length; e3 < t3; e3 += 2)
          pO.bodyA = this.getBodyById(cO[e3]), pO.bodyB = this.getBodyById(cO[e3 + 1]), this.dispatchEvent(pO);
        pO.bodyA = pO.bodyB = null;
      }
      lO.length = cO.length = 0;
      const n2 = this.hasAnyEventListener("beginShapeContact"), r2 = this.hasAnyEventListener("endShapeContact");
      if ((n2 || r2) && this.shapeOverlapKeeper.getDiff(lO, cO), n2) {
        for (let e3 = 0, t3 = lO.length; e3 < t3; e3 += 2) {
          const t4 = this.getShapeById(lO[e3]), n3 = this.getShapeById(lO[e3 + 1]);
          dO.shapeA = t4, dO.shapeB = n3, t4 && (dO.bodyA = t4.body), n3 && (dO.bodyB = n3.body), this.dispatchEvent(dO);
        }
        dO.bodyA = dO.bodyB = dO.shapeA = dO.shapeB = null;
      }
      if (r2) {
        for (let e3 = 0, t3 = cO.length; e3 < t3; e3 += 2) {
          const t4 = this.getShapeById(cO[e3]), n3 = this.getShapeById(cO[e3 + 1]);
          hO.shapeA = t4, hO.shapeB = n3, t4 && (hO.bodyA = t4.body), n3 && (hO.bodyB = n3.body), this.dispatchEvent(hO);
        }
        hO.bodyA = hO.bodyB = hO.shapeA = hO.shapeB = null;
      }
    }
    clearForces() {
      const e2 = this.bodies, t2 = e2.length;
      for (let n2 = 0; n2 !== t2; n2++) {
        const t3 = e2[n2];
        t3.force, t3.torque, t3.force.set(0, 0, 0), t3.torque.set(0, 0, 0);
      }
    }
  }
  new FI();
  const $B = new RR(), eO = globalThis.performance || {};
  if (!eO.now) {
    let e2 = Date.now();
    eO.timing && eO.timing.navigationStart && (e2 = eO.timing.navigationStart), eO.now = () => Date.now() - e2;
  }
  new BI();
  const tO = { type: "postStep" }, nO = { type: "preStep" }, rO = { type: rR.COLLIDE_EVENT_NAME, body: null, contact: null }, iO = [], sO = [], oO = [], aO = [], lO = [], cO = [], uO = { type: "beginContact", bodyA: null, bodyB: null }, pO = { type: "endContact", bodyA: null, bodyB: null }, dO = { type: "beginShapeContact", bodyA: null, bodyB: null, shapeA: null, shapeB: null }, hO = { type: "endShapeContact", bodyA: null, bodyB: null, shapeA: null, shapeB: null };
  var fO = function() {
    var e2, t2, r2, i2, s2 = 0, o2 = new n.Pa4();
    function a2() {
      this.tolerance = -1, this.faces = [], this.newFaces = [], this.assigned = new p2(), this.unassigned = new p2(), this.vertices = [];
    }
    function l2() {
      this.normal = new n.Pa4(), this.midpoint = new n.Pa4(), this.area = 0, this.constant = 0, this.outside = null, this.mark = s2, this.edge = null;
    }
    function c2(e3, t3) {
      this.vertex = e3, this.prev = null, this.next = null, this.twin = null, this.face = t3;
    }
    function u2(e3, t3) {
      this.point = e3, this.index = t3, this.prev = null, this.next = null, this.face = null;
    }
    function p2() {
      this.head = null, this.tail = null;
    }
    return Object.assign(a2.prototype, { toJSON: function() {
      const e3 = this.faces.map((e4) => e4.toArray()), t3 = Array.from(new Set(e3.flat())).sort(), n2 = [];
      for (let e4 = 0; e4 < t3.length; e4++)
        n2.push(this.vertices[t3[e4]].point.x, this.vertices[t3[e4]].point.y, this.vertices[t3[e4]].point.z);
      const r3 = /* @__PURE__ */ new Map();
      for (let e4 = 0; e4 < t3.length; e4++)
        r3.set(t3[e4], e4);
      const i3 = [];
      for (let t4 = 0; t4 < e3.length; t4++)
        i3.push([r3.get(e3[t4][0]), r3.get(e3[t4][1]), r3.get(e3[t4][2])]);
      return [n2, i3];
    }, setFromPoints: function(e3) {
      true !== Array.isArray(e3) && console.error("THREE.ConvexHull: Points parameter is not an array."), e3.length < 4 && console.error("THREE.ConvexHull: The algorithm needs at least four points."), this.makeEmpty();
      for (var t3 = 0, n2 = e3.length; t3 < n2; t3++)
        this.vertices.push(new u2(e3[t3], t3));
      return this.compute(), this;
    }, setFromObject: function(e3) {
      var t3 = [];
      return e3.updateMatrixWorld(true), e3.traverse(function(e4) {
        var r3, i3, s3, o3 = e4.geometry;
        if (void 0 !== o3 && (o3.isGeometry && (o3 = o3.toBufferGeometry ? o3.toBufferGeometry() : new BufferGeometry().fromGeometry(o3)), o3.isBufferGeometry)) {
          var a3 = o3.attributes.position;
          if (void 0 !== a3)
            for (r3 = 0, i3 = a3.count; r3 < i3; r3++)
              (s3 = new n.Pa4()).fromBufferAttribute(a3, r3).applyMatrix4(e4.matrixWorld), t3.push(s3);
        }
      }), this.setFromPoints(t3);
    }, containsPoint: function(e3) {
      for (var t3 = this.faces, n2 = 0, r3 = t3.length; n2 < r3; n2++)
        if (t3[n2].distanceToPoint(e3) > this.tolerance)
          return false;
      return true;
    }, intersectRay: function(e3, t3) {
      for (var n2 = this.faces, r3 = -1 / 0, i3 = 1 / 0, s3 = 0, o3 = n2.length; s3 < o3; s3++) {
        var a3 = n2[s3], l3 = a3.distanceToPoint(e3.origin), c3 = a3.normal.dot(e3.direction);
        if (l3 > 0 && c3 >= 0)
          return null;
        var u3 = 0 !== c3 ? -l3 / c3 : 0;
        if (!(u3 <= 0) && (c3 > 0 ? i3 = Math.min(u3, i3) : r3 = Math.max(u3, r3), r3 > i3))
          return null;
      }
      return r3 !== -1 / 0 ? e3.at(r3, t3) : e3.at(i3, t3), t3;
    }, intersectsRay: function(e3) {
      return null !== this.intersectRay(e3, o2);
    }, makeEmpty: function() {
      return this.faces = [], this.vertices = [], this;
    }, addVertexToFace: function(e3, t3) {
      return e3.face = t3, null === t3.outside ? this.assigned.append(e3) : this.assigned.insertBefore(t3.outside, e3), t3.outside = e3, this;
    }, removeVertexFromFace: function(e3, t3) {
      return e3 === t3.outside && (null !== e3.next && e3.next.face === t3 ? t3.outside = e3.next : t3.outside = null), this.assigned.remove(e3), this;
    }, removeAllVerticesFromFace: function(e3) {
      if (null !== e3.outside) {
        for (var t3 = e3.outside, n2 = e3.outside; null !== n2.next && n2.next.face === e3; )
          n2 = n2.next;
        return this.assigned.removeSubList(t3, n2), t3.prev = n2.next = null, e3.outside = null, t3;
      }
    }, deleteFaceVertices: function(e3, t3) {
      var n2 = this.removeAllVerticesFromFace(e3);
      if (void 0 !== n2)
        if (void 0 === t3)
          this.unassigned.appendChain(n2);
        else {
          var r3 = n2;
          do {
            var i3 = r3.next;
            t3.distanceToPoint(r3.point) > this.tolerance ? this.addVertexToFace(r3, t3) : this.unassigned.append(r3), r3 = i3;
          } while (null !== r3);
        }
      return this;
    }, resolveUnassignedPoints: function(e3) {
      if (false === this.unassigned.isEmpty()) {
        var t3 = this.unassigned.first();
        do {
          for (var n2 = t3.next, r3 = this.tolerance, i3 = null, o3 = 0; o3 < e3.length; o3++) {
            var a3 = e3[o3];
            if (a3.mark === s2) {
              var l3 = a3.distanceToPoint(t3.point);
              if (l3 > r3 && (r3 = l3, i3 = a3), r3 > 1e3 * this.tolerance)
                break;
            }
          }
          null !== i3 && this.addVertexToFace(t3, i3), t3 = n2;
        } while (null !== t3);
      }
      return this;
    }, computeExtremes: function() {
      var e3, t3, r3, i3 = new n.Pa4(), s3 = new n.Pa4(), o3 = [], a3 = [];
      for (e3 = 0; e3 < 3; e3++)
        o3[e3] = a3[e3] = this.vertices[0];
      for (i3.copy(this.vertices[0].point), s3.copy(this.vertices[0].point), e3 = 0, t3 = this.vertices.length; e3 < t3; e3++) {
        var l3 = this.vertices[e3], c3 = l3.point;
        for (r3 = 0; r3 < 3; r3++)
          c3.getComponent(r3) < i3.getComponent(r3) && (i3.setComponent(r3, c3.getComponent(r3)), o3[r3] = l3);
        for (r3 = 0; r3 < 3; r3++)
          c3.getComponent(r3) > s3.getComponent(r3) && (s3.setComponent(r3, c3.getComponent(r3)), a3[r3] = l3);
      }
      return this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(i3.x), Math.abs(s3.x)) + Math.max(Math.abs(i3.y), Math.abs(s3.y)) + Math.max(Math.abs(i3.z), Math.abs(s3.z))), { min: o3, max: a3 };
    }, computeInitialHull: function() {
      void 0 === e2 && (e2 = new n.Zzh(), t2 = new n.JOQ(), r2 = new n.Pa4());
      var i3, s3, o3, a3, c3, u3, p3, d2, h2, f2 = this.vertices, m2 = this.computeExtremes(), _2 = m2.min, g2 = m2.max, v2 = 0, y2 = 0;
      for (u3 = 0; u3 < 3; u3++)
        (h2 = g2[u3].point.getComponent(u3) - _2[u3].point.getComponent(u3)) > v2 && (v2 = h2, y2 = u3);
      for (s3 = _2[y2], o3 = g2[y2], v2 = 0, e2.set(s3.point, o3.point), u3 = 0, p3 = this.vertices.length; u3 < p3; u3++)
        (i3 = f2[u3]) !== s3 && i3 !== o3 && (e2.closestPointToPoint(i3.point, true, r2), (h2 = r2.distanceToSquared(i3.point)) > v2 && (v2 = h2, a3 = i3));
      for (v2 = -1, t2.setFromCoplanarPoints(s3.point, o3.point, a3.point), u3 = 0, p3 = this.vertices.length; u3 < p3; u3++)
        (i3 = f2[u3]) !== s3 && i3 !== o3 && i3 !== a3 && (h2 = Math.abs(t2.distanceToPoint(i3.point))) > v2 && (v2 = h2, c3 = i3);
      var b2 = [];
      if (t2.distanceToPoint(c3.point) < 0)
        for (b2.push(l2.create(s3, o3, a3), l2.create(c3, o3, s3), l2.create(c3, a3, o3), l2.create(c3, s3, a3)), u3 = 0; u3 < 3; u3++)
          d2 = (u3 + 1) % 3, b2[u3 + 1].getEdge(2).setTwin(b2[0].getEdge(d2)), b2[u3 + 1].getEdge(1).setTwin(b2[d2 + 1].getEdge(0));
      else
        for (b2.push(l2.create(s3, a3, o3), l2.create(c3, s3, o3), l2.create(c3, o3, a3), l2.create(c3, a3, s3)), u3 = 0; u3 < 3; u3++)
          d2 = (u3 + 1) % 3, b2[u3 + 1].getEdge(2).setTwin(b2[0].getEdge((3 - u3) % 3)), b2[u3 + 1].getEdge(0).setTwin(b2[d2 + 1].getEdge(1));
      for (u3 = 0; u3 < 4; u3++)
        this.faces.push(b2[u3]);
      for (u3 = 0, p3 = f2.length; u3 < p3; u3++)
        if ((i3 = f2[u3]) !== s3 && i3 !== o3 && i3 !== a3 && i3 !== c3) {
          v2 = this.tolerance;
          var w2 = null;
          for (d2 = 0; d2 < 4; d2++)
            (h2 = this.faces[d2].distanceToPoint(i3.point)) > v2 && (v2 = h2, w2 = this.faces[d2]);
          null !== w2 && this.addVertexToFace(i3, w2);
        }
      return this;
    }, reindexFaces: function() {
      for (var e3 = [], t3 = 0; t3 < this.faces.length; t3++) {
        var n2 = this.faces[t3];
        n2.mark === s2 && e3.push(n2);
      }
      return this.faces = e3, this;
    }, nextVertexToAdd: function() {
      if (false === this.assigned.isEmpty()) {
        var e3, t3 = 0, n2 = this.assigned.first().face, r3 = n2.outside;
        do {
          var i3 = n2.distanceToPoint(r3.point);
          i3 > t3 && (t3 = i3, e3 = r3), r3 = r3.next;
        } while (null !== r3 && r3.face === n2);
        return e3;
      }
    }, computeHorizon: function(e3, t3, n2, r3) {
      var i3;
      this.deleteFaceVertices(n2), n2.mark = 1, i3 = null === t3 ? t3 = n2.getEdge(0) : t3.next;
      do {
        var o3 = i3.twin, a3 = o3.face;
        a3.mark === s2 && (a3.distanceToPoint(e3) > this.tolerance ? this.computeHorizon(e3, o3, a3, r3) : r3.push(i3)), i3 = i3.next;
      } while (i3 !== t3);
      return this;
    }, addAdjoiningFace: function(e3, t3) {
      var n2 = l2.create(e3, t3.tail(), t3.head());
      return this.faces.push(n2), n2.getEdge(-1).setTwin(t3.twin), n2.getEdge(0);
    }, addNewFaces: function(e3, t3) {
      this.newFaces = [];
      for (var n2 = null, r3 = null, i3 = 0; i3 < t3.length; i3++) {
        var s3 = t3[i3], o3 = this.addAdjoiningFace(e3, s3);
        null === n2 ? n2 = o3 : o3.next.setTwin(r3), this.newFaces.push(o3.face), r3 = o3;
      }
      return n2.next.setTwin(r3), this;
    }, addVertexToHull: function(e3) {
      var t3 = [];
      return this.unassigned.clear(), this.removeVertexFromFace(e3, e3.face), this.computeHorizon(e3.point, null, e3.face, t3), this.addNewFaces(e3, t3), this.resolveUnassignedPoints(this.newFaces), this;
    }, cleanup: function() {
      return this.assigned.clear(), this.unassigned.clear(), this.newFaces = [], this;
    }, compute: function() {
      var e3;
      for (this.computeInitialHull(); void 0 !== (e3 = this.nextVertexToAdd()); )
        this.addVertexToHull(e3);
      return this.reindexFaces(), this.cleanup(), this;
    } }), Object.assign(l2, { create: function(e3, t3, n2) {
      var r3 = new l2(), i3 = new c2(e3, r3), s3 = new c2(t3, r3), o3 = new c2(n2, r3);
      return i3.next = o3.prev = s3, s3.next = i3.prev = o3, o3.next = s3.prev = i3, r3.edge = i3, r3.compute();
    } }), Object.assign(l2.prototype, { toArray: function() {
      const e3 = [];
      let t3 = this.edge;
      do {
        e3.push(t3.head().index), t3 = t3.next;
      } while (t3 !== this.edge);
      return e3;
    }, getEdge: function(e3) {
      for (var t3 = this.edge; e3 > 0; )
        t3 = t3.next, e3--;
      for (; e3 < 0; )
        t3 = t3.prev, e3++;
      return t3;
    }, compute: function() {
      void 0 === i2 && (i2 = new n.CJI());
      var e3 = this.edge.tail(), t3 = this.edge.head(), r3 = this.edge.next.head();
      return i2.set(e3.point, t3.point, r3.point), i2.getNormal(this.normal), i2.getMidpoint(this.midpoint), this.area = i2.getArea(), this.constant = this.normal.dot(this.midpoint), this;
    }, distanceToPoint: function(e3) {
      return this.normal.dot(e3) - this.constant;
    } }), Object.assign(c2.prototype, { head: function() {
      return this.vertex;
    }, tail: function() {
      return this.prev ? this.prev.vertex : null;
    }, length: function() {
      var e3 = this.head(), t3 = this.tail();
      return null !== t3 ? t3.point.distanceTo(e3.point) : -1;
    }, lengthSquared: function() {
      var e3 = this.head(), t3 = this.tail();
      return null !== t3 ? t3.point.distanceToSquared(e3.point) : -1;
    }, setTwin: function(e3) {
      return this.twin = e3, e3.twin = this, this;
    } }), Object.assign(p2.prototype, { first: function() {
      return this.head;
    }, last: function() {
      return this.tail;
    }, clear: function() {
      return this.head = this.tail = null, this;
    }, insertBefore: function(e3, t3) {
      return t3.prev = e3.prev, t3.next = e3, null === t3.prev ? this.head = t3 : t3.prev.next = t3, e3.prev = t3, this;
    }, insertAfter: function(e3, t3) {
      return t3.prev = e3, t3.next = e3.next, null === t3.next ? this.tail = t3 : t3.next.prev = t3, e3.next = t3, this;
    }, append: function(e3) {
      return null === this.head ? this.head = e3 : this.tail.next = e3, e3.prev = this.tail, e3.next = null, this.tail = e3, this;
    }, appendChain: function(e3) {
      for (null === this.head ? this.head = e3 : this.tail.next = e3, e3.prev = this.tail; null !== e3.next; )
        e3 = e3.next;
      return this.tail = e3, this;
    }, remove: function(e3) {
      return null === e3.prev ? this.head = e3.next : e3.prev.next = e3.next, null === e3.next ? this.tail = e3.prev : e3.next.prev = e3.prev, this;
    }, removeSubList: function(e3, t3) {
      return null === e3.prev ? this.head = t3.next : e3.prev.next = t3.next, null === t3.next ? this.tail = e3.prev : t3.next.prev = e3.prev, this;
    }, isEmpty: function() {
      return null === this.head;
    } }), a2;
  }();
  const mO = new n.Pa4(), _O = new n.Pa4(), gO = new n._fP();
  function vO(e2) {
    const t2 = function(e3) {
      const t3 = [];
      return e3.traverse(function(e4) {
        e4.isMesh && t3.push(e4);
      }), t3;
    }(e2);
    if (0 === t2.length)
      return null;
    if (1 === t2.length)
      return yO(t2[0]);
    let r2;
    const i2 = [];
    for (; r2 = t2.pop(); )
      i2.push(AO(yO(r2)));
    return function(e3) {
      let t3 = 0;
      for (let n2 = 0; n2 < e3.length; n2++) {
        const r4 = e3[n2].attributes.position;
        r4 && 3 === r4.itemSize && (t3 += r4.count);
      }
      const r3 = new Float32Array(3 * t3);
      let i3 = 0;
      for (let t4 = 0; t4 < e3.length; t4++) {
        const n2 = e3[t4].attributes.position;
        if (n2 && 3 === n2.itemSize)
          for (let e4 = 0; e4 < n2.count; e4++)
            r3[i3++] = n2.getX(e4), r3[i3++] = n2.getY(e4), r3[i3++] = n2.getZ(e4);
      }
      return new n.u9r().setAttribute("position", new n.TlE(r3, 3));
    }(i2);
  }
  function yO(e2) {
    let t2 = e2.geometry;
    return t2 = t2.toBufferGeometry ? t2.toBufferGeometry() : t2.clone(), e2.updateMatrixWorld(), e2.matrixWorld.decompose(mO, gO, _O), t2.scale(_O.x, _O.y, _O.z), t2;
  }
  function bO(e2) {
    const t2 = e2.attributes.position, n2 = new Float32Array(3 * t2.count);
    for (let e3 = 0; e3 < t2.count; e3++)
      n2[3 * e3] = t2.getX(e3), n2[3 * e3 + 1] = t2.getY(e3), n2[3 * e3 + 2] = t2.getZ(e3);
    return n2;
  }
  function wO(e2, t2) {
    switch (t2) {
      case "x":
        return e2.x;
      case "y":
        return e2.y;
      case "z":
        return e2.z;
    }
    throw new Error(`Unexpected component ${t2}`);
  }
  function AO(e2, t2 = 1e-4) {
    t2 = Math.max(t2, Number.EPSILON);
    const r2 = {}, i2 = e2.getIndex(), s2 = e2.getAttribute("position"), o2 = i2 ? i2.count : s2.count;
    let a2 = 0;
    const l2 = [], c2 = [], u2 = Math.log10(1 / t2), p2 = Math.pow(10, u2);
    for (let e3 = 0; e3 < o2; e3++) {
      const t3 = i2 ? i2.getX(e3) : e3;
      let n2 = "";
      n2 += ~~(s2.getX(t3) * p2) + ",", n2 += ~~(s2.getY(t3) * p2) + ",", n2 += ~~(s2.getZ(t3) * p2) + ",", n2 in r2 ? l2.push(r2[n2]) : (c2.push(s2.getX(t3)), c2.push(s2.getY(t3)), c2.push(s2.getZ(t3)), r2[n2] = a2, l2.push(a2), a2++);
    }
    const d2 = new n.TlE(new Float32Array(c2), s2.itemSize, s2.normalized), h2 = new n.u9r();
    return h2.setAttribute("position", d2), h2.setIndex(l2), h2;
  }
  const xO = Math.PI / 2;
  var EO;
  !function(e2) {
    e2.BOX = "Box", e2.CYLINDER = "Cylinder", e2.SPHERE = "Sphere", e2.HULL = "ConvexPolyhedron", e2.MESH = "Trimesh";
  }(EO || (EO = {}));
  const CO = function(e2, t2 = {}) {
    const r2 = function(e3, t3 = {}) {
      let r3;
      if (t3.type === EO.BOX)
        return MO(e3);
      if (t3.type === EO.CYLINDER)
        return function(e4, t4) {
          const r4 = ["x", "y", "z"], i3 = t4.cylinderAxis || "y", s3 = r4.splice(r4.indexOf(i3), 1) && r4, o3 = new n.ZzF().setFromObject(e4);
          if (!isFinite(o3.min.lengthSq()))
            return null;
          const a3 = o3.max[i3] - o3.min[i3], l3 = 0.5 * Math.max(wO(o3.max, s3[0]) - wO(o3.min, s3[0]), wO(o3.max, s3[1]) - wO(o3.min, s3[1])), c2 = "y" === i3 ? xO : 0, u2 = "z" === i3 ? xO : 0;
          return { type: EO.CYLINDER, params: { radiusTop: l3, radiusBottom: l3, height: a3, segments: 12 }, orientation: new VI().setFromEuler(c2, u2, 0, "XYZ").normalize() };
        }(e3, t3);
      if (t3.type === EO.SPHERE)
        return function(e4, t4) {
          if (t4.sphereRadius)
            return { type: EO.SPHERE, params: { radius: t4.sphereRadius } };
          const n2 = vO(e4);
          return n2 ? (n2.computeBoundingSphere(), { type: EO.SPHERE, params: { radius: n2.boundingSphere.radius } }) : null;
        }(e3, t3);
      if (t3.type === EO.HULL)
        return function(e4) {
          const t4 = vO(e4);
          if (!t4)
            return null;
          const r4 = 1e-4;
          for (let e5 = 0; e5 < t4.attributes.position.count; e5++)
            t4.attributes.position.setXYZ(e5, t4.attributes.position.getX(e5) + (Math.random() - 0.5) * r4, t4.attributes.position.getY(e5) + (Math.random() - 0.5) * r4, t4.attributes.position.getZ(e5) + (Math.random() - 0.5) * r4);
          const [i3, s3] = new fO().setFromObject(new n.Kj0(t4)).toJSON();
          return { type: EO.HULL, params: { vertices: new Float32Array(i3), faces: s3 } };
        }(e3);
      if (t3.type === EO.MESH)
        return r3 = vO(e3), r3 ? function(e4) {
          const t4 = bO(e4);
          if (!t4.length)
            return null;
          const n2 = new Uint32Array(t4.length);
          for (let e5 = 0; e5 < t4.length; e5++)
            n2[e5] = e5;
          return { type: EO.MESH, params: { vertices: t4, indices: n2 } };
        }(r3) : null;
      if (t3.type)
        throw new Error(`[CANNON.getShapeParameters] Invalid type "${t3.type}".`);
      if (r3 = vO(e3), !r3)
        return null;
      switch (r3.type) {
        case "BoxGeometry":
        case "BoxBufferGeometry":
          return SO(r3);
        case "CylinderGeometry":
        case "CylinderBufferGeometry":
          return function(e4) {
            const t4 = e4.parameters;
            return { type: EO.CYLINDER, params: { radiusTop: t4.radiusTop, radiusBottom: t4.radiusBottom, height: t4.height, segments: t4.radialSegments }, orientation: new VI().setFromEuler(n.M8C.degToRad(-90), 0, 0, "XYZ").normalize() };
          }(r3);
        case "PlaneGeometry":
        case "PlaneBufferGeometry":
          return function(e4) {
            e4.computeBoundingBox();
            const t4 = e4.boundingBox;
            return { type: EO.BOX, params: { x: (t4.max.x - t4.min.x) / 2 || 0.1, y: (t4.max.y - t4.min.y) / 2 || 0.1, z: (t4.max.z - t4.min.z) / 2 || 0.1 } };
          }(r3);
        case "SphereGeometry":
        case "SphereBufferGeometry":
          return function(e4) {
            return { type: EO.SPHERE, params: { radius: e4.parameters.radius } };
          }(r3);
        case "TubeGeometry":
        case "BufferGeometry":
          return MO(e3);
        default:
          return console.warn('Unrecognized geometry: "%s". Using bounding box as shape.', r3.type), SO(r3);
      }
    }(e2, t2);
    if (!r2)
      return null;
    const { type: i2, params: s2, offset: o2, orientation: a2 } = r2;
    let l2;
    return l2 = i2 === EO.BOX ? function(e3) {
      const { x: t3, y: n2, z: r3 } = e3;
      return new eR(new BI(t3, n2, r3));
    }(s2) : i2 === EO.CYLINDER ? function(e3) {
      const { radiusTop: t3, radiusBottom: n2, height: r3, segments: i3 } = e3, s3 = new kk(t3, n2, r3, i3);
      return s3.radiusTop = n2, s3.radiusBottom = n2, s3.height = r3, s3.numSegments = i3, s3;
    }(s2) : i2 === EO.SPHERE ? function(e3) {
      return new Rk(e3.radius);
    }(s2) : i2 === EO.HULL ? function(e3) {
      const { faces: t3, vertices: n2 } = e3, r3 = [];
      for (let e4 = 0; e4 < n2.length; e4 += 3)
        r3.push(new BI(n2[e4], n2[e4 + 1], n2[e4 + 2]));
      return new YI({ faces: t3, vertices: r3 });
    }(s2) : function(e3) {
      const { vertices: t3, indices: n2 } = e3;
      return new Nk(t3, n2);
    }(s2), { shape: l2, offset: o2, orientation: a2 };
  };
  function SO(e2) {
    if (!bO(e2).length)
      return null;
    e2.computeBoundingBox();
    const t2 = e2.boundingBox;
    return { type: EO.BOX, params: { x: (t2.max.x - t2.min.x) / 2, y: (t2.max.y - t2.min.y) / 2, z: (t2.max.z - t2.min.z) / 2 } };
  }
  function MO(e2) {
    const t2 = e2.clone();
    t2.quaternion.set(0, 0, 0, 1), t2.updateMatrixWorld();
    const r2 = new n.ZzF().setFromObject(t2);
    if (!isFinite(r2.min.lengthSq()))
      return null;
    const i2 = r2.translate(t2.position.negate()).getCenter(new n.Pa4());
    return { type: EO.BOX, params: { x: (r2.max.x - r2.min.x) / 2, y: (r2.max.y - r2.min.y) / 2, z: (r2.max.z - r2.min.z) / 2 }, offset: i2.lengthSq() ? new BI(i2.x, i2.y, i2.z) : void 0 };
  }
  var TO, PO = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let IO = TO = class extends gt {
    constructor(e2 = false) {
      super(), this._world = new ZB(), this.enabled = true, this.nextSteps = 0, this.stepPhysics = { stepCount: 100, delta: 0.1, step: () => {
        this.nextSteps = this.stepPhysics.stepCount;
      } }, this.makeRootBodies = () => {
        var e3;
        null === (e3 = this._viewer) || void 0 === e3 || e3.scene.modelRoot.children.forEach((e4) => {
          this.makeBody(e4);
        });
      }, this._bodyMeshMap = /* @__PURE__ */ new Map(), this._movementPlane = new n.Kj0(new n._12(100, 100), new n.vBJ({ color: 65280, side: n.ehD })), this.enabled = e2, this._world.gravity.set(0, -9.81, 0);
      const t2 = new Dk(), r2 = new rR({ mass: 0, position: new BI(0, -2, 0) });
      r2.addShape(t2), r2.quaternion.setFromEuler(-Math.PI / 2, 0, 0), this._ground = r2, this._world.addBody(r2);
      const i2 = new Rk(0.1);
      this._jointBody = new rR({ mass: 0 }), this._jointBody.addShape(i2), this._jointBody.collisionFilterGroup = 0, this._jointBody.collisionFilterMask = 0, this._world.addBody(this._jointBody);
    }
    async onAdded(e2) {
      await super.onAdded(e2);
      const t2 = new n.Pa4(), r2 = new n.Pa4(), i2 = new n.Pa4(), s2 = new n._fP(), o2 = new n._fP(), a2 = new n.yGw(), l2 = new n.yGw();
      let c2 = false, u2 = false;
      function p2(t3) {
        const r3 = e2.canvas.getBoundingClientRect(), i3 = new n.FM8();
        return i3.x = (t3.clientX - r3.x) / r3.width * 2 - 1, i3.y = -(t3.clientY - r3.y) / r3.height * 2 + 1, i3;
      }
      e2.addEventListener("preFrame", () => {
        const n2 = e2.getPlugin(Gg), p3 = e2.getPlugin(Po);
        if (!this.enabled) {
          if (!(this.nextSteps > 0))
            return n2 && c2 && (n2.enableRefreshTransform = true, c2 = false), p3 && u2 && (p3.enable(TO.PluginType), u2 = false), void (this._dirty = false);
          this.enabled = true;
        }
        if (n2 && n2.enableRefreshTransform && !c2 && (n2.enableRefreshTransform = false, c2 = true), p3 && !u2 && p3.disable(TO.PluginType), this.nextSteps > 0)
          for (let e3 = 0; e3 < this.stepPhysics.stepCount; e3++)
            this._world.step(this.stepPhysics.delta);
        else
          this._world.fixedStep();
        this._dirty = false;
        let d2 = false;
        for (const e3 of this._world.bodies) {
          if (0 === e3.mass)
            continue;
          const n3 = this._bodyMeshMap.get(e3);
          if (n3 && (n3.updateMatrixWorld(), n3.getWorldPosition(r2), n3.getWorldQuaternion(o2), n3.getWorldScale(i2), r2.manhattanDistanceTo(t2.copy(e3.position)) > 0 && (d2 = true), o2.angleTo(s2.copy(e3.quaternion)) > 0 && (d2 = true), d2)) {
            if (a2.compose(t2, s2, i2), !n3.parent)
              throw new Error("no parent");
            l2.copy(n3.parent.matrixWorld).invert(), l2.multiply(a2), l2.decompose(t2, s2, i2), n3.position.copy(t2), n3.quaternion.copy(s2);
          }
        }
        this._dirty = d2, e2.setDirty(), e2.renderer.resetShadows(), null == n2 || n2.bakeShadows(), this.nextSteps > 0 && (this.enabled = false, this.nextSteps = 0);
      }), e2.scene.addEventListener("update", (e3) => {
        this._bodyMeshMap.forEach((e4, t3) => {
          t3.velocity.set(0, 0, 0), t3.angularVelocity.set(0, 0, 0);
        });
      }), e2.scene.addEventListener("addSceneObject", (e3) => {
        var t3;
        const n2 = null === (t3 = e3.object) || void 0 === t3 ? void 0 : t3.modelObject;
        n2 && n2.traverse((e4) => {
          const t4 = e4.uiConfig;
          t4 && Array.isArray(t4.children) && (t4.children.push({ type: "folder", label: "Physics", children: [{ type: "button", label: "Make Body", value: () => this.makeBody(e4) }, { type: "number", label: "Mass", hidden: () => !e4._physicsBody, getValue: () => {
            var t5, n3;
            return null !== (n3 = null === (t5 = e4._physicsBody) || void 0 === t5 ? void 0 : t5.mass) && void 0 !== n3 ? n3 : 0;
          }, setValue: (t5) => {
            e4._physicsBody && (e4._physicsBody.mass = t5);
          } }] }), void 0 !== e4.userData.physicsMass && this.makeBody(e4));
        });
      }), e2.canvas.addEventListener("pointerdown", (t3) => {
        if (!this.enabled)
          return;
        if (!t3.isPrimary)
          return;
        e2.getPlugin(za) && (e2.getPlugin(za).enabled = false);
        const r3 = p2(t3), i3 = new n.iMs();
        i3.setFromCamera(r3, e2.scene.activeCamera.cameraObject);
        const s3 = i3.intersectObjects([...this._bodyMeshMap.values()], true);
        if (!s3.length)
          return;
        let o3, a3 = null, l3 = s3[0];
        for (const e3 of s3) {
          for (a3 = e3.object, l3 = e3; !(null == a3 || a3.visible && a3.material); )
            a3 = a3.parent;
          if (a3)
            break;
        }
        if (!a3)
          return;
        for (; a3.parent && !o3; ) {
          for (const [e3, t4] of this._bodyMeshMap.entries())
            if (t4 === a3) {
              e3.mass > 0 && (o3 = e3);
              break;
            }
          a3 = a3.parent;
        }
        if (!o3)
          return;
        e2.scene.activeCamera.setInteractions(false, TO.PluginType), this._movementPlane.position.copy(l3.point), this._movementPlane.lookAt(e2.scene.activeCamera.cameraObject.getWorldPosition(new n.Pa4()));
        const c3 = new BI().copy(l3.point).vsub(o3.position), u3 = o3.quaternion.inverse().vmult(c3);
        this._jointBody.position.copy(l3.point), this._jointConstraint = new Ck(o3, u3, this._jointBody, new BI(0, 0, 0)), this._world.addConstraint(this._jointConstraint);
      }), e2.canvas.addEventListener("pointermove", (t3) => {
        if (!this.enabled)
          return;
        if (!t3.isPrimary)
          return;
        if (!this._jointConstraint)
          return;
        const r3 = p2(t3), i3 = new n.iMs();
        i3.setFromCamera(r3, e2.scene.activeCamera.cameraObject);
        const s3 = i3.intersectObject(this._movementPlane);
        if (!s3.length)
          return;
        const o3 = s3[0];
        this._jointBody.position.copy(o3.point), this._jointConstraint.update();
      }), e2.canvas.addEventListener("pointerup", (t3) => {
        this.enabled && t3.isPrimary && (e2.getPlugin(za) && (e2.getPlugin(za).enabled = true), e2.scene.activeCamera.setInteractions(true, TO.PluginType), this._jointConstraint && (this._world.removeConstraint(this._jointConstraint), this._jointConstraint = void 0));
      });
    }
    makeBody(e2) {
      if (e2.isLight)
        return;
      if (e2._physicsBody)
        return;
      const t2 = [];
      let r2 = 0;
      if (e2.updateMatrixWorld(), e2.traverse((e3) => {
        var n2;
        const i3 = e3;
        if (!i3.isMesh)
          return;
        if (!i3.material)
          return;
        if (!i3.visible)
          return;
        if (i3._physicsShape)
          return void t2.push(i3._physicsShape);
        if (r2 += null !== (n2 = i3.userData.physicsMass) && void 0 !== n2 ? n2 : 1, i3.addEventListener("objectUpdate", () => {
          0 === i3.userData.physicsMass && (this._ground.position.y = i3.position.y, this._bodyMeshMap.forEach((e4, t3) => {
            t3.velocity.set(0, 0, 0), t3.angularVelocity.set(0, 0, 0), t3.force.set(0, 0, 0), t3.torque.set(0, 0, 0);
          }));
        }), 0 === i3.userData.physicsMass)
          return;
        const s3 = CO(i3, { type: EO.HULL });
        s3 ? (t2.push([s3.shape, i3]), i3._physicsShape = s3.shape) : console.warn("Failed to convert mesh to cannon shape", i3);
      }), !t2.length)
        return;
      const i2 = new rR({ mass: r2, angularVelocity: new BI(0, 0, 0), velocity: new BI(0, 0, 0) }), s2 = new n.Pa4(), o2 = new n._fP(), a2 = new n.Pa4(), l2 = new n.yGw();
      for (const [n2, r3] of t2)
        r3 !== e2 ? (r3.updateMatrixWorld(), l2.copy(e2.matrixWorld).invert(), l2.multiply(r3.matrixWorld), l2.decompose(s2, o2, a2), i2.addShape(n2, new BI(...s2.toArray()), new VI(...o2.toArray()))) : i2.addShape(n2);
      i2.position.set(...e2.getWorldPosition(s2).toArray()), i2.quaternion.set(...e2.getWorldQuaternion(o2).toArray()), i2.angularVelocity.set(0, 0, 0), i2.velocity.set(0, 0, 0), e2.addEventListener("objectUpdate", () => {
        i2.position.set(...e2.getWorldPosition(s2).toArray()), i2.quaternion.set(...e2.getWorldQuaternion(o2).toArray()), i2.angularVelocity.set(0, 0, 0), i2.velocity.set(0, 0, 0);
      }), this._world.addBody(i2), this._bodyMeshMap.set(i2, e2), e2._physicsBody = i2, e2.setDirty({ sceneUpdate: true, updateGround: false, frameFade: false, refreshUi: true });
    }
  };
  IO.PluginType = "CannonPhysics", PO([Oe("Enabled", (e2) => ({ onChange: () => {
  } })), ie()], IO.prototype, "enabled", void 0), PO([Be()], IO.prototype, "stepPhysics", void 0), PO([je("Make Root Bodies")], IO.prototype, "makeRootBodies", void 0), IO = TO = PO([We("Physics (dev)")], IO);
  var RO = __webpackgi_require__2(819), kO = __webpackgi_require__2(665);
  const DO = (e2, t2, n2) => {
    var r2, i2;
    const s2 = e2.controller_, o2 = null === (i2 = null === (r2 = s2.parent) || void 0 === r2 ? void 0 : r2.children) || void 0 === i2 ? void 0 : i2.indexOf(s2), a2 = ((e3, t3) => t3.controller_.rackController.rack === e3.controller_.parent)(e2, t2);
    return !(a2 && o2 === n2 || (t2.add(e2, n2), 0));
  }, BO = (e2, n2, r2, i2) => {
    var s2, o2, a2, l2, c2;
    let u2 = n2.uiRef;
    (null == u2 ? void 0 : u2.controller_.viewProps.get("disposed")) && (u2 = void 0);
    const p2 = null == u2 ? void 0 : u2.expanded;
    if (!u2) {
      const r3 = e2.addFolder({ title: "" });
      u2 = r3, u2.on("fold", (e3) => {
        var i3, s3, o3, a3;
        let l3 = r3.expanded;
        (0, t.safeSetProperty)(n2, "expanded", l3, true), l3 = null !== (i3 = (0, t.getOrCall)(n2.expanded)) && void 0 !== i3 ? i3 : l3, l3 !== r3.expanded && (r3.expanded = l3), null === (s3 = n2.uiRefresh) || void 0 === s3 || s3.call(n2, "postFrame", true, 10), l3 ? null === (o3 = n2.onExpand) || void 0 === o3 || o3.call(n2, n2) : null === (a3 = n2.onCollapse) || void 0 === a3 || a3.call(n2, n2);
      });
    }
    if (!u2)
      return u2;
    u2.expanded = null !== (o2 = null !== (s2 = (0, t.getOrCall)(n2.expanded)) && void 0 !== s2 ? s2 : p2) && void 0 !== o2 && o2;
    const d2 = (null !== (a2 = n2.children) && void 0 !== a2 ? a2 : []).map((e3) => e3 && (0, t.getOrCall)(e3)).flat(2).filter((e3) => e3);
    let h2 = 0;
    for (const e3 of d2) {
      if (Array.isArray(e3) || "object" != typeof e3) {
        console.error("child is not an object", e3);
        continue;
      }
      let t2 = e3.uiRef;
      t2 && t2.controller_.viewProps.get("disposed") && (e3.uiRef = void 0, e3.uiRefresh = void 0), t2 = e3.uiRef, t2 || (r2.appendUiObject({ uiConfig: e3 }, u2), t2 = e3.uiRef), t2 && DO(t2, u2, h2++) && r2.appendUiObject({ uiConfig: e3 }, u2);
    }
    let f2 = u2.children;
    for (; f2.length > h2; ) {
      const e3 = f2[f2.length - 1];
      u2.remove(e3), e3.dispose(), f2 = u2.children;
    }
    u2.controller_.props.set("title", null !== (l2 = (0, t.getOrCall)(n2.label)) && void 0 !== l2 ? l2 : "");
    const m2 = u2.controller_.view.containerElement, _2 = (0, t.getOrCall)(n2.domChildren, []);
    if (void 0 !== (null == _2 ? void 0 : _2.length)) {
      const e3 = [];
      for (let t2 = 0; t2 < m2.children.length; t2++) {
        const n3 = m2.children[t2];
        (null === (c2 = n3.dataset) || void 0 === c2 ? void 0 : c2.tpCustomDOM) && e3.push(n3);
      }
      for (const t2 of e3)
        m2.removeChild(t2);
      for (const e4 of _2)
        e4.parentElement !== m2 && (m2.appendChild(e4), e4.dataset.tpCustomDOM = "true");
      u2.controller_.foldable.cleanUpTransition();
    }
    return u2;
  }, OO = (e2, n2, r2, i2) => {
    var s2, o2;
    const [a2, l2] = null !== (s2 = n2.property) && void 0 !== s2 ? s2 : [void 0, void 0], c2 = null !== (o2 = (0, t.getOrCall)(n2.label)) && void 0 !== o2 ? o2 : l2;
    let u2 = n2.uiRef;
    return (null == u2 ? void 0 : u2.controller_.viewProps.get("disposed")) && (u2 = void 0), u2 || (u2 = e2.addButton({ title: "" }), u2.on("click", async () => {
      const e3 = [];
      n2.prompt && e3.push(await r2.prompt(...n2.prompt));
      let t2 = a2 && l2 ? a2[l2] : void 0, i3 = a2;
      if (t2 || (t2 = n2.value, i3 = n2), "function" == typeof t2) {
        const s3 = () => {
          r2.removeEventListener("postFrame", s3), t2.call(null != i3 ? i3 : n2, ...e3);
        };
        r2.addEventListener("postFrame", s3);
      } else
        console.warn("uiconfig.js: Invalid action type for button");
    })), u2 && (u2.title = (null != c2 ? c2 : "click me") + ""), u2;
  }, LO = (e2, n2, r2, i2) => {
    var s2;
    const o2 = Object.fromEntries((null !== (s2 = (0, t.getOrCall)(n2.children)) && void 0 !== s2 ? s2 : []).map((e3) => (0, t.getOrCall)(e3)).flat(2).filter((e3) => e3).map((e3) => {
      var n3;
      const r3 = (0, t.getOrCall)(e3.label);
      return [r3, null !== (n3 = e3.value) && void 0 !== n3 ? n3 : r3];
    }));
    return jO(e2, n2, r2, { options: o2, ...null != i2 ? i2 : {} });
  }, UO = (e2, n2, r2, i2) => {
    var s2, o2;
    const a2 = (0, t.getOrCall)(n2.bounds), l2 = (null !== (s2 = null == a2 ? void 0 : a2.length) && void 0 !== s2 ? s2 : 0) >= 2 ? a2[1] : 1, c2 = (null !== (o2 = null == a2 ? void 0 : a2.length) && void 0 !== o2 ? o2 : 0) >= 1 ? a2[0] : 0, u2 = n2.stepSize || void 0;
    return jO(e2, n2, r2, { min: c2, max: l2, step: u2, ...null != i2 ? i2 : {} });
  }, FO = (e2, r2, i2, s2) => {
    var o2, a2, l2;
    const c2 = (0, t.getOrCall)(r2.bounds);
    if (!c2 || c2.length < 1)
      return jO(e2, r2, i2, { ...null != s2 ? s2 : {} });
    const u2 = (null !== (o2 = c2.length) && void 0 !== o2 ? o2 : 0) >= 2 ? c2[1] : 1, p2 = (null !== (a2 = c2.length) && void 0 !== a2 ? a2 : 0) >= 1 ? c2[0] : 0, d2 = { min: p2, max: u2, step: null !== (l2 = r2.stepSize) && void 0 !== l2 ? l2 : (u2 - p2) / 100 }, h2 = { x: d2, y: d2 };
    "vec3" !== r2.type && "vec4" !== r2.type || (h2.z = d2), "vec4" === r2.type && (h2.w = d2);
    const f2 = r2.property;
    if (void 0 === r2.value && f2 && f2[0] && "object" == typeof f2[0] && f2[0][f2[1]] && Array.isArray(f2[0][f2[1]])) {
      const [e3, t2] = f2, i3 = e3[t2], s3 = i3.length, o3 = new (2 === s3 ? n.FM8 : 3 === s3 ? n.Pa4 : n.Ltg)().fromArray(i3);
      r2.value = o3, r2.property = void 0, r2.onChange = [() => {
        e3[t2] = o3.toArray();
      }, ...Array.isArray(r2.onChange) ? r2.onChange : [r2.onChange]].filter((e4) => e4), void 0 === r2.label && (r2.label = t2);
    }
    return jO(e2, r2, i2, { ...h2, ...null != s2 ? s2 : {} });
  }, NO = (e2, r2, i2, s2) => {
    var o2;
    const a2 = r2.property;
    if (void 0 === r2.value && a2 && "object" == typeof a2[0] && (null === (o2 = a2[0][a2[1]]) || void 0 === o2 ? void 0 : o2.isColor)) {
      const [e3, t2] = a2, i3 = n.KI_;
      Object.defineProperty(r2, "value", { get: () => {
        const r3 = e3[t2];
        return r3 ? new n.Ilk(r3).getHex(i3) : 0;
      }, set: (r3) => {
        const s3 = e3[t2], o3 = new n.Ilk().setHex(r3, i3);
        s3.isColor ? s3.copy(o3) : "number" == typeof s3 ? e3[t2] = o3.getHex() : "string" == typeof s3 && (e3[t2] = "#" + o3.getHexString()), "function" == typeof (null == e3 ? void 0 : e3.setDirty) && e3.setDirty();
      } }), r2.property = void 0, r2.onChange = [...Array.isArray(r2.onChange) ? r2.onChange : [r2.onChange]].filter((e4) => e4), void 0 === r2.label && (r2.label = t2 + "");
    }
    return (s2 = null != s2 ? s2 : {}).view = "color", (0, t.getOrCall)(r2.inlinePicker) && (s2.picker = "inline"), jO(e2, r2, i2, s2);
  }, jO = (e2, n2, r2, i2) => {
    var s2, o2, a2, l2, c2, u2, p2;
    let d2 = (0, t.getOrCall)(n2.property);
    if ((n2.getValue || n2.setValue) && d2 && console.error("specify either property or value, or getValue and setValue", n2), d2)
      n2.value && console.warn("uiconfig.js: Both property and value are defined, value will be ignored", n2);
    else if ((Object.hasOwn ? Object.hasOwn(n2, "value") : n2.hasOwnProperty("value")) || void 0 !== n2.value || !n2.getValue && !n2.setValue || (Object.defineProperty(n2, "value", { get: () => {
      var e3;
      return null === (e3 = n2.getValue) || void 0 === e3 ? void 0 : e3.call(n2);
    }, set: (e3) => {
      var t2;
      return null === (t2 = n2.setValue) || void 0 === t2 ? void 0 : t2.call(n2, e3);
    } }), d2 = [n2, "value"]), d2 || void 0 === n2.value || (d2 = [n2, "value"]), !d2)
      return void console.error("cannot determine property", n2);
    i2 = null != i2 ? i2 : {};
    const h2 = { label: null !== (s2 = (0, t.getOrCall)(n2.label)) && void 0 !== s2 ? s2 : d2[1], ...i2 };
    let f2 = n2.uiRef;
    if ((null == f2 ? void 0 : f2.controller_.viewProps.get("disposed")) && (f2 = void 0), !f2 && "object" == typeof d2[0] && d2[0]) {
      const [t2, r3] = d2;
      try {
        f2 = n2.isMonitor ? e2.addMonitor(t2, r3, h2) : e2.addInput(t2, r3, h2).on("change", (e3) => {
          [n2.onChange].flat().forEach((t3) => "function" == typeof t3 && (null == t3 ? void 0 : t3(e3))), "function" == typeof (null == t2 ? void 0 : t2.setDirty) && t2.setDirty(e3);
        });
      } catch (e3) {
        if (!e3.message.startsWith("No matching controller for"))
          throw e3;
        f2 = void 0;
      }
    }
    if (f2) {
      for (const [e3, t2] of Object.entries(h2)) {
        const n3 = f2.controller_;
        let r3 = n3.props.value(e3);
        if (void 0 !== r3)
          r3.rawValue !== t2 && f2.controller_.props.set(e3, t2);
        else {
          const i3 = n3.valueController;
          r3 = null === (a2 = null === (o2 = i3.props) || void 0 === o2 ? void 0 : o2.value) || void 0 === a2 ? void 0 : a2.call(o2, e3);
          let s3 = t2;
          const u3 = null == r3 ? void 0 : r3.rawValue;
          let p3 = false;
          "options" === e3 && "object" == typeof s3 && !Array.isArray(s3) && Array.isArray(u3) && (s3 = Object.entries(s3).map(([e4, t3]) => ({ text: e4, value: t3 })), p3 = true), void 0 === r3 || u3 === s3 || p3 && f2.__lastOptions === t2 || (i3.props.set(e3, s3), p3 && (null === (c2 = null === (l2 = i3.view) || void 0 === l2 ? void 0 : l2.update_) || void 0 === c2 || c2.call(l2), f2.__lastOptions = t2));
        }
      }
      "slider" === n2.type && (void 0 !== h2.min && f2.controller_.valueController.sliderController.props.set("minValue", h2.min), void 0 !== h2.max && f2.controller_.valueController.sliderController.props.set("maxValue", h2.max)), null === (u2 = (null == f2 ? void 0 : f2.controller_.valueController.view).inputElement) || void 0 === u2 || u2.setAttribute("placeholder", null !== (p2 = (0, t.getOrCall)(n2.placeholder)) && void 0 !== p2 ? p2 : ""), f2.refresh();
    }
    return f2;
  };
  class zO extends t.SimpleEventDispatcher {
    constructor(e2 = false, t2 = false, n2 = false, r2 = true, i2 = document.body) {
      super(), this._refreshQueue = { preRender: [], postRender: [], preFrame: [], postFrame: [] }, this._lastModeTime = { preRender: 0, postRender: 0, preFrame: 0, postFrame: 0 }, this._typeGenerators = { panel: BO, folder: BO, input: jO, number: jO, slider: UO, dropdown: LO, checkbox: jO, color: NO, vec: FO, vec2: FO, vec3: FO, vec4: FO, button: OO, monitor: (e3, t3, n3, r3) => (t3.isMonitor = true, jO(e3, t3, n3, r3)), dummy: (e3, t3, n3, r3) => jO(e3, t3, n3, r3) }, this.alert = async (e3) => alert(e3), this.confirm = async (e3) => confirm(e3), this.prompt = async (e3, t3, n3 = true) => prompt(e3, t3), this._expand = e2, this._limitedOptions = n2;
      const s2 = this._createUiContainer();
      i2.appendChild(s2), this._container = i2, this._pane = new kO.Pane({ title: "Configuration", container: s2 }), this._pane.expanded = this._expand, r2 && (this.addEventListener("postFrame", () => this.refreshQueue("postFrame")), setTimeout(() => {
        this.dispatchEvent({ type: "postFrame" });
      }, 32));
    }
    refreshQueue(e2) {
      const n2 = this._refreshQueue[e2], r2 = [], i2 = (0, t.now)(), s2 = i2 - this._lastModeTime[e2];
      n2.forEach((e3) => {
        e3[2] > 1e-3 ? (e3[2] -= s2, r2.push(e3)) : this._refreshUiObject(e3[0], e3[1], e3[2]);
      }), this._refreshQueue[e2] = r2, this._lastModeTime[e2] = i2;
    }
    addToRefreshQueue(e2, t2) {
      var n2;
      const r2 = null === (n2 = t2[0]) || void 0 === n2 ? void 0 : n2.uiConfig, i2 = null == r2 ? void 0 : r2.uuid, s2 = this._refreshQueue[e2], o2 = s2.find((e3) => e3[3] === i2);
      o2 ? o2[2] = Math.max(o2[2], t2[2]) : s2.push([...t2, i2]), this._refreshQueue[e2] = s2;
    }
    dispose() {
      var e2;
      null === (e2 = this._pane) || void 0 === e2 || e2.dispose(), this._pane = void 0;
    }
    appendUiObject(e2, t2) {
      e2 && this._appendUiObject(e2, t2);
    }
    _appendUiObject(e2, n2) {
      var r2, i2, s2, o2;
      const { uiConfig: a2 } = null != e2 ? e2 : {};
      if (a2 && (!this._limitedOptions || a2.limitedUi) && (n2 = null != n2 ? n2 : this._pane, a2.type)) {
        a2.uuid || (a2.uuid = ke()), a2.uiRef && a2.uiRefType !== a2.type && this.removeUiConfig(a2);
        const l2 = null === (i2 = (r2 = this._typeGenerators)[a2.type]) || void 0 === i2 ? void 0 : i2.call(r2, n2, a2, this);
        l2 && (l2.hidden = null !== (s2 = (0, t.getOrCall)(a2.hidden)) && void 0 !== s2 && s2, l2.disabled = null !== (o2 = (0, t.getOrCall)(a2.disabled)) && void 0 !== o2 && o2), a2.uiRef = l2, a2.uiRefType = l2 ? a2.type : void 0, a2.uiRefresh = (t2 = "postFrame", r3 = false, i3 = 0) => {
          var s3;
          return this._uiObjectRefresh(t2, null !== (s3 = null == e2 ? void 0 : e2.uiConfig) && void 0 !== s3 ? s3 : a2, n2, r3, i3);
        }, null == l2 || l2.controller_.viewProps.handleDispose(() => {
          a2.uiRef = void 0, a2.uiRefType = void 0, a2.uiRefresh = void 0;
        });
      }
    }
    removeUiObject(e2) {
      this.removeUiConfig(null == e2 ? void 0 : e2.uiConfig);
    }
    removeUiConfig(e2) {
      var t2, n2;
      e2 && e2.uiRef && (null === (n2 = (t2 = e2.uiRef).dispose) || void 0 === n2 || n2.call(t2), e2.uiRef = void 0, e2.uiRefType = void 0, e2.uiRefresh = void 0);
    }
    _uiObjectRefresh(e2, t2, n2, r2, i2) {
      (r2 ? GO(t2, n2) : [{ uiConfig: t2, parentFolder: n2 }]).forEach((t3) => {
        const n3 = [{ uiConfig: t3.uiConfig }, t3.parentFolder, i2];
        "immediate" === e2 ? this._refreshUiObject(...n3) : this.addToRefreshQueue(e2, n3);
      });
    }
    _refreshUiObject(e2, t2, n2 = 0) {
      this._appendUiObject(e2, t2), n2 > 1e-4 && console.error("no support for immediate delay");
    }
    _createUiContainer() {
      const e2 = (0, t.createDiv)({ id: "tweakpaneUiContainer", addToBody: false });
      return (0, t.createStyles)(t.css`
          :root{
            --tweakpane-ui-container-width: 300px;
          }
          @media only screen and (min-width: 1500px) {
            :root{
              --tweakpane-ui-container-width: 300px;
            }
          }
          @media only screen and (min-width: 2500px) {
            :root{
              --tweakpane-ui-container-width: 500px;
            }
          }
          #tweakpaneUiContainer {
            position: fixed;
            top: 0px;
            padding-right: 4px;
            padding-bottom: 10px;
            right: 10px;
            width: var(--tweakpane-ui-container-width);
            height: auto;
            overflow-y: scroll;
            z-index: 100;
            pointer-events: auto;
            max-height: calc(100% - 6rem);
            border-radius: 0.5rem;
            font-family: Inter, ui-sans-serif, system-ui, -apple-system, "system-ui", "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
          }
        `), e2;
    }
  }
  function GO(e2, t2, n2) {
    return n2 = null != n2 ? n2 : [], e2 && e2.uiRef ? (n2.push({ uiConfig: e2, parentFolder: t2 }), "function" == typeof e2.children || [...e2.children || []].forEach((t3) => {
      "function" != typeof t3 && t3 && (Array.isArray(t3) ? t3.forEach((t4) => n2 = GO(t4, e2.uiRef, n2)) : n2 = GO(t3, e2.uiRef, n2));
    }), n2) : n2;
  }
  var VO = __webpackgi_require__2(898), HO = {};
  VO.Z && VO.Z.locals && (HO.locals = VO.Z.locals);
  var QO, WO = 0, qO = {};
  qO.styleTagTransform = uc(), qO.setAttributes = oc(), qO.insert = function(e2, t2) {
    (t2.target || document.head).appendChild(e2);
  }, qO.domAPI = ic(), qO.insertStyleElement = lc(), HO.use = function(e2) {
    return qO.options = e2 || {}, WO++ || (QO = nc()(VO.Z, qO)), HO;
  }, HO.unuse = function() {
    WO > 0 && !--WO && (QO(), QO = null);
  };
  var XO = HO;
  class YO extends zO {
    constructor(e2 = false, t2 = false, n2 = false, r2, i2) {
      var s2, o2;
      super(e2, t2, n2, false, null !== (s2 = null != r2 ? r2 : document.getElementById("tweakpaneMainPanelSlot")) && void 0 !== s2 ? s2 : document.body), this.dependencies = [Ls], this._preRender = () => this.refreshQueue("preRender"), this._postRender = () => this.refreshQueue("postRender"), this._postFrame = (e3) => {
        this.dispatchEvent(e3), this.refreshQueue("postFrame");
      }, this._preFrame = () => this.refreshQueue("preFrame"), this._plugins = [], this.alert = async (e3) => this._viewer ? this._viewer.alert(e3) : super.alert(e3), this.confirm = async (e3) => this._viewer ? this._viewer.confirm(e3) : super.confirm(e3), this.prompt = async (e3, t3, n3 = true) => this._viewer ? this._viewer.prompt(e3, t3, n3) : super.prompt(e3, t3, n3), this._pane.registerPlugin(RO), XO.use({ target: this._container }), this.colorMode = null !== (o2 = null != i2 ? i2 : localStorage ? localStorage.getItem("tpTheme") : "blue") && void 0 !== o2 ? o2 : "blue";
    }
    async onAdded(e2) {
      this._viewer = e2, this._typeGenerators.image = ((e3) => (r2, i2, s2, o2) => {
        let a2 = i2.property || i2.__property;
        const l2 = "placeholder";
        if (void 0 === i2.value && (i2.getValue || i2.setValue) && (Object.defineProperty(i2, "_value", { get: () => {
          var e4;
          return null === (e4 = i2.getValue) || void 0 === e4 ? void 0 : e4.call(i2);
        }, set: (e4) => {
          var t2;
          return null === (t2 = i2.setValue) || void 0 === t2 ? void 0 : t2.call(i2, e4);
        } }), a2 = [i2, "_value"]), (!(Object.hasOwn ? Object.hasOwn(i2, "value") : i2.hasOwnProperty("value")) || void 0 === i2.value) && a2 && "object" == typeof a2[0]) {
          const [r3, s3] = a2, o3 = (0, t.makeTextSvg)("Render Target"), c2 = (0, t.makeTextSvg)("Data Texture"), u2 = (0, t.makeTextSvg)("CUBE Texture"), p2 = (0, t.makeTextSvg)("Compressed Texture"), d2 = {}, h2 = {};
          Object.defineProperty(i2, "value", { get: () => {
            var n2;
            let i3, a3 = r3[s3];
            if ((null == a3 ? void 0 : a3.get) && (a3 = a3.get()), !a3)
              return l2;
            if (a3.isCompressedTexture && a3.image && !a3.image.tp_src && (a3.image.tp_src = p2), a3.isTexture ? (a3.image && !a3.image.tp_src && (a3.image instanceof ImageBitmap || a3.image instanceof HTMLImageElement || a3.image instanceof HTMLVideoElement) ? a3.image.tp_src = (0, t.imageBitmapToBase64)(a3.image, 160) : a3.image && a3.isRenderTargetTexture && !a3.image.tp_src ? a3.__target && (a3.tp_src = e3.renderer.renderTargetToDataUrl(a3.__target, void 0, void 0, Array.isArray(a3.__target.texture) ? a3.__target.texture.indexOf(a3) : void 0)) : a3.image && !a3.image.tp_src && (a3.image.tp_src = ee(a3, 160, false).toDataURL("image/png", 90)), !a3.isRenderTargetTexture || a3.image.tp_src || a3.tp_src || (a3.image.tp_src = o3), a3.isDataTexture && a3.image && !a3.image.tp_src && (a3.image.tp_src = c2), a3.image && (i3 = a3.image.tp_src_uuid, i3 = i3 ? d2[i3] : void 0, i3 || (i3 = a3.image.tp_src || a3.image.src)), a3.tp_src && (i3 = a3.tp_src)) : "string" == typeof a3 ? i3 = a3 : a3.domainMin ? (i3 = a3.texture, a3.texture.image && !a3.texture.image.tp_src && (a3.texture.image.tp_src = u2), a3.texture.image && (i3 = a3.texture.image.tp_src_uuid, i3 = i3 ? d2[i3] : void 0, i3 || (i3 = a3.texture.image.tp_src || a3.texture.image.src))) : a3 && console.error("unknown value", a3), i3 || (i3 = l2), a3.image && !a3.image.tp_src_uuid) {
              const e4 = ke();
              a3.image.tp_src_uuid = e4, h2[i3] = e4;
            }
            return "string" == typeof i3 && (i3 = null !== (n2 = d2[i3]) && void 0 !== n2 ? n2 : i3), i3;
          }, set: (t2) => {
            var o4, a3, c3, u3, p3, f2, m2, _2, g2, v2, y2;
            const b2 = r3[s3], w2 = (e4) => {
              var t3;
              r3[s3] = e4, (null == e4 ? void 0 : e4.isTexture) && (e4.flipY = e4.isDataTexture ? e4.flipY : null === (t3 = null == b2 ? void 0 : b2.flipY) || void 0 === t3 || t3);
            };
            if ("string" == typeof t2)
              return void ("string" == typeof b2 && w2(t2));
            if (!t2)
              return void (i2.value = l2);
            if (t2.isPlaceholder)
              return void (b2 && (w2("string" == typeof b2 ? "" : null), "function" == typeof (null == r3 ? void 0 : r3.setDirty) && r3.setDirty()));
            let A2 = t2.tp_src_uuid;
            if (A2 || (A2 = null !== (o4 = t2.src) && void 0 !== o4 ? o4 : t2.tp_src, A2 = null !== (a3 = h2[A2]) && void 0 !== a3 ? a3 : A2, delete h2[A2], t2.tp_src_uuid = A2), A2 && (d2[A2] = t2), "string" != typeof b2) {
              if (!((null == b2 ? void 0 : b2.image) === t2 || (null === (c3 = null == b2 ? void 0 : b2.image) || void 0 === c3 ? void 0 : c3.src) === t2.src || (null === (u3 = null == b2 ? void 0 : b2.image) || void 0 === u3 ? void 0 : u3.tp_src) === t2.tp_src && null != t2.tp_src || (null === (p3 = null == b2 ? void 0 : b2.image) || void 0 === p3 ? void 0 : p3.tp_src) === t2.src && null != t2.src || (null === (f2 = null == b2 ? void 0 : b2.image) || void 0 === f2 ? void 0 : f2.src) === t2.tp_src && null != t2.tp_src))
                if (t2 instanceof File) {
                  const n2 = null == e3 ? void 0 : e3.getPlugin(Ls);
                  if (!n2)
                    throw "Viewer or AssetManagerPlugin not found";
                  null === (m2 = n2.importer) || void 0 === m2 || m2.importSingle({ file: t2, path: t2.src }).then((e4) => {
                    var n3, s4, o5, a4;
                    if (e4) {
                      e4.isDataTexture && (e4.needsUpdate = true);
                      const l3 = null === (o5 = null === (s4 = null === (n3 = t2.src) || void 0 === n3 ? void 0 : n3.split("?")) || void 0 === s4 ? void 0 : s4[0]) || void 0 === o5 ? void 0 : o5.split(".").pop();
                      e4.userData && (e4.userData.mimeType || (e4.userData.mimeType = "image/" + (["jpg", "jpeg"].includes(l3) ? "jpeg" : "png"))), w2(e4), [i2.onChange].flat().forEach((e5) => "function" == typeof e5 && (null == e5 ? void 0 : e5())), "function" == typeof (null == r3 ? void 0 : r3.setDirty) && r3.setDirty(), null === (a4 = i2.uiRefresh) || void 0 === a4 || a4.call(i2, "postFrame", false);
                    }
                  });
                } else {
                  const e4 = new n.xEZ(t2);
                  e4.assetType = "texture", e4.needsUpdate = true;
                  const o5 = null === (v2 = null === (g2 = null === (_2 = t2.src) || void 0 === _2 ? void 0 : _2.split("?")) || void 0 === g2 ? void 0 : g2[0]) || void 0 === v2 ? void 0 : v2.split(".").pop();
                  e4.userData.mimeType || (e4.userData.mimeType = "image/" + (["jpg", "jpeg"].includes(o5) ? "jpeg" : "png"));
                  const a4 = ["normalMap", "aoMap", "emissiveMap", "roughnessMap", "metalnessMap", "displacementMap", "bumpMap", "alphaMap"].includes(s3);
                  e4.colorSpace = a4 ? n.GUF : n.KI_, e4.wrapS = n.rpg, e4.wrapT = n.rpg, w2(e4), [i2.onChange].flat().forEach((e5) => "function" == typeof e5 && (null == e5 ? void 0 : e5())), "function" == typeof (null == r3 ? void 0 : r3.setDirty) && r3.setDirty(), null === (y2 = i2.uiRefresh) || void 0 === y2 || y2.call(i2, "postFrame", false);
                }
            } else
              w2(A2);
          } }), i2.__property = i2.property, i2.property = void 0, void 0 === i2.label && (i2.label = s3);
        }
        return (o2 = null != o2 ? o2 : {}).extensions = [".jpg", ".png", ".svg", ".hdr", ".exr", ".jpeg", ".bmp", ".gif", ".webp", ".cube"], void 0 === o2.imageFit && (o2.imageFit = "contain"), void 0 === o2.clickCallback && (o2.clickCallback = (r3, o3) => {
          var a3;
          const c2 = null == r3 ? void 0 : r3.target, u2 = null == c2 ? void 0 : c2.getBoundingClientRect();
          if (!u2)
            return void o3.click();
          const p2 = i2.uiRef.controller_.valueController.value.rawValue, d2 = p2 === l2 || (null == p2 ? void 0 : p2.isPlaceholder) ? {} : { "remove image": () => {
            var e4;
            i2.uiRef.controller_.valueController.value.setRawValue("");
            const [t2, n2] = i2.property || i2.__property || [i2, "value"], r4 = "string" == typeof t2[n2];
            t2[n2] = r4 ? "" : null, [i2.onChange].flat().forEach((e5) => "function" == typeof e5 && (null == e5 ? void 0 : e5())), "function" == typeof (null == t2 ? void 0 : t2.setDirty) && t2.setDirty(), null === (e4 = i2.uiRefresh) || void 0 === e4 || e4.call(i2, "postFrame", false), Tg.Remove();
          }, "download image": async () => {
            var r4, s3;
            Tg.Remove();
            const [o4, a4] = i2.property || i2.__property || [i2, "value"], l3 = o4[a4];
            if (!l3)
              return;
            const c3 = null !== (r4 = null == l3 ? void 0 : l3.image) && void 0 !== r4 ? r4 : i2.uiRef.controller_.valueController.value.rawValue;
            let u3 = l3.__rootBlob ? l3.__rootBlob.objectUrl || URL.createObjectURL(l3.__rootBlob) : l3.userData.rootPath || (null == c3 ? void 0 : c3.src);
            c3 && (c3 instanceof ImageBitmap || c3 instanceof HTMLImageElement || c3 instanceof HTMLVideoElement) && !u3 && (u3 = (0, t.imageBitmapToBase64)(c3));
            let p3 = l3.__rootBlob ? l3.__rootBlob.name || "image." + (l3.__rootBlob.ext || "png") : null;
            if (!u3 && l3.isRenderTargetTexture) {
              const t2 = l3.__target;
              if (l3.type === n.ywz)
                u3 = e3.renderer.renderTargetToDataUrl(t2, "image/png", 90, Array.isArray(l3.__target.texture) ? l3.__target.texture.indexOf(l3) : void 0), p3 = "renderTarget.png";
              else {
                const n2 = new ab().parse(e3.renderer.rendererObject, t2, { textureIndex: Array.isArray(l3.__target.texture) ? l3.__target.texture.indexOf(l3) : void 0 }), r5 = new Blob([n2], { type: "image/x-exr" });
                if (!r5)
                  return void console.error("cannot export render target", c3, o4[a4], o4, a4, i2);
                p3 = "renderTarget.exr", u3 = URL.createObjectURL(r5);
              }
            }
            if (!u3 && l3.isDataTexture) {
              const e4 = new ab().parse(void 0, l3), t2 = new Blob([e4], { type: "image/x-exr" });
              if (!t2)
                return void console.error("cannot export data texture", c3, o4[a4], o4, a4, i2);
              p3 = "dataTexture.exr", u3 = URL.createObjectURL(t2);
            }
            if (!u3)
              return void console.error("cannot export image", c3, o4[a4], o4, a4, i2);
            const d3 = document.createElement("a");
            document.body.appendChild(d3), d3.style.display = "none", d3.href = u3, d3.download = p3 || (u3.startsWith("data:") ? "image.png" : null !== (s3 = u3.split("/").pop()) && void 0 !== s3 ? s3 : "image.png"), d3.target = "_blank", d3.click(), document.body.removeChild(d3);
          } }, h2 = Tg.Create({ ...d2, "set/replace image": () => {
            o3.click(), Tg.Remove();
          }, "from url": async () => {
            var t2, r4;
            let o4 = "";
            if (o4 = await s2.prompt("Load texture: Enter Image/Texture URL", o4, true), !o4 || !o4.startsWith("http") && !o4.startsWith("data:image"))
              return null !== o4 && await s2.alert("Loading Image: Invalid URL"), void Tg.Remove();
            o4 = o4.trim();
            const [a4, l3] = i2.property || i2.__property || [i2, "value"], c3 = a4[l3];
            if ("string" == typeof c3)
              a4[l3] = o4, [i2.onChange].flat().forEach((e4) => "function" == typeof e4 && (null == e4 ? void 0 : e4())), "function" == typeof (null == a4 ? void 0 : a4.setDirty) && a4.setDirty(), null === (t2 = i2.uiRefresh) || void 0 === t2 || t2.call(i2, "postFrame", false);
            else {
              const t3 = null == e3 ? void 0 : e3.getPlugin(Ls);
              if (!t3)
                throw "Viewer or AssetManagerPlugin not found";
              null === (r4 = t3.importer) || void 0 === r4 || r4.importSinglePath(o4).then((e4) => {
                var t4;
                if (e4) {
                  e4.isDataTexture ? e4.needsUpdate = true : e4 && void 0 !== (null == c3 ? void 0 : c3.flipY) && (e4.flipY = c3.flipY);
                  const r5 = ["normalMap", "aoMap", "emissiveMap", "roughnessMap", "metalnessMap", "displacementMap", "bumpMap", "alphaMap"].includes(l3);
                  e4.colorSpace = r5 ? n.GUF : n.KI_, a4[l3] = e4, [i2.onChange].flat().forEach((e5) => "function" == typeof e5 && (null == e5 ? void 0 : e5())), "function" == typeof (null == a4 ? void 0 : a4.setDirty) && a4.setDirty(), null === (t4 = i2.uiRefresh) || void 0 === t4 || t4.call(i2, "postFrame", false);
                } else
                  console.warn("uiconfig-tweakpane: Failed to load texture", o4);
              });
            }
            Tg.Remove();
          }, cancel: () => {
            Tg.Remove();
          } }, 2, u2.height + 8);
          null === (a3 = c2.parentElement) || void 0 === a3 || a3.appendChild(h2), u2.y > 0.7 * document.body.clientHeight && (h2.style.top = "auto", h2.style.bottom = u2.height + 8 + "px");
        }), o2.view = "input-image", jO(r2, i2, s2, o2);
      })(this._viewer), e2.addEventListener("preRender", this._preRender), e2.addEventListener("postRender", this._postRender), e2.addEventListener("preFrame", this._preFrame), e2.addEventListener("postFrame", this._postFrame);
    }
    async onDispose(e2) {
      this.dispose();
    }
    async onRemove(e2) {
      this._viewer = void 0, e2.removeEventListener("preRender", this._preRender), e2.removeEventListener("postRender", this._postRender), e2.removeEventListener("preFrame", this._preFrame), e2.removeEventListener("postFrame", this._postFrame), this.dispose();
    }
    setupPluginUi(e2) {
      var n2;
      const r2 = null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.getPlugin(e2);
      if (!r2)
        return void console.warn("plugin not found:", e2);
      this._plugins.push(r2), r2.uiConfig && (r2.uiConfig.limitedUi = true), r2.uiConfig && void 0 === r2.uiConfig.hidden && (r2.uiConfig.hidden = false), this._appendUiObject(r2);
      const i2 = r2.uiConfig;
      if ((null == i2 ? void 0 : i2.uiRef) && r2.toJSON) {
        const e3 = "function" == typeof r2.toJSON ? r2.toJSON() : null;
        r2.resetDefaults = async () => {
          var t2, n4;
          await (null === (t2 = r2.fromJSON) || void 0 === t2 ? void 0 : t2.call(r2, e3)), null === (n4 = i2.uiRefresh) || void 0 === n4 || n4.call(i2, "postFrame", true);
        };
        const n3 = i2.uiRef.controller_.view.element, s2 = (0, t.createDiv)({ innerHTML: "&#8942;", classList: ["pluginOptionsButton"], elementTag: "button" });
        s2.onclick = (s3) => {
          const o2 = {};
          "function" == typeof r2.toJSON && (o2["download preset"] = async () => {
            var e4, n4;
            const i3 = null === (n4 = null === (e4 = this._viewer) || void 0 === e4 ? void 0 : e4.getPlugin(Ls)) || void 0 === n4 ? void 0 : n4.exportPluginPreset(r2);
            await (0, t.downloadBlob)(new Blob([JSON.stringify(i3, null, 2)], { type: "application/json" }), "preset." + r2.constructor.PluginType + ".json"), Tg.Remove();
          }), "function" == typeof r2.fromJSON && (o2["upload preset"] = async () => {
            var e4, n4, s4;
            Tg.Remove();
            const o3 = await (0, t.uploadFile)(false, false);
            if (0 === o3.length)
              return;
            const a3 = o3[0], l2 = await a3.text(), c2 = JSON.parse(l2);
            await (null === (n4 = null === (e4 = this._viewer) || void 0 === e4 ? void 0 : e4.getPlugin(Ls)) || void 0 === n4 ? void 0 : n4.importPluginPreset(c2, r2)), null === (s4 = i2.uiRefresh) || void 0 === s4 || s4.call(i2, "postFrame", true);
          }, e3 && (o2["reset defaults"] = async () => {
            var e4, t2;
            Tg.Remove(), await (null === (t2 = (e4 = r2).resetDefaults) || void 0 === t2 ? void 0 : t2.call(e4));
          }));
          const a2 = Tg.Create(o2, n3.clientWidth - 120, 12);
          n3.append(a2), s3.preventDefault();
        }, n3.appendChild(s2);
      }
      return i2;
    }
    setupPlugins(...e2) {
      e2.forEach((e3) => this.setupPluginUi(e3));
    }
    refreshPluginsEnabled() {
      this._plugins.forEach((e2) => {
        var n2;
        const r2 = e2.uiConfig;
        r2 && (true !== (0, t.getOrCall)(r2.hidden) ? null === (n2 = r2.uiRefresh) || void 0 === n2 || n2.call(r2, "postFrame", true) : r2.uiRef && (r2.uiRef.hidden = true));
      });
    }
    _colorModeChanged() {
      document.body.classList.remove("tpTheme-black", "tpTheme-white", "tpTheme-blue"), document.body.classList.add("tpTheme-" + this.colorMode), localStorage && localStorage.setItem("tpTheme", this.colorMode);
    }
  }
  YO.PluginType = "TweakpaneUi", function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    s2 > 3 && o2 && Object.defineProperty(t2, n2, o2);
  }([(0, t.onChange)(YO.prototype._colorModeChanged)], YO.prototype, "colorMode", void 0);
  class KO extends gt {
    constructor() {
      super(...arguments), this.enabled = true, this.toJSON = void 0, this._savedBg = false, this.lastBgVal = null, this.uiConfig = { label: "Background / Environment", type: "folder", expanded: false, limitedUi: true, children: [{ label: "Color", type: "color", inlinePicker: true, property: [this, "sceneBackgroundColor"], limitedUi: true }, () => ({ label: "Image", property: [this, "sceneBackground"], type: "image", limitedUi: true }), { label: "EnvMap BG", type: "checkbox", property: [this, "envmapBg"] }, () => ({ type: "slider", label: "BG Intensity", getValue: () => {
        var e2, t2;
        return null !== (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.scene.backgroundIntensity) && void 0 !== t2 ? t2 : 1;
      }, setValue: (e2) => {
        this._viewer && (this._viewer.scene.backgroundIntensity = e2);
      }, bounds: [0, 16] }), { label: "Set Transparent BG", type: "button", hidden: () => !this._viewer || this._viewer.useRgbm, value: () => {
        this._viewer && (this._viewer.scene.background = null, this._viewer.scene.backgroundColor = null);
      } }, () => ({ label: "Environment", getValue: () => {
        var e2;
        return (null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.scene.environment) || null;
      }, setValue: (e2) => {
        this._viewer && (this._viewer.scene.environment = e2);
      }, type: "image", limitedUi: true }), { type: "slider", label: "Env Rotation", getValue: () => {
        var e2, t2, n2;
        return null !== (n2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.scene.environment) || void 0 === t2 ? void 0 : t2.rotation) && void 0 !== n2 ? n2 : 0;
      }, setValue: (e2) => {
        var t2, n2;
        const r2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.scene.environment;
        r2 && (r2.rotation = e2, null === (n2 = this._viewer) || void 0 === n2 || n2.scene.setDirty());
      }, bounds: [0, 2 * Math.PI], limitedUi: true }, { type: "slider", label: "Env Intensity", getValue: () => {
        var e2, t2;
        return null !== (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.scene.envMapIntensity) && void 0 !== t2 ? t2 : 1;
      }, setValue: (e2) => {
        var t2;
        (null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.scene) && (this._viewer.scene.envMapIntensity = e2);
      }, bounds: [0, 4], limitedUi: true }, () => ({ label: "Environment1", getValue: () => {
        var e2;
        return (null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.scene.textureSlots.environment1) || null;
      }, setValue: (e2) => {
        this._viewer && (e2.mapping === n.xfE && (e2.mapping = n.dSO, e2.needsUpdate = true), this._viewer.scene.textureSlots.environment1 = e2);
      }, type: "image" }), { type: "slider", label: "Env1 Rotation", hidden: () => {
        var e2;
        return !(null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.scene.textureSlots.environment1);
      }, getValue: () => {
        var e2, t2, n2;
        return null !== (n2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.scene.textureSlots.environment1) || void 0 === t2 ? void 0 : t2.rotation) && void 0 !== n2 ? n2 : 0;
      }, setValue: (e2) => {
        var t2, n2;
        const r2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.scene.textureSlots.environment1;
        r2 && (r2.rotation = e2, null === (n2 = this._viewer) || void 0 === n2 || n2.scene.setDirty());
      }, bounds: [0, 2 * Math.PI] }, { type: "checkbox", label: "Fixed Env Direction", getValue: () => {
        var e2, t2;
        return null !== (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.scene.fixedEnvMapDirection) && void 0 !== t2 && t2;
      }, setValue: (e2) => {
        this._viewer && (this._viewer.scene.fixedEnvMapDirection = e2);
      } }, { type: "checkbox", label: "Artistic Lighting", getValue: () => {
        var e2, t2;
        return null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.renderer.useLegacyLights) || void 0 === t2 || t2;
      }, setValue: (e2) => {
        this._viewer && (this._viewer.renderer.useLegacyLights = e2);
      } }] };
    }
    get sceneBackgroundColor() {
      var e2, t2;
      const r2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.scene.backgroundColor) || void 0 === t2 ? void 0 : t2.getHex(n.KI_);
      return void 0 !== r2 && (this._savedBg = true), r2 || 0;
    }
    set sceneBackgroundColor(e2) {
      this._viewer && this._savedBg && (this._viewer.scene.backgroundColor || (this._viewer.scene.backgroundColor = new n.Ilk()), this._viewer.scene.backgroundColor.setHex(e2), this._viewer.scene.setDirty());
    }
    get sceneBackground() {
      var e2;
      const t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.scene.background;
      return t2 && (t2.isTexture || "texture" === t2.assetType) ? t2 : null;
    }
    set sceneBackground(e2) {
      this._viewer && (this._viewer.scene.background = e2);
    }
    get envmapBg() {
      var e2, t2, n2;
      return "environment" === (null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.scene.background) || (null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.scene.background) === (null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.scene.environment);
    }
    set envmapBg(e2) {
      if (this._viewer)
        if (e2) {
          const e3 = this._viewer.scene.background;
          e3 && e3 !== this._viewer.scene.environment && "environment" !== e3 && (this.lastBgVal = e3), this._viewer.scene.background = "environment";
        } else
          this._viewer.scene.background !== this._viewer.scene.environment && "environment" !== this._viewer.scene.background || (this._viewer.scene.background = this.lastBgVal);
    }
    async onAdded(e2) {
      await super.onAdded(e2), this.lastBgVal = e2.scene.background, e2.scene.addEventListener("backgroundChanged", () => {
        var e3, t2;
        null === (t2 = (e3 = this.uiConfig).uiRefresh) || void 0 === t2 || t2.call(e3, "postFrame", true);
      }), e2.scene.addEventListener("environmentChanged", () => {
        var e3, t2;
        null === (t2 = (e3 = this.uiConfig).uiRefresh) || void 0 === t2 || t2.call(e3, "postFrame", true);
      });
    }
  }
  KO.PluginType = "SimpleBackgroundEnvUiPlugin1";
  class JO extends gt {
    constructor() {
      super(), this.enabled = true, this.toJSON = void 0, this._uiConfig = { type: "folder", label: "Scene", children: [], onExpand: () => {
        var e2, t2;
        null === (t2 = (e2 = this._uiConfig).uiRefresh) || void 0 === t2 || t2.call(e2, "postFrame", true);
      } }, this._clearSceneButton = { type: "button", label: "Clear Scene", value: () => {
        var e2;
        null === (e2 = this._viewer) || void 0 === e2 || e2.scene.disposeSceneModels();
      } }, this._sceneUpdate = this._sceneUpdate.bind(this);
    }
    async onAdded(e2) {
      await super.onAdded(e2), e2.scene.addEventListener("sceneUpdate", this._sceneUpdate);
    }
    async onRemove(e2) {
      return e2.scene.removeEventListener("sceneUpdate", this._sceneUpdate), super.onRemove(e2);
    }
    setDirty() {
      var e2;
      null === (e2 = this._viewer) || void 0 === e2 || e2.setDirty();
    }
    get uiConfig() {
      return this._viewer ? (this._uiConfig.children = [this._clearSceneButton], this._uiConfig) : this._uiConfig;
    }
    _sceneUpdate() {
    }
  }
  JO.PluginType = "SimpleUi";
  var ZO = __webpackgi_require__2(1), $O = __webpackgi_require__2.n(ZO)();
  class eL extends gt {
    constructor(e2 = true) {
      super(), this.enabled = true, this.toJSON = void 0, this.treeView = void 0, this.hierarchyDiv = (0, t.createDiv)({ innerHTML: "", id: "tpHierarchyContainer", addToBody: false }), this._resetting = false, this._uiConfig = { type: "folder", label: "Hierarchy", children: [] }, this._buildData = (e3, t2) => (e3.push({ text: t2.name || "unnamed", id: t2.uuid, children: t2.children.reduce(this._buildData, []) }), e3), this._findVisible = (e3, t2) => t2.visible ? (t2.children.length < 1 ? e3.push(t2.uuid) : e3.push(...t2.children.reduce(this._findVisible, [])), e3) : e3, this._setVisible = (e3) => {
        var t2;
        null === (t2 = this._viewer) || void 0 === t2 || t2.doOnce("postFrame", () => {
          var t3, n2, r2;
          const i2 = null === (t3 = this._viewer) || void 0 === t3 ? void 0 : t3.scene.modelRoot;
          if (!i2 || null == e3)
            return;
          const s2 = /* @__PURE__ */ new Set();
          i2.traverse((t4) => {
            t4 !== i2 && (t4.visible = e3.includes(t4.uuid), t4.visible && t4.traverseAncestors((e4) => s2.add(e4)));
          }), s2.forEach((e4) => e4.visible = true), null === (r2 = null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.scene) || void 0 === r2 || r2.setDirty({ sceneUpdate: true, fromHierarchyPlugin: true, updateGround: false });
        });
      }, this.enabled = e2, this.reset = this.reset.bind(this), (0, t.createStyles)(t.css`
#tpHierarchyContainer{
  width: 100%;
  height: auto;
  background-color: transparent;
  color: var(--tp-container-foreground-color, hsl(230, 7%, 75%));
  margin-top: 0;
}
.treejs .treejs-switcher:before {
    border-top: 6px solid var(--tp-container-foreground-color, hsl(230, 7%, 75%)) !important;
}
        `);
    }
    _reset(e2) {
      var n2;
      if (null == e2 ? void 0 : e2.fromHierarchyPlugin)
        return;
      if (e2 && !e2.hierarchyChanged)
        return;
      for (; this.hierarchyDiv.firstChild; )
        this.hierarchyDiv.firstChild.remove();
      const r2 = null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.scene.modelRoot;
      if (!r2)
        return;
      const i2 = r2.children.reduce(this._buildData, []), s2 = r2.children.reduce(this._findVisible, []);
      let o2 = false;
      return new Promise((e3, n3) => {
        this.treeView = new $O(this.hierarchyDiv, { closeDepth: 1, data: i2, loaded: function() {
          this.values = s2, e3();
        }, onChange: () => {
          o2 ? (0, t.timeout)(200).then(() => {
            this.treeView && this._setVisible(this.treeView.values);
          }) : o2 = true;
        }, onItemLabelClick: (e4) => {
          var t2;
          const n4 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.scene.modelRoot.modelObject.getObjectByProperty("uuid", e4);
          n4 && r2.visible && n4.dispatchEvent({ type: "select", value: n4, ui: true });
        } });
      });
    }
    async onAdded(e2) {
      await super.onAdded(e2), e2.scene.addEventListener("sceneUpdate", this.reset), await this.reset();
    }
    async reset(e2) {
      this._resetting || (this._resetting = true, await (0, t.timeout)(500), await this._reset(e2), this._resetting = false);
    }
    async onRemove(e2) {
      return e2.scene.removeEventListener("sceneUpdate", this.reset), super.onRemove(e2);
    }
    async onDispose(e2) {
      return super.onDispose(e2);
    }
    get uiConfig() {
      return this._uiConfig.domChildren || (this._uiConfig.domChildren = [this.hierarchyDiv]), this._uiConfig;
    }
  }
  eL.PluginType = "HierarchyUiPlugin";
  class tL extends gt {
    constructor() {
      super(), this.toJSON = void 0, this.enabled = true, this.uiConfig = { type: "folder", label: "Lights", children: [{ type: "button", label: "Add Directional Light", value: () => {
        if (!this._viewer)
          return;
        const e2 = new sr();
        e2.position.set(0, 0, 0), e2.target.position.set(0, 0, -1).normalize(), e2.intensity = 2, e2.shadow.mapSize.set(1024, 1024), this._viewer.scene.addLight(e2);
      } }, { type: "button", label: "Add Ambient Light", value: () => {
        if (!this._viewer)
          return;
        const e2 = new lr();
        e2.intensity = 2, this._viewer.scene.addLight(e2);
      } }, { type: "button", label: "Add Point Light", value: () => {
        if (!this._viewer)
          return;
        const e2 = new ar();
        e2.position.set(3, 3, 3), e2.shadow.mapSize.set(1024, 1024), e2.intensity = 2, this._viewer.scene.addLight(e2);
      } }, { type: "button", label: "Add Spot Light", value: () => {
        if (!this._viewer)
          return;
        const e2 = new or();
        e2.position.set(3, 3, 3), e2.shadow.mapSize.set(1024, 1024), e2.intensity = 2, e2.lookAt(0, 0, 0), this._viewer.scene.addLight(e2);
      } }], limitedUi: true }, this.dependencies = [Ls], this._sceneUpdate = (e2) => {
        var t2, n2, r2;
        if (!e2.hierarchyChanged)
          return;
        const i2 = [];
        null === (t2 = this._viewer) || void 0 === t2 || t2.traverseSceneObjects((e3) => {
          if (!e3.lightObject)
            return;
          const t3 = e3.uiConfig;
          t3 && !i2.includes(t3) && i2.push(t3);
        }), [...this.uiConfig.children].forEach((e3) => {
          "button" === (null == e3 ? void 0 : e3.type) || i2.includes(e3) || this.uiConfig.children.splice(this.uiConfig.children.indexOf(e3), 1);
        }), i2.forEach((e3) => {
          this.uiConfig.children.includes(e3) || this.uiConfig.children.push(e3);
        }), null === (r2 = (n2 = this.uiConfig).uiRefresh) || void 0 === r2 || r2.call(n2, "postFrame", true);
      };
    }
    async onAdded(e2) {
      await super.onAdded(e2), e2.scene.addEventListener("sceneUpdate", this._sceneUpdate);
    }
    async onRemove(e2) {
      return e2.scene.removeEventListener("sceneUpdate", this._sceneUpdate), super.onRemove(e2);
    }
  }
  tL.PluginType = "SimpleLightsUi";
  class nL extends gt {
    constructor() {
      super(), this.toJSON = void 0, this.enabled = true, this.uiConfig = { type: "folder", label: "Cameras (Loaded)", children: [{ type: "button", label: "Add Camera", value: () => {
        var e2;
        if (!this._viewer)
          return;
        const t2 = this._viewer.createCamera(new n.cPb(45, 1, 0.5, 20));
        this._viewer.scene.modelRoot.add(t2.cameraObject), t2.setCameraOptions({ controlsMode: "orbit" }), t2.position.set(2, 2, 2), t2.target.set(0, 0, 0), t2.positionUpdated(true), t2.cameraObject.lookAt(0, 0, 0), t2.setDirty();
        const r2 = this._viewer.getPluginByType("VirtualCamerasPlugin");
        if (r2) {
          const n2 = r2.addCamera(t2), i2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPluginByType("debug");
          i2 && i2.addTexture("camera frame", () => n2.target.texture, [40, 310, 300, 200]);
        }
      } }], limitedUi: true }, this.dependencies = [Ls], this._sceneUpdate = (e2) => {
        var t2, n2, r2;
        if (!e2.hierarchyChanged)
          return;
        const i2 = [];
        null === (t2 = this._viewer) || void 0 === t2 || t2.traverseSceneObjects((e3) => {
          if (!e3.cameraObject)
            return;
          const t3 = e3.uiConfig;
          t3 && !i2.includes(t3) && i2.push(t3);
        }), [...this.uiConfig.children].forEach((e3) => {
          "button" === (null == e3 ? void 0 : e3.type) || i2.includes(e3) || this.uiConfig.children.splice(this.uiConfig.children.indexOf(e3), 1);
        }), i2.forEach((e3) => {
          this.uiConfig.children.includes(e3) || this.uiConfig.children.push(e3);
        }), null === (r2 = (n2 = this.uiConfig).uiRefresh) || void 0 === r2 || r2.call(n2, "postFrame", true);
      };
    }
    async onAdded(e2) {
      await super.onAdded(e2), e2.scene.addEventListener("sceneUpdate", this._sceneUpdate);
    }
    async onRemove(e2) {
      return e2.scene.removeEventListener("sceneUpdate", this._sceneUpdate), super.onRemove(e2);
    }
  }
  nL.PluginType = "SimpleSceneCamerasUi";
  var rL, iL = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let sL = rL = class extends gt {
    constructor() {
      super(), this.enabled = true, this._serializeVersion = 1, this.mode = "full", this.width = 0, this.height = 0, this.scale = 1, this._sizeChanged = this._sizeChanged.bind(this), this._refresh = this._refresh.bind(this);
    }
    refreshSize() {
      this._sizeChanged();
    }
    _sizeChanged(e2 = true) {
      if (!this._viewer)
        return;
      if ("full" === this.mode)
        return this._viewer.setSize({}), this._setScale(this.scale), void this._refresh();
      const t2 = { width: Math.floor(this.width), height: Math.floor(this.height) }, n2 = this._viewer.container.getBoundingClientRect(), r2 = { width: Math.floor(n2.width), height: Math.floor(n2.height) };
      let i2 = 1;
      if (t2.width > r2.width) {
        const e3 = t2.width;
        t2.width = r2.width;
        const n3 = t2.width / e3;
        if (t2.height = Math.floor(t2.height * n3), i2 /= n3, i2 > rL.MaxCanvasScale)
          return this.width = r2.width * rL.MaxCanvasScale, console.log("loop", this.width, r2.width, i2), void this._sizeChanged();
      }
      if (t2.height > r2.height) {
        const e3 = t2.height;
        t2.height = r2.height;
        const n3 = t2.height / e3;
        if (t2.width = Math.floor(t2.width * n3), i2 /= n3, i2 > rL.MaxCanvasScale)
          return this.height = r2.height * rL.MaxCanvasScale, console.log("loop", this.width, r2.width, this.height, r2.height, i2), void this._sizeChanged();
      }
      (t2.width >= r2.width || t2.width < 1) && delete t2.width, (t2.height >= r2.height || t2.height < 1) && delete t2.height, this._viewer.setSize(t2), this._setScale(i2), e2 && (this.scale = i2), this._refresh();
    }
    _setScale(e2) {
      this._viewer && (this._viewer.renderer.displayCanvasScaling = e2);
    }
    _scaleChanged() {
      if (!this._viewer)
        return;
      const e2 = this.scale;
      if (Math.abs(e2 - this._viewer.renderer.displayCanvasScaling) < 0.01)
        return;
      if ("full" === this.mode)
        return void this._sizeChanged();
      const t2 = this.width / this.height, n2 = this._viewer.container.getBoundingClientRect(), r2 = Math.floor(n2.width * e2), i2 = Math.floor(r2 / t2);
      this.width = r2, this.height = i2, this._sizeChanged(false);
    }
    async onAdded(e2) {
      await super.onAdded(e2);
      const t2 = e2.canvas.clientWidth, n2 = e2.canvas.clientHeight, r2 = e2.renderer.displayCanvasScaling;
      this.width = t2, this.height = n2, this.scale = r2, e2.renderer.addEventListener("resize", this._refresh), this.addEventListener("deserialize", () => this._sizeChanged(true)), this._refresh();
    }
    async onRemove(e2) {
      return e2.renderer.removeEventListener("resize", this._refresh), super.onRemove(e2);
    }
    _refresh() {
      var e2, t2;
      null === (t2 = null === (e2 = this.uiConfig) || void 0 === e2 ? void 0 : e2.uiRefresh) || void 0 === t2 || t2.call(e2, "postFrame", true);
    }
    fromJSON(e2, t2) {
      if (!e2.mode)
        if (e2.width || e2.height) {
          const t3 = this._viewer.container.getBoundingClientRect();
          e2.width || (e2.width = t3.width), e2.height || (e2.height = t3.height), e2.scale && (e2.width *= e2.scale, e2.height *= e2.scale, delete e2.scale), e2.width = Math.round(e2.width), e2.height = Math.round(e2.height), e2.mode = "custom";
        } else
          e2.mode = "full";
      return super.fromJSON(e2, t2);
    }
    toJSON(e2) {
      const t2 = super.toJSON(e2);
      return "full" === t2.mode && (delete t2.width, delete t2.height), "custom" === t2.mode && delete t2.scale, t2;
    }
  };
  sL.PluginType = "RendererParamsUiPlugin", sL.MaxCanvasScale = 5, iL([ie("version")], sL.prototype, "_serializeVersion", void 0), iL([ie(), Ne("Mode", ["full", "custom"].map((e2) => ({ label: e2 }))), (0, t.onChange2)(rL.prototype._sizeChanged)], sL.prototype, "mode", void 0), iL([ie(), Ue("Width", void 0, 1, (e2) => ({ onChange: () => e2._sizeChanged(), hidden: () => "full" === e2.mode, bounds: () => {
    var t2;
    return [10, Math.pow(2, Math.ceil(Math.log2((null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.container.getBoundingClientRect().width) || 1024) + 2))];
  } }))], sL.prototype, "width", void 0), iL([ie(), Ue("Height", void 0, 1, (e2) => ({ onChange: () => e2._sizeChanged(), hidden: () => "full" === e2.mode, bounds: () => {
    var t2;
    return [10, Math.pow(2, Math.ceil(Math.log2((null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.container.getBoundingClientRect().height) || 1024) + 2))];
  } }))], sL.prototype, "height", void 0), iL([ie(), (0, t.onChange)(rL.prototype._scaleChanged), Ue("Scale", [0.25, rL.MaxCanvasScale], 1e-3, (e2) => ({ disabled: () => "custom" === e2.mode }))], sL.prototype, "scale", void 0), sL = rL = iL([We("Renderer")], sL);
  class oL extends gt {
    async onAdded(e2) {
      await super.onAdded(e2), e2.scene.addEventListener("activeCameraChange", this._refresh), e2.scene.addEventListener("sceneUpdate", this._refresh);
    }
    async onRemove(e2) {
      return e2.scene.removeEventListener("activeCameraChange", this._refresh), e2.scene.removeEventListener("sceneUpdate", this._refresh), super.onRemove(e2);
    }
    constructor() {
      super(), this.enabled = true, this.serializeWithViewer = false, this._refresh = this._refresh.bind(this);
    }
    toJSON(e2) {
      var t2;
      const n2 = super.toJSON(e2);
      return n2.activeCamera = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.scene.activeCamera.toJSON(), n2;
    }
    fromJSON(e2, t2) {
      var n2;
      return e2.activeCamera && (null === (n2 = this._viewer) || void 0 === n2 || n2.scene.activeCamera.fromJSON(e2.activeCamera), delete (e2 = { ...e2 }).activeCamera), super.fromJSON(e2, t2);
    }
    _refresh() {
      var e2, t2;
      this._viewer && (null === (t2 = (e2 = this.uiConfig).uiRefresh) || void 0 === t2 || t2.call(e2, "postFrame", true));
    }
    get uiConfig() {
      var e2;
      return (null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.scene.activeCamera.uiConfig) || {};
    }
  }
  oL.PluginType = "CameraUiPlugin";
  let aL = { create: (e2) => {
    let t2 = "button" + (e2.type ? " " + e2.type : ""), n2 = uL.createDiv(t2, e2.text);
    return n2.addEventListener("click", e2.onClick), n2;
  } };
  var lL = aL;
  let cL = { createElement: (e2, t2, n2, r2) => {
    let i2 = document.createElement(e2);
    if (t2 && (i2.className = t2), n2 && (i2.innerHTML = n2), r2)
      for (let e3 in r2)
        i2.setAttribute(e3, r2[e3]);
    return i2;
  }, createDiv: (e2, t2, n2) => cL.createElement("div", e2, t2, n2), createDomTree: (e2) => {
    if (!e2 || !e2.hasOwnProperty("dom"))
      return e2;
    let t2 = e2.dom;
    if (e2.children)
      for (let n2 in e2.children)
        e2.children[n2] && t2.appendChild(cL.createDomTree(e2.children[n2]));
    return t2;
  }, removeElement: (e2) => {
    null != e2 && e2.parentNode.removeChild(e2);
  }, appendToBody: (e2) => {
    document.body.appendChild(e2);
  }, makeIconHTML: (e2) => {
    let t2 = "";
    return "ok" == e2 && (t2 = "#tick"), "error" == e2 && (t2 = "#cancel"), "info" == e2 && (t2 = "#info-button"), "caution" == e2 && (t2 = "#danger"), "min" == e2 && (t2 = "#line"), "close" == e2 && (t2 = "#close"), `<svg class="icon ${e2}"><use xlink:href="${t2}" /></svg>`;
  }, makeNftContent: (e2) => {
    let t2 = null;
    if (e2.type) {
      let n2 = null;
      n2 = "string" == typeof e2.content ? cL.createDiv("inner-content", e2.content) : cL.createDomTree({ dom: cL.createDiv("inner-content"), children: [e2.content] }), t2 = "text" == e2.type ? cL.createDomTree({ dom: cL.createDiv("content text"), children: [n2] }) : cL.createDomTree({ dom: cL.createDiv("content"), children: [cL.createDiv("state", cL.makeIconHTML(e2.type)), n2] });
    } else
      "string" == typeof e2.content && (t2 = cL.createDiv("content", e2.content));
    return t2;
  }, standardizeButtons: (e2, t2) => {
    let n2 = [];
    if (void 0 === t2.buttons)
      return "caution" != t2.type && "info" != t2.type || n2.push({ key: 27, text: "Cancel", onClick: e2.close.bind(e2, "cancel") }), n2.push({ key: 13, text: "OK", type: "main", onClick: e2.close.bind(e2, "ok") }), n2;
    n2 = t2.buttons, n2.constructor !== Array && (n2 = [n2]);
    for (let t3 in n2)
      !n2[t3].onClick && (n2[t3].onClick = e2.close.bind(e2, n2[t3].id));
    return n2;
  }, makeButtons: (e2) => {
    let t2 = [];
    if (e2)
      for (let n2 in e2)
        t2.push(lL.create({ text: e2[n2].text ? e2[n2].text : "OK", type: e2[n2].normal ? null : "main", onClick: e2[n2].onClick }));
    return cL.createDomTree({ dom: cL.createDiv("button-wrapper"), children: t2 });
  }, bindButtonKeyEvents: (e2) => {
    let t2 = (t3) => {
      for (let n2 in e2)
        if (e2[n2].key === t3.keyCode)
          return void e2[n2].onClick();
    };
    return window.addEventListener("keydown", t2), t2;
  }, unbindButtonKeyEvents: (e2) => {
    window.removeEventListener("keydown", e2);
  } };
  var uL = cL, pL = __webpackgi_require__2(476);
  var dL = { "wwise-overlay-in-1": { opacity: "0" }, "wwise-overlay-in-2": { opacity: "1" }, "wwise-overlay-out-1": { opacity: "0" }, "wwise-pop-in-1": { transform: "scale(0.5, 0.5)", "margin-top": "50px", opacity: ".5" }, "wwise-pop-in-2": { transform: "scale(1, 1)", "margin-top": "0", opacity: "1" }, "wwise-pop-in-3": { transform: "scale(1.05, 1.05)" }, "wwise-pop-in-4": { transform: "scale(1, 1)" }, "wwise-pop-out-1": { transform: "scale(0.25, 0.25)", "margin-top": "50px", opacity: "0" }, "wwise-flip-in-1": { transform: "rotateX(60deg) scaleX(.5)", opacity: ".2" }, "wwise-flip-in-2": { transform: "none", opacity: "1" }, "wwise-flip-out-1": { transform: "rotateX(60deg) scaleX(.5)", opacity: "0" }, "wwise-top-in-1": { transform: "translateY(-30vh)", opacity: ".5" }, "wwise-top-in-2": { transform: "none", opacity: "1" }, "wwise-top-out-1": { transform: "translateY(-30vh)", opacity: "0" }, "wwise-bottom-in-1": { transform: "translateY(30vh)", opacity: ".5" }, "wwise-bottom-in-2": { transform: "none", opacity: "1" }, "wwise-bottom-out-1": { transform: "translateY(30vh)", opacity: "0" }, "wwise-left-in-1": { transform: "translateX(-30vw)", opacity: ".5" }, "wwise-left-in-2": { transform: "none", opacity: "1" }, "wwise-left-out-1": { transform: "translateX(-30vw)", opacity: "0" }, "wwise-right-in-1": { transform: "translateX(30vw)", opacity: ".5" }, "wwise-right-in-2": { transform: "none", opacity: "1" }, "wwise-right-out-1": { transform: "translateX(30vw)", opacity: "0" }, "wwise-min-in-1": { "margin-top": "0", transform: "rotateX(-60deg) scale(0.2, 1.8) translateY(80vh)", opacity: ".2" }, "wwise-min-in-2": { transform: "none", opacity: "1" }, "wwise-min-out-1": { "margin-top": "30vh", transform: "rotateX(-60deg) scale(0.05, 2) translateY(30vh)", opacity: "0" } };
  let hL = {};
  hL.overlay_in = [new pL.Frame(dL["wwise-overlay-in-1"], 0), new pL.Frame(dL["wwise-overlay-in-2"], 400)], hL.overlay_out = [new pL.Frame(dL["wwise-overlay-out-1"], 300)], hL.pop_in = [new pL.Frame(dL["wwise-pop-in-1"], 0), new pL.Frame(dL["wwise-pop-in-2"], { duration: 200, "timing-function": "ease-in" }), new pL.Frame(dL["wwise-pop-in-3"], { duration: 100, "timing-function": "linear" }), new pL.Frame(dL["wwise-pop-in-4"], { duration: 100, "timing-function": "linear" })], hL.pop_out = [new pL.Frame(dL["wwise-pop-out-1"], { duration: 250, "timing-function": "ease-in" })], hL.flip_in = [new pL.Frame(dL["wwise-flip-in-1"], 0), new pL.Frame(dL["wwise-flip-in-2"], 500)], hL.flip_out = [new pL.Frame(dL["wwise-flip-out-1"], 400)], hL.min_in = [new pL.Frame(dL["wwise-min-in-1"], 0), new pL.Frame(dL["wwise-min-in-2"], 350)], hL.min_out = [new pL.Frame(dL["wwise-min-out-1"], 400)];
  let fL = ["top", "bottom", "left", "right"];
  for (let e2 in fL) {
    let t2 = fL[e2];
    hL[t2 + "_in"] = [new pL.Frame(dL["wwise-" + t2 + "-in-1"], 0), new pL.Frame(dL["wwise-" + t2 + "-in-2"], { duration: 400, "timing-function": "ease-out" })], hL[t2 + "_out"] = [new pL.Frame(dL["wwise-" + t2 + "-out-1"], { duration: 400, "timing-function": "ease-in" })];
  }
  var mL = hL;
  let _L = { animation: "pop", topbar: { showClose: true, showMin: false }, keepOverlay: false, position: "center", overlay: false, clickOverlayToClose: true, removeBackground: false, noRadius: false, zIndex: null };
  class gL {
    static create(e2, t2) {
      let n2 = e2.getElementsByClassName("title")[0];
      n2 && (n2 = n2.innerHTML);
      let r2 = e2.getElementsByClassName("content")[0];
      return r2 && (r2 = r2.innerHTML), uL.removeElement(e2), t2.title = n2, t2.content = r2, new gL(t2);
    }
    constructor(e2) {
      this.options = JSON.parse(JSON.stringify(_L));
      for (let t3 in e2)
        null != e2[t3] && (this.options[t3] = e2[t3]);
      let t2 = this.options.position;
      if (-1 == t2.indexOf(" ") && ("left" == t2 || "right" == t2 ? t2 += " center" : t2 = "top" == t2 || "bottom" == t2 ? "center " + t2 : t2 + " " + t2), this.options.position = t2, this.options.overlay) {
        let e3 = document.getElementsByClassName("wwise-overlay");
        e3.length ? (this.overlay = e3[0], this.hasOverlay = true) : (this.overlay = uL.createDiv("wwise-overlay"), this.options.zIndex && (this.overlay.style.zIndex = this.options.zIndex)), this.overlayClickHandler = this.close.bind(this, void 0);
      } else
        this.options.clickOverlayToClose = false;
      let n2 = "content";
      if (this.options.topbar) {
        let e3 = [];
        this.options.topbar.showMin && (e3.push(uL.createDiv(null, uL.makeIconHTML("min"))), e3[e3.length - 1].addEventListener("click", this.min.bind(this))), this.options.topbar.showClose && (e3.push(uL.createDiv(null, uL.makeIconHTML("close"))), e3[e3.length - 1].addEventListener("click", this.close.bind(this, void 0)));
        let t3 = null;
        t3 = "string" == typeof this.options.title ? uL.createDiv("title", this.options.title) : uL.createDomTree({ dom: uL.createDiv("title"), children: [this.options.title] }), this.topbar = uL.createDomTree({ dom: uL.createDiv("topbar"), children: [{ dom: uL.createDiv("control"), children: e3.map((e4) => ({ dom: e4 })) }, { dom: t3 }, { dom: uL.createDiv("clear") }] });
      } else
        n2 += " no-topbar";
      "string" == typeof this.options.content ? this.content = uL.createDomTree({ dom: uL.createDiv(n2, this.options.content) }) : this.content = uL.createDomTree({ dom: uL.createDiv(n2), children: [this.options.content] }), this.options.removeBackground && (this.content.style.background = "initial"), this.window = uL.createDomTree({ dom: uL.createDiv("wwise" + (this.options.noRadius ? " no-radius" : "")), children: [this.topbar, this.content] });
      let r2 = uL.createDiv("wwise-wrapper");
      this.options.zIndex && (r2.style.zIndex = this.options.zIndex), this.wrapper = uL.createDomTree({ dom: r2, children: [this.window] }), this.dom = uL.createDomTree({ dom: uL.createDiv(), children: [this.wrapper] });
      let i2 = this.options.position.split(" "), s2 = -50, o2 = -50;
      if ("left" == i2[0] ? (s2 = 0, this.wrapper.classList.add("left")) : "right" == i2[0] ? (s2 = -100, this.wrapper.classList.add("right")) : "center" == i2[0] ? this.wrapper.classList.add("h-center") : this.wrapper.style.left = i2[0], "top" == i2[1] ? (o2 = 0, this.wrapper.classList.add("top")) : "bottom" == i2[1] ? (o2 = -100, this.wrapper.classList.add("bottom")) : "center" == i2[1] ? this.wrapper.classList.add("v-center") : this.wrapper.style.top = t2[1], this.window.style.transform = `translate(${s2}%, ${o2}%)`, this.options.style)
        for (let e3 in this.options.style)
          this.window.style[e3] = this.options.style[e3];
      this.options.margin && (this.wrapper.style.margin = this.options.margin), this.options.draggable && this.draggable();
    }
    open(e2) {
      if (this.opened)
        return;
      this.promise = new Promise((e3) => {
        this.promiseResolve = e3;
      }), this.appendDoms(), this.opened = true, this.options.clickOverlayToClose && (this.overlay.addEventListener("click", this.overlayClickHandler), this.overlay.addEventListener("touchstart", this.overlayClickHandler));
      let t2 = e2 ? "min" : this.options.animation;
      if (t2) {
        "min" != t2 && "flip" != t2 || this.dom.classList.add("wwise-perspective");
        let e3 = [new pL.Queue(this.wrapper, mL[t2 + "_in"], { instant: true, applyOnEnd: true }).getPromise()];
        return this.options.overlay && !this.hasOverlay && e3.push(new pL.Queue(this.overlay, mL.overlay_in, { instant: true, applyOnEnd: true }).getPromise()), Promise.all(e3).then(() => {
          this.dom.classList.remove("wwise-perspective");
        });
      }
      return Promise.resolve();
    }
    close(e2) {
      if (!this.opened)
        return;
      this.opened = false;
      let t2 = e2 ? "min" : this.options.animation;
      if (this.overlay && (this.overlay.removeEventListener("click", this.overlayClickHandler), this.overlay.removeEventListener("touchstart", this.overlayClickHandler)), t2) {
        "min" != t2 && "flip" != t2 || this.dom.classList.add("wwise-perspective");
        let e3 = [new pL.Queue(this.wrapper, mL[t2 + "_out"], { instant: true, applyOnEnd: true }).getPromise()];
        return this.options.overlay && !this.options.keepOverlay && e3.push(new pL.Queue(this.overlay, mL.overlay_out, { instant: true, applyOnEnd: true }).getPromise()), Promise.all(e3).then(() => {
          this.removeDoms(), this.dom.classList.remove("wwise-perspective"), this.promiseResolve();
        });
      }
      return this.removeDoms(), this.promiseResolve(), Promise.resolve();
    }
    min() {
      return this.close(true);
    }
    resume() {
      return this.open(true);
    }
    getPromise() {
      return this.promise;
    }
    appendDoms() {
      this.options.overlay && !this.hasOverlay && (uL.appendToBody(this.overlay), document.body.classList.add("wwise-no-scroll"), this.overlay.addEventListener("touchstart", (e2) => {
        e2.preventDefault();
      })), uL.appendToBody(this.dom);
    }
    removeDoms() {
      uL.removeElement(this.dom), !this.options.keepOverlay && this.overlay && (uL.removeElement(this.overlay), document.body.classList.remove("wwise-no-scroll"));
    }
    draggable(e2 = true) {
      this.topbar && (e2 ? (this.draggableMouseMoveHandler = this.handleDraggableMouseMove.bind(this), this.draggableMouseDownHandler = this.handleDraggableMouseDown.bind(this), this.draggableMouseUpHandler = this.handleDraggableMouseUp.bind(this), this.draggableMouseOutHandler = this.handleDraggableMouseOut.bind(this), window.addEventListener("mousemove", this.draggableMouseMoveHandler), window.addEventListener("mouseout", this.draggableMouseOutHandler), this.topbar.addEventListener("mousedown", this.draggableMouseDownHandler), window.addEventListener("mouseup", this.draggableMouseUpHandler)) : (window.removeEventListener("mousemove", this.draggableMouseMoveHandler), window.removeEventListener("mouseout", this.draggableMouseOutHandler), this.topbar.removeEventListener("mousedown", this.draggableMouseDownHandler), window.removeEventListener("mouseup", this.draggableMouseUpHandler)));
    }
    handleDraggableMouseMove(e2) {
      if (this.inDragging) {
        let t2 = { x: e2.clientX - this.dragPrev.x, y: e2.clientY - this.dragPrev.y }, n2 = window.getComputedStyle(this.wrapper), r2 = this.options.draggable, i2 = parseFloat(n2.left), s2 = parseFloat(n2.top);
        if (-1 != n2.left.indexOf("%")) {
          i2 = n2.left, i2 = i2.substr(0, i2.length - 1), i2 = parseInt(i2);
          let e3 = window, t3 = document, r3 = t3.documentElement, s3 = t3.getElementsByTagName("body")[0];
          i2 = i2 * (e3.innerWidth || r3.clientWidth || s3.clientWidth) / 100;
        }
        if (-1 != n2.top.indexOf("%")) {
          s2 = n2.top, s2 = s2.substr(0, s2.length - 1), s2 = parseInt(s2);
          let e3 = window, t3 = document, r3 = t3.documentElement, i3 = t3.getElementsByTagName("body")[0];
          s2 = s2 * (e3.innerHeight || r3.clientHeight || i3.clientHeight) / 100;
        }
        1 != r2 && "horizontal" != r2 || (this.wrapper.style.left = i2 + t2.x + "px"), 1 != r2 && "vertical" != r2 || (this.wrapper.style.top = s2 + t2.y + "px"), this.dragPrev = { x: e2.clientX, y: e2.clientY };
      }
    }
    handleDraggableMouseDown(e2) {
      this.inDragging = true, this.dragPrev = { x: e2.clientX, y: e2.clientY };
    }
    handleDraggableMouseUp(e2) {
      this.inDragging = false;
    }
    handleDraggableMouseOut(e2) {
      let t2 = e2.relatedTarget;
      t2 && "HTML" != t2.nodeName || (this.inDragging = false);
    }
  }
  var vL = gL, yL = class {
    constructor(e2) {
      let t2 = this.options = e2;
      !t2.type && (t2.type = "ok");
      let n2 = { topbar: false };
      n2.content = this.constructContent({ type: t2.type, title: t2.title, text: t2.text, content: t2.content, buttons: t2.buttons }), n2.overlay = true, n2.keepOverlay = t2.keepOverlay, n2.clickOverlayToClose = false, n2.animation = t2.animation, n2.zIndex = t2.zIndex, this.wwise = new vL(n2);
    }
    constructContent(e2) {
      let t2 = uL.createDiv("modal"), n2 = uL.createDomTree({ dom: uL.createDiv("main " + e2.type), children: [uL.createDiv(null, uL.makeIconHTML(e2.type)), uL.createDiv("title", e2.title), uL.createDiv("text", e2.text)] });
      this.buttonArr = uL.standardizeButtons(this, e2);
      let r2 = uL.makeButtons(this.buttonArr), i2 = null;
      e2.content && (i2 = "string" == typeof e2.content ? uL.createDiv(null, e2.content) : e2.content);
      let s2 = null;
      return r2.innerHTML && (s2 = uL.createDomTree({ dom: uL.createDiv("operation " + e2.type), children: [r2] })), i2 || s2 || n2.classList.add("no-op"), uL.createDomTree({ dom: t2, children: [n2, i2, s2] });
    }
    open() {
      if (this.wwise.opened)
        return;
      let e2 = this.wwise.open();
      return this.value = void 0, this.promise = new Promise((e3) => {
        this.promiseResolve = e3;
      }), this.wwise.getPromise().then(this.handlePromiseResolve.bind(this)), this.keyHandler = uL.bindButtonKeyEvents(this.buttonArr), this.options.closeAfter && window.setTimeout(() => {
        this.close("timer");
      }, this.options.closeAfter), e2;
    }
    close(e2) {
      if (this.wwise.opened)
        return this.value = e2, uL.unbindButtonKeyEvents(this.keyHandler), this.wwise.close();
    }
    getPromise() {
      return this.promise;
    }
    handlePromiseResolve() {
      this.promiseResolve(this.value);
    }
  };
  let bL = { showCancel: false, okText: "OK", cancelText: "Cancel", placeholder: "", validator: null }, wL = { type: "info", keepOverlay: false, title: "Input", text: "", zIndex: null };
  var AL = __webpackgi_require__2(513), xL = {};
  AL.Z && AL.Z.locals && (xL.locals = AL.Z.locals);
  var EL, CL = 0, SL = {};
  SL.styleTagTransform = uc(), SL.setAttributes = oc(), SL.insert = function(e2, t2) {
    (t2.target || document.head).appendChild(e2);
  }, SL.domAPI = ic(), SL.insertStyleElement = lc(), xL.use = function(e2) {
    return SL.options = e2 || {}, CL++ || (EL = nc()(AL.Z, SL)), xL;
  }, xL.unuse = function() {
    CL > 0 && !--CL && (EL(), EL = null);
  };
  var ML = xL;
  class TL extends gt {
    constructor() {
      super(...arguments), this.enabled = true, this.toJSON = void 0, this._previousMappings = {};
    }
    async onAdded(e2) {
      await super.onAdded(e2), this._previousMappings = { alert: e2.alert, confirm: e2.confirm, prompt: e2.prompt }, uL.appendToBody = (t2) => {
        t2.style.zIndex = "100", e2.container.appendChild(t2);
      }, uL.makeIconHTML = (e3) => "", ML.use({ target: e2.container }), e2.alert = async (e3) => {
        const t2 = null == e3 ? void 0 : e3.split(":")[0], n2 = new yL({ type: "info", title: null != t2 ? t2 : "&ndsp;", text: (null == e3 ? void 0 : e3.replace(t2 + ":", "").replace(/(\r?\n)/gm, "<br>")) || "", buttons: [{ key: 13, text: "OK", type: "main", id: "ok" }], animation: "overlay" });
        return n2.open(), n2.getPromise();
      }, e2.confirm = async (e3) => {
        const t2 = null == e3 ? void 0 : e3.split(":")[0], n2 = new yL({ type: "info", title: null != t2 ? t2 : "&ndsp;", text: (null == e3 ? void 0 : e3.replace(t2 || "", "").replace(":", "")) || "", buttons: [{ id: "no", key: 27, text: "No", normal: true }, { id: "yes", key: 13, text: "Yes" }], animation: "overlay" });
        return n2.open(), "yes" === await n2.getPromise();
      }, e2.prompt = async (e3, t2, n2 = true) => {
        const r2 = null == e3 ? void 0 : e3.split(":")[0], i2 = new class {
          constructor(e4) {
            this.options = JSON.parse(JSON.stringify(bL));
            for (let t4 in e4)
              null != e4[t4] && (this.options[t4] = e4[t4]);
            let t3 = this.options, n3 = JSON.parse(JSON.stringify(wL));
            for (let e5 in n3)
              t3.hasOwnProperty(e5) && (n3[e5] = t3[e5]);
            let r3 = [];
            t3.showCancel && r3.push({ key: 27, text: t3.cancelText, normal: true, onClick: this.handleCancel.bind(this) }), r3.push({ key: 13, text: t3.okText, onClick: this.handleOk.bind(this) }), n3.buttons = r3, this.input = uL.createElement("input", "input", null, { placeholder: t3.placeholder }), this.error = uL.createDiv("error"), n3.content = uL.createDomTree({ dom: uL.createDiv("input-wrapper"), children: [this.input, this.error] }), this.modal = new yL(n3);
          }
          handleCancel() {
            this.close().then(this.promiseReject.bind(this));
          }
          handleOk() {
            this.options.validator ? this.options.validator(this.input.value).then(() => {
              this.close().then(this.promiseResolve.bind(this, this.input.value));
            }, (e4) => {
              this.error.innerText = e4;
            }) : this.close().then(this.promiseResolve.bind(this, this.input.value));
          }
          open() {
            if (this.modal.wwise.opened)
              return;
            let e4 = this.modal.open();
            return this.input.value = "", this.error.innerText = "", this.input.focus(), this.promise = new Promise((e5, t3) => {
              this.promiseResolve = e5, this.promiseReject = t3;
            }), e4;
          }
          close() {
            if (this.modal.wwise.opened)
              return this.modal.close();
          }
          getPromise() {
            return this.promise;
          }
        }({ type: "info", title: null != r2 ? r2 : "&ndsp;", placeholder: null != t2 ? t2 : "", showCancel: n2, animation: "overlay", text: (null == e3 ? void 0 : e3.replace(r2 || "", "").replace(":", "")) || "" });
        return i2.open(), await i2.getPromise().catch(async () => null);
      };
    }
    async onRemove(e2) {
      return e2.alert = this._previousMappings.alert, e2.confirm = this._previousMappings.confirm, e2.prompt = this._previousMappings.prompt, super.onRemove(e2);
    }
  }
  TL.PluginType = "WindowiseDialogPlugin";
  var PL = __webpackgi_require__2(729), IL = {};
  PL.Z && PL.Z.locals && (IL.locals = PL.Z.locals);
  var RL, kL = 0, DL = {};
  DL.styleTagTransform = uc(), DL.setAttributes = oc(), DL.insert = function(e2, t2) {
    (t2.target || document.head).appendChild(e2);
  }, DL.domAPI = ic(), DL.insertStyleElement = lc(), IL.use = function(e2) {
    return DL.options = e2 || {}, kL++ || (RL = nc()(PL.Z, DL)), IL;
  }, IL.unuse = function() {
    kL > 0 && !--kL && (RL(), RL = null);
  };
  var BL = IL;
  function OL() {
    BL.use(), pv.use();
  }
  async function LL(e2, n2 = void 0, r2 = []) {
    var i2, s2;
    Mg.setDefaultProps({ theme: "editor", duration: 300, arrow: true, appendTo: () => e2.container });
    const o2 = (0, t.createDiv)({ classList: ["mode-buttons-container", "button-bar"], addToBody: true }), a2 = (0, t.createDiv)({ innerHTML: "", id: "webgi-logo", addToBody: false });
    (0, t.getUrlQueryParam)("logo-img") && (a2.style.backgroundImage = `url(${(0, t.getUrlQueryParam)("logo-img")})`), a2.onclick = () => {
      window.open((0, t.getUrlQueryParam)("logo-link") || "https://webgi.xyz", "_blank");
    };
    const l2 = '<svg xmlns="http://www.w3.org/2000/svg" style="width:100%; height:100%;" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">\n  <path stroke-linecap="round" stroke-linejoin="round" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4" />\n</svg>';
    e2.container.appendChild(a2), Mg(a2, { placement: "right", content: "Powered by WebGi SDK" });
    const c2 = (0, t.createDiv)({ innerHTML: l2, id: "fsToggle", classList: ["round-button"], addToBody: false });
    c2.dataset.tippyContent = "Full-Screen", null === (i2 = e2.getPlugin(wd)) || void 0 === i2 || i2.addEventListener("enter", () => {
      c2.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" style="width:100%; height:100%;" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">\n  <path d="M9 19L9 15M9 15L5 15M9 15L4 20M15 15L20 20M15 15V19M15 15H19M15 5V9M15 9L19 9M15 9L20 4M9 5L9 9M9 9L5 9M9 9L4 4" stroke-linecap="round" stroke-linejoin="round"/>\n</svg>', c2.dataset.tippyContent = "Exit Full-Screen";
    }), null === (s2 = e2.getPlugin(wd)) || void 0 === s2 || s2.addEventListener("exit", () => {
      c2.innerHTML = l2, c2.dataset.tippyContent = "Full-Screen";
    }), c2.onclick = () => {
      var t2;
      null === (t2 = e2.getPlugin(wd)) || void 0 === t2 || t2.toggle(e2.container);
    }, e2.container.appendChild(c2), Mg(c2, { placement: "left" });
    const u2 = (0, t.createDiv)({ classList: ["button-bar", "util-buttons-container"], addToBody: false });
    e2.container.appendChild(u2);
    const p2 = [{ id: "reset-settings", icon: '<svg xmlns="http://www.w3.org/2000/svg" style="width:100%; height:100%;" fill="currentColor" viewBox="0 0 24 24">\n <path fill="currentColor" d="M19 8L15 12H18C18 15.31 15.31 18 12 18C11 18 10.03 17.75 9.2 17.3L7.74 18.76C8.97 19.54 10.43 20 12 20C16.42 20 20 16.42 20 12H23M6 12C6 8.69 8.69 6 12 6C13 6 13.97 6.25 14.8 6.7L16.26 5.24C15.03 4.46 13.57 4 12 4C7.58 4 4 7.58 4 12H1L5 16L9 12M14 12C14 13.11 13.11 14 12 14S10 13.11 10 12 10.9 10 12 10 14 10.9 14 12Z" />\n</svg>', tooltip: "Reset All Settings", onclick: async () => {
      var t2;
      if (!await e2.confirm("Reset settings: Are you sure you want to reset all plugin settings?"))
        return;
      const n3 = _2.map((t3) => e2.getPlugin(t3));
      for (const e3 of n3)
        await (null === (t2 = null == e3 ? void 0 : e3.resetDefaults) || void 0 === t2 ? void 0 : t2.call(e3));
    } }, { id: "clear-scene", icon: '<svg xmlns="http://www.w3.org/2000/svg" style="width:100%; height:100%;" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">\n <path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />\n</svg>', tooltip: "Clear Scene", onclick: async () => {
      await e2.confirm("Clear scene: Are you sure you want to clear the scene?") && e2.scene.disposeSceneModels();
    } }, { id: "fit-scene", icon: '<svg xmlns="http://www.w3.org/2000/svg" style="width:100%; height:100%;" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1">\n    <path fill="currentColor" d="M17 12C17 7.55 11.62 5.31 8.46 8.46C5.31 11.61 7.55 17 12 17C14.76 17 17 14.76 17 12M12 15C9.33 15 8 11.77 9.88 9.88C11.77 8 15 9.33 15 12C15 13.66 13.66 15 12 15M5 15H3V19C3 20.1 3.9 21 5 21H9V19H5M5 5H9V3H5C3.9 3 3 3.9 3 5V9H5M19 3H15V5H19V9H21V5C21 3.9 20.1 3 19 3M19 19H15V21H19C20.1 21 21 20.1 21 19V15H19" />\n</svg>', tooltip: "Fit Object/Scene", onclick: async () => {
      var t2;
      await e2.fitToView(null === (t2 = e2.getPlugin(za)) || void 0 === t2 ? void 0 : t2.getSelectedObject());
    } }, { id: "loop-cam-views", icon: '<svg xmlns="http://www.w3.org/2000/svg" style="width:100%; height:100%;" fill="currentColor" viewBox="0 0 24 24">\n <path fill="currentColor" d="M19 8L15 12H18C18 15.31 15.31 18 12 18C11 18 10.03 17.75 9.2 17.3L7.74 18.76C8.97 19.54 10.43 20 12 20C16.42 20 20 16.42 20 12H23M6 12C6 8.69 8.69 6 12 6C13 6 13.97 6.25 14.8 6.7L16.26 5.24C15.03 4.46 13.57 4 12 4C7.58 4 4 7.58 4 12H1L5 16L9 12M14 12C14 13.11 13.11 14 12 14S10 13.11 10 12 10.9 10 12 10 14 10.9 14 12Z" />\n</svg>', tooltip: "Loop Camera Views", toggle: true, onclick: async () => {
      e2.getPlugin(zp) && (e2.getPlugin(zp).viewLooping = !e2.getPlugin(zp).viewLooping);
    } }, { id: "play-gltf", icon: '<svg xmlns="http://www.w3.org/2000/svg" style="width:100%; height:100%;" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">\n  <path stroke-linecap="round" stroke-linejoin="round" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />\n  <path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />\n</svg>', tooltip: "GLTF Animations", toggle: true, onclick: async () => {
      var t2;
      null === (t2 = e2.getPlugin(Ya)) || void 0 === t2 || t2.playPauseAnimation();
    } }, { id: "auto-rotate-cc", icon: '<svg xmlns="http://www.w3.org/2000/svg" style="width:100%; height:100%;" fill="currentColor" viewBox="0 0 24 24">\n <path fill="currentColor" d="M10,12L14,16L10,20V16.9C5.44,16.44 2,14.42 2,12C2,9.58 5.44,7.56 10,7.1V9.09C6.55,9.43 4,10.6 4,12C4,13.4 6.55,14.57 10,14.91V12M20,12C20,10.6 17.45,9.43 14,9.09V7.1C18.56,7.56 22,9.58 22,12C22,14.16 19.26,16 15.42,16.7L16.12,16L14.92,14.79C17.89,14.36 20,13.27 20,12M11,2H13V13L11,11V2M11,22V21L13,19V22H11Z" />\n</svg>', tooltip: "Auto rotate", toggle: true, onclick: async () => {
      const t2 = e2.scene.activeCamera.controls;
      t2 && void 0 !== t2.autoRotate && (t2.autoRotate = !t2.autoRotate);
    } }, { id: "snapshot", icon: '<svg xmlns="http://www.w3.org/2000/svg" style="width:100%; height:100%;" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">\n  <path stroke-linecap="round" stroke-linejoin="round" d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z" />\n  <path stroke-linecap="round" stroke-linejoin="round" d="M15 13a3 3 0 11-6 0 3 3 0 016 0z" />\n</svg>', tooltip: "Capture Snapshot", onclick: async () => {
      const t2 = e2.getPlugin(Fc);
      t2 ? await t2.downloadSnapshot() : e2.console.error("CanvasSnipperPlugin not added");
    } }, { id: "glb-export", icon: '<svg xmlns="http://www.w3.org/2000/svg" style="width:100%; height:100%;" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">\n  <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />\n</svg>', tooltip: "Export GLB", onclick: async () => {
      const t2 = e2.getPlugin(ub);
      t2 ? await (null == t2 ? void 0 : t2.downloadSceneGlb()) : e2.console.error("AssetExporterPlugin not added");
    } }];
    for (const e3 of p2) {
      const n3 = (0, t.createDiv)({ innerHTML: e3.icon, id: e3.id, classList: ["button-bar-button", "util-button"], addToBody: false });
      n3.dataset.tippyContent = e3.tooltip, n3.onclick = () => {
        e3.toggle && n3.classList.toggle("button-bar-selected-box"), e3.onclick();
      }, u2.appendChild(n3);
    }
    Sg(Mg(".util-button"), { moveTransition: "transform 0.2s ease-out", placement: "top" });
    const d2 = e2.getPlugin(za), h2 = e2.getPlugin(rv);
    for (const [e3, t2] of Object.entries(null != n2 ? n2 : {})) {
      const n3 = r2.find((t3) => t3.title === e3);
      n3 ? n3.plugins.push(...t2) : r2.push({ title: e3, plugins: [...t2] });
    }
    let f2 = r2[2], m2 = [];
    const _2 = r2.reduce((e3, t2) => e3.concat(t2.plugins), []);
    function g2(n3) {
      var i3;
      f2 = n3, d2 && (d2.enabled = true), h2 && (["Plugins"].includes(f2.title) ? h2.enable("modesUi") : h2.disable("modesUi")), m2 = [];
      for (const r3 of _2) {
        const i4 = e2.getPlugin(r3);
        if (!(null == i4 ? void 0 : i4.uiConfig))
          continue;
        const s3 = n3.plugins.includes(r3);
        (0, t.safeSetProperty)(i4.uiConfig, "hidden", !s3, true), s3 && m2.push(i4);
      }
      for (const e3 of r2)
        null === (i3 = e3.div) || void 0 === i3 || i3.classList[f2 !== e3 ? "remove" : "add"]("mode-button-selected", "button-bar-selected");
      e2.getPlugin(YO).refreshPluginsEnabled();
    }
    for (const e3 of r2) {
      const n3 = (0, t.createDiv)({ innerHTML: e3.title, classList: ["mode-button", "button-bar-button"] });
      n3.onclick = () => {
        g2(e3);
      }, e3.div = n3, o2.appendChild(n3);
    }
    g2(r2[0]), window.webgi_setEditorMode = g2, window.webgi_editorModes = r2, null == d2 || d2.addEventListener("selectedObjectChanged", () => {
      (null == d2 ? void 0 : d2.getSelectedObject()) && !["Picking", "Modifiers", "Configurators"].includes(f2.title) && g2(r2.find((e3) => e3.plugins.includes(za)));
    });
  }
  class UL extends gt {
    constructor() {
      super(...arguments), this.enabled = true, this.toJSON = void 0, this.uiConfig = { type: "folder", label: "Extras", limitedUi: false, children: [() => ({ label: "Color Scheme", type: "dropdown", children: ["black", "white", "blue"].map((e2) => ({ label: e2 })), getValue: () => {
        var e2, t2;
        return null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPluginByType("TweakpaneUi")) || void 0 === t2 ? void 0 : t2.colorMode;
      }, setValue: (e2) => {
        var t2;
        const n2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPluginByType("TweakpaneUi");
        n2 && (n2.colorMode = e2);
      } }), () => ({ label: "Shadow type", type: "dropdown", children: [["Basic", n._MY], ["PCF", n._iA], ["PCFSoft", n.ntZ], ["VSM", n.dwk]].map((e2) => ({ label: e2[0], value: e2[1] })), getValue: () => {
        var e2;
        return null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.renderer.rendererObject.shadowMap.type;
      }, setValue: (e2) => {
        var t2;
        null === (t2 = this._viewer) || void 0 === t2 || t2.doOnce("postFrame", () => {
          this._viewer && (this._viewer.renderer.rendererObject.shadowMap.type = e2, this._viewer.renderer.resetShadows(), this._viewer.renderer.reset(), this._viewer.scene.setDirty({ sceneUpdate: true, frameFade: false }), this._viewer.setDirty());
        });
      } }), () => {
        var e2;
        return { label: ((null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.useRgbm) ? "Disable" : "Enable") + " RGBM", type: "button", value: async () => {
          var e3, n2;
          await (null === (e3 = this._viewer) || void 0 === e3 ? void 0 : e3.confirm("Edit Extras: This will reload the webpage. Are you sure?")) && (0, t.setUrlQueryParam)("rgbm", (null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.useRgbm) ? "no" : "yes", true);
        } };
      }, () => {
        var e2;
        return { label: ((null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.isAntialiased) ? "Disable" : "Enable") + " MSAA", type: "button", value: async () => {
          var e3, n2;
          await (null === (e3 = this._viewer) || void 0 === e3 ? void 0 : e3.confirm("Edit Extras: This will reload the webpage. Are you sure?")) && (0, t.setUrlQueryParam)("msaa", (null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.isAntialiased) ? "no" : "yes", true);
        } };
      }, () => {
        var e2;
        return { label: ((null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.useGBufferDepth) ? "Disable" : "Enable") + " Depth(z) Prepass", type: "button", value: async () => {
          var e3, n2;
          await (null === (e3 = this._viewer) || void 0 === e3 ? void 0 : e3.confirm("Edit Extras: This will reload the webpage. Are you sure?")) && (0, t.setUrlQueryParam)("depthPrepass", (null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.useGBufferDepth) ? "no" : "yes", true);
        } };
      }, () => {
        var e2;
        return { label: ((null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPluginByType("debug")) ? "Disable" : "Enable") + " Debug", type: "button", value: async () => {
          var e3, n2;
          await (null === (e3 = this._viewer) || void 0 === e3 ? void 0 : e3.confirm("Edit Extras: This will reload the webpage. Are you sure?")) && (0, t.setUrlQueryParam)("debug", (null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.getPluginByType("debug")) ? null : "true", true);
        } };
      }, { label: "Clear local storage", type: "button", value: async () => {
        var e2;
        await (null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.confirm("Edit Extras: This will clear all local storage. Are you sure?")) && localStorage.clear();
      } }, { label: "Clear caches", type: "button", value: async () => {
        var e2, t2;
        const n2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPlugin(Ls)) || void 0 === t2 ? void 0 : t2.storage;
        if (n2 instanceof Storage)
          n2.clear();
        else if (n2 instanceof Cache) {
          const e3 = await n2.keys();
          await Promise.all(e3.map(async (e4) => n2.delete(e4)));
        }
        localStorage.clear();
      } }, { label: "Auto GPU instance all", type: "button", value: () => {
        var e2;
        const t2 = /* @__PURE__ */ new Set();
        null === (e2 = this._viewer) || void 0 === e2 || e2.scene.modelRoot.traverse((e3) => e3.geometry && t2.add(e3.geometry)), t2.forEach((e3) => _e(e3));
      } }, { label: "Auto Center All Geometries", type: "button", value: () => {
        var e2;
        const t2 = /* @__PURE__ */ new Set();
        null === (e2 = this._viewer) || void 0 === e2 || e2.scene.modelRoot.traverse((e3) => e3.geometry && t2.add(e3.geometry)), t2.forEach((e3) => {
          const t3 = new n.Pa4();
          e3.center(t3), t3.negate();
          const r2 = e3.userData.__appliedMeshes;
          r2 || console.error("No meshes found for geometry", e3), null == r2 || r2.forEach((e4) => {
            e4.updateMatrix(), e4.position.copy(t3).applyMatrix4(e4.matrix), e4.setDirty && e4.setDirty();
          });
        });
      } }] };
    }
  }
  UL.PluginType = "ExtrasUiPlugin1";
  class FL extends n.Tme {
    constructor(e2) {
      super(), this.modelObject = this, this.assetType = "widget", this.visible = true, this.uiConfig = Qe("Widget", this), this.object = e2, this.object.updateMatrixWorld(), this.object.updateProjectionMatrix && this.object.updateProjectionMatrix(), this.matrix = e2.matrixWorld, this.matrixAutoUpdate = false, this._objectUpdate = this._objectUpdate.bind(this), this.attach(e2), this.traverse((e3) => {
        e3.userData.__keepShadowDef = true, e3.castShadow = false, e3.receiveShadow = false;
      });
    }
    dispose() {
      this.detach();
    }
    _objectUpdate() {
      this.object && this.update();
    }
    attach(e2) {
      var t2, n2;
      return this.object && this.detach(), this.object = e2, this.object && (this.update(), this.object.addEventListener("objectUpdate", this._objectUpdate), this.object.addEventListener("dispose", this.dispose), this.uiConfig && (null === (n2 = null === (t2 = this.object.uiConfig) || void 0 === t2 ? void 0 : t2.children) || void 0 === n2 || n2.push(this.uiConfig)), this.visible = true), this;
    }
    detach() {
      var e2, t2, n2, r2;
      if (this.object) {
        if (this.object.removeEventListener("objectUpdate", this._objectUpdate), this.object.removeEventListener("dispose", this.dispose), this.uiConfig) {
          const i2 = null === (t2 = null === (e2 = this.object.uiConfig) || void 0 === e2 ? void 0 : e2.children) || void 0 === t2 ? void 0 : t2.indexOf(this.uiConfig);
          void 0 !== i2 && i2 >= 0 && (null === (r2 = null === (n2 = this.object.uiConfig) || void 0 === n2 ? void 0 : n2.children) || void 0 === r2 || r2.splice(i2, 1));
        }
        this.object = void 0, this.visible = false;
      }
      return this;
    }
  }
  !function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    s2 > 3 && o2 && Object.defineProperty(t2, n2, o2);
  }([Oe()], FL.prototype, "visible", void 0);
  class NL extends FL {
    constructor(e2) {
      super(e2), this.light = e2, this.traverse((e3) => {
        e3.userData.__keepShadowDef = true, e3.castShadow = false, e3.receiveShadow = false;
      });
    }
  }
  var jL = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  class zL extends NL {
    constructor(e2, t2, r2) {
      super(e2), this.lineWidth = 5, this.size = 0.5, this._v1 = new n.Pa4(), this._v2 = new n.Pa4(), this._v3 = new n.Pa4(), this.color = r2, void 0 !== t2 && (this.size = t2);
      let i2 = new Jv();
      this.material = new ta({ color: 16711680, linewidth: 5e-3, vertexColors: false, dashed: false, alphaToCoverage: true, toneMapped: false, transparent: true, depthTest: false, depthWrite: false }), this.lightPlane = new Zv(i2, this.material), this.add(this.lightPlane), i2 = new Jv(), i2.setPositions([0, 0, 0, 0, 0, 1]), this.targetLine = new Zv(i2, this.material), this.add(this.targetLine), this.update(), this.traverse((e3) => {
        e3.userData.__keepShadowDef = true, e3.castShadow = false, e3.receiveShadow = false;
      });
    }
    dispose() {
      this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose(), super.dispose();
    }
    update() {
      var e2;
      this.light && this.lightPlane && (this._v1.setFromMatrixPosition(this.light.matrixWorld), this._v2.setFromMatrixPosition(this.light.target.matrixWorld), this._v3.subVectors(this._v2, this._v1), this.lightPlane.geometry.setPositions([-this.size, this.size, 0, this.size, this.size, 0, this.size, -this.size, 0, -this.size, -this.size, 0, -this.size, this.size, 0]), this.lightPlane.lookAt(this._v2), this.lightPlane.material = this.material, this.targetLine.material = this.material, this.material.color.set(null !== (e2 = this.color) && void 0 !== e2 ? e2 : this.light.color), this.material.linewidth = 1e-3 * this.lineWidth, this.targetLine.lookAt(this._v2), this.targetLine.scale.z = this.light.intensity / 3);
    }
    static Check(e2) {
      return e2.isDirectionalLight;
    }
    static Create(e2) {
      return new zL(e2);
    }
  }
  jL([(0, t.onChange)(zL.prototype.update)], zL.prototype, "material", void 0), jL([(0, t.onChange)(zL.prototype.update), Ue(void 0, [0.1, 20], 0.01)], zL.prototype, "lineWidth", void 0), jL([(0, t.onChange)(zL.prototype.update), Ue(void 0, [0.01, 10], 0.01)], zL.prototype, "size", void 0);
  var GL = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  class VL extends NL {
    constructor(e2, t2, r2) {
      super(e2), this.lineWidth = 5, this.size = 0.5, this.color = r2, void 0 !== t2 && (this.size = t2);
      const i2 = new ea(new n.xo$(0.5, 4, 2));
      this.material = new ta({ color: 16711680, linewidth: 5e-3, vertexColors: false, dashed: false, alphaToCoverage: true, toneMapped: false, transparent: true, depthTest: false, depthWrite: false }), this.lightSphere = new ia(i2, this.material), this.lightSphere.computeLineDistances(), this.add(this.lightSphere), this.update(), this.traverse((e3) => {
        e3.userData.__keepShadowDef = true, e3.castShadow = false, e3.receiveShadow = false;
      });
    }
    dispose() {
      this.lightSphere.geometry.dispose(), this.lightSphere.material.dispose(), super.dispose();
    }
    update() {
      var e2;
      this.light && this.lightSphere && (this.material.color.set(null !== (e2 = this.color) && void 0 !== e2 ? e2 : this.light.color), this.material.linewidth = 1e-3 * this.lineWidth, this.lightSphere.scale.setScalar(this.size));
    }
    static Check(e2) {
      return e2.isPointLight;
    }
    static Create(e2) {
      return new VL(e2);
    }
  }
  GL([(0, t.onChange)(VL.prototype.update)], VL.prototype, "material", void 0), GL([(0, t.onChange)(VL.prototype.update), Ue(void 0, [0.1, 20], 0.01)], VL.prototype, "lineWidth", void 0), GL([(0, t.onChange)(VL.prototype.update), Ue(void 0, [0.01, 10], 0.01)], VL.prototype, "size", void 0);
  var HL = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  class QL extends NL {
    constructor(e2, t2, r2) {
      super(e2), this.lineWidth = 5, this._v1 = new n.Pa4(), this.color = r2, void 0 === t2 && (t2 = 0.5);
      let i2 = new $o();
      const s2 = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
      for (let e3 = 0, t3 = 1, n2 = 32; e3 < n2; e3++, t3++) {
        const r3 = e3 / n2 * Math.PI * 2, i3 = t3 / n2 * Math.PI * 2;
        s2.push(Math.cos(r3), Math.sin(r3), 1, Math.cos(i3), Math.sin(i3), 1);
      }
      i2.setPositions(s2), this.material = new ta({ color: 16711680, linewidth: 5e-3, vertexColors: false, dashed: false, alphaToCoverage: true, toneMapped: false, transparent: true, depthTest: false, depthWrite: false }), this.cone = new Kv(i2, this.material), this.add(this.cone), i2 = new Jv(), i2.setPositions([0, 0, 0, 0, 0, 1]), this.update(), this.traverse((e3) => {
        e3.userData.__keepShadowDef = true, e3.castShadow = false, e3.receiveShadow = false;
      });
    }
    dispose() {
      this.cone.geometry.dispose(), this.cone.material.dispose(), super.dispose();
    }
    update() {
      var e2;
      if (!this.light || !this.cone)
        return;
      this.light.updateWorldMatrix(true, false), this.light.target.updateWorldMatrix(true, false);
      const t2 = this.light.distance ? this.light.distance : 1e3, n2 = t2 * Math.tan(this.light.angle);
      this.cone.scale.set(n2, n2, t2), this._v1.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(this._v1), this.material.color.set(null !== (e2 = this.color) && void 0 !== e2 ? e2 : this.light.color), this.material.linewidth = 1e-3 * this.lineWidth;
    }
    static Check(e2) {
      return e2.isSpotLight;
    }
    static Create(e2) {
      return new QL(e2);
    }
  }
  HL([(0, t.onChange)(QL.prototype.update)], QL.prototype, "material", void 0), HL([(0, t.onChange)(QL.prototype.update), Ue(void 0, [0.1, 20], 0.01)], QL.prototype, "lineWidth", void 0);
  class WL extends FL {
    constructor(e2) {
      super(e2), this.camera = e2, this.traverse((e3) => {
        e3.userData.__keepShadowDef = true, e3.castShadow = false, e3.receiveShadow = false;
      });
    }
  }
  class qL extends WL {
    constructor(e2) {
      super(e2), this._vector = new n.Pa4(), this._camera = new n.V1s();
      const t2 = new $o(), r2 = new ta({ color: 16777215, linewidth: 5e-3, vertexColors: true, dashed: false, alphaToCoverage: true, toneMapped: false, transparent: true, depthTest: false, depthWrite: false }), { vertices: i2, colors: s2, pointMap: o2 } = function() {
        const e3 = [], t3 = [], n2 = {};
        function r3(e4, t4) {
          i3(e4), i3(t4);
        }
        function i3(r4) {
          e3.push(0, 0, 0), t3.push(0, 0, 0), void 0 === n2[r4] && (n2[r4] = []), n2[r4].push(e3.length / 3 - 1);
        }
        return r3("n1", "n2"), r3("n2", "n4"), r3("n4", "n3"), r3("n3", "n1"), r3("f1", "f2"), r3("f2", "f4"), r3("f4", "f3"), r3("f3", "f1"), r3("n1", "f1"), r3("n2", "f2"), r3("n3", "f3"), r3("n4", "f4"), r3("p", "n1"), r3("p", "n2"), r3("p", "n3"), r3("p", "n4"), r3("u1", "u2"), r3("u2", "u3"), r3("u3", "u1"), r3("c", "t"), r3("p", "c"), r3("cn1", "cn2"), r3("cn3", "cn4"), r3("cf1", "cf2"), r3("cf3", "cf4"), { vertices: e3, colors: t3, pointMap: n2 };
      }();
      t2.setPositions(i2), t2.setColors(s2), this.line = new Kv(t2, r2), this.line.frustumCulled = false, this.add(this.line), this.pointMap = o2, this.update();
      const a2 = new n.Ilk(16755200), l2 = new n.Ilk(16711680), c2 = new n.Ilk(43775), u2 = new n.Ilk(16777215), p2 = new n.Ilk(3355443);
      this.setColors(a2, l2, c2, u2, p2);
    }
    setColors(e2, t2, n2, r2, i2) {
      const s2 = this.line.geometry, o2 = s2.getAttribute("instanceColorStart"), a2 = s2.getAttribute("instanceColorEnd");
      function l2(e3, t3) {
        o2.setXYZ(e3 / 2, t3.r, t3.g, t3.b), a2.setXYZ(e3 / 2, t3.r, t3.g, t3.b);
      }
      l2(0, e2), l2(2, e2), l2(4, e2), l2(6, e2), l2(8, e2), l2(10, e2), l2(12, e2), l2(14, e2), l2(16, e2), l2(18, e2), l2(20, e2), l2(22, e2), l2(24, t2), l2(26, t2), l2(28, t2), l2(30, t2), l2(32, n2), l2(34, n2), l2(36, n2), l2(38, r2), l2(40, i2), l2(42, i2), l2(44, i2), l2(46, i2), l2(48, i2), o2.needsUpdate = true, a2.needsUpdate = true;
    }
    update() {
      if (!this.camera)
        return;
      const e2 = this.line.geometry, t2 = this.pointMap, { _camera: n2, _vector: r2 } = this;
      n2.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), XL("c", t2, e2, n2, 0, 0, -1, r2), XL("t", t2, e2, n2, 0, 0, 1, r2), XL("n1", t2, e2, n2, -1, -1, -1, r2), XL("n2", t2, e2, n2, 1, -1, -1, r2), XL("n3", t2, e2, n2, -1, 1, -1, r2), XL("n4", t2, e2, n2, 1, 1, -1, r2), XL("f1", t2, e2, n2, -1, -1, 1, r2), XL("f2", t2, e2, n2, 1, -1, 1, r2), XL("f3", t2, e2, n2, -1, 1, 1, r2), XL("f4", t2, e2, n2, 1, 1, 1, r2), XL("u1", t2, e2, n2, 0.7, 1.1, -1, r2), XL("u2", t2, e2, n2, -0.7, 1.1, -1, r2), XL("u3", t2, e2, n2, 0, 2, -1, r2), XL("cf1", t2, e2, n2, -1, 0, 1, r2), XL("cf2", t2, e2, n2, 1, 0, 1, r2), XL("cf3", t2, e2, n2, 0, -1, 1, r2), XL("cf4", t2, e2, n2, 0, 1, 1, r2), XL("cn1", t2, e2, n2, -1, 0, -1, r2), XL("cn2", t2, e2, n2, 1, 0, -1, r2), XL("cn3", t2, e2, n2, 0, -1, -1, r2), XL("cn4", t2, e2, n2, 0, 1, -1, r2), e2.getAttribute("instanceStart").needsUpdate = true, e2.getAttribute("instanceEnd").needsUpdate = true, e2.computeBoundingBox(), e2.computeBoundingSphere();
    }
    dispose() {
      this.line.geometry.dispose(), this.line.material.dispose(), super.dispose();
    }
    static Check(e2) {
      return e2.isCamera;
    }
    static Create(e2) {
      return new qL(e2);
    }
  }
  function XL(e2, t2, n2, r2, i2, s2, o2, a2) {
    a2.set(i2, s2, o2).unproject(r2);
    const l2 = t2[e2];
    if (void 0 !== l2) {
      const e3 = n2.getAttribute("instanceStart"), t3 = n2.getAttribute("instanceEnd");
      for (let n3 = 0, r3 = l2.length; n3 < r3; n3++) {
        const r4 = Math.floor(l2[n3] / 2);
        (l2[n3] % 2 == 0 ? e3 : t3).setXYZ(r4, a2.x, a2.y, a2.z);
      }
    }
  }
  class YL extends gt {
    setDirty() {
      var e2, t2;
      null === (e2 = this.widgets) || void 0 === e2 || e2.forEach((e3) => e3.visible = this.enabled), null === (t2 = this._viewer) || void 0 === t2 || t2.setDirty();
    }
    constructor(e2 = true) {
      super(), this.enabled = true, this.helpers = [zL, QL, VL, qL], this.toJSON = null, this._addSceneObject = (e3) => {
        const t2 = e3.object;
        this._createWidgets(null == t2 ? void 0 : t2.modelObject);
      }, this.widgets = [], this.uiConfig = { type: "folder", label: "Widgets", children: [{ type: "checkbox", label: "Visible", property: [this, "enabled"] }, { type: "button", label: "Refresh", value: () => this.refresh() }] }, this.enabled = e2;
    }
    async onAdded(e2) {
      await super.onAdded(e2), e2.scene.addEventListener("addSceneObject", this._addSceneObject);
    }
    async onRemove(e2) {
      return e2.scene.removeEventListener("addSceneObject", this._addSceneObject), this.widgets.forEach((e3) => e3.dispose && e3.dispose()), this.widgets = [], super.onRemove(e2);
    }
    refresh() {
      var e2;
      this._createWidgets(null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.scene.modelRoot);
    }
    _createWidgets(e2) {
      null == e2 || e2.traverse((e3) => {
        const t2 = this.widgets.find((t3) => t3.object === e3);
        if (t2)
          return void (t2.update && t2.update());
        this.helpers.filter((t3) => t3.Check(e3)).forEach((t3) => {
          var n2;
          const r2 = t3.Create(e3);
          r2.visible = this.enabled, this.widgets.push(r2), null === (n2 = this._viewer) || void 0 === n2 || n2.scene.addWidget(r2);
        });
      });
    }
  }
  YL.PluginType = "WidgetsPlugin", function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    s2 > 3 && o2 && Object.defineProperty(t2, n2, o2);
  }([(0, t.onChange)(YL.prototype.setDirty)], YL.prototype, "enabled", void 0);
  var KL = s_({ defaultModifiers: [l_, h_, __, g_] }), JL = __webpackgi_require__2(388), ZL = __webpackgi_require__2.n(JL);
  function $L(e2) {
    const t2 = [];
    e2.traverse((e3) => {
      e3.geometry && t2.push(e3);
    });
    const n2 = {}, r2 = {};
    t2.forEach((e3) => {
      var t3;
      if (!n2[e3.geometry.uuid]) {
        const t4 = e3.geometry.toJSON().data, r3 = t4 ? ZL()({ a: t4.attributes || {}, b: t4.index || [] }) : "";
        n2[e3.geometry.uuid] = r3;
      }
      const i2 = n2[e3.geometry.uuid], s2 = null !== (t3 = r2[i2]) && void 0 !== t3 ? t3 : r2[i2] = [];
      s2.includes(e3) || s2.push(e3);
    }), Object.values(r2).forEach((e3) => {
      if (e3.length < 2)
        return;
      const t3 = e3[0].geometry;
      e3.forEach((e4, n3) => {
        n3 < 1 || (e4.geometry.dispose(), e4.geometry = t3);
      });
    });
  }
  const eU = new n.Pa4(), tU = new n.Pa4(), nU = new n.Pa4(), rU = new n.Pa4(), iU = new n.Pa4(), sU = new n.Pa4();
  let oU = 1;
  const aU = new n.Pa4(0, 1, 0);
  class lU extends Ze {
    constructor(e2, t2) {
      super(e2, t2), this.throttleUpdate = 60, this.targetOffset = new n.Pa4(0, 0, 0);
      const r2 = this.update;
      this.update = () => this._update(r2);
    }
    _update(e2) {
      this.target.add(this.targetOffset), eU.copy(this.object.position).sub(this.target), oU = eU.length(), sU.copy(this.target);
      const t2 = e2();
      return sU.sub(this.target), eU.copy(this.object.position).sub(this.target), oU /= eU.length(), this.target.add(sU), this.object.position.copy(this.target).add(eU), eU.normalize(), tU.crossVectors(aU, eU).normalize(), nU.crossVectors(eU, tU).normalize(), rU.crossVectors(tU, nU).normalize().negate(), tU.length() > 0.1 && this.object.up.crossVectors(eU.clone().normalize(), tU), this.enablePan && (iU.set(0, 0, 0).addScaledVector(tU, sU.x).addScaledVector(nU, sU.y).addScaledVector(rU, sU.z), this.targetOffset.add(iU), this.targetOffset.multiplyScalar(1 / oU)), iU.set(0, 0, 0).addScaledVector(tU, -this.targetOffset.x).addScaledVector(nU, -this.targetOffset.y).addScaledVector(rU, -this.targetOffset.z), this.object.lookAt(iU.add(this.target)), this.object.updateMatrixWorld(), this.object.isCamera && this.object.updateProjectionMatrix(), this.target.sub(this.targetOffset), t2;
    }
  }
  class cU extends t.SimpleEventDispatcher {
    _setOptions(e2) {
      var t2, n2;
      Object.assign(this._options, e2), this._options.mimeType && "auto" !== this._options.mimeType || (this._options.mimeType = null !== (t2 = cU.GetSupportedMimeTypes([], ["h264"], true)) && void 0 !== t2 ? t2 : cU.GetSupportedMimeTypes(void 0, void 0, true)), this._options.mimeType && !(null === (n2 = this._options.mimeType) || void 0 === n2 ? void 0 : n2.startsWith("video/")) || window.MediaRecorder || (this._console.warn("MediaRecorder is not supported, switching to png"), this._options.mimeType = "image/png"), this._options.mimeType || console.warn(new Error("No supported mimetype found"));
    }
    setOptions(e2) {
      this._setOptions(e2);
    }
    constructor(e2, n2) {
      super(), this._state = "stopped", this._console = console, this._currentRecording = [], this._currentImages = [], this.stepMode = false, this._resumeSyncTime = 0, this._frameCount = 0, this._onstop = (e3) => {
        var t2;
        if (this._state = "stopped", this._recorder && this._currentRecording.length > 0) {
          const e4 = new Blob(this._currentRecording, { type: this._options.mimeType });
          null === (t2 = this._recordingCallback) || void 0 === t2 || t2.call(this, e4);
        } else
          this._currentImages.length > 0 && (this._writeImages([...this._currentImages]), this._currentImages = []);
        this._recorder = void 0, this.dispatchEvent({ type: "stop" });
      }, this._onstart = (e3) => {
        var t2;
        this._state = "recording", this._frameCount = 0, this.dispatchEvent({ type: "start" }), this.stepMode && (null === (t2 = this._recorder) || void 0 === t2 || t2.pause());
      }, this._onresume = (e3) => {
        if (!this.stepMode)
          return;
        const n3 = () => {
          var e4;
          "recording" === this._state && (null === (e4 = this._recorder) || void 0 === e4 || e4.pause());
        }, r3 = Math.min(this._resumeSyncTime - (0, t.now)(), 0) + 1e3 / this._options.frameRate;
        r3 > 0 ? (0, t.timeout)(r3).then(n3) : n3();
      }, this._onpause = (e3) => {
      }, this._ondataavailable = (e3) => {
        e3.data && e3.data.size > 0 && this._currentRecording.push(e3.data);
      }, this._onerror = (e3) => {
        this._state = "error", this._console.error(e3), this.dispatchEvent({ type: "error", error: e3 }), this._recorder = void 0;
      }, this._canvas = e2;
      const r2 = null == n2 ? void 0 : n2.mimeType;
      this._options = { mimeType: r2 || "auto", frameRate: 30, stepMode: false }, this._setOptions(n2 || this._options);
    }
    isRecording() {
      return "recording" === this._state;
    }
    start() {
      var e2, t2, n2;
      if ("recording" === this._state)
        return void this._console.log("Already recording canvas");
      if ("error" === this._state && (this._recorder = void 0, this._console.warn("Resetting from error state.")), this._recorder)
        return "paused" === this._state ? (this.dispatchEvent({ type: "starting" }), void this._recorder.resume()) : void this._console.warn("Canvas recorder unknown state", this._state);
      if ("paused" === this._state)
        return this.dispatchEvent({ type: "starting" }), void (this._state = "recording");
      const r2 = { mimeType: this._options.mimeType, videoBitsPerSecond: this._options.videoBitsPerSecond };
      if (this._currentRecording = [], this._currentImages = [], this._frameCount = 0, null === (e2 = r2.mimeType) || void 0 === e2 ? void 0 : e2.startsWith("video")) {
        if (!window.MediaRecorder)
          return this._console.error("MediaRecorder not supported, use image sequence"), void (this._state = "error");
        {
          const e3 = this._canvas.captureStream(this.stepMode ? 0 : this._options.frameRate), n3 = null === (t2 = e3.getVideoTracks()) || void 0 === t2 ? void 0 : t2[0];
          this._track = n3, this._recorder = new window.MediaRecorder(e3, r2), this._recorder.onstop = this._onstop, this._recorder.ondataavailable = this._ondataavailable, this._recorder.onerror = this._onerror, this._recorder.onresume = this._onresume, this._recorder.onstart = this._onstart;
        }
      }
      this.dispatchEvent({ type: "starting" }), this._recorder ? (this._state = "recording", null === (n2 = this._recorder) || void 0 === n2 || n2.start()) : window && window.showDirectoryPicker && window.showDirectoryPicker().then(async (e3) => {
        const t3 = await (null == e3 ? void 0 : e3.getDirectoryHandle("i-" + Math.floor(Date.now()), { create: true }));
        this._imgDirectory = t3, this._state = "recording", this._onstart({});
      }).catch((e3) => {
        this._onerror({ detail: e3 });
      });
    }
    async requestFrame() {
      if ("recording" !== this._state)
        return;
      this._frameCount++;
      const e2 = this._options.mimeType;
      if (!this._recorder && e2.startsWith("image/")) {
        const t2 = this._canvas.toDataURL(e2, 90);
        this._currentImages.push(["frame_" + String(this._frameCount).padStart(5, "0") + (e2.includes("png") ? ".png" : ".jpg"), t2]), this._currentImages.length > 60 && (this._writeImages([...this._currentImages]), this._currentImages = []);
      }
      this._recorder && this._track && this.stepMode && (this._resumeSyncTime = (0, t.now)(), this._track.requestFrame(), this._recorder.resume());
    }
    pause() {
      "paused" !== this._state && "stopped" !== this._state && (this._recorder ? this._recorder.pause() : this._state = "paused");
    }
    stop(e2) {
      "stopped" !== this._state && ("error" !== this._state ? (this._recordingCallback = e2, this.dispatchEvent({ type: "stopping" }), this._recorder ? this._recorder.stop() : this._onstop({})) : this._console.error("Recorder in error state, cannot stop, call start again."));
    }
    get state() {
      return this._state;
    }
    dispose() {
      this._recorder && "error" !== this._state ? this.stop((e2) => {
        this._console.warn("disposed with blob", e2), this.dispose();
      }) : this._recorder = void 0;
    }
    async _writeImages(e2) {
      if (!this._imgDirectory)
        return;
      const n2 = await Promise.all(e2.map(async ([e3, t2]) => await (await fetch(t2)).blob())), r2 = [];
      for (let i2 = 0; i2 < e2.length; i2++) {
        const s2 = await this._imgDirectory.getFileHandle(e2[i2][0], { create: true });
        r2.push((0, t.writeFile)(s2, n2[i2]));
      }
      await Promise.all(r2);
    }
    static GetSupportedMimeTypes(e2, t2, n2 = false) {
      if (!window.MediaRecorder)
        return n2 ? void 0 : [];
      const r2 = ["webm", "ogg", "mp4", "x-matroska"].filter((t3) => !e2 || e2.length < 1 || e2.includes(t3)), i2 = ["vp9", "vp9.0", "vp8", "vp8.0", "avc1", "av1", "h265", "h.265", "h264", "h.264", "opus"].filter((e3) => !t2 || t2.length < 1 || t2.includes(e3)), s2 = [];
      return r2.forEach((e3) => {
        const t3 = `video/${e3}`;
        i2.forEach((e4) => {
          [`${t3};codecs=${e4}`, `${t3};codecs:${e4}`, `${t3};codecs=${e4.toUpperCase()}`, `${t3};codecs:${e4.toUpperCase()}`, `${t3}`].forEach((e5) => {
            MediaRecorder.isTypeSupported(e5) && s2.push(e5);
          });
        });
      }), n2 ? s2.length > 0 ? s2[0] : void 0 : s2;
    }
  }
  class uU extends sa {
    constructor() {
      super(), this.boundingScaleMultiplier = 1.2, this._initGeometry(new n.cJO(1, 0));
    }
  }
  function pU(e2, t2, n2) {
    var r2, i2;
    let s2 = Array.from((null !== (r2 = e2.access) && void 0 !== r2 ? r2 : "").split(".")), o2 = null !== (i2 = e2.targetObject) && void 0 !== i2 ? i2 : t2;
    const a2 = s2.pop();
    if (!a2 || 0 === a2.length)
      return { key: void 0, tar: o2 };
    if ((n2 = null != n2 ? n2 : null == t2 ? void 0 : t2._animGetters) && s2[0] in n2) {
      const e3 = n2[s2[0]](s2);
      e3 ? (o2 = e3.tar, s2 = s2.slice(e3.i + 1)) : o2 = e3;
    }
    return o2 = function(e3, t3, n3 = false) {
      for ("string" == typeof e3 && (e3 = e3.split(".")); e3.length > 0; ) {
        if (!t3)
          return t3;
        const r3 = e3.splice(0, 1)[0];
        if (!(r3.length < 1))
          if (Array.isArray(t3))
            t3 = t3[parseInt(r3)];
          else {
            if ("object" != typeof t3 || !(r3 in t3)) {
              if (n3)
                throw new Error("invalid access, check " + r3 + " in " + t3);
              return;
            }
            t3 = t3[r3];
          }
      }
      return t3;
    }(s2, o2), o2 && !(a2 in o2) ? (console.error("invalid key", a2, o2, t2, e2), { key: void 0, tar: o2 }) : { key: a2, tar: o2 };
  }
  async function dU(e2, n2, r2) {
    var i2, s2, o2, a2;
    const { key: l2, tar: c2 } = pU(n2, e2), u2 = n2.animSet ? [fU(e2, n2.animSet, r2, null !== (i2 = n2.animSetParallel) && void 0 !== i2 && i2)] : [];
    if (l2 && c2) {
      const e3 = null !== (a2 = n2.updater) && void 0 !== a2 ? a2 : [], i3 = async () => Lp(c2, l2, { from: n2.from, to: n2.to, ease: "string" == typeof n2.ease ? Dp[n2.ease] : n2.ease, duration: n2.duration, ...n2.options, onUpdate: (t2) => {
        var i4, s3;
        null === (s3 = (i4 = n2.options).onUpdate) || void 0 === s3 || s3.call(i4, t2), e3.forEach((e4) => {
          var t3;
          return null === (t3 = r2[e4]) || void 0 === t3 ? void 0 : t3.call(r2);
        });
      } }, void 0, false);
      n2.delay ? u2.push((0, t.timeout)(n2.delay).then(i3)) : u2.push(i3());
    } else
      (n2.duration || n2.delay) && u2.push((0, t.timeout)((null !== (s2 = n2.delay) && void 0 !== s2 ? s2 : 0) + (null !== (o2 = n2.duration) && void 0 !== o2 ? o2 : 0)));
    return 1 === u2.length ? u2[0] : Promise.all(u2);
  }
  async function hU(e2, t2, n2) {
    return "function" == typeof t2.animate ? t2.animate() : dU(e2, t2, n2);
  }
  async function fU(e2, t2, n2, r2 = false) {
    if (r2)
      return Promise.all(t2.map(async (t3) => hU(e2, t3, n2)));
    for (const r3 of t2)
      await hU(e2, r3, n2);
  }
  const mU = new TextEncoder(), _U = { appstream2: "appstream", cloudhsmv2: "cloudhsm", email: "ses", marketplace: "aws-marketplace", mobile: "AWSMobileHubService", pinpoint: "mobiletargeting", queue: "sqs", "git-codecommit": "codecommit", "mturk-requester-sandbox": "mturk-requester", "personalize-runtime": "personalize" }, gU = /* @__PURE__ */ new Set(["authorization", "content-type", "content-length", "user-agent", "presigned-expires", "expect", "x-amzn-trace-id", "range", "connection"]);
  class vU {
    constructor({ accessKeyId: e2, secretAccessKey: t2, sessionToken: n2, service: r2, region: i2, cache: s2, retries: o2, initRetryMs: a2 }) {
      if (null == e2)
        throw new TypeError("accessKeyId is a required option");
      if (null == t2)
        throw new TypeError("secretAccessKey is a required option");
      this.accessKeyId = e2, this.secretAccessKey = t2, this.sessionToken = n2, this.service = r2, this.region = i2, this.cache = s2 || /* @__PURE__ */ new Map(), this.retries = null != o2 ? o2 : 10, this.initRetryMs = a2 || 50;
    }
    async sign(e2, t2) {
      if (e2 instanceof Request) {
        const { method: n3, url: r3, headers: i2, body: s2 } = e2;
        null == (t2 = Object.assign({ method: n3, url: r3, headers: i2 }, t2)).body && i2.has("Content-Type") && (t2.body = null != s2 && i2.has("X-Amz-Content-Sha256") ? s2 : await e2.clone().arrayBuffer()), e2 = r3;
      }
      const n2 = new yU(Object.assign({ url: e2 }, t2, this, t2 && t2.aws)), r2 = Object.assign({}, t2, await n2.sign());
      delete r2.aws;
      try {
        return new Request(r2.url.toString(), r2);
      } catch (e3) {
        if (e3 instanceof TypeError)
          return new Request(r2.url.toString(), Object.assign({ duplex: "half" }, r2));
        throw e3;
      }
    }
    async fetch(e2, t2) {
      for (let n2 = 0; n2 <= this.retries; n2++) {
        const r2 = fetch(await this.sign(e2, t2));
        if (n2 === this.retries)
          return r2;
        const i2 = await r2;
        if (i2.status < 500 && 429 !== i2.status)
          return i2;
        await new Promise((e3) => setTimeout(e3, Math.random() * this.initRetryMs * Math.pow(2, n2)));
      }
      throw new Error("An unknown error occurred, ensure retries is not negative");
    }
  }
  class yU {
    constructor({ method: e2, url: t2, headers: n2, body: r2, accessKeyId: i2, secretAccessKey: s2, sessionToken: o2, service: a2, region: l2, cache: c2, datetime: u2, signQuery: p2, appendSessionToken: d2, allHeaders: h2, singleEncode: f2 }) {
      if (null == t2)
        throw new TypeError("url is a required option");
      if (null == i2)
        throw new TypeError("accessKeyId is a required option");
      if (null == s2)
        throw new TypeError("secretAccessKey is a required option");
      let m2, _2;
      this.method = e2 || (r2 ? "POST" : "GET"), this.url = new URL(t2), this.headers = new Headers(n2 || {}), this.body = r2, this.accessKeyId = i2, this.secretAccessKey = s2, this.sessionToken = o2, a2 && l2 || ([m2, _2] = function(e3, t3) {
        const { hostname: n3, pathname: r3 } = e3;
        if (n3.endsWith(".r2.cloudflarestorage.com"))
          return ["s3", "auto"];
        if (n3.endsWith(".backblazeb2.com")) {
          const e4 = n3.match(/^(?:[^.]+\.)?s3\.([^.]+)\.backblazeb2\.com$/);
          return null != e4 ? ["s3", e4[1]] : ["", ""];
        }
        const i3 = n3.replace("dualstack.", "").match(/([^.]+)\.(?:([^.]*)\.)?amazonaws\.com(?:\.cn)?$/);
        let [s3, o3] = (i3 || ["", ""]).slice(1, 3);
        if ("us-gov" === o3)
          o3 = "us-gov-west-1";
        else if ("s3" === o3 || "s3-accelerate" === o3)
          o3 = "us-east-1", s3 = "s3";
        else if ("iot" === s3)
          s3 = n3.startsWith("iot.") ? "execute-api" : n3.startsWith("data.jobs.iot.") ? "iot-jobs-data" : "/mqtt" === r3 ? "iotdevicegateway" : "iotdata";
        else if ("autoscaling" === s3) {
          const e4 = (t3.get("X-Amz-Target") || "").split(".")[0];
          "AnyScaleFrontendService" === e4 ? s3 = "application-autoscaling" : "AnyScaleScalingPlannerFrontendService" === e4 && (s3 = "autoscaling-plans");
        } else
          null == o3 && s3.startsWith("s3-") ? (o3 = s3.slice(3).replace(/^fips-|^external-1/, ""), s3 = "s3") : s3.endsWith("-fips") ? s3 = s3.slice(0, -5) : o3 && /-\d$/.test(s3) && !/-\d$/.test(o3) && ([s3, o3] = [o3, s3]);
        return [_U[s3] || s3, o3];
      }(this.url, this.headers)), this.service = a2 || m2 || "", this.region = l2 || _2 || "us-east-1", this.cache = c2 || /* @__PURE__ */ new Map(), this.datetime = u2 || (/* @__PURE__ */ new Date()).toISOString().replace(/[:-]|\.\d{3}/g, ""), this.signQuery = p2, this.appendSessionToken = d2 || "iotdevicegateway" === this.service, this.headers.delete("Host"), "s3" !== this.service || this.signQuery || this.headers.has("X-Amz-Content-Sha256") || this.headers.set("X-Amz-Content-Sha256", "UNSIGNED-PAYLOAD");
      const g2 = this.signQuery ? this.url.searchParams : this.headers;
      if (g2.set("X-Amz-Date", this.datetime), this.sessionToken && !this.appendSessionToken && g2.set("X-Amz-Security-Token", this.sessionToken), this.signableHeaders = ["host", ...this.headers.keys()].filter((e3) => h2 || !gU.has(e3)).sort(), this.signedHeaders = this.signableHeaders.join(";"), this.canonicalHeaders = this.signableHeaders.map((e3) => e3 + ":" + ("host" === e3 ? this.url.host : (this.headers.get(e3) || "").replace(/\s+/g, " "))).join("\n"), this.credentialString = [this.datetime.slice(0, 8), this.region, this.service, "aws4_request"].join("/"), this.signQuery && ("s3" !== this.service || g2.has("X-Amz-Expires") || g2.set("X-Amz-Expires", "86400"), g2.set("X-Amz-Algorithm", "AWS4-HMAC-SHA256"), g2.set("X-Amz-Credential", this.accessKeyId + "/" + this.credentialString), g2.set("X-Amz-SignedHeaders", this.signedHeaders)), "s3" === this.service)
        try {
          this.encodedPath = decodeURIComponent(this.url.pathname.replace(/\+/g, " "));
        } catch (e3) {
          this.encodedPath = this.url.pathname;
        }
      else
        this.encodedPath = this.url.pathname.replace(/\/+/g, "/");
      f2 || (this.encodedPath = encodeURIComponent(this.encodedPath).replace(/%2F/g, "/")), this.encodedPath = xU(this.encodedPath);
      const v2 = /* @__PURE__ */ new Set();
      this.encodedSearch = [...this.url.searchParams].filter(([e3]) => {
        if (!e3)
          return false;
        if ("s3" === this.service) {
          if (v2.has(e3))
            return false;
          v2.add(e3);
        }
        return true;
      }).map((e3) => e3.map((e4) => xU(encodeURIComponent(e4)))).sort(([e3, t3], [n3, r3]) => e3 < n3 ? -1 : e3 > n3 ? 1 : t3 < r3 ? -1 : t3 > r3 ? 1 : 0).map((e3) => e3.join("=")).join("&");
    }
    async sign() {
      return this.signQuery ? (this.url.searchParams.set("X-Amz-Signature", await this.signature()), this.sessionToken && this.appendSessionToken && this.url.searchParams.set("X-Amz-Security-Token", this.sessionToken)) : this.headers.set("Authorization", await this.authHeader()), { method: this.method, url: this.url, headers: this.headers, body: this.body };
    }
    async authHeader() {
      return ["AWS4-HMAC-SHA256 Credential=" + this.accessKeyId + "/" + this.credentialString, "SignedHeaders=" + this.signedHeaders, "Signature=" + await this.signature()].join(", ");
    }
    async signature() {
      const e2 = this.datetime.slice(0, 8), t2 = [this.secretAccessKey, e2, this.region, this.service].join();
      let n2 = this.cache.get(t2);
      if (!n2) {
        const r2 = await bU("AWS4" + this.secretAccessKey, e2), i2 = await bU(r2, this.region), s2 = await bU(i2, this.service);
        n2 = await bU(s2, "aws4_request"), this.cache.set(t2, n2);
      }
      return AU(await bU(n2, await this.stringToSign()));
    }
    async stringToSign() {
      return ["AWS4-HMAC-SHA256", this.datetime, this.credentialString, AU(await wU(await this.canonicalString()))].join("\n");
    }
    async canonicalString() {
      return [this.method.toUpperCase(), this.encodedPath, this.encodedSearch, this.canonicalHeaders + "\n", this.signedHeaders, await this.hexBodyHash()].join("\n");
    }
    async hexBodyHash() {
      let e2 = this.headers.get("X-Amz-Content-Sha256") || ("s3" === this.service && this.signQuery ? "UNSIGNED-PAYLOAD" : null);
      if (null == e2) {
        if (this.body && "string" != typeof this.body && !("byteLength" in this.body))
          throw new Error("body must be a string, ArrayBuffer or ArrayBufferView, unless you include the X-Amz-Content-Sha256 header");
        e2 = AU(await wU(this.body || ""));
      }
      return e2;
    }
  }
  async function bU(e2, t2) {
    const n2 = await crypto.subtle.importKey("raw", "string" == typeof e2 ? mU.encode(e2) : e2, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]);
    return crypto.subtle.sign("HMAC", n2, mU.encode(t2));
  }
  async function wU(e2) {
    return crypto.subtle.digest("SHA-256", "string" == typeof e2 ? mU.encode(e2) : e2);
  }
  function AU(e2) {
    return Array.prototype.map.call(new Uint8Array(e2), (e3) => ("0" + e3.toString(16)).slice(-2)).join("");
  }
  function xU(e2) {
    return e2.replace(/[!'()*]/g, (e3) => "%" + e3.charCodeAt(0).toString(16).toUpperCase());
  }
  var EU, CU = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let SU = EU = class extends gt {
    constructor() {
      super(), this.enabled = true, this._connected = false, this.dependencies = [IP], this.accessKeyId = "", this.accessKeySecret = "", this.endpointURL = "", this.pathPrefix = "webgi", this.serializeSettings = false, this.toggleConnection = () => {
        this._connected ? this.disconnect() : this.connect();
      }, this.serializeWithViewer = false, this.fetchFunction = fetch;
    }
    connect() {
      this._connected && this.disconnect(), this._client = new vU({ accessKeyId: this.accessKeyId, secretAccessKey: this.accessKeySecret }), this._connected = true, this.refreshUi();
    }
    refreshUi() {
      var e2, t2;
      null === (t2 = null === (e2 = this.uiConfig) || void 0 === e2 ? void 0 : e2.uiRefresh) || void 0 === t2 || t2.call(e2, "postFrame", true);
    }
    disconnect() {
      this._client = void 0, this._connected = false, this.refreshUi();
    }
    get connected() {
      return this._connected;
    }
    get client() {
      return this._client;
    }
    toJSON(e2) {
      return this.serializeSettings ? super.toJSON(e2) : { type: this.constructor.PluginType };
    }
    async onAdded(e2) {
      await super.onAdded(e2);
      const n2 = e2.getPlugin(IP);
      n2.actions.exportFile = async (r2, i2, s2) => {
        if (!this._connected)
          return void await n2.defaultActions.exportFile(r2, i2);
        const o2 = (0, t.pathJoin)([this.endpointURL, this.pathPrefix, i2]), a2 = await this.fetch(o2, { method: "PUT", body: r2 }, s2);
        if (!a2.ok)
          return e2.console.error("Error uploading file", a2), void await n2.defaultActions.exportFile(r2, i2);
        this.dispatchEvent({ type: "fileUpload", name: i2, blob: r2, response: a2, path: o2 }), e2.console.log("File uploaded", a2);
      };
    }
    async fetch(e2, n2, r2) {
      if (!this._client)
        throw new Error("Not connected");
      for (let r3 = 0; r3 <= this._client.retries; r3++) {
        const i2 = await MU(this._client, e2, n2);
        let s2 = i2.url.toString();
        EU.USE_PROXY && s2 && !s2.includes(EU.PROXY_URL) && (s2 = EU.PROXY_URL.replace("{path}", s2));
        const o2 = (0, this.fetchFunction)(s2, i2);
        if (r3 === this._client.retries)
          return o2;
        const a2 = await o2;
        if (a2.status < 500 && 429 !== a2.status)
          return a2;
        await (0, t.timeout)(Math.random() * this._client.initRetryMs * Math.pow(2, r3));
      }
      throw new Error("An unknown error occurred, ensure retries is not negative");
    }
  };
  async function MU(e2, t2, n2) {
    if (t2 instanceof Request) {
      const { method: e3, url: r3, headers: i3, body: s2 } = t2;
      null == (n2 = Object.assign({ method: e3, url: r3, headers: i3 }, n2)).body && i3.has("Content-Type") && (n2.body = null != s2 && i3.has("X-Amz-Content-Sha256") ? s2 : await t2.clone().arrayBuffer()), t2 = r3, console.warn("WebGi AWSClientPlugin: There could be a bug in chrome with cloning Request objects, see https://bugs.chromium.org/p/chromium/issues/detail?id=1360943");
    }
    const r2 = new yU(Object.assign({ url: t2 }, n2, e2, n2 && n2.aws)), i2 = Object.assign({}, n2, await r2.sign());
    return delete i2.aws, i2;
  }
  SU.PluginType = "AWSClientPlugin1", SU.USE_PROXY = false, SU.PROXY_URL = "https://r2-s3-api.repalash.com/{path}", CU([ie(), ze("Access Key ID", (e2) => ({ disabled: () => !e2.enabled || e2._connected }))], SU.prototype, "accessKeyId", void 0), CU([ie(), ze("Access Key Secret", (e2) => ({ disabled: () => !e2.enabled || e2._connected }))], SU.prototype, "accessKeySecret", void 0), CU([ie(), ze("Endpoint URL", (e2) => ({ disabled: () => !e2.enabled || e2._connected }))], SU.prototype, "endpointURL", void 0), CU([ie(), ze("Path Prefix", (e2) => ({ disabled: () => !e2.enabled }))], SU.prototype, "pathPrefix", void 0), CU([ie(), Oe("Remember", (e2) => ({ disabled: () => !e2.enabled || e2._connected }))], SU.prototype, "serializeSettings", void 0), CU([je(void 0, (e2) => ({ label: () => e2._connected ? "Disconnect" : "Connect" }))], SU.prototype, "toggleConnection", void 0), SU = EU = CU([We("S3 Connection")], SU);
  const TU = (() => {
    let e2 = false, t2 = false;
    const n2 = "function" == typeof globalThis.ReadableStream, r2 = "function" == typeof globalThis.Request;
    return n2 && r2 && (t2 = new globalThis.Request("https://empty.invalid", { body: new globalThis.ReadableStream(), method: "POST", get duplex() {
      return e2 = true, "half";
    } }).headers.has("Content-Type")), e2 && !t2;
  })(), PU = { Background: new Pv({ basePath: "https://demo-assets.pixotronics.com/pixo/presets/background", assets: ["gradient-radial-dark-blue.svg", "gradient-radial-grey.svg", "gradient-radial-red.svg", "gradient-radial-aqua.svg", "gradient-radial-green.svg", "gradient-radial-white.svg", "gradient-radial-coral.svg", "gradient-radial-fuchsia.svg", "gradient-radial-blue.svg", "gradient-radial-black.svg", "gradient-radial-light-blue.svg", "gradient-radial-gray.svg", "gradient-radial-beige.svg", "gradient-radial-antrasit.svg", "gradient-linear-light-blue.svg", "gradient-linear-gray.svg", "gradient-linear-beige.svg", "gradient-linear-antrasit.svg", "bg-1.jpg", "bg-2.png"].map((e2) => ({ path: e2 })) }).assets, Environment: new Pv({ basePath: "https://demo-assets.pixotronics.com/pixo/presets/environment", assets: ["env-metal-1.hdr", "env-metal-2.hdr", "env-metal-3.hdr", "env-metal-4.hdr", "env-metal-5.hdr", "env-metal-6.hdr", "env-metal-7.hdr", "env-metal-8.hdr", "env-metal-9.hdr", "env-metal-10.hdr", "env-metal-11.hdr", "env-metal-12.hdr", "env-metal-13.hdr", "env-metal-14.exr", "env-metal-gem-1.hdr", "env-metal-gem-2.hdr", "env-gem-1.hdr", "env-gem-2.hdr", "env-gem-3.exr", "env-gem-4.exr", "alps_field_1k.hdr", "paul_lobe_haus_1k.hdr", "derelict_highway_midday_1k.hdr", "neon_photostudio_1k.hdr", "studio_small_08_1k.hdr", "evening_meadow_1k.hdr", "st_peters_square_night_1k.hdr", "studio_small_07_1k.hdr", "moonless_golf_1k.hdr", "satara_night_1k.hdr", "venice_sunset_1k.hdr", "umhlanga_sunrise_1k.hdr", "studio_country_hall_1k.hdr"].map((e2) => ({ path: e2 })) }).assets, GemEnvironment: new Pv({ basePath: "https://demo-assets.pixotronics.com/pixo/presets/environment", assets: ["env-gem-1.hdr", "env-gem-2.hdr", "env-gem-3.exr", "env-gem-4.exr", "env-metal-gem-1.hdr", "env-metal-gem-2.hdr"].map((e2) => ({ path: e2 })) }).assets, GemEnvironment2: new Pv({ basePath: "https://demo-assets.pixotronics.com/pixo/presets/environment", assets: ["env-gem-1.hdr", "env-gem-2.hdr", "env-gem-3.exr", "env-gem-4.exr", "env-metal-gem-1.hdr", "env-metal-gem-2.hdr"].map((e2) => ({ path: e2 })) }).assets, GemEnvironment3: new Pv({ basePath: "https://demo-assets.pixotronics.com/pixo/presets/environment", assets: ["env-gem-1.hdr", "env-gem-2.hdr", "env-gem-3.exr", "env-gem-4.exr", "env-metal-gem-1.hdr", "env-metal-gem-2.hdr"].map((e2) => ({ path: e2 })) }).assets, Ground: new Pv({ basePath: "https://demo-assets.pixotronics.com/pixo/presets/ground", assets: ["ground-1.json", "ground-2.json", "ground-3.json", "g-1.json", "g-2.json", "g-3.json", "g-4.json", "g-5.json"].map((e2) => ({ path: e2 })) }).assets, CameraViews: new Pv({ basePath: "https://demo-assets.pixotronics.com/pixo/presets/views", assets: ["views-1.json", "views-2.json"].map((e2) => ({ path: e2 })) }).assets, MaterialConfiguration: new Pv({ basePath: "https://demo-assets.pixotronics.com/pixo/presets/material-conf", assets: ["gold-ceramic.json", "gold.json", "metal-diamond.json"].map((e2) => ({ path: e2 })) }).assets, MaterialLibraries: new Pv({ basePath: "https://demo-assets.pixotronics.com/pixo/presets/material-lib", assets: ["metal.zip", "gem.zip"].map((e2) => ({ path: e2 })) }).assets };
  function IU(e2, t2) {
    return t2 ? e2 * (1e3 / t2) : 0;
  }
  function RU(e2) {
    var t2, n2 = e2.from, r2 = void 0 === n2 ? 0 : n2, i2 = e2.velocity, s2 = void 0 === i2 ? 0 : i2, o2 = e2.min, a2 = e2.max, l2 = e2.power, c2 = void 0 === l2 ? 0.8 : l2, u2 = e2.timeConstant, p2 = void 0 === u2 ? 750 : u2, d2 = e2.bounceStiffness, h2 = void 0 === d2 ? 500 : d2, f2 = e2.bounceDamping, m2 = void 0 === f2 ? 10 : f2, _2 = e2.restDelta, g2 = void 0 === _2 ? 1 : _2, v2 = e2.modifyTarget, y2 = e2.driver, b2 = e2.onUpdate, w2 = e2.onComplete, A2 = e2.onStop;
    function x2(e3) {
      return void 0 !== o2 && e3 < o2 || void 0 !== a2 && e3 > a2;
    }
    function E2(e3) {
      return void 0 === o2 ? a2 : void 0 === a2 || Math.abs(o2 - e3) < Math.abs(a2 - e3) ? o2 : a2;
    }
    function C2(e3) {
      null == t2 || t2.stop(), t2 = kp(iu(iu({}, e3), { driver: y2, onUpdate: function(t3) {
        var n3;
        null == b2 || b2(t3), null === (n3 = e3.onUpdate) || void 0 === n3 || n3.call(e3, t3);
      }, onComplete: w2, onStop: A2 }));
    }
    function S2(e3) {
      C2(iu({ type: "spring", stiffness: h2, damping: m2, restDelta: g2 }, e3));
    }
    if (x2(r2))
      S2({ from: r2, velocity: s2, to: E2(r2) });
    else {
      var M2 = c2 * s2 + r2;
      void 0 !== v2 && (M2 = v2(M2));
      var T2, P2, I2 = E2(M2), R2 = I2 === o2 ? -1 : 1;
      C2({ type: "decay", from: r2, velocity: s2, timeConstant: p2, power: c2, restDelta: g2, modifyTarget: v2, onUpdate: x2(M2) ? function(e3) {
        T2 = P2, P2 = e3, s2 = IU(e3 - T2, Tp().delta), (1 === R2 && e3 > I2 || -1 === R2 && e3 < I2) && S2({ from: e3, to: I2, velocity: s2 });
      } : void 0 });
    }
    return { stop: function() {
      return null == t2 ? void 0 : t2.stop();
    } };
  }
  var kU = function(e2) {
    return 180 * e2 / Math.PI;
  }, DU = function(e2, t2) {
    return void 0 === t2 && (t2 = $u), kU(Math.atan2(t2.y - e2.y, t2.x - e2.x));
  }, BU = function(e2, t2) {
    var n2 = true;
    return void 0 === t2 && (t2 = e2, n2 = false), function(r2) {
      return n2 ? r2 - e2 + t2 : (e2 = r2, n2 = true, t2);
    };
  }, OU = function(e2) {
    return e2;
  }, LU = function(e2) {
    return void 0 === e2 && (e2 = OU), function(t2, n2, r2) {
      var i2 = n2 - r2, s2 = -(0 - t2 + 1) * (0 - e2(Math.abs(i2)));
      return i2 <= 0 ? n2 + s2 : n2 - s2;
    };
  }, UU = LU(), FU = LU(Math.sqrt), NU = function(e2) {
    return e2 * Math.PI / 180;
  }, jU = function(e2) {
    return e2.hasOwnProperty("x") && e2.hasOwnProperty("y");
  }, zU = function(e2) {
    return jU(e2) && e2.hasOwnProperty("z");
  }, GU = function(e2, t2) {
    return Math.abs(e2 - t2);
  };
  function VU(e2, t2) {
    if (ep(e2) && ep(t2))
      return GU(e2, t2);
    if (jU(e2) && jU(t2)) {
      var n2 = GU(e2.x, t2.x), r2 = GU(e2.y, t2.y), i2 = zU(e2) && zU(t2) ? GU(e2.z, t2.z) : 0;
      return Math.sqrt(Math.pow(n2, 2) + Math.pow(r2, 2) + Math.pow(i2, 2));
    }
  }
  var HU = function(e2, t2, n2) {
    return t2 = NU(t2), { x: n2 * Math.cos(t2) + e2.x, y: n2 * Math.sin(t2) + e2.y };
  }, QU = function(e2, t2) {
    return void 0 === t2 && (t2 = 2), t2 = Math.pow(10, t2), Math.round(e2 * t2) / t2;
  }, WU = function(e2, t2, n2, r2) {
    return void 0 === r2 && (r2 = 0), QU(e2 + n2 * (t2 - e2) / Math.max(r2, n2));
  }, qU = function(e2) {
    void 0 === e2 && (e2 = 50);
    var t2 = 0, n2 = 0;
    return function(r2) {
      var i2 = Tp().timestamp, s2 = i2 !== n2 ? i2 - n2 : 0, o2 = s2 ? WU(t2, r2, s2, e2) : t2;
      return n2 = i2, t2 = o2, o2;
    };
  }, XU = function(e2) {
    if ("number" == typeof e2)
      return function(t3) {
        return Math.round(t3 / e2) * e2;
      };
    var t2 = 0, n2 = e2.length;
    return function(r2) {
      var i2 = Math.abs(e2[0] - r2);
      for (t2 = 1; t2 < n2; t2++) {
        var s2 = e2[t2], o2 = Math.abs(s2 - r2);
        if (0 === o2)
          return s2;
        if (o2 > i2)
          return e2[t2 - 1];
        if (t2 === n2 - 1)
          return s2;
        i2 = o2;
      }
    };
  };
  function YU(e2, t2) {
    return e2 / (1e3 / t2);
  }
  var KU = function(e2, t2, n2) {
    var r2 = t2 - e2;
    return ((n2 - e2) % r2 + r2) % r2 + e2;
  }, JU = function(e2, t2) {
    return 1 - 3 * t2 + 3 * e2;
  }, ZU = function(e2, t2) {
    return 3 * t2 - 6 * e2;
  }, $U = function(e2) {
    return 3 * e2;
  }, eF = function(e2, t2, n2) {
    return ((JU(t2, n2) * e2 + ZU(t2, n2)) * e2 + $U(t2)) * e2;
  }, tF = function(e2, t2, n2) {
    return 3 * JU(t2, n2) * e2 * e2 + 2 * ZU(t2, n2) * e2 + $U(t2);
  }, nF = 1e-7, rF = 10, iF = 8, sF = 1e-3, oF = 11, aF = 1 / (oF - 1);
  function lF(e2, t2, n2, r2) {
    if (e2 === t2 && n2 === r2)
      return Hc;
    for (var i2 = new Float32Array(oF), s2 = 0; s2 < oF; ++s2)
      i2[s2] = eF(s2 * aF, e2, n2);
    return function(s3) {
      return 0 === s3 || 1 === s3 ? s3 : eF(function(t3) {
        for (var r3 = 0, s4 = 1, o2 = oF - 1; s4 !== o2 && i2[s4] <= t3; ++s4)
          r3 += aF;
        --s4;
        var a2 = r3 + (t3 - i2[s4]) / (i2[s4 + 1] - i2[s4]) * aF, l2 = tF(a2, e2, n2);
        return l2 >= sF ? function(e3, t4, n3, r4) {
          for (var i3 = 0; i3 < iF; ++i3) {
            var s5 = tF(t4, n3, r4);
            if (0 === s5)
              return t4;
            t4 -= (eF(t4, n3, r4) - e3) / s5;
          }
          return t4;
        }(t3, a2, e2, n2) : 0 === l2 ? a2 : function(e3, t4, n3, r4, i3) {
          var s5, o3, a3 = 0;
          do {
            (s5 = eF(o3 = t4 + (n3 - t4) / 2, r4, i3) - e3) > 0 ? n3 = o3 : t4 = o3;
          } while (Math.abs(s5) > nF && ++a3 < rF);
          return o3;
        }(t3, r3, r3 + aF, e2, n2);
      }(s3), t2, r2);
    };
  }
  var cF = function(e2, t2) {
    return void 0 === t2 && (t2 = "end"), function(n2) {
      var r2 = (n2 = "end" === t2 ? Math.min(n2, 0.999) : Math.max(n2, 1e-3)) * e2, i2 = "end" === t2 ? Math.floor(r2) : Math.ceil(r2);
      return lu(0, 1, i2 / e2);
    };
  };
  const uF = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
  function pF() {
    const e2 = 4294967295 * Math.random() | 0, t2 = 4294967295 * Math.random() | 0, n2 = 4294967295 * Math.random() | 0, r2 = 4294967295 * Math.random() | 0;
    return (uF[255 & e2] + uF[e2 >> 8 & 255] + uF[e2 >> 16 & 255] + uF[e2 >> 24 & 255] + "-" + uF[255 & t2] + uF[t2 >> 8 & 255] + "-" + uF[t2 >> 16 & 15 | 64] + uF[t2 >> 24 & 255] + "-" + uF[63 & n2 | 128] + uF[n2 >> 8 & 255] + "-" + uF[n2 >> 16 & 255] + uF[n2 >> 24 & 255] + uF[255 & r2] + uF[r2 >> 8 & 255] + uF[r2 >> 16 & 255] + uF[r2 >> 24 & 255]).toLowerCase();
  }
  Math.PI, Math.PI;
  var dF, hF = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  class fF extends gt {
    constructor() {
      super(...arguments), this.enabled = true, this.animation = new mF(() => this._viewer), this.uiConfig = this.animation.uiConfig;
    }
    async onAdded(e2) {
      function t2(e3) {
        let t3 = "", n2 = 1;
        for (; n2 < e3.length && (t3 += e3[n2], e3[n2].endsWith("\\")); n2++)
          t3 = t3.slice(0, -1), t3 += ".";
        return [t3, n2];
      }
      await super.onAdded(e2), e2._animGetters = { objects: (n2) => {
        if (n2.length < 2 || !e2)
          return;
        const [r2, i2] = t2(n2);
        return { tar: e2.scene.getObjectByName(r2), i: i2 };
      }, materials: (n2) => {
        var r2, i2, s2;
        if (n2.length < 2 || !e2)
          return;
        const [o2, a2] = t2(n2);
        return { tar: null === (s2 = null === (i2 = null === (r2 = e2.assetManager) || void 0 === r2 ? void 0 : r2.materials) || void 0 === i2 ? void 0 : i2.findMaterialsByName(o2)) || void 0 === s2 ? void 0 : s2[0], i: a2 };
      } };
    }
  }
  fF.PluginType = "AnimationObjectPlugin", hF([ie(), Be()], fF.prototype, "animation", void 0);
  let mF = dF = class {
    constructor(e2) {
      this.target = e2, this.uuid = pF(), this.name = "", this.access = "", this.options = {}, this.duration = 1e3, this.delay = 0, this.repeat = 1, this.repeatType = "mirror", this.ease = "easeInOutSine", this.updater = [], this.updateScene = false, this.updateCamera = false, this.updateViewer = false, this.animSetParallel = false, this.animSet = [], this.uiConfig = Qe("Animation Object", this, void 0, "folder", true);
    }
    _onAccessChanged() {
      const e2 = (0, t.getOrCall)(this.target), { key: n2, tar: r2 } = pU(this, e2);
      if (this.from = void 0, this.to = void 0, !n2 || !r2)
        return void this.refreshUi();
      const i2 = r2[n2];
      if (null == i2)
        return void this.refreshUi();
      const s2 = () => {
        if (!i2)
          return i2;
        if (i2.isColor)
          return "#" + i2.getHexString();
        const e3 = "function" == typeof i2.clone ? i2.clone() : "object" == typeof i2 ? { ...i2 } : i2;
        return console.log(e3), e3;
      };
      this.from = s2(), this.to = s2(), this.refreshUi();
    }
    refreshUi() {
      var e2, t2;
      null === (t2 = null === (e2 = this.uiConfig) || void 0 === e2 ? void 0 : e2.uiRefresh) || void 0 === t2 || t2.call(e2, "postFrame", true, 1);
    }
    add(e2) {
      this.animSet.push(e2), e2.parent = this, this.refreshUi();
    }
    remove(e2) {
      const t2 = this.animSet.indexOf(e2);
      t2 >= 0 && (this.animSet.splice(t2, 1), e2.parent = void 0, this.refreshUi());
    }
    async animate(e2 = false) {
      "boolean" != typeof e2 && (e2 = false);
      const n2 = (0, t.getOrCall)(this.target);
      if (!n2)
        return void console.warn("AnimationObject: No viewer");
      e2 && (this.options.to = this.from, this.options.from = this.to), this.options.repeatType = this.repeatType, this.options.repeat = this.repeat, this.updater = [], this.updateScene && this.updater.push("scene"), this.updateCamera && this.updater.push("camera"), this.updateViewer && this.updater.push("viewer"), this.animSet.forEach((e3) => e3.target = this.target);
      const r2 = dU(n2, this, { viewer: () => n2.setDirty(), renderer: () => n2.renderer.reset(), scene: () => {
        n2.scene.setDirty();
      }, camera: () => n2.scene.activeCamera.setDirty() });
      await r2, delete this.options.to, delete this.options.from;
    }
    async animateReverse() {
      await this.animate(true);
    }
    async removeFromParent2() {
      const e2 = (0, t.getOrCall)(this.target);
      this.parent && e2 && await e2.confirm(`Delete: Are you sure you want to delete the animation ${this.name}?`) && this.removeFromParent();
    }
    removeFromParent() {
      this.parent && this.parent.remove(this);
    }
    addAnimation() {
      this.add(new dF(this.target));
    }
  };
  hF([ie(), ze()], mF.prototype, "name", void 0), hF([ie(), ze(), (0, t.onChange)(dF.prototype._onAccessChanged)], mF.prototype, "access", void 0), hF([Be(), ie()], mF.prototype, "from", void 0), hF([Be(), ie()], mF.prototype, "to", void 0), hF([ie()], mF.prototype, "options", void 0), hF([ie(), Ue(void 0, [0, 1e4], 1, (e2) => ({ hidden: () => void 0 === e2.from }))], mF.prototype, "duration", void 0), hF([ie(), Ue(void 0, [0, 1e4], 1, (e2) => ({ hidden: () => void 0 === e2.from }))], mF.prototype, "delay", void 0), hF([ie(), Ue(void 0, [0, 10], 1, (e2) => ({ hidden: () => void 0 === e2.from }))], mF.prototype, "repeat", void 0), hF([ie(), Ne("repeatType", ["loop", "reverse", "mirror"].map((e2) => ({ label: e2 })), (e2) => ({ hidden: () => void 0 === e2.from }))], mF.prototype, "repeatType", void 0), hF([ie(), Ne("ease", Object.keys(Dp).map((e2) => ({ label: e2 })), (e2) => ({ hidden: () => void 0 === e2.from }))], mF.prototype, "ease", void 0), hF([ie(), Oe(void 0, (e2) => ({ hidden: () => void 0 === e2.from }))], mF.prototype, "updateScene", void 0), hF([ie(), Oe(void 0, (e2) => ({ hidden: () => void 0 === e2.from }))], mF.prototype, "updateCamera", void 0), hF([ie(), Oe(void 0, (e2) => ({ hidden: () => void 0 === e2.from }))], mF.prototype, "updateViewer", void 0), hF([je("Animate")], mF.prototype, "animate", null), hF([je("Animate Reverse")], mF.prototype, "animateReverse", null), hF([je("Delete")], mF.prototype, "removeFromParent2", null), hF([ie(), Oe()], mF.prototype, "animSetParallel", void 0), hF([ie(), Be()], mF.prototype, "animSet", void 0), hF([je("Add Animation")], mF.prototype, "addAnimation", null), mF = dF = hF([pe("AnimationObject")], mF);
  var _F, gF = function(e2, t2, n2, r2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, n2, r2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
  };
  let vF = _F = class extends gt {
    constructor(e2 = true) {
      super(), this.enabled = true, this.dependencies = [], this.options = { id: pF(), type: "linear", gradientUnits: "objectBoundingBox", linearOptions: { angle: 45, x1: 0, y1: 0, x2: 1, y2: 1 }, radialOptions: { cx: 0.5, cy: 0.5, r: 0.5, fx: 0.5, fy: 0.5, spreadMethod: "pad" } }, this.type = "linear", this.gradientUnits = "objectBoundingBox", this.position1 = new n.FM8(0, 0), this.position2 = new n.FM8(1, 1), this.angle = 0, this.radius = 0.5, this.center = new n.FM8(0.5, 0.5), this.focus = new n.FM8(0.5, 0.5), this.spreadMethod = "pad", this._svgGradient = new yF(), this._needsUpdate = false, this.colors = [new n.Ilk(1, 1, 1), new n.Ilk(1, 0, 0)], this.color1 = this.colors[0], this.color2 = this.colors[1], this.applyToBackground = false, this.autoRefresh = true, this.enabled = e2;
    }
    _refreshOptions() {
      var e2, t2, n2, r2, i2, s2, o2, a2;
      this.options.type = this.type, this.options.gradientUnits = this.gradientUnits, this.options.linearOptions = { angle: this.angle, x1: null === (e2 = this.position1) || void 0 === e2 ? void 0 : e2.x, y1: null === (t2 = this.position1) || void 0 === t2 ? void 0 : t2.y, x2: null === (n2 = this.position2) || void 0 === n2 ? void 0 : n2.x, y2: null === (r2 = this.position2) || void 0 === r2 ? void 0 : r2.y }, this.options.radialOptions = { cx: null === (i2 = this.center) || void 0 === i2 ? void 0 : i2.x, cy: null === (s2 = this.center) || void 0 === s2 ? void 0 : s2.y, r: this.radius, fx: null === (o2 = this.focus) || void 0 === o2 ? void 0 : o2.x, fy: null === (a2 = this.focus) || void 0 === a2 ? void 0 : a2.y, spreadMethod: this.spreadMethod }, this.setDirty();
    }
    setDirty() {
      this._needsUpdate = true;
    }
    addColor() {
      this.colors.push(new n.Ilk()), this.setDirty();
    }
    refreshSvg() {
      if ((!this.applyToBackground || this._viewer) && (this._refreshOptions(), this._needsUpdate = false, this._svgElement = this._svgGradient.get(this.colors, this.options), this.applyToBackground)) {
        const e2 = `
            <svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">
            <defs>
            ${this._svgElement.outerHTML}
            </defs>
            <rect width="100%" height="100%" fill="url(#${this.options.id})"/>
            </svg>
            `, r2 = (0, t.svgUrl)(e2), i2 = new Image();
        i2.src = r2;
        const s2 = new n.xEZ(i2);
        i2.onload = () => {
          this._svgTexture === s2 && (this._svgTexture.needsUpdate = true, this._viewer.scene.background = this._svgTexture, this._viewer.setDirty());
        }, this._svgTexture && this._svgTexture.dispose(), this._svgTexture = s2;
      }
    }
    async onAdded(e2) {
      await super.onAdded(e2), e2.addEventListener("postFrame", () => {
        this.enabled && this._needsUpdate && this.autoRefresh && this.refreshSvg();
      });
    }
  };
  vF.PluginType = "GradientSvgPlugin", gF([Oe()], vF.prototype, "enabled", void 0), gF([ie(), Ne("type", ["linear", "radial"].map((e2) => ({ label: e2 }))), (0, t.onChange)(_F.prototype._refreshOptions)], vF.prototype, "type", void 0), gF([ie(), (0, t.onChange)(_F.prototype._refreshOptions)], vF.prototype, "gradientUnits", void 0), gF([ie(), Fe("position1", [0, 1], 0.01, (e2) => ({ hidden: () => "linear" !== e2.type, onChange: () => e2._refreshOptions() })), (0, t.onChange)(_F.prototype._refreshOptions)], vF.prototype, "position1", void 0), gF([ie(), Fe("position2", [0, 1], 0.01, (e2) => ({ hidden: () => "linear" !== e2.type, onChange: () => e2._refreshOptions() })), (0, t.onChange)(_F.prototype._refreshOptions)], vF.prototype, "position2", void 0), gF([ie(), Ue("angle", [0, 360], 1, (e2) => ({ hidden: () => "linear" !== e2.type })), (0, t.onChange)(_F.prototype._refreshOptions)], vF.prototype, "angle", void 0), gF([ie(), Ue("radius", [0, 1], 0.01, (e2) => ({ hidden: () => "radial" !== e2.type })), (0, t.onChange)(_F.prototype._refreshOptions)], vF.prototype, "radius", void 0), gF([ie(), Fe("center", [0, 1], 0.01, (e2) => ({ hidden: () => "radial" !== e2.type, onChange: () => e2._refreshOptions() })), (0, t.onChange)(_F.prototype._refreshOptions)], vF.prototype, "center", void 0), gF([ie(), Fe("focus", [0, 1], 0.01, (e2) => ({ hidden: () => "radial" !== e2.type, onChange: () => e2._refreshOptions() })), (0, t.onChange)(_F.prototype._refreshOptions)], vF.prototype, "focus", void 0), gF([ie(), (0, t.onChange)(_F.prototype._refreshOptions)], vF.prototype, "spreadMethod", void 0), gF([ie()], vF.prototype, "colors", void 0), gF([Ge(void 0, (e2) => ({ onChange: () => e2.setDirty() })), (0, t.onChange)(_F.prototype.setDirty)], vF.prototype, "color1", void 0), gF([Ge(void 0, (e2) => ({ onChange: () => e2.setDirty() })), (0, t.onChange)(_F.prototype.setDirty)], vF.prototype, "color2", void 0), gF([ie(), Oe(), (0, t.onChange)(_F.prototype.setDirty)], vF.prototype, "applyToBackground", void 0), gF([je()], vF.prototype, "refreshSvg", null), gF([ie()], vF.prototype, "autoRefresh", void 0), vF = _F = gF([We("Gradient SVG")], vF);
  class yF {
    constructor() {
    }
    get(e2, t2) {
      return this.colors = e2, this.options = t2, this.createGradient();
    }
    createSvgElement(e2) {
      return document.createElementNS("http://www.w3.org/2000/svg", e2);
    }
    createColorStop(e2, t2, n2) {
      const r2 = this.createSvgElement("stop");
      return r2.setAttribute("offset", t2 / n2 * 100 + "%"), r2.setAttribute("stop-color", e2), r2;
    }
    colorsToStops() {
      const e2 = this.colors;
      return e2.map((t2, n2) => {
        const r2 = t2.getStyle();
        return this.createColorStop(r2, n2, e2.length);
      });
    }
    createGradientElement() {
      const e2 = this.options, t2 = this.createSvgElement(`${e2.type}Gradient`), n2 = /((id)|([c|f|x|y|r][x|y|1|2]?)|(gradientUnits))/, r2 = e2[`${e2.type}Options`], i2 = { id: e2.id, type: e2.type, gradientUnits: e2.gradientUnits, ...r2 };
      return Object.entries(i2).filter((e3) => n2.test(e3[0])).forEach((e3) => {
        "type" !== e3[0] && t2.setAttribute(e3[0], e3[1]);
      }), i2.angle && t2.setAttribute("gradientTransform", `rotate(${i2.angle})`), t2;
    }
    createGradient() {
      const e2 = this.createGradientElement();
      return this.colorsToStops().forEach((t2) => e2.appendChild(t2)), e2;
    }
  }
  class bF extends zs {
    get editorInitialized() {
      return this._editorInitialized;
    }
    constructor(e2) {
      super(e2), this._editorInitialized = false, this.defaultModes = [{ title: "Viewer", plugins: [sL, oL, Ho, Fs] }, { title: "Picking", plugins: [eL, za, Bc, Dg, uI, YL] }, { title: "Scene", plugins: [KO, Gg, JO, tL, nL, bl, Ul, SC, SI, vF] }, { title: "Anti-aliasing", plugins: [To, yd, nd] }, { title: "Post Processing", plugins: [eo, $E, ad, io, Yo, Kp, El, fo, yo, Ro, il, jl] }, { title: "Export", plugins: [ub, Fc, AC, SU, TI] }, { title: "Animations", plugins: [Ya, zp, fF, Zp, LP, IO] }, { title: "Modifiers", plugins: [RC, FC, XC, BC, aS, VT, dd, MP] }, { title: "Configurators", plugins: [Rg, Pg, Pd, hI] }, { title: "Plugins", plugins: [rv, Sl, wd, Ha, Po, Wd, Do, Rl, kd, al, fd, Sc, HE, Jg] }, { title: "Extras", plugins: [UL, mC, _I, II, RI] }], OL();
    }
    async setupUi(e2, t2) {
      await LL(this, e2, null != t2 ? t2 : this.defaultModes), this._editorInitialized = true;
    }
  }
  async function wF(e2, { debug: n2 = false, ground: r2 = true, bloom: i2 = true, depthTonemap: s2 = true, importPopup: o2 = true, caching: a2 = true, presetLibrary: l2 = true, switchNode: c2 = true, materialConfigurator: u2 = true }) {
    e2.enabled = false, n2 && await e2.addPlugin(bh), e2.getPlugin(Ls) || await e2.addPlugin(Ls, void 0, void 0, { storage: a2 && window.caches ? await window.caches.open("webgi-cache-storage") : void 0 }), await e2.addPlugin(ub), await e2.addPlugin(uE), await e2.addPlugin(IP), o2 && await e2.addPlugin(Sc), await e2.addPlugin(TL), await e2.addPlugin(_I, false), await e2.getOrAddPlugin(ty), await e2.addPlugin(jC), await e2.getOrAddPlugin(Fs), await e2.addPlugin(IO), await e2.addPlugin(fI), await e2.addPlugin(za, oa, false, true), await sv(e2, { ground: r2, bloom: i2, depthTonemap: s2 }), l2 && await e2.getOrAddPlugin(Ho), await e2.getOrAddPlugin(Bc), await e2.addPlugin($E), await e2.addPlugin(BC, false), await e2.addPlugin($T), await e2.addPlugin(oP), await e2.addPlugin(mP), await e2.addPlugin(AP), await e2.addPlugin(HE, false), await e2.addPlugin(new RC(false)), await e2.addPlugin(FC), await e2.addPlugin(XC), u2 && ((await e2.addPlugin(Pg)).enableEditContextMenus = true), c2 && await e2.addPlugin(Rg), await e2.addPlugin(hI), await e2.addPlugin(Dg), await e2.addPlugin(AC), await e2.addPlugin(Fc), await e2.addPlugin(eL), await e2.addPlugin(JO), await e2.addPlugin(tL), await e2.addPlugin(nL), await e2.addPlugin(sL), await e2.addPlugin(oL), await e2.addPlugin(KO), await e2.addPlugin(YL, false), await e2.addPlugin(SI), await e2.addPlugin(uI), await e2.addPlugin(LP, e2.container, false), await e2.addPlugin(SU), await e2.addPlugin(II), await e2.addPlugin(TI), await e2.addPlugin(vF), await e2.addPlugin(fF), await e2.addPlugin(MP);
    const p2 = await e2.addPlugin(new YO(!(0, t.mobileAndTabletCheck)()));
    return e2.renderer.refreshPipeline(), e2.scene.addEventListener("textureAdded", (t2) => {
      t2.texture && e2.setEnvironmentMap(t2.texture);
    }), p2.setupPluginUi(wd), p2.setupPluginUi(sL), p2.setupPluginUi(oL), p2.setupPluginUi(Sc), p2.setupPluginUi(Fs), p2.setupPluginUi(KO), p2.setupPluginUi(ub), p2.setupPluginUi(Ya), p2.setupPluginUi(bl), c2 && p2.setupPluginUi(Rg), u2 && p2.setupPluginUi(Pg), p2.setupPluginUi(IO), p2.setupPluginUi(eL), p2.setupPluginUi(Dg), p2.setupPluginUi(Bc), p2.setupPluginUi(za), r2 && e2.getPlugin(Gg) && p2.setupPluginUi(Gg), r2 && e2.getPlugin(SC) && p2.setupPluginUi(SC), p2.setupPluginUi(El), p2.setupPluginUi(zp), p2.setupPluginUi(AC), p2.setupPluginUi(eo), p2.setupPluginUi($E), p2.setupPluginUi(io), p2.setupPluginUi(Yo), p2.setupPluginUi(ad), p2.setupPluginUi(Kp), p2.setupPluginUi(Ro), p2.setupPluginUi(fo), p2.setupPluginUi(al), p2.setupPluginUi(kd), p2.setupPluginUi(JO), p2.setupPluginUi(RC), p2.setupPluginUi(FC), p2.setupPluginUi(To), p2.setupPluginUi(vF), p2.setupPluginUi(fF), p2.setupPluginUi(tL), p2.setupPluginUi(nL), p2.setupPluginUi(Do), p2.setupPluginUi(Rl), p2.setupPluginUi(fd), i2 && p2.setupPluginUi(yo), p2.setupPluginUi(Fc), p2.setupPluginUi(Sl), p2.setupPluginUi(yd), p2.setupPluginUi(Ul), p2.setupPluginUi(il), p2.setupPluginUi(jl), p2.setupPluginUi(XC), p2.setupPluginUi(Po), p2.setupPluginUi(nd), l2 && p2.setupPluginUi(Ho), p2.setupPluginUi(Pd), p2.setupPluginUi(Ha), p2.setupPluginUi(BC), p2.setupPluginUi(Zp), p2.setupPluginUi(HE), p2.setupPluginUi(SU), p2.setupPluginUi(LP), p2.setupPluginUi(uI), p2.setupPluginUi(hI), p2.setupPluginUi(dd), p2.setupPluginUi(YL), p2.setupPluginUi(Jg), p2.setupPluginUi(_I), p2.setupPluginUi(SI), p2.setupPluginUi(rv), p2.setupPluginUi(II), p2.setupPluginUi(TI), p2.setupPluginUi(MP), e2.enabled = true, e2;
  }
  async function AF(e2, { debug: t2 = false, ground: n2 = true, bloom: r2 = true, depthTonemap: i2 = true, importPopup: s2 = true, caching: o2 = true }) {
    const a2 = new zs(e2);
    return await wF(a2, { debug: t2, ground: n2, bloom: r2, depthTonemap: i2, importPopup: s2, caching: o2 }), a2;
  }
  async function xF(e2, { debug: t2 = false, ground: n2 = true, bloom: r2 = true, depthTonemap: i2 = true, importPopup: s2 = false, enableDrop: o2 = false, caching: a2 = true } = {}) {
    const l2 = new zs(e2);
    return t2 && await l2.addPlugin(bh), l2.getPlugin(Ls) || l2.addPluginSync(Ls, void 0, void 0, { storage: a2 && window.caches ? await caches.open("webgi-cache-storage") : void 0 }), await l2.addPlugin(Tv, true), await sv(l2, { ground: n2, bloom: r2, depthTonemap: i2, enableDrop: o2, importPopup: s2 }), await l2.getOrAddPlugin(Bc), l2;
  }
}();
var __webpackgi_exports__AAssetManagerProcessStatePlugin = __webpackgi_exports__2.MWW;
var __webpackgi_exports__ACESFilmicToneMapping = __webpackgi_exports__2.LY2;
var __webpackgi_exports__ACameraControlsPlugin = __webpackgi_exports__2.GYo;
var __webpackgi_exports__ACanvasRecorder = __webpackgi_exports__2.GPz;
var __webpackgi_exports__AMaterialManager = __webpackgi_exports__2.HRj;
var __webpackgi_exports__ARPlacementBox = __webpackgi_exports__2.li4;
var __webpackgi_exports__ARPlugin = __webpackgi_exports__2.FO5;
var __webpackgi_exports__ARTouchInputHelper = __webpackgi_exports__2.Nlh;
var __webpackgi_exports__AShaderMaterial2 = __webpackgi_exports__2.Mp4;
var __webpackgi_exports__AViewerPlugin = __webpackgi_exports__2.QvI;
var __webpackgi_exports__AWSClientPlugin = __webpackgi_exports__2.PrA;
var __webpackgi_exports__AddBlendPass = __webpackgi_exports__2.JHp;
var __webpackgi_exports__AddEquation = __webpackgi_exports__2.bGH;
var __webpackgi_exports__AddOperation = __webpackgi_exports__2.NDo;
var __webpackgi_exports__AdditiveAnimationBlendMode = __webpackgi_exports__2.gSk;
var __webpackgi_exports__AdditiveBlending = __webpackgi_exports__2.WMw;
var __webpackgi_exports__AlphaFormat = __webpackgi_exports__2.OTo;
var __webpackgi_exports__AlwaysCompare = __webpackgi_exports__2.T6w;
var __webpackgi_exports__AlwaysDepth = __webpackgi_exports__2.Se2;
var __webpackgi_exports__AlwaysStencilFunc = __webpackgi_exports__2.cum;
var __webpackgi_exports__AmbientLight = __webpackgi_exports__2.Mig;
var __webpackgi_exports__AmbientLight2 = __webpackgi_exports__2.B$7;
var __webpackgi_exports__AmbientLightProbe = __webpackgi_exports__2.i_9;
var __webpackgi_exports__AnimationAction = __webpackgi_exports__2.bBp;
var __webpackgi_exports__AnimationClip = __webpackgi_exports__2.m7l;
var __webpackgi_exports__AnimationLoader = __webpackgi_exports__2.sYA;
var __webpackgi_exports__AnimationMixer = __webpackgi_exports__2.Xcj;
var __webpackgi_exports__AnimationObjectGroup = __webpackgi_exports__2.mzJ;
var __webpackgi_exports__AnimationUtils = __webpackgi_exports__2.ZZA;
var __webpackgi_exports__AnisotropyPlugin = __webpackgi_exports__2.$Ph;
var __webpackgi_exports__ArcCurve = __webpackgi_exports__2.T__;
var __webpackgi_exports__ArrayCamera = __webpackgi_exports__2.HkE;
var __webpackgi_exports__ArrowHelper = __webpackgi_exports__2.tGC;
var __webpackgi_exports__AssetExporter = __webpackgi_exports__2.g1S;
var __webpackgi_exports__AssetExporterPlugin = __webpackgi_exports__2.I$C;
var __webpackgi_exports__AssetImporter = __webpackgi_exports__2.QIH;
var __webpackgi_exports__AssetManagerBasicPopupPlugin = __webpackgi_exports__2._JE;
var __webpackgi_exports__AssetManagerLoadingBarPlugin = __webpackgi_exports__2.SwW;
var __webpackgi_exports__AssetManagerPlugin = __webpackgi_exports__2.ksm;
var __webpackgi_exports__AsyncCompress = __webpackgi_exports__2.jl_;
var __webpackgi_exports__AsyncDecompress = __webpackgi_exports__2.b7R;
var __webpackgi_exports__AsyncDeflate = __webpackgi_exports__2.BDV;
var __webpackgi_exports__AsyncGunzip = __webpackgi_exports__2.Ea_;
var __webpackgi_exports__AsyncGzip = __webpackgi_exports__2.qff;
var __webpackgi_exports__AsyncInflate = __webpackgi_exports__2.tmC;
var __webpackgi_exports__AsyncUnzipInflate = __webpackgi_exports__2.BON;
var __webpackgi_exports__AsyncUnzlib = __webpackgi_exports__2.P40;
var __webpackgi_exports__AsyncZipDeflate = __webpackgi_exports__2.wLL;
var __webpackgi_exports__AsyncZlib = __webpackgi_exports__2.iHO;
var __webpackgi_exports__Audio = __webpackgi_exports__2.BbS;
var __webpackgi_exports__AudioAnalyser = __webpackgi_exports__2.kqm;
var __webpackgi_exports__AudioContext = __webpackgi_exports__2.Hmr;
var __webpackgi_exports__AudioListener = __webpackgi_exports__2.SJI;
var __webpackgi_exports__AudioLoader = __webpackgi_exports__2.mTL;
var __webpackgi_exports__AxesHelper = __webpackgi_exports__2.y8_;
var __webpackgi_exports__BackSide = __webpackgi_exports__2._Li;
var __webpackgi_exports__BackgroundPresetGroup = __webpackgi_exports__2.w7U;
var __webpackgi_exports__BaseGroundPlugin = __webpackgi_exports__2.g56;
var __webpackgi_exports__BaseRenderer = __webpackgi_exports__2.bj3;
var __webpackgi_exports__BasicDepthPacking = __webpackgi_exports__2.z81;
var __webpackgi_exports__BasicShadowMap = __webpackgi_exports__2._MY;
var __webpackgi_exports__BeringRingAnimation = __webpackgi_exports__2.L7J;
var __webpackgi_exports__BlobLoader = __webpackgi_exports__2.yEv;
var __webpackgi_exports__BloomPlugin = __webpackgi_exports__2.dFZ;
var __webpackgi_exports__Bone = __webpackgi_exports__2.N$j;
var __webpackgi_exports__BooleanKeyframeTrack = __webpackgi_exports__2._YM;
var __webpackgi_exports__Box2 = __webpackgi_exports__2.TUj;
var __webpackgi_exports__Box3 = __webpackgi_exports__2.ZzF;
var __webpackgi_exports__Box3B = __webpackgi_exports__2.qzb;
var __webpackgi_exports__Box3Helper = __webpackgi_exports__2.GQ;
var __webpackgi_exports__BoxBufferGeometry = __webpackgi_exports__2.nvb;
var __webpackgi_exports__BoxGeometry = __webpackgi_exports__2.DvJ;
var __webpackgi_exports__BoxHelper = __webpackgi_exports__2.fQA;
var __webpackgi_exports__BoxSelectionWidget = __webpackgi_exports__2.cPz;
var __webpackgi_exports__BufferAttribute = __webpackgi_exports__2.TlE;
var __webpackgi_exports__BufferGeometry = __webpackgi_exports__2.u9r;
var __webpackgi_exports__BufferGeometryLoader = __webpackgi_exports__2.s4_;
var __webpackgi_exports__ByteType = __webpackgi_exports__2.T95;
var __webpackgi_exports__CSGPluginBSP = __webpackgi_exports__2.F5w;
var __webpackgi_exports__CSGPluginBVH = __webpackgi_exports__2.NlP;
var __webpackgi_exports__CSGPluginBase = __webpackgi_exports__2.$8Z;
var __webpackgi_exports__CSS3DRendererPlugin = __webpackgi_exports__2.YYN;
var __webpackgi_exports__Cache = __webpackgi_exports__2.CtF;
var __webpackgi_exports__Camera = __webpackgi_exports__2.V1s;
var __webpackgi_exports__CameraController = __webpackgi_exports__2.jOv;
var __webpackgi_exports__CameraHelper = __webpackgi_exports__2.Rki;
var __webpackgi_exports__CameraUiPlugin = __webpackgi_exports__2.pzV;
var __webpackgi_exports__CameraView = __webpackgi_exports__2.itZ;
var __webpackgi_exports__CameraViewControlPlugin = __webpackgi_exports__2.MMq;
var __webpackgi_exports__CameraViewPlugin = __webpackgi_exports__2.qKx;
var __webpackgi_exports__CannonPhysicsPlugin = __webpackgi_exports__2.Hmi;
var __webpackgi_exports__CanvasMediaRecorder = __webpackgi_exports__2.X4S;
var __webpackgi_exports__CanvasRecorder = __webpackgi_exports__2.vlJ;
var __webpackgi_exports__CanvasRecorderPlugin = __webpackgi_exports__2.nPO;
var __webpackgi_exports__CanvasSnipper = __webpackgi_exports__2.zcQ;
var __webpackgi_exports__CanvasSnipperPlugin = __webpackgi_exports__2.GH1;
var __webpackgi_exports__CanvasTexture = __webpackgi_exports__2.ROQ;
var __webpackgi_exports__CapsuleBufferGeometry = __webpackgi_exports__2.YN5;
var __webpackgi_exports__CapsuleGeometry = __webpackgi_exports__2.BVQ;
var __webpackgi_exports__CatmullRomCurve3 = __webpackgi_exports__2.YT8;
var __webpackgi_exports__ChromaticAberrationPlugin = __webpackgi_exports__2._DE;
var __webpackgi_exports__CineonToneMapping = __webpackgi_exports__2.YGz;
var __webpackgi_exports__CircleBufferGeometry = __webpackgi_exports__2.trn;
var __webpackgi_exports__CircleGeometry = __webpackgi_exports__2.zf8;
var __webpackgi_exports__ClampToEdgeWrapping = __webpackgi_exports__2.uWy;
var __webpackgi_exports__ClearcoatTintPlugin = __webpackgi_exports__2.wYQ;
var __webpackgi_exports__Clock = __webpackgi_exports__2.SUY;
var __webpackgi_exports__Color = __webpackgi_exports__2.Ilk;
var __webpackgi_exports__ColorKeyframeTrack = __webpackgi_exports__2.R2R;
var __webpackgi_exports__ColorManagement = __webpackgi_exports__2.epp;
var __webpackgi_exports__CombinedPostPlugin = __webpackgi_exports__2.xmJ;
var __webpackgi_exports__Compress = __webpackgi_exports__2.GD$;
var __webpackgi_exports__CompressedArrayTexture = __webpackgi_exports__2.Z_g;
var __webpackgi_exports__CompressedTexture = __webpackgi_exports__2.EB7;
var __webpackgi_exports__CompressedTextureLoader = __webpackgi_exports__2.DqL;
var __webpackgi_exports__ConeBufferGeometry = __webpackgi_exports__2._3;
var __webpackgi_exports__ConeGeometry = __webpackgi_exports__2.b_z;
var __webpackgi_exports__ContactShadowGroundPlugin = __webpackgi_exports__2.OCn;
var __webpackgi_exports__CoreEditorApp = __webpackgi_exports__2.N_j;
var __webpackgi_exports__CoreViewerApp = __webpackgi_exports__2.hNv;
var __webpackgi_exports__CubeCamera = __webpackgi_exports__2._am;
var __webpackgi_exports__CubeNormalsCaptureHelper = __webpackgi_exports__2.kB7;
var __webpackgi_exports__CubeReflectionMapping = __webpackgi_exports__2.fY$;
var __webpackgi_exports__CubeRefractionMapping = __webpackgi_exports__2.vxC;
var __webpackgi_exports__CubeTexture = __webpackgi_exports__2.BtG;
var __webpackgi_exports__CubeTextureLoader = __webpackgi_exports__2.cBK;
var __webpackgi_exports__CubeUVReflectionMapping = __webpackgi_exports__2.g8_;
var __webpackgi_exports__CubicBezierCurve = __webpackgi_exports__2.AXT;
var __webpackgi_exports__CubicBezierCurve3 = __webpackgi_exports__2.yj7;
var __webpackgi_exports__CubicInterpolant = __webpackgi_exports__2.dYG;
var __webpackgi_exports__CullFaceBack = __webpackgi_exports__2.tm_;
var __webpackgi_exports__CullFaceFront = __webpackgi_exports__2.S2y;
var __webpackgi_exports__CullFaceFrontBack = __webpackgi_exports__2.B02;
var __webpackgi_exports__CullFaceNone = __webpackgi_exports__2.PeU;
var __webpackgi_exports__Curve = __webpackgi_exports__2.Hyl;
var __webpackgi_exports__CurvePath = __webpackgi_exports__2.Wqd;
var __webpackgi_exports__CustomAnimationHelper = __webpackgi_exports__2.c0Q;
var __webpackgi_exports__CustomAnimationHelperPlugin = __webpackgi_exports__2.re0;
var __webpackgi_exports__CustomBlending = __webpackgi_exports__2.Xaj;
var __webpackgi_exports__CustomBumpMapPlugin = __webpackgi_exports__2.DUb;
var __webpackgi_exports__CustomToneMapping = __webpackgi_exports__2.dZ3;
var __webpackgi_exports__CylinderBufferGeometry = __webpackgi_exports__2.m_w;
var __webpackgi_exports__CylinderGeometry = __webpackgi_exports__2.fHI;
var __webpackgi_exports__Cylindrical = __webpackgi_exports__2.LBq;
var __webpackgi_exports__DRACOLoader2 = __webpackgi_exports__2.Qww;
var __webpackgi_exports__Damper = __webpackgi_exports__2.CGV;
var __webpackgi_exports__Data3DTexture = __webpackgi_exports__2.JUT;
var __webpackgi_exports__DataArrayTexture = __webpackgi_exports__2.p3g;
var __webpackgi_exports__DataTexture = __webpackgi_exports__2.IEO;
var __webpackgi_exports__DataTextureLoader = __webpackgi_exports__2.yxD;
var __webpackgi_exports__DataUrlLoader = __webpackgi_exports__2.CUS;
var __webpackgi_exports__DataUtils = __webpackgi_exports__2.A5E;
var __webpackgi_exports__DebugPlugin = __webpackgi_exports__2.zqG;
var __webpackgi_exports__DecodeUTF8 = __webpackgi_exports__2.PfX;
var __webpackgi_exports__Decompress = __webpackgi_exports__2.Q1o;
var __webpackgi_exports__DecrementStencilOp = __webpackgi_exports__2.jfJ;
var __webpackgi_exports__DecrementWrapStencilOp = __webpackgi_exports__2.T_J;
var __webpackgi_exports__DefaultLoadingManager = __webpackgi_exports__2.tEQ;
var __webpackgi_exports__Deflate = __webpackgi_exports__2.gb4;
var __webpackgi_exports__DepthFormat = __webpackgi_exports__2.qkB;
var __webpackgi_exports__DepthOfFieldPass = __webpackgi_exports__2.cvk;
var __webpackgi_exports__DepthOfFieldPlugin = __webpackgi_exports__2.HWo;
var __webpackgi_exports__DepthStencilFormat = __webpackgi_exports__2.brP;
var __webpackgi_exports__DepthTexture = __webpackgi_exports__2.$YQ;
var __webpackgi_exports__DeviceOrientationControls2 = __webpackgi_exports__2.X8d;
var __webpackgi_exports__DeviceOrientationControlsPlugin = __webpackgi_exports__2.Zdt;
var __webpackgi_exports__DiamondMaterial = __webpackgi_exports__2.yNB;
var __webpackgi_exports__DiamondPlugin = __webpackgi_exports__2.h7x;
var __webpackgi_exports__DirectionalLight = __webpackgi_exports__2.Ox3;
var __webpackgi_exports__DirectionalLight2 = __webpackgi_exports__2.qtn;
var __webpackgi_exports__DirectionalLightHelper = __webpackgi_exports__2.cBI;
var __webpackgi_exports__DiscreteInterpolant = __webpackgi_exports__2.cU9;
var __webpackgi_exports__DisplayP3ColorSpace = __webpackgi_exports__2.ntt;
var __webpackgi_exports__DodecahedronBufferGeometry = __webpackgi_exports__2.DT1;
var __webpackgi_exports__DodecahedronGeometry = __webpackgi_exports__2.Kgo;
var __webpackgi_exports__DoubleSide = __webpackgi_exports__2.ehD;
var __webpackgi_exports__Dropzone = __webpackgi_exports__2.fhJ;
var __webpackgi_exports__DropzonePlugin = __webpackgi_exports__2.y1s;
var __webpackgi_exports__DstAlphaFactor = __webpackgi_exports__2.fSK;
var __webpackgi_exports__DstColorFactor = __webpackgi_exports__2.Vdb;
var __webpackgi_exports__DynamicCopyUsage = __webpackgi_exports__2.l8J;
var __webpackgi_exports__DynamicDrawUsage = __webpackgi_exports__2.dj0;
var __webpackgi_exports__DynamicReadUsage = __webpackgi_exports__2.QM0;
var __webpackgi_exports__EXRExporter2 = __webpackgi_exports__2.n94;
var __webpackgi_exports__EXRLoadPlugin = __webpackgi_exports__2.OIS;
var __webpackgi_exports__EasingFunctions = __webpackgi_exports__2.q8b;
var __webpackgi_exports__EdgesGeometry = __webpackgi_exports__2.TOt;
var __webpackgi_exports__EffectComposer2 = __webpackgi_exports__2.xaN;
var __webpackgi_exports__EllipseCurve = __webpackgi_exports__2.Ny0;
var __webpackgi_exports__EllipseCurve3D = __webpackgi_exports__2.NeD;
var __webpackgi_exports__EncodeUTF8 = __webpackgi_exports__2.Zof;
var __webpackgi_exports__EncoderMethod = __webpackgi_exports__2.N1Y;
var __webpackgi_exports__EnvironmentPresetGroup = __webpackgi_exports__2.itK;
var __webpackgi_exports__EqualCompare = __webpackgi_exports__2.F1y;
var __webpackgi_exports__EqualDepth = __webpackgi_exports__2.eD;
var __webpackgi_exports__EqualStencilFunc = __webpackgi_exports__2.jwo;
var __webpackgi_exports__EquirectangularReflectionMapping = __webpackgi_exports__2.dSO;
var __webpackgi_exports__EquirectangularRefractionMapping = __webpackgi_exports__2.Bf4;
var __webpackgi_exports__Euler = __webpackgi_exports__2.USm;
var __webpackgi_exports__EventDispatcher = __webpackgi_exports__2.pBf;
var __webpackgi_exports__ExtrasUiPlugin = __webpackgi_exports__2.eBg;
var __webpackgi_exports__ExtrudeBufferGeometry = __webpackgi_exports__2.$Vf;
var __webpackgi_exports__ExtrudeGeometry = __webpackgi_exports__2.O7d;
var __webpackgi_exports__FBXLoadPlugin = __webpackgi_exports__2.ksq;
var __webpackgi_exports__FFMPEGRecorder = __webpackgi_exports__2.hFL;
var __webpackgi_exports__FSShadowMaterial = __webpackgi_exports__2.gXf;
var __webpackgi_exports__FileLoader = __webpackgi_exports__2.hH6;
var __webpackgi_exports__FileTransferPlugin = __webpackgi_exports__2.izP;
var __webpackgi_exports__FilmicGrainPlugin = __webpackgi_exports__2.kpi;
var __webpackgi_exports__FirstPersonControls2 = __webpackgi_exports__2.DwZ;
var __webpackgi_exports__FirstPersonControlsPlugin = __webpackgi_exports__2.kN3;
var __webpackgi_exports__Float16BufferAttribute = __webpackgi_exports__2.e62;
var __webpackgi_exports__Float32BufferAttribute = __webpackgi_exports__2.a$l;
var __webpackgi_exports__Float64BufferAttribute = __webpackgi_exports__2.OM3;
var __webpackgi_exports__FloatType = __webpackgi_exports__2.VzW;
var __webpackgi_exports__Fog = __webpackgi_exports__2.ybr;
var __webpackgi_exports__FogExp2 = __webpackgi_exports__2.yo9;
var __webpackgi_exports__FragmentClippingExtensionPlugin = __webpackgi_exports__2.Dzq;
var __webpackgi_exports__FragmentClippingMode = __webpackgi_exports__2.zCA;
var __webpackgi_exports__FrameFadePlugin = __webpackgi_exports__2.$Bt;
var __webpackgi_exports__FramebufferTexture = __webpackgi_exports__2.Wzm;
var __webpackgi_exports__FrontSide = __webpackgi_exports__2.Wl3;
var __webpackgi_exports__Frustum = __webpackgi_exports__2.iWj;
var __webpackgi_exports__FullScreenPlugin = __webpackgi_exports__2.DNz;
var __webpackgi_exports__GBufferPlugin = __webpackgi_exports__2.m1M;
var __webpackgi_exports__GLBufferAttribute = __webpackgi_exports__2.ylh;
var __webpackgi_exports__GLSL1 = __webpackgi_exports__2.v9Y;
var __webpackgi_exports__GLSL3 = __webpackgi_exports__2.LSk;
var __webpackgi_exports__GLTFAnimationPlugin = __webpackgi_exports__2.LHE;
var __webpackgi_exports__GLTFDracoExportPlugin = __webpackgi_exports__2.KE0;
var __webpackgi_exports__GLTFDracoExporter = __webpackgi_exports__2.KCF;
var __webpackgi_exports__GLTFExporter2 = __webpackgi_exports__2.a4n;
var __webpackgi_exports__GLTFExporterMaterialsVariantsExtensionExport = __webpackgi_exports__2.NKC;
var __webpackgi_exports__GLTFKHRMaterialVariantsPlugin = __webpackgi_exports__2.jrv;
var __webpackgi_exports__GLTFLoader2 = __webpackgi_exports__2.zIH;
var __webpackgi_exports__GLTFMaterialsAlphaMapExtensionName = __webpackgi_exports__2.Hfk;
var __webpackgi_exports__GLTFMaterialsBumpMapExtensionName = __webpackgi_exports__2.png;
var __webpackgi_exports__GLTFMaterialsDisplacementMapExtensionName = __webpackgi_exports__2.tAj;
var __webpackgi_exports__GLTFMaterialsLightMapExtensionName = __webpackgi_exports__2.Eb_;
var __webpackgi_exports__GLTFMaterialsVariantsExtensionImport = __webpackgi_exports__2.SJj;
var __webpackgi_exports__GLTFMeshGpuInstancingExporter = __webpackgi_exports__2.cF0;
var __webpackgi_exports__GLTFMeshOptPlugin = __webpackgi_exports__2.BT2;
var __webpackgi_exports__GLTFWriter2 = __webpackgi_exports__2._8p;
var __webpackgi_exports__GammaCorrectionExtension = __webpackgi_exports__2.V5Z;
var __webpackgi_exports__GammaCorrectionPlugin = __webpackgi_exports__2.s5b;
var __webpackgi_exports__GemEnvironmentPresetGroup = __webpackgi_exports__2.BHZ;
var __webpackgi_exports__GenericBlendTexturePass = __webpackgi_exports__2.hkn;
var __webpackgi_exports__GenericFilterPlugin = __webpackgi_exports__2.GFY;
var __webpackgi_exports__GeometryGeneratorPlugin = __webpackgi_exports__2.hZr;
var __webpackgi_exports__GreaterCompare = __webpackgi_exports__2.Zen;
var __webpackgi_exports__GreaterDepth = __webpackgi_exports__2.w$m;
var __webpackgi_exports__GreaterEqualCompare = __webpackgi_exports__2.Jjb;
var __webpackgi_exports__GreaterEqualDepth = __webpackgi_exports__2.ksN;
var __webpackgi_exports__GreaterEqualStencilFunc = __webpackgi_exports__2.j4z;
var __webpackgi_exports__GreaterStencilFunc = __webpackgi_exports__2.OAl;
var __webpackgi_exports__GridHelper = __webpackgi_exports__2.VLJ;
var __webpackgi_exports__GroundPlugin = __webpackgi_exports__2.C73;
var __webpackgi_exports__Group = __webpackgi_exports__2.ZAu;
var __webpackgi_exports__Gunzip = __webpackgi_exports__2.ibP;
var __webpackgi_exports__GyroInputDevice = __webpackgi_exports__2.lth;
var __webpackgi_exports__Gzip = __webpackgi_exports__2._fI;
var __webpackgi_exports__HDRiGroundPlugin = __webpackgi_exports__2.hUN;
var __webpackgi_exports__HalfFloatType = __webpackgi_exports__2.cLu;
var __webpackgi_exports__HemisphereLight = __webpackgi_exports__2.vmT;
var __webpackgi_exports__HemisphereLightHelper = __webpackgi_exports__2.Qpg;
var __webpackgi_exports__HemisphereLightProbe = __webpackgi_exports__2.So8;
var __webpackgi_exports__HierarchyUiPlugin = __webpackgi_exports__2.eOv;
var __webpackgi_exports__IcosahedronBufferGeometry = __webpackgi_exports__2.Wjw;
var __webpackgi_exports__IcosahedronGeometry = __webpackgi_exports__2.cJO;
var __webpackgi_exports__ImageBitmapLoader = __webpackgi_exports__2.QRU;
var __webpackgi_exports__ImageLoader = __webpackgi_exports__2.S3k;
var __webpackgi_exports__ImageSequenceRecorder = __webpackgi_exports__2.OPJ;
var __webpackgi_exports__ImageUtils = __webpackgi_exports__2.PpQ;
var __webpackgi_exports__Importer = __webpackgi_exports__2.q_9;
var __webpackgi_exports__IncrementStencilOp = __webpackgi_exports__2.ZRs;
var __webpackgi_exports__IncrementWrapStencilOp = __webpackgi_exports__2.oqc;
var __webpackgi_exports__Inflate = __webpackgi_exports__2.T_x;
var __webpackgi_exports__InstancedBufferAttribute = __webpackgi_exports__2.lb7;
var __webpackgi_exports__InstancedBufferGeometry = __webpackgi_exports__2.L5s;
var __webpackgi_exports__InstancedInterleavedBuffer = __webpackgi_exports__2.$TI;
var __webpackgi_exports__InstancedMesh = __webpackgi_exports__2.SPe;
var __webpackgi_exports__Int16BufferAttribute = __webpackgi_exports__2.aVm;
var __webpackgi_exports__Int32BufferAttribute = __webpackgi_exports__2.j87;
var __webpackgi_exports__Int8BufferAttribute = __webpackgi_exports__2.RNb;
var __webpackgi_exports__IntType = __webpackgi_exports__2.Kz5;
var __webpackgi_exports__InteractionPromptPlugin = __webpackgi_exports__2.LYt;
var __webpackgi_exports__InterleavedBuffer = __webpackgi_exports__2.vpT;
var __webpackgi_exports__InterleavedBufferAttribute = __webpackgi_exports__2.kB5;
var __webpackgi_exports__Interpolant = __webpackgi_exports__2._C8;
var __webpackgi_exports__InterpolateDiscrete = __webpackgi_exports__2.Syv;
var __webpackgi_exports__InterpolateLinear = __webpackgi_exports__2.NMF;
var __webpackgi_exports__InterpolateSmooth = __webpackgi_exports__2.pIN;
var __webpackgi_exports__InvertStencilOp = __webpackgi_exports__2.eMJ;
var __webpackgi_exports__KHR_TEXTURE_BASISU = __webpackgi_exports__2.rN7;
var __webpackgi_exports__KTX2LoadPlugin = __webpackgi_exports__2.iUp;
var __webpackgi_exports__KTXLoadPlugin = __webpackgi_exports__2.GFd;
var __webpackgi_exports__KeepStencilOp = __webpackgi_exports__2.x5V;
var __webpackgi_exports__KeyframeTrack = __webpackgi_exports__2.tUh;
var __webpackgi_exports__LOD = __webpackgi_exports__2.z8B;
var __webpackgi_exports__LUTPlugin = __webpackgi_exports__2.vcl;
var __webpackgi_exports__LatheBufferGeometry = __webpackgi_exports__2.GZb;
var __webpackgi_exports__LatheGeometry = __webpackgi_exports__2.p7y;
var __webpackgi_exports__LayeredMaterialPlugin = __webpackgi_exports__2.e6l;
var __webpackgi_exports__Layers = __webpackgi_exports__2.S9g;
var __webpackgi_exports__LessCompare = __webpackgi_exports__2.D67;
var __webpackgi_exports__LessDepth = __webpackgi_exports__2.Zr5;
var __webpackgi_exports__LessEqualCompare = __webpackgi_exports__2.M$G;
var __webpackgi_exports__LessEqualDepth = __webpackgi_exports__2.vCF;
var __webpackgi_exports__LessEqualStencilFunc = __webpackgi_exports__2.yt0;
var __webpackgi_exports__LessStencilFunc = __webpackgi_exports__2.uXU;
var __webpackgi_exports__Light = __webpackgi_exports__2._kC;
var __webpackgi_exports__LightProbe = __webpackgi_exports__2.lk7;
var __webpackgi_exports__LightsUiPlugin = __webpackgi_exports__2.USc;
var __webpackgi_exports__Line = __webpackgi_exports__2.x12;
var __webpackgi_exports__Line2 = __webpackgi_exports__2.w_R;
var __webpackgi_exports__Line3 = __webpackgi_exports__2.Zzh;
var __webpackgi_exports__LineBasicMaterial = __webpackgi_exports__2.nls;
var __webpackgi_exports__LineCurve = __webpackgi_exports__2.g_z;
var __webpackgi_exports__LineCurve3 = __webpackgi_exports__2.U7;
var __webpackgi_exports__LineDashedMaterial = __webpackgi_exports__2.FT0;
var __webpackgi_exports__LineGeometry = __webpackgi_exports__2.L1_;
var __webpackgi_exports__LineLoop = __webpackgi_exports__2.blk;
var __webpackgi_exports__LineMaterial = __webpackgi_exports__2.YRm;
var __webpackgi_exports__LineSegments = __webpackgi_exports__2.ejS;
var __webpackgi_exports__LineSegments2 = __webpackgi_exports__2.wUb;
var __webpackgi_exports__LineSegmentsGeometry = __webpackgi_exports__2.zOz;
var __webpackgi_exports__LinearEncoding = __webpackgi_exports__2.rnI;
var __webpackgi_exports__LinearFilter = __webpackgi_exports__2.wem;
var __webpackgi_exports__LinearInterpolant = __webpackgi_exports__2.lfu;
var __webpackgi_exports__LinearMipMapLinearFilter = __webpackgi_exports__2.FDw;
var __webpackgi_exports__LinearMipMapNearestFilter = __webpackgi_exports__2.lRj;
var __webpackgi_exports__LinearMipmapLinearFilter = __webpackgi_exports__2.D1R;
var __webpackgi_exports__LinearMipmapNearestFilter = __webpackgi_exports__2.qyh;
var __webpackgi_exports__LinearSRGBColorSpace = __webpackgi_exports__2.GUF;
var __webpackgi_exports__LinearToneMapping = __webpackgi_exports__2.EoG;
var __webpackgi_exports__Loader = __webpackgi_exports__2.aNw;
var __webpackgi_exports__LoaderUtils = __webpackgi_exports__2.Zp0;
var __webpackgi_exports__LoadingManager = __webpackgi_exports__2.lLk;
var __webpackgi_exports__LoadingScreenPlugin = __webpackgi_exports__2.NHT;
var __webpackgi_exports__LoopOnce = __webpackgi_exports__2.jAl;
var __webpackgi_exports__LoopPingPong = __webpackgi_exports__2.uEv;
var __webpackgi_exports__LoopRepeat = __webpackgi_exports__2.YKA;
var __webpackgi_exports__LuminanceAlphaFormat = __webpackgi_exports__2.cRx;
var __webpackgi_exports__LuminanceFormat = __webpackgi_exports__2.Y8D;
var __webpackgi_exports__MOUSE = __webpackgi_exports__2.RsA;
var __webpackgi_exports__MTLLoader2 = __webpackgi_exports__2.Y0m;
var __webpackgi_exports__Material = __webpackgi_exports__2.F5T;
var __webpackgi_exports__MaterialConfiguratorBasePlugin = __webpackgi_exports__2.EDU;
var __webpackgi_exports__MaterialConfiguratorPlugin = __webpackgi_exports__2.z$Q;
var __webpackgi_exports__MaterialExtender = __webpackgi_exports__2.KA8;
var __webpackgi_exports__MaterialLibPresetGroupPresetGroup = __webpackgi_exports__2.ZqF;
var __webpackgi_exports__MaterialLibraryBasePlugin = __webpackgi_exports__2.XUj;
var __webpackgi_exports__MaterialLibraryPlugin = __webpackgi_exports__2.Me$;
var __webpackgi_exports__MaterialLoader = __webpackgi_exports__2.u7G;
var __webpackgi_exports__MaterialManager = __webpackgi_exports__2.PEk;
var __webpackgi_exports__MaterialPreviewGenerator = __webpackgi_exports__2.BG4;
var __webpackgi_exports__MathUtils = __webpackgi_exports__2.M8C;
var __webpackgi_exports__Matrix3 = __webpackgi_exports__2.Vkp;
var __webpackgi_exports__Matrix4 = __webpackgi_exports__2.yGw;
var __webpackgi_exports__MaxEquation = __webpackgi_exports__2.Sm8;
var __webpackgi_exports__Mesh = __webpackgi_exports__2.Kj0;
var __webpackgi_exports__MeshBasicMaterial = __webpackgi_exports__2.vBJ;
var __webpackgi_exports__MeshBasicMaterial2 = __webpackgi_exports__2.QfV;
var __webpackgi_exports__MeshDepthMaterial = __webpackgi_exports__2.lRF;
var __webpackgi_exports__MeshDistanceMaterial = __webpackgi_exports__2.Lun;
var __webpackgi_exports__MeshLambertMaterial = __webpackgi_exports__2.YBo;
var __webpackgi_exports__MeshMatcapMaterial = __webpackgi_exports__2.kaV;
var __webpackgi_exports__MeshNormalMaterial = __webpackgi_exports__2.RSm;
var __webpackgi_exports__MeshOptSimplifyModifierPlugin = __webpackgi_exports__2.NDk;
var __webpackgi_exports__MeshPhongMaterial = __webpackgi_exports__2.xoR;
var __webpackgi_exports__MeshPhysicalMaterial = __webpackgi_exports__2.EJi;
var __webpackgi_exports__MeshStandardMaterial = __webpackgi_exports__2.Wid;
var __webpackgi_exports__MeshStandardMaterial2 = __webpackgi_exports__2.iuj;
var __webpackgi_exports__MeshToonMaterial = __webpackgi_exports__2.IKL;
var __webpackgi_exports__MinEquation = __webpackgi_exports__2.r_;
var __webpackgi_exports__MirroredRepeatWrapping = __webpackgi_exports__2.OoA;
var __webpackgi_exports__MixOperation = __webpackgi_exports__2.qhX;
var __webpackgi_exports__MouseInputDevice = __webpackgi_exports__2.CRe;
var __webpackgi_exports__MultiFilterPlugin = __webpackgi_exports__2.qPT;
var __webpackgi_exports__MultiplyBlending = __webpackgi_exports__2.M5h;
var __webpackgi_exports__MultiplyOperation = __webpackgi_exports__2.Ns1;
var __webpackgi_exports__NearestFilter = __webpackgi_exports__2.TyD;
var __webpackgi_exports__NearestMipMapLinearFilter = __webpackgi_exports__2.vZf;
var __webpackgi_exports__NearestMipMapNearestFilter = __webpackgi_exports__2.HTd;
var __webpackgi_exports__NearestMipmapLinearFilter = __webpackgi_exports__2.aH4;
var __webpackgi_exports__NearestMipmapNearestFilter = __webpackgi_exports__2.YLQ;
var __webpackgi_exports__NeverCompare = __webpackgi_exports__2.xoQ;
var __webpackgi_exports__NeverDepth = __webpackgi_exports__2.BVF;
var __webpackgi_exports__NeverStencilFunc = __webpackgi_exports__2.MyG;
var __webpackgi_exports__NoBlending = __webpackgi_exports__2.jFi;
var __webpackgi_exports__NoColorSpace = __webpackgi_exports__2.aCh;
var __webpackgi_exports__NoToneMapping = __webpackgi_exports__2.uL9;
var __webpackgi_exports__NoiseBumpMaterialPlugin = __webpackgi_exports__2.TNj;
var __webpackgi_exports__NormalAnimationBlendMode = __webpackgi_exports__2.IFH;
var __webpackgi_exports__NormalBlending = __webpackgi_exports__2.bdR;
var __webpackgi_exports__NormalBufferPlugin = __webpackgi_exports__2.RPs;
var __webpackgi_exports__NormalCaptureMaterial = __webpackgi_exports__2.kM_;
var __webpackgi_exports__NotEqualCompare = __webpackgi_exports__2.O78;
var __webpackgi_exports__NotEqualDepth = __webpackgi_exports__2.M6v;
var __webpackgi_exports__NotEqualStencilFunc = __webpackgi_exports__2.RvT;
var __webpackgi_exports__NumberKeyframeTrack = __webpackgi_exports__2.dUE;
var __webpackgi_exports__OBJLoader2 = __webpackgi_exports__2.oe_;
var __webpackgi_exports__ObjMtlLoadPlugin = __webpackgi_exports__2.BuN;
var __webpackgi_exports__Object3D = __webpackgi_exports__2.Tme;
var __webpackgi_exports__Object3DModel = __webpackgi_exports__2.N9P;
var __webpackgi_exports__Object3DWidgetsPlugin = __webpackgi_exports__2.tfP;
var __webpackgi_exports__ObjectLoader = __webpackgi_exports__2.Gql;
var __webpackgi_exports__ObjectLoader2 = __webpackgi_exports__2.$XY;
var __webpackgi_exports__ObjectPicker = __webpackgi_exports__2.O9d;
var __webpackgi_exports__ObjectProcessorMap = __webpackgi_exports__2.zEO;
var __webpackgi_exports__ObjectRotationPlugin = __webpackgi_exports__2.qfx;
var __webpackgi_exports__ObjectSpaceNormalMap = __webpackgi_exports__2.PA7;
var __webpackgi_exports__OctahedronBufferGeometry = __webpackgi_exports__2.REq;
var __webpackgi_exports__OctahedronGeometry = __webpackgi_exports__2.pQR;
var __webpackgi_exports__OneFactor = __webpackgi_exports__2.ghN;
var __webpackgi_exports__OneMinusDstAlphaFactor = __webpackgi_exports__2.Hy8;
var __webpackgi_exports__OneMinusDstColorFactor = __webpackgi_exports__2.Wpd;
var __webpackgi_exports__OneMinusSrcAlphaFactor = __webpackgi_exports__2.LgZ;
var __webpackgi_exports__OneMinusSrcColorFactor = __webpackgi_exports__2.iWC;
var __webpackgi_exports__OrbitControls2 = __webpackgi_exports__2.mqn;
var __webpackgi_exports__OrbitControls3 = __webpackgi_exports__2.SKe;
var __webpackgi_exports__OrthographicCamera = __webpackgi_exports__2.iKG;
var __webpackgi_exports__OutlinePlugin = __webpackgi_exports__2.rCq;
var __webpackgi_exports__PCFShadowMap = __webpackgi_exports__2._iA;
var __webpackgi_exports__PCFSoftShadowMap = __webpackgi_exports__2.ntZ;
var __webpackgi_exports__PMREMGenerator = __webpackgi_exports__2.anP;
var __webpackgi_exports__PMREMGeneratorPlugin = __webpackgi_exports__2.X2e;
var __webpackgi_exports__ParallaxCameraControllerPlugin = __webpackgi_exports__2.oxT;
var __webpackgi_exports__ParallaxMappingPlugin = __webpackgi_exports__2.FCo;
var __webpackgi_exports__Path = __webpackgi_exports__2.y$t;
var __webpackgi_exports__PerspectiveCamera = __webpackgi_exports__2.cPb;
var __webpackgi_exports__PickingPlugin = __webpackgi_exports__2.lmx;
var __webpackgi_exports__Plane = __webpackgi_exports__2.JOQ;
var __webpackgi_exports__PlaneBufferGeometry = __webpackgi_exports__2.BKK;
var __webpackgi_exports__PlaneGeometry = __webpackgi_exports__2._12;
var __webpackgi_exports__PlaneHelper = __webpackgi_exports__2.tJx;
var __webpackgi_exports__PluginPresetGroup = __webpackgi_exports__2.mjX;
var __webpackgi_exports__PointLight = __webpackgi_exports__2.cek;
var __webpackgi_exports__PointLight2 = __webpackgi_exports__2.qD0;
var __webpackgi_exports__PointLightHelper = __webpackgi_exports__2.xG9;
var __webpackgi_exports__PointerDragHelper = __webpackgi_exports__2.eqi;
var __webpackgi_exports__PointerLockControls2 = __webpackgi_exports__2.wI8;
var __webpackgi_exports__PointerLockControlsPlugin = __webpackgi_exports__2.Sgv;
var __webpackgi_exports__Points = __webpackgi_exports__2.woe;
var __webpackgi_exports__PointsMaterial = __webpackgi_exports__2.UY4;
var __webpackgi_exports__PolarGridHelper = __webpackgi_exports__2.aq0;
var __webpackgi_exports__PolyhedronBufferGeometry = __webpackgi_exports__2.ujx;
var __webpackgi_exports__PolyhedronGeometry = __webpackgi_exports__2.Uol;
var __webpackgi_exports__PopmotionPlugin = __webpackgi_exports__2.JiH;
var __webpackgi_exports__PositionalAudio = __webpackgi_exports__2.VYz;
var __webpackgi_exports__PresetGroup = __webpackgi_exports__2.B2H;
var __webpackgi_exports__PresetLibraryPlugin = __webpackgi_exports__2._Pm;
var __webpackgi_exports__ProgressivePlugin = __webpackgi_exports__2.EsW;
var __webpackgi_exports__PropertyBinding = __webpackgi_exports__2.iUV;
var __webpackgi_exports__PropertyMixer = __webpackgi_exports__2.tf;
var __webpackgi_exports__QuadraticBezierCurve = __webpackgi_exports__2.ZQ6;
var __webpackgi_exports__QuadraticBezierCurve3 = __webpackgi_exports__2.mXe;
var __webpackgi_exports__Quaternion = __webpackgi_exports__2._fP;
var __webpackgi_exports__QuaternionKeyframeTrack = __webpackgi_exports__2.iLg;
var __webpackgi_exports__QuaternionLinearInterpolant = __webpackgi_exports__2.zbs;
var __webpackgi_exports__RED_GREEN_RGTC2_Format = __webpackgi_exports__2.ZTh;
var __webpackgi_exports__RED_RGTC1_Format = __webpackgi_exports__2.HdW;
var __webpackgi_exports__REVISION = __webpackgi_exports__2.UZH;
var __webpackgi_exports__RGBADepthPacking = __webpackgi_exports__2.mSO;
var __webpackgi_exports__RGBAFormat = __webpackgi_exports__2.wk1;
var __webpackgi_exports__RGBAIntegerFormat = __webpackgi_exports__2.E2K;
var __webpackgi_exports__RGBA_ASTC_10x10_Format = __webpackgi_exports__2.FUD;
var __webpackgi_exports__RGBA_ASTC_10x5_Format = __webpackgi_exports__2.pKu;
var __webpackgi_exports__RGBA_ASTC_10x6_Format = __webpackgi_exports__2.GG6;
var __webpackgi_exports__RGBA_ASTC_10x8_Format = __webpackgi_exports__2.Gih;
var __webpackgi_exports__RGBA_ASTC_12x10_Format = __webpackgi_exports__2.iiP;
var __webpackgi_exports__RGBA_ASTC_12x12_Format = __webpackgi_exports__2.SvJ;
var __webpackgi_exports__RGBA_ASTC_4x4_Format = __webpackgi_exports__2.ptH;
var __webpackgi_exports__RGBA_ASTC_5x4_Format = __webpackgi_exports__2.jZA;
var __webpackgi_exports__RGBA_ASTC_5x5_Format = __webpackgi_exports__2.y2t;
var __webpackgi_exports__RGBA_ASTC_6x5_Format = __webpackgi_exports__2.gi4;
var __webpackgi_exports__RGBA_ASTC_6x6_Format = __webpackgi_exports__2.Djp;
var __webpackgi_exports__RGBA_ASTC_8x5_Format = __webpackgi_exports__2.BG$;
var __webpackgi_exports__RGBA_ASTC_8x6_Format = __webpackgi_exports__2.NYV;
var __webpackgi_exports__RGBA_ASTC_8x8_Format = __webpackgi_exports__2.xJs;
var __webpackgi_exports__RGBA_BPTC_Format = __webpackgi_exports__2.bsb;
var __webpackgi_exports__RGBA_ETC2_EAC_Format = __webpackgi_exports__2.ekQ;
var __webpackgi_exports__RGBA_PVRTC_2BPPV1_Format = __webpackgi_exports__2.CaW;
var __webpackgi_exports__RGBA_PVRTC_4BPPV1_Format = __webpackgi_exports__2.eaV;
var __webpackgi_exports__RGBA_S3TC_DXT1_Format = __webpackgi_exports__2.BFQ;
var __webpackgi_exports__RGBA_S3TC_DXT3_Format = __webpackgi_exports__2.v3W;
var __webpackgi_exports__RGBA_S3TC_DXT5_Format = __webpackgi_exports__2.ILR;
var __webpackgi_exports__RGBM16ColorSpace = __webpackgi_exports__2.G_r;
var __webpackgi_exports__RGBM16ColorSpace_ = __webpackgi_exports__2.N3F;
var __webpackgi_exports__RGB_ETC1_Format = __webpackgi_exports__2.fto;
var __webpackgi_exports__RGB_ETC2_Format = __webpackgi_exports__2.l0P;
var __webpackgi_exports__RGB_PVRTC_2BPPV1_Format = __webpackgi_exports__2.vCx;
var __webpackgi_exports__RGB_PVRTC_4BPPV1_Format = __webpackgi_exports__2._AM;
var __webpackgi_exports__RGB_S3TC_DXT1_Format = __webpackgi_exports__2.wuA;
var __webpackgi_exports__RGFormat = __webpackgi_exports__2.av9;
var __webpackgi_exports__RGIntegerFormat = __webpackgi_exports__2.CtA;
var __webpackgi_exports__RainbowDiamondPlugin = __webpackgi_exports__2.fpq;
var __webpackgi_exports__RandomizedDirectionalLight = __webpackgi_exports__2.BvQ;
var __webpackgi_exports__RandomizedDirectionalLightPlugin = __webpackgi_exports__2.FZJ;
var __webpackgi_exports__RawShaderMaterial = __webpackgi_exports__2.FIo;
var __webpackgi_exports__Ray = __webpackgi_exports__2.zHn;
var __webpackgi_exports__Raycaster = __webpackgi_exports__2.iMs;
var __webpackgi_exports__RectAreaLight = __webpackgi_exports__2.T_f;
var __webpackgi_exports__RedFormat = __webpackgi_exports__2.hEm;
var __webpackgi_exports__RedIntegerFormat = __webpackgi_exports__2.D9w;
var __webpackgi_exports__Reflector2 = __webpackgi_exports__2.sHH;
var __webpackgi_exports__ReinhardToneMapping = __webpackgi_exports__2.CdI;
var __webpackgi_exports__RendererUiPlugin = __webpackgi_exports__2.rkc;
var __webpackgi_exports__RepeatWrapping = __webpackgi_exports__2.rpg;
var __webpackgi_exports__ReplaceStencilOp = __webpackgi_exports__2.ce8;
var __webpackgi_exports__ReverseSubtractEquation = __webpackgi_exports__2.rOj;
var __webpackgi_exports__Rhino3dmLoadPlugin = __webpackgi_exports__2.P6m;
var __webpackgi_exports__Rhino3dmLoader2 = __webpackgi_exports__2.JA6;
var __webpackgi_exports__RingBufferGeometry = __webpackgi_exports__2.V4E;
var __webpackgi_exports__RingGeometry = __webpackgi_exports__2.o8S;
var __webpackgi_exports__RootScene = __webpackgi_exports__2.flB;
var __webpackgi_exports__SIGNED_RED_GREEN_RGTC2_Format = __webpackgi_exports__2.lGU;
var __webpackgi_exports__SIGNED_RED_RGTC1_Format = __webpackgi_exports__2.vuL;
var __webpackgi_exports__SRGBColorSpace = __webpackgi_exports__2.KI_;
var __webpackgi_exports__SSAOPlugin = __webpackgi_exports__2.iLN;
var __webpackgi_exports__SSBevelPass = __webpackgi_exports__2.X6w;
var __webpackgi_exports__SSBevelPlugin = __webpackgi_exports__2.rz_;
var __webpackgi_exports__SSContactShadows = __webpackgi_exports__2.jsw;
var __webpackgi_exports__SSGIPlugin = __webpackgi_exports__2.srG;
var __webpackgi_exports__SSRPlugin = __webpackgi_exports__2.i6Z;
var __webpackgi_exports__STLLoadPlugin = __webpackgi_exports__2.vfv;
var __webpackgi_exports__Scene = __webpackgi_exports__2.xsS;
var __webpackgi_exports__SceneCamerasUiPlugin = __webpackgi_exports__2.or;
var __webpackgi_exports__SceneLoopPlugin = __webpackgi_exports__2.EQj;
var __webpackgi_exports__ScrollableCameraViewPlugin = __webpackgi_exports__2.Rnn;
var __webpackgi_exports__ScrollableCameraViewPreviewPlugin = __webpackgi_exports__2.TyN;
var __webpackgi_exports__SelectionWidget = __webpackgi_exports__2.ov0;
var __webpackgi_exports__ShaderChunk = __webpackgi_exports__2.WdD;
var __webpackgi_exports__ShaderLib = __webpackgi_exports__2.Vj0;
var __webpackgi_exports__ShaderMaterial = __webpackgi_exports__2.jyz;
var __webpackgi_exports__ShaderMaterial2 = __webpackgi_exports__2.mTM;
var __webpackgi_exports__ShaderMaterialEncodingSupport = __webpackgi_exports__2.Mn1;
var __webpackgi_exports__ShaderPass2 = __webpackgi_exports__2.Hlq;
var __webpackgi_exports__ShadowMapBaker = __webpackgi_exports__2.Fi7;
var __webpackgi_exports__ShadowMaterial = __webpackgi_exports__2.Tn7;
var __webpackgi_exports__Shape = __webpackgi_exports__2.bnF;
var __webpackgi_exports__ShapeBufferGeometry = __webpackgi_exports__2.HW6;
var __webpackgi_exports__ShapeGeometry = __webpackgi_exports__2.oa8;
var __webpackgi_exports__ShapePath = __webpackgi_exports__2.T_1;
var __webpackgi_exports__ShapeTubeExtrudePlugin = __webpackgi_exports__2.zHJ;
var __webpackgi_exports__ShapeUtils = __webpackgi_exports__2.iDF;
var __webpackgi_exports__ShortType = __webpackgi_exports__2.iAb;
var __webpackgi_exports__SimpleAssetList = __webpackgi_exports__2.d4E;
var __webpackgi_exports__SimpleBackgroundEnvUiPlugin = __webpackgi_exports__2.lBg;
var __webpackgi_exports__SimpleDataSource = __webpackgi_exports__2.JeJ;
var __webpackgi_exports__SimpleEventDispatcher = __webpackgi_exports__2.FKY;
var __webpackgi_exports__SimpleJSONExporter = __webpackgi_exports__2.zlZ;
var __webpackgi_exports__SimpleJSONLoader = __webpackgi_exports__2.vkg;
var __webpackgi_exports__SimpleTextExporter = __webpackgi_exports__2.brh;
var __webpackgi_exports__SimpleTextPlugin = __webpackgi_exports__2.kZK;
var __webpackgi_exports__SimpleViewerUi = __webpackgi_exports__2.puG;
var __webpackgi_exports__SimplifyModifierPlugin = __webpackgi_exports__2.VJK;
var __webpackgi_exports__Skeleton = __webpackgi_exports__2.OdW;
var __webpackgi_exports__SkeletonHelper = __webpackgi_exports__2._YX;
var __webpackgi_exports__SkinnedMesh = __webpackgi_exports__2.TUv;
var __webpackgi_exports__Source = __webpackgi_exports__2.Hw6;
var __webpackgi_exports__Sphere = __webpackgi_exports__2.aLr;
var __webpackgi_exports__SphereBufferGeometry = __webpackgi_exports__2.Aip;
var __webpackgi_exports__SphereGeometry = __webpackgi_exports__2.xo$;
var __webpackgi_exports__SphereSelectionWidget = __webpackgi_exports__2.bIn;
var __webpackgi_exports__Spherical = __webpackgi_exports__2.$V;
var __webpackgi_exports__SphericalHarmonics3 = __webpackgi_exports__2.lDi;
var __webpackgi_exports__SplineCurve = __webpackgi_exports__2.gti;
var __webpackgi_exports__SpotLight = __webpackgi_exports__2.PMe;
var __webpackgi_exports__SpotLight2 = __webpackgi_exports__2.iwP;
var __webpackgi_exports__SpotLightHelper = __webpackgi_exports__2.FvO;
var __webpackgi_exports__Sprite = __webpackgi_exports__2.jyi;
var __webpackgi_exports__SpriteMaterial = __webpackgi_exports__2.xeV;
var __webpackgi_exports__SrcAlphaFactor = __webpackgi_exports__2.k74;
var __webpackgi_exports__SrcAlphaSaturateFactor = __webpackgi_exports__2.RlZ;
var __webpackgi_exports__SrcColorFactor = __webpackgi_exports__2.KhW;
var __webpackgi_exports__StaticCopyUsage = __webpackgi_exports__2.HgB;
var __webpackgi_exports__StaticDrawUsage = __webpackgi_exports__2.W2J;
var __webpackgi_exports__StaticReadUsage = __webpackgi_exports__2.JWc;
var __webpackgi_exports__StereoCamera = __webpackgi_exports__2.u37;
var __webpackgi_exports__StreamCopyUsage = __webpackgi_exports__2.Z6B;
var __webpackgi_exports__StreamDrawUsage = __webpackgi_exports__2.QZ1;
var __webpackgi_exports__StreamReadUsage = __webpackgi_exports__2.Ir4;
var __webpackgi_exports__StringKeyframeTrack = __webpackgi_exports__2.NwF;
var __webpackgi_exports__SubtractEquation = __webpackgi_exports__2.Wbm;
var __webpackgi_exports__SubtractiveBlending = __webpackgi_exports__2.N4l;
var __webpackgi_exports__SwitchNodeBasePlugin = __webpackgi_exports__2.Jxm;
var __webpackgi_exports__SwitchNodePlugin = __webpackgi_exports__2.ej9;
var __webpackgi_exports__TOUCH = __webpackgi_exports__2.QmN;
var __webpackgi_exports__TYPED_ARRAYS = __webpackgi_exports__2.Y4W;
var __webpackgi_exports__TangentSpaceNormalMap = __webpackgi_exports__2.IOt;
var __webpackgi_exports__TemporalAAPlugin = __webpackgi_exports__2.NOD;
var __webpackgi_exports__TetrahedronBufferGeometry = __webpackgi_exports__2.L5g;
var __webpackgi_exports__TetrahedronGeometry = __webpackgi_exports__2.H$k;
var __webpackgi_exports__TextSVGOptions = __webpackgi_exports__2.cuP;
var __webpackgi_exports__Texture = __webpackgi_exports__2.xEZ;
var __webpackgi_exports__TextureLoader = __webpackgi_exports__2.dpR;
var __webpackgi_exports__ThinFilmLayerPlugin = __webpackgi_exports__2.wOD;
var __webpackgi_exports__ThreeMaterialLoader = __webpackgi_exports__2.KNb;
var __webpackgi_exports__TonemapPlugin = __webpackgi_exports__2.IiN;
var __webpackgi_exports__TorusBufferGeometry = __webpackgi_exports__2.Cne;
var __webpackgi_exports__TorusGeometry = __webpackgi_exports__2.XvJ;
var __webpackgi_exports__TorusKnotBufferGeometry = __webpackgi_exports__2.XZw;
var __webpackgi_exports__TorusKnotGeometry = __webpackgi_exports__2.FE5;
var __webpackgi_exports__TrackballControlsPlugin = __webpackgi_exports__2.lUF;
var __webpackgi_exports__TransformAnimationPlugin = __webpackgi_exports__2.Mck;
var __webpackgi_exports__TransformControls2 = __webpackgi_exports__2.lVp;
var __webpackgi_exports__TransfrSharePlugin = __webpackgi_exports__2.Lpo;
var __webpackgi_exports__Triangle = __webpackgi_exports__2.CJI;
var __webpackgi_exports__TriangleFanDrawMode = __webpackgi_exports__2.z$h;
var __webpackgi_exports__TriangleStripDrawMode = __webpackgi_exports__2.UlW;
var __webpackgi_exports__TrianglesDrawMode = __webpackgi_exports__2.WwZ;
var __webpackgi_exports__TriplanarUVMappingPlugin = __webpackgi_exports__2.zG7;
var __webpackgi_exports__TubeBufferGeometry = __webpackgi_exports__2.Lcc;
var __webpackgi_exports__TubeGeometry = __webpackgi_exports__2.WXh;
var __webpackgi_exports__TubeShapeGeometry = __webpackgi_exports__2.Vjr;
var __webpackgi_exports__TweakpaneUiPlugin = __webpackgi_exports__2.LuM;
var __webpackgi_exports__TweakpaneWrapper = __webpackgi_exports__2.LP5;
var __webpackgi_exports__TwoPassDoubleSide = __webpackgi_exports__2.ub3;
var __webpackgi_exports__UChartOptions = __webpackgi_exports__2.OV;
var __webpackgi_exports__UPackOptions = __webpackgi_exports__2.G_n;
var __webpackgi_exports__UVMapping = __webpackgi_exports__2.xfE;
var __webpackgi_exports__Uint16BufferAttribute = __webpackgi_exports__2.qlB;
var __webpackgi_exports__Uint32BufferAttribute = __webpackgi_exports__2.lCJ;
var __webpackgi_exports__Uint8BufferAttribute = __webpackgi_exports__2.WTc;
var __webpackgi_exports__Uint8ClampedBufferAttribute = __webpackgi_exports__2.rAo;
var __webpackgi_exports__Uncharted2Tonemapping = __webpackgi_exports__2.LZj;
var __webpackgi_exports__Uniform = __webpackgi_exports__2.xWb;
var __webpackgi_exports__UniformsGroup = __webpackgi_exports__2.gH0;
var __webpackgi_exports__UniformsLib = __webpackgi_exports__2.rBU;
var __webpackgi_exports__UniformsUtils = __webpackgi_exports__2.rDY;
var __webpackgi_exports__UnsignedByteType = __webpackgi_exports__2.ywz;
var __webpackgi_exports__UnsignedInt248Type = __webpackgi_exports__2.wJv;
var __webpackgi_exports__UnsignedIntType = __webpackgi_exports__2.JQ4;
var __webpackgi_exports__UnsignedShort4444Type = __webpackgi_exports__2.k0A;
var __webpackgi_exports__UnsignedShort5551Type = __webpackgi_exports__2.irR;
var __webpackgi_exports__UnsignedShortType = __webpackgi_exports__2.LsT;
var __webpackgi_exports__Unzip = __webpackgi_exports__2.q5h;
var __webpackgi_exports__UnzipInflate = __webpackgi_exports__2.TKh;
var __webpackgi_exports__UnzipPassThrough = __webpackgi_exports__2.tyg;
var __webpackgi_exports__Unzlib = __webpackgi_exports__2.Ro5;
var __webpackgi_exports__VJSONPresetGroup = __webpackgi_exports__2.Saj;
var __webpackgi_exports__VRPluginBasic = __webpackgi_exports__2.CHp;
var __webpackgi_exports__VSMShadowMap = __webpackgi_exports__2.dwk;
var __webpackgi_exports__VariationConfiguratorEditorUiPlugin = __webpackgi_exports__2.t0w;
var __webpackgi_exports__VariationConfiguratorGridUiPlugin = __webpackgi_exports__2.M7$;
var __webpackgi_exports__VariationConfiguratorPlugin = __webpackgi_exports__2.ML4;
var __webpackgi_exports__Vector2 = __webpackgi_exports__2.FM8;
var __webpackgi_exports__Vector3 = __webpackgi_exports__2.Pa4;
var __webpackgi_exports__Vector4 = __webpackgi_exports__2.Ltg;
var __webpackgi_exports__VectorKeyframeTrack = __webpackgi_exports__2.yC1;
var __webpackgi_exports__VelocityBufferPlugin = __webpackgi_exports__2.lHq;
var __webpackgi_exports__VideoTexture = __webpackgi_exports__2.fO1;
var __webpackgi_exports__ViewerApp = __webpackgi_exports__2.oMA;
var __webpackgi_exports__ViewerState = __webpackgi_exports__2.JzW;
var __webpackgi_exports__VignettePlugin = __webpackgi_exports__2.QEt;
var __webpackgi_exports__VirtualCamerasPlugin = __webpackgi_exports__2.IFZ;
var __webpackgi_exports__WebGL1Renderer = __webpackgi_exports__2.b5g;
var __webpackgi_exports__WebGL3DRenderTarget = __webpackgi_exports__2.Ywn;
var __webpackgi_exports__WebGLArrayRenderTarget = __webpackgi_exports__2.GVz;
var __webpackgi_exports__WebGLCoordinateSystem = __webpackgi_exports__2._RZ;
var __webpackgi_exports__WebGLCubeRenderTarget = __webpackgi_exports__2.oAp;
var __webpackgi_exports__WebGLMultipleRenderTargets = __webpackgi_exports__2.kFz;
var __webpackgi_exports__WebGLRenderTarget = __webpackgi_exports__2.dd2;
var __webpackgi_exports__WebGLRenderer = __webpackgi_exports__2.CP7;
var __webpackgi_exports__WebGLUtils = __webpackgi_exports__2.fQK;
var __webpackgi_exports__WebGPUCoordinateSystem = __webpackgi_exports__2.JCZ;
var __webpackgi_exports__WebGiViewerElement = __webpackgi_exports__2.Wd$;
var __webpackgi_exports__WindowiseDialogPlugin = __webpackgi_exports__2.t1_;
var __webpackgi_exports__Wireframe = __webpackgi_exports__2.v27;
var __webpackgi_exports__WireframeGeometry = __webpackgi_exports__2.Uk6;
var __webpackgi_exports__WireframeGeometry2 = __webpackgi_exports__2.H7Z;
var __webpackgi_exports__WrapAroundEnding = __webpackgi_exports__2._sL;
var __webpackgi_exports__XAtlasPlugin = __webpackgi_exports__2.czO;
var __webpackgi_exports__ZeroCurvatureEnding = __webpackgi_exports__2.Pnf;
var __webpackgi_exports__ZeroFactor = __webpackgi_exports__2.c8b;
var __webpackgi_exports__ZeroSlopeEnding = __webpackgi_exports__2._lf;
var __webpackgi_exports__ZeroStencilOp = __webpackgi_exports__2.ad5;
var __webpackgi_exports__Zip = __webpackgi_exports__2.sZV;
var __webpackgi_exports__ZipDeflate = __webpackgi_exports__2.TfA;
var __webpackgi_exports__ZipLoader = __webpackgi_exports__2.sKX;
var __webpackgi_exports__ZipPassThrough = __webpackgi_exports__2.UdM;
var __webpackgi_exports__Zlib = __webpackgi_exports__2.P0y;
var __webpackgi_exports___SRGBAFormat = __webpackgi_exports__2.L_r;
var __webpackgi_exports__absMax = __webpackgi_exports__2.zC5;
var __webpackgi_exports__addBasePlugins = __webpackgi_exports__2.Bve;
var __webpackgi_exports__addBloomData = __webpackgi_exports__2.b5G;
var __webpackgi_exports__addDracoLoader = __webpackgi_exports__2.UeO;
var __webpackgi_exports__addEditorPlugins = __webpackgi_exports__2.qCx;
var __webpackgi_exports__addGLTFExporter = __webpackgi_exports__2.$nx;
var __webpackgi_exports__addGLTFLoader = __webpackgi_exports__2.Bk6;
var __webpackgi_exports__addLUTData = __webpackgi_exports__2.EER;
var __webpackgi_exports__addRGBELoader = __webpackgi_exports__2.y4l;
var __webpackgi_exports__addSSBevel = __webpackgi_exports__2.P39;
var __webpackgi_exports__aesGcmDecrypt = __webpackgi_exports__2.HI1;
var __webpackgi_exports__aesGcmEncrypt = __webpackgi_exports__2.ZYi;
var __webpackgi_exports__afterMain = __webpackgi_exports__2.wXW;
var __webpackgi_exports__afterRead = __webpackgi_exports__2.r5x;
var __webpackgi_exports__afterWrite = __webpackgi_exports__2.MSI;
var __webpackgi_exports__angle = __webpackgi_exports__2.EUu;
var __webpackgi_exports__animate = __webpackgi_exports__2.jtH;
var __webpackgi_exports__animateAsync = __webpackgi_exports__2.T0T;
var __webpackgi_exports__animateObject = __webpackgi_exports__2.gAb;
var __webpackgi_exports__animateSet = __webpackgi_exports__2.je_;
var __webpackgi_exports__animateTarget = __webpackgi_exports__2.wBP;
var __webpackgi_exports__anticipate = __webpackgi_exports__2.LU2;
var __webpackgi_exports__applyOffset = __webpackgi_exports__2.wQL;
var __webpackgi_exports__applyStyles = __webpackgi_exports__2.Zs7;
var __webpackgi_exports__arrayBufferToBase64 = __webpackgi_exports__2.sMc;
var __webpackgi_exports__arrow = __webpackgi_exports__2.x7s;
var __webpackgi_exports__attract = __webpackgi_exports__2.Mnd;
var __webpackgi_exports__attractExpo = __webpackgi_exports__2.A0_;
var __webpackgi_exports__auto = __webpackgi_exports__2.d73;
var __webpackgi_exports__autoCenterObject3D = __webpackgi_exports__2.HCD;
var __webpackgi_exports__autoGPUInstanceMeshes = __webpackgi_exports__2.YQ8;
var __webpackgi_exports__autoScaleObject3D = __webpackgi_exports__2.RG9;
var __webpackgi_exports__backIn = __webpackgi_exports__2.G2P;
var __webpackgi_exports__backInOut = __webpackgi_exports__2.XLf;
var __webpackgi_exports__backOut = __webpackgi_exports__2.CGN;
var __webpackgi_exports__base64ToArrayBuffer = __webpackgi_exports__2.RGi;
var __webpackgi_exports__basePlacements = __webpackgi_exports__2.mvg;
var __webpackgi_exports__basicMaterialPropList = __webpackgi_exports__2.Hiy;
var __webpackgi_exports__beforeMain = __webpackgi_exports__2.XMc;
var __webpackgi_exports__beforeRead = __webpackgi_exports__2.N7M;
var __webpackgi_exports__beforeWrite = __webpackgi_exports__2.iv;
var __webpackgi_exports__blobToDataURL = __webpackgi_exports__2.n55;
var __webpackgi_exports__bottom = __webpackgi_exports__2.IaC;
var __webpackgi_exports__bounceIn = __webpackgi_exports__2.h9t;
var __webpackgi_exports__bounceInOut = __webpackgi_exports__2.yDW;
var __webpackgi_exports__bounceOut = __webpackgi_exports__2.gJv;
var __webpackgi_exports__buildCSGMeshBSP = __webpackgi_exports__2.l$g;
var __webpackgi_exports__buildCSGMeshBVH = __webpackgi_exports__2.vQi;
var __webpackgi_exports__cLinearToRGBM = __webpackgi_exports__2.$MY;
var __webpackgi_exports__cRGBMToLinear = __webpackgi_exports__2.wJl;
var __webpackgi_exports__circIn = __webpackgi_exports__2.Z7Y;
var __webpackgi_exports__circInOut = __webpackgi_exports__2.X7D;
var __webpackgi_exports__circOut = __webpackgi_exports__2.BnX;
var __webpackgi_exports__clamp = __webpackgi_exports__2.uZ5;
var __webpackgi_exports__clippingParents = __webpackgi_exports__2.zVI;
var __webpackgi_exports__colorToDataUrl = __webpackgi_exports__2.Wz1;
var __webpackgi_exports__combineDofShader = __webpackgi_exports__2.DpF;
var __webpackgi_exports__compress = __webpackgi_exports__2.nNb;
var __webpackgi_exports__compressSync = __webpackgi_exports__2.cqZ;
var __webpackgi_exports__computeAverageGeometryNormal = __webpackgi_exports__2.pKN;
var __webpackgi_exports__computeEigenVectors = __webpackgi_exports__2.CN8;
var __webpackgi_exports__computeGeometryCenter = __webpackgi_exports__2.DdI;
var __webpackgi_exports__computeGeometrySize = __webpackgi_exports__2.rrX;
var __webpackgi_exports__computeMikkTSpaceTangents = __webpackgi_exports__2.uqj;
var __webpackgi_exports__computeMorphedAttributes = __webpackgi_exports__2.Z9P;
var __webpackgi_exports__computeOffsetMatrix = __webpackgi_exports__2.KlC;
var __webpackgi_exports__computeScreenSpaceBoundingBox = __webpackgi_exports__2.KVn;
var __webpackgi_exports__computeStyles = __webpackgi_exports__2.oau;
var __webpackgi_exports__copyMaterialUserData = __webpackgi_exports__2.aw9;
var __webpackgi_exports__copyObject3DUserData = __webpackgi_exports__2.Aap;
var __webpackgi_exports__copyProps = __webpackgi_exports__2.Dxg;
var __webpackgi_exports__copyTextureUserData = __webpackgi_exports__2.MjT;
var __webpackgi_exports__createAnticipate = __webpackgi_exports__2.F7Q;
var __webpackgi_exports__createAttractor = __webpackgi_exports__2.IFq;
var __webpackgi_exports__createBackIn = __webpackgi_exports__2.IJl;
var __webpackgi_exports__createCanvasElement = __webpackgi_exports__2.O5A;
var __webpackgi_exports__createDiv = __webpackgi_exports__2.wCn;
var __webpackgi_exports__createExpoIn = __webpackgi_exports__2.gGT;
var __webpackgi_exports__createGenericExtensionClass = __webpackgi_exports__2.hqj;
var __webpackgi_exports__createIFrameCSS3DObject = __webpackgi_exports__2.pEc;
var __webpackgi_exports__createImage = __webpackgi_exports__2.Bi6;
var __webpackgi_exports__createPopper = __webpackgi_exports__2.fi_;
var __webpackgi_exports__createPopperBase = __webpackgi_exports__2.TT;
var __webpackgi_exports__createPopperLite = __webpackgi_exports__2.q2Z;
var __webpackgi_exports__createRenderTargetKey = __webpackgi_exports__2.NyK;
var __webpackgi_exports__createScriptFromURL = __webpackgi_exports__2.bgu;
var __webpackgi_exports__createStyles = __webpackgi_exports__2.kcS;
var __webpackgi_exports__csgOperations = __webpackgi_exports__2.rRN;
var __webpackgi_exports__css = __webpackgi_exports__2.ivY;
var __webpackgi_exports__cubicBezier = __webpackgi_exports__2._s1;
var __webpackgi_exports__dataTextureFromColor = __webpackgi_exports__2._HO;
var __webpackgi_exports__dataTextureFromVec4 = __webpackgi_exports__2.tpL;
var __webpackgi_exports__decay = __webpackgi_exports__2.DMK;
var __webpackgi_exports__decompress = __webpackgi_exports__2.LjN;
var __webpackgi_exports__decompressSync = __webpackgi_exports__2.iFs;
var __webpackgi_exports__deepAccessObject = __webpackgi_exports__2.qTg;
var __webpackgi_exports__deepCloneAttribute = __webpackgi_exports__2.J4G;
var __webpackgi_exports__defaultPresets = __webpackgi_exports__2.Zj8;
var __webpackgi_exports__deflate = __webpackgi_exports__2.Wtl;
var __webpackgi_exports__deflateSync = __webpackgi_exports__2.DmK;
var __webpackgi_exports__degreesToRadians = __webpackgi_exports__2.Htt;
var __webpackgi_exports__deinterleaveAttribute = __webpackgi_exports__2.Nv0;
var __webpackgi_exports__deinterleaveGeometry = __webpackgi_exports__2.tCp;
var __webpackgi_exports__deserializeObject = __webpackgi_exports__2.Hx7;
var __webpackgi_exports__deserializers = __webpackgi_exports__2.imt;
var __webpackgi_exports__detectOverflow = __webpackgi_exports__2.US6;
var __webpackgi_exports__diamondMaterialPropList = __webpackgi_exports__2.vZs;
var __webpackgi_exports__distance = __webpackgi_exports__2.TE$;
var __webpackgi_exports__downloadBlob = __webpackgi_exports__2.lmu;
var __webpackgi_exports__downloadFile = __webpackgi_exports__2.SvO;
var __webpackgi_exports__easeIn = __webpackgi_exports__2.YQY;
var __webpackgi_exports__easeInOut = __webpackgi_exports__2.mZN;
var __webpackgi_exports__easeOut = __webpackgi_exports__2.VvG;
var __webpackgi_exports__embedUrlRefs = __webpackgi_exports__2.omp;
var __webpackgi_exports__end = __webpackgi_exports__2.utz;
var __webpackgi_exports__envMapBackground = __webpackgi_exports__2.TFV;
var __webpackgi_exports__escapeRegExp = __webpackgi_exports__2.hrz;
var __webpackgi_exports__estimateBytesUsed = __webpackgi_exports__2.H$s;
var __webpackgi_exports__eventListeners = __webpackgi_exports__2.JKM;
var __webpackgi_exports__extractAnimationKey = __webpackgi_exports__2.jZf;
var __webpackgi_exports__flattenUiConfig = __webpackgi_exports__2.RjL;
var __webpackgi_exports__flip = __webpackgi_exports__2.RRI;
var __webpackgi_exports__fontFormatExtensionMap = __webpackgi_exports__2.RUq;
var __webpackgi_exports__generateUiConfig = __webpackgi_exports__2._t4;
var __webpackgi_exports__generateUiFolder = __webpackgi_exports__2.YHh;
var __webpackgi_exports__getEncodingComponents = __webpackgi_exports__2.R8g;
var __webpackgi_exports__getFileHandle = __webpackgi_exports__2.f1L;
var __webpackgi_exports__getFilenameFromPath = __webpackgi_exports__2.Bbl;
var __webpackgi_exports__getKeyByValue = __webpackgi_exports__2.V9r;
var __webpackgi_exports__getNewFileHandle = __webpackgi_exports__2.a95;
var __webpackgi_exports__getOrCall = __webpackgi_exports__2.PZ2;
var __webpackgi_exports__getPropertyDescriptor = __webpackgi_exports__2.w7A;
var __webpackgi_exports__getTexelDecoding = __webpackgi_exports__2.N6S;
var __webpackgi_exports__getTexelDecoding2 = __webpackgi_exports__2.Uxp;
var __webpackgi_exports__getTexelDecodingFunction = __webpackgi_exports__2.tAz;
var __webpackgi_exports__getTexelEncoding = __webpackgi_exports__2.R$F;
var __webpackgi_exports__getTexelEncodingFunction = __webpackgi_exports__2.N33;
var __webpackgi_exports__getTextureColorSpaceFromMap = __webpackgi_exports__2.JFD;
var __webpackgi_exports__getTextureDataType = __webpackgi_exports__2.gw2;
var __webpackgi_exports__getTypedArray = __webpackgi_exports__2.rfc;
var __webpackgi_exports__getUrlQueryParam = __webpackgi_exports__2.wo6;
var __webpackgi_exports__glbEncryptionPreparser = __webpackgi_exports__2.V4T;
var __webpackgi_exports__glsl = __webpackgi_exports__2.H4P;
var __webpackgi_exports__gltfExporterMaterialsVariantsExtensionExport = __webpackgi_exports__2.NLp;
var __webpackgi_exports__gunzip = __webpackgi_exports__2.swA;
var __webpackgi_exports__gunzipSync = __webpackgi_exports__2._Z3;
var __webpackgi_exports__gzip = __webpackgi_exports__2.ivc;
var __webpackgi_exports__gzipSync = __webpackgi_exports__2.rZ1;
var __webpackgi_exports__hide = __webpackgi_exports__2.CpZ;
var __webpackgi_exports__html = __webpackgi_exports__2.dyc;
var __webpackgi_exports__htmlToCanvas = __webpackgi_exports__2.MxZ;
var __webpackgi_exports__htmlToPng = __webpackgi_exports__2.btp;
var __webpackgi_exports__htmlToSvg = __webpackgi_exports__2.mXy;
var __webpackgi_exports__iGeometryIgnoredUserData = __webpackgi_exports__2.Ej0;
var __webpackgi_exports__iMaterialIgnoredUserData = __webpackgi_exports__2.ep4;
var __webpackgi_exports__iModelIgnoredUserData = __webpackgi_exports__2.DQP;
var __webpackgi_exports__iTextureIgnoredUserData = __webpackgi_exports__2.VNr;
var __webpackgi_exports__imageBitmapToBase64 = __webpackgi_exports__2.V7q;
var __webpackgi_exports__imageDataToCanvas = __webpackgi_exports__2.hiB;
var __webpackgi_exports__imageToCanvas = __webpackgi_exports__2.zEk;
var __webpackgi_exports__imageUrlToImageData = __webpackgi_exports__2.qfq;
var __webpackgi_exports__includesAll = __webpackgi_exports__2.piB;
var __webpackgi_exports__inertia = __webpackgi_exports__2.IIc;
var __webpackgi_exports__inflate = __webpackgi_exports__2.rrF;
var __webpackgi_exports__inflateSync = __webpackgi_exports__2.naq;
var __webpackgi_exports__interleaveAttributes = __webpackgi_exports__2.zlD;
var __webpackgi_exports__interpolate = __webpackgi_exports__2.sXR;
var __webpackgi_exports__isAnimatableType = __webpackgi_exports__2.p5I;
var __webpackgi_exports__isPoint = __webpackgi_exports__2.wps;
var __webpackgi_exports__isPoint3D = __webpackgi_exports__2.wuo;
var __webpackgi_exports__isPropertyWritable = __webpackgi_exports__2.GpE;
var __webpackgi_exports__keyframes = __webpackgi_exports__2.F4b;
var __webpackgi_exports__khrMaterialsVariantsGLTF = __webpackgi_exports__2.NN$;
var __webpackgi_exports__left = __webpackgi_exports__2.t$v;
var __webpackgi_exports__lerpAngle = __webpackgi_exports__2.tdn;
var __webpackgi_exports__lerpAngle2 = __webpackgi_exports__2.Y9t;
var __webpackgi_exports__linear = __webpackgi_exports__2.GEo;
var __webpackgi_exports__longestCommonPrefix = __webpackgi_exports__2.GGm;
var __webpackgi_exports__main = __webpackgi_exports__2.DH3;
var __webpackgi_exports__makeColorSvg = __webpackgi_exports__2.uxM;
var __webpackgi_exports__makeColorSvgCircle = __webpackgi_exports__2.zH3;
var __webpackgi_exports__makeFilter = __webpackgi_exports__2.MLs;
var __webpackgi_exports__makeSamplerUi = __webpackgi_exports__2.xXG;
var __webpackgi_exports__makeSetterFor = __webpackgi_exports__2.YM4;
var __webpackgi_exports__makeTextSvg = __webpackgi_exports__2.iAx;
var __webpackgi_exports__matDefine = __webpackgi_exports__2.lDn;
var __webpackgi_exports__mergeAttributes = __webpackgi_exports__2.P1O;
var __webpackgi_exports__mergeBufferAttributes = __webpackgi_exports__2.iib;
var __webpackgi_exports__mergeBufferGeometries = __webpackgi_exports__2.qf5;
var __webpackgi_exports__mergeGeometries = __webpackgi_exports__2.n4s;
var __webpackgi_exports__mergeGroups = __webpackgi_exports__2.fr;
var __webpackgi_exports__mergeVertices = __webpackgi_exports__2.Z9s;
var __webpackgi_exports__mirrorEasing = __webpackgi_exports__2.oaQ;
var __webpackgi_exports__mix = __webpackgi_exports__2.CD7;
var __webpackgi_exports__mixColor = __webpackgi_exports__2.Rc0;
var __webpackgi_exports__mixComplex = __webpackgi_exports__2.iPG;
var __webpackgi_exports__mobileAndTabletCheck = __webpackgi_exports__2.TIc;
var __webpackgi_exports__modifierPhases = __webpackgi_exports__2.xsC;
var __webpackgi_exports__now = __webpackgi_exports__2.zOc;
var __webpackgi_exports__objectHasOwn = __webpackgi_exports__2.i8W;
var __webpackgi_exports__offset = __webpackgi_exports__2.r46;
var __webpackgi_exports__onChange = __webpackgi_exports__2.z2C;
var __webpackgi_exports__onChange2 = __webpackgi_exports__2.N4A;
var __webpackgi_exports__onChange3 = __webpackgi_exports__2.hjq;
var __webpackgi_exports__parseFileExtension = __webpackgi_exports__2._X$;
var __webpackgi_exports__patchShaderEncodingSupport = __webpackgi_exports__2._yn;
var __webpackgi_exports__pathJoin = __webpackgi_exports__2.Dyg;
var __webpackgi_exports__physicalMaterialPropList = __webpackgi_exports__2.cUc;
var __webpackgi_exports__pipe = __webpackgi_exports__2.zGw;
var __webpackgi_exports__placements = __webpackgi_exports__2.Ctq;
var __webpackgi_exports__pointFromVector = __webpackgi_exports__2.$ch;
var __webpackgi_exports__popper = __webpackgi_exports__2.k5b;
var __webpackgi_exports__popperGenerator = __webpackgi_exports__2.kZl;
var __webpackgi_exports__popperOffsets = __webpackgi_exports__2.OCg;
var __webpackgi_exports__prettyScrollbar = __webpackgi_exports__2.Kd3;
var __webpackgi_exports__preventOverflow = __webpackgi_exports__2.YjH;
var __webpackgi_exports__processViewer = __webpackgi_exports__2.Ui8;
var __webpackgi_exports__progress = __webpackgi_exports__2.YD2;
var __webpackgi_exports__radiansToDegrees = __webpackgi_exports__2.vi9;
var __webpackgi_exports__read = __webpackgi_exports__2.ij3;
var __webpackgi_exports__readFile = __webpackgi_exports__2.pJq;
var __webpackgi_exports__reference = __webpackgi_exports__2.YPW;
var __webpackgi_exports__remoteWorkerURL = __webpackgi_exports__2._tY;
var __webpackgi_exports__removeDuplicateGeometries = __webpackgi_exports__2.Bg1;
var __webpackgi_exports__replaceAll = __webpackgi_exports__2.kon;
var __webpackgi_exports__reverseEasing = __webpackgi_exports__2.M3g;
var __webpackgi_exports__right = __webpackgi_exports__2.F2z;
var __webpackgi_exports__rotateDuplicatedMesh = __webpackgi_exports__2.pJF;
var __webpackgi_exports__sRGBEncoding = __webpackgi_exports__2.knz;
var __webpackgi_exports__safeSetProperty = __webpackgi_exports__2.Ejo;
var __webpackgi_exports__serializable = __webpackgi_exports__2.BgY;
var __webpackgi_exports__serialize = __webpackgi_exports__2.qCG;
var __webpackgi_exports__serializeObject = __webpackgi_exports__2.HD9;
var __webpackgi_exports__serializeTextureInExtras = __webpackgi_exports__2.Rgz;
var __webpackgi_exports__serializers = __webpackgi_exports__2.fEB;
var __webpackgi_exports__setMeshGeometry = __webpackgi_exports__2.Udc;
var __webpackgi_exports__setMeshMaterial = __webpackgi_exports__2.ZQg;
var __webpackgi_exports__setThreeRendererMode = __webpackgi_exports__2.ofC;
var __webpackgi_exports__setUrlQueryParam = __webpackgi_exports__2.yRy;
var __webpackgi_exports__setupCoreWebGiViewer = __webpackgi_exports__2._NL;
var __webpackgi_exports__setupIModel = __webpackgi_exports__2.LCA;
var __webpackgi_exports__setupModesStyles = __webpackgi_exports__2.Sy1;
var __webpackgi_exports__setupModesUi = __webpackgi_exports__2.Vs_;
var __webpackgi_exports__setupObject3dModel = __webpackgi_exports__2.j1w;
var __webpackgi_exports__setupSandboxWebGiEditor = __webpackgi_exports__2.i8J;
var __webpackgi_exports__shaderReplaceString = __webpackgi_exports__2.p7C;
var __webpackgi_exports__sign2 = __webpackgi_exports__2.Y8s;
var __webpackgi_exports__slerp = __webpackgi_exports__2.ZAS;
var __webpackgi_exports__smooth = __webpackgi_exports__2.ipH;
var __webpackgi_exports__smoothFrame = __webpackgi_exports__2.$TF;
var __webpackgi_exports__snap = __webpackgi_exports__2.uZI;
var __webpackgi_exports__snapObject = __webpackgi_exports__2.VWG;
var __webpackgi_exports__sphericalFromObject = __webpackgi_exports__2.pQ7;
var __webpackgi_exports__spring = __webpackgi_exports__2.STw;
var __webpackgi_exports__standardMaterialPropList = __webpackgi_exports__2.jc8;
var __webpackgi_exports__start = __webpackgi_exports__2.BL_;
var __webpackgi_exports__steps = __webpackgi_exports__2.S6;
var __webpackgi_exports__strFromU8 = __webpackgi_exports__2.T8U;
var __webpackgi_exports__strToU8 = __webpackgi_exports__2.TD6;
var __webpackgi_exports__supportsRequestStreams = __webpackgi_exports__2.BTW;
var __webpackgi_exports__svgToCanvas = __webpackgi_exports__2.akS;
var __webpackgi_exports__svgToPng = __webpackgi_exports__2.QKE;
var __webpackgi_exports__svgUrl = __webpackgi_exports__2.dKx;
var __webpackgi_exports__texImageToCanvas = __webpackgi_exports__2.doP;
var __webpackgi_exports__textureDataToImageData = __webpackgi_exports__2.$jA;
var __webpackgi_exports__textureToCanvas = __webpackgi_exports__2.T99;
var __webpackgi_exports__textureToDataUrl = __webpackgi_exports__2.LJS;
var __webpackgi_exports__timeout = __webpackgi_exports__2.VsW;
var __webpackgi_exports__toCreasedNormals = __webpackgi_exports__2.LZE;
var __webpackgi_exports__toDecimal = __webpackgi_exports__2.YMc;
var __webpackgi_exports__toIndexedGeometry = __webpackgi_exports__2.aPg;
var __webpackgi_exports__toTitleCase = __webpackgi_exports__2.LFn;
var __webpackgi_exports__toTrianglesDrawMode = __webpackgi_exports__2.VsX;
var __webpackgi_exports__top = __webpackgi_exports__2.wey;
var __webpackgi_exports__uiButton = __webpackgi_exports__2.MaE;
var __webpackgi_exports__uiColor = __webpackgi_exports__2.s4x;
var __webpackgi_exports__uiConfig = __webpackgi_exports__2.FJA;
var __webpackgi_exports__uiDropdown = __webpackgi_exports__2.vIA;
var __webpackgi_exports__uiFolder = __webpackgi_exports__2.Spv;
var __webpackgi_exports__uiImage = __webpackgi_exports__2.w8l;
var __webpackgi_exports__uiInput = __webpackgi_exports__2.riG;
var __webpackgi_exports__uiMonitor = __webpackgi_exports__2.Kbh;
var __webpackgi_exports__uiPanel = __webpackgi_exports__2.BFq;
var __webpackgi_exports__uiSlider = __webpackgi_exports__2.t8K;
var __webpackgi_exports__uiToggle = __webpackgi_exports__2.Q7n;
var __webpackgi_exports__uiVector = __webpackgi_exports__2.KGF;
var __webpackgi_exports__uniform = __webpackgi_exports__2.e5;
var __webpackgi_exports__unzip = __webpackgi_exports__2.Rik;
var __webpackgi_exports__unzipSync = __webpackgi_exports__2.GZo;
var __webpackgi_exports__unzlib = __webpackgi_exports__2.Bds;
var __webpackgi_exports__unzlibSync = __webpackgi_exports__2.HTu;
var __webpackgi_exports__uploadFile = __webpackgi_exports__2.cTq;
var __webpackgi_exports__vLinearToRGBM = __webpackgi_exports__2.X_Y;
var __webpackgi_exports__vRGBMToLinear = __webpackgi_exports__2.dA8;
var __webpackgi_exports__valueToUiType = __webpackgi_exports__2.NSm;
var __webpackgi_exports__variationPlacements = __webpackgi_exports__2.bwS;
var __webpackgi_exports__velocityPerFrame = __webpackgi_exports__2.Lks;
var __webpackgi_exports__velocityPerSecond = __webpackgi_exports__2.Rvq;
var __webpackgi_exports__verifyPermission = __webpackgi_exports__2.P4F;
var __webpackgi_exports__viewerGLTFExtension = __webpackgi_exports__2.Pd0;
var __webpackgi_exports__viewport = __webpackgi_exports__2.Pjo;
var __webpackgi_exports__webgiLightExtrasExtension = __webpackgi_exports__2.Tum;
var __webpackgi_exports__webgiMaterialExtrasExtension = __webpackgi_exports__2.dRH;
var __webpackgi_exports__webgiObject3DExtrasExtension = __webpackgi_exports__2.RX0;
var __webpackgi_exports__wrap = __webpackgi_exports__2.reQ;
var __webpackgi_exports__write = __webpackgi_exports__2.cWm;
var __webpackgi_exports__writeFile = __webpackgi_exports__2.NC9;
var __webpackgi_exports__zip = __webpackgi_exports__2.$Re;
var __webpackgi_exports__zipSync = __webpackgi_exports__2.Xo9;
var __webpackgi_exports__zlib = __webpackgi_exports__2.LNO;
var __webpackgi_exports__zlibSync = __webpackgi_exports__2.iZP;
export {
  __webpackgi_exports__AAssetManagerProcessStatePlugin as AAssetManagerProcessStatePlugin,
  __webpackgi_exports__ACESFilmicToneMapping as ACESFilmicToneMapping,
  __webpackgi_exports__ACameraControlsPlugin as ACameraControlsPlugin,
  __webpackgi_exports__ACanvasRecorder as ACanvasRecorder,
  __webpackgi_exports__AMaterialManager as AMaterialManager,
  __webpackgi_exports__ARPlacementBox as ARPlacementBox,
  __webpackgi_exports__ARPlugin as ARPlugin,
  __webpackgi_exports__ARTouchInputHelper as ARTouchInputHelper,
  __webpackgi_exports__AShaderMaterial2 as AShaderMaterial2,
  __webpackgi_exports__AViewerPlugin as AViewerPlugin,
  __webpackgi_exports__AWSClientPlugin as AWSClientPlugin,
  __webpackgi_exports__AddBlendPass as AddBlendPass,
  __webpackgi_exports__AddEquation as AddEquation,
  __webpackgi_exports__AddOperation as AddOperation,
  __webpackgi_exports__AdditiveAnimationBlendMode as AdditiveAnimationBlendMode,
  __webpackgi_exports__AdditiveBlending as AdditiveBlending,
  __webpackgi_exports__AlphaFormat as AlphaFormat,
  __webpackgi_exports__AlwaysCompare as AlwaysCompare,
  __webpackgi_exports__AlwaysDepth as AlwaysDepth,
  __webpackgi_exports__AlwaysStencilFunc as AlwaysStencilFunc,
  __webpackgi_exports__AmbientLight as AmbientLight,
  __webpackgi_exports__AmbientLight2 as AmbientLight2,
  __webpackgi_exports__AmbientLightProbe as AmbientLightProbe,
  __webpackgi_exports__AnimationAction as AnimationAction,
  __webpackgi_exports__AnimationClip as AnimationClip,
  __webpackgi_exports__AnimationLoader as AnimationLoader,
  __webpackgi_exports__AnimationMixer as AnimationMixer,
  __webpackgi_exports__AnimationObjectGroup as AnimationObjectGroup,
  __webpackgi_exports__AnimationUtils as AnimationUtils,
  __webpackgi_exports__AnisotropyPlugin as AnisotropyPlugin,
  __webpackgi_exports__ArcCurve as ArcCurve,
  __webpackgi_exports__ArrayCamera as ArrayCamera,
  __webpackgi_exports__ArrowHelper as ArrowHelper,
  __webpackgi_exports__AssetExporter as AssetExporter,
  __webpackgi_exports__AssetExporterPlugin as AssetExporterPlugin,
  __webpackgi_exports__AssetImporter as AssetImporter,
  __webpackgi_exports__AssetManagerBasicPopupPlugin as AssetManagerBasicPopupPlugin,
  __webpackgi_exports__AssetManagerLoadingBarPlugin as AssetManagerLoadingBarPlugin,
  __webpackgi_exports__AssetManagerPlugin as AssetManagerPlugin,
  __webpackgi_exports__AsyncCompress as AsyncCompress,
  __webpackgi_exports__AsyncDecompress as AsyncDecompress,
  __webpackgi_exports__AsyncDeflate as AsyncDeflate,
  __webpackgi_exports__AsyncGunzip as AsyncGunzip,
  __webpackgi_exports__AsyncGzip as AsyncGzip,
  __webpackgi_exports__AsyncInflate as AsyncInflate,
  __webpackgi_exports__AsyncUnzipInflate as AsyncUnzipInflate,
  __webpackgi_exports__AsyncUnzlib as AsyncUnzlib,
  __webpackgi_exports__AsyncZipDeflate as AsyncZipDeflate,
  __webpackgi_exports__AsyncZlib as AsyncZlib,
  __webpackgi_exports__Audio as Audio,
  __webpackgi_exports__AudioAnalyser as AudioAnalyser,
  __webpackgi_exports__AudioContext as AudioContext,
  __webpackgi_exports__AudioListener as AudioListener,
  __webpackgi_exports__AudioLoader as AudioLoader,
  __webpackgi_exports__AxesHelper as AxesHelper,
  __webpackgi_exports__BackSide as BackSide,
  __webpackgi_exports__BackgroundPresetGroup as BackgroundPresetGroup,
  __webpackgi_exports__BaseGroundPlugin as BaseGroundPlugin,
  __webpackgi_exports__BaseRenderer as BaseRenderer,
  __webpackgi_exports__BasicDepthPacking as BasicDepthPacking,
  __webpackgi_exports__BasicShadowMap as BasicShadowMap,
  __webpackgi_exports__BeringRingAnimation as BeringRingAnimation,
  __webpackgi_exports__BlobLoader as BlobLoader,
  __webpackgi_exports__BloomPlugin as BloomPlugin,
  __webpackgi_exports__Bone as Bone,
  __webpackgi_exports__BooleanKeyframeTrack as BooleanKeyframeTrack,
  __webpackgi_exports__Box2 as Box2,
  __webpackgi_exports__Box3 as Box3,
  __webpackgi_exports__Box3B as Box3B,
  __webpackgi_exports__Box3Helper as Box3Helper,
  __webpackgi_exports__BoxBufferGeometry as BoxBufferGeometry,
  __webpackgi_exports__BoxGeometry as BoxGeometry,
  __webpackgi_exports__BoxHelper as BoxHelper,
  __webpackgi_exports__BoxSelectionWidget as BoxSelectionWidget,
  __webpackgi_exports__BufferAttribute as BufferAttribute,
  __webpackgi_exports__BufferGeometry as BufferGeometry,
  __webpackgi_exports__BufferGeometryLoader as BufferGeometryLoader,
  __webpackgi_exports__ByteType as ByteType,
  __webpackgi_exports__CSGPluginBSP as CSGPluginBSP,
  __webpackgi_exports__CSGPluginBVH as CSGPluginBVH,
  __webpackgi_exports__CSGPluginBase as CSGPluginBase,
  __webpackgi_exports__CSS3DRendererPlugin as CSS3DRendererPlugin,
  __webpackgi_exports__Cache as Cache,
  __webpackgi_exports__Camera as Camera,
  __webpackgi_exports__CameraController as CameraController,
  __webpackgi_exports__CameraHelper as CameraHelper,
  __webpackgi_exports__CameraUiPlugin as CameraUiPlugin,
  __webpackgi_exports__CameraView as CameraView,
  __webpackgi_exports__CameraViewControlPlugin as CameraViewControlPlugin,
  __webpackgi_exports__CameraViewPlugin as CameraViewPlugin,
  __webpackgi_exports__CannonPhysicsPlugin as CannonPhysicsPlugin,
  __webpackgi_exports__CanvasMediaRecorder as CanvasMediaRecorder,
  __webpackgi_exports__CanvasRecorder as CanvasRecorder,
  __webpackgi_exports__CanvasRecorderPlugin as CanvasRecorderPlugin,
  __webpackgi_exports__CanvasSnipper as CanvasSnipper,
  __webpackgi_exports__CanvasSnipperPlugin as CanvasSnipperPlugin,
  __webpackgi_exports__CanvasTexture as CanvasTexture,
  __webpackgi_exports__CapsuleBufferGeometry as CapsuleBufferGeometry,
  __webpackgi_exports__CapsuleGeometry as CapsuleGeometry,
  __webpackgi_exports__CatmullRomCurve3 as CatmullRomCurve3,
  __webpackgi_exports__ChromaticAberrationPlugin as ChromaticAberrationPlugin,
  __webpackgi_exports__CineonToneMapping as CineonToneMapping,
  __webpackgi_exports__CircleBufferGeometry as CircleBufferGeometry,
  __webpackgi_exports__CircleGeometry as CircleGeometry,
  __webpackgi_exports__ClampToEdgeWrapping as ClampToEdgeWrapping,
  __webpackgi_exports__ClearcoatTintPlugin as ClearcoatTintPlugin,
  __webpackgi_exports__Clock as Clock,
  __webpackgi_exports__Color as Color,
  __webpackgi_exports__ColorKeyframeTrack as ColorKeyframeTrack,
  __webpackgi_exports__ColorManagement as ColorManagement,
  __webpackgi_exports__CombinedPostPlugin as CombinedPostPlugin,
  __webpackgi_exports__Compress as Compress,
  __webpackgi_exports__CompressedArrayTexture as CompressedArrayTexture,
  __webpackgi_exports__CompressedTexture as CompressedTexture,
  __webpackgi_exports__CompressedTextureLoader as CompressedTextureLoader,
  __webpackgi_exports__ConeBufferGeometry as ConeBufferGeometry,
  __webpackgi_exports__ConeGeometry as ConeGeometry,
  __webpackgi_exports__ContactShadowGroundPlugin as ContactShadowGroundPlugin,
  __webpackgi_exports__CoreEditorApp as CoreEditorApp,
  __webpackgi_exports__CoreViewerApp as CoreViewerApp,
  __webpackgi_exports__CubeCamera as CubeCamera,
  __webpackgi_exports__CubeNormalsCaptureHelper as CubeNormalsCaptureHelper,
  __webpackgi_exports__CubeReflectionMapping as CubeReflectionMapping,
  __webpackgi_exports__CubeRefractionMapping as CubeRefractionMapping,
  __webpackgi_exports__CubeTexture as CubeTexture,
  __webpackgi_exports__CubeTextureLoader as CubeTextureLoader,
  __webpackgi_exports__CubeUVReflectionMapping as CubeUVReflectionMapping,
  __webpackgi_exports__CubicBezierCurve as CubicBezierCurve,
  __webpackgi_exports__CubicBezierCurve3 as CubicBezierCurve3,
  __webpackgi_exports__CubicInterpolant as CubicInterpolant,
  __webpackgi_exports__CullFaceBack as CullFaceBack,
  __webpackgi_exports__CullFaceFront as CullFaceFront,
  __webpackgi_exports__CullFaceFrontBack as CullFaceFrontBack,
  __webpackgi_exports__CullFaceNone as CullFaceNone,
  __webpackgi_exports__Curve as Curve,
  __webpackgi_exports__CurvePath as CurvePath,
  __webpackgi_exports__CustomAnimationHelper as CustomAnimationHelper,
  __webpackgi_exports__CustomAnimationHelperPlugin as CustomAnimationHelperPlugin,
  __webpackgi_exports__CustomBlending as CustomBlending,
  __webpackgi_exports__CustomBumpMapPlugin as CustomBumpMapPlugin,
  __webpackgi_exports__CustomToneMapping as CustomToneMapping,
  __webpackgi_exports__CylinderBufferGeometry as CylinderBufferGeometry,
  __webpackgi_exports__CylinderGeometry as CylinderGeometry,
  __webpackgi_exports__Cylindrical as Cylindrical,
  __webpackgi_exports__DRACOLoader2 as DRACOLoader2,
  __webpackgi_exports__Damper as Damper,
  __webpackgi_exports__Data3DTexture as Data3DTexture,
  __webpackgi_exports__DataArrayTexture as DataArrayTexture,
  __webpackgi_exports__DataTexture as DataTexture,
  __webpackgi_exports__DataTextureLoader as DataTextureLoader,
  __webpackgi_exports__DataUrlLoader as DataUrlLoader,
  __webpackgi_exports__DataUtils as DataUtils,
  __webpackgi_exports__DebugPlugin as DebugPlugin,
  __webpackgi_exports__DecodeUTF8 as DecodeUTF8,
  __webpackgi_exports__Decompress as Decompress,
  __webpackgi_exports__DecrementStencilOp as DecrementStencilOp,
  __webpackgi_exports__DecrementWrapStencilOp as DecrementWrapStencilOp,
  __webpackgi_exports__DefaultLoadingManager as DefaultLoadingManager,
  __webpackgi_exports__Deflate as Deflate,
  __webpackgi_exports__DepthFormat as DepthFormat,
  __webpackgi_exports__DepthOfFieldPass as DepthOfFieldPass,
  __webpackgi_exports__DepthOfFieldPlugin as DepthOfFieldPlugin,
  __webpackgi_exports__DepthStencilFormat as DepthStencilFormat,
  __webpackgi_exports__DepthTexture as DepthTexture,
  __webpackgi_exports__DeviceOrientationControls2 as DeviceOrientationControls2,
  __webpackgi_exports__DeviceOrientationControlsPlugin as DeviceOrientationControlsPlugin,
  __webpackgi_exports__DiamondMaterial as DiamondMaterial,
  __webpackgi_exports__DiamondPlugin as DiamondPlugin,
  __webpackgi_exports__DirectionalLight as DirectionalLight,
  __webpackgi_exports__DirectionalLight2 as DirectionalLight2,
  __webpackgi_exports__DirectionalLightHelper as DirectionalLightHelper,
  __webpackgi_exports__DiscreteInterpolant as DiscreteInterpolant,
  __webpackgi_exports__DisplayP3ColorSpace as DisplayP3ColorSpace,
  __webpackgi_exports__DodecahedronBufferGeometry as DodecahedronBufferGeometry,
  __webpackgi_exports__DodecahedronGeometry as DodecahedronGeometry,
  __webpackgi_exports__DoubleSide as DoubleSide,
  __webpackgi_exports__Dropzone as Dropzone,
  __webpackgi_exports__DropzonePlugin as DropzonePlugin,
  __webpackgi_exports__DstAlphaFactor as DstAlphaFactor,
  __webpackgi_exports__DstColorFactor as DstColorFactor,
  __webpackgi_exports__DynamicCopyUsage as DynamicCopyUsage,
  __webpackgi_exports__DynamicDrawUsage as DynamicDrawUsage,
  __webpackgi_exports__DynamicReadUsage as DynamicReadUsage,
  __webpackgi_exports__EXRExporter2 as EXRExporter2,
  __webpackgi_exports__EXRLoadPlugin as EXRLoadPlugin,
  __webpackgi_exports__EasingFunctions as EasingFunctions,
  __webpackgi_exports__EdgesGeometry as EdgesGeometry,
  __webpackgi_exports__EffectComposer2 as EffectComposer2,
  __webpackgi_exports__EllipseCurve as EllipseCurve,
  __webpackgi_exports__EllipseCurve3D as EllipseCurve3D,
  __webpackgi_exports__EncodeUTF8 as EncodeUTF8,
  __webpackgi_exports__EncoderMethod as EncoderMethod,
  __webpackgi_exports__EnvironmentPresetGroup as EnvironmentPresetGroup,
  __webpackgi_exports__EqualCompare as EqualCompare,
  __webpackgi_exports__EqualDepth as EqualDepth,
  __webpackgi_exports__EqualStencilFunc as EqualStencilFunc,
  __webpackgi_exports__EquirectangularReflectionMapping as EquirectangularReflectionMapping,
  __webpackgi_exports__EquirectangularRefractionMapping as EquirectangularRefractionMapping,
  __webpackgi_exports__Euler as Euler,
  __webpackgi_exports__EventDispatcher as EventDispatcher,
  __webpackgi_exports__ExtrasUiPlugin as ExtrasUiPlugin,
  __webpackgi_exports__ExtrudeBufferGeometry as ExtrudeBufferGeometry,
  __webpackgi_exports__ExtrudeGeometry as ExtrudeGeometry,
  __webpackgi_exports__FBXLoadPlugin as FBXLoadPlugin,
  __webpackgi_exports__FFMPEGRecorder as FFMPEGRecorder,
  __webpackgi_exports__FSShadowMaterial as FSShadowMaterial,
  __webpackgi_exports__FileLoader as FileLoader,
  __webpackgi_exports__FileTransferPlugin as FileTransferPlugin,
  __webpackgi_exports__FilmicGrainPlugin as FilmicGrainPlugin,
  __webpackgi_exports__FirstPersonControls2 as FirstPersonControls2,
  __webpackgi_exports__FirstPersonControlsPlugin as FirstPersonControlsPlugin,
  __webpackgi_exports__Float16BufferAttribute as Float16BufferAttribute,
  __webpackgi_exports__Float32BufferAttribute as Float32BufferAttribute,
  __webpackgi_exports__Float64BufferAttribute as Float64BufferAttribute,
  __webpackgi_exports__FloatType as FloatType,
  __webpackgi_exports__Fog as Fog,
  __webpackgi_exports__FogExp2 as FogExp2,
  __webpackgi_exports__FragmentClippingExtensionPlugin as FragmentClippingExtensionPlugin,
  __webpackgi_exports__FragmentClippingMode as FragmentClippingMode,
  __webpackgi_exports__FrameFadePlugin as FrameFadePlugin,
  __webpackgi_exports__FramebufferTexture as FramebufferTexture,
  __webpackgi_exports__FrontSide as FrontSide,
  __webpackgi_exports__Frustum as Frustum,
  __webpackgi_exports__FullScreenPlugin as FullScreenPlugin,
  __webpackgi_exports__GBufferPlugin as GBufferPlugin,
  __webpackgi_exports__GLBufferAttribute as GLBufferAttribute,
  __webpackgi_exports__GLSL1 as GLSL1,
  __webpackgi_exports__GLSL3 as GLSL3,
  __webpackgi_exports__GLTFAnimationPlugin as GLTFAnimationPlugin,
  __webpackgi_exports__GLTFDracoExportPlugin as GLTFDracoExportPlugin,
  __webpackgi_exports__GLTFDracoExporter as GLTFDracoExporter,
  __webpackgi_exports__GLTFExporter2 as GLTFExporter2,
  __webpackgi_exports__GLTFExporterMaterialsVariantsExtensionExport as GLTFExporterMaterialsVariantsExtensionExport,
  __webpackgi_exports__GLTFKHRMaterialVariantsPlugin as GLTFKHRMaterialVariantsPlugin,
  __webpackgi_exports__GLTFLoader2 as GLTFLoader2,
  __webpackgi_exports__GLTFMaterialsAlphaMapExtensionName as GLTFMaterialsAlphaMapExtensionName,
  __webpackgi_exports__GLTFMaterialsBumpMapExtensionName as GLTFMaterialsBumpMapExtensionName,
  __webpackgi_exports__GLTFMaterialsDisplacementMapExtensionName as GLTFMaterialsDisplacementMapExtensionName,
  __webpackgi_exports__GLTFMaterialsLightMapExtensionName as GLTFMaterialsLightMapExtensionName,
  __webpackgi_exports__GLTFMaterialsVariantsExtensionImport as GLTFMaterialsVariantsExtensionImport,
  __webpackgi_exports__GLTFMeshGpuInstancingExporter as GLTFMeshGpuInstancingExporter,
  __webpackgi_exports__GLTFMeshOptPlugin as GLTFMeshOptPlugin,
  __webpackgi_exports__GLTFWriter2 as GLTFWriter2,
  __webpackgi_exports__GammaCorrectionExtension as GammaCorrectionExtension,
  __webpackgi_exports__GammaCorrectionPlugin as GammaCorrectionPlugin,
  __webpackgi_exports__GemEnvironmentPresetGroup as GemEnvironmentPresetGroup,
  __webpackgi_exports__GenericBlendTexturePass as GenericBlendTexturePass,
  __webpackgi_exports__GenericFilterPlugin as GenericFilterPlugin,
  __webpackgi_exports__GeometryGeneratorPlugin as GeometryGeneratorPlugin,
  __webpackgi_exports__GreaterCompare as GreaterCompare,
  __webpackgi_exports__GreaterDepth as GreaterDepth,
  __webpackgi_exports__GreaterEqualCompare as GreaterEqualCompare,
  __webpackgi_exports__GreaterEqualDepth as GreaterEqualDepth,
  __webpackgi_exports__GreaterEqualStencilFunc as GreaterEqualStencilFunc,
  __webpackgi_exports__GreaterStencilFunc as GreaterStencilFunc,
  __webpackgi_exports__GridHelper as GridHelper,
  __webpackgi_exports__GroundPlugin as GroundPlugin,
  __webpackgi_exports__Group as Group,
  __webpackgi_exports__Gunzip as Gunzip,
  __webpackgi_exports__GyroInputDevice as GyroInputDevice,
  __webpackgi_exports__Gzip as Gzip,
  __webpackgi_exports__HDRiGroundPlugin as HDRiGroundPlugin,
  __webpackgi_exports__HalfFloatType as HalfFloatType,
  __webpackgi_exports__HemisphereLight as HemisphereLight,
  __webpackgi_exports__HemisphereLightHelper as HemisphereLightHelper,
  __webpackgi_exports__HemisphereLightProbe as HemisphereLightProbe,
  __webpackgi_exports__HierarchyUiPlugin as HierarchyUiPlugin,
  __webpackgi_exports__IcosahedronBufferGeometry as IcosahedronBufferGeometry,
  __webpackgi_exports__IcosahedronGeometry as IcosahedronGeometry,
  __webpackgi_exports__ImageBitmapLoader as ImageBitmapLoader,
  __webpackgi_exports__ImageLoader as ImageLoader,
  __webpackgi_exports__ImageSequenceRecorder as ImageSequenceRecorder,
  __webpackgi_exports__ImageUtils as ImageUtils,
  __webpackgi_exports__Importer as Importer,
  __webpackgi_exports__IncrementStencilOp as IncrementStencilOp,
  __webpackgi_exports__IncrementWrapStencilOp as IncrementWrapStencilOp,
  __webpackgi_exports__Inflate as Inflate,
  __webpackgi_exports__InstancedBufferAttribute as InstancedBufferAttribute,
  __webpackgi_exports__InstancedBufferGeometry as InstancedBufferGeometry,
  __webpackgi_exports__InstancedInterleavedBuffer as InstancedInterleavedBuffer,
  __webpackgi_exports__InstancedMesh as InstancedMesh,
  __webpackgi_exports__Int16BufferAttribute as Int16BufferAttribute,
  __webpackgi_exports__Int32BufferAttribute as Int32BufferAttribute,
  __webpackgi_exports__Int8BufferAttribute as Int8BufferAttribute,
  __webpackgi_exports__IntType as IntType,
  __webpackgi_exports__InteractionPromptPlugin as InteractionPromptPlugin,
  __webpackgi_exports__InterleavedBuffer as InterleavedBuffer,
  __webpackgi_exports__InterleavedBufferAttribute as InterleavedBufferAttribute,
  __webpackgi_exports__Interpolant as Interpolant,
  __webpackgi_exports__InterpolateDiscrete as InterpolateDiscrete,
  __webpackgi_exports__InterpolateLinear as InterpolateLinear,
  __webpackgi_exports__InterpolateSmooth as InterpolateSmooth,
  __webpackgi_exports__InvertStencilOp as InvertStencilOp,
  __webpackgi_exports__KHR_TEXTURE_BASISU as KHR_TEXTURE_BASISU,
  __webpackgi_exports__KTX2LoadPlugin as KTX2LoadPlugin,
  __webpackgi_exports__KTXLoadPlugin as KTXLoadPlugin,
  __webpackgi_exports__KeepStencilOp as KeepStencilOp,
  __webpackgi_exports__KeyframeTrack as KeyframeTrack,
  __webpackgi_exports__LOD as LOD,
  __webpackgi_exports__LUTPlugin as LUTPlugin,
  __webpackgi_exports__LatheBufferGeometry as LatheBufferGeometry,
  __webpackgi_exports__LatheGeometry as LatheGeometry,
  __webpackgi_exports__LayeredMaterialPlugin as LayeredMaterialPlugin,
  __webpackgi_exports__Layers as Layers,
  __webpackgi_exports__LessCompare as LessCompare,
  __webpackgi_exports__LessDepth as LessDepth,
  __webpackgi_exports__LessEqualCompare as LessEqualCompare,
  __webpackgi_exports__LessEqualDepth as LessEqualDepth,
  __webpackgi_exports__LessEqualStencilFunc as LessEqualStencilFunc,
  __webpackgi_exports__LessStencilFunc as LessStencilFunc,
  __webpackgi_exports__Light as Light,
  __webpackgi_exports__LightProbe as LightProbe,
  __webpackgi_exports__LightsUiPlugin as LightsUiPlugin,
  __webpackgi_exports__Line as Line,
  __webpackgi_exports__Line2 as Line2,
  __webpackgi_exports__Line3 as Line3,
  __webpackgi_exports__LineBasicMaterial as LineBasicMaterial,
  __webpackgi_exports__LineCurve as LineCurve,
  __webpackgi_exports__LineCurve3 as LineCurve3,
  __webpackgi_exports__LineDashedMaterial as LineDashedMaterial,
  __webpackgi_exports__LineGeometry as LineGeometry,
  __webpackgi_exports__LineLoop as LineLoop,
  __webpackgi_exports__LineMaterial as LineMaterial,
  __webpackgi_exports__LineSegments as LineSegments,
  __webpackgi_exports__LineSegments2 as LineSegments2,
  __webpackgi_exports__LineSegmentsGeometry as LineSegmentsGeometry,
  __webpackgi_exports__LinearEncoding as LinearEncoding,
  __webpackgi_exports__LinearFilter as LinearFilter,
  __webpackgi_exports__LinearInterpolant as LinearInterpolant,
  __webpackgi_exports__LinearMipMapLinearFilter as LinearMipMapLinearFilter,
  __webpackgi_exports__LinearMipMapNearestFilter as LinearMipMapNearestFilter,
  __webpackgi_exports__LinearMipmapLinearFilter as LinearMipmapLinearFilter,
  __webpackgi_exports__LinearMipmapNearestFilter as LinearMipmapNearestFilter,
  __webpackgi_exports__LinearSRGBColorSpace as LinearSRGBColorSpace,
  __webpackgi_exports__LinearToneMapping as LinearToneMapping,
  __webpackgi_exports__Loader as Loader,
  __webpackgi_exports__LoaderUtils as LoaderUtils,
  __webpackgi_exports__LoadingManager as LoadingManager,
  __webpackgi_exports__LoadingScreenPlugin as LoadingScreenPlugin,
  __webpackgi_exports__LoopOnce as LoopOnce,
  __webpackgi_exports__LoopPingPong as LoopPingPong,
  __webpackgi_exports__LoopRepeat as LoopRepeat,
  __webpackgi_exports__LuminanceAlphaFormat as LuminanceAlphaFormat,
  __webpackgi_exports__LuminanceFormat as LuminanceFormat,
  __webpackgi_exports__MOUSE as MOUSE,
  __webpackgi_exports__MTLLoader2 as MTLLoader2,
  __webpackgi_exports__Material as Material,
  __webpackgi_exports__MaterialConfiguratorBasePlugin as MaterialConfiguratorBasePlugin,
  __webpackgi_exports__MaterialConfiguratorPlugin as MaterialConfiguratorPlugin,
  __webpackgi_exports__MaterialExtender as MaterialExtender,
  __webpackgi_exports__MaterialLibPresetGroupPresetGroup as MaterialLibPresetGroupPresetGroup,
  __webpackgi_exports__MaterialLibraryBasePlugin as MaterialLibraryBasePlugin,
  __webpackgi_exports__MaterialLibraryPlugin as MaterialLibraryPlugin,
  __webpackgi_exports__MaterialLoader as MaterialLoader,
  __webpackgi_exports__MaterialManager as MaterialManager,
  __webpackgi_exports__MaterialPreviewGenerator as MaterialPreviewGenerator,
  __webpackgi_exports__MathUtils as MathUtils,
  __webpackgi_exports__Matrix3 as Matrix3,
  __webpackgi_exports__Matrix4 as Matrix4,
  __webpackgi_exports__MaxEquation as MaxEquation,
  __webpackgi_exports__Mesh as Mesh,
  __webpackgi_exports__MeshBasicMaterial as MeshBasicMaterial,
  __webpackgi_exports__MeshBasicMaterial2 as MeshBasicMaterial2,
  __webpackgi_exports__MeshDepthMaterial as MeshDepthMaterial,
  __webpackgi_exports__MeshDistanceMaterial as MeshDistanceMaterial,
  __webpackgi_exports__MeshLambertMaterial as MeshLambertMaterial,
  __webpackgi_exports__MeshMatcapMaterial as MeshMatcapMaterial,
  __webpackgi_exports__MeshNormalMaterial as MeshNormalMaterial,
  __webpackgi_exports__MeshOptSimplifyModifierPlugin as MeshOptSimplifyModifierPlugin,
  __webpackgi_exports__MeshPhongMaterial as MeshPhongMaterial,
  __webpackgi_exports__MeshPhysicalMaterial as MeshPhysicalMaterial,
  __webpackgi_exports__MeshStandardMaterial as MeshStandardMaterial,
  __webpackgi_exports__MeshStandardMaterial2 as MeshStandardMaterial2,
  __webpackgi_exports__MeshToonMaterial as MeshToonMaterial,
  __webpackgi_exports__MinEquation as MinEquation,
  __webpackgi_exports__MirroredRepeatWrapping as MirroredRepeatWrapping,
  __webpackgi_exports__MixOperation as MixOperation,
  __webpackgi_exports__MouseInputDevice as MouseInputDevice,
  __webpackgi_exports__MultiFilterPlugin as MultiFilterPlugin,
  __webpackgi_exports__MultiplyBlending as MultiplyBlending,
  __webpackgi_exports__MultiplyOperation as MultiplyOperation,
  __webpackgi_exports__NearestFilter as NearestFilter,
  __webpackgi_exports__NearestMipMapLinearFilter as NearestMipMapLinearFilter,
  __webpackgi_exports__NearestMipMapNearestFilter as NearestMipMapNearestFilter,
  __webpackgi_exports__NearestMipmapLinearFilter as NearestMipmapLinearFilter,
  __webpackgi_exports__NearestMipmapNearestFilter as NearestMipmapNearestFilter,
  __webpackgi_exports__NeverCompare as NeverCompare,
  __webpackgi_exports__NeverDepth as NeverDepth,
  __webpackgi_exports__NeverStencilFunc as NeverStencilFunc,
  __webpackgi_exports__NoBlending as NoBlending,
  __webpackgi_exports__NoColorSpace as NoColorSpace,
  __webpackgi_exports__NoToneMapping as NoToneMapping,
  __webpackgi_exports__NoiseBumpMaterialPlugin as NoiseBumpMaterialPlugin,
  __webpackgi_exports__NormalAnimationBlendMode as NormalAnimationBlendMode,
  __webpackgi_exports__NormalBlending as NormalBlending,
  __webpackgi_exports__NormalBufferPlugin as NormalBufferPlugin,
  __webpackgi_exports__NormalCaptureMaterial as NormalCaptureMaterial,
  __webpackgi_exports__NotEqualCompare as NotEqualCompare,
  __webpackgi_exports__NotEqualDepth as NotEqualDepth,
  __webpackgi_exports__NotEqualStencilFunc as NotEqualStencilFunc,
  __webpackgi_exports__NumberKeyframeTrack as NumberKeyframeTrack,
  __webpackgi_exports__OBJLoader2 as OBJLoader2,
  __webpackgi_exports__ObjMtlLoadPlugin as ObjMtlLoadPlugin,
  __webpackgi_exports__Object3D as Object3D,
  __webpackgi_exports__Object3DModel as Object3DModel,
  __webpackgi_exports__Object3DWidgetsPlugin as Object3DWidgetsPlugin,
  __webpackgi_exports__ObjectLoader as ObjectLoader,
  __webpackgi_exports__ObjectLoader2 as ObjectLoader2,
  __webpackgi_exports__ObjectPicker as ObjectPicker,
  __webpackgi_exports__ObjectProcessorMap as ObjectProcessorMap,
  __webpackgi_exports__ObjectRotationPlugin as ObjectRotationPlugin,
  __webpackgi_exports__ObjectSpaceNormalMap as ObjectSpaceNormalMap,
  __webpackgi_exports__OctahedronBufferGeometry as OctahedronBufferGeometry,
  __webpackgi_exports__OctahedronGeometry as OctahedronGeometry,
  __webpackgi_exports__OneFactor as OneFactor,
  __webpackgi_exports__OneMinusDstAlphaFactor as OneMinusDstAlphaFactor,
  __webpackgi_exports__OneMinusDstColorFactor as OneMinusDstColorFactor,
  __webpackgi_exports__OneMinusSrcAlphaFactor as OneMinusSrcAlphaFactor,
  __webpackgi_exports__OneMinusSrcColorFactor as OneMinusSrcColorFactor,
  __webpackgi_exports__OrbitControls2 as OrbitControls2,
  __webpackgi_exports__OrbitControls3 as OrbitControls3,
  __webpackgi_exports__OrthographicCamera as OrthographicCamera,
  __webpackgi_exports__OutlinePlugin as OutlinePlugin,
  __webpackgi_exports__PCFShadowMap as PCFShadowMap,
  __webpackgi_exports__PCFSoftShadowMap as PCFSoftShadowMap,
  __webpackgi_exports__PMREMGenerator as PMREMGenerator,
  __webpackgi_exports__PMREMGeneratorPlugin as PMREMGeneratorPlugin,
  __webpackgi_exports__ParallaxCameraControllerPlugin as ParallaxCameraControllerPlugin,
  __webpackgi_exports__ParallaxMappingPlugin as ParallaxMappingPlugin,
  __webpackgi_exports__Path as Path,
  __webpackgi_exports__PerspectiveCamera as PerspectiveCamera,
  __webpackgi_exports__PickingPlugin as PickingPlugin,
  __webpackgi_exports__Plane as Plane,
  __webpackgi_exports__PlaneBufferGeometry as PlaneBufferGeometry,
  __webpackgi_exports__PlaneGeometry as PlaneGeometry,
  __webpackgi_exports__PlaneHelper as PlaneHelper,
  __webpackgi_exports__PluginPresetGroup as PluginPresetGroup,
  __webpackgi_exports__PointLight as PointLight,
  __webpackgi_exports__PointLight2 as PointLight2,
  __webpackgi_exports__PointLightHelper as PointLightHelper,
  __webpackgi_exports__PointerDragHelper as PointerDragHelper,
  __webpackgi_exports__PointerLockControls2 as PointerLockControls2,
  __webpackgi_exports__PointerLockControlsPlugin as PointerLockControlsPlugin,
  __webpackgi_exports__Points as Points,
  __webpackgi_exports__PointsMaterial as PointsMaterial,
  __webpackgi_exports__PolarGridHelper as PolarGridHelper,
  __webpackgi_exports__PolyhedronBufferGeometry as PolyhedronBufferGeometry,
  __webpackgi_exports__PolyhedronGeometry as PolyhedronGeometry,
  __webpackgi_exports__PopmotionPlugin as PopmotionPlugin,
  __webpackgi_exports__PositionalAudio as PositionalAudio,
  __webpackgi_exports__PresetGroup as PresetGroup,
  __webpackgi_exports__PresetLibraryPlugin as PresetLibraryPlugin,
  __webpackgi_exports__ProgressivePlugin as ProgressivePlugin,
  __webpackgi_exports__PropertyBinding as PropertyBinding,
  __webpackgi_exports__PropertyMixer as PropertyMixer,
  __webpackgi_exports__QuadraticBezierCurve as QuadraticBezierCurve,
  __webpackgi_exports__QuadraticBezierCurve3 as QuadraticBezierCurve3,
  __webpackgi_exports__Quaternion as Quaternion,
  __webpackgi_exports__QuaternionKeyframeTrack as QuaternionKeyframeTrack,
  __webpackgi_exports__QuaternionLinearInterpolant as QuaternionLinearInterpolant,
  __webpackgi_exports__RED_GREEN_RGTC2_Format as RED_GREEN_RGTC2_Format,
  __webpackgi_exports__RED_RGTC1_Format as RED_RGTC1_Format,
  __webpackgi_exports__REVISION as REVISION,
  __webpackgi_exports__RGBADepthPacking as RGBADepthPacking,
  __webpackgi_exports__RGBAFormat as RGBAFormat,
  __webpackgi_exports__RGBAIntegerFormat as RGBAIntegerFormat,
  __webpackgi_exports__RGBA_ASTC_10x10_Format as RGBA_ASTC_10x10_Format,
  __webpackgi_exports__RGBA_ASTC_10x5_Format as RGBA_ASTC_10x5_Format,
  __webpackgi_exports__RGBA_ASTC_10x6_Format as RGBA_ASTC_10x6_Format,
  __webpackgi_exports__RGBA_ASTC_10x8_Format as RGBA_ASTC_10x8_Format,
  __webpackgi_exports__RGBA_ASTC_12x10_Format as RGBA_ASTC_12x10_Format,
  __webpackgi_exports__RGBA_ASTC_12x12_Format as RGBA_ASTC_12x12_Format,
  __webpackgi_exports__RGBA_ASTC_4x4_Format as RGBA_ASTC_4x4_Format,
  __webpackgi_exports__RGBA_ASTC_5x4_Format as RGBA_ASTC_5x4_Format,
  __webpackgi_exports__RGBA_ASTC_5x5_Format as RGBA_ASTC_5x5_Format,
  __webpackgi_exports__RGBA_ASTC_6x5_Format as RGBA_ASTC_6x5_Format,
  __webpackgi_exports__RGBA_ASTC_6x6_Format as RGBA_ASTC_6x6_Format,
  __webpackgi_exports__RGBA_ASTC_8x5_Format as RGBA_ASTC_8x5_Format,
  __webpackgi_exports__RGBA_ASTC_8x6_Format as RGBA_ASTC_8x6_Format,
  __webpackgi_exports__RGBA_ASTC_8x8_Format as RGBA_ASTC_8x8_Format,
  __webpackgi_exports__RGBA_BPTC_Format as RGBA_BPTC_Format,
  __webpackgi_exports__RGBA_ETC2_EAC_Format as RGBA_ETC2_EAC_Format,
  __webpackgi_exports__RGBA_PVRTC_2BPPV1_Format as RGBA_PVRTC_2BPPV1_Format,
  __webpackgi_exports__RGBA_PVRTC_4BPPV1_Format as RGBA_PVRTC_4BPPV1_Format,
  __webpackgi_exports__RGBA_S3TC_DXT1_Format as RGBA_S3TC_DXT1_Format,
  __webpackgi_exports__RGBA_S3TC_DXT3_Format as RGBA_S3TC_DXT3_Format,
  __webpackgi_exports__RGBA_S3TC_DXT5_Format as RGBA_S3TC_DXT5_Format,
  __webpackgi_exports__RGBM16ColorSpace as RGBM16ColorSpace,
  __webpackgi_exports__RGBM16ColorSpace_ as RGBM16ColorSpace_,
  __webpackgi_exports__RGB_ETC1_Format as RGB_ETC1_Format,
  __webpackgi_exports__RGB_ETC2_Format as RGB_ETC2_Format,
  __webpackgi_exports__RGB_PVRTC_2BPPV1_Format as RGB_PVRTC_2BPPV1_Format,
  __webpackgi_exports__RGB_PVRTC_4BPPV1_Format as RGB_PVRTC_4BPPV1_Format,
  __webpackgi_exports__RGB_S3TC_DXT1_Format as RGB_S3TC_DXT1_Format,
  __webpackgi_exports__RGFormat as RGFormat,
  __webpackgi_exports__RGIntegerFormat as RGIntegerFormat,
  __webpackgi_exports__RainbowDiamondPlugin as RainbowDiamondPlugin,
  __webpackgi_exports__RandomizedDirectionalLight as RandomizedDirectionalLight,
  __webpackgi_exports__RandomizedDirectionalLightPlugin as RandomizedDirectionalLightPlugin,
  __webpackgi_exports__RawShaderMaterial as RawShaderMaterial,
  __webpackgi_exports__Ray as Ray,
  __webpackgi_exports__Raycaster as Raycaster,
  __webpackgi_exports__RectAreaLight as RectAreaLight,
  __webpackgi_exports__RedFormat as RedFormat,
  __webpackgi_exports__RedIntegerFormat as RedIntegerFormat,
  __webpackgi_exports__Reflector2 as Reflector2,
  __webpackgi_exports__ReinhardToneMapping as ReinhardToneMapping,
  __webpackgi_exports__RendererUiPlugin as RendererUiPlugin,
  __webpackgi_exports__RepeatWrapping as RepeatWrapping,
  __webpackgi_exports__ReplaceStencilOp as ReplaceStencilOp,
  __webpackgi_exports__ReverseSubtractEquation as ReverseSubtractEquation,
  __webpackgi_exports__Rhino3dmLoadPlugin as Rhino3dmLoadPlugin,
  __webpackgi_exports__Rhino3dmLoader2 as Rhino3dmLoader2,
  __webpackgi_exports__RingBufferGeometry as RingBufferGeometry,
  __webpackgi_exports__RingGeometry as RingGeometry,
  __webpackgi_exports__RootScene as RootScene,
  __webpackgi_exports__SIGNED_RED_GREEN_RGTC2_Format as SIGNED_RED_GREEN_RGTC2_Format,
  __webpackgi_exports__SIGNED_RED_RGTC1_Format as SIGNED_RED_RGTC1_Format,
  __webpackgi_exports__SRGBColorSpace as SRGBColorSpace,
  __webpackgi_exports__SSAOPlugin as SSAOPlugin,
  __webpackgi_exports__SSBevelPass as SSBevelPass,
  __webpackgi_exports__SSBevelPlugin as SSBevelPlugin,
  __webpackgi_exports__SSContactShadows as SSContactShadows,
  __webpackgi_exports__SSGIPlugin as SSGIPlugin,
  __webpackgi_exports__SSRPlugin as SSRPlugin,
  __webpackgi_exports__STLLoadPlugin as STLLoadPlugin,
  __webpackgi_exports__Scene as Scene,
  __webpackgi_exports__SceneCamerasUiPlugin as SceneCamerasUiPlugin,
  __webpackgi_exports__SceneLoopPlugin as SceneLoopPlugin,
  __webpackgi_exports__ScrollableCameraViewPlugin as ScrollableCameraViewPlugin,
  __webpackgi_exports__ScrollableCameraViewPreviewPlugin as ScrollableCameraViewPreviewPlugin,
  __webpackgi_exports__SelectionWidget as SelectionWidget,
  __webpackgi_exports__ShaderChunk as ShaderChunk,
  __webpackgi_exports__ShaderLib as ShaderLib,
  __webpackgi_exports__ShaderMaterial as ShaderMaterial,
  __webpackgi_exports__ShaderMaterial2 as ShaderMaterial2,
  __webpackgi_exports__ShaderMaterialEncodingSupport as ShaderMaterialEncodingSupport,
  __webpackgi_exports__ShaderPass2 as ShaderPass2,
  __webpackgi_exports__ShadowMapBaker as ShadowMapBaker,
  __webpackgi_exports__ShadowMaterial as ShadowMaterial,
  __webpackgi_exports__Shape as Shape,
  __webpackgi_exports__ShapeBufferGeometry as ShapeBufferGeometry,
  __webpackgi_exports__ShapeGeometry as ShapeGeometry,
  __webpackgi_exports__ShapePath as ShapePath,
  __webpackgi_exports__ShapeTubeExtrudePlugin as ShapeTubeExtrudePlugin,
  __webpackgi_exports__ShapeUtils as ShapeUtils,
  __webpackgi_exports__ShortType as ShortType,
  __webpackgi_exports__SimpleAssetList as SimpleAssetList,
  __webpackgi_exports__SimpleBackgroundEnvUiPlugin as SimpleBackgroundEnvUiPlugin,
  __webpackgi_exports__SimpleDataSource as SimpleDataSource,
  __webpackgi_exports__SimpleEventDispatcher as SimpleEventDispatcher,
  __webpackgi_exports__SimpleJSONExporter as SimpleJSONExporter,
  __webpackgi_exports__SimpleJSONLoader as SimpleJSONLoader,
  __webpackgi_exports__SimpleTextExporter as SimpleTextExporter,
  __webpackgi_exports__SimpleTextPlugin as SimpleTextPlugin,
  __webpackgi_exports__SimpleViewerUi as SimpleViewerUi,
  __webpackgi_exports__SimplifyModifierPlugin as SimplifyModifierPlugin,
  __webpackgi_exports__Skeleton as Skeleton,
  __webpackgi_exports__SkeletonHelper as SkeletonHelper,
  __webpackgi_exports__SkinnedMesh as SkinnedMesh,
  __webpackgi_exports__Source as Source,
  __webpackgi_exports__Sphere as Sphere,
  __webpackgi_exports__SphereBufferGeometry as SphereBufferGeometry,
  __webpackgi_exports__SphereGeometry as SphereGeometry,
  __webpackgi_exports__SphereSelectionWidget as SphereSelectionWidget,
  __webpackgi_exports__Spherical as Spherical,
  __webpackgi_exports__SphericalHarmonics3 as SphericalHarmonics3,
  __webpackgi_exports__SplineCurve as SplineCurve,
  __webpackgi_exports__SpotLight as SpotLight,
  __webpackgi_exports__SpotLight2 as SpotLight2,
  __webpackgi_exports__SpotLightHelper as SpotLightHelper,
  __webpackgi_exports__Sprite as Sprite,
  __webpackgi_exports__SpriteMaterial as SpriteMaterial,
  __webpackgi_exports__SrcAlphaFactor as SrcAlphaFactor,
  __webpackgi_exports__SrcAlphaSaturateFactor as SrcAlphaSaturateFactor,
  __webpackgi_exports__SrcColorFactor as SrcColorFactor,
  __webpackgi_exports__StaticCopyUsage as StaticCopyUsage,
  __webpackgi_exports__StaticDrawUsage as StaticDrawUsage,
  __webpackgi_exports__StaticReadUsage as StaticReadUsage,
  __webpackgi_exports__StereoCamera as StereoCamera,
  __webpackgi_exports__StreamCopyUsage as StreamCopyUsage,
  __webpackgi_exports__StreamDrawUsage as StreamDrawUsage,
  __webpackgi_exports__StreamReadUsage as StreamReadUsage,
  __webpackgi_exports__StringKeyframeTrack as StringKeyframeTrack,
  __webpackgi_exports__SubtractEquation as SubtractEquation,
  __webpackgi_exports__SubtractiveBlending as SubtractiveBlending,
  __webpackgi_exports__SwitchNodeBasePlugin as SwitchNodeBasePlugin,
  __webpackgi_exports__SwitchNodePlugin as SwitchNodePlugin,
  __webpackgi_exports__TOUCH as TOUCH,
  __webpackgi_exports__TYPED_ARRAYS as TYPED_ARRAYS,
  __webpackgi_exports__TangentSpaceNormalMap as TangentSpaceNormalMap,
  __webpackgi_exports__TemporalAAPlugin as TemporalAAPlugin,
  __webpackgi_exports__TetrahedronBufferGeometry as TetrahedronBufferGeometry,
  __webpackgi_exports__TetrahedronGeometry as TetrahedronGeometry,
  __webpackgi_exports__TextSVGOptions as TextSVGOptions,
  __webpackgi_exports__Texture as Texture,
  __webpackgi_exports__TextureLoader as TextureLoader,
  __webpackgi_exports__ThinFilmLayerPlugin as ThinFilmLayerPlugin,
  __webpackgi_exports__ThreeMaterialLoader as ThreeMaterialLoader,
  __webpackgi_exports__TonemapPlugin as TonemapPlugin,
  __webpackgi_exports__TorusBufferGeometry as TorusBufferGeometry,
  __webpackgi_exports__TorusGeometry as TorusGeometry,
  __webpackgi_exports__TorusKnotBufferGeometry as TorusKnotBufferGeometry,
  __webpackgi_exports__TorusKnotGeometry as TorusKnotGeometry,
  __webpackgi_exports__TrackballControlsPlugin as TrackballControlsPlugin,
  __webpackgi_exports__TransformAnimationPlugin as TransformAnimationPlugin,
  __webpackgi_exports__TransformControls2 as TransformControls2,
  __webpackgi_exports__TransfrSharePlugin as TransfrSharePlugin,
  __webpackgi_exports__Triangle as Triangle,
  __webpackgi_exports__TriangleFanDrawMode as TriangleFanDrawMode,
  __webpackgi_exports__TriangleStripDrawMode as TriangleStripDrawMode,
  __webpackgi_exports__TrianglesDrawMode as TrianglesDrawMode,
  __webpackgi_exports__TriplanarUVMappingPlugin as TriplanarUVMappingPlugin,
  __webpackgi_exports__TubeBufferGeometry as TubeBufferGeometry,
  __webpackgi_exports__TubeGeometry as TubeGeometry,
  __webpackgi_exports__TubeShapeGeometry as TubeShapeGeometry,
  __webpackgi_exports__TweakpaneUiPlugin as TweakpaneUiPlugin,
  __webpackgi_exports__TweakpaneWrapper as TweakpaneWrapper,
  __webpackgi_exports__TwoPassDoubleSide as TwoPassDoubleSide,
  __webpackgi_exports__UChartOptions as UChartOptions,
  __webpackgi_exports__UPackOptions as UPackOptions,
  __webpackgi_exports__UVMapping as UVMapping,
  __webpackgi_exports__Uint16BufferAttribute as Uint16BufferAttribute,
  __webpackgi_exports__Uint32BufferAttribute as Uint32BufferAttribute,
  __webpackgi_exports__Uint8BufferAttribute as Uint8BufferAttribute,
  __webpackgi_exports__Uint8ClampedBufferAttribute as Uint8ClampedBufferAttribute,
  __webpackgi_exports__Uncharted2Tonemapping as Uncharted2Tonemapping,
  __webpackgi_exports__Uniform as Uniform,
  __webpackgi_exports__UniformsGroup as UniformsGroup,
  __webpackgi_exports__UniformsLib as UniformsLib,
  __webpackgi_exports__UniformsUtils as UniformsUtils,
  __webpackgi_exports__UnsignedByteType as UnsignedByteType,
  __webpackgi_exports__UnsignedInt248Type as UnsignedInt248Type,
  __webpackgi_exports__UnsignedIntType as UnsignedIntType,
  __webpackgi_exports__UnsignedShort4444Type as UnsignedShort4444Type,
  __webpackgi_exports__UnsignedShort5551Type as UnsignedShort5551Type,
  __webpackgi_exports__UnsignedShortType as UnsignedShortType,
  __webpackgi_exports__Unzip as Unzip,
  __webpackgi_exports__UnzipInflate as UnzipInflate,
  __webpackgi_exports__UnzipPassThrough as UnzipPassThrough,
  __webpackgi_exports__Unzlib as Unzlib,
  __webpackgi_exports__VJSONPresetGroup as VJSONPresetGroup,
  __webpackgi_exports__VRPluginBasic as VRPluginBasic,
  __webpackgi_exports__VSMShadowMap as VSMShadowMap,
  __webpackgi_exports__VariationConfiguratorEditorUiPlugin as VariationConfiguratorEditorUiPlugin,
  __webpackgi_exports__VariationConfiguratorGridUiPlugin as VariationConfiguratorGridUiPlugin,
  __webpackgi_exports__VariationConfiguratorPlugin as VariationConfiguratorPlugin,
  __webpackgi_exports__Vector2 as Vector2,
  __webpackgi_exports__Vector3 as Vector3,
  __webpackgi_exports__Vector4 as Vector4,
  __webpackgi_exports__VectorKeyframeTrack as VectorKeyframeTrack,
  __webpackgi_exports__VelocityBufferPlugin as VelocityBufferPlugin,
  __webpackgi_exports__VideoTexture as VideoTexture,
  __webpackgi_exports__ViewerApp as ViewerApp,
  __webpackgi_exports__ViewerState as ViewerState,
  __webpackgi_exports__VignettePlugin as VignettePlugin,
  __webpackgi_exports__VirtualCamerasPlugin as VirtualCamerasPlugin,
  __webpackgi_exports__WebGL1Renderer as WebGL1Renderer,
  __webpackgi_exports__WebGL3DRenderTarget as WebGL3DRenderTarget,
  __webpackgi_exports__WebGLArrayRenderTarget as WebGLArrayRenderTarget,
  __webpackgi_exports__WebGLCoordinateSystem as WebGLCoordinateSystem,
  __webpackgi_exports__WebGLCubeRenderTarget as WebGLCubeRenderTarget,
  __webpackgi_exports__WebGLMultipleRenderTargets as WebGLMultipleRenderTargets,
  __webpackgi_exports__WebGLRenderTarget as WebGLRenderTarget,
  __webpackgi_exports__WebGLRenderer as WebGLRenderer,
  __webpackgi_exports__WebGLUtils as WebGLUtils,
  __webpackgi_exports__WebGPUCoordinateSystem as WebGPUCoordinateSystem,
  __webpackgi_exports__WebGiViewerElement as WebGiViewerElement,
  __webpackgi_exports__WindowiseDialogPlugin as WindowiseDialogPlugin,
  __webpackgi_exports__Wireframe as Wireframe,
  __webpackgi_exports__WireframeGeometry as WireframeGeometry,
  __webpackgi_exports__WireframeGeometry2 as WireframeGeometry2,
  __webpackgi_exports__WrapAroundEnding as WrapAroundEnding,
  __webpackgi_exports__XAtlasPlugin as XAtlasPlugin,
  __webpackgi_exports__ZeroCurvatureEnding as ZeroCurvatureEnding,
  __webpackgi_exports__ZeroFactor as ZeroFactor,
  __webpackgi_exports__ZeroSlopeEnding as ZeroSlopeEnding,
  __webpackgi_exports__ZeroStencilOp as ZeroStencilOp,
  __webpackgi_exports__Zip as Zip,
  __webpackgi_exports__ZipDeflate as ZipDeflate,
  __webpackgi_exports__ZipLoader as ZipLoader,
  __webpackgi_exports__ZipPassThrough as ZipPassThrough,
  __webpackgi_exports__Zlib as Zlib,
  __webpackgi_exports___SRGBAFormat as _SRGBAFormat,
  __webpackgi_exports__absMax as absMax,
  __webpackgi_exports__addBasePlugins as addBasePlugins,
  __webpackgi_exports__addBloomData as addBloomData,
  __webpackgi_exports__addDracoLoader as addDracoLoader,
  __webpackgi_exports__addEditorPlugins as addEditorPlugins,
  __webpackgi_exports__addGLTFExporter as addGLTFExporter,
  __webpackgi_exports__addGLTFLoader as addGLTFLoader,
  __webpackgi_exports__addLUTData as addLUTData,
  __webpackgi_exports__addRGBELoader as addRGBELoader,
  __webpackgi_exports__addSSBevel as addSSBevel,
  __webpackgi_exports__aesGcmDecrypt as aesGcmDecrypt,
  __webpackgi_exports__aesGcmEncrypt as aesGcmEncrypt,
  __webpackgi_exports__afterMain as afterMain,
  __webpackgi_exports__afterRead as afterRead,
  __webpackgi_exports__afterWrite as afterWrite,
  __webpackgi_exports__angle as angle,
  __webpackgi_exports__animate as animate,
  __webpackgi_exports__animateAsync as animateAsync,
  __webpackgi_exports__animateObject as animateObject,
  __webpackgi_exports__animateSet as animateSet,
  __webpackgi_exports__animateTarget as animateTarget,
  __webpackgi_exports__anticipate as anticipate,
  __webpackgi_exports__applyOffset as applyOffset,
  __webpackgi_exports__applyStyles as applyStyles,
  __webpackgi_exports__arrayBufferToBase64 as arrayBufferToBase64,
  __webpackgi_exports__arrow as arrow,
  __webpackgi_exports__attract as attract,
  __webpackgi_exports__attractExpo as attractExpo,
  __webpackgi_exports__auto as auto,
  __webpackgi_exports__autoCenterObject3D as autoCenterObject3D,
  __webpackgi_exports__autoGPUInstanceMeshes as autoGPUInstanceMeshes,
  __webpackgi_exports__autoScaleObject3D as autoScaleObject3D,
  __webpackgi_exports__backIn as backIn,
  __webpackgi_exports__backInOut as backInOut,
  __webpackgi_exports__backOut as backOut,
  __webpackgi_exports__base64ToArrayBuffer as base64ToArrayBuffer,
  __webpackgi_exports__basePlacements as basePlacements,
  __webpackgi_exports__basicMaterialPropList as basicMaterialPropList,
  __webpackgi_exports__beforeMain as beforeMain,
  __webpackgi_exports__beforeRead as beforeRead,
  __webpackgi_exports__beforeWrite as beforeWrite,
  __webpackgi_exports__blobToDataURL as blobToDataURL,
  __webpackgi_exports__bottom as bottom,
  __webpackgi_exports__bounceIn as bounceIn,
  __webpackgi_exports__bounceInOut as bounceInOut,
  __webpackgi_exports__bounceOut as bounceOut,
  __webpackgi_exports__buildCSGMeshBSP as buildCSGMeshBSP,
  __webpackgi_exports__buildCSGMeshBVH as buildCSGMeshBVH,
  __webpackgi_exports__cLinearToRGBM as cLinearToRGBM,
  __webpackgi_exports__cRGBMToLinear as cRGBMToLinear,
  __webpackgi_exports__circIn as circIn,
  __webpackgi_exports__circInOut as circInOut,
  __webpackgi_exports__circOut as circOut,
  __webpackgi_exports__clamp as clamp,
  __webpackgi_exports__clippingParents as clippingParents,
  __webpackgi_exports__colorToDataUrl as colorToDataUrl,
  __webpackgi_exports__combineDofShader as combineDofShader,
  __webpackgi_exports__compress as compress,
  __webpackgi_exports__compressSync as compressSync,
  __webpackgi_exports__computeAverageGeometryNormal as computeAverageGeometryNormal,
  __webpackgi_exports__computeEigenVectors as computeEigenVectors,
  __webpackgi_exports__computeGeometryCenter as computeGeometryCenter,
  __webpackgi_exports__computeGeometrySize as computeGeometrySize,
  __webpackgi_exports__computeMikkTSpaceTangents as computeMikkTSpaceTangents,
  __webpackgi_exports__computeMorphedAttributes as computeMorphedAttributes,
  __webpackgi_exports__computeOffsetMatrix as computeOffsetMatrix,
  __webpackgi_exports__computeScreenSpaceBoundingBox as computeScreenSpaceBoundingBox,
  __webpackgi_exports__computeStyles as computeStyles,
  __webpackgi_exports__copyMaterialUserData as copyMaterialUserData,
  __webpackgi_exports__copyObject3DUserData as copyObject3DUserData,
  __webpackgi_exports__copyProps as copyProps,
  __webpackgi_exports__copyTextureUserData as copyTextureUserData,
  __webpackgi_exports__createAnticipate as createAnticipate,
  __webpackgi_exports__createAttractor as createAttractor,
  __webpackgi_exports__createBackIn as createBackIn,
  __webpackgi_exports__createCanvasElement as createCanvasElement,
  __webpackgi_exports__createDiv as createDiv,
  __webpackgi_exports__createExpoIn as createExpoIn,
  __webpackgi_exports__createGenericExtensionClass as createGenericExtensionClass,
  __webpackgi_exports__createIFrameCSS3DObject as createIFrameCSS3DObject,
  __webpackgi_exports__createImage as createImage,
  __webpackgi_exports__createPopper as createPopper,
  __webpackgi_exports__createPopperBase as createPopperBase,
  __webpackgi_exports__createPopperLite as createPopperLite,
  __webpackgi_exports__createRenderTargetKey as createRenderTargetKey,
  __webpackgi_exports__createScriptFromURL as createScriptFromURL,
  __webpackgi_exports__createStyles as createStyles,
  __webpackgi_exports__csgOperations as csgOperations,
  __webpackgi_exports__css as css,
  __webpackgi_exports__cubicBezier as cubicBezier,
  __webpackgi_exports__dataTextureFromColor as dataTextureFromColor,
  __webpackgi_exports__dataTextureFromVec4 as dataTextureFromVec4,
  __webpackgi_exports__decay as decay,
  __webpackgi_exports__decompress as decompress,
  __webpackgi_exports__decompressSync as decompressSync,
  __webpackgi_exports__deepAccessObject as deepAccessObject,
  __webpackgi_exports__deepCloneAttribute as deepCloneAttribute,
  __webpackgi_exports__defaultPresets as defaultPresets,
  __webpackgi_exports__deflate as deflate,
  __webpackgi_exports__deflateSync as deflateSync,
  __webpackgi_exports__degreesToRadians as degreesToRadians,
  __webpackgi_exports__deinterleaveAttribute as deinterleaveAttribute,
  __webpackgi_exports__deinterleaveGeometry as deinterleaveGeometry,
  __webpackgi_exports__deserializeObject as deserializeObject,
  __webpackgi_exports__deserializers as deserializers,
  __webpackgi_exports__detectOverflow as detectOverflow,
  __webpackgi_exports__diamondMaterialPropList as diamondMaterialPropList,
  __webpackgi_exports__distance as distance,
  __webpackgi_exports__downloadBlob as downloadBlob,
  __webpackgi_exports__downloadFile as downloadFile,
  __webpackgi_exports__easeIn as easeIn,
  __webpackgi_exports__easeInOut as easeInOut,
  __webpackgi_exports__easeOut as easeOut,
  __webpackgi_exports__embedUrlRefs as embedUrlRefs,
  __webpackgi_exports__end as end,
  __webpackgi_exports__envMapBackground as envMapBackground,
  __webpackgi_exports__escapeRegExp as escapeRegExp,
  __webpackgi_exports__estimateBytesUsed as estimateBytesUsed,
  __webpackgi_exports__eventListeners as eventListeners,
  __webpackgi_exports__extractAnimationKey as extractAnimationKey,
  __webpackgi_exports__flattenUiConfig as flattenUiConfig,
  __webpackgi_exports__flip as flip,
  __webpackgi_exports__fontFormatExtensionMap as fontFormatExtensionMap,
  __webpackgi_exports__generateUiConfig as generateUiConfig,
  __webpackgi_exports__generateUiFolder as generateUiFolder,
  __webpackgi_exports__getEncodingComponents as getEncodingComponents,
  __webpackgi_exports__getFileHandle as getFileHandle,
  __webpackgi_exports__getFilenameFromPath as getFilenameFromPath,
  __webpackgi_exports__getKeyByValue as getKeyByValue,
  __webpackgi_exports__getNewFileHandle as getNewFileHandle,
  __webpackgi_exports__getOrCall as getOrCall,
  __webpackgi_exports__getPropertyDescriptor as getPropertyDescriptor,
  __webpackgi_exports__getTexelDecoding as getTexelDecoding,
  __webpackgi_exports__getTexelDecoding2 as getTexelDecoding2,
  __webpackgi_exports__getTexelDecodingFunction as getTexelDecodingFunction,
  __webpackgi_exports__getTexelEncoding as getTexelEncoding,
  __webpackgi_exports__getTexelEncodingFunction as getTexelEncodingFunction,
  __webpackgi_exports__getTextureColorSpaceFromMap as getTextureColorSpaceFromMap,
  __webpackgi_exports__getTextureDataType as getTextureDataType,
  __webpackgi_exports__getTypedArray as getTypedArray,
  __webpackgi_exports__getUrlQueryParam as getUrlQueryParam,
  __webpackgi_exports__glbEncryptionPreparser as glbEncryptionPreparser,
  __webpackgi_exports__glsl as glsl,
  __webpackgi_exports__gltfExporterMaterialsVariantsExtensionExport as gltfExporterMaterialsVariantsExtensionExport,
  __webpackgi_exports__gunzip as gunzip,
  __webpackgi_exports__gunzipSync as gunzipSync,
  __webpackgi_exports__gzip as gzip,
  __webpackgi_exports__gzipSync as gzipSync,
  __webpackgi_exports__hide as hide,
  __webpackgi_exports__html as html,
  __webpackgi_exports__htmlToCanvas as htmlToCanvas,
  __webpackgi_exports__htmlToPng as htmlToPng,
  __webpackgi_exports__htmlToSvg as htmlToSvg,
  __webpackgi_exports__iGeometryIgnoredUserData as iGeometryIgnoredUserData,
  __webpackgi_exports__iMaterialIgnoredUserData as iMaterialIgnoredUserData,
  __webpackgi_exports__iModelIgnoredUserData as iModelIgnoredUserData,
  __webpackgi_exports__iTextureIgnoredUserData as iTextureIgnoredUserData,
  __webpackgi_exports__imageBitmapToBase64 as imageBitmapToBase64,
  __webpackgi_exports__imageDataToCanvas as imageDataToCanvas,
  __webpackgi_exports__imageToCanvas as imageToCanvas,
  __webpackgi_exports__imageUrlToImageData as imageUrlToImageData,
  __webpackgi_exports__includesAll as includesAll,
  __webpackgi_exports__inertia as inertia,
  __webpackgi_exports__inflate as inflate,
  __webpackgi_exports__inflateSync as inflateSync,
  __webpackgi_exports__interleaveAttributes as interleaveAttributes,
  __webpackgi_exports__interpolate as interpolate,
  __webpackgi_exports__isAnimatableType as isAnimatableType,
  __webpackgi_exports__isPoint as isPoint,
  __webpackgi_exports__isPoint3D as isPoint3D,
  __webpackgi_exports__isPropertyWritable as isPropertyWritable,
  __webpackgi_exports__keyframes as keyframes,
  __webpackgi_exports__khrMaterialsVariantsGLTF as khrMaterialsVariantsGLTF,
  __webpackgi_exports__left as left,
  __webpackgi_exports__lerpAngle as lerpAngle,
  __webpackgi_exports__lerpAngle2 as lerpAngle2,
  __webpackgi_exports__linear as linear,
  __webpackgi_exports__longestCommonPrefix as longestCommonPrefix,
  __webpackgi_exports__main as main,
  __webpackgi_exports__makeColorSvg as makeColorSvg,
  __webpackgi_exports__makeColorSvgCircle as makeColorSvgCircle,
  __webpackgi_exports__makeFilter as makeFilter,
  __webpackgi_exports__makeSamplerUi as makeSamplerUi,
  __webpackgi_exports__makeSetterFor as makeSetterFor,
  __webpackgi_exports__makeTextSvg as makeTextSvg,
  __webpackgi_exports__matDefine as matDefine,
  __webpackgi_exports__mergeAttributes as mergeAttributes,
  __webpackgi_exports__mergeBufferAttributes as mergeBufferAttributes,
  __webpackgi_exports__mergeBufferGeometries as mergeBufferGeometries,
  __webpackgi_exports__mergeGeometries as mergeGeometries,
  __webpackgi_exports__mergeGroups as mergeGroups,
  __webpackgi_exports__mergeVertices as mergeVertices,
  __webpackgi_exports__mirrorEasing as mirrorEasing,
  __webpackgi_exports__mix as mix,
  __webpackgi_exports__mixColor as mixColor,
  __webpackgi_exports__mixComplex as mixComplex,
  __webpackgi_exports__mobileAndTabletCheck as mobileAndTabletCheck,
  __webpackgi_exports__modifierPhases as modifierPhases,
  __webpackgi_exports__now as now,
  __webpackgi_exports__objectHasOwn as objectHasOwn,
  __webpackgi_exports__offset as offset,
  __webpackgi_exports__onChange as onChange,
  __webpackgi_exports__onChange2 as onChange2,
  __webpackgi_exports__onChange3 as onChange3,
  __webpackgi_exports__parseFileExtension as parseFileExtension,
  __webpackgi_exports__patchShaderEncodingSupport as patchShaderEncodingSupport,
  __webpackgi_exports__pathJoin as pathJoin,
  __webpackgi_exports__physicalMaterialPropList as physicalMaterialPropList,
  __webpackgi_exports__pipe as pipe,
  __webpackgi_exports__placements as placements,
  __webpackgi_exports__pointFromVector as pointFromVector,
  __webpackgi_exports__popper as popper,
  __webpackgi_exports__popperGenerator as popperGenerator,
  __webpackgi_exports__popperOffsets as popperOffsets,
  __webpackgi_exports__prettyScrollbar as prettyScrollbar,
  __webpackgi_exports__preventOverflow as preventOverflow,
  __webpackgi_exports__processViewer as processViewer,
  __webpackgi_exports__progress as progress,
  __webpackgi_exports__radiansToDegrees as radiansToDegrees,
  __webpackgi_exports__read as read,
  __webpackgi_exports__readFile as readFile,
  __webpackgi_exports__reference as reference,
  __webpackgi_exports__remoteWorkerURL as remoteWorkerURL,
  __webpackgi_exports__removeDuplicateGeometries as removeDuplicateGeometries,
  __webpackgi_exports__replaceAll as replaceAll,
  __webpackgi_exports__reverseEasing as reverseEasing,
  __webpackgi_exports__right as right,
  __webpackgi_exports__rotateDuplicatedMesh as rotateDuplicatedMesh,
  __webpackgi_exports__sRGBEncoding as sRGBEncoding,
  __webpackgi_exports__safeSetProperty as safeSetProperty,
  __webpackgi_exports__serializable as serializable,
  __webpackgi_exports__serialize as serialize,
  __webpackgi_exports__serializeObject as serializeObject,
  __webpackgi_exports__serializeTextureInExtras as serializeTextureInExtras,
  __webpackgi_exports__serializers as serializers,
  __webpackgi_exports__setMeshGeometry as setMeshGeometry,
  __webpackgi_exports__setMeshMaterial as setMeshMaterial,
  __webpackgi_exports__setThreeRendererMode as setThreeRendererMode,
  __webpackgi_exports__setUrlQueryParam as setUrlQueryParam,
  __webpackgi_exports__setupCoreWebGiViewer as setupCoreWebGiViewer,
  __webpackgi_exports__setupIModel as setupIModel,
  __webpackgi_exports__setupModesStyles as setupModesStyles,
  __webpackgi_exports__setupModesUi as setupModesUi,
  __webpackgi_exports__setupObject3dModel as setupObject3dModel,
  __webpackgi_exports__setupSandboxWebGiEditor as setupSandboxWebGiEditor,
  __webpackgi_exports__shaderReplaceString as shaderReplaceString,
  __webpackgi_exports__sign2 as sign2,
  __webpackgi_exports__slerp as slerp,
  __webpackgi_exports__smooth as smooth,
  __webpackgi_exports__smoothFrame as smoothFrame,
  __webpackgi_exports__snap as snap,
  __webpackgi_exports__snapObject as snapObject,
  __webpackgi_exports__sphericalFromObject as sphericalFromObject,
  __webpackgi_exports__spring as spring,
  __webpackgi_exports__standardMaterialPropList as standardMaterialPropList,
  __webpackgi_exports__start as start,
  __webpackgi_exports__steps as steps,
  __webpackgi_exports__strFromU8 as strFromU8,
  __webpackgi_exports__strToU8 as strToU8,
  __webpackgi_exports__supportsRequestStreams as supportsRequestStreams,
  __webpackgi_exports__svgToCanvas as svgToCanvas,
  __webpackgi_exports__svgToPng as svgToPng,
  __webpackgi_exports__svgUrl as svgUrl,
  __webpackgi_exports__texImageToCanvas as texImageToCanvas,
  __webpackgi_exports__textureDataToImageData as textureDataToImageData,
  __webpackgi_exports__textureToCanvas as textureToCanvas,
  __webpackgi_exports__textureToDataUrl as textureToDataUrl,
  __webpackgi_exports__timeout as timeout,
  __webpackgi_exports__toCreasedNormals as toCreasedNormals,
  __webpackgi_exports__toDecimal as toDecimal,
  __webpackgi_exports__toIndexedGeometry as toIndexedGeometry,
  __webpackgi_exports__toTitleCase as toTitleCase,
  __webpackgi_exports__toTrianglesDrawMode as toTrianglesDrawMode,
  __webpackgi_exports__top as top,
  __webpackgi_exports__uiButton as uiButton,
  __webpackgi_exports__uiColor as uiColor,
  __webpackgi_exports__uiConfig as uiConfig,
  __webpackgi_exports__uiDropdown as uiDropdown,
  __webpackgi_exports__uiFolder as uiFolder,
  __webpackgi_exports__uiImage as uiImage,
  __webpackgi_exports__uiInput as uiInput,
  __webpackgi_exports__uiMonitor as uiMonitor,
  __webpackgi_exports__uiPanel as uiPanel,
  __webpackgi_exports__uiSlider as uiSlider,
  __webpackgi_exports__uiToggle as uiToggle,
  __webpackgi_exports__uiVector as uiVector,
  __webpackgi_exports__uniform as uniform,
  __webpackgi_exports__unzip as unzip,
  __webpackgi_exports__unzipSync as unzipSync,
  __webpackgi_exports__unzlib as unzlib,
  __webpackgi_exports__unzlibSync as unzlibSync,
  __webpackgi_exports__uploadFile as uploadFile,
  __webpackgi_exports__vLinearToRGBM as vLinearToRGBM,
  __webpackgi_exports__vRGBMToLinear as vRGBMToLinear,
  __webpackgi_exports__valueToUiType as valueToUiType,
  __webpackgi_exports__variationPlacements as variationPlacements,
  __webpackgi_exports__velocityPerFrame as velocityPerFrame,
  __webpackgi_exports__velocityPerSecond as velocityPerSecond,
  __webpackgi_exports__verifyPermission as verifyPermission,
  __webpackgi_exports__viewerGLTFExtension as viewerGLTFExtension,
  __webpackgi_exports__viewport as viewport,
  __webpackgi_exports__webgiLightExtrasExtension as webgiLightExtrasExtension,
  __webpackgi_exports__webgiMaterialExtrasExtension as webgiMaterialExtrasExtension,
  __webpackgi_exports__webgiObject3DExtrasExtension as webgiObject3DExtrasExtension,
  __webpackgi_exports__wrap as wrap,
  __webpackgi_exports__write as write,
  __webpackgi_exports__writeFile as writeFile,
  __webpackgi_exports__zip as zip,
  __webpackgi_exports__zipSync as zipSync,
  __webpackgi_exports__zlib as zlib,
  __webpackgi_exports__zlibSync as zlibSync
};
/*! Bundled license information:

webgi/dist/examples/runtime/bundle.m.js:
  (*! For license information please see bundle.m.js.LICENSE.txt *)
*/
//# sourceMappingURL=webgi.js.map
